        try:
            # call the matching registered function
            func = self.funcs[method]
        except KeyError:
            pass
        else:
            if func is not None:
                return func(*params)
            raise Exception('method "%s" is not supported' % method)

        if self.instance is not None:
            if hasattr(self.instance, '_dispatch'):
                # call the `_dispatch` method on the instance
                return self.instance._dispatch(method, params)

            # call the instance's method directly
            try:
                func = resolve_dotted_attribute(
                    self.instance,
                    method,
                    self.allow_dotted_names
                )
            except AttributeError:
                pass
            else:
                if func is not None:
                    return func(*params)

        raise Exception('method "%s" is not supported' % method)

class SimpleXMLRPCRequestHandler(BaseHTTPRequestHandler):
    """Simple XML-RPC request handler class.

    Handles all HTTP POST requests and attempts to decode them as
    XML-RPC requests.
    """

    # Class attribute listing the accessible path components;
    # paths not on this list will result in a 404 error.
    rpc_paths = ('/', '/RPC2', '/pydoc.css')

    #if not None, encode responses larger than this, if possible
    encode_threshold = 1400 #a common MTU

    #Override form StreamRequestHandler: full buffering of output
    #and no Nagle.
    wbufsize = -1
    disable_nagle_algorithm = True

    # a re to match a gzip Accept-Encoding
    aepattern = re.compile(r"""
                            \s* ([^\s;]+) \s*            #content-coding
                            (;\s* q \s*=\s* ([0-9\.]+))? #q
                            """, re.VERBOSE | re.IGNORECASE)

    def accept_encodings(self):
        r = {}
        ae = self.headers.get("Accept-Encoding", "")
        for e in ae.split(","):
            match = self.aepattern.match(e)
            if match:
                v = match.group(3)
                v = float(v) if v else 1.0
                r[match.group(1)] = v
        return r

    def is_rpc_path_valid(self):
        if self.rpc_paths:
            return self.path in self.rpc_paths
        else:
            # If .rpc_paths is empty, just assume all paths are legal
            return True

    def do_POST(self):
        """Handles the HTTP POST request.

        Attempts to interpret all HTTP POST requests as XML-RPC calls,
        which are forwarded to the server's _dispatch method for handling.
        """

        # Check that the path is legal
        if not self.is_rpc_path_valid():
            self.report_404()
            return

        try:
            # Get arguments by reading body of request.
            # We read this in chunks to avoid straining
            # socket.read(); around the 10 or 15Mb mark, some platforms
            # begin to have problems (bug #792570).
            max_chunk_size = 10*1024*1024
            size_remaining = int(self.headers["content-length"])
            L = []
            while size_remaining:
                chunk_size = min(size_remaining, max_chunk_size)
                chunk = self.rfile.read(chunk_size)
                if not chunk:
                    break
                L.append(chunk)
                size_remaining -= len(L[-1])
            data = b''.join(L)

            data = self.decode_request_content(data)
            if data is None:
                return #response has been sent

            # In previous versions of SimpleXMLRPCServer, _dispatch
            # could be overridden in this class, instead of in
            # SimpleXMLRPCDispatcher. To maintain backwards compatibility,
            # check to see if a subclass implements _dispatch and dispatch
            # using that method if present.
            response = self.server._marshaled_dispatch(
                    data, getattr(self, '_dispatch', None), self.path
                )
        except Exception as e: # This should only happen if the module is buggy
            # internal error, report as HTTP server error
            self.send_response(500)

            # Send information about the exception if requested
            if hasattr(self.server, '_send_traceback_header') and \
                    self.server._send_traceback_header:
                self.send_header("X-exception", str(e))
                trace = traceback.format_exc()
                trace = str(trace.encode('ASCII', 'backslashreplace'), 'ASCII')
                self.send_header("X-traceback", trace)

            self.send_header("Content-length", "0")
            self.end_headers()
        else:
            self.send_response(200)
            self.send_header("Content-type", "text/xml")
            if self.encode_threshold is not None:
                if len(response) > self.encode_threshold:
                    q = self.accept_encodings().get("gzip", 0)
                    if q:
                        try:
                            response = gzip_encode(response)
                            self.send_header("Content-Encoding", "gzip")
                        except NotImplementedError:
                            pass
            self.send_header("Content-length", str(len(response)))
            self.end_headers()
            self.wfile.write(response)

    def decode_request_content(self, data):
        #support gzip encoding of request
        encoding = self.headers.get("content-encoding", "identity").lower()
        if encoding == "identity":
            return data
        if encoding == "gzip":
            try:
                return gzip_decode(data)
            except NotImplementedError:
                self.send_response(501, "encoding %r not supported" % encoding)
            except ValueError:
                self.send_response(400, "error decoding gzip content")
        else:
            self.send_response(501, "encoding %r not supported" % encoding)
        self.send_header("Content-length", "0")
        self.end_headers()

    def report_404 (self):
            # Report a 404 error
        self.send_response(404)
        response = b'No such page'
        self.send_header("Content-type", "text/plain")
        self.send_header("Content-length", str(len(response)))
        self.end_headers()
        self.wfile.write(response)

    def log_request(self, code='-', size='-'):
        """Selectively log an accepted request."""

        if self.server.logRequests:
            BaseHTTPRequestHandler.log_request(self, code, size)

class SimpleXMLRPCServer(socketserver.TCPServer,
                         SimpleXMLRPCDispatcher):
    """Simple XML-RPC server.

    Simple XML-RPC server that allows functions and a single instance
    to be installed to handle requests. The default implementation
    attempts to dispatch XML-RPC calls to the functions or instance
    installed in the server. Override the _dispatch method inherited
    from SimpleXMLRPCDispatcher to change this behavior.
    """

    allow_reuse_address = True
    allow_reuse_port = True

    # Warning: this is for debugging purposes only! Never set this to True in
    # production code, as will be sending out sensitive information (exception
    # and stack trace details) when exceptions are raised inside
    # SimpleXMLRPCRequestHandler.do_POST
    _send_traceback_header = False

    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,
                 logRequests=True, allow_none=False, encoding=None,
                 bind_and_activate=True, use_builtin_types=False):
        self.logRequests = logRequests

        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding, use_builtin_types)
        socketserver.TCPServer.__init__(self, addr, requestHandler, bind_and_activate)


class MultiPathXMLRPCServer(SimpleXMLRPCServer):
    """Multipath XML-RPC Server
    This specialization of SimpleXMLRPCServer allows the user to create
    multiple Dispatcher instances and assign them to different
    HTTP request paths.  This makes it possible to run two or more
    'virtual XML-RPC servers' at the same port.
    Make sure that the requestHandler accepts the paths in question.
    """
    def __init__(self, addr, requestHandler=SimpleXMLRPCRequestHandler,
                 logRequests=True, allow_none=False, encoding=None,
                 bind_and_activate=True, use_builtin_types=False):

        SimpleXMLRPCServer.__init__(self, addr, requestHandler, logRequests, allow_none,
                                    encoding, bind_and_activate, use_builtin_types)
        self.dispatchers = {}
        self.allow_none = allow_none
        self.encoding = encoding or 'utf-8'

    def add_dispatcher(self, path, dispatcher):
        self.dispatchers[path] = dispatcher
        return dispatcher

    def get_dispatcher(self, path):
        return self.dispatchers[path]

    def _marshaled_dispatch(self, data, dispatch_method = None, path = None):
        try:
            response = self.dispatchers[path]._marshaled_dispatch(
               data, dispatch_method, path)
        except BaseException as exc:
            # report low level exception back to server
            # (each dispatcher should have handled their own
            # exceptions)
            response = dumps(
                Fault(1, "%s:%s" % (type(exc), exc)),
                encoding=self.encoding, allow_none=self.allow_none)
            response = response.encode(self.encoding, 'xmlcharrefreplace')
        return response

class CGIXMLRPCRequestHandler(SimpleXMLRPCDispatcher):
    """Simple handler for XML-RPC data passed through CGI."""

    def __init__(self, allow_none=False, encoding=None, use_builtin_types=False):
        SimpleXMLRPCDispatcher.__init__(self, allow_none, encoding, use_builtin_types)

    def handle_xmlrpc(self, request_text):
        """Handle a single XML-RPC request"""

        response = self._marshaled_dispatch(request_text)

        print('Content-Type: text/xml')
        print('Content-Length: %d' % len(response))
        print()
        sys.stdout.flush()
        sys.stdout.buffer.write(response)
        sys.stdout.buffer.flush()

    def handle_get(self):
        """Handle a single HTTP GET request.

        Default implementation indicates an error because
        XML-RPC uses the POST method.
        """

        code = 400
        message, explain = BaseHTTPRequestHandler.responses[code]

        response = http.server.DEFAULT_ERROR_MESSAGE % \
            {
             'code' : code,
             'message' : message,
             'explain' : explain
            }
        response = response.encode('utf-8')
        print('Status: %d %s' % (code, message))
        print('Content-Type: %s' % http.server.DEFAULT_ERROR_CONTENT_TYPE)
        print('Content-Length: %d' % len(response))
        print()
        sys.stdout.flush()
        sys.stdout.buffer.write(response)
        sys.stdout.buffer.flush()

    def handle_request(self, request_text=None):
        """Handle a single XML-RPC request passed through a CGI post method.

        If no XML data is given then it is read from stdin. The resulting
        XML-RPC response is printed to stdout along with the correct HTTP
        headers.
        """

        if request_text is None and \
            os.environ.get('REQUEST_METHOD', None) == 'GET':
            self.handle_get()
        else:
            # POST data is normally available through stdin
            try:
                length = int(os.environ.get('CONTENT_LENGTH', None))
            except (ValueError, TypeError):
                length = -1
            if request_text is None:
                request_text = sys.stdin.read(length)

            self.handle_xmlrpc(request_text)


# -----------------------------------------------------------------------------
# Self documenting XML-RPC Server.

class ServerHTMLDoc(pydoc.HTMLDoc):
    """Class used to generate pydoc HTML document for a server"""

    def markup(self, text, escape=None, funcs={}, classes={}, methods={}):
        """Mark up some plain text, given a context of symbols to look for.
        Each context dictionary maps object names to anchor names."""
        escape = escape or self.escape
        results = []
        here = 0

        # XXX Note that this regular expression does not allow for the
        # hyperlinking of arbitrary strings being used as method
        # names. Only methods with names consisting of word characters
        # and '.'s are hyperlinked.
        pattern = re.compile(r'\b((http|https|ftp)://\S+[\w/]|'
                                r'RFC[- ]?(\d+)|'
                                r'PEP[- ]?(\d+)|'
                                r'(self\.)?((?:\w|\.)+))\b')
        while match := pattern.search(text, here):
            start, end = match.span()
            results.append(escape(text[here:start]))

            all, scheme, rfc, pep, selfdot, name = match.groups()
            if scheme:
                url = escape(all).replace('"', '&quot;')
                results.append('<a href="%s">%s</a>' % (url, url))
            elif rfc:
                url = 'https://www.rfc-editor.org/rfc/rfc%d.txt' % int(rfc)
                results.append('<a href="%s">%s</a>' % (url, escape(all)))
            elif pep:
                url = 'https://peps.python.org/pep-%04d/' % int(pep)
                results.append('<a href="%s">%s</a>' % (url, escape(all)))
            elif text[end:end+1] == '(':
                results.append(self.namelink(name, methods, funcs, classes))
            elif selfdot:
                results.append('self.<strong>%s</strong>' % name)
            else:
                results.append(self.namelink(name, classes))
            here = end
        results.append(escape(text[here:]))
        return ''.join(results)

    def docroutine(self, object, name, mod=None,
                   funcs={}, classes={}, methods={}, cl=None):
        """Produce HTML documentation for a function or method object."""

        anchor = (cl and cl.__name__ or '') + '-' + name
        note = ''

        title = '<a name="%s"><strong>%s</strong></a>' % (
            self.escape(anchor), self.escape(name))

        if callable(object):
            argspec = str(signature(object))
        else:
            argspec = '(...)'

        if isinstance(object, tuple):
            argspec = object[0] or argspec
            docstring = object[1] or ""
        else:
            docstring = pydoc.getdoc(object)

        decl = title + argspec + (note and self.grey(
               '<font face="helvetica, arial">%s</font>' % note))

        doc = self.markup(
            docstring, self.preformat, funcs, classes, methods)
        doc = doc and '<dd><tt>%s</tt></dd>' % doc
        return '<dl><dt>%s</dt>%s</dl>\n' % (decl, doc)

    def docserver(self, server_name, package_documentation, methods):
        """Produce HTML documentation for an XML-RPC server."""

        fdict = {}
        for key, value in methods.items():
            fdict[key] = '#-' + key
            fdict[value] = fdict[key]

        server_name = self.escape(server_name)
        head = '<big><big><strong>%s</strong></big></big>' % server_name
        result = self.heading(head)

        doc = self.markup(package_documentation, self.preformat, fdict)
        doc = doc and '<tt>%s</tt>' % doc
        result = result + '<p>%s</p>\n' % doc

        contents = []
        method_items = sorted(methods.items())
        for key, value in method_items:
            contents.append(self.docroutine(value, key, funcs=fdict))
        result = result + self.bigsection(
            'Methods', 'functions', ''.join(contents))

        return result


    def page(self, title, contents):
        """Format an HTML page."""
        css_path = "/pydoc.css"
        css_link = (
            '<link rel="stylesheet" type="text/css" href="%s">' %
            css_path)
        return '''\
<!DOCTYPE>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Python: %s</title>
%s</head><body>%s</body></html>''' % (title, css_link, contents)

class XMLRPCDocGenerator:
    """Generates documentation for an XML-RPC server.

    This class is designed as mix-in and should not
    be constructed directly.
    """

    def __init__(self):
        # setup variables used for HTML documentation
        self.server_name = 'XML-RPC Server Documentation'
        self.server_documentation = \
            "This server exports the following methods through the XML-RPC "\
            "protocol."
        self.server_title = 'XML-RPC Server Documentation'

    def set_server_title(self, server_title):
        """Set the HTML title of the generated server documentation"""

        self.server_title = server_title

    def set_server_name(self, server_name):
        """Set the name of the generated HTML server documentation"""

        self.server_name = server_name

    def set_server_documentation(self, server_documentation):
        """Set the documentation string for the entire server."""

        self.server_documentation = server_documentation

    def generate_html_documentation(self):
        """generate_html_documentation() => html documentation for the server

        Generates HTML documentation for the server using introspection for
        installed functions and instances that do not implement the
        _dispatch method. Alternatively, instances can choose to implement
        the _get_method_argstring(method_name) method to provide the
        argument string used in the documentation and the
        _methodHelp(method_name) method to provide the help text used
        in the documentation."""

        methods = {}

        for method_name in self.system_listMethods():
            if method_name in self.funcs:
                method = self.funcs[method_name]
            elif self.instance is not None:
                method_info = [None, None] # argspec, documentation
                if hasattr(self.instance, '_get_method_argstring'):
                    method_info[0] = self.instance._get_method_argstring(method_name)
                if hasattr(self.instance, '_methodHelp'):
                    method_info[1] = self.instance._methodHelp(method_name)

                method_info = tuple(method_info)
                if method_info != (None, None):
                    method = method_info
                elif not hasattr(self.instance, '_dispatch'):
                    try:
                        method = resolve_dotted_attribute(
                                    self.instance,
                                    method_name
                                    )
                    except AttributeError:
                        method = method_info
                else:
                    method = method_info
            else:
                assert 0, "Could not find method in self.functions and no "\
                          "instance installed"

            methods[method_name] = method

        documenter = ServerHTMLDoc()
        documentation = documenter.docserver(
                                self.server_name,
                                self.server_documentation,
                                methods
                            )

        return documenter.page(html.escape(self.server_title), documentation)

class DocXMLRPCRequestHandler(SimpleXMLRPCRequestHandler):
    """XML-RPC and documentation request handler class.

    Handles all HTTP POST requests and attempts to decode them as
    XML-RPC requests.

    Handles all HTTP GET requests and interprets them as requests
    for documentation.
    """

    def _get_css(self, url):
        path_here = os.path.dirname(os.path.realpath(__file__))
        css_path = os.path.join(path_here, "..", "pydoc_data", "_pydoc.css")
        with open(css_path, mode="rb") as fp:
            return fp.read()

    def do_GET(self):
        """Handles the HTTP GET request.

        Interpret all HTTP GET requests as requests for server
        documentation.
        """
        # Check that the path is legal
        if not self.is_rpc_path_valid():
            self.report_404()
            return

        if self.path.endswith('.css'):
            content_type = 'text/css'
            response = self._get_css(self.path)
        else:
            content_type = 'text/html'
            response = self.server.generate_html_documentation().encode('utf-8')

        self.send_response(200)
        self.send_header('Content-Type', '%s; charset=UTF-8' % content_type)
        self.send_header("Content-length", str(len(response)))
        self.end_headers()
        self.wfile.write(response)

class DocXMLRPCServer(  SimpleXMLRPCServer,
                        XMLRPCDocGenerator):
    """XML-RPC and HTML documentation server.

    Adds the ability to serve server documentation to the capabilities
    of SimpleXMLRPCServer.
    """

    def __init__(self, addr, requestHandler=DocXMLRPCRequestHandler,
                 logRequests=True, allow_none=False, encoding=None,
                 bind_and_activate=True, use_builtin_types=False):
        SimpleXMLRPCServer.__init__(self, addr, requestHandler, logRequests,
                                    allow_none, encoding, bind_and_activate,
                                    use_builtin_types)
        XMLRPCDocGenerator.__init__(self)

class DocCGIXMLRPCRequestHandler(   CGIXMLRPCRequestHandler,
                                    XMLRPCDocGenerator):
    """Handler for XML-RPC data and documentation requests passed through
    CGI"""

    def handle_get(self):
        """Handles the HTTP GET request.

        Interpret all HTTP GET requests as requests for server
        documentation.
        """

        response = self.generate_html_documentation().encode('utf-8')

        print('Content-Type: text/html')
        print('Content-Length: %d' % len(response))
        print()
        sys.stdout.flush()
        sys.stdout.buffer.write(response)
        sys.stdout.buffer.flush()

    def __init__(self):
        CGIXMLRPCRequestHandler.__init__(self)
        XMLRPCDocGenerator.__init__(self)


if __name__ == '__main__':
    import datetime

    class ExampleService:
        def getData(self):
            return '42'

        class currentTime:
            @staticmethod
            def getCurrentTime():
                return datetime.datetime.now()

    with SimpleXMLRPCServer(("localhost", 8000)) as server:
        server.register_function(pow)
        server.register_function(lambda x,y: x+y, 'add')
        server.register_instance(ExampleService(), allow_dotted_names=True)
        server.register_multicall_functions()
        print('Serving XML-RPC on localhost port 8000')
        print('It is advisable to run this example server within a secure, closed network.')
        try:
            server.serve_forever()
        except KeyboardInterrupt:
            print("\nKeyboard interrupt received, exiting.")
            sys.exit(0)


================================================
File: /Lib/zipfile/__main__.py
================================================
from . import main

if __name__ == "__main__":
    main()


================================================
File: /Lib/zipfile/_path/__init__.py
================================================
"""
A Path-like interface for zipfiles.

This codebase is shared between zipfile.Path in the stdlib
and zipp in PyPI. See
https://github.com/python/importlib_metadata/wiki/Development-Methodology
for more detail.
"""

import io
import posixpath
import zipfile
import itertools
import contextlib
import pathlib
import re
import stat
import sys

from .glob import Translator


__all__ = ['Path']


def _parents(path):
    """
    Given a path with elements separated by
    posixpath.sep, generate all parents of that path.

    >>> list(_parents('b/d'))
    ['b']
    >>> list(_parents('/b/d/'))
    ['/b']
    >>> list(_parents('b/d/f/'))
    ['b/d', 'b']
    >>> list(_parents('b'))
    []
    >>> list(_parents(''))
    []
    """
    return itertools.islice(_ancestry(path), 1, None)


def _ancestry(path):
    """
    Given a path with elements separated by
    posixpath.sep, generate all elements of that path.

    >>> list(_ancestry('b/d'))
    ['b/d', 'b']
    >>> list(_ancestry('/b/d/'))
    ['/b/d', '/b']
    >>> list(_ancestry('b/d/f/'))
    ['b/d/f', 'b/d', 'b']
    >>> list(_ancestry('b'))
    ['b']
    >>> list(_ancestry(''))
    []

    Multiple separators are treated like a single.

    >>> list(_ancestry('//b//d///f//'))
    ['//b//d///f', '//b//d', '//b']
    """
    path = path.rstrip(posixpath.sep)
    while path.rstrip(posixpath.sep):
        yield path
        path, tail = posixpath.split(path)


_dedupe = dict.fromkeys
"""Deduplicate an iterable in original order"""


def _difference(minuend, subtrahend):
    """
    Return items in minuend not in subtrahend, retaining order
    with O(1) lookup.
    """
    return itertools.filterfalse(set(subtrahend).__contains__, minuend)


class InitializedState:
    """
    Mix-in to save the initialization state for pickling.
    """

    def __init__(self, *args, **kwargs):
        self.__args = args
        self.__kwargs = kwargs
        super().__init__(*args, **kwargs)

    def __getstate__(self):
        return self.__args, self.__kwargs

    def __setstate__(self, state):
        args, kwargs = state
        super().__init__(*args, **kwargs)


class CompleteDirs(InitializedState, zipfile.ZipFile):
    """
    A ZipFile subclass that ensures that implied directories
    are always included in the namelist.

    >>> list(CompleteDirs._implied_dirs(['foo/bar.txt', 'foo/bar/baz.txt']))
    ['foo/', 'foo/bar/']
    >>> list(CompleteDirs._implied_dirs(['foo/bar.txt', 'foo/bar/baz.txt', 'foo/bar/']))
    ['foo/']
    """

    @staticmethod
    def _implied_dirs(names):
        parents = itertools.chain.from_iterable(map(_parents, names))
        as_dirs = (p + posixpath.sep for p in parents)
        return _dedupe(_difference(as_dirs, names))

    def namelist(self):
        names = super().namelist()
        return names + list(self._implied_dirs(names))

    def _name_set(self):
        return set(self.namelist())

    def resolve_dir(self, name):
        """
        If the name represents a directory, return that name
        as a directory (with the trailing slash).
        """
        names = self._name_set()
        dirname = name + '/'
        dir_match = name not in names and dirname in names
        return dirname if dir_match else name

    def getinfo(self, name):
        """
        Supplement getinfo for implied dirs.
        """
        try:
            return super().getinfo(name)
        except KeyError:
            if not name.endswith('/') or name not in self._name_set():
                raise
            return zipfile.ZipInfo(filename=name)

    @classmethod
    def make(cls, source):
        """
        Given a source (filename or zipfile), return an
        appropriate CompleteDirs subclass.
        """
        if isinstance(source, CompleteDirs):
            return source

        if not isinstance(source, zipfile.ZipFile):
            return cls(source)

        # Only allow for FastLookup when supplied zipfile is read-only
        if 'r' not in source.mode:
            cls = CompleteDirs

        source.__class__ = cls
        return source

    @classmethod
    def inject(cls, zf: zipfile.ZipFile) -> zipfile.ZipFile:
        """
        Given a writable zip file zf, inject directory entries for
        any directories implied by the presence of children.
        """
        for name in cls._implied_dirs(zf.namelist()):
            zf.writestr(name, b"")
        return zf


class FastLookup(CompleteDirs):
    """
    ZipFile subclass to ensure implicit
    dirs exist and are resolved rapidly.
    """

    def namelist(self):
        with contextlib.suppress(AttributeError):
            return self.__names
        self.__names = super().namelist()
        return self.__names

    def _name_set(self):
        with contextlib.suppress(AttributeError):
            return self.__lookup
        self.__lookup = super()._name_set()
        return self.__lookup


def _extract_text_encoding(encoding=None, *args, **kwargs):
    # compute stack level so that the caller of the caller sees any warning.
    is_pypy = sys.implementation.name == 'pypy'
    stack_level = 3 + is_pypy
    return io.text_encoding(encoding, stack_level), args, kwargs


class Path:
    """
    A :class:`importlib.resources.abc.Traversable` interface for zip files.

    Implements many of the features users enjoy from
    :class:`pathlib.Path`.

    Consider a zip file with this structure::

        .
        ├── a.txt
        └── b
            ├── c.txt
            └── d
                └── e.txt

    >>> data = io.BytesIO()
    >>> zf = ZipFile(data, 'w')
    >>> zf.writestr('a.txt', 'content of a')
    >>> zf.writestr('b/c.txt', 'content of c')
    >>> zf.writestr('b/d/e.txt', 'content of e')
    >>> zf.filename = 'mem/abcde.zip'

    Path accepts the zipfile object itself or a filename

    >>> path = Path(zf)

    From there, several path operations are available.

    Directory iteration (including the zip file itself):

    >>> a, b = path.iterdir()
    >>> a
    Path('mem/abcde.zip', 'a.txt')
    >>> b
    Path('mem/abcde.zip', 'b/')

    name property:

    >>> b.name
    'b'

    join with divide operator:

    >>> c = b / 'c.txt'
    >>> c
    Path('mem/abcde.zip', 'b/c.txt')
    >>> c.name
    'c.txt'

    Read text:

    >>> c.read_text(encoding='utf-8')
    'content of c'

    existence:

    >>> c.exists()
    True
    >>> (b / 'missing.txt').exists()
    False

    Coercion to string:

    >>> import os
    >>> str(c).replace(os.sep, posixpath.sep)
    'mem/abcde.zip/b/c.txt'

    At the root, ``name``, ``filename``, and ``parent``
    resolve to the zipfile.

    >>> str(path)
    'mem/abcde.zip/'
    >>> path.name
    'abcde.zip'
    >>> path.filename == pathlib.Path('mem/abcde.zip')
    True
    >>> str(path.parent)
    'mem'

    If the zipfile has no filename, such attributes are not
    valid and accessing them will raise an Exception.

    >>> zf.filename = None
    >>> path.name
    Traceback (most recent call last):
    ...
    TypeError: ...

    >>> path.filename
    Traceback (most recent call last):
    ...
    TypeError: ...

    >>> path.parent
    Traceback (most recent call last):
    ...
    TypeError: ...

    # workaround python/cpython#106763
    >>> pass
    """

    __repr = "{self.__class__.__name__}({self.root.filename!r}, {self.at!r})"

    def __init__(self, root, at=""):
        """
        Construct a Path from a ZipFile or filename.

        Note: When the source is an existing ZipFile object,
        its type (__class__) will be mutated to a
        specialized type. If the caller wishes to retain the
        original type, the caller should either create a
        separate ZipFile object or pass a filename.
        """
        self.root = FastLookup.make(root)
        self.at = at

    def __eq__(self, other):
        """
        >>> Path(zipfile.ZipFile(io.BytesIO(), 'w')) == 'foo'
        False
        """
        if self.__class__ is not other.__class__:
            return NotImplemented
        return (self.root, self.at) == (other.root, other.at)

    def __hash__(self):
        return hash((self.root, self.at))

    def open(self, mode='r', *args, pwd=None, **kwargs):
        """
        Open this entry as text or binary following the semantics
        of ``pathlib.Path.open()`` by passing arguments through
        to io.TextIOWrapper().
        """
        if self.is_dir():
            raise IsADirectoryError(self)
        zip_mode = mode[0]
        if zip_mode == 'r' and not self.exists():
            raise FileNotFoundError(self)
        stream = self.root.open(self.at, zip_mode, pwd=pwd)
        if 'b' in mode:
            if args or kwargs:
                raise ValueError("encoding args invalid for binary operation")
            return stream
        # Text mode:
        encoding, args, kwargs = _extract_text_encoding(*args, **kwargs)
        return io.TextIOWrapper(stream, encoding, *args, **kwargs)

    def _base(self):
        return pathlib.PurePosixPath(self.at or self.root.filename)

    @property
    def name(self):
        return self._base().name

    @property
    def suffix(self):
        return self._base().suffix

    @property
    def suffixes(self):
        return self._base().suffixes

    @property
    def stem(self):
        return self._base().stem

    @property
    def filename(self):
        return pathlib.Path(self.root.filename).joinpath(self.at)

    def read_text(self, *args, **kwargs):
        encoding, args, kwargs = _extract_text_encoding(*args, **kwargs)
        with self.open('r', encoding, *args, **kwargs) as strm:
            return strm.read()

    def read_bytes(self):
        with self.open('rb') as strm:
            return strm.read()

    def _is_child(self, path):
        return posixpath.dirname(path.at.rstrip("/")) == self.at.rstrip("/")

    def _next(self, at):
        return self.__class__(self.root, at)

    def is_dir(self):
        return not self.at or self.at.endswith("/")

    def is_file(self):
        return self.exists() and not self.is_dir()

    def exists(self):
        return self.at in self.root._name_set()

    def iterdir(self):
        if not self.is_dir():
            raise ValueError("Can't listdir a file")
        subs = map(self._next, self.root.namelist())
        return filter(self._is_child, subs)

    def match(self, path_pattern):
        return pathlib.PurePosixPath(self.at).match(path_pattern)

    def is_symlink(self):
        """
        Return whether this path is a symlink.
        """
        info = self.root.getinfo(self.at)
        mode = info.external_attr >> 16
        return stat.S_ISLNK(mode)

    def glob(self, pattern):
        if not pattern:
            raise ValueError(f"Unacceptable pattern: {pattern!r}")

        prefix = re.escape(self.at)
        tr = Translator(seps='/')
        matches = re.compile(prefix + tr.translate(pattern)).fullmatch
        return map(self._next, filter(matches, self.root.namelist()))

    def rglob(self, pattern):
        return self.glob(f'**/{pattern}')

    def relative_to(self, other, *extra):
        return posixpath.relpath(str(self), str(other.joinpath(*extra)))

    def __str__(self):
        return posixpath.join(self.root.filename, self.at)

    def __repr__(self):
        return self.__repr.format(self=self)

    def joinpath(self, *other):
        next = posixpath.join(self.at, *other)
        return self._next(self.root.resolve_dir(next))

    __truediv__ = joinpath

    @property
    def parent(self):
        if not self.at:
            return self.filename.parent
        parent_at = posixpath.dirname(self.at.rstrip('/'))
        if parent_at:
            parent_at += '/'
        return self._next(parent_at)


================================================
File: /Lib/zipfile/_path/glob.py
================================================
import os
import re


_default_seps = os.sep + str(os.altsep) * bool(os.altsep)


class Translator:
    """
    >>> Translator('xyz')
    Traceback (most recent call last):
    ...
    AssertionError: Invalid separators

    >>> Translator('')
    Traceback (most recent call last):
    ...
    AssertionError: Invalid separators
    """

    seps: str

    def __init__(self, seps: str = _default_seps):
        assert seps and set(seps) <= set(_default_seps), "Invalid separators"
        self.seps = seps

    def translate(self, pattern):
        """
        Given a glob pattern, produce a regex that matches it.
        """
        return self.extend(self.match_dirs(self.translate_core(pattern)))

    def extend(self, pattern):
        r"""
        Extend regex for pattern-wide concerns.

        Apply '(?s:)' to create a non-matching group that
        matches newlines (valid on Unix).

        Append '\Z' to imply fullmatch even when match is used.
        """
        return rf'(?s:{pattern})\Z'

    def match_dirs(self, pattern):
        """
        Ensure that zipfile.Path directory names are matched.

        zipfile.Path directory names always end in a slash.
        """
        return rf'{pattern}[/]?'

    def translate_core(self, pattern):
        r"""
        Given a glob pattern, produce a regex that matches it.

        >>> t = Translator()
        >>> t.translate_core('*.txt').replace('\\\\', '')
        '[^/]*\\.txt'
        >>> t.translate_core('a?txt')
        'a[^/]txt'
        >>> t.translate_core('**/*').replace('\\\\', '')
        '.*/[^/][^/]*'
        """
        self.restrict_rglob(pattern)
        return ''.join(map(self.replace, separate(self.star_not_empty(pattern))))

    def replace(self, match):
        """
        Perform the replacements for a match from :func:`separate`.
        """
        return match.group('set') or (
            re.escape(match.group(0))
            .replace('\\*\\*', r'.*')
            .replace('\\*', rf'[^{re.escape(self.seps)}]*')
            .replace('\\?', r'[^/]')
        )

    def restrict_rglob(self, pattern):
        """
        Raise ValueError if ** appears in anything but a full path segment.

        >>> Translator().translate('**foo')
        Traceback (most recent call last):
        ...
        ValueError: ** must appear alone in a path segment
        """
        seps_pattern = rf'[{re.escape(self.seps)}]+'
        segments = re.split(seps_pattern, pattern)
        if any('**' in segment and segment != '**' for segment in segments):
            raise ValueError("** must appear alone in a path segment")

    def star_not_empty(self, pattern):
        """
        Ensure that * will not match an empty segment.
        """

        def handle_segment(match):
            segment = match.group(0)
            return '?*' if segment == '*' else segment

        not_seps_pattern = rf'[^{re.escape(self.seps)}]+'
        return re.sub(not_seps_pattern, handle_segment, pattern)


def separate(pattern):
    """
    Separate out character sets to avoid translating their contents.

    >>> [m.group(0) for m in separate('*.txt')]
    ['*.txt']
    >>> [m.group(0) for m in separate('a[?]txt')]
    ['a', '[?]', 'txt']
    """
    return re.finditer(r'([^\[]+)|(?P<set>[\[].*?[\]])|([\[][^\]]*$)', pattern)


================================================
File: /Lib/zoneinfo/__init__.py
================================================
__all__ = [
    "ZoneInfo",
    "reset_tzpath",
    "available_timezones",
    "TZPATH",
    "ZoneInfoNotFoundError",
    "InvalidTZPathWarning",
]

from . import _tzpath
from ._common import ZoneInfoNotFoundError

try:
    from _zoneinfo import ZoneInfo
except ImportError:  # pragma: nocover
    from ._zoneinfo import ZoneInfo

reset_tzpath = _tzpath.reset_tzpath
available_timezones = _tzpath.available_timezones
InvalidTZPathWarning = _tzpath.InvalidTZPathWarning


def __getattr__(name):
    if name == "TZPATH":
        return _tzpath.TZPATH
    else:
        raise AttributeError(f"module {__name__!r} has no attribute {name!r}")


def __dir__():
    return sorted(list(globals()) + ["TZPATH"])


================================================
File: /Lib/zoneinfo/_common.py
================================================
import struct


def load_tzdata(key):
    from importlib import resources

    components = key.split("/")
    package_name = ".".join(["tzdata.zoneinfo"] + components[:-1])
    resource_name = components[-1]

    try:
        return resources.files(package_name).joinpath(resource_name).open("rb")
    except (ImportError, FileNotFoundError, UnicodeEncodeError):
        # There are three types of exception that can be raised that all amount
        # to "we cannot find this key":
        #
        # ImportError: If package_name doesn't exist (e.g. if tzdata is not
        #   installed, or if there's an error in the folder name like
        #   Amrica/New_York)
        # FileNotFoundError: If resource_name doesn't exist in the package
        #   (e.g. Europe/Krasnoy)
        # UnicodeEncodeError: If package_name or resource_name are not UTF-8,
        #   such as keys containing a surrogate character.
        raise ZoneInfoNotFoundError(f"No time zone found with key {key}")


def load_data(fobj):
    header = _TZifHeader.from_file(fobj)

    if header.version == 1:
        time_size = 4
        time_type = "l"
    else:
        # Version 2+ has 64-bit integer transition times
        time_size = 8
        time_type = "q"

        # Version 2+ also starts with a Version 1 header and data, which
        # we need to skip now
        skip_bytes = (
            header.timecnt * 5  # Transition times and types
            + header.typecnt * 6  # Local time type records
            + header.charcnt  # Time zone designations
            + header.leapcnt * 8  # Leap second records
            + header.isstdcnt  # Standard/wall indicators
            + header.isutcnt  # UT/local indicators
        )

        fobj.seek(skip_bytes, 1)

        # Now we need to read the second header, which is not the same
        # as the first
        header = _TZifHeader.from_file(fobj)

    typecnt = header.typecnt
    timecnt = header.timecnt
    charcnt = header.charcnt

    # The data portion starts with timecnt transitions and indices
    if timecnt:
        trans_list_utc = struct.unpack(
            f">{timecnt}{time_type}", fobj.read(timecnt * time_size)
        )
        trans_idx = struct.unpack(f">{timecnt}B", fobj.read(timecnt))
    else:
        trans_list_utc = ()
        trans_idx = ()

    # Read the ttinfo struct, (utoff, isdst, abbrind)
    if typecnt:
        utcoff, isdst, abbrind = zip(
            *(struct.unpack(">lbb", fobj.read(6)) for i in range(typecnt))
        )
    else:
        utcoff = ()
        isdst = ()
        abbrind = ()

    # Now read the abbreviations. They are null-terminated strings, indexed
    # not by position in the array but by position in the unsplit
    # abbreviation string. I suppose this makes more sense in C, which uses
    # null to terminate the strings, but it's inconvenient here...
    abbr_vals = {}
    abbr_chars = fobj.read(charcnt)

    def get_abbr(idx):
        # Gets a string starting at idx and running until the next \x00
        #
        # We cannot pre-populate abbr_vals by splitting on \x00 because there
        # are some zones that use subsets of longer abbreviations, like so:
        #
        #  LMT\x00AHST\x00HDT\x00
        #
        # Where the idx to abbr mapping should be:
        #
        # {0: "LMT", 4: "AHST", 5: "HST", 9: "HDT"}
        if idx not in abbr_vals:
            span_end = abbr_chars.find(b"\x00", idx)
            abbr_vals[idx] = abbr_chars[idx:span_end].decode()

        return abbr_vals[idx]

    abbr = tuple(get_abbr(idx) for idx in abbrind)

    # The remainder of the file consists of leap seconds (currently unused) and
    # the standard/wall and ut/local indicators, which are metadata we don't need.
    # In version 2 files, we need to skip the unnecessary data to get at the TZ string:
    if header.version >= 2:
        # Each leap second record has size (time_size + 4)
        skip_bytes = header.isutcnt + header.isstdcnt + header.leapcnt * 12
        fobj.seek(skip_bytes, 1)

        c = fobj.read(1)  # Should be \n
        assert c == b"\n", c

        tz_bytes = b""
        while (c := fobj.read(1)) != b"\n":
            tz_bytes += c

        tz_str = tz_bytes
    else:
        tz_str = None

    return trans_idx, trans_list_utc, utcoff, isdst, abbr, tz_str


class _TZifHeader:
    __slots__ = [
        "version",
        "isutcnt",
        "isstdcnt",
        "leapcnt",
        "timecnt",
        "typecnt",
        "charcnt",
    ]

    def __init__(self, *args):
        for attr, val in zip(self.__slots__, args, strict=True):
            setattr(self, attr, val)

    @classmethod
    def from_file(cls, stream):
        # The header starts with a 4-byte "magic" value
        if stream.read(4) != b"TZif":
            raise ValueError("Invalid TZif file: magic not found")

        _version = stream.read(1)
        if _version == b"\x00":
            version = 1
        else:
            version = int(_version)
        stream.read(15)

        args = (version,)

        # Slots are defined in the order that the bytes are arranged
        args = args + struct.unpack(">6l", stream.read(24))

        return cls(*args)


class ZoneInfoNotFoundError(KeyError):
    """Exception raised when a ZoneInfo key is not found."""


================================================
File: /Lib/zoneinfo/_tzpath.py
================================================
import os
import sysconfig


def _reset_tzpath(to=None, stacklevel=4):
    global TZPATH

    tzpaths = to
    if tzpaths is not None:
        if isinstance(tzpaths, (str, bytes)):
            raise TypeError(
                f"tzpaths must be a list or tuple, "
                + f"not {type(tzpaths)}: {tzpaths!r}"
            )

        if not all(map(os.path.isabs, tzpaths)):
            raise ValueError(_get_invalid_paths_message(tzpaths))
        base_tzpath = tzpaths
    else:
        env_var = os.environ.get("PYTHONTZPATH", None)
        if env_var is None:
            env_var = sysconfig.get_config_var("TZPATH")
        base_tzpath = _parse_python_tzpath(env_var, stacklevel)

    TZPATH = tuple(base_tzpath)


def reset_tzpath(to=None):
    """Reset global TZPATH."""
    # We need `_reset_tzpath` helper function because it produces a warning,
    # it is used as both a module-level call and a public API.
    # This is how we equalize the stacklevel for both calls.
    _reset_tzpath(to)


def _parse_python_tzpath(env_var, stacklevel):
    if not env_var:
        return ()

    raw_tzpath = env_var.split(os.pathsep)
    new_tzpath = tuple(filter(os.path.isabs, raw_tzpath))

    # If anything has been filtered out, we will warn about it
    if len(new_tzpath) != len(raw_tzpath):
        import warnings

        msg = _get_invalid_paths_message(raw_tzpath)

        warnings.warn(
            "Invalid paths specified in PYTHONTZPATH environment variable. "
            + msg,
            InvalidTZPathWarning,
            stacklevel=stacklevel,
        )

    return new_tzpath


def _get_invalid_paths_message(tzpaths):
    invalid_paths = (path for path in tzpaths if not os.path.isabs(path))

    prefix = "\n    "
    indented_str = prefix + prefix.join(invalid_paths)

    return (
        "Paths should be absolute but found the following relative paths:"
        + indented_str
    )


def find_tzfile(key):
    """Retrieve the path to a TZif file from a key."""
    _validate_tzfile_path(key)
    for search_path in TZPATH:
        filepath = os.path.join(search_path, key)
        if os.path.isfile(filepath):
            return filepath

    return None


_TEST_PATH = os.path.normpath(os.path.join("_", "_"))[:-1]


def _validate_tzfile_path(path, _base=_TEST_PATH):
    if os.path.isabs(path):
        raise ValueError(
            f"ZoneInfo keys may not be absolute paths, got: {path}"
        )

    # We only care about the kinds of path normalizations that would change the
    # length of the key - e.g. a/../b -> a/b, or a/b/ -> a/b. On Windows,
    # normpath will also change from a/b to a\b, but that would still preserve
    # the length.
    new_path = os.path.normpath(path)
    if len(new_path) != len(path):
        raise ValueError(
            f"ZoneInfo keys must be normalized relative paths, got: {path}"
        )

    resolved = os.path.normpath(os.path.join(_base, new_path))
    if not resolved.startswith(_base):
        raise ValueError(
            f"ZoneInfo keys must refer to subdirectories of TZPATH, got: {path}"
        )


del _TEST_PATH


def available_timezones():
    """Returns a set containing all available time zones.

    .. caution::

        This may attempt to open a large number of files, since the best way to
        determine if a given file on the time zone search path is to open it
        and check for the "magic string" at the beginning.
    """
    from importlib import resources

    valid_zones = set()

    # Start with loading from the tzdata package if it exists: this has a
    # pre-assembled list of zones that only requires opening one file.
    try:
        with resources.files("tzdata").joinpath("zones").open("r") as f:
            for zone in f:
                zone = zone.strip()
                if zone:
                    valid_zones.add(zone)
    except (ImportError, FileNotFoundError):
        pass

    def valid_key(fpath):
        try:
            with open(fpath, "rb") as f:
                return f.read(4) == b"TZif"
        except Exception:  # pragma: nocover
            return False

    for tz_root in TZPATH:
        if not os.path.exists(tz_root):
            continue

        for root, dirnames, files in os.walk(tz_root):
            if root == tz_root:
                # right/ and posix/ are special directories and shouldn't be
                # included in the output of available zones
                if "right" in dirnames:
                    dirnames.remove("right")
                if "posix" in dirnames:
                    dirnames.remove("posix")

            for file in files:
                fpath = os.path.join(root, file)

                key = os.path.relpath(fpath, start=tz_root)
                if os.sep != "/":  # pragma: nocover
                    key = key.replace(os.sep, "/")

                if not key or key in valid_zones:
                    continue

                if valid_key(fpath):
                    valid_zones.add(key)

    if "posixrules" in valid_zones:
        # posixrules is a special symlink-only time zone where it exists, it
        # should not be included in the output
        valid_zones.remove("posixrules")

    return valid_zones


class InvalidTZPathWarning(RuntimeWarning):
    """Warning raised if an invalid path is specified in PYTHONTZPATH."""


TZPATH = ()
_reset_tzpath(stacklevel=5)


================================================
File: /Lib/zoneinfo/_zoneinfo.py
================================================
import bisect
import calendar
import collections
import functools
import re
import weakref
from datetime import datetime, timedelta, tzinfo

from . import _common, _tzpath

EPOCH = datetime(1970, 1, 1)
EPOCHORDINAL = datetime(1970, 1, 1).toordinal()

# It is relatively expensive to construct new timedelta objects, and in most
# cases we're looking at the same deltas, like integer numbers of hours, etc.
# To improve speed and memory use, we'll keep a dictionary with references
# to the ones we've already used so far.
#
# Loading every time zone in the 2020a version of the time zone database
# requires 447 timedeltas, which requires approximately the amount of space
# that ZoneInfo("America/New_York") with 236 transitions takes up, so we will
# set the cache size to 512 so that in the common case we always get cache
# hits, but specifically crafted ZoneInfo objects don't leak arbitrary amounts
# of memory.
@functools.lru_cache(maxsize=512)
def _load_timedelta(seconds):
    return timedelta(seconds=seconds)


class ZoneInfo(tzinfo):
    _strong_cache_size = 8
    _strong_cache = collections.OrderedDict()
    _weak_cache = weakref.WeakValueDictionary()
    __module__ = "zoneinfo"

    def __init_subclass__(cls):
        cls._strong_cache = collections.OrderedDict()
        cls._weak_cache = weakref.WeakValueDictionary()

    def __new__(cls, key):
        instance = cls._weak_cache.get(key, None)
        if instance is None:
            instance = cls._weak_cache.setdefault(key, cls._new_instance(key))
            instance._from_cache = True

        # Update the "strong" cache
        cls._strong_cache[key] = cls._strong_cache.pop(key, instance)

        if len(cls._strong_cache) > cls._strong_cache_size:
            cls._strong_cache.popitem(last=False)

        return instance

    @classmethod
    def no_cache(cls, key):
        obj = cls._new_instance(key)
        obj._from_cache = False

        return obj

    @classmethod
    def _new_instance(cls, key):
        obj = super().__new__(cls)
        obj._key = key
        obj._file_path = obj._find_tzfile(key)

        if obj._file_path is not None:
            file_obj = open(obj._file_path, "rb")
        else:
            file_obj = _common.load_tzdata(key)

        with file_obj as f:
            obj._load_file(f)

        return obj

    @classmethod
    def from_file(cls, fobj, /, key=None):
        obj = super().__new__(cls)
        obj._key = key
        obj._file_path = None
        obj._load_file(fobj)
        obj._file_repr = repr(fobj)

        # Disable pickling for objects created from files
        obj.__reduce__ = obj._file_reduce

        return obj

    @classmethod
    def clear_cache(cls, *, only_keys=None):
        if only_keys is not None:
            for key in only_keys:
                cls._weak_cache.pop(key, None)
                cls._strong_cache.pop(key, None)

        else:
            cls._weak_cache.clear()
            cls._strong_cache.clear()

    @property
    def key(self):
        return self._key

    def utcoffset(self, dt):
        return self._find_trans(dt).utcoff

    def dst(self, dt):
        return self._find_trans(dt).dstoff

    def tzname(self, dt):
        return self._find_trans(dt).tzname

    def fromutc(self, dt):
        """Convert from datetime in UTC to datetime in local time"""

        if not isinstance(dt, datetime):
            raise TypeError("fromutc() requires a datetime argument")
        if dt.tzinfo is not self:
            raise ValueError("dt.tzinfo is not self")

        timestamp = self._get_local_timestamp(dt)
        num_trans = len(self._trans_utc)

        if num_trans >= 1 and timestamp < self._trans_utc[0]:
            tti = self._tti_before
            fold = 0
        elif (
            num_trans == 0 or timestamp > self._trans_utc[-1]
        ) and not isinstance(self._tz_after, _ttinfo):
            tti, fold = self._tz_after.get_trans_info_fromutc(
                timestamp, dt.year
            )
        elif num_trans == 0:
            tti = self._tz_after
            fold = 0
        else:
            idx = bisect.bisect_right(self._trans_utc, timestamp)

            if num_trans > 1 and timestamp >= self._trans_utc[1]:
                tti_prev, tti = self._ttinfos[idx - 2 : idx]
            elif timestamp > self._trans_utc[-1]:
                tti_prev = self._ttinfos[-1]
                tti = self._tz_after
            else:
                tti_prev = self._tti_before
                tti = self._ttinfos[0]

            # Detect fold
            shift = tti_prev.utcoff - tti.utcoff
            fold = shift.total_seconds() > timestamp - self._trans_utc[idx - 1]
        dt += tti.utcoff
        if fold:
            return dt.replace(fold=1)
        else:
            return dt

    def _find_trans(self, dt):
        if dt is None:
            if self._fixed_offset:
                return self._tz_after
            else:
                return _NO_TTINFO

        ts = self._get_local_timestamp(dt)

        lt = self._trans_local[dt.fold]

        num_trans = len(lt)

        if num_trans and ts < lt[0]:
            return self._tti_before
        elif not num_trans or ts > lt[-1]:
            if isinstance(self._tz_after, _TZStr):
                return self._tz_after.get_trans_info(ts, dt.year, dt.fold)
            else:
                return self._tz_after
        else:
            # idx is the transition that occurs after this timestamp, so we
            # subtract off 1 to get the current ttinfo
            idx = bisect.bisect_right(lt, ts) - 1
            assert idx >= 0
            return self._ttinfos[idx]

    def _get_local_timestamp(self, dt):
        return (
            (dt.toordinal() - EPOCHORDINAL) * 86400
            + dt.hour * 3600
            + dt.minute * 60
            + dt.second
        )

    def __str__(self):
        if self._key is not None:
            return f"{self._key}"
        else:
            return repr(self)

    def __repr__(self):
        if self._key is not None:
            return f"{self.__class__.__name__}(key={self._key!r})"
        else:
            return f"{self.__class__.__name__}.from_file({self._file_repr})"

    def __reduce__(self):
        return (self.__class__._unpickle, (self._key, self._from_cache))

    def _file_reduce(self):
        import pickle

        raise pickle.PicklingError(
            "Cannot pickle a ZoneInfo file created from a file stream."
        )

    @classmethod
    def _unpickle(cls, key, from_cache, /):
        if from_cache:
            return cls(key)
        else:
            return cls.no_cache(key)

    def _find_tzfile(self, key):
        return _tzpath.find_tzfile(key)

    def _load_file(self, fobj):
        # Retrieve all the data as it exists in the zoneinfo file
        trans_idx, trans_utc, utcoff, isdst, abbr, tz_str = _common.load_data(
            fobj
        )

        # Infer the DST offsets (needed for .dst()) from the data
        dstoff = self._utcoff_to_dstoff(trans_idx, utcoff, isdst)

        # Convert all the transition times (UTC) into "seconds since 1970-01-01 local time"
        trans_local = self._ts_to_local(trans_idx, trans_utc, utcoff)

        # Construct `_ttinfo` objects for each transition in the file
        _ttinfo_list = [
            _ttinfo(
                _load_timedelta(utcoffset), _load_timedelta(dstoffset), tzname
            )
            for utcoffset, dstoffset, tzname in zip(utcoff, dstoff, abbr)
        ]

        self._trans_utc = trans_utc
        self._trans_local = trans_local
        self._ttinfos = [_ttinfo_list[idx] for idx in trans_idx]

        # Find the first non-DST transition
        for i in range(len(isdst)):
            if not isdst[i]:
                self._tti_before = _ttinfo_list[i]
                break
        else:
            if self._ttinfos:
                self._tti_before = self._ttinfos[0]
            else:
                self._tti_before = None

        # Set the "fallback" time zone
        if tz_str is not None and tz_str != b"":
            self._tz_after = _parse_tz_str(tz_str.decode())
        else:
            if not self._ttinfos and not _ttinfo_list:
                raise ValueError("No time zone information found.")

            if self._ttinfos:
                self._tz_after = self._ttinfos[-1]
            else:
                self._tz_after = _ttinfo_list[-1]

        # Determine if this is a "fixed offset" zone, meaning that the output
        # of the utcoffset, dst and tzname functions does not depend on the
        # specific datetime passed.
        #
        # We make three simplifying assumptions here:
        #
        # 1. If _tz_after is not a _ttinfo, it has transitions that might
        #    actually occur (it is possible to construct TZ strings that
        #    specify STD and DST but no transitions ever occur, such as
        #    AAA0BBB,0/0,J365/25).
        # 2. If _ttinfo_list contains more than one _ttinfo object, the objects
        #    represent different offsets.
        # 3. _ttinfo_list contains no unused _ttinfos (in which case an
        #    otherwise fixed-offset zone with extra _ttinfos defined may
        #    appear to *not* be a fixed offset zone).
        #
        # Violations to these assumptions would be fairly exotic, and exotic
        # zones should almost certainly not be used with datetime.time (the
        # only thing that would be affected by this).
        if len(_ttinfo_list) > 1 or not isinstance(self._tz_after, _ttinfo):
            self._fixed_offset = False
        elif not _ttinfo_list:
            self._fixed_offset = True
        else:
            self._fixed_offset = _ttinfo_list[0] == self._tz_after

    @staticmethod
    def _utcoff_to_dstoff(trans_idx, utcoffsets, isdsts):
        # Now we must transform our ttis and abbrs into `_ttinfo` objects,
        # but there is an issue: .dst() must return a timedelta with the
        # difference between utcoffset() and the "standard" offset, but
        # the "base offset" and "DST offset" are not encoded in the file;
        # we can infer what they are from the isdst flag, but it is not
        # sufficient to just look at the last standard offset, because
        # occasionally countries will shift both DST offset and base offset.

        typecnt = len(isdsts)
        dstoffs = [0] * typecnt  # Provisionally assign all to 0.
        dst_cnt = sum(isdsts)
        dst_found = 0

        for i in range(1, len(trans_idx)):
            if dst_cnt == dst_found:
                break

            idx = trans_idx[i]

            dst = isdsts[idx]

            # We're only going to look at daylight saving time
            if not dst:
                continue

            # Skip any offsets that have already been assigned
            if dstoffs[idx] != 0:
                continue

            dstoff = 0
            utcoff = utcoffsets[idx]

            comp_idx = trans_idx[i - 1]

            if not isdsts[comp_idx]:
                dstoff = utcoff - utcoffsets[comp_idx]

            if not dstoff and idx < (typecnt - 1):
                comp_idx = trans_idx[i + 1]

                # If the following transition is also DST and we couldn't
                # find the DST offset by this point, we're going to have to
                # skip it and hope this transition gets assigned later
                if isdsts[comp_idx]:
                    continue

                dstoff = utcoff - utcoffsets[comp_idx]

            if dstoff:
                dst_found += 1
                dstoffs[idx] = dstoff
        else:
            # If we didn't find a valid value for a given index, we'll end up
            # with dstoff = 0 for something where `isdst=1`. This is obviously
            # wrong - one hour will be a much better guess than 0
            for idx in range(typecnt):
                if not dstoffs[idx] and isdsts[idx]:
                    dstoffs[idx] = 3600

        return dstoffs

    @staticmethod
    def _ts_to_local(trans_idx, trans_list_utc, utcoffsets):
        """Generate number of seconds since 1970 *in the local time*.

        This is necessary to easily find the transition times in local time"""
        if not trans_list_utc:
            return [[], []]

        # Start with the timestamps and modify in-place
        trans_list_wall = [list(trans_list_utc), list(trans_list_utc)]

        if len(utcoffsets) > 1:
            offset_0 = utcoffsets[0]
            offset_1 = utcoffsets[trans_idx[0]]
            if offset_1 > offset_0:
                offset_1, offset_0 = offset_0, offset_1
        else:
            offset_0 = offset_1 = utcoffsets[0]

        trans_list_wall[0][0] += offset_0
        trans_list_wall[1][0] += offset_1

        for i in range(1, len(trans_idx)):
            offset_0 = utcoffsets[trans_idx[i - 1]]
            offset_1 = utcoffsets[trans_idx[i]]

            if offset_1 > offset_0:
                offset_1, offset_0 = offset_0, offset_1

            trans_list_wall[0][i] += offset_0
            trans_list_wall[1][i] += offset_1

        return trans_list_wall


class _ttinfo:
    __slots__ = ["utcoff", "dstoff", "tzname"]

    def __init__(self, utcoff, dstoff, tzname):
        self.utcoff = utcoff
        self.dstoff = dstoff
        self.tzname = tzname

    def __eq__(self, other):
        return (
            self.utcoff == other.utcoff
            and self.dstoff == other.dstoff
            and self.tzname == other.tzname
        )

    def __repr__(self):  # pragma: nocover
        return (
            f"{self.__class__.__name__}"
            + f"({self.utcoff}, {self.dstoff}, {self.tzname})"
        )


_NO_TTINFO = _ttinfo(None, None, None)


class _TZStr:
    __slots__ = (
        "std",
        "dst",
        "start",
        "end",
        "get_trans_info",
        "get_trans_info_fromutc",
        "dst_diff",
    )

    def __init__(
        self, std_abbr, std_offset, dst_abbr, dst_offset, start=None, end=None
    ):
        self.dst_diff = dst_offset - std_offset
        std_offset = _load_timedelta(std_offset)
        self.std = _ttinfo(
            utcoff=std_offset, dstoff=_load_timedelta(0), tzname=std_abbr
        )

        self.start = start
        self.end = end

        dst_offset = _load_timedelta(dst_offset)
        delta = _load_timedelta(self.dst_diff)
        self.dst = _ttinfo(utcoff=dst_offset, dstoff=delta, tzname=dst_abbr)

        # These are assertions because the constructor should only be called
        # by functions that would fail before passing start or end
        assert start is not None, "No transition start specified"
        assert end is not None, "No transition end specified"

        self.get_trans_info = self._get_trans_info
        self.get_trans_info_fromutc = self._get_trans_info_fromutc

    def transitions(self, year):
        start = self.start.year_to_epoch(year)
        end = self.end.year_to_epoch(year)
        return start, end

    def _get_trans_info(self, ts, year, fold):
        """Get the information about the current transition - tti"""
        start, end = self.transitions(year)

        # With fold = 0, the period (denominated in local time) with the
        # smaller offset starts at the end of the gap and ends at the end of
        # the fold; with fold = 1, it runs from the start of the gap to the
        # beginning of the fold.
        #
        # So in order to determine the DST boundaries we need to know both
        # the fold and whether DST is positive or negative (rare), and it
        # turns out that this boils down to fold XOR is_positive.
        if fold == (self.dst_diff >= 0):
            end -= self.dst_diff
        else:
            start += self.dst_diff

        if start < end:
            isdst = start <= ts < end
        else:
            isdst = not (end <= ts < start)

        return self.dst if isdst else self.std

    def _get_trans_info_fromutc(self, ts, year):
        start, end = self.transitions(year)
        start -= self.std.utcoff.total_seconds()
        end -= self.dst.utcoff.total_seconds()

        if start < end:
            isdst = start <= ts < end
        else:
            isdst = not (end <= ts < start)

        # For positive DST, the ambiguous period is one dst_diff after the end
        # of DST; for negative DST, the ambiguous period is one dst_diff before
        # the start of DST.
        if self.dst_diff > 0:
            ambig_start = end
            ambig_end = end + self.dst_diff
        else:
            ambig_start = start
            ambig_end = start - self.dst_diff

        fold = ambig_start <= ts < ambig_end

        return (self.dst if isdst else self.std, fold)


def _post_epoch_days_before_year(year):
    """Get the number of days between 1970-01-01 and YEAR-01-01"""
    y = year - 1
    return y * 365 + y // 4 - y // 100 + y // 400 - EPOCHORDINAL


class _DayOffset:
    __slots__ = ["d", "julian", "hour", "minute", "second"]

    def __init__(self, d, julian, hour=2, minute=0, second=0):
        min_day = 0 + julian  # convert bool to int
        if not min_day <= d <= 365:
            raise ValueError(f"d must be in [{min_day}, 365], not: {d}")

        self.d = d
        self.julian = julian
        self.hour = hour
        self.minute = minute
        self.second = second

    def year_to_epoch(self, year):
        days_before_year = _post_epoch_days_before_year(year)

        d = self.d
        if self.julian and d >= 59 and calendar.isleap(year):
            d += 1

        epoch = (days_before_year + d) * 86400
        epoch += self.hour * 3600 + self.minute * 60 + self.second

        return epoch


class _CalendarOffset:
    __slots__ = ["m", "w", "d", "hour", "minute", "second"]

    _DAYS_BEFORE_MONTH = (
        -1,
        0,
        31,
        59,
        90,
        120,
        151,
        181,
        212,
        243,
        273,
        304,
        334,
    )

    def __init__(self, m, w, d, hour=2, minute=0, second=0):
        if not 1 <= m <= 12:
            raise ValueError("m must be in [1, 12]")

        if not 1 <= w <= 5:
            raise ValueError("w must be in [1, 5]")

        if not 0 <= d <= 6:
            raise ValueError("d must be in [0, 6]")

        self.m = m
        self.w = w
        self.d = d
        self.hour = hour
        self.minute = minute
        self.second = second

    @classmethod
    def _ymd2ord(cls, year, month, day):
        return (
            _post_epoch_days_before_year(year)
            + cls._DAYS_BEFORE_MONTH[month]
            + (month > 2 and calendar.isleap(year))
            + day
        )

    # TODO: These are not actually epoch dates as they are expressed in local time
    def year_to_epoch(self, year):
        """Calculates the datetime of the occurrence from the year"""
        # We know year and month, we need to convert w, d into day of month
        #
        # Week 1 is the first week in which day `d` (where 0 = Sunday) appears.
        # Week 5 represents the last occurrence of day `d`, so we need to know
        # the range of the month.
        first_day, days_in_month = calendar.monthrange(year, self.m)

        # This equation seems magical, so I'll break it down:
        # 1. calendar says 0 = Monday, POSIX says 0 = Sunday
        #    so we need first_day + 1 to get 1 = Monday -> 7 = Sunday,
        #    which is still equivalent because this math is mod 7
        # 2. Get first day - desired day mod 7: -1 % 7 = 6, so we don't need
        #    to do anything to adjust negative numbers.
        # 3. Add 1 because month days are a 1-based index.
        month_day = (self.d - (first_day + 1)) % 7 + 1

        # Now use a 0-based index version of `w` to calculate the w-th
        # occurrence of `d`
        month_day += (self.w - 1) * 7

        # month_day will only be > days_in_month if w was 5, and `w` means
        # "last occurrence of `d`", so now we just check if we over-shot the
        # end of the month and if so knock off 1 week.
        if month_day > days_in_month:
            month_day -= 7

        ordinal = self._ymd2ord(year, self.m, month_day)
        epoch = ordinal * 86400
        epoch += self.hour * 3600 + self.minute * 60 + self.second
        return epoch


def _parse_tz_str(tz_str):
    # The tz string has the format:
    #
    # std[offset[dst[offset],start[/time],end[/time]]]
    #
    # std and dst must be 3 or more characters long and must not contain
    # a leading colon, embedded digits, commas, nor a plus or minus signs;
    # The spaces between "std" and "offset" are only for display and are
    # not actually present in the string.
    #
    # The format of the offset is ``[+|-]hh[:mm[:ss]]``

    offset_str, *start_end_str = tz_str.split(",", 1)

    parser_re = re.compile(
        r"""
        (?P<std>[^<0-9:.+-]+|<[a-zA-Z0-9+-]+>)
        (?:
            (?P<stdoff>[+-]?\d{1,3}(?::\d{2}(?::\d{2})?)?)
            (?:
                (?P<dst>[^0-9:.+-]+|<[a-zA-Z0-9+-]+>)
                (?P<dstoff>[+-]?\d{1,3}(?::\d{2}(?::\d{2})?)?)?
            )? # dst
        )? # stdoff
        """,
        re.ASCII|re.VERBOSE
    )

    m = parser_re.fullmatch(offset_str)

    if m is None:
        raise ValueError(f"{tz_str} is not a valid TZ string")

    std_abbr = m.group("std")
    dst_abbr = m.group("dst")
    dst_offset = None

    std_abbr = std_abbr.strip("<>")

    if dst_abbr:
        dst_abbr = dst_abbr.strip("<>")

    if std_offset := m.group("stdoff"):
        try:
            std_offset = _parse_tz_delta(std_offset)
        except ValueError as e:
            raise ValueError(f"Invalid STD offset in {tz_str}") from e
    else:
        std_offset = 0

    if dst_abbr is not None:
        if dst_offset := m.group("dstoff"):
            try:
                dst_offset = _parse_tz_delta(dst_offset)
            except ValueError as e:
                raise ValueError(f"Invalid DST offset in {tz_str}") from e
        else:
            dst_offset = std_offset + 3600

        if not start_end_str:
            raise ValueError(f"Missing transition rules: {tz_str}")

        start_end_strs = start_end_str[0].split(",", 1)
        try:
            start, end = (_parse_dst_start_end(x) for x in start_end_strs)
        except ValueError as e:
            raise ValueError(f"Invalid TZ string: {tz_str}") from e

        return _TZStr(std_abbr, std_offset, dst_abbr, dst_offset, start, end)
    elif start_end_str:
        raise ValueError(f"Transition rule present without DST: {tz_str}")
    else:
        # This is a static ttinfo, don't return _TZStr
        return _ttinfo(
            _load_timedelta(std_offset), _load_timedelta(0), std_abbr
        )


def _parse_dst_start_end(dststr):
    date, *time = dststr.split("/", 1)
    type = date[:1]
    if type == "M":
        n_is_julian = False
        m = re.fullmatch(r"M(\d{1,2})\.(\d).(\d)", date, re.ASCII)
        if m is None:
            raise ValueError(f"Invalid dst start/end date: {dststr}")
        date_offset = tuple(map(int, m.groups()))
        offset = _CalendarOffset(*date_offset)
    else:
        if type == "J":
            n_is_julian = True
            date = date[1:]
        else:
            n_is_julian = False

        doy = int(date)
        offset = _DayOffset(doy, n_is_julian)

    if time:
        offset.hour, offset.minute, offset.second = _parse_transition_time(time[0])

    return offset


def _parse_transition_time(time_str):
    match = re.fullmatch(
        r"(?P<sign>[+-])?(?P<h>\d{1,3})(:(?P<m>\d{2})(:(?P<s>\d{2}))?)?",
        time_str,
        re.ASCII
    )
    if match is None:
        raise ValueError(f"Invalid time: {time_str}")

    h, m, s = (int(v or 0) for v in match.group("h", "m", "s"))

    if h > 167:
        raise ValueError(
            f"Hour must be in [0, 167]: {time_str}"
        )

    if match.group("sign") == "-":
        h, m, s = -h, -m, -s

    return h, m, s


def _parse_tz_delta(tz_delta):
    match = re.fullmatch(
        r"(?P<sign>[+-])?(?P<h>\d{1,3})(:(?P<m>\d{2})(:(?P<s>\d{2}))?)?",
        tz_delta,
        re.ASCII
    )
    # Anything passed to this function should already have hit an equivalent
    # regular expression to find the section to parse.
    assert match is not None, tz_delta

    h, m, s = (int(v or 0) for v in match.group("h", "m", "s"))

    total = h * 3600 + m * 60 + s

    if h > 24:
        raise ValueError(
            f"Offset hours must be in [0, 24]: {tz_delta}"
        )

    # Yes, +5 maps to an offset of -5h
    if match.group("sign") != "-":
        total = -total

    return total


================================================
File: /Mac/Extras.install.py
================================================
"""Recursively copy a directory but skip undesired files and
directories (CVS, backup files, pyc files, etc)"""

import sys
import os
import shutil

verbose = 1
debug = 0

def isclean(name):
    if name in ('CVS', '.cvsignore', '.svn'):
        return 0
    if name.lower() == '.ds_store': return 0
    if name.endswith('~'): return 0
    if name.endswith('.BAK'): return 0
    if name.endswith('.pyc'): return 0
    if name.endswith('.pyo'): return 0
    if name.endswith('.orig'): return 0
    return 1

def copycleandir(src, dst):
    for cursrc, dirs, files in os.walk(src):
        assert cursrc.startswith(src)
        curdst = dst + cursrc[len(src):]
        if verbose:
            print("mkdir", curdst)
        if not debug:
            if not os.path.exists(curdst):
                os.makedirs(curdst)
        for fn in files:
            if isclean(fn):
                if verbose:
                    print("copy", os.path.join(cursrc, fn), os.path.join(curdst, fn))
                if not debug:
                    shutil.copy2(os.path.join(cursrc, fn), os.path.join(curdst, fn))
            else:
                if verbose:
                    print("skipfile", os.path.join(cursrc, fn))
        for i in range(len(dirs)-1, -1, -1):
            if not isclean(dirs[i]):
                if verbose:
                    print("skipdir", os.path.join(cursrc, dirs[i]))
                del dirs[i]

def main():
    if len(sys.argv) != 3:
        sys.stderr.write("Usage: %s srcdir dstdir\n" % sys.argv[0])
        sys.exit(1)
    copycleandir(sys.argv[1], sys.argv[2])

if __name__ == '__main__':
    main()


================================================
File: /Mac/Makefile.in
================================================
# This file can be invoked from the various frameworkinstall... targets in the
# main Makefile. The next couple of variables are overridden on the
# commandline in that case.

VERSION=@VERSION@
ABIFLAGS=@ABIFLAGS@
LDVERSION=@LDVERSION@
ENSUREPIP=@ENSUREPIP@
builddir = ..
srcdir=@srcdir@
prefix=@prefix@
exec_prefix=@exec_prefix@
LIBDEST=$(prefix)/lib/python$(VERSION)
RUNSHARED=@RUNSHARED@
BUILDEXE=@BUILDEXEEXT@
BUILDPYTHON=$(builddir)/python$(BUILDEXE)
DESTDIR=
LDFLAGS=@LDFLAGS@
FRAMEWORKUNIXTOOLSPREFIX=@FRAMEWORKUNIXTOOLSPREFIX@
PYTHONFRAMEWORK=@PYTHONFRAMEWORK@
PYTHONFRAMEWORKIDENTIFIER=@PYTHONFRAMEWORKIDENTIFIER@
LIPO_32BIT_FLAGS=@LIPO_32BIT_FLAGS@
LIPO_INTEL64_FLAGS=@LIPO_INTEL64_FLAGS@
CC=@CC@
MACOSX_DEPLOYMENT_TARGET=@CONFIGURE_MACOSX_DEPLOYMENT_TARGET@
export MACOSX_DEPLOYMENT_TARGET



# These are normally glimpsed from the previous set
BINDIR=		@bindir@
PYTHONAPPSDIR=@FRAMEWORKINSTALLAPPSPREFIX@/$(PYTHONFRAMEWORK) $(VERSION)
APPINSTALLDIR=$(prefix)/Resources/Python.app

# Variables for installing the "normal" unix binaries
INSTALLED_PYTHONAPP=$(APPINSTALLDIR)/Contents/MacOS/$(PYTHONFRAMEWORK)

# Items more-or-less copied from the main Makefile
DIRMODE=755
FILEMODE=644
INSTALL=@INSTALL@
INSTALL_SYMLINK=ln -fsn
INSTALL_PROGRAM=@INSTALL_PROGRAM@
INSTALL_SCRIPT= @INSTALL_SCRIPT@
INSTALL_DATA=@INSTALL_DATA@
LN=@LN@
STRIPFLAG=-s
CPMAC=CpMac

APPTEMPLATE=$(srcdir)/Resources/app
APPSUBDIRS=MacOS Resources
compileall=$(srcdir)/../Lib/compileall.py

installapps: install_Python install_PythonLauncher install_IDLE

#
# Install unix tools in /usr/local/bin. These are just aliases for the
# actual installation inside the framework.
#
installunixtools:
	if [ ! -d "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" ]; then  \
		$(INSTALL) -d -m $(DIRMODE) "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" ;\
	fi
	cd "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" && \
	for fn in \
			idle3 \
			pydoc3 \
			python3 \
			python3-config \
			; \
	do \
		rm -f $${fn} ; \
		$(LN) -s $(BINDIR)/$${fn} $${fn} ;\
	done
	-if test "x$(VERSION)" != "x$(LDVERSION)"; then \
		cd "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" && \
		for fn in \
				python$(VERSION)-config \
				; \
		do \
			rm -f $${fn} ;\
			$(LN) -s $(BINDIR)/$${fn} $${fn} ;\
		done ;\
	fi
	-if test "x$(LIPO_32BIT_FLAGS)" != "x"; then \
		cd "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" && \
		for fn in \
				python3-32 \
				; \
		do \
			rm -f $${fn} ;\
			$(LN) -s $(BINDIR)/$${fn} $${fn} ;\
		done ;\
	fi
	-if test "x$(LIPO_INTEL64_FLAGS)" != "x"; then \
		cd "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" && \
		for fn in \
				python3-intel64 \
				; \
		do \
			rm -f $${fn} ;\
			$(LN) -s $(BINDIR)/$${fn} $${fn} ;\
		done ;\
	fi
	-if test "x$(ENSUREPIP)" != "xno"  ; then \
		cd "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" && \
		for fn in \
				pip3 \
				; \
		do \
			rm -f $${fn} ;\
			$(LN) -s $(BINDIR)/$${fn} $${fn} ;\
		done ;\
	fi

#
# Like installunixtools, but only install links to the versioned binaries.
#
altinstallunixtools:
	if [ ! -d "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" ]; then  \
		$(INSTALL) -d -m $(DIRMODE) "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" ;\
	fi
	cd "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" && \
	for fn in \
			idle$(VERSION) \
			pydoc$(VERSION) \
			python$(VERSION) \
			python$(LDVERSION)-config \
			; \
	do \
		rm -f $${fn} ;\
		$(LN) -s $(BINDIR)/$${fn} $${fn} ;\
	done
	-if test "x$(VERSION)" != "x$(LDVERSION)"; then \
		cd "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" && \
		for fn in \
				python$(LDVERSION) \
				; \
		do \
			rm -f $${fn} ;\
			$(LN) -s $(BINDIR)/$${fn} $${fn} ;\
		done ;\
	fi
	-if test "x$(LIPO_32BIT_FLAGS)" != "x"; then \
		cd "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" && \
		for fn in \
				python$(VERSION)-32 \
				; \
		do \
			rm -f $${fn} ;\
			$(LN) -s $(BINDIR)/$${fn} $${fn} ;\
		done ;\
	fi
	-if test "x$(LIPO_INTEL64_FLAGS)" != "x"; then \
		cd "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" && \
		for fn in \
				python$(VERSION)-intel64 \
				; \
		do \
			rm -f $${fn} ;\
			$(LN) -s $(BINDIR)/$${fn} $${fn} ;\
		done ;\
	fi
	-if test "x$(ENSUREPIP)" != "xno"  ; then \
		cd "$(DESTDIR)$(FRAMEWORKUNIXTOOLSPREFIX)/bin" && \
		for fn in \
				pip$(VERSION) \
				; \
		do \
			rm -f $${fn} ;\
			$(LN) -s $(BINDIR)/$${fn} $${fn} ;\
		done ;\
	fi

pythonw: $(srcdir)/Tools/pythonw.c Makefile
	$(CC) $(LDFLAGS) -DPYTHONFRAMEWORK='"$(PYTHONFRAMEWORK)"' -o $@ \
		$(srcdir)/Tools/pythonw.c -I.. -I$(srcdir)/../Include \
		../$(PYTHONFRAMEWORK).framework/Versions/$(VERSION)/$(PYTHONFRAMEWORK)

install_PythonLauncher:
	cd PythonLauncher && make install DESTDIR=$(DESTDIR)

install_Python:
	@for i in "$(PYTHONAPPSDIR)" "$(APPINSTALLDIR)" "$(APPINSTALLDIR)/Contents"; do \
		if test ! -d "$(DESTDIR)$$i"; then \
			echo "Creating directory $(DESTDIR)$$i"; \
			$(INSTALL) -d -m $(DIRMODE) "$(DESTDIR)$$i"; \
		fi;\
	done
	@for i in $(APPSUBDIRS); do \
		if test ! -d "$(DESTDIR)$(APPINSTALLDIR)/Contents/$$i"; then \
			echo "Creating directory $(DESTDIR)$(APPINSTALLDIR)/Contents/$$i"; \
			$(INSTALL) -d -m $(DIRMODE) "$(DESTDIR)$(APPINSTALLDIR)/Contents/$$i"; \
		else	true; \
		fi; \
	done
	@for d in . $(APPSUBDIRS); \
	do \
		a=$(APPTEMPLATE)/$$d; \
		if test ! -d $$a; then continue; else true; fi; \
		b="$(DESTDIR)$(APPINSTALLDIR)/Contents/$$d"; \
		for i in $$a/*; \
		do \
			case $$i in \
			*CVS) ;; \
			*.svn) ;; \
			*.py[co]) ;; \
			*.orig) ;; \
			*~) ;; \
			*idx) \
				echo $(CPMAC) "$$i" $$b; \
				$(CPMAC) "$$i" "$$b"; \
				;; \
			*) \
				if test -d $$i; then continue; fi; \
				if test -x $$i; then \
				    echo $(INSTALL_SCRIPT) "$$i" "$$b"; \
				    $(INSTALL_SCRIPT) "$$i" "$$b"; \
				else \
				    echo $(INSTALL_DATA) "$$i" "$$b"; \
				    $(INSTALL_DATA) "$$i" "$$b"; \
				fi;; \
			esac; \
		done; \
	done
	$(INSTALL_PROGRAM) $(STRIPFLAG) $(BUILDPYTHON) "$(DESTDIR)$(APPINSTALLDIR)/Contents/MacOS/$(PYTHONFRAMEWORK)"
	sed -e "s!%bundleid%!$(PYTHONFRAMEWORKIDENTIFIER)!g" \
		-e "s!%version%!`$(RUNSHARED) $(BUILDPYTHON) \
		-c 'import platform; print(platform.python_version())'`!g" \
		< "$(DESTDIR)$(APPINSTALLDIR)/Contents/Info.plist.in" \
		> "$(DESTDIR)$(APPINSTALLDIR)/Contents/Info.plist"
	rm "$(DESTDIR)$(APPINSTALLDIR)/Contents/Info.plist.in"


install_IDLE:
	test -d "$(DESTDIR)$(PYTHONAPPSDIR)" || mkdir -p "$(DESTDIR)$(PYTHONAPPSDIR)"
	-test -d "$(DESTDIR)$(PYTHONAPPSDIR)/IDLE.app" && rm -rf "$(DESTDIR)$(PYTHONAPPSDIR)/IDLE.app"
	/bin/cp -PR "$(srcdir)/IDLE/IDLE.app" "$(DESTDIR)$(PYTHONAPPSDIR)"
	ln -sf "$(INSTALLED_PYTHONAPP)" "$(DESTDIR)$(PYTHONAPPSDIR)/IDLE.app/Contents/MacOS/Python"
	sed -e "s!%prefix%!$(prefix)!g" -e 's!%exe%!$(PYTHONFRAMEWORK)!g' < "$(srcdir)/IDLE/IDLE.app/Contents/MacOS/IDLE" > "$(DESTDIR)$(PYTHONAPPSDIR)/IDLE.app/Contents/MacOS/IDLE"
	sed "s!%version%!`$(RUNSHARED) $(BUILDPYTHON) -c 'import platform; print(platform.python_version())'`!g" < "$(srcdir)/IDLE/IDLE.app/Contents/Info.plist" > "$(DESTDIR)$(PYTHONAPPSDIR)/IDLE.app/Contents/Info.plist"
	if [ -f "$(DESTDIR)$(LIBDEST)/idlelib/config-main.def" ]; then \
		/bin/cp -p "$(DESTDIR)$(LIBDEST)/idlelib/config-main.def" \
			"$(DESTDIR)$(LIBDEST)/idlelib/config-main.def~" ; \
		sed -e 's!name= IDLE Classic Windows!name= IDLE Classic OSX!g' \
			< "$(DESTDIR)$(LIBDEST)/idlelib/config-main.def~" \
			> "$(DESTDIR)$(LIBDEST)/idlelib/config-main.def" ; \
		rm "$(DESTDIR)$(LIBDEST)/idlelib/config-main.def~" ; \
	fi
	if [ -f "$(DESTDIR)$(LIBDEST)/idlelib/config-extensions.def" ]; then \
		/bin/cp -p "$(DESTDIR)$(LIBDEST)/idlelib/config-extensions.def" \
			"$(DESTDIR)$(LIBDEST)/idlelib/config-extensions.def~" ; \
		sed -e 's!zoom-height=<Alt-Key-2>!zoom-height=<Option-Key-0>!g' \
			-e 's!<Alt-Key-!<Option-Key-!g' \
			< "$(DESTDIR)$(LIBDEST)/idlelib/config-extensions.def~" \
			> "$(DESTDIR)$(LIBDEST)/idlelib/config-extensions.def" ; \
		rm "$(DESTDIR)$(LIBDEST)/idlelib/config-extensions.def~" ; \
	fi
	touch "$(DESTDIR)$(PYTHONAPPSDIR)/IDLE.app"
	chmod -R ugo+rX,go-w "$(DESTDIR)$(PYTHONAPPSDIR)/IDLE.app"
	chmod ugo+x "$(DESTDIR)$(PYTHONAPPSDIR)/IDLE.app/Contents/MacOS/IDLE"

$(INSTALLED_PYTHONAPP): install_Python

installextras: $(srcdir)/Extras.install.py
	$(INSTALL) -d "$(DESTDIR)$(prefix)/share/doc/python$(VERSION)/examples"
	$(RUNSHARED) $(BUILDPYTHON) $(srcdir)/Extras.install.py $(srcdir)/../Tools \
		"$(DESTDIR)$(prefix)/share/doc/python$(VERSION)/examples/Tools" ; \
		chmod -R ugo+rX,go-w "$(DESTDIR)$(prefix)/share/doc/python$(VERSION)/examples/Tools"

clean:
	rm pythonw
	cd PythonLauncher && make clean

Makefile: $(srcdir)/Makefile.in ../config.status
	cd .. && CONFIG_FILES=Mac/Makefile CONFIG_HEADERS= $(SHELL) ./config.status


================================================
File: /Mac/README.rst
================================================
======================
Python on macOS README
======================

:Authors:
    Jack Jansen (2004-07),
    Ronald Oussoren (2010-04),
    Ned Deily (2012-06)

This document provides a quick overview of some macOS specific features in
the Python distribution.

Compilers for building on macOS
===============================

The core developers primarily test builds on macOS with Apple's compiler tools,
either Xcode or the Command Line Tools.  For these we only support building with
a compiler that includes an SDK that targets the OS on the build machine, that is
the version of Xcode that shipped with the OS version or one newer.

For example, for macOS 12 we support Xcode 13 and Xcode 14 (or the corresponding
Command Line Tools).

Building with other compilers, such as GCC, likely works, but is not actively supported.

macOS specific arguments to configure
=====================================

* ``--enable-framework[=DIR]``

  If this argument is specified the build will create a Python.framework rather
  than a traditional Unix install. See the section
  _`Building and using a framework-based Python on macOS` for more
  information on frameworks.

  If the optional directory argument is specified the framework is installed
  into that directory. This can be used to install a python framework into
  your home directory::

     $ ./configure --enable-framework=/Users/ronald/Library/Frameworks
     $ make && make install

  This will install the framework itself in ``/Users/ronald/Library/Frameworks``,
  the applications in a subdirectory of ``/Users/ronald/Applications`` and the
  command-line tools in ``/Users/ronald/bin``.

* ``--with-framework-name=NAME``

  Specify the name for the python framework, defaults to ``Python``. This option
  is only valid when ``--enable-framework`` is specified.

* ``--enable-universalsdk[=PATH]``

  Create a universal binary build of Python. This can be used with both
  regular and framework builds.

  The optional argument specifies which macOS SDK should be used to perform the
  build.  In most cases on current systems, you do not need to specify PATH or
  you can just use ``/``; the default MacOSX SDK for the active Xcode or Command
  Line Tools developer directory will be used.  See the macOS ``xcrun`` man page
  for more information.  Current versions of macOS and Xcode no longer install
  system header files in their traditional locations, like ``/usr/include`` and
  ``/System/Library/Frameworks``; instead they are found within a MacOSX SDK.
  The Apple-supplied build tools handle this transparently and current
  versions of Python now handle this as well.  So it is no longer necessary,
  and since macOS 10.14, no longer possible to force the installation of system
  headers with ``xcode-select``.

* ``--with-universal-archs=VALUE``

  Specify the kind of universal binary that should be created. This option is
  only valid when ``--enable-universalsdk`` is specified.  The default is
  ``32-bit`` if building with a SDK that supports PPC, otherwise defaults
  to ``intel``.  Note that ``intel`` means a universal build of both 32-bit
  and 64-bit binaries and that may not be what you want; for example,
  as of macOS 10.15 Catalina, 32-bit execution is no longer supported by
  the operating system.  Thus it is best to either explicitly specify
  values for ``--with-universal-archs``:

      ``--enable-universalsdk --with-universal-archs=intel-64``

  or avoid using either.


Building and using a universal binary of Python on macOS
========================================================

1. What is a universal binary
-----------------------------

A universal binary build of Python contains object code for more than one
CPU architecture.  A universal macOS executable file or library combines the
architecture-specific code into one file and can therefore run at native
speed on all supported architectures.  Universal files were introduced in
macOS 10.4 to add support for Intel-based Macs to the existing PowerPC (PPC)
machines.  In macOS 10.5 support was extended to 64-bit Intel and 64-bit PPC
architectures.  It is possible to build Python with various combinations
of architectures depending on the build tools and macOS version in use.
Note that PPC support was removed in macOS 10.7 and 32-bit Intel support
was removed in macOS 10.15.  So currently as of macOS 10.15, macOS only
supports one execution architecture, 64-bit Intel (``x86_64``).

2. How do I build a universal binary
------------------------------------

You can enable universal binaries by specifying the "--enable-universalsdk"
flag to configure::

  $ ./configure --enable-universalsdk
  $ make
  $ make install

This flag can be used with a framework build of python, but also with a classic
unix build. Universal builds were first supported with macOS 10.4 with Xcode 2.1
and the 10.4u SDK.  Starting with Xcode 3 and macOS 10.5, more configurations are
available.

In general, universal builds depend on specific features provided by the
Apple-supplied compilers and other build tools included in Apple's Xcode
development tools.  You should install Xcode or the command line tools
component appropriate for the macOS release you are running on.  See the
Python Developer's Guide (https://devguide.python.org/setup/)
for more information.

2.1 Flavors of universal binaries
.................................

It is possible to build a number of flavors of the universal binary build,
the default is a 32-bit only binary (i386 and ppc) in build environments that
support ppc (10.4 with Xcode 2, 10.5 and 10.6 with Xcode 3) or an
Intel-32/-64-bit binary (i386 and X86_64) in build environments that do not
support ppc (Xcode 4 on 10.6 and later systems).  The flavor can be specified
using the configure option ``--with-universal-archs=VALUE``. The following
values are available:

  * ``universal2``: ``arm64``, ``x86_64``

  * ``intel``:	  ``i386``, ``x86_64``

  * ``intel-32``: ``i386``

  * ``intel-64``: ``x86_64``

  * ``32-bit``:   ``ppc``, ``i386``

  * ``3-way``:	  ``i386``, ``x86_64``, ``ppc``

  * ``64-bit``:   ``ppc64``, ``x86_64``

  * ``all``:      ``ppc``, ``ppc64``, ``i386``, ``x86_64``

To build a universal binary that includes a 64-bit architecture, you must build
on a system running macOS 10.5 or later.  The ``all`` and ``64-bit`` flavors can
only be built with a 10.5 SDK because ``ppc64`` support was only included with
macOS 10.5.  Although legacy ``ppc`` support was included with Xcode 3 on macOS
10.6, it was removed in Xcode 4, versions of which were released on macOS 10.6
and which is the standard for macOS 10.7.  To summarize, the
following combinations of SDKs and universal-archs flavors are available:

  * 10.4u SDK with Xcode 2 supports ``32-bit`` only

  * 10.5 SDK with Xcode 3.1.x supports all flavors

  * 10.6 SDK with Xcode 3.2.x supports ``intel``, ``intel-32``,
    ``intel-64``, ``3-way``, and ``32-bit``

  * 10.6 SDK with Xcode 4 supports ``intel``, ``intel-32``, and ``intel-64``

  * 10.7 through 10.14 SDKs support ``intel``, ``intel-32``, and ``intel-64``

  * 10.15 and later SDKs support ``intel-64`` only

  * 11.0 and later SDKs support ``universal2``

The makefile for a framework build will also install ``python3.x-32``
binaries when the universal architecture includes at least one 32-bit
architecture (that is, for all flavors but ``64-bit`` and ``intel-64``).
It will also install ``python3.x-intel64`` binaries in the ``universal2``
case to allow easy execution with the Rosetta 2 Intel emulator on Apple
Silicon Macs.

Running a specific architecture
...............................

You can run code using a specific architecture using the ``arch`` command::

   $ arch -i386 python

Or to explicitly run in 32-bit mode, regardless of the machine hardware::

   $ arch -i386 -ppc python

Using ``arch`` is not a perfect solution as the selected architecture will
not automatically carry through to subprocesses launched by programs and tests
under that Python.  If you want to ensure that Python interpreters launched in
subprocesses also run in 32-bit-mode if the main interpreter does, use
a ``python3.x-32`` binary and use the value of ``sys.executable`` as the
``subprocess`` ``Popen`` executable value.

Likewise, use ``python3.x-intel64`` to force execution in ``x86_64`` mode
with ``universal2`` binaries.

Building and using a framework-based Python on macOS
====================================================


1. Why would I want a framework Python instead of a normal static Python?
-------------------------------------------------------------------------

The main reason is because you want to create GUI programs in Python. With the
exception of X11/XDarwin-based GUI toolkits all GUI programs need to be run
from a macOS application bundle (".app").

While it is technically possible to create a .app without using frameworks you
will have to do the work yourself if you really want this.

A second reason for using frameworks is that they put Python-related items in
only two places: "/Library/Framework/Python.framework" and
"/Applications/Python <VERSION>" where ``<VERSION>`` can be e.g. "3.8",
"2.7", etc.  This simplifies matters for users installing
Python from a binary distribution if they want to get rid of it again. Moreover,
due to the way frameworks work, users without admin privileges can install a
binary distribution in their home directory without recompilation.

2. How does a framework Python differ from a normal static Python?
------------------------------------------------------------------

In everyday use there is no difference, except that things are stored in
a different place. If you look in /Library/Frameworks/Python.framework
you will see lots of relative symlinks, see the Apple documentation for
details. If you are used to a normal unix Python file layout go down to
Versions/Current and you will see the familiar bin and lib directories.

3. Do I need extra packages?
----------------------------

Yes, probably.  If you want Tkinter support you need to get the macOS AquaTk
distribution, this is installed by default on macOS 10.4 or later.  Be
aware, though, that the Cocoa-based AquaTk's supplied starting with macOS
10.6 have proven to be unstable.  If possible, you should consider
installing a newer version before building on macOS 10.6 or later, such as
the ActiveTcl 8.6.  See https://www.python.org/download/mac/tcltk/.  If you
are building with an SDK, ensure that the newer Tcl and Tk frameworks are
seen in the SDK's ``Library/Frameworks`` directory; you may need to
manually create symlinks to their installed location, ``/Library/Frameworks``.
If you want wxPython you need to get that.
If you want Cocoa you need to get PyObjC.

4. How do I build a framework Python?
-------------------------------------

This directory contains a Makefile that will create a couple of python-related
applications (full-blown macOS .app applications, that is) in
"/Applications/Python <VERSION>", and a hidden helper application Python.app
inside the Python.framework, and unix tools including "python" into
/usr/local/bin.  In addition it has a target "installmacsubtree" that installs
the relevant portions of the Mac subtree into the Python.framework.

It is normally invoked indirectly through the main Makefile, as the last step
in the sequence

 1. ./configure --enable-framework

 2. make

 3. make install

This sequence will put the framework in ``/Library/Framework/Python.framework``,
the applications in ``/Applications/Python <VERSION>`` and the unix tools in
``/usr/local/bin``.

Installing in another place, for instance ``$HOME/Library/Frameworks`` if you
have no admin privileges on your machine, is possible. This can be accomplished
by configuring with ``--enable-framework=$HOME/Library/Frameworks``.
The other two directories will then also be installed in your home directory,
at ``$HOME/Applications/Python-<VERSION>`` and ``$HOME/bin``.

If you want to install some part, but not all, read the main Makefile. The
frameworkinstall is composed of a couple of sub-targets that install the
framework itself, the Mac subtree, the applications and the unix tools.

There is an extra target frameworkinstallextras that is not part of the
normal frameworkinstall which installs the Tools directory into
"/Applications/Python <VERSION>", this is useful for binary
distributions.

What do all these programs do?
==============================

"IDLE.app" is an integrated development environment for Python: editor,
debugger, etc.

"Python Launcher.app" is a helper application that will handle things when you
double-click a .py, .pyc or .pyw file. For the first two it creates a Terminal
window and runs the scripts with the normal command-line Python. For the
latter it runs the script in the Python.app interpreter so the script can do
GUI-things. Keep the ``Option`` key depressed while dragging or double-clicking
a script to set runtime options. These options can be set persistently
through Python Launcher's preferences dialog.

The program ``pythonx.x`` runs python scripts from the command line.
Previously, various compatibility aliases were also installed, including
``pythonwx.x`` which in early releases of Python on macOS was required to run
GUI programs.  As of 3.4.0, the ``pythonwx.x`` aliases are no longer installed.

How do I create a binary distribution?
======================================

Download and unpack the source release from https://www.python.org/download/.
Go to the directory ``Mac/BuildScript``. There you will find a script
``build-installer.py`` that does all the work. This will download and build
a number of 3rd-party libraries, configures and builds a framework Python,
installs it, creates the installer package files and then packs this in a
DMG image.  The script also builds an HTML copy of the current Python
documentation set for this release for inclusion in the framework.  The
installer package will create links to the documentation for use by IDLE,
pydoc, shell users, and Finder user.

The script will build a universal binary so you'll therefore have to run this
script on macOS 10.4 or later and with Xcode 2.1 or later installed.
However, the Python build process itself has several build dependencies not
available out of the box with macOS 10.4 so you may have to install
additional software beyond what is provided with Xcode 2.
It should be possible to use SDKs and/or older
versions of Xcode to build installers that are compatible with older systems
on a newer system but this may not be completely foolproof so the resulting
executables, shared libraries, and ``.so`` bundles should be carefully
examined and tested on all supported systems for proper dynamic linking
dependencies.  It is safest to build the distribution on a system running the
minimum macOS version supported.

All of this is normally done completely isolated in /tmp/_py, so it does not
use your normal build directory nor does it install into /.

Because of the way the script locates the files it needs you have to run it
from within the BuildScript directory. The script accepts a number of
command-line arguments, run it with --help for more information.

Configure warnings
==================

The configure script sometimes emits warnings like the one below::

   configure: WARNING: libintl.h: present but cannot be compiled
   configure: WARNING: libintl.h:     check for missing prerequisite headers?
   configure: WARNING: libintl.h: see the Autoconf documentation
   configure: WARNING: libintl.h:     section "Present But Cannot Be Compiled"
   configure: WARNING: libintl.h: proceeding with the preprocessor's result
   configure: WARNING: libintl.h: in the future, the compiler will take precedence
   configure: WARNING:     ## -------------------------------------------------------- ##
   configure: WARNING:     ## Report this to https://github.com/python/cpython/issues/ ##
   configure: WARNING:     ## -------------------------------------------------------- ##

This almost always means you are trying to build a universal binary for
Python and have libraries in ``/usr/local`` that don't contain the required
architectures. Temporarily move ``/usr/local`` aside to finish the build.


Uninstalling a framework install, including the binary installer
================================================================

Uninstalling a framework can be done by manually removing all bits that got installed.
That's true for both installations from source and installations using the binary installer.
macOS does not provide a central uninstaller.

The main bit of a framework install is the framework itself, installed in
``/Library/Frameworks/Python.framework``. This can contain multiple versions
of Python, if you want to remove just one version you have to remove the
version-specific subdirectory: ``/Library/Frameworks/Python.framework/Versions/X.Y``.
If you do that, ensure that ``/Library/Frameworks/Python.framework/Versions/Current``
is a symlink that points to an installed version of Python.

A framework install also installs some applications in ``/Applications/Python X.Y``,

And lastly a framework installation installs files in ``/usr/local/bin``, all of
them symbolic links to files in ``/Library/Frameworks/Python.framework/Versions/X.Y/bin``.

Weak linking support
====================

The CPython sources support building with the latest SDK while targeting deployment
to macOS 10.9. This is done through weak linking of symbols introduced in macOS
10.10 or later and checking for their availability at runtime.

This requires the use of Apple's compiler toolchain on macOS 10.13 or later.

The basic implementation pattern is:

* ``HAVE_<FUNCTION>`` is a macro defined (or not) by the configure script

* ``HAVE_<FUNCTION>_RUNTIME`` is a macro defined in the relevant source
  files. This expands to a call to ``__builtin_available`` when using
  a new enough Apple compiler, and to a true value otherwise.

* Use ``HAVE_<FUNCTION>_RUNTIME`` before calling ``<function>``. This macro
  *must* be used a the sole expression in an if statement::

   if (HAVE_<FUNCTION>_RUNTIME) {
     /* <function> is available */
   }

  Or:

   if (HAVE_<FUNCTION>_RUNTIME) {} else {
     /* <function> is not available */
   }

  Using other patterns (such as ``!HAVE_<FUNCTION>_RUNTIME``) is not supported
  by Apple's compilers.


Resources
=========

  *  https://www.python.org/downloads/macos/

  *  https://www.python.org/community/sigs/current/pythonmac-sig/

  *  https://devguide.python.org/


================================================
File: /Mac/BuildScript/README.rst
================================================
Building a Python Mac OS X distribution
=======================================

The ``build-install.py`` script creates Python distributions, including
certain third-party libraries as necessary.  It builds a complete
framework-based Python out-of-tree, installs it in a funny place with
$DESTROOT, massages that installation to remove .pyc files and such, creates
an Installer package from the installation plus other files in ``resources``
and ``scripts`` and placed that on a ``.dmg`` disk image.
The installer package built on the dmg is a macOS bundle format installer
package. This format is deprecated and is no longer supported by modern
macOS systems; it is usable on macOS 10.6 and earlier systems.
To be usable on newer versions of macOS, the bits in the bundle package
must be assembled in a macOS flat installer package, using current
versions of the pkgbuild and productbuild utilities. To pass macoS
Gatekeeper download quarantine, the final package must be signed
with a valid Apple Developer ID certificate using productsign.
Starting with macOS 10.15 Catalina, Gatekeeper now also requires
that installer packages are submitted to and pass Apple's automated
notarization service using the ``notarytool`` command.  To pass notarization,
the binaries included in the package must be built with at least
the macOS 10.9 SDK, must now be signed with the codesign utility,
and executables must opt in to the hardened run time option with
any necessary entitlements.  Details of these processes are
available in the on-line Apple Developer Documentation and man pages.

A goal of PSF-provided (python.org) Python binaries for macOS is to
support a wide-range of operating system releases with one set of
binaries.  Currently, the oldest release supported by python.org
binaries is macOS 10.9; it should still be possible to build Python and
Python installers on older versions of macOS but we not regularly
test on those systems nor provide binaries for them.

Prior to Python 3.9.1, no Python releases supported building on a
newer version of macOS that will run on older versions
by setting MACOSX_DEPLOYMENT_TARGET. This is because the various
Python C modules did not yet support runtime testing of macOS
feature availability (for example, by using macOS AvailabilityMacros.h
and weak-linking). To build a Python that is to be used on a
range of macOS releases, it was necessary to always build on the
oldest release to be supported; the necessary shared libraries for
that release will normally also be available on later systems,
with the occasional exception such as the removal of 32-bit
libraries in macOS 10.15. For 3.9.x and recent earlier systems,
PSF practice was to provide a "macOS 64-bit Intel installer" variant
that was built on 10.9 that would run on macOS 10.9 and later.

Starting with 3.9.1, Python fully supports macOS "weaklinking",
meaning it is now possible to build a Python on a current macOS version
with a deployment target of an earlier macOS system. For 3.9.1 and
later systems, we provide a "macOS 64-bit universal2 installer"
variant, currently built on macOS 11 Big Sur with fat binaries
natively supporting both Apple Silicon (arm64) and Intel-64
(x86_64) Macs running macOS 10.9 or later.

build-installer.py requires Apple Developer tools, either from the
Command Line Tools package or from a full Xcode installation.
You should use the most recent version of either for the operating
system version in use.  (One notable exception: on macOS 10.6,
Snow Leopard, use Xcode 3, not Xcode 4 which was released later
in the 10.6 support cycle.) build-installer.py also must be run
with recent versions of Python 3.x. On older systems,
due to changes in TLS practices, it may be easier to manually
download and cache third-party source distributions used by
build-installer.py rather than have it attempt to automatically
download them.

1.  universal2, arm64 and x86_64, for OS X 10.9 (and later)::

        /path/to/bootstrap/python3 build-installer.py \
            --universal-archs=universal2 \
            --dep-target=10.9

    - builds the following third-party libraries

        * OpenSSL 3.0.x
        * Tcl/Tk 8.6.x
        * NCurses
        * SQLite
        * XZ
        * mpdecimal

    - uses system-supplied versions of third-party libraries

        * readline module links with Apple BSD editline (libedit)
        * zlib
        * bz2

    - recommended build environment:

        * Mac OS X 11 or later
        * Xcode Command Line Tools 12.5 or later
        * current default macOS SDK
        * ``MACOSX_DEPLOYMENT_TARGET=10.9``
        * Apple ``clang``


General Prerequisites
---------------------

* No Fink (in ``/sw``) or MacPorts (in ``/opt/local``) or Homebrew or
  other local libraries or utilities (in ``/usr/local``) as they could
  interfere with the build.

* It is safest to start each variant build with an empty source directory
  populated with a fresh copy of the untarred source or a source repo.

* It is recommended that you remove any existing installed version of the
  Python being built::

      sudo rm -rf /Library/Frameworks/Python.framework/Versions/n.n



================================================
File: /Mac/BuildScript/backport_gh110950_fix.patch
================================================
From https://core.tcl-lang.org/tk/info/ed7cfbac8db11aa0

Note: the diff here is hand-tweaked so that it applies cleanly to both Tk 8.6.8 and 8.6.13.

diff --git a/macosx/tkMacOSXInit.c b/macosx/tkMacOSXInit.c
index 71d7c3385..e6a68356c 100644
--- a/macosx/tkMacOSXInit.c
+++ b/macosx/tkMacOSXInit.c
@@ -128,6 +128,16 @@ static int		TkMacOSXGetAppPathCmd(ClientData cd, Tcl_Interp *ip,
     observe(NSApplicationDidChangeScreenParametersNotification, displayChanged:);
     observe(NSTextInputContextKeyboardSelectionDidChangeNotification, keyboardChanged:);
 #undef observe
+}
+
+
+/*
+ * Fix for 10b38a7a7c.
+ */
+
+- (BOOL)applicationSupportsSecureRestorableState:(NSApplication *)app
+{
+    return YES;
 }
 
 -(void)applicationWillFinishLaunching:(NSNotification *)aNotification


================================================
File: /Mac/BuildScript/backport_gh71383_fix.patch
================================================
Adapted from https://core.tcl-lang.org/tk/info/b1876b9ebc4b

Index: generic/tkInt.h
==================================================================
--- a/generic/tkInt.h.orig
+++ b/generic/tkInt.h
@@ -1094,10 +1094,11 @@
 /*
  * Themed widget set init function:
  */
 
 MODULE_SCOPE int	Ttk_Init(Tcl_Interp *interp);
+MODULE_SCOPE void	Ttk_TkDestroyedHandler(Tcl_Interp *interp);
 
 /*
  * Internal functions shared among Tk modules but not exported to the outside
  * world:
  */

Index: generic/tkWindow.c
==================================================================
--- a/generic/tkWindow.c.orig
+++ b/generic/tkWindow.c
@@ -1619,10 +1619,11 @@
 	    TkBindFree(winPtr->mainPtr);
 	    TkDeleteAllImages(winPtr->mainPtr);
 	    TkFontPkgFree(winPtr->mainPtr);
 	    TkFocusFree(winPtr->mainPtr);
 	    TkStylePkgFree(winPtr->mainPtr);
+	    Ttk_TkDestroyedHandler(winPtr->mainPtr->interp);
 
 	    /*
 	     * When embedding Tk into other applications, make sure that all
 	     * destroy events reach the server. Otherwise the embedding
 	     * application may also attempt to destroy the windows, resulting

Index: generic/ttk/ttkTheme.c
==================================================================
--- a/generic/ttk/ttkTheme.c.orig
+++ b/generic/ttk/ttkTheme.c
@@ -415,17 +415,10 @@
     StylePackageData *pkgPtr = (StylePackageData *)clientData;
     Tcl_HashSearch search;
     Tcl_HashEntry *entryPtr;
     Cleanup *cleanup;
 
-    /*
-     * Cancel any pending ThemeChanged calls:
-     */
-    if (pkgPtr->themeChangePending) {
-	Tcl_CancelIdleCall(ThemeChangedProc, pkgPtr);
-    }
-
     /*
      * Free themes.
      */
     entryPtr = Tcl_FirstHashEntry(&pkgPtr->themeTable, &search);
     while (entryPtr != NULL) {
@@ -528,10 +521,29 @@
     if (!pkgPtr->themeChangePending) {
 	Tcl_DoWhenIdle(ThemeChangedProc, pkgPtr);
 	pkgPtr->themeChangePending = 1;
     }
 }
+
+/* Ttk_TkDestroyedHandler --
+ *	See bug [310c74ecf440]: idle calls to ThemeChangedProc()
+ *	need to be canceled when Tk is destroyed, since the interp
+ *	may still be active afterward; canceling them from
+ *	Ttk_StylePkgFree() would be too late.
+ */
+void Ttk_TkDestroyedHandler(
+    Tcl_Interp* interp)
+{
+    StylePackageData* pkgPtr = GetStylePackageData(interp);
+
+    /*
+     * Cancel any pending ThemeChanged calls:
+     */
+    if (pkgPtr->themeChangePending) {
+	Tcl_CancelIdleCall(ThemeChangedProc, pkgPtr);
+    }
+}
 
 /*
  * Ttk_CreateTheme --
  *	Create a new theme and register it in the global theme table.
  *



================================================
File: /Mac/BuildScript/seticon.m
================================================
/*
 * Simple tool for setting an icon on a file.
 */
#import <Cocoa/Cocoa.h>
#include <stdio.h>

int main(int argc, char** argv)
{
	if (argc != 3) {
		fprintf(stderr, "Usage: seticon ICON TARGET");
		return 1;
	}

	NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];
	NSString* iconPath = [NSString stringWithUTF8String:argv[1]];
	NSString* filePath = [NSString stringWithUTF8String:argv[2]];

	[NSApplication sharedApplication];

	[[NSWorkspace sharedWorkspace]
		setIcon: [[NSImage alloc] initWithContentsOfFile: iconPath]
		forFile: filePath
		options: 0];
	[pool release];
	return 0;
}


================================================
File: /Mac/BuildScript/tk868_on_10_8_10_9.patch
================================================
Fix build failure with +quartz variant on OS X 10.8 and 10.9.
Even though Gestalt was deprecated in OS X 10.8, it should work fine
through OS X 10.9, and its replacement NSOperatingSystemVersion was
not introduced until OS X 10.10.

Patch from MacPorts project and reported upstream:
https://trac.macports.org/ticket/55649
--- tk8.6.8/macosx/tkMacOSXXStubs.c.orig	2017-12-06 09:25:08.000000000 -0600
+++ tk8.6.8-patched/macosx/tkMacOSXXStubs.c	2018-01-06 19:34:17.000000000 -0600
@@ -175,7 +175,7 @@
     {
 	int major, minor, patch;
 
-#if MAC_OS_X_VERSION_MIN_REQUIRED < 1080
+#if MAC_OS_X_VERSION_MIN_REQUIRED < 101000
 	Gestalt(gestaltSystemVersionMajor, (SInt32*)&major);
 	Gestalt(gestaltSystemVersionMinor, (SInt32*)&minor);
 	Gestalt(gestaltSystemVersionBugFix, (SInt32*)&patch);


================================================
File: /Mac/BuildScript/resources/Conclusion.rtf
================================================
{\rtf1\ansi\ansicpg1252\cocoartf1561\cocoasubrtf200
{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fnil\fcharset0 LucidaGrande-Bold;\f2\fnil\fcharset0 LucidaGrande;
\f3\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww10540\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs28 \cf0 Congratulations!
\fs24   
\f1\b\fs28 Python $FULL_VERSION for macOS $MACOSX_DEPLOYMENT_TARGET
\f2\b0  was successfully installed.
\fs24 \
\
One more thing: to verify the identity of secure network connections, this Python needs a set of SSL root certificates.  You can download and install a current curated set from {\field{\*\fldinst{HYPERLINK "https://pypi.org/project/certifi/"}}{\fldrslt the Certifi project}} by double-clicking on the 
\f3 Install Certificates
\f2  icon in {\field{\*\fldinst{HYPERLINK "file://localhost/Applications/Python%20$VERSION/"}}{\fldrslt the Finder window}}.  See {\field{\*\fldinst{HYPERLINK "file://localhost/Applications/Python%20$VERSION/ReadMe.rtf"}}{\fldrslt the 
\f3 ReadMe
\f2  file}} for more information.\
}

================================================
File: /Mac/BuildScript/resources/License.rtf
================================================
{\rtf1\ansi\ansicpg1252\cocoartf2513
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;\f2\fmodern\fcharset0 CourierNewPS-BoldMT;
\f3\fmodern\fcharset0 CourierNewPSMT;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww18500\viewh13520\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b\fs36 \cf0 \ul \ulc0 HISTORY AND LICENSE\

\fs24 \
HISTORY OF THE SOFTWARE\

\f1\b0 \ulnone \
Python was created in the early 1990s by Guido van Rossum at Stichting Mathematisch Centrum (CWI, see https://www.cwi.nl) in the Netherlands as a successor of a language called ABC. Guido remains Python's principal author, although it includes many contributions from others.\
\
In 1995, Guido continued his work on Python at the Corporation for National Research Initiatives (CNRI, see https://www.cnri.reston.va.us) in Reston, Virginia where he released several versions of the software.\
\
In May 2000, Guido and the Python core development team moved to BeOpen.com to form the BeOpen PythonLabs team. In October of the same year, the PythonLabs team moved to Digital Creations (now Zope Corporation, see https://www.zope.dev). In 2001, the Python Software Foundation (PSF, see https://www.python.org/psf/) was formed, a non-profit organization created specifically to own Python-related Intellectual Property. Zope Corporation is a sponsoring member of the PSF.\
\
All Python releases are Open Source (see https://opensource.org for the Open Source Definition). Historically, most, but not all, Python releases have also been GPL-compatible; the table below summarizes the various releases.\
\

\f2\b Release         Derived     Year        Owner       GPL-\
                from                                compatible?\

\f3\b0 \
0.9.0 thru 1.2  n/a         1991-1995   CWI         yes\
1.3 thru 1.5.2  1.2         1995-1999   CNRI        yes\
1.6             1.5.2       2000        CNRI        no\
2.0             1.6         2000        BeOpen.com  no\
1.6.1           1.6         2001        CNRI        no\
2.1             2.0+1.6.1   2001        PSF         no\
2.0.1           2.0+1.6.1   2001        PSF         yes\
2.1.1           2.1+2.0.1   2001        PSF         yes\
2.1.2           2.1.1       2002        PSF         yes\
2.1.3           2.1.2       2002        PSF         yes\
2.2 and above   2.1.1       2001-now    PSF         yes\

\f1 \

\f0\b Note:  
\f1\b0 GPL-compatible doesn't mean that we're distributing Python under the GPL. All Python licenses, unlike the GPL, let you distribute a modified version without making your changes open source. The GPL-compatible licenses make it possible to combine Python with other software that is released under the GPL; the others don't.\
\
Thanks to the many outside volunteers who have worked under Guido's direction to make these releases possible.\
\
\

\f0\b \ul TERMS AND CONDITIONS FOR ACCESSING OR OTHERWISE USING PYTHON\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b0 \cf0 \ulnone Python software and documentation are licensed under the Python Software Foundation License Version 2.\
\
Starting with Python 3.8.6, examples, recipes, and other code in the documentation are dual licensed under the PSF License Version 2 and the Zero-Clause BSD license.\
\
Some software incorporated into Python is under different licenses. The licenses are listed with code falling under that license.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \

\f0\b PYTHON SOFTWARE FOUNDATION LICENSE VERSION 2\

\f1\b0 \
1. This LICENSE AGREEMENT is between the Python Software Foundation ("PSF"), and the Individual or Organization ("Licensee") accessing and otherwise using this software ("Python") in source or binary form and its associated documentation.\
\
2. Subject to the terms and conditions of this License Agreement, PSF hereby grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare derivative works, distribute, and otherwise use Python alone or in any derivative version, provided, however, that PSF's License Agreement and PSF's notice of copyright, i.e., "Copyright \'a9 2001 Python Software Foundation; All Rights Reserved" are retained in Python alone or in any derivative version prepared by Licensee.\
\
3. In the event Licensee prepares a derivative work that is based on or incorporates Python or any part thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby agrees to include in any such work a brief summary of the changes made to Python.\
\
4. PSF is making Python available to Licensee on an "AS IS" basis. PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.\
\
5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.\
\
6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.\
\
7. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between PSF and Licensee. This License Agreement does not grant permission to use PSF trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.\
\
8. By copying, installing or otherwise using Python, Licensee agrees to be bound by the terms and conditions of this License Agreement.\
\
\

\f0\b BEOPEN.COM LICENSE AGREEMENT FOR PYTHON 2.0\

\f1\b0 \
BEOPEN PYTHON OPEN SOURCE LICENSE AGREEMENT VERSION 1\
\
1. This LICENSE AGREEMENT is between BeOpen.com ("BeOpen"), having an office at 160 Saratoga Avenue, Santa Clara, CA 95051, and the Individual or Organization ("Licensee") accessing and otherwise using this software in source or binary form and its associated documentation ("the Software").\
\
2. Subject to the terms and conditions of this BeOpen Python License Agreement, BeOpen hereby grants Licensee a non-exclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare derivative works, distribute, and otherwise use the Software alone or in any derivative version, provided, however, that the BeOpen Python License is retained in the Software, alone or in any derivative version prepared by Licensee.\
\
3. BeOpen is making the Software available to Licensee on an "AS IS" basis. BEOPEN MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, BEOPEN MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF THE SOFTWARE WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.\
\
4. BEOPEN SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF THE SOFTWARE FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF USING, MODIFYING OR DISTRIBUTING THE SOFTWARE, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.\
\
5. This License Agreement will automatically terminate upon a material breach of its terms and conditions.\
\
6. This License Agreement shall be governed by and interpreted in all respects by the law of the State of California, excluding conflict of law provisions. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between BeOpen and Licensee. This License Agreement does not grant permission to use BeOpen trademarks or trade names in a trademark sense to endorse or promote products or services of Licensee, or any third party. As an exception, the "BeOpen Python" logos available at http://www.pythonlabs.com/logos.html may be used according to the permissions granted on that web page.\
\
7. By copying, installing or otherwise using the software, Licensee agrees to be bound by the terms and conditions of this License Agreement.\
\
\

\f0\b CNRI LICENSE AGREEMENT FOR PYTHON 1.6.1\

\f1\b0 \
1. This LICENSE AGREEMENT is between the Corporation for National Research Initiatives, having an office at 1895 Preston White Drive, Reston, VA 20191 ("CNRI"), and the Individual or Organization ("Licensee") accessing and otherwise using Python 1.6.1 software in source or binary form and its associated documentation.\
\
2. Subject to the terms and conditions of this License Agreement, CNRI hereby grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce, analyze, test, perform and/or display publicly, prepare derivative works, distribute, and otherwise use Python 1.6.1 alone or in any derivative version, provided, however, that CNRI's License Agreement and CNRI's notice of copyright, i.e., "Copyright (c) 1995-2001 Corporation for National Research Initiatives; All Rights Reserved" are retained in Python 1.6.1 alone or in any derivative version prepared by Licensee. Alternately, in lieu of CNRI's License Agreement, Licensee may substitute the following text (omitting the quotes): "Python 1.6.1 is made available subject to the terms and conditions in CNRI's License Agreement. This Agreement together with Python 1.6.1 may be located on the internet using the following unique, persistent identifier (known as a handle): 1895.22/1013. This Agreement may also be obtained from a proxy server on the internet using the following URL: http://hdl.handle.net/1895.22/1013".\
\
3. In the event Licensee prepares a derivative work that is based on or incorporates Python 1.6.1 or any part thereof, and wants to make the derivative work available to others as provided herein, then Licensee hereby agrees to include in any such work a brief summary of the changes made to Python 1.6.1.\
\
4. CNRI is making Python 1.6.1 available to Licensee on an "AS IS" basis. CNRI MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED. BY WAY OF EXAMPLE, BUT NOT LIMITATION, CNRI MAKES NO AND DISCLAIMS ANY REPRESENTATION OR WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE USE OF PYTHON 1.6.1 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.\
\
5. CNRI SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 1.6.1 FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 1.6.1, OR ANY DERIVATIVE THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.\
\
6. This License Agreement will automatically terminate upon a material breach of its terms and conditions.\
\
7. This License Agreement shall be governed by the federal intellectual property law of the United States, including without limitation the federal copyright law, and, to the extent such U.S. federal law does not apply, by the law of the Commonwealth of Virginia, excluding Virginia's conflict of law provisions. Notwithstanding the foregoing, with regard to derivative works based on Python 1.6.1 that incorporate non-separable material that was previously distributed under the GNU General Public License (GPL), the law of the Commonwealth of Virginia shall govern this License Agreement only as to issues arising under or with respect to Paragraphs 4, 5, and 7 of this License Agreement. Nothing in this License Agreement shall be deemed to create any relationship of agency, partnership, or joint venture between CNRI and Licensee. This License Agreement does not grant permission to use CNRI trademarks or trade name in a trademark sense to endorse or promote products or services of Licensee, or any third party.\
\
8. By clicking on the "ACCEPT" button where indicated, or by copying, installing or otherwise using Python 1.6.1, Licensee agrees to be bound by the terms and conditions of this License Agreement.\
\
        ACCEPT\
\
\

\f0\b CWI LICENSE AGREEMENT FOR PYTHON 0.9.0 THROUGH 1.2\

\f1\b0 \
Copyright (c) 1991 - 1995, Stichting Mathematisch Centrum Amsterdam, The Netherlands. All rights reserved.\
\
Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that the name of Stichting Mathematisch Centrum or CWI not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.\
\
STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\
\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\b \cf0 ZERO-CLAUSE BSD LICENSE FOR CODE IN THE PYTHON DOCUMENTATION\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b0 \cf0 \
Permission to use, copy, modify, and/or distribute this software for any purpose with or without fee is hereby granted.\
\
THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\

\f0\b \ul LICENSES AND ACKNOWLEDGEMENTS FOR INCORPORATED SOFTWARE\

\f1\b0 \ulnone \
This installer incorporates portions of the following third-party software:\
\

\f3 $THIRD_PARTY_LIBS\
\

\f1 For licenses and acknowledgements for these and other third-party software incorporated in this Python distribution, please refer to the on-line documentation {\field{\*\fldinst{HYPERLINK "https://docs.python.org/$VERSION/license.html#licenses-and-acknowledgements-for-incorporated-software"}}{\fldrslt here}}.\
\
\
\
\
}


================================================
File: /Mac/BuildScript/resources/ReadMe.rtf
================================================
{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Bold;\f2\fswiss\fcharset0 Helvetica-Oblique;
\f3\fmodern\fcharset0 CourierNewPSMT;\f4\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww13380\viewh14580\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 This package will install Python $FULL_VERSION for macOS $MACOSX_DEPLOYMENT_TARGET for the following architecture(s): $ARCHITECTURES.\
\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\partightenfactor0

\f1\b \cf0 NOTE: 
\f0\b0 This is a beta preview of Python 3.13.0, the next feature release of Python 3.  It is not intended for production use.\
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0
\cf0 \
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f1\b \cf0 \ul \ulc0 Certificate verification and OpenSSL\

\f0\b0 \ulnone \
This package includes its own private copy of OpenSSL 3.0.   The trust certificates in system and user keychains managed by the 
\f2\i Keychain Access 
\f0\i0 application and the 
\f2\i security
\f0\i0  command line utility are not used as defaults by the Python 
\f3 ssl
\f0  module.  A sample command script is included in 
\f3 /Applications/Python 3.13
\f0  to install a curated bundle of default root certificates from the third-party 
\f3 certifi
\f0  package ({\field{\*\fldinst{HYPERLINK "https://pypi.org/project/certifi/"}}{\fldrslt https://pypi.org/project/certifi/}}).  Double-click on 
\f3 Install Certificates
\f0  to run it.\
\
The bundled 
\f3 pip
\f0  has its own default certificate store for verifying download connections.\
\

\f1\b \ul Install Options\

\f0\b0 \ulnone \
You can control some aspects of what is installed by this package. To see the options, click on the 
\f4 Customize
\f0  button in the 
\f4 Installation Type
\f0  step of the macOS installer app.  Click on a package name in the list shown to see more information about that option,\
  \

\f1\b \ul Using IDLE or other Tk applications 
\f0\b0 \ulnone \
\
This package includes its own private version of Tcl/Tk 8.6. It does not use any system-supplied or third-party supplied versions of Tcl/Tk.\
\
Due to new security checks on macOS 10.15 Catalina, when launching IDLE macOS may open a window with a message 
\f1\b "Python" would like to access files in your Documents folder
\f0\b0 .  This is normal as IDLE uses your 
\f1\b Documents
\f0\b0  folder as its default when opening and saving files; you can still choose other locations in the 
\f1\b Open
\f0\b0  and 
\f1\b Save
\f0\b0  file dialog windows.  Click on the 
\f1\b OK
\f0\b0  button to proceed.\
\

\f1\b \ul Apple Silicon Mac support\

\f0\b0 \ulnone \
On Apple Silicon Macs, it is possible to run Python either with native ARM64 code or under Intel 64 emulation using Rosetta2. This option might be useful for testing or if binary wheels are not yet available with native ARM64 binaries.  To easily force Python to run in emulation mode, invoke it from a command line shell with the 
\f4 python3-intel64
\f0  command instead of just 
\f4 python3
\f0 .\

\f1\b \ul \
Other changes\

\f0\b0 \ulnone \
For other changes in this release, see the 
\f2\i What's new
\f0\i0  section in the {\field{\*\fldinst{HYPERLINK "https://www.python.org/doc/"}}{\fldrslt Documentation Set}} for this release and its 
\f2\i Release Notes
\f0\i0  link at {\field{\*\fldinst{HYPERLINK "https://www.python.org/downloads/"}}{\fldrslt https://www.python.org/downloads/}}.\
}

================================================
File: /Mac/BuildScript/resources/Welcome.rtf
================================================
{\rtf1\ansi\ansicpg1252\cocoartf2761
\cocoascreenfonts1\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;\f1\fswiss\fcharset0 Helvetica-Bold;\f2\fmodern\fcharset0 CourierNewPSMT;
}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww12200\viewh10880\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\partightenfactor0

\f0\fs24 \cf0 This package will install 
\f1\b Python $FULL_VERSION
\f0\b0  for 
\f1\b macOS $MACOSX_DEPLOYMENT_TARGET
\f0\b0 .\
\

\f1\b Python for macOS
\f0\b0  consists of the {\field{\*\fldinst{HYPERLINK "https://www.python.org"}}{\fldrslt Python}} programming language interpreter and its batteries-included standard library to allow easy access to macOS features.  It also includes the Python integrated development environment, 
\f1\b IDLE
\f0\b0 .  You can also use the included 
\f1\b pip
\f0\b0  to download and install third-party packages from the {\field{\*\fldinst{HYPERLINK "https://pypi.org"}}{\fldrslt Python Package Index}}. \
\
At the end of this install, click on 
\f2 Install Certificates
\f0  to install a set of current SSL root certificates.\
\

\f1\b NOTE: 
\f0\b0 This is a beta test preview of Python 3.13.0, the next feature release of Python 3.  It is not intended for production use.\
}

================================================
File: /Mac/BuildScript/resources/install_certificates.command
================================================
#!/bin/sh

/Library/Frameworks/Python.framework/Versions/@PYVER@/bin/python@PYVER@ << "EOF"

# install_certifi.py
#
# sample script to install or update a set of default Root Certificates
# for the ssl module.  Uses the certificates provided by the certifi package:
#       https://pypi.org/project/certifi/

import os
import os.path
import ssl
import stat
import subprocess
import sys

STAT_0o775 = ( stat.S_IRUSR | stat.S_IWUSR | stat.S_IXUSR
             | stat.S_IRGRP | stat.S_IWGRP | stat.S_IXGRP
             | stat.S_IROTH |                stat.S_IXOTH )

def main():
    openssl_dir, openssl_cafile = os.path.split(
        ssl.get_default_verify_paths().openssl_cafile)

    print(" -- pip install --upgrade certifi")
    subprocess.check_call([sys.executable,
        "-E", "-s", "-m", "pip", "install", "--upgrade", "certifi"])

    import certifi

    # change working directory to the default SSL directory
    os.chdir(openssl_dir)
    relpath_to_certifi_cafile = os.path.relpath(certifi.where())
    print(" -- removing any existing file or link")
    try:
        os.remove(openssl_cafile)
    except FileNotFoundError:
        pass
    print(" -- creating symlink to certifi certificate bundle")
    os.symlink(relpath_to_certifi_cafile, openssl_cafile)
    print(" -- setting permissions")
    os.chmod(openssl_cafile, STAT_0o775)
    print(" -- update complete")

if __name__ == '__main__':
    main()
EOF


================================================
File: /Mac/BuildScript/scripts/postflight.documentation
================================================
#!/bin/sh

PYVER="@PYVER@"
FWK="/Library/Frameworks/Python.framework/Versions/${PYVER}"
FWK_DOCDIR_SUBPATH="Resources/English.lproj/Documentation"
FWK_DOCDIR="${FWK}/${FWK_DOCDIR_SUBPATH}"
APPDIR="/Applications/Python ${PYVER}"
SHARE_DIR="${FWK}/share"
SHARE_DOCDIR="${SHARE_DIR}/doc/python${PYVER}"
SHARE_DOCDIR_TO_FWK="../../.."

# make link in /Applications/Python m.n/ for Finder users
if [ -d "${APPDIR}" ]; then
    ln -fhs "${FWK_DOCDIR}/index.html" "${APPDIR}/Python Documentation.html"
    if [ "${COMMAND_LINE_INSTALL}" != 1 ]; then
        open "${APPDIR}" || true  # open the applications folder
    fi
fi

# make share/doc link in framework for command line users
if [ -d "${SHARE_DIR}" ]; then
    mkdir -m 775 -p "${SHARE_DOCDIR}"
    # make relative link to html doc directory
    ln -fhs "${SHARE_DOCDIR_TO_FWK}/${FWK_DOCDIR_SUBPATH}" "${SHARE_DOCDIR}/html"
fi



================================================
File: /Mac/BuildScript/scripts/postflight.ensurepip
================================================
#!/bin/sh
#
# Install/upgrade pip.
#

PYVER="@PYVER@"
PYMAJOR="@PYMAJOR@"
FWK="/Library/Frameworks/Python.framework/Versions/${PYVER}"
RELFWKBIN="../../..${FWK}/bin"

umask 022

"${FWK}/bin/python${PYVER}" -E -s -m ensurepip --upgrade

# bpo-33290: An earlier "pip3 install --upgrade pip" may have installed
#     a "pip" in the fw bin directory.  For a py3 install, remove it.

rm -f "${FWK}/bin/pip"

"${FWK}/bin/python${PYVER}" -E -s -Wi \
    "${FWK}/lib/python${PYVER}/compileall.py" -q -j0 \
    -f -x badsyntax \
    "${FWK}/lib/python${PYVER}/site-packages"

"${FWK}/bin/python${PYVER}" -E -s -Wi -O \
    "${FWK}/lib/python${PYVER}/compileall.py" -q -j0 \
    -f -x badsyntax \
    "${FWK}/lib/python${PYVER}/site-packages"

chgrp -R admin "${FWK}/lib/python${PYVER}/site-packages" "${FWK}/bin"
chmod -R g+w "${FWK}/lib/python${PYVER}/site-packages" "${FWK}/bin"

# We do not know if the user selected the Python command-line tools
# package that installs symlinks to /usr/local/bin.  So we assume
# that the command-line tools package has already completed or was
# not selected and we will only install /usr/local/bin symlinks for
# pip et al if there are /usr/local/bin/python* symlinks to our
# framework bin directory.

if [ -d /usr/local/bin ] ; then
    (
        install_links_if_our_fw() {
            if [ "$(readlink -n ./$1)" = "${RELFWKBIN}/$1" ] ; then
                shift
                for fn ;
                do
                    if [ -e "${RELFWKBIN}/${fn}" ] ; then
                        rm -f ./${fn}
                        ln -s "${RELFWKBIN}/${fn}" "./${fn}"
                        chgrp -h admin "./${fn}"
                        chmod -h g+w "./${fn}"
                    fi
                done
            fi
        }

        cd /usr/local/bin

        # Create pipx.y links if /usr/local/bin/pythonx.y
        #   is linked to this framework version
        install_links_if_our_fw "python${PYVER}" \
                                    "pip${PYVER}"

        # Create pipx link if /usr/local/bin/pythonx is linked to this version
        install_links_if_our_fw "python${PYMAJOR}" \
                                    "pip${PYMAJOR}"

        # Create pip link if /usr/local/bin/python
        #   is linked to this version
        install_links_if_our_fw "python" \
                                    "pip"
    )
fi
exit 0


================================================
File: /Mac/BuildScript/scripts/postflight.framework
================================================
#!/bin/sh
#
# Recompile the .py files.
#

PYVER="@PYVER@"
FWK="/Library/Frameworks/Python.framework/Versions/@PYVER@"

"${FWK}/bin/python@PYVER@" -E -s -Wi \
    "${FWK}/lib/python${PYVER}/compileall.py" -q -j0 \
    -f -x 'bad_coding|badsyntax|site-packages' \
    "${FWK}/lib/python${PYVER}"

"${FWK}/bin/python@PYVER@" -E -s -Wi -O \
    "${FWK}/lib/python${PYVER}/compileall.py" -q -j0 \
    -f -x 'bad_coding|badsyntax|site-packages' \
    "${FWK}/lib/python${PYVER}"

"${FWK}/bin/python@PYVER@" -E -s -Wi \
    "${FWK}/lib/python${PYVER}/compileall.py" -q -j0 \
    -f -x badsyntax \
    "${FWK}/lib/python${PYVER}/site-packages"

"${FWK}/bin/python@PYVER@" -E -s -Wi -O \
    "${FWK}/lib/python${PYVER}/compileall.py" -q -j0 \
    -f -x badsyntax \
    "${FWK}/lib/python${PYVER}/site-packages"

chgrp -R admin "${FWK}"
chmod -R g+w "${FWK}"

exit 0


================================================
File: /Mac/BuildScript/scripts/postflight.patch-profile
================================================
#!/bin/sh

echo "This script will update your shell profile when the 'bin' directory"
echo "of python is not early enough of the PATH of your shell."
echo "These changes will be effective only in shell windows that you open"
echo "after running this script."

PYVER=@PYVER@
PYTHON_ROOT="/Library/Frameworks/Python.framework/Versions/@PYVER@"

if [ `id -ur` = 0 ]; then
	# Run from the installer, do some trickery to fetch the information
	# we need.
	theShell="`finger $USER | grep Shell: | head  -1 | awk '{ print $NF }'`"

else
	theShell="${SHELL}"
fi

# Make sure the directory ${PYTHON_ROOT}/bin is on the users PATH.
BSH="`basename "${theShell}"`"
case "${BSH}" in
bash|ksh|sh|*csh|zsh|fish)
	if [ `id -ur` = 0 ]; then
		P=`su - ${USER} -c 'echo A-X-4-X@@$PATH@@X-4-X-A' | grep 'A-X-4-X@@.*@@X-4-X-A' | sed -e 's/^A-X-4-X@@//g' -e 's/@@X-4-X-A$//g'`
	else
		P="`(exec -l ${theShell} -c 'echo $PATH')`"
	fi
	;;
*)
	echo "Sorry, I don't know how to patch $BSH shells"
	exit 0
	;;
esac

# Now ensure that our bin directory is on $P and before /usr/bin at that
for elem in `echo $P | tr ':' ' '`
do
	if [ "${elem}" = "${PYTHON_ROOT}/bin" ]; then
		echo "All right, you're a python lover already"
		exit 0
	elif [ "${elem}" = "/usr/bin" ]; then
		break
	fi
done

echo "${PYTHON_ROOT}/bin is not on your PATH or at least not early enough"
case "${BSH}" in
*csh)
	if [ -f "${HOME}/.tcshrc" ]; then
		RC="${HOME}/.tcshrc"
	else
		RC="${HOME}/.cshrc"
	fi
	# Create backup copy before patching
	if [ -f "${RC}" ]; then
		cp -fp "${RC}" "${RC}.pysave"
	fi
	echo "" >> "${RC}"
	echo "# Setting PATH for Python ${PYVER}" >> "${RC}"
	echo "# The original version is saved in .cshrc.pysave" >> "${RC}"
	echo "set path=(${PYTHON_ROOT}/bin "'$path'")" >> "${RC}"
	if [ `id -ur` = 0 ]; then
		chown "${USER}" "${RC}"
	fi
	exit 0
	;;
bash)
	if [ -e "${HOME}/.bash_profile" ]; then
		PR="${HOME}/.bash_profile"
	elif [ -e "${HOME}/.bash_login" ]; then
		PR="${HOME}/.bash_login"
	elif [ -e "${HOME}/.profile" ]; then
		PR="${HOME}/.profile"
	else
		PR="${HOME}/.bash_profile"
	fi
	;;
fish)
	CONFIG_DIR="${HOME}/.config/fish/conf.d/"
	RC="${CONFIG_DIR}/python-${PYVER}.fish"
	mkdir -p "$CONFIG_DIR"
	if [ -f "${RC}" ]; then
		cp -fp "${RC}" "${RC}.pysave"
	fi
	echo "# Setting PATH for Python ${PYVER}" > "${RC}"
	if [ -f "${RC}.pysave" ]; then
		echo "# The original version is saved in ${RC}.pysave" >> "${RC}"
	fi
	echo "fish_add_path -g \"${PYTHON_ROOT}/bin\"" >> "${RC}"
	if [ `id -ur` = 0 ]; then
		chown "${USER}" "${RC}"
	fi
	exit 0
	;;
zsh)
        PR="${HOME}/.zprofile"
        ;;
*sh)
	PR="${HOME}/.profile"
	;;
esac

# Create backup copy before patching
if [ -f "${PR}" ]; then
	cp -fp "${PR}" "${PR}.pysave"
fi
echo "" >> "${PR}"
echo "# Setting PATH for Python ${PYVER}" >> "${PR}"
echo "# The original version is saved in `basename ${PR}`.pysave" >> "${PR}"
echo 'PATH="'"${PYTHON_ROOT}/bin"':${PATH}"' >> "${PR}"
echo 'export PATH' >> "${PR}"
if [ `id -ur` = 0 ]; then
	chown "${USER}" "${PR}"
fi
exit 0


================================================
File: /Mac/IDLE/IDLE.app/Contents/Info.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleDocumentTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>py</string>
				<string>pyi</string>
				<string>pyw</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>PythonSource.icns</string>
			<key>CFBundleTypeName</key>
			<string>Python Script</string>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>pyc</string>
				<string>pyo</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>PythonCompiled.icns</string>
			<key>CFBundleTypeName</key>
			<string>Python Bytecode Document</string>
			<key>CFBundleTypeRole</key>
			<string>Editor</string>
		</dict>
	</array>
	<key>CFBundleExecutable</key>
	<string>IDLE</string>
	<key>CFBundleGetInfoString</key>
	<string>%version%, © 2001-2024 Python Software Foundation</string>
	<key>CFBundleIconFile</key>
	<string>IDLE.icns</string>
	<key>CFBundleIdentifier</key>
	<string>org.python.IDLE</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>IDLE</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>%version%</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>%version%</string>
	<key>NSHighResolutionCapable</key>
	<true/>
	<key>CFBundleAllowMixedLocalizations</key>
	<true/>
</dict>
</plist>


================================================
File: /Mac/IDLE/IDLE.app/Contents/PkgInfo
================================================
APPL????

================================================
File: /Mac/IDLE/IDLE.app/Contents/MacOS/IDLE
================================================
#!%prefix%/Resources/Python.app/Contents/MacOS/%exe%

import sys, os
execdir = os.path.dirname(sys.argv[0])
executable = os.path.join(execdir, "Python")
resdir = os.path.join(os.path.dirname(execdir), "Resources")
libdir = os.path.join(os.path.dirname(execdir), "Frameworks")
mainprogram = os.path.join(resdir, "idlemain.py")

sys.argv.insert(1, mainprogram)
if 0 or 0:
    os.environ["PYTHONPATH"] = resdir
    if 0:
        os.environ["PYTHONHOME"] = resdir
else:
    pypath = os.getenv("PYTHONPATH", "")
    if pypath:
        pypath = ":" + pypath
    os.environ["PYTHONPATH"] = resdir + pypath
os.environ["PYTHONEXECUTABLE"] = executable
os.environ["DYLD_LIBRARY_PATH"] = libdir
os.environ["DYLD_FRAMEWORK_PATH"] = libdir
os.execve(executable, sys.argv, os.environ)


================================================
File: /Mac/IDLE/IDLE.app/Contents/Resources/idlemain.py
================================================
"""
Bootstrap script for IDLE as an application bundle.
"""
import sys, os

# Change the current directory the user's home directory, that way we'll get
# a more useful default location in the open/save dialogs.
os.chdir(os.path.expanduser('~/Documents'))


# Make sure sys.executable points to the python interpreter inside the
# framework, instead of at the helper executable inside the application
# bundle (the latter works, but doesn't allow access to the window server)
#
#  .../IDLE.app/
#       Contents/
#           MacOS/
#               IDLE (a python script)
#               Python{-32} (symlink)
#           Resources/
#               idlemain.py (this module)
#               ...
#
# ../IDLE.app/Contents/MacOS/Python{-32} is symlinked to
#       ..Library/Frameworks/Python.framework/Versions/m.n
#                   /Resources/Python.app/Contents/MacOS/Python{-32}
#       which is the Python interpreter executable
#
# The flow of control is as follows:
# 1. IDLE.app is launched which starts python running the IDLE script
# 2. IDLE script exports
#       PYTHONEXECUTABLE = .../IDLE.app/Contents/MacOS/Python{-32}
#           (the symlink to the framework python)
# 3. IDLE script alters sys.argv and uses os.execve to replace itself with
#       idlemain.py running under the symlinked python.
#       This is the magic step.
# 4. During interpreter initialization, because PYTHONEXECUTABLE is defined,
#    sys.executable may get set to an useless value.
#
# (Note that the IDLE script and the setting of PYTHONEXECUTABLE is
#  generated automatically by bundlebuilder in the Python 2.x build.
#  Also, IDLE invoked via command line, i.e. bin/idle, bypasses all of
#  this.)
#
# Now fix up the execution environment before importing idlelib.

# Reset sys.executable to its normal value, the actual path of
# the interpreter in the framework, by following the symlink
# exported in PYTHONEXECUTABLE.
pyex = os.environ['PYTHONEXECUTABLE']
sys.executable = os.path.join(sys.prefix, 'bin', 'python%d.%d'%(sys.version_info[:2]))

# Remove any sys.path entries for the Resources dir in the IDLE.app bundle.
p = pyex.partition('.app')
if p[2].startswith('/Contents/MacOS/Python'):
    sys.path = [value for value in sys.path if
            value.partition('.app') != (p[0], p[1], '/Contents/Resources')]

# Unexport PYTHONEXECUTABLE so that the other Python processes started
# by IDLE have a normal sys.executable.
del os.environ['PYTHONEXECUTABLE']

# Look for the -psn argument that the launcher adds and remove it, it will
# only confuse the IDLE startup code.
for idx, value in enumerate(sys.argv):
    if value.startswith('-psn_'):
        del sys.argv[idx]
        break

# Now it is safe to import idlelib.
from idlelib.pyshell import main
if __name__ == '__main__':
    main()


================================================
File: /Mac/Icons/ReadMe.txt
================================================
The icons for use on MacOS X were created by Jacob Rus <jrus@fas.harvard.edu>
with some feedback from the folks on pythonmac-sig@python.org.



================================================
File: /Mac/PythonLauncher/FileSettings.h
================================================
//
//  FileSettings.h
//  PythonLauncher
//
//  Created by Jack Jansen on Sun Jul 21 2002.
//  Copyright (c) 2002 __MyCompanyName__. All rights reserved.
//

#import <Foundation/Foundation.h>

@protocol FileSettingsSource
- (NSString *) interpreter;
- (BOOL) honourhashbang;
- (BOOL) debug;
- (BOOL) verbose;
- (BOOL) inspect;
- (BOOL) optimize;
- (BOOL) nosite;
- (BOOL) tabs;
- (NSString *) others;
- (BOOL) with_terminal;
- (NSString *) scriptargs;
@end

@interface FileSettings : NSObject <FileSettingsSource>
{
    NSString *interpreter;      // The pathname of the interpreter to use
    NSArray *interpreters;      // List of known interpreters
    BOOL honourhashbang;        // #! line overrides interpreter
    BOOL debug;                 // -d option: debug parser
    BOOL verbose;               // -v option: verbose import
    BOOL inspect;               // -i option: interactive mode after script
    BOOL optimize;              // -O option: optimize bytecode
    BOOL nosite;                // -S option: don't import site.py
    BOOL tabs;                  // -t option: warn about inconsistent tabs
    NSString *others;           // other options
    NSString *scriptargs;       // script arguments (not for preferences)
    BOOL with_terminal;         // Run in terminal window

    FileSettings *origsource;
    NSString *prefskey;
}

+ (id)getDefaultsForFileType: (NSString *)filetype;
+ (id)getFactorySettingsForFileType: (NSString *)filetype;
+ (id)newSettingsForFileType: (NSString *)filetype;

- (id)initForFileType: (NSString *)filetype;
- (id)initForFSDefaultFileType: (NSString *)filetype;
- (id)initForDefaultFileType: (NSString *)filetype;

- (void)updateFromSource: (id <FileSettingsSource>)source;
- (NSString *)commandLineForScript: (NSString *)script;

- (void)applyValuesFromDict: (NSDictionary *)dict;
- (void)reset;
- (NSArray *) interpreters;

@end


================================================
File: /Mac/PythonLauncher/FileSettings.m
================================================
//
//  FileSettings.m
//  PythonLauncher
//
//  Created by Jack Jansen on Sun Jul 21 2002.
//  Copyright (c) 2002 __MyCompanyName__. All rights reserved.
//

#import "FileSettings.h"

@implementation FileSettings

+ (id)getFactorySettingsForFileType: (NSString *)filetype
{
    static FileSettings *fsdefault_py, *fsdefault_pyw, *fsdefault_pyc;
    FileSettings **curdefault;

    if ([filetype isEqualToString: @"Python Script"]) {
        curdefault = &fsdefault_py;
    } else if ([filetype isEqualToString: @"Python GUI Script"]) {
        curdefault = &fsdefault_pyw;
    } else if ([filetype isEqualToString: @"Python Bytecode Document"]) {
        curdefault = &fsdefault_pyc;
    } else {
        NSLog(@"Funny File Type: %@\n", filetype);
        curdefault = &fsdefault_py;
        filetype = @"Python Script";
    }
    if (!*curdefault) {
        *curdefault = [[FileSettings new] initForFSDefaultFileType: filetype];
    }
    return *curdefault;
}

+ (id)getDefaultsForFileType: (NSString *)filetype
{
    static FileSettings *default_py, *default_pyw, *default_pyc;
    FileSettings **curdefault;

    if ([filetype isEqualToString: @"Python Script"]) {
        curdefault = &default_py;
    } else if ([filetype isEqualToString: @"Python GUI Script"]) {
        curdefault = &default_pyw;
    } else if ([filetype isEqualToString: @"Python Bytecode Document"]) {
        curdefault = &default_pyc;
    } else {
        NSLog(@"Funny File Type: %@\n", filetype);
        curdefault = &default_py;
        filetype = @"Python Script";
    }
    if (!*curdefault) {
        *curdefault = [[FileSettings new] initForDefaultFileType: filetype];
    }
    return *curdefault;
}

+ (id)newSettingsForFileType: (NSString *)filetype
{
    FileSettings *cur;

    cur = [FileSettings new];
    [cur initForFileType: filetype];
    return [cur retain];
}

- (id)initWithFileSettings: (FileSettings *)source
{
    self = [super init];
    if (!self) return self;

    interpreter = [source->interpreter retain];
    honourhashbang = source->honourhashbang;
    debug = source->debug;
    verbose = source->verbose;
    inspect = source->inspect;
    optimize = source->optimize;
    nosite = source->nosite;
    tabs = source->tabs;
    others = [source->others retain];
    scriptargs = [source->scriptargs retain];
    with_terminal = source->with_terminal;
    prefskey = source->prefskey;
    if (prefskey) [prefskey retain];

    return self;
}

- (id)initForFileType: (NSString *)filetype
{
    FileSettings *defaults;

    defaults = [FileSettings getDefaultsForFileType: filetype];
    self = [self initWithFileSettings: defaults];
    origsource = [defaults retain];
    return self;
}

- (id)initForFSDefaultFileType: (NSString *)filetype
{
    int i;
    NSString *filename;
    NSDictionary *dict;
    static NSDictionary *factorySettings;

    self = [super init];
    if (!self) return self;

    if (factorySettings == NULL) {
        NSBundle *bdl = [NSBundle mainBundle];
        NSString *path = [ bdl pathForResource: @"factorySettings"
                ofType: @"plist"];
        factorySettings = [[NSDictionary dictionaryWithContentsOfFile:
            path] retain];
        if (factorySettings == NULL) {
            NSLog(@"Missing %@", path);
            return NULL;
        }
    }
    dict = [factorySettings objectForKey: filetype];
    if (dict == NULL) {
        NSLog(@"factorySettings.plist misses file type \"%@\"", filetype);
        interpreter = [@"no default found" retain];
        return NULL;
    }
    [self applyValuesFromDict: dict];
    interpreters = [dict objectForKey: @"interpreter_list"];
    interpreter = NULL;
    for (i=0; i < [interpreters count]; i++) {
        filename = [interpreters objectAtIndex: i];
        filename = [filename stringByExpandingTildeInPath];
        if ([[NSFileManager defaultManager] fileExistsAtPath: filename]) {
            interpreter = [filename retain];
            break;
        }
    }
    if (interpreter == NULL)
        interpreter = [@"no default found" retain];
    origsource = NULL;
    return self;
}

- (void)applyUserDefaults: (NSString *)filetype
{
    NSUserDefaults *defaults;
    NSDictionary *dict;

    defaults = [NSUserDefaults standardUserDefaults];
    dict = [defaults dictionaryForKey: filetype];
    if (!dict)
        return;
    [self applyValuesFromDict: dict];
}

- (id)initForDefaultFileType: (NSString *)filetype
{
    FileSettings *fsdefaults;

    fsdefaults = [FileSettings getFactorySettingsForFileType: filetype];
    self = [self initWithFileSettings: fsdefaults];
    if (!self) return self;
    interpreters = [fsdefaults->interpreters retain];
    scriptargs = [@"" retain];
    [self applyUserDefaults: filetype];
    prefskey = [filetype retain];
    return self;
}

- (void)reset
{
    if (origsource) {
        [self updateFromSource: origsource];
    } else {
        FileSettings *fsdefaults;
        fsdefaults = [FileSettings getFactorySettingsForFileType: prefskey];
        [self updateFromSource: fsdefaults];
    }
}

- (void)updateFromSource: (id <FileSettingsSource>)source
{
    interpreter = [[source interpreter] retain];
    honourhashbang = [source honourhashbang];
    debug = [source debug];
    verbose = [source verbose];
    inspect = [source inspect];
    optimize = [source optimize];
    nosite = [source nosite];
    tabs = [source tabs];
    others = [[source others] retain];
    scriptargs = [[source scriptargs] retain];
    with_terminal = [source with_terminal];
    // And if this is a user defaults object we also save the
    // values
    if (!origsource) {
        NSUserDefaults *defaults;
        NSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:
            interpreter, @"interpreter",
            [NSNumber numberWithBool: honourhashbang], @"honourhashbang",
            [NSNumber numberWithBool: debug], @"debug",
            [NSNumber numberWithBool: verbose], @"verbose",
            [NSNumber numberWithBool: inspect], @"inspect",
            [NSNumber numberWithBool: optimize], @"optimize",
            [NSNumber numberWithBool: nosite], @"nosite",
            [NSNumber numberWithBool: tabs], @"tabs",
            others, @"others",
            scriptargs, @"scriptargs",
            [NSNumber numberWithBool: with_terminal], @"with_terminal",
            nil];
        defaults = [NSUserDefaults standardUserDefaults];
        [defaults setObject: dict forKey: prefskey];
    }
}

- (void)applyValuesFromDict: (NSDictionary *)dict
{
    id value;

    value = [dict objectForKey: @"interpreter"];
    if (value) interpreter = [value retain];
    value = [dict objectForKey: @"honourhashbang"];
    if (value) honourhashbang = [value boolValue];
    value = [dict objectForKey: @"debug"];
    if (value) debug = [value boolValue];
    value = [dict objectForKey: @"verbose"];
    if (value) verbose = [value boolValue];
    value = [dict objectForKey: @"inspect"];
    if (value) inspect = [value boolValue];
    value = [dict objectForKey: @"optimize"];
    if (value) optimize = [value boolValue];
    value = [dict objectForKey: @"nosite"];
    if (value) nosite = [value boolValue];
    value = [dict objectForKey: @"tabs"];
    if (value) tabs = [value boolValue];
    value = [dict objectForKey: @"others"];
    if (value) others = [value retain];
    value = [dict objectForKey: @"scriptargs"];
    if (value) scriptargs = [value retain];
    value = [dict objectForKey: @"with_terminal"];
    if (value) with_terminal = [value boolValue];
}

- (NSString*)_replaceSingleQuotes: (NSString*)string
{
    /* Replace all single-quotes by '"'"', that way shellquoting will
     * be correct when the result value is delimited  using single quotes.
     */
    NSArray* components = [string componentsSeparatedByString:@"'"];

    return [components componentsJoinedByString:@"'\"'\"'"];
}

- (NSString *)commandLineForScript: (NSString *)script
{
    NSString *cur_interp = NULL;
    NSString* script_dir = NULL;
    char hashbangbuf[1024];
    FILE *fp;
    char *p;

    script_dir = [script substringToIndex:
	    [script length]-[[script lastPathComponent] length]];

    if (honourhashbang &&
       (fp=fopen([script fileSystemRepresentation], "r")) &&
       fgets(hashbangbuf, sizeof(hashbangbuf), fp) &&
       strncmp(hashbangbuf, "#!", 2) == 0 &&
       (p=strchr(hashbangbuf, '\n'))) {
            *p = '\0';
            p = hashbangbuf + 2;
            while (*p == ' ') p++;
            cur_interp = [NSString stringWithUTF8String: p];
    }
    if (!cur_interp)
        cur_interp = interpreter;

    return [NSString stringWithFormat:
        @"cd '%@' && '%@'%s%s%s%s%s%s %@ '%@' %@ %s",
    	[self _replaceSingleQuotes:script_dir],
        [self _replaceSingleQuotes:cur_interp],
        debug?" -d":"",
        verbose?" -v":"",
        inspect?" -i":"",
        optimize?" -O":"",
        nosite?" -S":"",
        tabs?" -t":"",
        others,
        [self _replaceSingleQuotes:script],
        scriptargs ? scriptargs : @"",
        with_terminal? "&& echo Exit status: $? && exit 1" : " &"];
}

- (NSArray *) interpreters { return interpreters;};

// FileSettingsSource protocol
- (NSString *) interpreter { return interpreter;};
- (BOOL) honourhashbang { return honourhashbang; };
- (BOOL) debug { return debug;};
- (BOOL) verbose { return verbose;};
- (BOOL) inspect { return inspect;};
- (BOOL) optimize { return optimize;};
- (BOOL) nosite { return nosite;};
- (BOOL) tabs { return tabs;};
- (NSString *) others { return others;};
- (NSString *) scriptargs { return scriptargs;};
- (BOOL) with_terminal { return with_terminal;};

@end


================================================
File: /Mac/PythonLauncher/Info.plist.in
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>en</string>
	<key>CFBundleDocumentTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>py</string>
				<string>pyw</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>PythonSource.icns</string>
			<key>CFBundleTypeName</key>
			<string>Python Script</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>NSDocumentClass</key>
			<string>MyDocument</string>
		</dict>
		<dict>
			<key>CFBundleTypeExtensions</key>
			<array>
				<string>pyc</string>
				<string>pyo</string>
			</array>
			<key>CFBundleTypeIconFile</key>
			<string>PythonCompiled.icns</string>
			<key>CFBundleTypeName</key>
			<string>Python Bytecode Document</string>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
			<key>NSDocumentClass</key>
			<string>MyDocument</string>
		</dict>
	</array>
	<key>CFBundleExecutable</key>
	<string>Python Launcher</string>
	<key>NSHumanReadableCopyright</key>
	<string>Copyright © 2001 Python Software Foundation</string>
	<key>CFBundleGetInfoString</key>
	<string>%VERSION%, © 2001 Python Software Foundation</string>
	<key>CFBundleIconFile</key>
	<string>PythonLauncher.icns</string>
	<key>CFBundleIdentifier</key>
	<string>org.python.PythonLauncher</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>Python Launcher</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>%VERSION%</string>
	<key>CFBundleSignature</key>
	<string>PytL</string>
	<key>CFBundleVersion</key>
	<string>%VERSION%</string>
	<key>NSMainNibFile</key>
	<string>MainMenu</string>
	<key>NSPrincipalClass</key>
	<string>NSApplication</string>
	<key>NSAppleEventsUsageDescription</key>
	<string>Python Launcher uses Apple events to launch your Python script in a Terminal window.</string>
</dict>
</plist>


================================================
File: /Mac/PythonLauncher/Makefile.in
================================================
CC=@CC@
LD=@CC@
BASECFLAGS=@BASECFLAGS@
OPT=@OPT@
CFLAGS=@CFLAGS@ $(BASECFLAGS) $(OPT)
LDFLAGS=@LDFLAGS@
srcdir=         @srcdir@
VERSION=	@VERSION@
UNIVERSALSDK=@UNIVERSALSDK@
builddir=	../..

RUNSHARED=      @RUNSHARED@
BUILDEXE=       @BUILDEXEEXT@
BUILDPYTHON=    $(builddir)/python$(BUILDEXE)
PYTHONFRAMEWORK=@PYTHONFRAMEWORK@

# Deployment target selected during configure, to be checked
# by distutils
MACOSX_DEPLOYMENT_TARGET=@CONFIGURE_MACOSX_DEPLOYMENT_TARGET@
@EXPORT_MACOSX_DEPLOYMENT_TARGET@export MACOSX_DEPLOYMENT_TARGET

PYTHONAPPSDIR=@FRAMEWORKINSTALLAPPSPREFIX@/$(PYTHONFRAMEWORK) $(VERSION)
OBJECTS=FileSettings.o MyAppDelegate.o MyDocument.o PreferencesWindowController.o doscript.o main.o

install: Python\ Launcher.app
	test -d "$(DESTDIR)$(PYTHONAPPSDIR)" || mkdir -p "$(DESTDIR)$(PYTHONAPPSDIR)"
	-test -d "$(DESTDIR)$(PYTHONAPPSDIR)/Python Launcher.app" && rm -r "$(DESTDIR)$(PYTHONAPPSDIR)/Python Launcher.app"
	/bin/cp -r "Python Launcher.app" "$(DESTDIR)$(PYTHONAPPSDIR)"
	touch "$(DESTDIR)$(PYTHONAPPSDIR)/Python Launcher.app"
	chmod -R ugo+rX,go-w "$(DESTDIR)$(PYTHONAPPSDIR)/Python Launcher.app"
	chmod ugo+x "$(DESTDIR)$(PYTHONAPPSDIR)/Python Launcher.app/Contents/MacOS/Python Launcher"

clean:
	rm -f *.o "Python Launcher"
	rm -rf "Python Launcher.app"
	rm -f Info.plist

Python\ Launcher.app:  Info.plist \
		Python\ Launcher $(srcdir)/../Icons/PythonLauncher.icns \
		$(srcdir)/../Icons/PythonSource.icns \
		$(srcdir)/../Icons/PythonCompiled.icns \
		$(srcdir)/factorySettings.plist
	rm -fr "Python Launcher.app"
	mkdir "Python Launcher.app"
	mkdir "Python Launcher.app/Contents"
	mkdir "Python Launcher.app/Contents/MacOS"
	mkdir "Python Launcher.app/Contents/Resources"
	cp "Python Launcher" "Python Launcher.app/Contents/MacOS"
	cp Info.plist  "Python Launcher.app/Contents"
	cp $(srcdir)/../Icons/PythonLauncher.icns  "Python Launcher.app/Contents/Resources"
	cp $(srcdir)/../Icons/PythonSource.icns  "Python Launcher.app/Contents/Resources"
	cp $(srcdir)/../Icons/PythonCompiled.icns  "Python Launcher.app/Contents/Resources"
	cp $(srcdir)/factorySettings.plist  "Python Launcher.app/Contents/Resources"
	cp -R $(srcdir)/English.lproj "Python Launcher.app/Contents/Resources"

FileSettings.o: $(srcdir)/FileSettings.m
	$(CC) $(CFLAGS) -o $@ -c $(srcdir)/FileSettings.m

MyAppDelegate.o: $(srcdir)/MyAppDelegate.m
	$(CC) $(CFLAGS) -o $@ -c $(srcdir)/MyAppDelegate.m

MyDocument.o: $(srcdir)/MyDocument.m
	$(CC) $(CFLAGS) -o $@ -c $(srcdir)/MyDocument.m

PreferencesWindowController.o: $(srcdir)/PreferencesWindowController.m
	$(CC) $(CFLAGS) -o $@ -c $(srcdir)/PreferencesWindowController.m

doscript.o: $(srcdir)/doscript.m
	$(CC) $(CFLAGS) -o $@ -c $(srcdir)/doscript.m

main.o: $(srcdir)/main.m
	$(CC) $(CFLAGS) -o $@ -c $(srcdir)/main.m

Python\ Launcher: $(OBJECTS)
	$(CC) $(LDFLAGS) -o "Python Launcher" $(OBJECTS) -framework AppKit -framework Carbon

Info.plist: $(srcdir)/Info.plist.in
	sed 's/%VERSION%/'"`$(RUNSHARED) $(BUILDPYTHON) -c 'import platform; print(platform.python_version())'`"'/g' < $(srcdir)/Info.plist.in > Info.plist


================================================
File: /Mac/PythonLauncher/MyAppDelegate.h
================================================
/* MyAppDelegate */

#import <Cocoa/Cocoa.h>

@interface MyAppDelegate : NSObject
{
    BOOL        initial_action_done;
    BOOL        should_terminate;
}
- (id)init;
- (IBAction)showPreferences:(id)sender;
- (BOOL)shouldShowUI;
- (BOOL)shouldTerminate;
- (void)testFileTypeBinding;
@end


================================================
File: /Mac/PythonLauncher/MyAppDelegate.m
================================================
#import "MyAppDelegate.h"
#import "PreferencesWindowController.h"
#import <Carbon/Carbon.h>
#import <ApplicationServices/ApplicationServices.h>

@implementation MyAppDelegate

- (id)init
{
    self = [super init];
    initial_action_done = NO;
    should_terminate = NO;
    return self;
}

- (IBAction)showPreferences:(id)sender
{
    [PreferencesWindowController getPreferencesWindow];
}

- (void)applicationDidFinishLaunching:(NSNotification *)notification
{
    // Test that the file mappings are correct
    [self testFileTypeBinding];
    // If we were opened because of a file drag or double-click
    // we've set initial_action_done in shouldShowUI
    // Otherwise we open a preferences dialog.
    if (!initial_action_done) {
        initial_action_done = YES;
        [self showPreferences: self];
    }
}

- (BOOL)shouldShowUI
{
    // if this call comes before applicationDidFinishLaunching: we
    // should terminate immediately after starting the script.
    if (!initial_action_done)
        should_terminate = YES;
    initial_action_done = YES;
    if( GetCurrentKeyModifiers() & optionKey )
        return YES;
    return NO;
}

- (BOOL)shouldTerminate
{
    return should_terminate;
}

- (BOOL)applicationShouldOpenUntitledFile:(NSApplication *)sender
{
    return NO;
}

- (void)testFileTypeBinding
{
    NSURL *ourUrl;
    OSStatus err;
    FSRef appRef;
    NSURL *appUrl;
    static NSString *extensions[] = { @"py", @"pyw", @"pyc", NULL};
    NSString **ext_p;
    int i;

    if ([[NSUserDefaults standardUserDefaults] boolForKey: @"SkipFileBindingTest"])
        return;
    ourUrl = [NSURL fileURLWithPath: [[NSBundle mainBundle] bundlePath]];
    for( ext_p = extensions; *ext_p; ext_p++ ) {
        err = LSGetApplicationForInfo(
            kLSUnknownType,
            kLSUnknownCreator,
            (CFStringRef)*ext_p,
            kLSRolesViewer,
            &appRef,
            (CFURLRef *)&appUrl);
        if (err || ![appUrl isEqual: ourUrl] ) {
            i = NSRunAlertPanel(@"File type binding",
                @"PythonLauncher is not the default application for all " \
                  @"Python script types. You should fix this with the " \
                  @"Finder's \"Get Info\" command.\n\n" \
                  @"See \"Changing the application that opens a file\" in " \
                  @"Mac Help for details.",
                @"OK",
                @"Don't show this warning again",
                NULL);
            if ( i == 0 ) { // Don't show again
                [[NSUserDefaults standardUserDefaults]
                    setObject:@"YES" forKey:@"SkipFileBindingTest"];
            }
            return;
        }
    }
}

@end


================================================
File: /Mac/PythonLauncher/MyDocument.h
================================================
//
//  MyDocument.h
//  PythonLauncher
//
//  Created by Jack Jansen on Fri Jul 19 2002.
//  Copyright (c) 2002 __MyCompanyName__. All rights reserved.
//


#import <Cocoa/Cocoa.h>

#import "FileSettings.h"

@interface MyDocument : NSDocument <FileSettingsSource>
{
    IBOutlet NSTextField *interpreter;
    IBOutlet NSButton *honourhashbang;
    IBOutlet NSButton *debug;
    IBOutlet NSButton *verbose;
    IBOutlet NSButton *inspect;
    IBOutlet NSButton *optimize;
    IBOutlet NSButton *nosite;
    IBOutlet NSButton *tabs;
    IBOutlet NSTextField *others;
    IBOutlet NSButton *with_terminal;
    IBOutlet NSTextField *scriptargs;
    IBOutlet NSTextField *commandline;

    NSString *script;
    NSString *filetype;
    FileSettings *settings;
}

- (IBAction)do_run:(id)sender;
- (IBAction)do_cancel:(id)sender;
- (IBAction)do_reset:(id)sender;
- (IBAction)do_apply:(id)sender;

- (void)controlTextDidChange:(NSNotification *)aNotification;

@end


================================================
File: /Mac/PythonLauncher/MyDocument.m
================================================
//
//  MyDocument.m
//  PythonLauncher
//
//  Created by Jack Jansen on Fri Jul 19 2002.
//  Copyright (c) 2002 __MyCompanyName__. All rights reserved.
//

#import "MyDocument.h"
#import "MyAppDelegate.h"
#import "doscript.h"

@implementation MyDocument

- (id)init
{
    self = [super init];
    if (self) {

        // Add your subclass-specific initialization here.
        // If an error occurs here, send a [self dealloc] message and return nil.
        script = [@"<no script>.py" retain];
        filetype = [@"Python Script" retain];
        settings = NULL;
    }
    return self;
}

- (NSString *)windowNibName
{
    // Override returning the nib file name of the document
    // If you need to use a subclass of NSWindowController or if your document supports multiple NSWindowControllers, you should remove this method and override -makeWindowControllers instead.
    return @"MyDocument";
}

- (void)close
{
    NSApplication *app = [NSApplication sharedApplication];
    [super close];
    if ([(MyAppDelegate*)[app delegate] shouldTerminate])
        [app terminate: self];
}

- (void)load_defaults
{
    settings = [FileSettings newSettingsForFileType: filetype];
}

- (void)update_display
{
    [interpreter setStringValue: [settings interpreter]];
    [honourhashbang setState: [settings honourhashbang]];
    [debug setState: [settings debug]];
    [verbose setState: [settings verbose]];
    [inspect setState: [settings inspect]];
    [optimize setState: [settings optimize]];
    [nosite setState: [settings nosite]];
    [tabs setState: [settings tabs]];
    [others setStringValue: [settings others]];
    [scriptargs setStringValue: [settings scriptargs]];
    [with_terminal setState: [settings with_terminal]];

    [commandline setStringValue: [settings commandLineForScript: script]];
}

- (void)update_settings
{
    [settings updateFromSource: self];
}

- (BOOL)run
{
    const char *cmdline;
    int sts;

     cmdline = [[settings commandLineForScript: script] UTF8String];
   if ([settings with_terminal]) {
        sts = doscript(cmdline);
    } else {
        sts = system(cmdline);
    }
    if (sts) {
        NSLog(@"Exit status: %d\n", sts);
        return NO;
    }
    return YES;
}

- (void)windowControllerDidLoadNib:(NSWindowController *) aController
{
    [super windowControllerDidLoadNib:aController];
    // Add any code here that need to be executed once the windowController has loaded the document's window.
    [self load_defaults];
    [self update_display];
}

- (NSData *)dataRepresentationOfType:(NSString *)aType
{
    // Insert code here to write your document from the given data.  You can also choose to override -fileWrapperRepresentationOfType: or -writeToFile:ofType: instead.
    return nil;
}

- (BOOL)readFromFile:(NSString *)fileName ofType:(NSString *)type;
{
    // Insert code here to read your document from the given data.  You can also choose to override -loadFileWrapperRepresentation:ofType: or -readFromFile:ofType: instead.
    BOOL show_ui;

    // ask the app delegate whether we should show the UI or not.
    show_ui = [(MyAppDelegate*)[[NSApplication sharedApplication] delegate] shouldShowUI];
    [script release];
    script = [fileName retain];
    [filetype release];
    filetype = [type retain];
    settings = [FileSettings newSettingsForFileType: filetype];
    if (show_ui) {
        [self update_display];
        return YES;
    } else {
        [self run];
	[self performSelector:@selector(close) withObject:nil afterDelay:0.0];
        return YES;
    }
}

- (IBAction)do_run:(id)sender
{
    [self update_settings];
    [self update_display];
    if ([self run])
        [self close];
}

- (IBAction)do_cancel:(id)sender
{
    [self close];
}


- (IBAction)do_reset:(id)sender
{
    [settings reset];
    [self update_display];
}

- (IBAction)do_apply:(id)sender
{
    [self update_settings];
    [self update_display];
}

// FileSettingsSource protocol
- (NSString *) interpreter { return [interpreter stringValue];};
- (BOOL) honourhashbang { return [honourhashbang state];};
- (BOOL) debug { return [debug state];};
- (BOOL) verbose { return [verbose state];};
- (BOOL) inspect { return [inspect state];};
- (BOOL) optimize { return [optimize state];};
- (BOOL) nosite { return [nosite state];};
- (BOOL) tabs { return [tabs state];};
- (NSString *) others { return [others stringValue];};
- (NSString *) scriptargs { return [scriptargs stringValue];};
- (BOOL) with_terminal { return [with_terminal state];};

// Delegates
- (void)controlTextDidChange:(NSNotification *)aNotification
{
    [self update_settings];
    [self update_display];
};

@end


================================================
File: /Mac/PythonLauncher/PreferencesWindowController.h
================================================
/* PreferencesWindowController */

#import <Cocoa/Cocoa.h>

#import "FileSettings.h"

@interface PreferencesWindowController : NSWindowController <FileSettingsSource>
{
    IBOutlet NSPopUpButton *filetype;
    IBOutlet NSComboBox *interpreter;
    IBOutlet NSButton *honourhashbang;
    IBOutlet NSButton *debug;
    IBOutlet NSButton *verbose;
    IBOutlet NSButton *inspect;
    IBOutlet NSButton *optimize;
    IBOutlet NSButton *nosite;
    IBOutlet NSButton *tabs;
    IBOutlet NSTextField *others;
    IBOutlet NSButton *with_terminal;
    IBOutlet NSTextField *commandline;

    FileSettings *settings;
}

+ getPreferencesWindow;

- (IBAction)do_reset:(id)sender;
- (IBAction)do_apply:(id)sender;
- (IBAction)do_filetype:(id)sender;

- (void)controlTextDidChange:(NSNotification *)aNotification;

- (unsigned int)comboBox:(NSComboBox *)aComboBox indexOfItemWithStringValue:(NSString *)aString;
- (id)comboBox:(NSComboBox *)aComboBox objectValueForItemAtIndex:(int)index;
- (int)numberOfItemsInComboBox:(NSComboBox *)aComboBox;


@end


================================================
File: /Mac/PythonLauncher/PreferencesWindowController.m
================================================
#import "PreferencesWindowController.h"

@implementation PreferencesWindowController

+ getPreferencesWindow
{
    static PreferencesWindowController *_singleton;

    if (!_singleton)
        _singleton = [[PreferencesWindowController alloc] init];
    [_singleton showWindow: _singleton];
    return _singleton;
}

- (id) init
{
    self = [self initWithWindowNibName: @"PreferenceWindow"];
    return self;
}

- (void)load_defaults
{
    NSString *title = [filetype titleOfSelectedItem];

    settings = [FileSettings getDefaultsForFileType: title];
}

- (void)update_display
{
    [interpreter reloadData];
    [interpreter setStringValue: [settings interpreter]];
    [honourhashbang setState: [settings honourhashbang]];
    [debug setState: [settings debug]];
    [verbose setState: [settings verbose]];
    [inspect setState: [settings inspect]];
    [optimize setState: [settings optimize]];
    [nosite setState: [settings nosite]];
    [tabs setState: [settings tabs]];
    [others setStringValue: [settings others]];
    [with_terminal setState: [settings with_terminal]];
    // Not scriptargs, it isn't for preferences
    [commandline setStringValue: [settings commandLineForScript: @"<your script here>"]];
}

- (void) windowDidLoad
{
    [super windowDidLoad];
    [self load_defaults];
    [self update_display];
}

- (void)update_settings
{
    [settings updateFromSource: self];
}

- (IBAction)do_filetype:(id)sender
{
    [self load_defaults];
    [self update_display];
}

- (IBAction)do_reset:(id)sender
{
    [settings reset];
    [self update_display];
}

- (IBAction)do_apply:(id)sender
{
    [self update_settings];
    [self update_display];
}

// FileSettingsSource protocol
- (NSString *) interpreter { return [interpreter stringValue];};
- (BOOL) honourhashbang { return [honourhashbang state]; };
- (BOOL) debug { return [debug state];};
- (BOOL) verbose { return [verbose state];};
- (BOOL) inspect { return [inspect state];};
- (BOOL) optimize { return [optimize state];};
- (BOOL) nosite { return [nosite state];};
- (BOOL) tabs { return [tabs state];};
- (NSString *) others { return [others stringValue];};
- (BOOL) with_terminal { return [with_terminal state];};
- (NSString *) scriptargs { return @"";};

// Delegates
- (void)controlTextDidChange:(NSNotification *)aNotification
{
    [self update_settings];
    [self update_display];
};

// NSComboBoxDataSource protocol
- (unsigned int)comboBox:(NSComboBox *)aComboBox indexOfItemWithStringValue:(NSString *)aString
{
	NSArray *interp_list = [settings interpreters];
    unsigned int rv = [interp_list indexOfObjectIdenticalTo: aString];
	return rv;
}

- (id)comboBox:(NSComboBox *)aComboBox objectValueForItemAtIndex:(int)index
{
	NSArray *interp_list = [settings interpreters];
    id rv = [interp_list objectAtIndex: index];
	return rv;
}

- (int)numberOfItemsInComboBox:(NSComboBox *)aComboBox
{
	NSArray *interp_list = [settings interpreters];
    int rv = [interp_list count];
	return rv;
}


@end


================================================
File: /Mac/PythonLauncher/doscript.h
================================================
/*
 *  doscript.h
 *  PythonLauncher
 *
 *  Created by Jack Jansen on Wed Jul 31 2002.
 *  Copyright (c) 2002 __MyCompanyName__. All rights reserved.
 *
 */

#include <Carbon/Carbon.h>

extern int doscript(const char *command);


================================================
File: /Mac/PythonLauncher/doscript.m
================================================
/*
 *  doscript.c
 *  PythonLauncher
 *
 *  Created by Jack Jansen on Wed Jul 31 2002.
 *  Copyright (c) 2002 __MyCompanyName__. All rights reserved.
 *
 */

#import <Cocoa/Cocoa.h>
#import <ApplicationServices/ApplicationServices.h>
#import "doscript.h"

extern int
doscript(const char *command)
{
    char *bundleID = "com.apple.Terminal";
    AppleEvent evt, res;
    AEDesc desc;
    OSStatus err;

    [[NSWorkspace sharedWorkspace] launchApplication:@"Terminal.app"];

    // Build event
    err = AEBuildAppleEvent(kAECoreSuite, kAEDoScript,
                             typeApplicationBundleID,
                             bundleID, strlen(bundleID),
                             kAutoGenerateReturnID,
                             kAnyTransactionID,
                             &evt, NULL,
                             "'----':utf8(@)", strlen(command),
                             command);
    if (err) {
        NSLog(@"AEBuildAppleEvent failed: %ld\n", (long)err);
        return err;
    }

    // Send event and check for any Apple Event Manager errors
    err = AESendMessage(&evt, &res, kAEWaitReply, kAEDefaultTimeout);
    AEDisposeDesc(&evt);
    if (err) {
        NSLog(@"AESendMessage failed: %ld\n", (long)err);
        return err;
    }
    // Check for any application errors
    err = AEGetParamDesc(&res, keyErrorNumber, typeSInt32, &desc);
    AEDisposeDesc(&res);
    if (!err) {
        AEGetDescData(&desc, &err, sizeof(err));
        NSLog(@"Terminal returned an error: %ld", (long)err);
        AEDisposeDesc(&desc);
    } else if (err == errAEDescNotFound) {
        err = noErr;
    } else {
        NSLog(@"AEGetPArmDesc returned an error: %ld", (long)err);
    }

    return err;
}


================================================
File: /Mac/PythonLauncher/factorySettings.plist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
        <key>Python GUI Script</key>
        <dict>
                <key>debug</key>
                <false/>
                <key>inspect</key>
                <false/>
                <key>interpreter_list</key>
                <array>
                    <string>/usr/local/bin/python3</string>
                    <string>/opt/local/bin/python3</string>
                    <string>/sw/bin/python3</string>
                </array>
                <key>honourhashbang</key>
                <false/>
                <key>nosite</key>
                <false/>
                <key>optimize</key>
                <false/>
                <key>others</key>
                <string></string>
                <key>verbose</key>
                <false/>
                <key>with_terminal</key>
                <false/>
        </dict>
        <key>Python Script</key>
        <dict>
                <key>debug</key>
                <false/>
                <key>inspect</key>
                <false/>
                <key>interpreter_list</key>
                <array>
                    <string>/usr/local/bin/python3</string>
                    <string>/opt/local/bin/python3</string>
                    <string>/sw/bin/python3</string>
                </array>
                <key>honourhashbang</key>
                <false/>
                <key>nosite</key>
                <false/>
                <key>optimize</key>
                <false/>
                <key>others</key>
                <string></string>
                <key>verbose</key>
                <false/>
                <key>with_terminal</key>
                <true/>
        </dict>
        <key>Python Bytecode Document</key>
        <dict>
                <key>debug</key>
                <false/>
                <key>inspect</key>
                <false/>
                <key>interpreter_list</key>
                <array>
                    <string>/usr/local/bin/python3</string>
                    <string>/opt/local/bin/python3</string>
                    <string>/sw/bin/python3</string>
                </array>
                <key>honourhashbang</key>
                <false/>
                 <key>nosite</key>
                <false/>
                <key>optimize</key>
                <false/>
                <key>others</key>
                <string></string>
                <key>verbose</key>
                <false/>
                <key>with_terminal</key>
                <true/>
        </dict>
</dict>
</plist>


================================================
File: /Mac/PythonLauncher/main.m
================================================
//
//  main.m
//  PythonLauncher
//
//  Created by Jack Jansen on Fri Jul 19 2002.
//  Copyright (c) 2002 __MyCompanyName__. All rights reserved.
//

#import <Cocoa/Cocoa.h>
#include <unistd.h>

int main(int argc, const char *argv[])
{
    char *home = getenv("HOME");
    if (home) chdir(home);
    return NSApplicationMain(argc, argv);
}


================================================
File: /Mac/PythonLauncher/English.lproj/Credits.rtf
================================================
{\rtf1\mac\ansicpg10000\cocoartf100
{\fonttbl\f0\fswiss\fcharset77 Helvetica-Bold;\f1\fswiss\fcharset77 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural

\f0\b\fs24 \cf0 Engineering:
\f1\b0 \
	Jack Jansen\
\

\f0\b Human Interface Design:
\f1\b0 \
	Jack Jansen\
\

\f0\b Testing:
\f1\b0 \
	Jack Jansen\
        Pythonmac-SIG@python.org\
\

\f0\b Documentation:
\f1\b0 \
	Missing\
\

\f0\b With special thanks to:
\f1\b0 \
	Guido, of course\
}

================================================
File: /Mac/PythonLauncher/English.lproj/MainMenu.nib/classes.nib
================================================
{
    IBClasses = (
        {CLASS = FirstResponder; LANGUAGE = ObjC; SUPERCLASS = NSObject; }, 
        {
            ACTIONS = {showPreferences = id; }; 
            CLASS = MyAppDelegate; 
            LANGUAGE = ObjC; 
            SUPERCLASS = NSObject; 
        }
    ); 
    IBVersion = 1; 
}

================================================
File: /Mac/PythonLauncher/English.lproj/MainMenu.nib/info.nib
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist SYSTEM "file://localhost/System/Library/DTDs/PropertyList.dtd">
<plist version="0.9">
<dict>
	<key>IBDocumentLocation</key>
	<string>99 33 356 240 0 0 800 578 </string>
	<key>IBEditorPositions</key>
	<dict>
		<key>29</key>
		<string>82 396 318 44 0 0 800 578 </string>
	</dict>
	<key>IBFramework Version</key>
	<string>263.2</string>
	<key>IBOpenObjects</key>
	<array>
		<integer>29</integer>
	</array>
	<key>IBSystem Version</key>
	<string>5S66</string>
</dict>
</plist>


================================================
File: /Mac/PythonLauncher/English.lproj/MyDocument.nib/classes.nib
================================================
{
    IBClasses = (
        {CLASS = FirstResponder; LANGUAGE = ObjC; SUPERCLASS = NSObject; }, 
        {
            ACTIONS = {"do_apply" = id; "do_cancel" = id; "do_reset" = id; "do_run" = id; }; 
            CLASS = MyDocument; 
            LANGUAGE = ObjC; 
            OUTLETS = {
                commandline = NSTextField; 
                debug = NSButton; 
                honourhashbang = NSButton; 
                inspect = NSButton; 
                interpreter = NSTextField; 
                nosite = NSButton; 
                optimize = NSButton; 
                others = NSTextField; 
                scriptargs = NSTextField; 
                tabs = NSButton; 
                verbose = NSButton; 
                "with_terminal" = NSButton; 
            }; 
            SUPERCLASS = NSDocument; 
        }
    ); 
    IBVersion = 1; 
}

================================================
File: /Mac/PythonLauncher/English.lproj/MyDocument.nib/info.nib
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IBDocumentLocation</key>
	<string>398 60 356 240 0 0 1024 746 </string>
	<key>IBFramework Version</key>
	<string>291.0</string>
	<key>IBOpenObjects</key>
	<array>
		<integer>5</integer>
	</array>
	<key>IBSystem Version</key>
	<string>6L60</string>
</dict>
</plist>


================================================
File: /Mac/PythonLauncher/English.lproj/PreferenceWindow.nib/classes.nib
================================================
{
    IBClasses = (
        {CLASS = FirstResponder; LANGUAGE = ObjC; SUPERCLASS = NSObject; }, 
        {
            ACTIONS = {"do_apply" = id; "do_filetype" = id; "do_reset" = id; }; 
            CLASS = PreferencesWindowController; 
            LANGUAGE = ObjC; 
            OUTLETS = {
                commandline = NSTextField; 
                debug = NSButton; 
                filetype = NSPopUpButton; 
                honourhashbang = NSButton; 
                inspect = NSButton; 
                interpreter = NSTextField; 
                nosite = NSButton; 
                optimize = NSButton; 
                others = NSTextField; 
                tabs = NSButton; 
                verbose = NSButton; 
                "with_terminal" = NSButton; 
            }; 
            SUPERCLASS = NSWindowController; 
        }
    ); 
    IBVersion = 1; 
}

================================================
File: /Mac/PythonLauncher/English.lproj/PreferenceWindow.nib/info.nib
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>IBDocumentLocation</key>
	<string>565 235 519 534 0 0 1280 1002 </string>
	<key>IBFramework Version</key>
	<string>364.0</string>
	<key>IBOpenObjects</key>
	<array>
		<integer>5</integer>
	</array>
	<key>IBSystem Version</key>
	<string>7H63</string>
</dict>
</plist>


================================================
File: /Mac/Resources/app-store-compliance.patch
================================================
diff --git a/Lib/test/test_urlparse.py b/Lib/test/test_urlparse.py
index d6c83a75c1c..19ed4e01091 100644
--- a/Lib/test/test_urlparse.py
+++ b/Lib/test/test_urlparse.py
@@ -237,11 +237,6 @@ def test_roundtrips(self):
               '','',''),
              ('git+ssh', 'git@github.com','/user/project.git',
               '', '')),
-            ('itms-services://?action=download-manifest&url=https://example.com/app',
-             ('itms-services', '', '', '',
-              'action=download-manifest&url=https://example.com/app', ''),
-             ('itms-services', '', '',
-              'action=download-manifest&url=https://example.com/app', '')),
             ('+scheme:path/to/file',
              ('', '', '+scheme:path/to/file', '', '', ''),
              ('', '', '+scheme:path/to/file', '', '')),
diff --git a/Lib/urllib/parse.py b/Lib/urllib/parse.py
index 8f724f907d4..148caf742c9 100644
--- a/Lib/urllib/parse.py
+++ b/Lib/urllib/parse.py
@@ -59,7 +59,7 @@
                'imap', 'wais', 'file', 'mms', 'https', 'shttp',
                'snews', 'prospero', 'rtsp', 'rtsps', 'rtspu', 'rsync',
                'svn', 'svn+ssh', 'sftp', 'nfs', 'git', 'git+ssh',
-               'ws', 'wss', 'itms-services']
+               'ws', 'wss']

 uses_params = ['', 'ftp', 'hdl', 'prospero', 'http', 'imap',
                'https', 'shttp', 'rtsp', 'rtsps', 'rtspu', 'sip',


================================================
File: /Mac/Resources/app/Info.plist.in
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple Computer//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleDocumentTypes</key>
	<array>
		<dict>
			<key>CFBundleTypeOSTypes</key>
			<array>
				<string>****</string>
				<string>fold</string>
				<string>disk</string>
			</array>
			<key>CFBundleTypeRole</key>
			<string>Viewer</string>
		</dict>
	</array>
	<key>CFBundleExecutable</key>
	<string>Python</string>
	<key>CFBundleGetInfoString</key>
	<string>%version%, (c) 2001-2024 Python Software Foundation.</string>
	<key>CFBundleHelpBookFolder</key>
	<array>
		<string>Documentation</string>
		<string>PythonDocumentation</string>
	</array>
	<key>CFBundleHelpBookName</key>
	<string>MacPython Help</string>
	<key>CFBundleHelpTOCFile</key>
	<string>index.html</string>
	<key>CFBundleIconFile</key>
	<string>PythonInterpreter.icns</string>
	<key>CFBundleIdentifier</key>
	<string>%bundleid%</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleLongVersionString</key>
	<string>%version%, (c) 2001-2024 Python Software Foundation.</string>
	<key>CFBundleName</key>
	<string>Python</string>
	<key>CFBundlePackageType</key>
	<string>APPL</string>
	<key>CFBundleShortVersionString</key>
	<string>%version%</string>
	<key>CFBundleSignature</key>
	<string>PytX</string>
	<key>CFBundleVersion</key>
	<string>%version%</string>
	<key>CSResourcesFileMapped</key>
	<true/>
	<key>LSRequiresCarbon</key>
	<true/>
	<key>NSAppleScriptEnabled</key>
	<true/>
	<key>NSHumanReadableCopyright</key>
	<string>(c) 2001-2024 Python Software Foundation.</string>
	<key>NSHighResolutionCapable</key>
	<true/>
	<key>CFBundleAllowMixedLocalizations</key>
	<true/>
</dict>
</plist>


================================================
File: /Mac/Resources/app/PkgInfo
================================================
APPLPytX

================================================
File: /Mac/Resources/framework/Info.plist.in
================================================
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist SYSTEM "file://localhost/System/Library/DTDs/PropertyList.dtd">
<plist version="0.9">
<dict>
	<key>CFBundleDevelopmentRegion</key>
	<string>English</string>
	<key>CFBundleExecutable</key>
	<string>Python</string>
	<key>CFBundleGetInfoString</key>
	<string>Python Runtime and Library</string>
	<key>CFBundleIdentifier</key>
	<string>@PYTHONFRAMEWORKIDENTIFIER@</string>
	<key>CFBundleInfoDictionaryVersion</key>
	<string>6.0</string>
	<key>CFBundleName</key>
	<string>Python</string>
	<key>CFBundlePackageType</key>
	<string>FMWK</string>
	<key>CFBundleShortVersionString</key>
	<string>%VERSION%, (c) 2001-2024 Python Software Foundation.</string>
	<key>CFBundleLongVersionString</key>
	<string>%VERSION%, (c) 2001-2024 Python Software Foundation.</string>
	<key>CFBundleSignature</key>
	<string>????</string>
	<key>CFBundleVersion</key>
	<string>%VERSION%</string>
	<key>CFBundleAllowMixedLocalizations</key>
	<true/>
</dict>
</plist>


================================================
File: /Mac/Tools/plistlib_generate_testdata.py
================================================
#!/usr/bin/env python3

from Cocoa import NSMutableDictionary, NSMutableArray, NSString, NSDate, NSNumber
from Cocoa import NSPropertyListSerialization, NSPropertyListOpenStepFormat
from Cocoa import NSPropertyListXMLFormat_v1_0, NSPropertyListBinaryFormat_v1_0
from Cocoa import CFUUIDCreateFromString, NSNull, NSUUID, CFPropertyListCreateData
from Cocoa import NSURL
from Cocoa import NSKeyedArchiver

import datetime
from collections import OrderedDict
import binascii

FORMATS=[
#    ('openstep', NSPropertyListOpenStepFormat),
    ('plistlib.FMT_XML', NSPropertyListXMLFormat_v1_0),
    ('plistlib.FMT_BINARY', NSPropertyListBinaryFormat_v1_0),
]

def nsstr(value):
    return NSString.alloc().initWithString_(value)


def main():
    pl = OrderedDict()

    # Note: pl is an OrderedDict to control the order
    # of keys, and hence have some control on the structure
    # of the output file.
    # New keys should be added in alphabetical order.

    seconds = datetime.datetime(2004, 10, 26, 10, 33, 33, tzinfo=datetime.timezone(datetime.timedelta(0))).timestamp()
    pl[nsstr('aBigInt')] = 2 ** 63 - 44
    pl[nsstr('aBigInt2')] = NSNumber.numberWithUnsignedLongLong_(2 ** 63 + 44)
    pl[nsstr('aDate')] = NSDate.dateWithTimeIntervalSince1970_(seconds)

    pl[nsstr('aDict')] = d = OrderedDict()
    d[nsstr('aFalseValue')] = False
    d[nsstr('aTrueValue')] = True
    d[nsstr('aUnicodeValue')] = "M\xe4ssig, Ma\xdf"
    d[nsstr('anotherString')] = "<hello & 'hi' there!>"
    d[nsstr('deeperDict')] = dd = OrderedDict()
    dd[nsstr('a')] = 17
    dd[nsstr('b')] = 32.5
    dd[nsstr('c')] = a = NSMutableArray.alloc().init()
    a.append(1)
    a.append(2)
    a.append(nsstr('text'))

    pl[nsstr('aFloat')] = 0.5

    pl[nsstr('aList')] = a = NSMutableArray.alloc().init()
    a.append(nsstr('A'))
    a.append(nsstr('B'))
    a.append(12)
    a.append(32.5)
    aa = NSMutableArray.alloc().init()
    a.append(aa)
    aa.append(1)
    aa.append(2)
    aa.append(3)

    pl[nsstr('aNegativeBigInt')] = -80000000000
    pl[nsstr('aNegativeInt')] = -5
    pl[nsstr('aString')] = nsstr('Doodah')

    pl[nsstr('anEmptyDict')] = NSMutableDictionary.alloc().init()

    pl[nsstr('anEmptyList')] = NSMutableArray.alloc().init()

    pl[nsstr('anInt')] = 728

    pl[nsstr('nestedData')] = a = NSMutableArray.alloc().init()
    a.append(b'''<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03''')


    pl[nsstr('someData')] = b'<binary gunk>'

    pl[nsstr('someMoreData')] = b'''<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03<lots of binary gunk>\x00\x01\x02\x03'''

    pl[nsstr('\xc5benraa')] = nsstr("That was a unicode key.")

    print("TESTDATA={")
    for fmt_name, fmt_key in FORMATS:
        data, error = NSPropertyListSerialization.dataWithPropertyList_format_options_error_(
            pl, fmt_key, 0, None)
        if data is None:
            print("Cannot serialize", fmt_name, error)

        else:
            print("    %s: binascii.a2b_base64(b'''\n        %s'''),"%(fmt_name, _encode_base64(bytes(data)).decode('ascii')[:-1]))

    keyed_archive_data = NSKeyedArchiver.archivedDataWithRootObject_("KeyArchive UID Test")
    print("    'KEYED_ARCHIVE': binascii.a2b_base64(b'''\n        %s''')," % (_encode_base64(bytes(keyed_archive_data)).decode('ascii')[:-1]))
    print("}")
    print()

def _encode_base64(s, maxlinelength=60):
    maxbinsize = (maxlinelength//4)*3
    pieces = []
    for i in range(0, len(s), maxbinsize):
        chunk = s[i : i + maxbinsize]
        pieces.append(binascii.b2a_base64(chunk))
    return b'        '.join(pieces)

main()


================================================
File: /Mac/Tools/pythonw.c
================================================
/*
 * This wrapper program executes a python executable hidden inside an
 * application bundle inside the Python framework. This is needed to run
 * GUI code: some GUI API's don't work unless the program is inside an
 * application bundle.
 *
 * This program uses posix_spawn rather than plain execv because we need
 * slightly more control over how the "real" interpreter is executed.
 *
 * On OSX 10.4 (and earlier) this falls back to using exec because the
 * posix_spawnv functions aren't available there.
 */

#pragma weak_import posix_spawnattr_init
#pragma weak_import posix_spawnattr_setbinpref_np
#pragma weak_import posix_spawnattr_setflags
#pragma weak_import posix_spawn

#include <Python.h>
#include <unistd.h>
#ifdef HAVE_SPAWN_H
#include <spawn.h>
#endif
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <err.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <mach-o/dyld.h>


extern char** environ;

/*
 * Locate the python framework by looking for the
 * library that contains Py_Initialize.
 *
 * In a regular framework the structure is:
 *
 *    Python.framework/Versions/2.7
 *              /Python
 *              /Resources/Python.app/Contents/MacOS/Python
 *
 * In a virtualenv style structure the expected
 * structure is:
 *
 *    ROOT
 *       /bin/pythonw
 *       /.Python   <- the dylib
 *       /.Resources/Python.app/Contents/MacOS/Python
 *
 * NOTE: virtualenv's are not an officially supported
 * feature, support for that structure is provided as
 * a convenience.
 */
static char* get_python_path(void)
{
    size_t len;
    Dl_info info;
    char* end;
    char* g_path;

    if (dladdr(Py_Initialize, &info) == 0) {
        return NULL;
    }

    len = strlen(info.dli_fname);

    g_path = malloc(len+60);
    if (g_path == NULL) {
        return NULL;
    }

    strcpy(g_path, info.dli_fname);
    end = g_path + len - 1;
    while (end != g_path && *end != '/') {
        end --;
    }
    end++;
    if (*end == '.') {
        end++;
    }
    strcpy(end, "Resources/Python.app/Contents/MacOS/" PYTHONFRAMEWORK);

    return g_path;
}

#ifdef HAVE_SPAWN_H
static void
setup_spawnattr(posix_spawnattr_t* spawnattr)
{
    size_t ocount;
    size_t count;
    cpu_type_t cpu_types[1];
    short flags = 0;

    if ((errno = posix_spawnattr_init(spawnattr)) != 0) {
        err(2, "posix_spawnattr_int");
        /* NOTREACHTED */
    }

    count = 1;

    /* Run the real python executable using the same architecture as this
     * executable, this allows users to control the architecture using
     * "arch -ppc python"
     */

#if defined(__ppc64__)
    cpu_types[0] = CPU_TYPE_POWERPC64;

#elif defined(__x86_64__)
    cpu_types[0] = CPU_TYPE_X86_64;

#elif defined(__ppc__)
    cpu_types[0] = CPU_TYPE_POWERPC;

#elif defined(__i386__)
    cpu_types[0] = CPU_TYPE_X86;

#elif defined(__arm64__)
    cpu_types[0] = CPU_TYPE_ARM64;

#else
#       error "Unknown CPU"

#endif

    if (posix_spawnattr_setbinpref_np(spawnattr, count,
                            cpu_types, &ocount) == -1) {
        err(1, "posix_spawnattr_setbinpref");
        /* NOTREACHTED */
    }
    if (count != ocount) {
        fprintf(stderr, "posix_spawnattr_setbinpref failed to copy\n");
        exit(1);
        /* NOTREACHTED */
    }


    /*
     * Set flag that causes posix_spawn to behave like execv
     */
    flags |= POSIX_SPAWN_SETEXEC;
    if ((errno = posix_spawnattr_setflags(spawnattr, flags)) != 0) {
        err(1, "posix_spawnattr_setflags");
        /* NOTREACHTED */
    }
}
#endif

int
main(int argc, char **argv) {
    char* exec_path = get_python_path();
    static char path[PATH_MAX * 2];
    static char real_path[PATH_MAX * 2];
    int status;
    uint32_t size = PATH_MAX * 2;

    /* Set the original executable path in the environment. */
    status = _NSGetExecutablePath(path, &size);
    if (status == 0) {
        /*
         * Note: don't call 'realpath', that will
         * erase symlink information, and that
         * breaks "pyvenv --symlink"
         *
         * It is nice to have the directory name
         * as a cleaned up absolute path though,
         * therefore call realpath on dirname(path)
         */
        char* slash = strrchr(path, '/');
        if (slash) {
            char  replaced;
            replaced = slash[1];
            slash[1] = 0;
            if (realpath(path, real_path) == NULL) {
                err(1, "realpath: %s", path);
            }
            slash[1] = replaced;
            if (strlcat(real_path, slash, sizeof(real_path)) > sizeof(real_path)) {
                errno = EINVAL;
                err(1, "realpath: %s", path);
            }

        } else {
            if (realpath(".", real_path) == NULL) {
                err(1, "realpath: %s", path);
            }
            if (strlcat(real_path, "/", sizeof(real_path)) > sizeof(real_path)) {
                errno = EINVAL;
                err(1, "realpath: %s", path);
            }
            if (strlcat(real_path, path, sizeof(real_path)) > sizeof(real_path)) {
                errno = EINVAL;
                err(1, "realpath: %s", path);
            }
        }

        /*
         * The environment variable is used to pass the value of real_path
         * to the actual python interpreter, and is read by code in
         * Python/coreconfig.c.
         *
         * This way the real interpreter knows how the user invoked the
         * interpreter and can behave as if this launcher is the real
         * interpreter (looking for pyvenv configuration, ...)
         */
        setenv("__PYVENV_LAUNCHER__", real_path, 1);
    }

    /*
     * Let argv[0] refer to the new interpreter. This is needed to
     * get the effect we want on OSX 10.5 or earlier. That is, without
     * changing argv[0] the real interpreter won't have access to
     * the Window Server.
     */
    argv[0] = exec_path;

#ifdef HAVE_SPAWN_H
    /* We're weak-linking to posix-spawnv to ensure that
     * an executable build on 10.5 can work on 10.4.
     */

    if (&posix_spawn != NULL) {
        posix_spawnattr_t spawnattr = NULL;

        setup_spawnattr(&spawnattr);
        posix_spawn(NULL, exec_path, NULL,
            &spawnattr, argv, environ);
        err(1, "posix_spawn: %s", exec_path);
    }
#endif
    execve(exec_path, argv, environ);
    err(1, "execve: %s", argv[0]);
    /* NOTREACHED */
}


================================================
File: /Misc/ACKS
================================================
Acknowledgements
----------------

This list is not complete and not in any useful order, but I would
like to thank everybody who contributed in any way, with code, hints,
bug reports, ideas, moral support, endorsement, or even complaints....
Without you, I would've stopped working on Python long ago!

	--Guido

PS: In the standard Python distribution, this file is encoded in UTF-8
and the list is in rough alphabetical order by last names.

Aahz
Erlend Egeberg Aasland
Edison Abahurire
Michael Abbott
Rajiv Abraham
David Abrahams
Marc Abramowitz
Eldar Abusalimov
Ron Adam
Eitan Adler
Anton Afanasyev
Ali Afshar
Nitika Agarwal
Maxim Ageev
Anjani Agrawal
Pablo S. Blum de Aguiar
Jim Ahlstrom
Farhan Ahmad
Matthew Ahrens
Nir Aides
Akira
Ege Akman
Yaniv Aknin
Jyrki Alakuijala
Tatiana Al-Chueyr
Steve Alexander
Fred Allen
Jeff Allen
Ray Allen
Billy G. Allie
Jamiel Almeida
Kevin Altis
Samy Lahfa
Skyler Leigh Amador
Joe Amenta
Rose Ames
A. Amoroso
Mark Anacker
Shashwat Anand
Ananthakrishnan
Anders Andersen
Tycho Andersen
John Anderson
Pehr Anderson
Erik Andersén
Oliver Andrich
Ross Andrus
Fabrice Aneche
Juancarlo Añez
Chris Angelico
Jérémy Anger
Jon Anglin
Michele Angrisano
Ankur Ankan
Heidi Annexstad
David Antonini
Ramchandra Apte
Éric Araujo
Alexandru Ardelean
Emmanuel Arias
Alicia Arlen
Jeffrey Armstrong
Justin Turner Arthur
Jason Asbahr
David Ascher
Ammar Askar
Neil Aspinall
Chris AtLee
Aymeric Augustin
Andres Ayala
Cathy Avery
John Aycock
Donovan Baarda
Arne Babenhauserheide
Attila Babo
Matt Bachmann
Marcin Bachry
Alfonso Baciero
Dwayne Bailey
Stig Bakken
Lumír Balhar
Aleksandr Balezin
Greg Ball
Lewis Ball
Luigi Ballabio
Thomas Ballinger
Jeff Balogh
Manuel Balsera
Matt Bandy
Dmi Baranov
Michael J. Barber
Daniel Barclay
Nicolas Bareil
Chris Barker
Steven Barker
Anton Barkovsky
Nick Barnes
Quentin Barnes
David Barnett
Matthew Barnett
Richard Barran
Cesar Eduardo Barros
Des Barry
Emanuel Barry
Ulf Bartelt
Campbell Barton
Don Bashford
Pior Bastida
Nick Bastin
Ned Batchelder
Jeff Bauer
Michael R Bax
Anthony Baxter
Mike Bayer
Samuel L. Bayer
Bo Bayles
Christopher Beacham AKA Lady Red
Tommy Beadle
Donald Beaudry
David Beazley
John Beck
Ingolf Becker
Neal Becker
Robin Becker
Torsten Becker
Bill Bedford
Michał Bednarski
Bas van Beek
Ian Beer
Stefan Behnel
Reimer Behrends
Maxime Bélanger
Ben Bell
Thomas Bellman
John Belmonte
Alexander “Саша” Belopolsky
Eli Bendersky
Nikhil Benesch
David Benjamin
Oscar Benjamin
Andrew Bennetts
Andy Bensky
Bennett Benson
Ezra Berch
Stuart Berg
Michel Van den Bergh
Julian Berman
Brice Berna
Olivier Bernard
Vivien Bernet-Rollande
Maxwell Bernstein
Jay Berry
Eric Beser
Steven Bethard
Stephen Bevan
Ron Bickers
Natalia B. Bidart
Adrian von Bidder
Olexa Bilaniuk
David Binger
Dominic Binks
Philippe Biondi
Michael Birtwell
Stuart Bishop
Zane Bitter
Roy Bixler
Daniel Black
Jonathan Black
Renaud Blanch
Justin Blanchard
Mike Bland
Martin Bless
Pablo Bleyer
Erik van Blokland
Stéphane Blondon
Eric Blossom
Sergey Bobrov
Finn Bock
Paul Boddie
Matthew Boedicker
Robin Boerdijk
Wannes Boeykens
Andra Bogildea
Matt Bogosian
Nikolay Bogoychev
David Bolen
Wouter Bolsterlee
Gawain Bolton
Carl Friedrich Bolz-Tereick
Forest Bond
Gregory Bond
David Bonner
Angelin Booz
Médéric Boquien
Matias Bordese
Jonas Borgström
Jurjen Bos
Peter Bosch
Dan Boswell
Eric Bouck
Thierry Bousch
Sebastian Boving
Michal Bozon
Arseny Boykov
Jeff Bradberry
Chris Bradbury
Aaron Brancotti
Monty Brandenberg
Georg Brandl
Christopher Brannon
Terrence Brannon
Erin Braswell
Sven Brauch
Germán M. Bravo
Erik Bray
Brian Brazil
Demian Brecht
Dave Brennan
Christopher Richard James Brett
Tom Bridgman
Anthony Briggs
Keith Briggs
Tobias Brink
Miguel Brito
Dillon Brock
Richard Brodie
Michael Broghton
Ammar Brohi
Josh Bronson
Daniel Brotsky
Jean Brouwers
Amber Brown
Gary S. Brown
Titus Brown
Oleg Broytmann
Dave Brueck
Francisco Martín Brugué
Ian Bruntlett
Floris Bruynooghe
Matt Bryant
Stan Bubrouski
Brandt Bucher
Curtis Bucher
Colm Buckley
Erik de Bueger
Jan-Hein Bührman
Marc Bürg
Calvin Bui
Lars Buitinck
Artem Bulgakov
Dick Bulterman
Bill Bumgarner
Jimmy Burgett
Charles Burkland
Edmond Burnett
Tommy Burnette
Roger Burnham
Alastair Burt
Tarn Weisner Burton
Lee Busby
Katherine Busch
Matthias Bussonnier
Ralph Butler
Laurent De Buyst
Zach Byrne
Vedran Čačić
Nicolas Cadou
Jp Calderone
Ben Caller
Arnaud Calmettes
Daniel Calvelo
Tony Campbell
Giovanni Cappellotto
Brett Cannon
Joshua Cannon
Tristan Carel
Mike Carlton
Pierre Carrier
Terry Carroll
Edward Catmur
Lorenzo M. Catucci
Bruno Cauet
Donn Cave
James Cave
Charles Cazabon
Jesús Cea Avión
Per Cederqvist
Matěj Cepl
Carl Cerecke
Octavian Cerna
Michael Cetrulo
Dave Chambers
Pascal Chambon
Nicholas Chammas
Ofey Chan
Juhi Chandalia
John Chandler
Hye-Shik Chang
Jeffrey Chang
Gavin Chappell
Godefroid Chapelle
Brad Chapman
Greg Chapman
Mitch Chapman
Matt Chaput
William Chargin
Ben Chatterton
Yogesh Chaudhari
Gautam Chaudhuri
David Chaum
Nicolas Chauvat
Jerry Chen
Michael Chermside
Ingrid Cheung
Adam Chhina
Terry Chia
Albert Chin-A-Young
Adal Chiriliuc
Matt Chisholm
Lita Cho
Kit Yan Choi
Byeongmin Choi
Sayan Chowdhury
Yuan-Chao Chou
Anders Chrigström
Tom Christiansen
Renee Chu
Vadim Chugunov
Mauro Cicognini
David Cinege
Craig Citro
Gilles Civario
Chris Clark
Diana Clarke
Laurie Clark-Michalek
Alexander Clarkson
Mike Clarkson
Andrew Clegg
Brad Clements
Robbie Clemons
Steve Clift
Hervé Coatanhay
Riccardo Coccioli
Jacob Coffee
Nick Coghlan
Josh Cogliati
Noam Cohen
Dave Cole
Terrence Cole
Benjamin Collar
Jeffery Collins
Robert Collins
Paul Colomiets
Samuel Colvin
Christophe Combelles
Geremy Condra
Denver Coneybeare
Phil Connell
Juan José Conti
Matt Conway
Devin Cook
David M. Cooke
Jason R. Coombs
Garrett Cooper
Greg Copeland
Ian Cordasco
Aldo Cortesi
Mircea Cosbuc
David Costanzo
Scott Cotton
Greg Couch
FX Coudert
David Cournapeau
Julien Courteau
Steve Cousins
Francisco Couzo
Alex Coventry
Matthew Dixon Cowles
Ryan Coyner
Christopher A. Craig
Jeremy Craven
Laura Creighton
Nick Crews
Tyler Crompton
Simon Cross
Felipe Cruz
Drew Csillag
Alessandro Cucci
Joaquin Cuenca Abela
Sebastian Cufre
John Cugini
Tom Culliton
Raúl Cumplido
Antonio Cuni
Brian Curtin
Jason Curtis
Hakan Celik
Paul Dagnelie
Florian Dahlitz
Lisandro Dalcin
Darren Dale
Andrew Dalke
Lars Damerow
Evan Dandrea
Eric Daniel
Scott David Daniels
Derzsi Dániel
Lawrence D'Anna
Ben Darnell
Kushal Das
Jonathan Dasteel
Pierre-Yves David
A. Jesse Jiryu Davis
Jake Davis
Jamie (James C.) Davis
Ratnadeep Debnath
Merlijn van Deen
John DeGood
Ned Deily
Jim DeLaHunt
Vincent Delft
Arnaud Delobelle
Konrad Delong
Erik Demaine
Jeroen Demeyer
Martin Dengler
John Dennis
L. Peter Deutsch
Roger Dev
Philippe Devalkeneer
Raghuram Devarakonda
Caleb Deveraux
Catherine Devlin
Scott Dial
Alon Diamant
Lital Natan
Toby Dickenson
Mark Dickinson
Jack Diederich
Karl Ding
Daniel Diniz
Humberto Diogenes
Yves Dionne
Daniel Dittmar
Josip Djolonga
Walter Dörwald
Jaromir Dolecek
Zsolt Dollenstein
Brendan Donegan
Peter Donis
Ismail Donmez
Ray Donnelly
Robert Donohue
Marcos Donolo
Dima Dorfman
Yves Dorfsman
Michael Dorman
Andrey Doroschenko
Steve Dower
Allen Downey
Cesar Douady
Dean Draayer
Fred L. Drake, Jr.
Mehdi Drissi
Derk Drukker
John DuBois
Paul Dubois
Jacques Ducasse
Andrei Dorian Duma
Graham Dumpleton
Quinn Dunkan
Robin Dunn
Luke Dunstan
Virgil Dupras
Bruno Dupuis
Andy Dustman
Sayandip Dutta
Gary Duzan
Eugene Dvurechenski
Karmen Dykstra
Josip Dzolonga
Maxim Dzumanenko
Hans Eckardt
Rodolpho Eckhardt
Ulrich Eckhardt
David Edelsohn
John Edmonds
Benjamin Edwards
Grant Edwards
Vlad Efanov
Zvi Effron
John Ehresman
Tal Einat
Eric Eisner
Andrew Eland
Julien Élie
Eduardo Elizondo
Lance Ellinghaus
Daniel Ellis
Phil Elson
David Ely
Victor van den Elzen
Vlad Emelianov
Jeff Epler
Tom Epperly
Gökcen Eraslan
Stoffel Erasmus
Jürgen A. Erhard
Florian Ernst
Michael Ernst
Ben Escoto
Andy Eskilsson
André Espaze
Lucas Esposito
Stefan Esser
Nicolas Estibals
Jonathan Eunice
Carey Evans
Stephen D Evans
Tim Everett
Paul Everitt
David Everly
Daniel Evers
evilzero
Winston Ewert
Greg Ewing
Sam Ezeh
Martijn Faassen
Clovis Fabricio
Andreas Faerber
Bill Fancher
Michael Farrell
Troy J. Farrell
Jim Fasarakis-Hilliard
Mark Favas
Sergey Fedoseev
Boris Feld
M. Felt
Thomas Fenzl
Niels Ferguson
Francisco Fernández Castaño
Sebastian Fernandez
Florian Festi
John Feuerstein
Carl Feynman
Vincent Fiack
Niklas Fiekas
Anastasia Filatova
Tomer Filiba
Segev Finer
Jeffrey Finkelstein
Russell Finn
Neal Finne
Dan Finnie
Nils Fischbeck
Frederik Fix
Tom Flanagan
Matt Fleming
Sean Fleming
Hernán Martínez Foffani
Benjamin Fogle
Artem Fokin
Arnaud Fontaine
Michael Foord
Amaury Forgeot d'Arc
Doug Fort
Daniel Fortunov
Evens Fortuné
Chris Foster
John Fouhy
Andrew Francis
Matt Frank
Stefan Franke
Martin Franklin
Kent Frazier
Bruce Frederiksen
Jason Fried
Robin Friedrich
Bradley Froehle
Ivan Frohne
Matthias Fuchs
Jim Fulton
Tadayoshi Funaba
Gyro Funch
Peter Funk
Ethan Furman
Geoff Furnish
Ulisses Furquim
Hagen Fürstenau
Hallvard B Furuseth
Achim Gaedke
Martin von Gagern
Lele Gaifax
Santiago Gala
Yitzchak Gale
Matthew Gallagher
Quentin Gallet-Gilles
Riccardo Attilio Galli
Raymund Galvin
Nitin Ganatra
Soumendra Ganguly (गङ्गोपाध्याय)
Fred Gansevles
Paul Ganssle
Tian Gao
Lars Marius Garshol
Jake Garver
Dan Gass
Tim Gates
Andrew Gaul
Lewis Gaul
Matthieu Gautier
Stephen M. Gava
Xavier de Gaye
Harry Henry Gebel
Tamás Bence Gedai
Marius Gedminas
Jan-Philip Gehrcke
Thomas Gellekum
Gabriel Genellina
Andrew Geng
Philip Georgi
Christos Georgiou
Elazar (אלעזר) Gershuni
Ben Gertzfield
Nadim Ghaznavi
Dinu Gherman
Subhendu Ghosh
Jonathan Giddy
Johannes Gijsbers
Stephen Gildea
Michael Gilfix
Julian Gindi
Yannick Gingras
Neil Girdhar
Matt Giuca
Andrea Giudiceandrea
Franz Glasner
Jeff Glass
Wim Glenn
Michael Goderbauer
Karan Goel
Jeroen Van Goey
Christoph Gohlke
Tim Golden
Yonatan Goldschmidt
Mark Gollahon
Mikhail Golubev
Marta Gómez Macías
Guilherme Gonçalves
Tiago Gonçalves
Chris Gonnerman
Shelley Gooch
David Goodger
Michał Górny
Elliot Gorokhovsky
Hans de Graaff
Tim Graham
Kim Gräsman
Alex Grönholm
Thomas Grainger
Nathaniel Gray
Eddy De Greef
Duane Griffin
Grant Griffin
Andrea Griffini
Semyon Grigoryev
Duncan Grisby
Olivier Grisel
Fabian Groffen
Linus Groh
Eric Groo
Daniel Andrade Groppe
Dag Gruneau
Filip Gruszczyński
Andrii Grynenko
Grzegorz Grzywacz
Thomas Guettler
Yuyang Guo
Anuj Gupta
Om Gupta
Michael Guravage
Lars Gustäbel
Thomas Güttler
Jonas H.
Antti Haapala
Joseph Hackman
Barry Haddow
Philipp Hagemeister
John Hagen
Paul ten Hagen
Rasmus Hahn
Peter Haight
Václav Haisman
Zbigniew Halas
Walker Hale IV
Aaron Christopher Hall
Bob Halley
Jesse Hallio
Jun Hamano
Alexandre Hamelin
Anders Hammarquist
Mark Hammond
Harald Hanche-Olsen
Manus Hand
Michael Handler
Andreas Hangauer
Milton L. Hankins
Carl Bordum Hansen
Stephen Hansen
Barry Hantman
Lynda Hardman
Bar Harel
Derek Harland
Jason Harper
David Harrigan
Brian Harring
Jonathan Hartley
Travis B. Hartwell
Henrik Harutyunyan
Shane Harvey
Larry Hastings
Tim Hatch
Zac Hatfield-Dodds
Shane Hathaway
Akinori Hattori
Michael Haubenwallner
Janko Hauser
Flavian Hautbois
Rycharde Hawkes
Yahor Harunovich
Ben Hayden
Jochen Hayek
Tim Heaney
Henrik Heimbuerger
Christian Heimes
Thomas Heller
Malte Helmert
Lance Finn Helsten
Gordon P. Hemsley
Jonathan Hendry
Nathan Henrie
Michael Henry
James Henstridge
Kasun Herath
Chris Herborth
Ivan Herman
Jürgen Hermann
Joshua Jay Herman
Gary Herron
Ernie Hershey
Thomas Herve
Bernhard Herzog
Magnus L. Hetland
Raymond Hettinger
Lisa Hewus Fresh
Kevan Heydon
Wouter van Heyst
Derek Higgins
Kelsey Hightower
Jason Hildebrand
Ryan Hileman
Aaron Hill
Joel Hillacre
Richie Hindle
Konrad Hinsen
Richard Hoberecht
David Hobley
Tim Hochberg
Benjamin Hodgson
Joerg-Cyril Hoehle
Douwe Hoekstra
Robert Hoelzl
Gregor Hoffleit
Chris Hoffman
Tim Hoffmann
Stefan Hoffmeister
Albert Hofkamp
Chris Hogan
Tomas Hoger
Jonathan Hogg
Vladyslav Hoi
Kamilla Holanda
Steve Holden
Akintayo Holder
Thomas Holenstein
Gerrit Holl
Shane Holloway
Rune Holm
Thomas Holmes
Craig Holmquist
Philip Homburg
Naofumi Honda
Constantin Hong
Weipeng Hong
Jeffrey Honig
Rob Hooft
Michiel de Hoon
Brian Hooper
Randall Hopper
Tim Hopper
Nadav Horesh
Alon Horev
Jan Hosang
Jonathan Hosmer
Alan Hourihane
Ken Howard
Brad Howes
Mike Hoy
Ben Hoyt
Tomáš Hrnčiar
Miro Hrončok
Chiu-Hsiang Hsu
Chih-Hao Huang
Xuanteng Huang
Christian Hudon
Benoît Hudson
Lawrence Hudson
Michael Hudson
Roberto Hueso Gomez
Jim Hugunin
Greg Humphreys
Chris Hunt
Eric Huss
Nehal Hussain
Taihyun Hwang
Jeremy Hylton
Ludwig Hähne
Gerhard Häring
Fredrik Håård
Florian Höch
Oleg Höfling
Robert Hölzl
Stefan Hölzl
Catalin Iacob
Mihai Ibanescu
Ali Ikinci
Aaron Iles
Thomas Ilsche
Lars Immisch
Bobby Impollonia
Meador Inge
Peter Ingebretson
Tony Ingraldi
John Interrante
Dean Inwood
Bob Ippolito
Roger Irwin
Atsuo Ishimoto
Alexey Izbyshev
Kasia Jachim
Adam Jackson
Ben Jackson
Paul Jackson
Manuel Jacob
David Jacobs
Jeffrey C. Jacobs
Kevin Jacobs
Kjetil Jacobsen
Shantanu Jain
Bertrand Janin
Geert Jansen
Jack Jansen
Hans-Peter Jansen
Bill Janssen
Hans Petter Jansson
Jon Janzen
Thomas Jarosch
Juhana Jauhiainen
Rajagopalasarma Jayakrishnan
Devin Jeanpierre
Zbigniew Jędrzejewski-Szmek
Julien Jehannet
Muhammad Jehanzeb
Drew Jenkins
Flemming Kjær Jensen
Philip H. Jensen
Philip Jenvey
MunSic Jeong
Chris Jerdonek
Joe Jevnik
Jim Jewett
Pedro Diaz Jimenez
Orjan Johansen
Fredrik Johansson
Gregory K. Johnson
Kent Johnson
Michael Johnson
Simon Johnston
Matt Joiner
Thomas Jollans
Nicolas Joly
Brian K. Jones
Evan Jones
Glenn Jones
Jeremy Jones
Richard Jones
Irmen de Jong
Lucas de Jonge
Kristján Valur Jónsson
Jens B. Jorgensen
John Jorgensen
Sijin Joseph
Andreas Jung
Tattoo Mabonzo K.
Sarah K.
Sunny K
Bohuslav Kabrda
Alexey Kachayev
Bob Kahn
Kurt B. Kaiser
Tamito Kajiyama
Jan Kaliszewski
Peter van Kampen
Jan Kanis
Rafe Kaplan
Jacob Kaplan-Moss
Allison Kaptur
Yurii Karabas
Janne Karila
Per Øyvind Karlsen
Anton Kasyanov
Lou Kates
Makoto Kato
Irit Katriel
Hiroaki Kawai
Dmitry Kazakov
Brian Kearns
Sebastien Keim
Russell Keith-Magee
Ryan Kelly
Hugo van Kemenade
Dan Kenigsberg
Randall Kern
Robert Kern
Jim Kerr
Magnus Kessler
Lawrence Kesteloot
Garvit Khatri
Vivek Khera
Dhiru Kholia
Artem Khramov
Akshit Khurana
Sanyam Khurana
Tyler Kieft
Mads Kiilerich
Jason Killen
Beomsoo Bombs Kim
Derek D. Kim
Gihwan Kim
Jan Kim
Taek Joo Kim
Yeojin Kim
Sam Kimbrel
Tomohiko Kinebuchi
James King
W. Trevor King
Jeffrey Kintscher
Paul Kippes
Sergey B Kirpichev
Steve Kirsch
Sebastian Kirsche
Kamil Kisiel
Akira Kitada
Ron Klatchko
Reid Kleckner
Carsten Klein
Bastian Kleineidam
Joel Klimont
Bob Kline
Alois Klink
Matthias Klose
Jeremy Kloth
Thomas Kluyver
Kim Knapp
Lenny Kneler
Pat Knight
Jeff Knupp
Nicholas Kobald
Kubilay Kocak
Greg Kochanski
Manvisha Kodali
Niklas Koep
Damon Kohler
Marko Kohtala
Vajrasky Kok
Guido Kollerie
Jacek Kołodziej
Jacek Konieczny
Krzysztof Konopko
Arkady Koplyarov
Peter A. Koren
Марк Коренберг
Vlad Korolev
Susumu Koshiba
Joseph Koshy
Daniel Kozan
Jerzy Kozera
Maksim Kozyarchuk
Stefan Krah
Rolf Krahl
Bob Kras
Oleg Krasnikov
Sebastian Kreft
Holger Krekel
Michael Kremer
Fabian Kreutz
Cédric Krier
Pedro Kroger
Hannu Krosing
Andrej Krpic
Ivan Krstić
Anselm Kruis
Steven Kryskalla
Andrew Kuchling
Jakub Kuczys
Dave Kuhlman
Jon Kuhn
Andrei Kulakov
Ilya Kulakov
Upendra Kumar
Toshio Kuratomi
Ilia Kurenkov
Vladimir Kushnir
Erno Kuusela
Kabir Kwatra
Ross Lagerwall
Cameron Laird
Filipe Laíns
Loïc Lajeanne
Alexander Lakeev
David Lam
Thomas Lamb
Valerie Lambert
Peter Lamut
Jean-Baptiste "Jiba" Lamy
Ronan Lamy
Peter Landry
Torsten Landschoff
Łukasz Langa
Tino Lange
Glenn Langford
Andrew Langmead
Wolfgang Langner
Detlef Lannert
Rémi Lapeyre
Soren Larsen
Amos Latteier
Piers Lauder
Ben Laurie
Yoni Lavi
Simon Law
Julia Lawall
Chris Lawrence
Mark Lawrence
Chris Laws
Michael Layzell
Michael Lazar
Peter Lazorchak
Brian Leair
Mathieu Leduc-Hamel
Amandine Lee
Antony Lee
Christopher Lee
Inyeol Lee
James Lee
John J. Lee
Thomas Lee
Robert Leenders
Cooper Ry Lees
Yaron de Leeuw
Tennessee Leeuwenburg
Luc Lefebvre
Pierre Paul Lefebvre
Glyph Lefkowitz
Vincent Legoll
Kip Lehman
Joerg Lehmann
Robert Lehmann
Petri Lehtinen
Luke Kenneth Casson Leighton
John Leitch
Tshepang Mbambo
Marc-André Lemburg
Mateusz Lenik
John Lenton
Kostyantyn Leschenko
Benno Leslie
Christopher Tur Lesniewski-Laas
Pier-Yves Lessard
Alain Leufroy
Mark Levinson
Mark Levitt
Ivan Levkivskyi
Ben Lewis
William Lewis
Akira Li
Jiahao Li
Robert Li
Xuanji Li
Zekun Li
Zheao Li
Eli Libman
Dan Lidral-Porter
Robert van Liere
Ross Light
Shawn Ligocki
Martin Ligr
Gediminas Liktaras
Vitor de Lima
Grant Limberg
Christopher Lindblad
Ulf A. Lindgren
Björn Lindqvist
Per Lindqvist
Eric Lindvall
Gregor Lingl
Everett Lipman
Mirko Liss
Alexander Liu
Hui Liu
Yuan Liu
Nick Lockwood
Stephanie Lockwood
Martin von Löwis
Hugo Lopes Tavares
Guillermo López-Anglada
Anne Lord
Alex LordThorsen
Tom Loredo
Justin Love
Ned Jackson Lovely
Peter Lovett
Chalmer Lowe
Jason Lowe
Tony Lownds
Ray Loyzaga
Kang-Hao (Kenny) Lu
Raymond Lu
Lukas Lueg
Loren Luke
Fredrik Lundh
Mike Lundy
Zhongyue Luo
Mark Lutz
Taras Lyapun
Jim Lynch
Mikael Lyngvig
Ilya Lyubavski
Jeff MacDonald
John Machin
Andrew I MacIntyre
Tim MacKenzie
Nick Maclaren
Don MacMillen
Tomasz Maćkowiak
Wolfgang Maier
Steve Majewski
Marek Majkowski
Grzegorz Makarewicz
David Malcolm
Greg Malcolm
William Mallard
Cody Maloney
Ken Manheimer
Vladimir Marangozov
Colin Marc
Vincent Marchetti
David Marek
Doug Marien
Chris Markiewicz
Sven Marnach
John Marshall
Alex Martelli
Dennis Mårtensson
Anthony Martin
Owen Martin
Sidney San Martín
Westley Martínez
Sébastien Martini
Roger Masse
Nick Mathewson
Simon Mathieu
Laura Matson
Graham Matthews
mattip
Martin Matusiak
Dieter Maurer
Lev Maximov
Daniel May
Madison May
Lucas Maystre
Arnaud Mazin
Pam McA'Nulty
Matt McClure
Jack McCracken
Rebecca McCreary
Kirk McDonald
Chris McDonough
Michael McFadden
Greg McFarlane
Alan McIntyre
Jessica McKellar
Michael McLay
Brendan McLoughlin
Mark Mc Mahon
Gordon McMillan
Andrew McNamara
Caolan McNamara
Jeff McNeil
Craig McPheeters
Corvin McPherson
Lambert Meertens
Bill van Melle
Lucas Prado Melo
Ezio Melotti
Doug Mennella
Dimitri Merejkowsky
Brian Merrell
Bruce Merry
Alexis Métaireau
Carey Metcalfe
Luke Mewburn
Carl Meyer
Kyle Meyer
Mike Meyer
Piotr Meyer
Steven Miale
Jason Michalski
Franck Michea
Vincent Michel
Trent Mick
Tom Middleton
Thomas Miedema
Stan Mihai
Stefan Mihaila
Aristotelis Mikropoulos
Paolo Milani
Chad Miller
Damien Miller
Jason V. Miller
Jay T. Miller
Katie Miller
Oren Milman
Roman Milner
Julien Miotte
Andrii V. Mishkovskyi
Dom Mitchell
Dustin J. Mitchell
Gideon Mitchell
Tim Mitchell
Zubin Mithra
Florian Mladitsch
Kevin Modzelewski
Doug Moen
Jakub Molinski
Juliette Monsel
Paul Monson
The Dragon De Monsyne
Bastien Montagne
Skip Montanaro
Peter Moody
HyunKyun Moon
Alan D. Moore
Nicolai Moore
Paul Moore
Ross Moore
Ben Morgan
Emily Morehouse
Derek Morr
James A Morrison
Martin Morrison
Stephen Morton
Derek McTavish Mounce
Alessandro Moura
Pablo Mouzo
Mher Movsisyan
Ruslan Mstoi
Marc Mueller
Valentina Mukhamedzhanova
Michael Mulich
Sape Mullender
Sjoerd Mullender
Michael Muller
Neil Muller
Louis Munro
R. David Murray
Matti Mäki
Jörg Müller
Kaushik N
Donghee Na
Dale Nagata
John Nagle
Takahiro Nakayama
Inada Naoki
Travers Naran
Motoki Naruse
Charles-François Natali
Vilmos Nebehaj
Fredrik Nehr
Tony Nelson
Trent Nelson
Andrew Nester
Osvaldo Santana Neto
Chad Netzer
Max Neunhöffer
Anthon van der Neut
George Neville-Neil
Hieu Nguyen
Nam Nguyen
Johannes Nicolai
Samuel Nicolary
Jonathan Niehof
Gustavo Niemeyer
Oscar Nierstrasz
Lysandros Nikolaou
Hrvoje Nikšić
Gregory Nofi
Jesse Noller
Bill Noon
Janek Nouvertné
Stefan Norberg
Tim Northover
Joe Norton
Neal Norwitz
Mikhail Novikov
Michal Nowikowski
Steffen Daode Nurpmeso
Thomas Nyberg
Nigel O'Brian
