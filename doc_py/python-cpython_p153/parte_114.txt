
static PyType_Slot Xxo_Type_slots[] = {
    {Py_tp_doc, (char *)Xxo_doc},
    {Py_tp_traverse, Xxo_traverse},
    {Py_tp_clear, Xxo_clear},
    {Py_tp_finalize, Xxo_finalize},
    {Py_tp_dealloc, Xxo_dealloc},
    {Py_tp_getattro, Xxo_getattro},
    {Py_tp_setattro, Xxo_setattro},
    {Py_tp_methods, Xxo_methods},
    {Py_bf_getbuffer, Xxo_getbuffer},
    {Py_bf_releasebuffer, Xxo_releasebuffer},
    {Py_tp_getset, Xxo_getsetlist},
    {0, 0},  /* sentinel */
};

static PyType_Spec Xxo_Type_spec = {
    .name = "xxlimited.Xxo",
    .basicsize = sizeof(XxoObject),
    .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
    .slots = Xxo_Type_slots,
};


/* Str type definition*/

static PyType_Slot Str_Type_slots[] = {
    {0, 0},  /* sentinel */
};

static PyType_Spec Str_Type_spec = {
    .name = "xxlimited.Str",
    .basicsize = 0,
    .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .slots = Str_Type_slots,
};


/* Function of two integers returning integer (with C "long int" arithmetic) */

PyDoc_STRVAR(xx_foo_doc,
"foo(i,j)\n\
\n\
Return the sum of i and j.");

static PyObject *
xx_foo(PyObject *module, PyObject *args)
{
    long i, j;
    long res;
    if (!PyArg_ParseTuple(args, "ll:foo", &i, &j))
        return NULL;
    res = i+j; /* XXX Do something here */
    return PyLong_FromLong(res);
}


/* Function of no arguments returning new Xxo object */

static PyObject *
xx_new(PyObject *module, PyObject *Py_UNUSED(unused))
{
    XxoObject *rv;

    rv = newXxoObject(module);
    if (rv == NULL)
        return NULL;
    return (PyObject *)rv;
}



/* List of functions defined in the module */

static PyMethodDef xx_methods[] = {
    {"foo",             xx_foo,         METH_VARARGS,
        xx_foo_doc},
    {"new",             xx_new,         METH_NOARGS,
        PyDoc_STR("new() -> new Xx object")},
    {NULL,              NULL}           /* sentinel */
};


/* The module itself */

PyDoc_STRVAR(module_doc,
"This is a template module just for instruction.");

static int
xx_modexec(PyObject *m)
{
    xx_state *state = PyModule_GetState(m);

    state->Error_Type = PyErr_NewException("xxlimited.Error", NULL, NULL);
    if (state->Error_Type == NULL) {
        return -1;
    }
    if (PyModule_AddType(m, (PyTypeObject*)state->Error_Type) < 0) {
        return -1;
    }

    state->Xxo_Type = PyType_FromModuleAndSpec(m, &Xxo_Type_spec, NULL);
    if (state->Xxo_Type == NULL) {
        return -1;
    }
    if (PyModule_AddType(m, (PyTypeObject*)state->Xxo_Type) < 0) {
        return -1;
    }

    // Add the Str type. It is not needed from C code, so it is only
    // added to the module dict.
    // It does not inherit from "object" (PyObject_Type), but from "str"
    // (PyUnincode_Type).
    PyObject *Str_Type = PyType_FromModuleAndSpec(
        m, &Str_Type_spec, (PyObject *)&PyUnicode_Type);
    if (Str_Type == NULL) {
        return -1;
    }
    if (PyModule_AddType(m, (PyTypeObject*)Str_Type) < 0) {
        return -1;
    }
    Py_DECREF(Str_Type);

    return 0;
}

static PyModuleDef_Slot xx_slots[] = {
    {Py_mod_exec, xx_modexec},
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL}
};

static int
xx_traverse(PyObject *module, visitproc visit, void *arg)
{
    xx_state *state = PyModule_GetState(module);
    Py_VISIT(state->Xxo_Type);
    Py_VISIT(state->Error_Type);
    return 0;
}

static int
xx_clear(PyObject *module)
{
    xx_state *state = PyModule_GetState(module);
    Py_CLEAR(state->Xxo_Type);
    Py_CLEAR(state->Error_Type);
    return 0;
}

static struct PyModuleDef xxmodule = {
    PyModuleDef_HEAD_INIT,
    .m_name = "xxlimited",
    .m_doc = module_doc,
    .m_size = sizeof(xx_state),
    .m_methods = xx_methods,
    .m_slots = xx_slots,
    .m_traverse = xx_traverse,
    .m_clear = xx_clear,
    /* m_free is not necessary here: xx_clear clears all references,
     * and the module state is deallocated along with the module.
     */
};


/* Export function for the module (*must* be called PyInit_xx) */

PyMODINIT_FUNC
PyInit_xxlimited(void)
{
    return PyModuleDef_Init(&xxmodule);
}


================================================
File: /Modules/xxlimited_35.c
================================================

/* This module is compiled using limited API from Python 3.5,
 * making sure that it works as expected.
 *
 * See the xxlimited module for an extension module template.
 */

// Test the limited C API version 3.5
#include "pyconfig.h"   // Py_GIL_DISABLED
#ifndef Py_GIL_DISABLED
#  define Py_LIMITED_API 0x03050000
#endif

#include "Python.h"

/* Xxo objects */

static PyObject *ErrorObject;

typedef struct {
    PyObject_HEAD
    PyObject            *x_attr;        /* Attributes dictionary */
} XxoObject;

static PyObject *Xxo_Type;

#define XxoObject_Check(v)      Py_IS_TYPE(v, Xxo_Type)

static XxoObject *
newXxoObject(PyObject *arg)
{
    XxoObject *self;
    self = PyObject_GC_New(XxoObject, (PyTypeObject*)Xxo_Type);
    if (self == NULL)
        return NULL;
    self->x_attr = NULL;
    return self;
}

/* Xxo methods */

static int
Xxo_traverse(XxoObject *self, visitproc visit, void *arg)
{
    Py_VISIT(Py_TYPE(self));
    Py_VISIT(self->x_attr);
    return 0;
}

static int
Xxo_clear(XxoObject *self)
{
    Py_CLEAR(self->x_attr);
    return 0;
}

static void
Xxo_finalize(XxoObject *self)
{
    Py_CLEAR(self->x_attr);
}

static PyObject *
Xxo_demo(XxoObject *self, PyObject *args)
{
    PyObject *o = NULL;
    if (!PyArg_ParseTuple(args, "|O:demo", &o))
        return NULL;
    /* Test availability of fast type checks */
    if (o != NULL && PyUnicode_Check(o)) {
        return Py_NewRef(o);
    }
    return Py_NewRef(Py_None);
}

static PyMethodDef Xxo_methods[] = {
    {"demo",            (PyCFunction)Xxo_demo,  METH_VARARGS,
        PyDoc_STR("demo() -> None")},
    {NULL,              NULL}           /* sentinel */
};

static PyObject *
Xxo_getattro(XxoObject *self, PyObject *name)
{
    if (self->x_attr != NULL) {
        PyObject *v = PyDict_GetItemWithError(self->x_attr, name);
        if (v != NULL) {
            return Py_NewRef(v);
        }
        else if (PyErr_Occurred()) {
            return NULL;
        }
    }
    return PyObject_GenericGetAttr((PyObject *)self, name);
}

static int
Xxo_setattr(XxoObject *self, const char *name, PyObject *v)
{
    if (self->x_attr == NULL) {
        self->x_attr = PyDict_New();
        if (self->x_attr == NULL)
            return -1;
    }
    if (v == NULL) {
        int rv = PyDict_DelItemString(self->x_attr, name);
        if (rv < 0 && PyErr_ExceptionMatches(PyExc_KeyError))
            PyErr_SetString(PyExc_AttributeError,
                "delete non-existing Xxo attribute");
        return rv;
    }
    else
        return PyDict_SetItemString(self->x_attr, name, v);
}

static PyType_Slot Xxo_Type_slots[] = {
    {Py_tp_doc, "The Xxo type"},
    {Py_tp_traverse, Xxo_traverse},
    {Py_tp_clear, Xxo_clear},
    {Py_tp_finalize, Xxo_finalize},
    {Py_tp_getattro, Xxo_getattro},
    {Py_tp_setattr, Xxo_setattr},
    {Py_tp_methods, Xxo_methods},
    {0, 0},
};

static PyType_Spec Xxo_Type_spec = {
    "xxlimited_35.Xxo",
    sizeof(XxoObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,
    Xxo_Type_slots
};

/* --------------------------------------------------------------------- */

/* Function of two integers returning integer */

PyDoc_STRVAR(xx_foo_doc,
"foo(i,j)\n\
\n\
Return the sum of i and j.");

static PyObject *
xx_foo(PyObject *self, PyObject *args)
{
    long i, j;
    long res;
    if (!PyArg_ParseTuple(args, "ll:foo", &i, &j))
        return NULL;
    res = i+j; /* XXX Do something here */
    return PyLong_FromLong(res);
}


/* Function of no arguments returning new Xxo object */

static PyObject *
xx_new(PyObject *self, PyObject *args)
{
    XxoObject *rv;

    if (!PyArg_ParseTuple(args, ":new"))
        return NULL;
    rv = newXxoObject(args);
    if (rv == NULL)
        return NULL;
    return (PyObject *)rv;
}

/* Test bad format character */

static PyObject *
xx_roj(PyObject *self, PyObject *args)
{
    PyObject *a;
    long b;
    if (!PyArg_ParseTuple(args, "O#:roj", &a, &b))
        return NULL;
    return Py_NewRef(Py_None);
}


/* ---------- */

static PyType_Slot Str_Type_slots[] = {
    {Py_tp_base, NULL}, /* filled out in module init function */
    {0, 0},
};

static PyType_Spec Str_Type_spec = {
    "xxlimited_35.Str",
    0,
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    Str_Type_slots
};

/* ---------- */

static PyObject *
null_richcompare(PyObject *self, PyObject *other, int op)
{
    Py_RETURN_NOTIMPLEMENTED;
}

static PyType_Slot Null_Type_slots[] = {
    {Py_tp_base, NULL}, /* filled out in module init */
    {Py_tp_new, NULL},
    {Py_tp_richcompare, null_richcompare},
    {0, 0}
};

static PyType_Spec Null_Type_spec = {
    "xxlimited_35.Null",
    0,               /* basicsize */
    0,               /* itemsize */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    Null_Type_slots
};

/* ---------- */

/* List of functions defined in the module */

static PyMethodDef xx_methods[] = {
    {"roj",             xx_roj,         METH_VARARGS,
        PyDoc_STR("roj(a,b) -> None")},
    {"foo",             xx_foo,         METH_VARARGS,
        xx_foo_doc},
    {"new",             xx_new,         METH_VARARGS,
        PyDoc_STR("new() -> new Xx object")},
    {NULL,              NULL}           /* sentinel */
};

PyDoc_STRVAR(module_doc,
"This is a module for testing limited API from Python 3.5.");

static int
xx_modexec(PyObject *m)
{
    PyObject *o;

    /* Due to cross platform compiler issues the slots must be filled
     * here. It's required for portability to Windows without requiring
     * C++. */
    Null_Type_slots[0].pfunc = &PyBaseObject_Type;
    Null_Type_slots[1].pfunc = PyType_GenericNew;
    Str_Type_slots[0].pfunc = &PyUnicode_Type;

    /* Add some symbolic constants to the module */
    if (ErrorObject == NULL) {
        ErrorObject = PyErr_NewException("xxlimited_35.error", NULL, NULL);
        if (ErrorObject == NULL) {
            return -1;
        }
    }
    Py_INCREF(ErrorObject);
    if (PyModule_AddObject(m, "error", ErrorObject) < 0) {
        Py_DECREF(ErrorObject);
        return -1;
    }

    /* Add Xxo */
    Xxo_Type = PyType_FromSpec(&Xxo_Type_spec);
    if (Xxo_Type == NULL) {
        return -1;
    }
    if (PyModule_AddObject(m, "Xxo", Xxo_Type) < 0) {
        Py_DECREF(Xxo_Type);
        return -1;
    }

    /* Add Str */
    o = PyType_FromSpec(&Str_Type_spec);
    if (o == NULL) {
        return -1;
    }
    if (PyModule_AddObject(m, "Str", o) < 0) {
        Py_DECREF(o);
        return -1;
    }

    /* Add Null */
    o = PyType_FromSpec(&Null_Type_spec);
    if (o == NULL) {
        return -1;
    }
    if (PyModule_AddObject(m, "Null", o) < 0) {
        Py_DECREF(o);
        return -1;
    }

    return 0;
}


static PyModuleDef_Slot xx_slots[] = {
    {Py_mod_exec, xx_modexec},
#ifdef Py_GIL_DISABLED
    // These definitions are in the limited API, but not until 3.13.
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
#endif
    {0, NULL}
};

static struct PyModuleDef xxmodule = {
    PyModuleDef_HEAD_INIT,
    "xxlimited_35",
    module_doc,
    0,
    xx_methods,
    xx_slots,
    NULL,
    NULL,
    NULL
};

/* Export function for the module (*must* be called PyInit_xx) */

PyMODINIT_FUNC
PyInit_xxlimited_35(void)
{
    return PyModuleDef_Init(&xxmodule);
}


================================================
File: /Modules/xxmodule.c
================================================

/* Use this file as a template to start implementing a module that
   also declares object types. All occurrences of 'Xxo' should be changed
   to something reasonable for your objects. After that, all other
   occurrences of 'xx' should be changed to something reasonable for your
   module. If your module is named foo your sourcefile should be named
   foomodule.c.

   You will probably want to delete all references to 'x_attr' and add
   your own types of attributes instead.  Maybe you want to name your
   local variables other than 'self'.  If your object type is needed in
   other files, you'll have to create a file "foobarobject.h"; see
   floatobject.h for an example. */

/* Xxo objects */

#include "Python.h"

static PyObject *ErrorObject;

typedef struct {
    PyObject_HEAD
    PyObject            *x_attr;        /* Attributes dictionary */
} XxoObject;

static PyTypeObject Xxo_Type;

#define XxoObject_Check(v)      Py_IS_TYPE(v, &Xxo_Type)

static XxoObject *
newXxoObject(PyObject *arg)
{
    XxoObject *self;
    self = PyObject_New(XxoObject, &Xxo_Type);
    if (self == NULL)
        return NULL;
    self->x_attr = NULL;
    return self;
}

/* Xxo methods */

static void
Xxo_dealloc(XxoObject *self)
{
    Py_XDECREF(self->x_attr);
    PyObject_Free(self);
}

static PyObject *
Xxo_demo(XxoObject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ":demo"))
        return NULL;
    return Py_NewRef(Py_None);
}

static PyMethodDef Xxo_methods[] = {
    {"demo",            (PyCFunction)Xxo_demo,  METH_VARARGS,
        PyDoc_STR("demo() -> None")},
    {NULL,              NULL}           /* sentinel */
};

static PyObject *
Xxo_getattro(XxoObject *self, PyObject *name)
{
    if (self->x_attr != NULL) {
        PyObject *v = PyDict_GetItemWithError(self->x_attr, name);
        if (v != NULL) {
            return Py_NewRef(v);
        }
        else if (PyErr_Occurred()) {
            return NULL;
        }
    }
    return PyObject_GenericGetAttr((PyObject *)self, name);
}

static int
Xxo_setattr(XxoObject *self, const char *name, PyObject *v)
{
    if (self->x_attr == NULL) {
        self->x_attr = PyDict_New();
        if (self->x_attr == NULL)
            return -1;
    }
    if (v == NULL) {
        int rv = PyDict_DelItemString(self->x_attr, name);
        if (rv < 0 && PyErr_ExceptionMatches(PyExc_KeyError))
            PyErr_SetString(PyExc_AttributeError,
                "delete non-existing Xxo attribute");
        return rv;
    }
    else
        return PyDict_SetItemString(self->x_attr, name, v);
}

static PyTypeObject Xxo_Type = {
    /* The ob_type field must be initialized in the module init function
     * to be portable to Windows without using C++. */
    PyVarObject_HEAD_INIT(NULL, 0)
    "xxmodule.Xxo",             /*tp_name*/
    sizeof(XxoObject),          /*tp_basicsize*/
    0,                          /*tp_itemsize*/
    /* methods */
    (destructor)Xxo_dealloc,    /*tp_dealloc*/
    0,                          /*tp_vectorcall_offset*/
    (getattrfunc)0,             /*tp_getattr*/
    (setattrfunc)Xxo_setattr,   /*tp_setattr*/
    0,                          /*tp_as_async*/
    0,                          /*tp_repr*/
    0,                          /*tp_as_number*/
    0,                          /*tp_as_sequence*/
    0,                          /*tp_as_mapping*/
    0,                          /*tp_hash*/
    0,                          /*tp_call*/
    0,                          /*tp_str*/
    (getattrofunc)Xxo_getattro, /*tp_getattro*/
    0,                          /*tp_setattro*/
    0,                          /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT,         /*tp_flags*/
    0,                          /*tp_doc*/
    0,                          /*tp_traverse*/
    0,                          /*tp_clear*/
    0,                          /*tp_richcompare*/
    0,                          /*tp_weaklistoffset*/
    0,                          /*tp_iter*/
    0,                          /*tp_iternext*/
    Xxo_methods,                /*tp_methods*/
    0,                          /*tp_members*/
    0,                          /*tp_getset*/
    0,                          /*tp_base*/
    0,                          /*tp_dict*/
    0,                          /*tp_descr_get*/
    0,                          /*tp_descr_set*/
    0,                          /*tp_dictoffset*/
    0,                          /*tp_init*/
    0,                          /*tp_alloc*/
    0,                          /*tp_new*/
    0,                          /*tp_free*/
    0,                          /*tp_is_gc*/
};
/* --------------------------------------------------------------------- */

/* Function of two integers returning integer */

PyDoc_STRVAR(xx_foo_doc,
"foo(i,j)\n\
\n\
Return the sum of i and j.");

static PyObject *
xx_foo(PyObject *self, PyObject *args)
{
    long i, j;
    long res;
    if (!PyArg_ParseTuple(args, "ll:foo", &i, &j))
        return NULL;
    res = i+j; /* XXX Do something here */
    return PyLong_FromLong(res);
}


/* Function of no arguments returning new Xxo object */

static PyObject *
xx_new(PyObject *self, PyObject *args)
{
    XxoObject *rv;

    if (!PyArg_ParseTuple(args, ":new"))
        return NULL;
    rv = newXxoObject(args);
    if (rv == NULL)
        return NULL;
    return (PyObject *)rv;
}

/* Example with subtle bug from extensions manual ("Thin Ice"). */

static PyObject *
xx_bug(PyObject *self, PyObject *args)
{
    PyObject *list, *item;

    if (!PyArg_ParseTuple(args, "O:bug", &list))
        return NULL;

    item = PyList_GetItem(list, 0);
    /* Py_INCREF(item); */
    PyList_SetItem(list, 1, PyLong_FromLong(0L));
    PyObject_Print(item, stdout, 0);
    printf("\n");
    /* Py_DECREF(item); */

    return Py_NewRef(Py_None);
}

/* Test bad format character */

static PyObject *
xx_roj(PyObject *self, PyObject *args)
{
    PyObject *a;
    long b;
    if (!PyArg_ParseTuple(args, "O#:roj", &a, &b))
        return NULL;
    return Py_NewRef(Py_None);
}


/* ---------- */

static PyTypeObject Str_Type = {
    /* The ob_type field must be initialized in the module init function
     * to be portable to Windows without using C++. */
    PyVarObject_HEAD_INIT(NULL, 0)
    "xxmodule.Str",             /*tp_name*/
    0,                          /*tp_basicsize*/
    0,                          /*tp_itemsize*/
    /* methods */
    0,                          /*tp_dealloc*/
    0,                          /*tp_vectorcall_offset*/
    0,                          /*tp_getattr*/
    0,                          /*tp_setattr*/
    0,                          /*tp_as_async*/
    0,                          /*tp_repr*/
    0,                          /*tp_as_number*/
    0,                          /*tp_as_sequence*/
    0,                          /*tp_as_mapping*/
    0,                          /*tp_hash*/
    0,                          /*tp_call*/
    0,                          /*tp_str*/
    0,                          /*tp_getattro*/
    0,                          /*tp_setattro*/
    0,                          /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
    0,                          /*tp_doc*/
    0,                          /*tp_traverse*/
    0,                          /*tp_clear*/
    0,                          /*tp_richcompare*/
    0,                          /*tp_weaklistoffset*/
    0,                          /*tp_iter*/
    0,                          /*tp_iternext*/
    0,                          /*tp_methods*/
    0,                          /*tp_members*/
    0,                          /*tp_getset*/
    0, /* see PyInit_xx */      /*tp_base*/
    0,                          /*tp_dict*/
    0,                          /*tp_descr_get*/
    0,                          /*tp_descr_set*/
    0,                          /*tp_dictoffset*/
    0,                          /*tp_init*/
    0,                          /*tp_alloc*/
    0,                          /*tp_new*/
    0,                          /*tp_free*/
    0,                          /*tp_is_gc*/
};

/* ---------- */

static PyObject *
null_richcompare(PyObject *self, PyObject *other, int op)
{
    return Py_NewRef(Py_NotImplemented);
}

static PyTypeObject Null_Type = {
    /* The ob_type field must be initialized in the module init function
     * to be portable to Windows without using C++. */
    PyVarObject_HEAD_INIT(NULL, 0)
    "xxmodule.Null",            /*tp_name*/
    0,                          /*tp_basicsize*/
    0,                          /*tp_itemsize*/
    /* methods */
    0,                          /*tp_dealloc*/
    0,                          /*tp_vectorcall_offset*/
    0,                          /*tp_getattr*/
    0,                          /*tp_setattr*/
    0,                          /*tp_as_async*/
    0,                          /*tp_repr*/
    0,                          /*tp_as_number*/
    0,                          /*tp_as_sequence*/
    0,                          /*tp_as_mapping*/
    0,                          /*tp_hash*/
    0,                          /*tp_call*/
    0,                          /*tp_str*/
    0,                          /*tp_getattro*/
    0,                          /*tp_setattro*/
    0,                          /*tp_as_buffer*/
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /*tp_flags*/
    0,                          /*tp_doc*/
    0,                          /*tp_traverse*/
    0,                          /*tp_clear*/
    null_richcompare,           /*tp_richcompare*/
    0,                          /*tp_weaklistoffset*/
    0,                          /*tp_iter*/
    0,                          /*tp_iternext*/
    0,                          /*tp_methods*/
    0,                          /*tp_members*/
    0,                          /*tp_getset*/
    0, /* see PyInit_xx */      /*tp_base*/
    0,                          /*tp_dict*/
    0,                          /*tp_descr_get*/
    0,                          /*tp_descr_set*/
    0,                          /*tp_dictoffset*/
    0,                          /*tp_init*/
    0,                          /*tp_alloc*/
    PyType_GenericNew,          /*tp_new*/
    0,                          /*tp_free*/
    0,                          /*tp_is_gc*/
};


/* ---------- */


/* List of functions defined in the module */

static PyMethodDef xx_methods[] = {
    {"roj",             xx_roj,         METH_VARARGS,
        PyDoc_STR("roj(a,b) -> None")},
    {"foo",             xx_foo,         METH_VARARGS,
        xx_foo_doc},
    {"new",             xx_new,         METH_VARARGS,
        PyDoc_STR("new() -> new Xx object")},
    {"bug",             xx_bug,         METH_VARARGS,
        PyDoc_STR("bug(o) -> None")},
    {NULL,              NULL}           /* sentinel */
};

PyDoc_STRVAR(module_doc,
"This is a template module just for instruction.");


static int
xx_exec(PyObject *m)
{
    /* Slot initialization is subject to the rules of initializing globals.
       C99 requires the initializers to be "address constants".  Function
       designators like 'PyType_GenericNew', with implicit conversion to
       a pointer, are valid C99 address constants.

       However, the unary '&' operator applied to a non-static variable
       like 'PyBaseObject_Type' is not required to produce an address
       constant.  Compilers may support this (gcc does), MSVC does not.

       Both compilers are strictly standard conforming in this particular
       behavior.
    */
    Null_Type.tp_base = &PyBaseObject_Type;
    Str_Type.tp_base = &PyUnicode_Type;

    /* Finalize the type object including setting type of the new type
     * object; doing it here is required for portability, too. */
    if (PyType_Ready(&Xxo_Type) < 0) {
        return -1;
    }

    /* Add some symbolic constants to the module */
    if (ErrorObject == NULL) {
        ErrorObject = PyErr_NewException("xx.error", NULL, NULL);
        if (ErrorObject == NULL) {
            return -1;
        }
    }
    int rc = PyModule_AddType(m, (PyTypeObject *)ErrorObject);
    Py_DECREF(ErrorObject);
    if (rc < 0) {
        return -1;
    }

    /* Add Str and Null types */
    if (PyModule_AddType(m, &Str_Type) < 0) {
        return -1;
    }
    if (PyModule_AddType(m, &Null_Type) < 0) {
        return -1;
    }

    return 0;
}

static struct PyModuleDef_Slot xx_slots[] = {
    {Py_mod_exec, xx_exec},
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL},
};

static struct PyModuleDef xxmodule = {
    PyModuleDef_HEAD_INIT,
    "xx",
    module_doc,
    0,
    xx_methods,
    xx_slots,
    NULL,
    NULL,
    NULL
};

/* Export function for the module (*must* be called PyInit_xx) */

PyMODINIT_FUNC
PyInit_xx(void)
{
    return PyModuleDef_Init(&xxmodule);
}


================================================
File: /Modules/xxsubtype.c
================================================
#include "Python.h"

#include <stddef.h>               // offsetof()
#include <time.h>                 // clock()


PyDoc_STRVAR(xxsubtype__doc__,
"xxsubtype is an example module showing how to subtype builtin types from C.\n"
"test_descr.py in the standard test suite requires it in order to complete.\n"
"If you don't care about the examples, and don't intend to run the Python\n"
"test suite, you can recompile Python without Modules/xxsubtype.c.");

/* We link this module statically for convenience.  If compiled as a shared
   library instead, some compilers don't allow addresses of Python objects
   defined in other libraries to be used in static initializers here.  The
   DEFERRED_ADDRESS macro is used to tag the slots where such addresses
   appear; the module init function must fill in the tagged slots at runtime.
   The argument is for documentation -- the macro ignores it.
*/
#define DEFERRED_ADDRESS(ADDR) 0

/* spamlist -- a list subtype */

typedef struct {
    PyListObject list;
    int state;
} spamlistobject;

static PyObject *
spamlist_getstate(spamlistobject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ":getstate"))
        return NULL;
    return PyLong_FromLong(self->state);
}

static PyObject *
spamlist_setstate(spamlistobject *self, PyObject *args)
{
    int state;

    if (!PyArg_ParseTuple(args, "i:setstate", &state))
        return NULL;
    self->state = state;
    return Py_NewRef(Py_None);
}

static PyObject *
spamlist_specialmeth(PyObject *self, PyObject *args, PyObject *kw)
{
    PyObject *result = PyTuple_New(3);

    if (result != NULL) {
        if (self == NULL)
            self = Py_None;
        if (kw == NULL)
            kw = Py_None;
        PyTuple_SET_ITEM(result, 0, Py_NewRef(self));
        PyTuple_SET_ITEM(result, 1, Py_NewRef(args));
        PyTuple_SET_ITEM(result, 2, Py_NewRef(kw));
    }
    return result;
}

static PyMethodDef spamlist_methods[] = {
    {"getstate", (PyCFunction)spamlist_getstate, METH_VARARGS,
        PyDoc_STR("getstate() -> state")},
    {"setstate", (PyCFunction)spamlist_setstate, METH_VARARGS,
        PyDoc_STR("setstate(state)")},
    /* These entries differ only in the flags; they are used by the tests
       in test.test_descr. */
    {"classmeth", _PyCFunction_CAST(spamlist_specialmeth),
        METH_VARARGS | METH_KEYWORDS | METH_CLASS,
        PyDoc_STR("classmeth(*args, **kw)")},
    {"staticmeth", _PyCFunction_CAST(spamlist_specialmeth),
        METH_VARARGS | METH_KEYWORDS | METH_STATIC,
        PyDoc_STR("staticmeth(*args, **kw)")},
    {NULL,      NULL},
};

static int
spamlist_init(spamlistobject *self, PyObject *args, PyObject *kwds)
{
    if (PyList_Type.tp_init((PyObject *)self, args, kwds) < 0)
        return -1;
    self->state = 0;
    return 0;
}

static PyObject *
spamlist_state_get(spamlistobject *self, void *Py_UNUSED(ignored))
{
    return PyLong_FromLong(self->state);
}

static PyGetSetDef spamlist_getsets[] = {
    {"state", (getter)spamlist_state_get, NULL,
     PyDoc_STR("an int variable for demonstration purposes")},
    {0}
};

static PyTypeObject spamlist_type = {
    PyVarObject_HEAD_INIT(DEFERRED_ADDRESS(&PyType_Type), 0)
    "xxsubtype.spamlist",
    sizeof(spamlistobject),
    0,
    0,                                          /* tp_dealloc */
    0,                                          /* tp_vectorcall_offset */
    0,                                          /* tp_getattr */
    0,                                          /* tp_setattr */
    0,                                          /* tp_as_async */
    0,                                          /* tp_repr */
    0,                                          /* tp_as_number */
    0,                                          /* tp_as_sequence */
    0,                                          /* tp_as_mapping */
    0,                                          /* tp_hash */
    0,                                          /* tp_call */
    0,                                          /* tp_str */
    0,                                          /* tp_getattro */
    0,                                          /* tp_setattro */
    0,                                          /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
    0,                                          /* tp_doc */
    0,                                          /* tp_traverse */
    0,                                          /* tp_clear */
    0,                                          /* tp_richcompare */
    0,                                          /* tp_weaklistoffset */
    0,                                          /* tp_iter */
    0,                                          /* tp_iternext */
    spamlist_methods,                           /* tp_methods */
    0,                                          /* tp_members */
    spamlist_getsets,                           /* tp_getset */
    DEFERRED_ADDRESS(&PyList_Type),             /* tp_base */
    0,                                          /* tp_dict */
    0,                                          /* tp_descr_get */
    0,                                          /* tp_descr_set */
    0,                                          /* tp_dictoffset */
    (initproc)spamlist_init,                    /* tp_init */
    0,                                          /* tp_alloc */
    0,                                          /* tp_new */
};

/* spamdict -- a dict subtype */

typedef struct {
    PyDictObject dict;
    int state;
} spamdictobject;

static PyObject *
spamdict_getstate(spamdictobject *self, PyObject *args)
{
    if (!PyArg_ParseTuple(args, ":getstate"))
        return NULL;
    return PyLong_FromLong(self->state);
}

static PyObject *
spamdict_setstate(spamdictobject *self, PyObject *args)
{
    int state;

    if (!PyArg_ParseTuple(args, "i:setstate", &state))
        return NULL;
    self->state = state;
    return Py_NewRef(Py_None);
}

static PyMethodDef spamdict_methods[] = {
    {"getstate", (PyCFunction)spamdict_getstate, METH_VARARGS,
        PyDoc_STR("getstate() -> state")},
    {"setstate", (PyCFunction)spamdict_setstate, METH_VARARGS,
        PyDoc_STR("setstate(state)")},
    {NULL,      NULL},
};

static int
spamdict_init(spamdictobject *self, PyObject *args, PyObject *kwds)
{
    if (PyDict_Type.tp_init((PyObject *)self, args, kwds) < 0)
        return -1;
    self->state = 0;
    return 0;
}

static PyMemberDef spamdict_members[] = {
    {"state", Py_T_INT, offsetof(spamdictobject, state), Py_READONLY,
     PyDoc_STR("an int variable for demonstration purposes")},
    {0}
};

static PyTypeObject spamdict_type = {
    PyVarObject_HEAD_INIT(DEFERRED_ADDRESS(&PyType_Type), 0)
    "xxsubtype.spamdict",
    sizeof(spamdictobject),
    0,
    0,                                          /* tp_dealloc */
    0,                                          /* tp_vectorcall_offset */
    0,                                          /* tp_getattr */
    0,                                          /* tp_setattr */
    0,                                          /* tp_as_async */
    0,                                          /* tp_repr */
    0,                                          /* tp_as_number */
    0,                                          /* tp_as_sequence */
    0,                                          /* tp_as_mapping */
    0,                                          /* tp_hash */
    0,                                          /* tp_call */
    0,                                          /* tp_str */
    0,                                          /* tp_getattro */
    0,                                          /* tp_setattro */
    0,                                          /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
    0,                                          /* tp_doc */
    0,                                          /* tp_traverse */
    0,                                          /* tp_clear */
    0,                                          /* tp_richcompare */
    0,                                          /* tp_weaklistoffset */
    0,                                          /* tp_iter */
    0,                                          /* tp_iternext */
    spamdict_methods,                           /* tp_methods */
    spamdict_members,                           /* tp_members */
    0,                                          /* tp_getset */
    DEFERRED_ADDRESS(&PyDict_Type),             /* tp_base */
    0,                                          /* tp_dict */
    0,                                          /* tp_descr_get */
    0,                                          /* tp_descr_set */
    0,                                          /* tp_dictoffset */
    (initproc)spamdict_init,                    /* tp_init */
    0,                                          /* tp_alloc */
    0,                                          /* tp_new */
};

static PyObject *
spam_bench(PyObject *self, PyObject *args)
{
    PyObject *obj, *name, *res;
    int n = 1000;
    time_t t0 = 0, t1 = 0;

    if (!PyArg_ParseTuple(args, "OU|i", &obj, &name, &n))
        return NULL;
#ifdef HAVE_CLOCK
    t0 = clock();
    while (--n >= 0) {
        res = PyObject_GetAttr(obj, name);
        if (res == NULL)
            return NULL;
        Py_DECREF(res);
    }
    t1 = clock();
#endif
    return PyFloat_FromDouble((double)(t1-t0) / CLOCKS_PER_SEC);
}

static PyMethodDef xxsubtype_functions[] = {
    {"bench",           spam_bench,     METH_VARARGS},
    {NULL,              NULL}           /* sentinel */
};

static int
xxsubtype_exec(PyObject* m)
{
    /* Fill in deferred data addresses.  This must be done before
       PyType_Ready() is called.  Note that PyType_Ready() automatically
       initializes the ob.ob_type field to &PyType_Type if it's NULL,
       so it's not necessary to fill in ob_type first. */
    spamdict_type.tp_base = &PyDict_Type;
    if (PyType_Ready(&spamdict_type) < 0)
        return -1;

    spamlist_type.tp_base = &PyList_Type;
    if (PyType_Ready(&spamlist_type) < 0)
        return -1;

    if (PyType_Ready(&spamlist_type) < 0)
        return -1;
    if (PyType_Ready(&spamdict_type) < 0)
        return -1;

    if (PyModule_AddObjectRef(m, "spamlist", (PyObject *)&spamlist_type) < 0)
        return -1;

    if (PyModule_AddObjectRef(m, "spamdict", (PyObject *)&spamdict_type) < 0)
        return -1;
    return 0;
}

static struct PyModuleDef_Slot xxsubtype_slots[] = {
    {Py_mod_exec, xxsubtype_exec},
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL},
};

static struct PyModuleDef xxsubtypemodule = {
    PyModuleDef_HEAD_INIT,
    "xxsubtype",
    xxsubtype__doc__,
    0,
    xxsubtype_functions,
    xxsubtype_slots,
    NULL,
    NULL,
    NULL
};


PyMODINIT_FUNC
PyInit_xxsubtype(void)
{
    return PyModuleDef_Init(&xxsubtypemodule);
}


================================================
File: /Modules/_ctypes/_ctypes_test.c
================================================
// Need limited C API version 3.13 for Py_mod_gil
#include "pyconfig.h"   // Py_GIL_DISABLED
#ifndef Py_GIL_DISABLED
#  define Py_LIMITED_API 0x030d0000
#endif

// gh-85283: On Windows, Py_LIMITED_API requires Py_BUILD_CORE to not attempt
// linking the extension to python3.lib (which fails). Py_BUILD_CORE_MODULE is
// needed to import Python symbols. Then Python.h undefines Py_BUILD_CORE and
// Py_BUILD_CORE_MODULE if Py_LIMITED_API is defined.
#define Py_BUILD_CORE
#define Py_BUILD_CORE_MODULE

#include <Python.h>

#if defined(Py_HAVE_C_COMPLEX) && defined(Py_FFI_SUPPORT_C_COMPLEX)
#  include "../_complex.h"        // csqrt()
#  undef I                        // for _ctypes_test_generated.c.h
#endif
#include <stdio.h>                // printf()
#include <stdlib.h>               // qsort()
#include <string.h>               // memset()
#ifdef MS_WIN32
#  include <windows.h>
#endif

#define EXPORT(x) Py_EXPORTED_SYMBOL x

#include "_ctypes_test_generated.c.h"

/* some functions handy for testing */

EXPORT(int)
_testfunc_cbk_reg_int(int a, int b, int c, int d, int e,
                      int (*func)(int, int, int, int, int))
{
    return func(a*a, b*b, c*c, d*d, e*e);
}

EXPORT(double)
_testfunc_cbk_reg_double(double a, double b, double c, double d, double e,
                         double (*func)(double, double, double, double, double))
{
    return func(a*a, b*b, c*c, d*d, e*e);
}

/*
 * This structure should be the same as in test_callbacks.py and the
 * method test_callback_large_struct. See issues 17310 and 20160: the
 * structure must be larger than 8 bytes long.
 */

typedef struct {
    unsigned long first;
    unsigned long second;
    unsigned long third;
} Test;

EXPORT(void)
_testfunc_cbk_large_struct(Test in, void (*func)(Test))
{
    func(in);
}

/*
 * See issue 29565. Update a structure passed by value;
 * the caller should not see any change.
 */

EXPORT(void)
_testfunc_large_struct_update_value(Test in)
{
    ((volatile Test *)&in)->first = 0x0badf00d;
    ((volatile Test *)&in)->second = 0x0badf00d;
    ((volatile Test *)&in)->third = 0x0badf00d;
}

typedef struct {
    unsigned int first;
    unsigned int second;
} TestReg;


EXPORT(TestReg) last_tfrsuv_arg = {0};


EXPORT(void)
_testfunc_reg_struct_update_value(TestReg in)
{
    last_tfrsuv_arg = in;
    ((volatile TestReg *)&in)->first = 0x0badf00d;
    ((volatile TestReg *)&in)->second = 0x0badf00d;
}

/*
 * See bpo-22273. Structs containing arrays should work on Linux 64-bit.
 */

typedef struct {
    unsigned char data[16];
} Test2;

EXPORT(int)
_testfunc_array_in_struct2(Test2 in)
{
    int result = 0;
    for (unsigned i = 0; i < sizeof(in.data)/sizeof(in.data[0]); i++)
        result += in.data[i];
    /* As the structure is passed by value, changes to it shouldn't be
     * reflected in the caller.
     */
    memset(in.data, 0, sizeof(in.data));
    return result;
}

/*
 * Test3A struct test the MAX_STRUCT_SIZE 16 with single precision floats.
 * These structs should be passed via registers on all platforms and they are
 * used for within bounds tests.
 */
typedef struct {
    float data[2];
    float more_data[2];
} Test3A;

EXPORT(double)
_testfunc_array_in_struct3A(Test3A in)
{
    double result = 0;

    for (unsigned i = 0; i < sizeof(in.data)/sizeof(in.data[0]); i++)
        result += in.data[i];
    for (unsigned i = 0; i < sizeof(in.more_data)/sizeof(in.more_data[0]); i++)
        result += in.more_data[i];
    /* As the structure is passed by value, changes to it shouldn't be
     * reflected in the caller.
     */
    memset(in.data, 0, sizeof(in.data));
    return result;
}

/* The structs Test3B..Test3E use the same functions hence using the MACRO
 * to define their implementation.
 */

#define _TESTFUNC_ARRAY_IN_STRUCT_IMPL                                  \
    double result = 0;                                                  \
                                                                        \
    for (unsigned i = 0; i < sizeof(in.data)/sizeof(in.data[0]); i++)   \
        result += in.data[i];                                           \
    /* As the structure is passed by value, changes to it shouldn't be  \
     * reflected in the caller.                                         \
     */                                                                 \
    memset(in.data, 0, sizeof(in.data));                                \
    return result;                                                      \

#define _TESTFUNC_ARRAY_IN_STRUCT_SET_DEFAULTS_IMPL                     \
    for (unsigned i = 0; i < sizeof(s.data)/sizeof(s.data[0]); i++)     \
        s.data[i] = (double)i+1;                                        \
    return s;                                                           \


/*
 * Test3B struct test the MAX_STRUCT_SIZE 16 with double precision floats.
 * These structs should be passed via registers on all platforms and they are
 * used for within bounds tests.
 */
typedef struct {
    double data[2];
} Test3B;

EXPORT(double)
_testfunc_array_in_struct3B(Test3B in)
{
    _TESTFUNC_ARRAY_IN_STRUCT_IMPL
}

EXPORT(Test3B)
_testfunc_array_in_struct3B_set_defaults(void)
{
    Test3B s;
    _TESTFUNC_ARRAY_IN_STRUCT_SET_DEFAULTS_IMPL
}

/*
 * Test3C struct tests the MAX_STRUCT_SIZE 32. Structs containing arrays of up
 * to four floating-point types are passed in registers on Arm platforms.
 * This struct is used for within-bounds tests on Arm platforms and for an
 * out-of-bounds test for platforms where MAX_STRUCT_SIZE is less than 32.
 * See gh-110190.
 */
typedef struct {
    double data[4];
} Test3C;

EXPORT(double)
_testfunc_array_in_struct3C(Test3C in)
{
    _TESTFUNC_ARRAY_IN_STRUCT_IMPL
}

EXPORT(Test3C)
_testfunc_array_in_struct3C_set_defaults(void)
{
    Test3C s;
    _TESTFUNC_ARRAY_IN_STRUCT_SET_DEFAULTS_IMPL
}

/*
 * Test3D struct tests the MAX_STRUCT_SIZE 64. Structs containing arrays of up
 * to eight floating-point types are passed in registers on PPC64LE platforms.
 * This struct is used for within bounds test on PPC64LE platforms and for an
 * out-of-bounds tests for platforms where MAX_STRUCT_SIZE is less than 64.
 * See gh-110190.
 */
typedef struct {
    double data[8];
} Test3D;

EXPORT(double)
_testfunc_array_in_struct3D(Test3D in)
{
    _TESTFUNC_ARRAY_IN_STRUCT_IMPL
}

EXPORT(Test3D)
_testfunc_array_in_struct3D_set_defaults(void)
{
    Test3D s;
    _TESTFUNC_ARRAY_IN_STRUCT_SET_DEFAULTS_IMPL
}

/*
 * Test3E struct tests the out-of-bounds for all architectures.
 * See gh-110190.
 */
typedef struct {
    double data[9];
} Test3E;

EXPORT(double)
_testfunc_array_in_struct3E(Test3E in)
{
    _TESTFUNC_ARRAY_IN_STRUCT_IMPL
}

EXPORT(Test3E)
_testfunc_array_in_struct3E_set_defaults(void)
{
    Test3E s;
    _TESTFUNC_ARRAY_IN_STRUCT_SET_DEFAULTS_IMPL
}

typedef union {
    long a_long;
    struct {
        int an_int;
        int another_int;
    } a_struct;
} Test4;

typedef struct {
    int an_int;
    struct {
        int an_int;
        Test4 a_union;
    } nested;
    int another_int;
} Test5;

EXPORT(long)
_testfunc_union_by_value1(Test4 in) {
    long result = in.a_long + in.a_struct.an_int + in.a_struct.another_int;

    /* As the union/struct are passed by value, changes to them shouldn't be
     * reflected in the caller.
     */
    memset(&in, 0, sizeof(in));
    return result;
}

EXPORT(long)
_testfunc_union_by_value2(Test5 in) {
    long result = in.an_int + in.nested.an_int;

    /* As the union/struct are passed by value, changes to them shouldn't be
     * reflected in the caller.
     */
    memset(&in, 0, sizeof(in));
    return result;
}

EXPORT(long)
_testfunc_union_by_reference1(Test4 *in) {
    long result = in->a_long;

    memset(in, 0, sizeof(Test4));
    return result;
}

EXPORT(long)
_testfunc_union_by_reference2(Test4 *in) {
    long result = in->a_struct.an_int + in->a_struct.another_int;

    memset(in, 0, sizeof(Test4));
    return result;
}

EXPORT(long)
_testfunc_union_by_reference3(Test5 *in) {
    long result = in->an_int + in->nested.an_int + in->another_int;

    memset(in, 0, sizeof(Test5));
    return result;
}

typedef struct {
    signed int A: 1, B:2, C:3, D:2;
} Test6;

EXPORT(long)
_testfunc_bitfield_by_value1(Test6 in) {
    long result = in.A + in.B + in.C + in.D;

    /* As the struct is passed by value, changes to it shouldn't be
     * reflected in the caller.
     */
    memset(&in, 0, sizeof(in));
    return result;
}

EXPORT(long)
_testfunc_bitfield_by_reference1(Test6 *in) {
    long result = in->A + in->B + in->C + in->D;

    memset(in, 0, sizeof(Test6));
    return result;
}

typedef struct {
    unsigned int A: 1, B:2, C:3, D:2;
} Test7;

EXPORT(long)
_testfunc_bitfield_by_reference2(Test7 *in) {
    long result = in->A + in->B + in->C + in->D;

    memset(in, 0, sizeof(Test7));
    return result;
}

typedef struct{
    uint16_t A ;
    uint16_t B : 9;
    uint16_t C : 1;
    uint16_t D : 1;
    uint16_t E : 1;
    uint16_t F : 1;
    uint16_t G : 3;
    uint32_t H : 10;
    uint32_t I : 20;
    uint32_t J : 2;
} Test9;

EXPORT(long)
_testfunc_bitfield_by_reference3(Test9 *in, long pos) {
    long data[] = {in->A , in->B , in->C , in->D , in->E , in->F , in->G , in->H , in->I , in->J};
    long data_length = (long) (sizeof(data)/sizeof(data[0]));
    if(pos < 0)
        return -1;
    if(pos >= data_length)
        return -1;

    return data[pos];
}

typedef union {
    signed int A: 1, B:2, C:3, D:2;
} Test8;

EXPORT(long)
_testfunc_bitfield_by_value2(Test8 in) {
    long result = in.A + in.B + in.C + in.D;

    /* As the struct is passed by value, changes to it shouldn't be
     * reflected in the caller.
     */
    memset(&in, 0, sizeof(in));
    return result;
}

EXPORT(void)testfunc_array(int values[4])
{
    printf("testfunc_array %d %d %d %d\n",
           values[0],
           values[1],
           values[2],
           values[3]);
}

EXPORT(long double)testfunc_Ddd(double a, double b)
{
    long double result = (long double)(a * b);
    printf("testfunc_Ddd(%p, %p)\n", (void *)&a, (void *)&b);
    printf("testfunc_Ddd(%g, %g)\n", a, b);
    return result;
}

EXPORT(long double)testfunc_DDD(long double a, long double b)
{
    long double result = a * b;
    printf("testfunc_DDD(%p, %p)\n", (void *)&a, (void *)&b);
    printf("testfunc_DDD(%Lg, %Lg)\n", a, b);
    return result;
}

EXPORT(int)testfunc_iii(int a, int b)
{
    int result = a * b;
    printf("testfunc_iii(%p, %p)\n", (void *)&a, (void *)&b);
    return result;
}

EXPORT(int)myprintf(char *fmt, ...)
{
    int result;
    va_list argptr;
    va_start(argptr, fmt);
    result = vprintf(fmt, argptr);
    va_end(argptr);
    return result;
}

EXPORT(char *)my_strtok(char *token, const char *delim)
{
    return strtok(token, delim);
}

EXPORT(char *)my_strchr(const char *s, int c)
{
    return strchr(s, c);
}


EXPORT(double) my_sqrt(double a)
{
    return sqrt(a);
}

#if defined(Py_HAVE_C_COMPLEX) && defined(Py_FFI_SUPPORT_C_COMPLEX)
EXPORT(double complex) my_csqrt(double complex a)
{
    return csqrt(a);
}

EXPORT(float complex) my_csqrtf(float complex a)
{
    return csqrtf(a);
}

EXPORT(long double complex) my_csqrtl(long double complex a)
{
    return csqrtl(a);
}
#endif

EXPORT(void) my_qsort(void *base, size_t num, size_t width, int(*compare)(const void*, const void*))
{
    qsort(base, num, width, compare);
}

EXPORT(int *) _testfunc_ai8(int a[8])
{
    return a;
}

EXPORT(void) _testfunc_v(int a, int b, int *presult)
{
    *presult = a + b;
}

EXPORT(int) _testfunc_i_bhilfd(signed char b, short h, int i, long l, float f, double d)
{
/*      printf("_testfunc_i_bhilfd got %d %d %d %ld %f %f\n",
               b, h, i, l, f, d);
*/
    return (int)(b + h + i + l + f + d);
}

EXPORT(float) _testfunc_f_bhilfd(signed char b, short h, int i, long l, float f, double d)
{
/*      printf("_testfunc_f_bhilfd got %d %d %d %ld %f %f\n",
               b, h, i, l, f, d);
*/
    return (float)(b + h + i + l + f + d);
}

EXPORT(double) _testfunc_d_bhilfd(signed char b, short h, int i, long l, float f, double d)
{
/*      printf("_testfunc_d_bhilfd got %d %d %d %ld %f %f\n",
               b, h, i, l, f, d);
*/
    return (double)(b + h + i + l + f + d);
}

EXPORT(long double) _testfunc_D_bhilfD(signed char b, short h, int i, long l, float f, long double d)
{
/*      printf("_testfunc_d_bhilfd got %d %d %d %ld %f %f\n",
               b, h, i, l, f, d);
*/
    return (long double)(b + h + i + l + f + d);
}

EXPORT(char *) _testfunc_p_p(void *s)
{
    return (char *)s;
}

EXPORT(void *) _testfunc_c_p_p(int *argcp, char **argv)
{
    return argv[(*argcp)-1];
}

EXPORT(void *) get_strchr(void)
{
    return (void *)strchr;
}

EXPORT(char *) my_strdup(char *src)
{
    char *dst = (char *)malloc(strlen(src)+1);
    if (!dst)
        return NULL;
    strcpy(dst, src);
    return dst;
}

EXPORT(void)my_free(void *ptr)
{
    free(ptr);
}

#ifdef HAVE_WCHAR_H
EXPORT(wchar_t *) my_wcsdup(wchar_t *src)
{
    size_t len = wcslen(src);
    wchar_t *ptr = (wchar_t *)malloc((len + 1) * sizeof(wchar_t));
    if (ptr == NULL)
        return NULL;
    memcpy(ptr, src, (len+1) * sizeof(wchar_t));
    return ptr;
}

EXPORT(size_t) my_wcslen(wchar_t *src)
{
    return wcslen(src);
}
#endif

#ifndef MS_WIN32
# ifndef __stdcall
#  define __stdcall /* */
# endif
#endif

typedef struct {
    int (*c)(int, int);
    int (__stdcall *s)(int, int);
} FUNCS;

EXPORT(int) _testfunc_callfuncp(FUNCS *fp)
{
    fp->c(1, 2);
    fp->s(3, 4);
    return 0;
}

EXPORT(int) _testfunc_deref_pointer(int *pi)
{
    return *pi;
}

#ifdef MS_WIN32
EXPORT(int) _testfunc_piunk(IUnknown FAR *piunk)
{
    piunk->lpVtbl->AddRef(piunk);
    return piunk->lpVtbl->Release(piunk);
}
#endif

EXPORT(int) _testfunc_callback_with_pointer(int (*func)(int *))
{
    int table[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    return (*func)(table);
}

EXPORT(long long) _testfunc_q_bhilfdq(signed char b, short h, int i, long l, float f,
                                      double d, long long q)
{
    return (long long)(b + h + i + l + f + d + q);
}

EXPORT(long long) _testfunc_q_bhilfd(signed char b, short h, int i, long l, float f, double d)
{
    return (long long)(b + h + i + l + f + d);
}

EXPORT(int) _testfunc_callback_i_if(int value, int (*func)(int))
{
    int sum = 0;
    while (value != 0) {
        sum += func(value);
        value /= 2;
    }
    return sum;
}

EXPORT(long long) _testfunc_callback_q_qf(long long value,
                                          long long (*func)(long long))
{
    long long sum = 0;

    while (value != 0) {
        sum += func(value);
        value /= 2;
    }
    return sum;
}

typedef struct {
    char *name;
    char *value;
} SPAM;

typedef struct {
    char *name;
    int num_spams;
    SPAM *spams;
} EGG;

SPAM my_spams[2] = {
    { "name1", "value1" },
    { "name2", "value2" },
};

EGG my_eggs[1] = {
    { "first egg", 1, my_spams }
};

EXPORT(int) getSPAMANDEGGS(EGG **eggs)
{
    *eggs = my_eggs;
    return 1;
}

typedef struct tagpoint {
    int x;
    int y;
} point;

EXPORT(int) _testfunc_byval(point in, point *pout)
{
    if (pout) {
        pout->x = in.x;
        pout->y = in.y;
    }
    return in.x + in.y;
}

EXPORT (int) an_integer = 42;

EXPORT(int) get_an_integer(void)
{
    return an_integer;
}

EXPORT(double)
integrate(double a, double b, double (*f)(double), long nstep)
{
    double x, sum=0.0, dx=(b-a)/(double)nstep;
    for(x=a+0.5*dx; (b-x)*(x-a)>0.0; x+=dx)
        sum += f(x);
    return sum/(double)nstep;
}

typedef struct {
    void (*initialize)(void *(*)(int), void(*)(void *));
} xxx_library;

static void _xxx_init(void *(*Xalloc)(int), void (*Xfree)(void *))
{
    void *ptr;

    printf("_xxx_init got %p %p\n", (void *)Xalloc, (void *)Xfree);
    printf("calling\n");
    ptr = Xalloc(32);
    Xfree(ptr);
    printf("calls done, ptr was %p\n", ptr);
}

xxx_library _xxx_lib = {
    _xxx_init
};

EXPORT(xxx_library) *library_get(void)
{
    return &_xxx_lib;
}

#ifdef MS_WIN32
/* See Don Box (german), pp 79ff. */
EXPORT(void) GetString(BSTR *pbstr)
{
    *pbstr = SysAllocString(L"Goodbye!");
}
#endif

/*
 * Some do-nothing functions, for speed tests
 */
PyObject *py_func_si(PyObject *self, PyObject *args)
{
    char *name;
    int i;
    if (!PyArg_ParseTuple(args, "si", &name, &i))
        return NULL;
    Py_RETURN_NONE;
}

EXPORT(void) _py_func_si(char *s, int i)
{
}

PyObject *py_func(PyObject *self, PyObject *args)
{
    Py_RETURN_NONE;
}

EXPORT(void) _py_func(void)
{
}

EXPORT(long long) last_tf_arg_s = 0;
EXPORT(unsigned long long) last_tf_arg_u = 0;

struct BITS {
    signed int A: 1, B:2, C:3, D:4, E: 5, F: 6, G: 7, H: 8, I: 9;
/*
 * The test case needs/uses "signed short" bitfields, but the
 * IBM XLC compiler does not support this
 */
#ifndef __xlc__
#define SIGNED_SHORT_BITFIELDS
    signed short M: 1, N: 2, O: 3, P: 4, Q: 5, R: 6, S: 7;
#endif
};

EXPORT(int) unpack_bitfields(struct BITS *bits, char name)
{
    switch (name) {
    case 'A': return bits->A;
    case 'B': return bits->B;
    case 'C': return bits->C;
    case 'D': return bits->D;
    case 'E': return bits->E;
    case 'F': return bits->F;
    case 'G': return bits->G;
    case 'H': return bits->H;
    case 'I': return bits->I;

#ifdef SIGNED_SHORT_BITFIELDS
    case 'M': return bits->M;
    case 'N': return bits->N;
    case 'O': return bits->O;
    case 'P': return bits->P;
    case 'Q': return bits->Q;
    case 'R': return bits->R;
    case 'S': return bits->S;
#endif
    }
    return 999;
}

#if (defined(MS_WIN32) || ((defined(__x86_64__) || defined(__i386__) || defined(__ppc64__)) && (defined(__GNUC__) || defined(__clang__))))
struct
#ifndef MS_WIN32
__attribute__ ((ms_struct))
#endif
BITS_msvc
{
    signed int A: 1, B:2, C:3, D:4, E: 5, F: 6, G: 7, H: 8, I: 9;
/*
 * The test case needs/uses "signed short" bitfields, but the
 * IBM XLC compiler does not support this
 */
#ifndef __xlc__
#define SIGNED_SHORT_BITFIELDS
    signed short M: 1, N: 2, O: 3, P: 4, Q: 5, R: 6, S: 7;
#endif
};

EXPORT(int) unpack_bitfields_msvc(struct BITS_msvc *bits, char name)
{
    switch (name) {
    case 'A': return bits->A;
    case 'B': return bits->B;
    case 'C': return bits->C;
    case 'D': return bits->D;
    case 'E': return bits->E;
    case 'F': return bits->F;
    case 'G': return bits->G;
    case 'H': return bits->H;
    case 'I': return bits->I;

#ifdef SIGNED_SHORT_BITFIELDS
    case 'M': return bits->M;
    case 'N': return bits->N;
    case 'O': return bits->O;
    case 'P': return bits->P;
    case 'Q': return bits->Q;
    case 'R': return bits->R;
    case 'S': return bits->S;
#endif
    }
    return 999;
}
#endif

static PyMethodDef module_methods[] = {
/*      {"get_last_tf_arg_s", get_last_tf_arg_s, METH_NOARGS},
    {"get_last_tf_arg_u", get_last_tf_arg_u, METH_NOARGS},
*/
    {"func_si", py_func_si, METH_VARARGS},
    {"func", py_func, METH_NOARGS},
    {"get_generated_test_data", get_generated_test_data, METH_O},
    { NULL, NULL, 0, NULL},
};

#define S last_tf_arg_s = (long long)c
#define U last_tf_arg_u = (unsigned long long)c

EXPORT(signed char) tf_b(signed char c) { S; return c/3; }
EXPORT(unsigned char) tf_B(unsigned char c) { U; return c/3; }
EXPORT(short) tf_h(short c) { S; return c/3; }
EXPORT(unsigned short) tf_H(unsigned short c) { U; return c/3; }
EXPORT(int) tf_i(int c) { S; return c/3; }
EXPORT(unsigned int) tf_I(unsigned int c) { U; return c/3; }
EXPORT(long) tf_l(long c) { S; return c/3; }
EXPORT(unsigned long) tf_L(unsigned long c) { U; return c/3; }
EXPORT(long long) tf_q(long long c) { S; return c/3; }
EXPORT(unsigned long long) tf_Q(unsigned long long c) { U; return c/3; }
EXPORT(float) tf_f(float c) { S; return c/3; }
EXPORT(double) tf_d(double c) { S; return c/3; }
EXPORT(long double) tf_D(long double c) { S; return c/3; }

#ifdef MS_WIN32
EXPORT(signed char) __stdcall s_tf_b(signed char c) { S; return c/3; }
EXPORT(unsigned char) __stdcall s_tf_B(unsigned char c) { U; return c/3; }
EXPORT(short) __stdcall s_tf_h(short c) { S; return c/3; }
EXPORT(unsigned short) __stdcall s_tf_H(unsigned short c) { U; return c/3; }
EXPORT(int) __stdcall s_tf_i(int c) { S; return c/3; }
EXPORT(unsigned int) __stdcall s_tf_I(unsigned int c) { U; return c/3; }
EXPORT(long) __stdcall s_tf_l(long c) { S; return c/3; }
EXPORT(unsigned long) __stdcall s_tf_L(unsigned long c) { U; return c/3; }
EXPORT(long long) __stdcall s_tf_q(long long c) { S; return c/3; }
EXPORT(unsigned long long) __stdcall s_tf_Q(unsigned long long c) { U; return c/3; }
EXPORT(float) __stdcall s_tf_f(float c) { S; return c/3; }
EXPORT(double) __stdcall s_tf_d(double c) { S; return c/3; }
EXPORT(long double) __stdcall s_tf_D(long double c) { S; return c/3; }
#endif
/*******/

EXPORT(signed char) tf_bb(signed char x, signed char c) { S; return c/3; }
EXPORT(unsigned char) tf_bB(signed char x, unsigned char c) { U; return c/3; }
EXPORT(short) tf_bh(signed char x, short c) { S; return c/3; }
EXPORT(unsigned short) tf_bH(signed char x, unsigned short c) { U; return c/3; }
EXPORT(int) tf_bi(signed char x, int c) { S; return c/3; }
EXPORT(unsigned int) tf_bI(signed char x, unsigned int c) { U; return c/3; }
EXPORT(long) tf_bl(signed char x, long c) { S; return c/3; }
EXPORT(unsigned long) tf_bL(signed char x, unsigned long c) { U; return c/3; }
EXPORT(long long) tf_bq(signed char x, long long c) { S; return c/3; }
EXPORT(unsigned long long) tf_bQ(signed char x, unsigned long long c) { U; return c/3; }
EXPORT(float) tf_bf(signed char x, float c) { S; return c/3; }
EXPORT(double) tf_bd(signed char x, double c) { S; return c/3; }
EXPORT(long double) tf_bD(signed char x, long double c) { S; return c/3; }
EXPORT(void) tv_i(int c) { S; return; }

#ifdef MS_WIN32
EXPORT(signed char) __stdcall s_tf_bb(signed char x, signed char c) { S; return c/3; }
EXPORT(unsigned char) __stdcall s_tf_bB(signed char x, unsigned char c) { U; return c/3; }
EXPORT(short) __stdcall s_tf_bh(signed char x, short c) { S; return c/3; }
EXPORT(unsigned short) __stdcall s_tf_bH(signed char x, unsigned short c) { U; return c/3; }
EXPORT(int) __stdcall s_tf_bi(signed char x, int c) { S; return c/3; }
EXPORT(unsigned int) __stdcall s_tf_bI(signed char x, unsigned int c) { U; return c/3; }
EXPORT(long) __stdcall s_tf_bl(signed char x, long c) { S; return c/3; }
EXPORT(unsigned long) __stdcall s_tf_bL(signed char x, unsigned long c) { U; return c/3; }
EXPORT(long long) __stdcall s_tf_bq(signed char x, long long c) { S; return c/3; }
EXPORT(unsigned long long) __stdcall s_tf_bQ(signed char x, unsigned long long c) { U; return c/3; }
EXPORT(float) __stdcall s_tf_bf(signed char x, float c) { S; return c/3; }
EXPORT(double) __stdcall s_tf_bd(signed char x, double c) { S; return c/3; }
EXPORT(long double) __stdcall s_tf_bD(signed char x, long double c) { S; return c/3; }
EXPORT(void) __stdcall s_tv_i(int c) { S; return; }
#endif

/********/

#ifndef MS_WIN32

typedef struct {
    long x;
    long y;
} POINT;

typedef struct {
    long left;
    long top;
    long right;
    long bottom;
} RECT;

#endif

EXPORT(int) PointInRect(RECT *prc, POINT pt)
{
    if (pt.x < prc->left)
        return 0;
    if (pt.x > prc->right)
        return 0;
    if (pt.y < prc->top)
        return 0;
    if (pt.y > prc->bottom)
        return 0;
    return 1;
}

EXPORT(long left = 10);
EXPORT(long top = 20);
EXPORT(long right = 30);
EXPORT(long bottom = 40);

EXPORT(RECT) ReturnRect(int i, RECT ar, RECT* br, POINT cp, RECT dr,
                        RECT *er, POINT fp, RECT gr)
{
    /*Check input */
    if (ar.left + br->left + dr.left + er->left + gr.left != left * 5)
    {
        ar.left = 100;
        return ar;
    }
    if (ar.right + br->right + dr.right + er->right + gr.right != right * 5)
    {
        ar.right = 100;
        return ar;
    }
    if (cp.x != fp.x)
    {
        ar.left = -100;
    }
    if (cp.y != fp.y)
    {
        ar.left = -200;
    }
    switch(i)
    {
    case 0:
        return ar;
        break;
    case 1:
        return dr;
        break;
    case 2:
        return gr;
        break;

    }
    return ar;
}

typedef struct {
    short x;
    short y;
} S2H;

EXPORT(S2H) ret_2h_func(S2H inp)
{
    inp.x *= 2;
    inp.y *= 3;
    return inp;
}

typedef struct {
    int a, b, c, d, e, f, g, h;
} S8I;

EXPORT(S8I) ret_8i_func(S8I inp)
{
    inp.a *= 2;
    inp.b *= 3;
    inp.c *= 4;
    inp.d *= 5;
    inp.e *= 6;
    inp.f *= 7;
    inp.g *= 8;
    inp.h *= 9;
    return inp;
}

EXPORT(int) GetRectangle(int flag, RECT *prect)
{
    if (flag == 0)
        return 0;
    prect->left = (int)flag;
    prect->top = (int)flag + 1;
    prect->right = (int)flag + 2;
    prect->bottom = (int)flag + 3;
    return 1;
}

EXPORT(void) TwoOutArgs(int a, int *pi, int b, int *pj)
{
    *pi += a;
    *pj += b;
}

#ifdef MS_WIN32

typedef struct {
    char f1;
} Size1;

typedef struct {
    char f1;
    char f2;
} Size2;

typedef struct {
    char f1;
    char f2;
    char f3;
} Size3;

typedef struct {
    char f1;
    char f2;
    char f3;
    char f4;
} Size4;

typedef struct {
    char f1;
    char f2;
    char f3;
    char f4;
    char f5;
} Size5;

typedef struct {
    char f1;
    char f2;
    char f3;
    char f4;
    char f5;
    char f6;
} Size6;

typedef struct {
    char f1;
    char f2;
    char f3;
    char f4;
    char f5;
    char f6;
    char f7;
} Size7;

typedef struct {
    char f1;
    char f2;
    char f3;
    char f4;
    char f5;
    char f6;
    char f7;
    char f8;
} Size8;

typedef struct {
    char f1;
    char f2;
    char f3;
    char f4;
    char f5;
    char f6;
    char f7;
    char f8;
    char f9;
} Size9;

typedef struct {
    char f1;
    char f2;
    char f3;
    char f4;
    char f5;
    char f6;
    char f7;
    char f8;
    char f9;
    char f10;
} Size10;

EXPORT(Size1) TestSize1() {
    Size1 f;
    f.f1 = 'a';
    return f;
}

EXPORT(Size2) TestSize2() {
    Size2 f;
    f.f1 = 'a';
    f.f2 = 'b';
    return f;
}

EXPORT(Size3) TestSize3() {
    Size3 f;
    f.f1 = 'a';
    f.f2 = 'b';
    f.f3 = 'c';
    return f;
}

EXPORT(Size4) TestSize4() {
    Size4 f;
    f.f1 = 'a';
    f.f2 = 'b';
    f.f3 = 'c';
    f.f4 = 'd';
    return f;
}

EXPORT(Size5) TestSize5() {
    Size5 f;
    f.f1 = 'a';
    f.f2 = 'b';
    f.f3 = 'c';
    f.f4 = 'd';
    f.f5 = 'e';
    return f;
}

EXPORT(Size6) TestSize6() {
    Size6 f;
    f.f1 = 'a';
    f.f2 = 'b';
    f.f3 = 'c';
    f.f4 = 'd';
    f.f5 = 'e';
    f.f6 = 'f';
    return f;
}

EXPORT(Size7) TestSize7() {
    Size7 f;
    f.f1 = 'a';
    f.f2 = 'b';
    f.f3 = 'c';
    f.f4 = 'd';
    f.f5 = 'e';
    f.f6 = 'f';
    f.f7 = 'g';
    return f;
}

EXPORT(Size8) TestSize8() {
    Size8 f;
    f.f1 = 'a';
    f.f2 = 'b';
    f.f3 = 'c';
    f.f4 = 'd';
    f.f5 = 'e';
    f.f6 = 'f';
    f.f7 = 'g';
    f.f8 = 'h';
    return f;
}

EXPORT(Size9) TestSize9() {
    Size9 f;
    f.f1 = 'a';
    f.f2 = 'b';
    f.f3 = 'c';
    f.f4 = 'd';
    f.f5 = 'e';
    f.f6 = 'f';
    f.f7 = 'g';
    f.f8 = 'h';
    f.f9 = 'i';
    return f;
}

EXPORT(Size10) TestSize10() {
    Size10 f;
    f.f1 = 'a';
    f.f2 = 'b';
    f.f3 = 'c';
    f.f4 = 'd';
    f.f5 = 'e';
    f.f6 = 'f';
    f.f7 = 'g';
    f.f8 = 'h';
    f.f9 = 'i';
    f.f10 = 'j';
    return f;
}

#endif

#ifdef MS_WIN32
EXPORT(S2H) __stdcall s_ret_2h_func(S2H inp) { return ret_2h_func(inp); }
EXPORT(S8I) __stdcall s_ret_8i_func(S8I inp) { return ret_8i_func(inp); }
#endif

#ifdef MS_WIN32
/* Should port this */
#include <stdlib.h>
#include <search.h>

EXPORT (HRESULT) KeepObject(IUnknown *punk)
{
    static IUnknown *pobj;
    if (punk)
        punk->lpVtbl->AddRef(punk);
    if (pobj)
        pobj->lpVtbl->Release(pobj);
    pobj = punk;
    return S_OK;
}

#endif

#ifdef MS_WIN32

// i38748: c stub for testing stack corruption
// When executing a Python callback with a long and a long long

typedef long(__stdcall *_test_i38748_funcType)(long, long long);

EXPORT(long) _test_i38748_runCallback(_test_i38748_funcType callback, int a, int b) {
    return callback(a, b);
}

#endif

EXPORT(int)
_testfunc_pylist_append(PyObject *list, PyObject *item)
{
    return PyList_Append(list, item);
}

static struct PyModuleDef_Slot _ctypes_test_slots[] = {
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL}
};

static struct PyModuleDef _ctypes_testmodule = {
    PyModuleDef_HEAD_INIT,
    "_ctypes_test",
    NULL,
    0,
    module_methods,
    _ctypes_test_slots,
    NULL,
    NULL,
    NULL
};

PyMODINIT_FUNC
PyInit__ctypes_test(void)
{
    return PyModuleDef_Init(&_ctypes_testmodule);
}


================================================
File: /Modules/_ctypes/_ctypes_test.h
================================================
extern int _testfunc_i_bhilfd(char b, short h, int i, long l, float f, double d);


================================================
File: /Modules/_ctypes/callbacks.c
================================================
#ifndef Py_BUILD_CORE_BUILTIN
#  define Py_BUILD_CORE_MODULE 1
#endif

#include "Python.h"
// windows.h must be included before pycore internal headers
#ifdef MS_WIN32
#  include <windows.h>
#endif

#include "pycore_call.h"          // _PyObject_CallNoArgs()
#include "pycore_runtime.h"       // _Py_ID()

#include <stdbool.h>

#ifdef MS_WIN32
#  include <malloc.h>
#endif

#include <ffi.h>
#include "ctypes.h"

#ifdef HAVE_ALLOCA_H
/* AIX needs alloca.h for alloca() */
#include <alloca.h>
#endif

/**************************************************************/

static int
CThunkObject_traverse(PyObject *myself, visitproc visit, void *arg)
{
    CThunkObject *self = (CThunkObject *)myself;
    Py_VISIT(Py_TYPE(self));
    Py_VISIT(self->converters);
    Py_VISIT(self->callable);
    Py_VISIT(self->restype);
    return 0;
}

static int
CThunkObject_clear(PyObject *myself)
{
    CThunkObject *self = (CThunkObject *)myself;
    Py_CLEAR(self->converters);
    Py_CLEAR(self->callable);
    Py_CLEAR(self->restype);
    return 0;
}

static void
CThunkObject_dealloc(PyObject *myself)
{
    CThunkObject *self = (CThunkObject *)myself;
    PyTypeObject *tp = Py_TYPE(myself);
    PyObject_GC_UnTrack(self);
    (void)CThunkObject_clear(myself);
    if (self->pcl_write) {
        Py_ffi_closure_free(self->pcl_write);
    }
    PyObject_GC_Del(self);
    Py_DECREF(tp);
}

static PyType_Slot cthunk_slots[] = {
    {Py_tp_doc, (void *)PyDoc_STR("CThunkObject")},
    {Py_tp_dealloc, CThunkObject_dealloc},
    {Py_tp_traverse, CThunkObject_traverse},
    {Py_tp_clear, CThunkObject_clear},
    {0, NULL},
};

PyType_Spec cthunk_spec = {
    .name = "_ctypes.CThunkObject",
    .basicsize = sizeof(CThunkObject),
    .itemsize = sizeof(ffi_type),
    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
              Py_TPFLAGS_IMMUTABLETYPE | Py_TPFLAGS_DISALLOW_INSTANTIATION),
    .slots = cthunk_slots,
};

/**************************************************************/

static void
PrintError(const char *msg, ...)
{
    char buf[512];
    PyObject *f = PySys_GetObject("stderr");
    va_list marker;

    va_start(marker, msg);
    PyOS_vsnprintf(buf, sizeof(buf), msg, marker);
    va_end(marker);
    if (f != NULL && f != Py_None)
        PyFile_WriteString(buf, f);
    PyErr_Print();
}


#ifdef MS_WIN32
/*
 * We must call AddRef() on non-NULL COM pointers we receive as arguments
 * to callback functions - these functions are COM method implementations.
 * The Python instances we create have a __del__ method which calls Release().
 *
 * The presence of a class attribute named '_needs_com_addref_' triggers this
 * behaviour.  It would also be possible to call the AddRef() Python method,
 * after checking for PyObject_IsTrue(), but this would probably be somewhat
 * slower.
 */
static void
TryAddRef(PyObject *cnv, CDataObject *obj)
{
    IUnknown *punk;
    PyObject *attrdict = _PyType_GetDict((PyTypeObject *)cnv);
    if (!attrdict) {
        return;
    }
    int r = PyDict_Contains(attrdict, &_Py_ID(_needs_com_addref_));
    if (r <= 0) {
        if (r < 0) {
            PrintError("getting _needs_com_addref_");
        }
        return;
    }

    punk = *(IUnknown **)obj->b_ptr;
    if (punk)
        punk->lpVtbl->AddRef(punk);
    return;
}
#endif

/******************************************************************************
 *
 * Call the python object with all arguments
 *
 */

// BEWARE: The GIL needs to be held throughout the function
static void _CallPythonObject(ctypes_state *st,
                              void *mem,
                              ffi_type *restype,
                              SETFUNC setfunc,
                              PyObject *callable,
                              PyObject *converters,
                              int flags,
                              void **pArgs)
{
    PyObject *result = NULL;
    Py_ssize_t i = 0, j = 0, nargs = 0;
    PyObject *error_object = NULL;
    int *space;

    assert(PyTuple_Check(converters));
    nargs = PyTuple_GET_SIZE(converters);
    assert(nargs <= CTYPES_MAX_ARGCOUNT);
    PyObject **args = alloca(nargs * sizeof(PyObject *));
    PyObject **cnvs = PySequence_Fast_ITEMS(converters);
    for (i = 0; i < nargs; i++) {
        PyObject *cnv = cnvs[i]; // borrowed ref

        StgInfo *info;
        if (PyStgInfo_FromType(st, cnv, &info) < 0) {
            goto Done;
        }

        if (info && info->getfunc && !_ctypes_simple_instance(st, cnv)) {
            PyObject *v = info->getfunc(*pArgs, info->size);
            if (!v) {
                PrintError("create argument %zd:\n", i);
                goto Done;
            }
            args[i] = v;
            /* XXX XXX XX
               We have the problem that c_byte or c_short have info->size of
               1 resp. 4, but these parameters are pushed as sizeof(int) bytes.
               BTW, the same problem occurs when they are pushed as parameters
            */
        }
        else if (info) {
            /* Hm, shouldn't we use PyCData_AtAddress() or something like that instead? */
            CDataObject *obj = (CDataObject *)_PyObject_CallNoArgs(cnv);
            if (!obj) {
                PrintError("create argument %zd:\n", i);
                goto Done;
            }
            if (!CDataObject_Check(st, obj)) {
                Py_DECREF(obj);
                PrintError("unexpected result of create argument %zd:\n", i);
                goto Done;
            }
            memcpy(obj->b_ptr, *pArgs, info->size);
            args[i] = (PyObject *)obj;
#ifdef MS_WIN32
            TryAddRef(cnv, obj);
#endif
        } else {
            PyErr_SetString(PyExc_TypeError,
                            "cannot build parameter");
            PrintError("Parsing argument %zd\n", i);
            goto Done;
        }
        /* XXX error handling! */
        pArgs++;
    }

    if (flags & (FUNCFLAG_USE_ERRNO | FUNCFLAG_USE_LASTERROR)) {
        error_object = _ctypes_get_errobj(st, &space);
        if (error_object == NULL)
            goto Done;
        if (flags & FUNCFLAG_USE_ERRNO) {
            int temp = space[0];
            space[0] = errno;
            errno = temp;
        }
#ifdef MS_WIN32
        if (flags & FUNCFLAG_USE_LASTERROR) {
            int temp = space[1];
            space[1] = GetLastError();
            SetLastError(temp);
        }
#endif
    }

    result = PyObject_Vectorcall(callable, args, nargs, NULL);
    if (result == NULL) {
        PyErr_FormatUnraisable(
                "Exception ignored on calling ctypes callback function %R",
                callable);
    }

#ifdef MS_WIN32
    if (flags & FUNCFLAG_USE_LASTERROR) {
        int temp = space[1];
        space[1] = GetLastError();
        SetLastError(temp);
    }
#endif
    if (flags & FUNCFLAG_USE_ERRNO) {
        int temp = space[0];
        space[0] = errno;
        errno = temp;
    }
    Py_XDECREF(error_object);

    if (restype != &ffi_type_void && result) {
        assert(setfunc);

#ifdef WORDS_BIGENDIAN
        /* See the corresponding code in _ctypes_callproc():
           in callproc.c, around line 1219. */
        if (restype->type != FFI_TYPE_FLOAT && restype->size < sizeof(ffi_arg)) {
            mem = (char *)mem + sizeof(ffi_arg) - restype->size;
        }
#endif

        /* keep is an object we have to keep alive so that the result
           stays valid.  If there is no such object, the setfunc will
           have returned Py_None.

           If there is such an object, we have no choice than to keep
           it alive forever - but a refcount and/or memory leak will
           be the result.  EXCEPT when restype is py_object - Python
           itself knows how to manage the refcount of these objects.
        */
        PyObject *keep = setfunc(mem, result, restype->size);

        if (keep == NULL) {
            /* Could not convert callback result. */
            PyErr_FormatUnraisable(
                    "Exception ignored on converting result "
                    "of ctypes callback function %R",
                    callable);
        }
        else if (setfunc != _ctypes_get_fielddesc("O")->setfunc) {
            if (keep == Py_None) {
                /* Nothing to keep */
                Py_DECREF(keep);
            }
            else if (PyErr_WarnEx(PyExc_RuntimeWarning,
                                  "memory leak in callback function.",
                                  1) == -1) {
                PyErr_FormatUnraisable(
                        "Exception ignored on converting result "
                        "of ctypes callback function %R",
                        callable);
            }
        }
    }

    Py_XDECREF(result);

  Done:
    for (j = 0; j < i; j++) {
        Py_DECREF(args[j]);
    }
}

static void closure_fcn(ffi_cif *cif,
                        void *resp,
                        void **args,
                        void *userdata)
{
    PyGILState_STATE state = PyGILState_Ensure();

    CThunkObject *p = (CThunkObject *)userdata;
    ctypes_state *st = get_module_state_by_class(Py_TYPE(p));

    _CallPythonObject(st,
                      resp,
                      p->ffi_restype,
                      p->setfunc,
                      p->callable,
                      p->converters,
                      p->flags,
                      args);

    PyGILState_Release(state);
}

static CThunkObject* CThunkObject_new(ctypes_state *st, Py_ssize_t nargs)
{
    CThunkObject *p;
    Py_ssize_t i;

    p = PyObject_GC_NewVar(CThunkObject, st->PyCThunk_Type, nargs);
    if (p == NULL) {
        return NULL;
    }

    p->pcl_write = NULL;
    p->pcl_exec = NULL;
    memset(&p->cif, 0, sizeof(p->cif));
    p->flags = 0;
    p->converters = NULL;
    p->callable = NULL;
    p->restype = NULL;
    p->setfunc = NULL;
    p->ffi_restype = NULL;

    for (i = 0; i < nargs + 1; ++i)
        p->atypes[i] = NULL;
    PyObject_GC_Track((PyObject *)p);
    return p;
}

CThunkObject *_ctypes_alloc_callback(ctypes_state *st,
                                    PyObject *callable,
                                    PyObject *converters,
                                    PyObject *restype,
                                    int flags)
{
    int result;
    CThunkObject *p;
    Py_ssize_t nargs, i;
    ffi_abi cc;

    assert(PyTuple_Check(converters));
    nargs = PyTuple_GET_SIZE(converters);
    p = CThunkObject_new(st, nargs);
    if (p == NULL)
        return NULL;

    assert(CThunk_CheckExact(st, (PyObject *)p));

    p->pcl_write = Py_ffi_closure_alloc(sizeof(ffi_closure), &p->pcl_exec);
    if (p->pcl_write == NULL) {
        PyErr_NoMemory();
        goto error;
    }

    p->flags = flags;
    PyObject **cnvs = PySequence_Fast_ITEMS(converters);
    for (i = 0; i < nargs; ++i) {
        PyObject *cnv = cnvs[i]; // borrowed ref
        p->atypes[i] = _ctypes_get_ffi_type(st, cnv);
    }
    p->atypes[i] = NULL;

    p->restype = Py_NewRef(restype);
    if (restype == Py_None) {
        p->setfunc = NULL;
        p->ffi_restype = &ffi_type_void;
    } else {
        StgInfo *info;
        if (PyStgInfo_FromType(st, restype, &info) < 0) {
            goto error;
        }

        if (info == NULL || info->setfunc == NULL) {
          PyErr_SetString(PyExc_TypeError,
                          "invalid result type for callback function");
          goto error;
        }
        p->setfunc = info->setfunc;
        p->ffi_restype = &info->ffi_type_pointer;
    }

    cc = FFI_DEFAULT_ABI;
#if defined(MS_WIN32) && !defined(_WIN32_WCE) && !defined(MS_WIN64) && !defined(_M_ARM)
    if ((flags & FUNCFLAG_CDECL) == 0)
        cc = FFI_STDCALL;
#endif
    result = ffi_prep_cif(&p->cif, cc,
                          Py_SAFE_DOWNCAST(nargs, Py_ssize_t, int),
                          p->ffi_restype,
                          &p->atypes[0]);
    if (result != FFI_OK) {
        PyErr_Format(PyExc_RuntimeError,
                     "ffi_prep_cif failed with %d", result);
        goto error;
    }


#if HAVE_FFI_PREP_CLOSURE_LOC
#   ifdef USING_APPLE_OS_LIBFFI
#    ifdef HAVE_BUILTIN_AVAILABLE
#      define HAVE_FFI_PREP_CLOSURE_LOC_RUNTIME __builtin_available(macos 10.15, ios 13, watchos 6, tvos 13, *)
#    else
#      define HAVE_FFI_PREP_CLOSURE_LOC_RUNTIME (ffi_prep_closure_loc != NULL)
#    endif
#   else
#      define HAVE_FFI_PREP_CLOSURE_LOC_RUNTIME 1
#   endif
    if (HAVE_FFI_PREP_CLOSURE_LOC_RUNTIME) {
        result = ffi_prep_closure_loc(p->pcl_write, &p->cif, closure_fcn,
                                    p,
                                    p->pcl_exec);
    } else
#endif
    {
#if defined(USING_APPLE_OS_LIBFFI) && defined(__arm64__)
        PyErr_Format(PyExc_NotImplementedError, "ffi_prep_closure_loc() is missing");
        goto error;
#else
        // GH-85272, GH-23327, GH-100540: On macOS,
        // HAVE_FFI_PREP_CLOSURE_LOC_RUNTIME is checked at runtime because the
        // symbol might not be available at runtime when targeting macOS 10.14
        // or earlier. Even if ffi_prep_closure_loc() is called in practice,
        // the deprecated ffi_prep_closure() code path is needed if
        // HAVE_FFI_PREP_CLOSURE_LOC_RUNTIME is false.
        //
        // On non-macOS platforms, even if HAVE_FFI_PREP_CLOSURE_LOC_RUNTIME is
        // defined as 1 and ffi_prep_closure_loc() is used in practice, this
        // code path is still compiled and emits a compiler warning. The
        // deprecated code path is likely to be removed by a simple
        // optimization pass.
        //
        // Ignore the compiler warning on the ffi_prep_closure() deprecation,
        // rather than using complex #if/#else code paths for the different
        // platforms.
        _Py_COMP_DIAG_PUSH
        _Py_COMP_DIAG_IGNORE_DEPR_DECLS
        result = ffi_prep_closure(p->pcl_write, &p->cif, closure_fcn, p);
        _Py_COMP_DIAG_POP
#endif
    }

    if (result != FFI_OK) {
        PyErr_Format(PyExc_RuntimeError,
                     "ffi_prep_closure failed with %d", result);
        goto error;
    }

    p->converters = Py_NewRef(converters);
    p->callable = Py_NewRef(callable);
    return p;

  error:
    Py_XDECREF(p);
    return NULL;
}

#ifdef MS_WIN32

static void LoadPython(void)
{
    if (!Py_IsInitialized()) {
        Py_Initialize();
    }
}

/******************************************************************/

long Call_GetClassObject(REFCLSID rclsid, REFIID riid, LPVOID *ppv)
{
    PyObject *func, *result;
    long retval;
    static PyObject *context;

    if (context == NULL)
        context = PyUnicode_InternFromString("_ctypes.DllGetClassObject");

    func = _PyImport_GetModuleAttrString("ctypes", "DllGetClassObject");
    if (!func) {
        PyErr_WriteUnraisable(context ? context : Py_None);
        /* There has been a warning before about this already */
        return E_FAIL;
    }

    {
        PyObject *py_rclsid = PyLong_FromVoidPtr((void *)rclsid);
        if (py_rclsid == NULL) {
            Py_DECREF(func);
            PyErr_WriteUnraisable(context ? context : Py_None);
            return E_FAIL;
        }
        PyObject *py_riid = PyLong_FromVoidPtr((void *)riid);
        if (py_riid == NULL) {
            Py_DECREF(func);
            Py_DECREF(py_rclsid);
            PyErr_WriteUnraisable(context ? context : Py_None);
            return E_FAIL;
        }
        PyObject *py_ppv = PyLong_FromVoidPtr(ppv);
        if (py_ppv == NULL) {
            Py_DECREF(py_rclsid);
            Py_DECREF(py_riid);
            Py_DECREF(func);
            PyErr_WriteUnraisable(context ? context : Py_None);
            return E_FAIL;
        }
        result = PyObject_CallFunctionObjArgs(func,
                                              py_rclsid,
                                              py_riid,
                                              py_ppv,
                                              NULL);
        Py_DECREF(py_rclsid);
        Py_DECREF(py_riid);
        Py_DECREF(py_ppv);
    }
    Py_DECREF(func);
    if (!result) {
        PyErr_WriteUnraisable(context ? context : Py_None);
        return E_FAIL;
    }

    retval = PyLong_AsLong(result);
    if (PyErr_Occurred()) {
        PyErr_WriteUnraisable(context ? context : Py_None);
        retval = E_FAIL;
    }
    Py_DECREF(result);
    return retval;
}

STDAPI DllGetClassObject(REFCLSID rclsid,
                         REFIID riid,
                         LPVOID *ppv)
{
    long result;
    PyGILState_STATE state;

    LoadPython();
    state = PyGILState_Ensure();
    result = Call_GetClassObject(rclsid, riid, ppv);
    PyGILState_Release(state);
    return result;
}

long Call_CanUnloadNow(void)
{
    PyObject *mod, *func, *result;
    long retval;
    static PyObject *context;

    if (context == NULL)
        context = PyUnicode_InternFromString("_ctypes.DllCanUnloadNow");

    mod = PyImport_ImportModule("ctypes");
    if (!mod) {
/*              OutputDebugString("Could not import ctypes"); */
        /* We assume that this error can only occur when shutting
           down, so we silently ignore it */
        PyErr_Clear();
        return E_FAIL;
    }
    /* Other errors cannot be raised, but are printed to stderr */
    func = PyObject_GetAttrString(mod, "DllCanUnloadNow");
    Py_DECREF(mod);
    if (!func) {
        PyErr_WriteUnraisable(context ? context : Py_None);
        return E_FAIL;
    }

    result = _PyObject_CallNoArgs(func);
    Py_DECREF(func);
    if (!result) {
        PyErr_WriteUnraisable(context ? context : Py_None);
        return E_FAIL;
    }

    retval = PyLong_AsLong(result);
    if (PyErr_Occurred()) {
        PyErr_WriteUnraisable(context ? context : Py_None);
        retval = E_FAIL;
    }
    Py_DECREF(result);
    return retval;
}

/*
  DllRegisterServer and DllUnregisterServer still missing
*/

STDAPI DllCanUnloadNow(void)
{
    long result;
    PyGILState_STATE state = PyGILState_Ensure();
    result = Call_CanUnloadNow();
    PyGILState_Release(state);
    return result;
}

#ifndef Py_NO_ENABLE_SHARED
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvRes)
{
    switch(fdwReason) {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hinstDLL);
        break;
    }
    return TRUE;
}
#endif

#endif

/*
 Local Variables:
 compile-command: "cd .. && python setup.py -q build_ext"
 End:
*/


================================================
File: /Modules/_ctypes/cfield.c
================================================
#ifndef Py_BUILD_CORE_BUILTIN
#  define Py_BUILD_CORE_MODULE 1
#endif

#include "Python.h"
// windows.h must be included before pycore internal headers
#ifdef MS_WIN32
#  include <windows.h>
#endif

#include "pycore_bitutils.h"      // _Py_bswap32()
#include "pycore_call.h"          // _PyObject_CallNoArgs()
#include <stdbool.h>              // bool

#include <ffi.h>
#include "ctypes.h"

#if defined(Py_HAVE_C_COMPLEX) && defined(Py_FFI_SUPPORT_C_COMPLEX)
#  include "../_complex.h"        // complex
#endif

#define CTYPES_CFIELD_CAPSULE_NAME_PYMEM "_ctypes/cfield.c pymem"

/*[clinic input]
module _ctypes
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=476a19c49b31a75c]*/

#include "clinic/cfield.c.h"

static void pymem_destructor(PyObject *ptr)
{
    void *p = PyCapsule_GetPointer(ptr, CTYPES_CFIELD_CAPSULE_NAME_PYMEM);
    if (p) {
        PyMem_Free(p);
    }
}


/******************************************************************/
/*
  PyCField_Type
*/
/*[clinic input]
class _ctypes.CField "PyObject *" "PyObject"
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=602817ea3ffc709c]*/

static inline
Py_ssize_t NUM_BITS(Py_ssize_t bitsize);
static inline
Py_ssize_t LOW_BIT(Py_ssize_t offset);


/*[clinic input]
@classmethod
_ctypes.CField.__new__ as PyCField_new

    name: object(subclass_of='&PyUnicode_Type')
    type as proto: object
    size: Py_ssize_t
    offset: Py_ssize_t
    index: Py_ssize_t
    bit_size as bit_size_obj: object = None

[clinic start generated code]*/

static PyObject *
PyCField_new_impl(PyTypeObject *type, PyObject *name, PyObject *proto,
                  Py_ssize_t size, Py_ssize_t offset, Py_ssize_t index,
                  PyObject *bit_size_obj)
/*[clinic end generated code: output=43649ef9157c5f58 input=3d813f56373c4caa]*/
{
    CFieldObject* self = NULL;
    if (size < 0) {
        PyErr_Format(PyExc_ValueError,
                     "size of field %R must not be negative, got %zd",
                     name, size);
        goto error;
    }
    // assert: no overflow;
    if ((unsigned long long int) size
            >= (1ULL << (8*sizeof(Py_ssize_t)-1)) / 8) {
        PyErr_Format(PyExc_ValueError,
                     "size of field %R is too big: %zd", name, size);
        goto error;
    }

    PyTypeObject *tp = type;
    ctypes_state *st = get_module_state_by_class(tp);
    self = (CFieldObject *)tp->tp_alloc(tp, 0);
    if (!self) {
        return NULL;
    }
    if (PyUnicode_CheckExact(name)) {
        self->name = Py_NewRef(name);
    } else {
        self->name = PyObject_Str(name);
        if (!self->name) {
            goto error;
        }
    }

    StgInfo *info;
    if (PyStgInfo_FromType(st, proto, &info) < 0) {
        goto error;
    }
    if (info == NULL) {
        PyErr_Format(PyExc_TypeError,
                     "type of field %R must be a C type", self->name);
        goto error;
    }

    if (bit_size_obj != Py_None) {
#ifdef Py_DEBUG
        Py_ssize_t bit_size = NUM_BITS(size);
        assert(bit_size > 0);
        assert(bit_size <= info->size * 8);
        // Currently, the bit size is specified redundantly
        // in NUM_BITS(size) and bit_size_obj.
        // Verify that they match.
        assert(PyLong_AsSsize_t(bit_size_obj) == bit_size);
#endif
        switch(info->ffi_type_pointer.type) {
            case FFI_TYPE_UINT8:
            case FFI_TYPE_UINT16:
            case FFI_TYPE_UINT32:
            case FFI_TYPE_SINT64:
            case FFI_TYPE_UINT64:
                break;

            case FFI_TYPE_SINT8:
            case FFI_TYPE_SINT16:
            case FFI_TYPE_SINT32:
                if (info->getfunc != _ctypes_get_fielddesc("c")->getfunc
                    && info->getfunc != _ctypes_get_fielddesc("u")->getfunc)
                {
                    break;
                }
                _Py_FALLTHROUGH;  /* else fall through */
            default:
                PyErr_Format(PyExc_TypeError,
                             "bit fields not allowed for type %s",
                             ((PyTypeObject*)proto)->tp_name);
                goto error;
        }
    }

    self->proto = Py_NewRef(proto);
    self->size = size;
    self->offset = offset;

    self->index = index;

    /*  Field descriptors for 'c_char * n' are be special cased to
        return a Python string instead of an Array object instance...
    */
    self->setfunc = NULL;
    self->getfunc = NULL;
    if (PyCArrayTypeObject_Check(st, proto)) {
        StgInfo *ainfo;
        if (PyStgInfo_FromType(st, proto, &ainfo) < 0) {
            goto error;
        }

        if (ainfo && ainfo->proto) {
            StgInfo *iinfo;
            if (PyStgInfo_FromType(st, ainfo->proto, &iinfo) < 0) {
                goto error;
            }
            if (!iinfo) {
                PyErr_SetString(PyExc_TypeError,
                                "has no _stginfo_");
                goto error;
            }
            if (iinfo->getfunc == _ctypes_get_fielddesc("c")->getfunc) {
                struct fielddesc *fd = _ctypes_get_fielddesc("s");
                self->getfunc = fd->getfunc;
                self->setfunc = fd->setfunc;
            }
            if (iinfo->getfunc == _ctypes_get_fielddesc("u")->getfunc) {
                struct fielddesc *fd = _ctypes_get_fielddesc("U");
                self->getfunc = fd->getfunc;
                self->setfunc = fd->setfunc;
            }
        }
    }

    return (PyObject *)self;
error:
    Py_XDECREF(self);
    return NULL;
}


static int
PyCField_set(CFieldObject *self, PyObject *inst, PyObject *value)
{
    CDataObject *dst;
    char *ptr;
    ctypes_state *st = get_module_state_by_class(Py_TYPE(self));
    if (!CDataObject_Check(st, inst)) {
        PyErr_SetString(PyExc_TypeError,
                        "not a ctype instance");
        return -1;
    }
    dst = (CDataObject *)inst;
    ptr = dst->b_ptr + self->offset;
    if (value == NULL) {
        PyErr_SetString(PyExc_TypeError,
                        "can't delete attribute");
        return -1;
    }
    return PyCData_set(st, inst, self->proto, self->setfunc, value,
                     self->index, self->size, ptr);
}

static PyObject *
PyCField_get(CFieldObject *self, PyObject *inst, PyTypeObject *type)
{
    CDataObject *src;
    if (inst == NULL) {
        return Py_NewRef(self);
    }
    ctypes_state *st = get_module_state_by_class(Py_TYPE(self));
    if (!CDataObject_Check(st, inst)) {
        PyErr_SetString(PyExc_TypeError,
                        "not a ctype instance");
        return NULL;
    }
    src = (CDataObject *)inst;
    return PyCData_get(st, self->proto, self->getfunc, inst,
                     self->index, self->size, src->b_ptr + self->offset);
}

static PyObject *
PyCField_get_offset(PyObject *self, void *data)
{
    return PyLong_FromSsize_t(((CFieldObject *)self)->offset);
}

static PyObject *
PyCField_get_size(PyObject *self, void *data)
{
    return PyLong_FromSsize_t(((CFieldObject *)self)->size);
}

static PyGetSetDef PyCField_getset[] = {
    { "offset", PyCField_get_offset, NULL, PyDoc_STR("offset in bytes of this field") },
    { "size", PyCField_get_size, NULL, PyDoc_STR("size in bytes of this field") },
    { NULL, NULL, NULL, NULL },
};

static int
PyCField_traverse(CFieldObject *self, visitproc visit, void *arg)
{
    Py_VISIT(Py_TYPE(self));
    Py_VISIT(self->proto);
    return 0;
}

static int
PyCField_clear(CFieldObject *self)
{
    Py_CLEAR(self->proto);
    return 0;
}

static void
PyCField_dealloc(PyObject *self)
{
    PyTypeObject *tp = Py_TYPE(self);
    PyObject_GC_UnTrack(self);
    CFieldObject *self_cf = (CFieldObject *)self;
    (void)PyCField_clear(self_cf);
    Py_CLEAR(self_cf->name);
    Py_TYPE(self)->tp_free(self);
    Py_DECREF(tp);
}

static PyObject *
PyCField_repr(CFieldObject *self)
{
    PyObject *result;
    Py_ssize_t bits = NUM_BITS(self->size);
    Py_ssize_t size = LOW_BIT(self->size);
    const char *name;

    name = ((PyTypeObject *)self->proto)->tp_name;

    if (bits)
        result = PyUnicode_FromFormat(
            "<Field type=%s, ofs=%zd:%zd, bits=%zd>",
            name, self->offset, size, bits);
    else
        result = PyUnicode_FromFormat(
            "<Field type=%s, ofs=%zd, size=%zd>",
            name, self->offset, size);
    return result;
}

static PyType_Slot cfield_slots[] = {
    {Py_tp_new, PyCField_new},
    {Py_tp_dealloc, PyCField_dealloc},
    {Py_tp_repr, PyCField_repr},
    {Py_tp_doc, (void *)PyDoc_STR("Structure/Union member")},
    {Py_tp_traverse, PyCField_traverse},
    {Py_tp_clear, PyCField_clear},
    {Py_tp_getset, PyCField_getset},
    {Py_tp_descr_get, PyCField_get},
    {Py_tp_descr_set, PyCField_set},
    {0, NULL},
};

PyType_Spec cfield_spec = {
    .name = "_ctypes.CField",
    .basicsize = sizeof(CFieldObject),
    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
              Py_TPFLAGS_IMMUTABLETYPE),
    .slots = cfield_slots,
};


/*****************************************************************
 * Integer fields, with bitfield support
 */

/* how to decode the size field, for integer get/set functions */
static inline
Py_ssize_t LOW_BIT(Py_ssize_t offset) {
    return offset & 0xFFFF;
}
static inline
Py_ssize_t NUM_BITS(Py_ssize_t bitsize) {
    return bitsize >> 16;
}

/* Doesn't work if NUM_BITS(size) == 0, but it never happens in SET() call. */
#define BIT_MASK(type, size) (((((type)1 << (NUM_BITS(size) - 1)) - 1) << 1) + 1)

/* This macro CHANGES the first parameter IN PLACE. For proper sign handling,
   we must first shift left, then right.
*/
#define GET_BITFIELD(v, size)                                           \
    if (NUM_BITS(size)) {                                               \
        v <<= (sizeof(v)*8 - LOW_BIT(size) - NUM_BITS(size));           \
        v >>= (sizeof(v)*8 - NUM_BITS(size));                           \
    }

/* This macro RETURNS the first parameter with the bit field CHANGED. */
#define SET(type, x, v, size)                                                 \
    (NUM_BITS(size) ?                                                   \
     ( ( (type)(x) & ~(BIT_MASK(type, size) << LOW_BIT(size)) ) | ( ((type)(v) & BIT_MASK(type, size)) << LOW_BIT(size) ) ) \
     : (type)(v))

/*****************************************************************
 * The setter methods return an object which must be kept alive, to keep the
 * data valid which has been stored in the memory block.  The ctypes object
 * instance inserts this object into its 'b_objects' list.
 *
 * For simple Python types like integers or characters, there is nothing that
 * has to been kept alive, so Py_None is returned in these cases.  But this
 * makes inspecting the 'b_objects' list, which is accessible from Python for
 * debugging, less useful.
 *
 * So, defining the _CTYPES_DEBUG_KEEP symbol returns the original value
 * instead of Py_None.
 */

#ifdef _CTYPES_DEBUG_KEEP
#define _RET(x) Py_INCREF(x); return x
#else
#define _RET(X) Py_RETURN_NONE
#endif

/*****************************************************************
 * accessor methods for fixed-width integers (e.g. int8_t, uint64_t),
 * supporting bit fields.
 * These are named e.g. `i8_set`/`i8_get` or `u64_set`/`u64_get`,
 * and are all alike, so they're defined using a macro.
 */

#define FIXINT_GETSET(TAG, CTYPE, NBITS, PYAPI_FROMFUNC)                      \
    static PyObject *                                                         \
    TAG ## _set(void *ptr, PyObject *value, Py_ssize_t size_arg)              \
    {                                                                         \
        assert(NUM_BITS(size_arg) || (size_arg == (NBITS) / 8));              \
        CTYPE val;                                                            \
        if (PyLong_Check(value)                                               \
            && PyUnstable_Long_IsCompact((PyLongObject *)value))              \
        {                                                                     \
            val = (CTYPE)PyUnstable_Long_CompactValue(                        \
                      (PyLongObject *)value);                                 \
        }                                                                     \
        else {                                                                \
            Py_ssize_t res = PyLong_AsNativeBytes(                            \
                value, &val, (NBITS) / 8,                                     \
                Py_ASNATIVEBYTES_NATIVE_ENDIAN                                \
                | Py_ASNATIVEBYTES_ALLOW_INDEX);                              \
            if (res < 0) {                                                    \
                return NULL;                                                  \
            }                                                                 \
        }                                                                     \
        CTYPE prev;                                                           \
        memcpy(&prev, ptr, (NBITS) / 8);                                      \
        val = SET(CTYPE, prev, val, size_arg);                                \
        memcpy(ptr, &val, (NBITS) / 8);                                       \
        _RET(value);                                                          \
    }                                                                         \
                                                                              \
    static PyObject *                                                         \
    TAG ## _get(void *ptr, Py_ssize_t size_arg)                               \
    {                                                                         \
        assert(NUM_BITS(size_arg) || (size_arg == (NBITS) / 8));              \
        CTYPE val;                                                            \
        memcpy(&val, ptr, sizeof(val));                                       \
        GET_BITFIELD(val, size_arg);                                          \
        return PYAPI_FROMFUNC(val);                                           \
    }                                                                         \
    ///////////////////////////////////////////////////////////////////////////

/* Another macro for byte-swapped variants (e.g. `i8_set_sw`/`i8_get_sw`) */

#define FIXINT_GETSET_SW(TAG, CTYPE, NBITS, PYAPI_FROMFUNC, PY_SWAPFUNC)      \
    static PyObject *                                                         \
    TAG ## _set_sw(void *ptr, PyObject *value, Py_ssize_t size_arg)           \
    {                                                                         \
        CTYPE val;                                                            \
        PyObject *res = TAG ## _set(&val, value, (NBITS) / 8);                \
        if (res == NULL) {                                                    \
            return NULL;                                                      \
        }                                                                     \
        Py_DECREF(res);                                                       \
        CTYPE field;                                                          \
        memcpy(&field, ptr, sizeof(field));                                   \
        field = PY_SWAPFUNC(field);                                           \
        field = SET(CTYPE, field, val, size_arg);                             \
        field = PY_SWAPFUNC(field);                                           \
        memcpy(ptr, &field, sizeof(field));                                   \
        _RET(value);                                                          \
    }                                                                         \
                                                                              \
    static PyObject *                                                         \
    TAG ## _get_sw(void *ptr, Py_ssize_t size_arg)                            \
    {                                                                         \
        assert(NUM_BITS(size_arg) || (size_arg == (NBITS) / 8));              \
        CTYPE val;                                                            \
        memcpy(&val, ptr, sizeof(val));                                       \
        val = PY_SWAPFUNC(val);                                               \
        GET_BITFIELD(val, size_arg);                                          \
        return PYAPI_FROMFUNC(val);                                           \
    }                                                                         \
    ///////////////////////////////////////////////////////////////////////////

/* These macros are expanded for all supported combinations of byte sizes
 * (1, 2, 4, 8), signed and unsigned, native and swapped byteorder.
 * That's a lot, so generate the list with Argument Clinic (`make clinic`).
 */

/*[python input]
for nbits in 8, 16, 32, 64:
    for sgn in 'i', 'u':
        u = 'u' if sgn == 'u' else ''
        U = u.upper()
        apibits = max(nbits, 32)
        parts = [
            f'{sgn}{nbits}',
            f'{u}int{nbits}_t',
            f'{nbits}',
            f'PyLong_From{U}Int{apibits}',
        ]
        print(f'FIXINT_GETSET({", ".join(parts)})')
        if nbits > 8:
            parts.append(f'_Py_bswap{nbits}')
            print(f'FIXINT_GETSET_SW({", ".join(parts)})')
[python start generated code]*/
FIXINT_GETSET(i8, int8_t, 8, PyLong_FromInt32)
FIXINT_GETSET(u8, uint8_t, 8, PyLong_FromUInt32)
FIXINT_GETSET(i16, int16_t, 16, PyLong_FromInt32)
FIXINT_GETSET_SW(i16, int16_t, 16, PyLong_FromInt32, _Py_bswap16)
FIXINT_GETSET(u16, uint16_t, 16, PyLong_FromUInt32)
FIXINT_GETSET_SW(u16, uint16_t, 16, PyLong_FromUInt32, _Py_bswap16)
FIXINT_GETSET(i32, int32_t, 32, PyLong_FromInt32)
FIXINT_GETSET_SW(i32, int32_t, 32, PyLong_FromInt32, _Py_bswap32)
FIXINT_GETSET(u32, uint32_t, 32, PyLong_FromUInt32)
FIXINT_GETSET_SW(u32, uint32_t, 32, PyLong_FromUInt32, _Py_bswap32)
FIXINT_GETSET(i64, int64_t, 64, PyLong_FromInt64)
FIXINT_GETSET_SW(i64, int64_t, 64, PyLong_FromInt64, _Py_bswap64)
FIXINT_GETSET(u64, uint64_t, 64, PyLong_FromUInt64)
FIXINT_GETSET_SW(u64, uint64_t, 64, PyLong_FromUInt64, _Py_bswap64)
/*[python end generated code: output=3d60c96fa58e07d5 input=0b7e166f2ea18e70]*/

// For one-byte types, swapped variants are the same as native
#define i8_set_sw i8_set
#define i8_get_sw i8_get
#define u8_set_sw u8_set
#define u8_get_sw u8_get

#undef FIXINT_GETSET
#undef FIXINT_GETSET_SW

/*****************************************************************
 * non-integer accessor methods, not supporting bit fields
 */

#ifndef MS_WIN32
/* http://msdn.microsoft.com/en-us/library/cc237864.aspx */
#define VARIANT_FALSE 0x0000
#define VARIANT_TRUE 0xFFFF
#endif
/* v: short BOOL - VARIANT_BOOL */
static PyObject *
v_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(short int)));
    switch (PyObject_IsTrue(value)) {
    case -1:
        return NULL;
    case 0:
        *(short int *)ptr = VARIANT_FALSE;
        _RET(value);
    default:
        *(short int *)ptr = VARIANT_TRUE;
        _RET(value);
    }
}

static PyObject *
v_get(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(short int)));
    return PyBool_FromLong((long)*(short int *)ptr);
}

/* bool ('?'): bool (i.e. _Bool) */
static PyObject *
bool_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(bool)));
    switch (PyObject_IsTrue(value)) {
    case -1:
        return NULL;
    case 0:
        *(bool *)ptr = 0;
        _RET(value);
    default:
        *(bool *)ptr = 1;
        _RET(value);
    }
}

static PyObject *
bool_get(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(bool)));
    return PyBool_FromLong((long)*(bool *)ptr);
}

/* g: long double */
static PyObject *
g_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(long double)));
    long double x;

    x = PyFloat_AsDouble(value);
    if (x == -1 && PyErr_Occurred())
        return NULL;
    memcpy(ptr, &x, sizeof(long double));
    _RET(value);
}

static PyObject *
g_get(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(long double)));
    long double val;
    memcpy(&val, ptr, sizeof(long double));
    return PyFloat_FromDouble(val);
}

/* d: double */
static PyObject *
d_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(double)));
    double x;

    x = PyFloat_AsDouble(value);
    if (x == -1 && PyErr_Occurred())
        return NULL;
    memcpy(ptr, &x, sizeof(double));
    _RET(value);
}

static PyObject *
d_get(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(double)));
    double val;
    memcpy(&val, ptr, sizeof(val));
    return PyFloat_FromDouble(val);
}

#if defined(Py_HAVE_C_COMPLEX) && defined(Py_FFI_SUPPORT_C_COMPLEX)
/* C: double complex */
static PyObject *
C_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(double complex)));
    Py_complex c = PyComplex_AsCComplex(value);

    if (c.real == -1 && PyErr_Occurred()) {
        return NULL;
    }
    double complex x = CMPLX(c.real, c.imag);
    memcpy(ptr, &x, sizeof(x));
    _RET(value);
}

static PyObject *
C_get(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(double complex)));
    double complex x;

    memcpy(&x, ptr, sizeof(x));
    return PyComplex_FromDoubles(creal(x), cimag(x));
}

/* E: float complex */
static PyObject *
E_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(float complex)));
    Py_complex c = PyComplex_AsCComplex(value);

    if (c.real == -1 && PyErr_Occurred()) {
        return NULL;
    }
    float complex x = CMPLXF((float)c.real, (float)c.imag);
    memcpy(ptr, &x, sizeof(x));
    _RET(value);
}

static PyObject *
E_get(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(float complex)));
    float complex x;

    memcpy(&x, ptr, sizeof(x));
    return PyComplex_FromDoubles(crealf(x), cimagf(x));
}

/* F: long double complex */
static PyObject *
F_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(long double complex)));
    Py_complex c = PyComplex_AsCComplex(value);

    if (c.real == -1 && PyErr_Occurred()) {
        return NULL;
    }
    long double complex x = CMPLXL(c.real, c.imag);
    memcpy(ptr, &x, sizeof(x));
    _RET(value);
}

static PyObject *
F_get(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(long double complex)));
    long double complex x;

    memcpy(&x, ptr, sizeof(x));
    return PyComplex_FromDoubles((double)creall(x), (double)cimagl(x));
}
#endif

/* d: double */
static PyObject *
d_set_sw(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(double)));
    double x;

    x = PyFloat_AsDouble(value);
    if (x == -1 && PyErr_Occurred())
        return NULL;
#ifdef WORDS_BIGENDIAN
    if (PyFloat_Pack8(x, ptr, 1))
        return NULL;
#else
    if (PyFloat_Pack8(x, ptr, 0))
        return NULL;
#endif
    _RET(value);
}

static PyObject *
d_get_sw(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(double)));
#ifdef WORDS_BIGENDIAN
    return PyFloat_FromDouble(PyFloat_Unpack8(ptr, 1));
#else
    return PyFloat_FromDouble(PyFloat_Unpack8(ptr, 0));
#endif
}

/* f: float */
static PyObject *
f_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(float)));
    float x;

    x = (float)PyFloat_AsDouble(value);
    if (x == -1 && PyErr_Occurred())
        return NULL;
    memcpy(ptr, &x, sizeof(x));
    _RET(value);
}

static PyObject *
f_get(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(float)));
    float val;
    memcpy(&val, ptr, sizeof(val));
    return PyFloat_FromDouble(val);
}

static PyObject *
f_set_sw(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(float)));
    float x;

    x = (float)PyFloat_AsDouble(value);
    if (x == -1 && PyErr_Occurred())
        return NULL;
#ifdef WORDS_BIGENDIAN
    if (PyFloat_Pack4(x, ptr, 1))
        return NULL;
#else
    if (PyFloat_Pack4(x, ptr, 0))
        return NULL;
#endif
    _RET(value);
}

static PyObject *
f_get_sw(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(float)));
#ifdef WORDS_BIGENDIAN
    return PyFloat_FromDouble(PyFloat_Unpack4(ptr, 1));
#else
    return PyFloat_FromDouble(PyFloat_Unpack4(ptr, 0));
#endif
}

/* O: Python object */
/*
  py_object refcounts:

  1. If we have a py_object instance, O_get must Py_INCREF the returned
  object, of course.  If O_get is called from a function result, no py_object
  instance is created - so callproc.c::GetResult has to call Py_DECREF.

  2. The memory block in py_object owns a refcount.  So, py_object must call
  Py_DECREF on destruction.  Maybe only when b_needsfree is non-zero.
*/
static PyObject *
O_get(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(PyObject *)));
    PyObject *ob = *(PyObject **)ptr;
    if (ob == NULL) {
        if (!PyErr_Occurred())
            /* Set an error if not yet set */
            PyErr_SetString(PyExc_ValueError,
                            "PyObject is NULL");
        return NULL;
    }
    return Py_NewRef(ob);
}

static PyObject *
O_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(PyObject *)));
    /* Hm, does the memory block need it's own refcount or not? */
    *(PyObject **)ptr = value;
    return Py_NewRef(value);
}


/* c: a single byte-character */
static PyObject *
c_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(char)));
    if (PyBytes_Check(value)) {
        if (PyBytes_GET_SIZE(value) != 1) {
            PyErr_Format(PyExc_TypeError,
                        "one character bytes, bytearray, or an integer "
                        "in range(256) expected, not bytes of length %zd",
                        PyBytes_GET_SIZE(value));
            return NULL;
        }
        *(char *)ptr = PyBytes_AS_STRING(value)[0];
        _RET(value);
    }
    if (PyByteArray_Check(value)) {
        if (PyByteArray_GET_SIZE(value) != 1) {
            PyErr_Format(PyExc_TypeError,
                        "one character bytes, bytearray, or an integer "
                        "in range(256) expected, not bytearray of length %zd",
                        PyByteArray_GET_SIZE(value));
            return NULL;
        }
        *(char *)ptr = PyByteArray_AS_STRING(value)[0];
        _RET(value);
    }
    if (PyLong_Check(value)) {
        int overflow;
        long longval = PyLong_AsLongAndOverflow(value, &overflow);
        if (longval == -1 && PyErr_Occurred()) {
            return NULL;
        }
        if (overflow || longval < 0 || longval >= 256) {
            PyErr_SetString(PyExc_TypeError, "integer not in range(256)");
            return NULL;
        }
        *(char *)ptr = (char)longval;
        _RET(value);
    }
    PyErr_Format(PyExc_TypeError,
                 "one character bytes, bytearray, or an integer "
                 "in range(256) expected, not %T",
                 value);
    return NULL;
}


static PyObject *
c_get(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(char)));
    return PyBytes_FromStringAndSize((char *)ptr, 1);
}

/* u: a single wchar_t character */
static PyObject *
u_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(wchar_t)));
    Py_ssize_t len;
    wchar_t chars[2];
    if (!PyUnicode_Check(value)) {
        PyErr_Format(PyExc_TypeError,
                     "a unicode character expected, not instance of %T",
                     value);
        return NULL;
    }

    len = PyUnicode_AsWideChar(value, chars, 2);
    if (len != 1) {
        if (PyUnicode_GET_LENGTH(value) != 1) {
            PyErr_Format(PyExc_TypeError,
                         "a unicode character expected, not a string of length %zd",
                         PyUnicode_GET_LENGTH(value));
        }
        else {
            PyErr_Format(PyExc_TypeError,
                         "the string %A cannot be converted to a single wchar_t character",
                         value);
        }
        return NULL;
    }

    *(wchar_t *)ptr = chars[0];

    _RET(value);
}


static PyObject *
u_get(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(wchar_t)));
    return PyUnicode_FromWideChar((wchar_t *)ptr, 1);
}

/* U: a wchar_t* unicode string */
static PyObject *
U_get(void *ptr, Py_ssize_t size)
{
    Py_ssize_t len;
    wchar_t *p;

    size /= sizeof(wchar_t); /* we count character units here, not bytes */

    /* We need 'result' to be able to count the characters with wcslen,
       since ptr may not be NUL terminated.  If the length is smaller (if
       it was actually NUL terminated, we construct a new one and throw
       away the result.
    */
    /* chop off at the first NUL character, if any. */
    p = (wchar_t*)ptr;
    for (len = 0; len < size; ++len) {
        if (!p[len])
            break;
    }

    return PyUnicode_FromWideChar((wchar_t *)ptr, len);
}

static PyObject *
U_set(void *ptr, PyObject *value, Py_ssize_t length)
{
    /* It's easier to calculate in characters than in bytes */
    length /= sizeof(wchar_t);

    if (!PyUnicode_Check(value)) {
        PyErr_Format(PyExc_TypeError,
                        "unicode string expected instead of %s instance",
                        Py_TYPE(value)->tp_name);
        return NULL;
    }

    Py_ssize_t size = PyUnicode_AsWideChar(value, NULL, 0);
    if (size < 0) {
        return NULL;
    }
    // PyUnicode_AsWideChar() returns number of wchars including trailing null byte,
    // when it is called with NULL.
    size--;
    assert(size >= 0);
    if (size > length) {
        PyErr_Format(PyExc_ValueError,
                     "string too long (%zd, maximum length %zd)",
                     size, length);
        return NULL;
    }
    if (PyUnicode_AsWideChar(value, (wchar_t *)ptr, length) == -1) {
        return NULL;
    }

    return Py_NewRef(value);
}


/* s: a byte string */
static PyObject *
s_get(void *ptr, Py_ssize_t size)
{
    Py_ssize_t i;
    char *p;

    p = (char *)ptr;
    for (i = 0; i < size; ++i) {
        if (*p++ == '\0')
            break;
    }

    return PyBytes_FromStringAndSize((char *)ptr, (Py_ssize_t)i);
}

static PyObject *
s_set(void *ptr, PyObject *value, Py_ssize_t length)
{
    const char *data;
    Py_ssize_t size;

    if(!PyBytes_Check(value)) {
        PyErr_Format(PyExc_TypeError,
                     "expected bytes, %s found",
                     Py_TYPE(value)->tp_name);
        return NULL;
    }

    data = PyBytes_AS_STRING(value);
    // bpo-39593: Use strlen() to truncate the string at the first null character.
    size = strlen(data);

    if (size < length) {
        /* This will copy the terminating NUL character
         * if there is space for it.
         */
        ++size;
    } else if (size > length) {
        PyErr_Format(PyExc_ValueError,
                     "bytes too long (%zd, maximum length %zd)",
                     size, length);
        return NULL;
    }
    /* Also copy the terminating NUL character if there is space */
    memcpy((char *)ptr, data, size);

    _RET(value);
}

/* z: a byte string, can be set from integer pointer */
static PyObject *
z_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    if (value == Py_None) {
        *(char **)ptr = NULL;
        return Py_NewRef(value);
    }
    if (PyBytes_Check(value)) {
        *(const char **)ptr = PyBytes_AsString(value);
        return Py_NewRef(value);
    } else if (PyLong_Check(value)) {
#if SIZEOF_VOID_P == SIZEOF_LONG_LONG
        *(char **)ptr = (char *)PyLong_AsUnsignedLongLongMask(value);
#else
        *(char **)ptr = (char *)PyLong_AsUnsignedLongMask(value);
#endif
        _RET(value);
    }
    PyErr_Format(PyExc_TypeError,
                 "bytes or integer address expected instead of %s instance",
                 Py_TYPE(value)->tp_name);
    return NULL;
}

static PyObject *
z_get(void *ptr, Py_ssize_t size)
{
    /* XXX What about invalid pointers ??? */
    if (*(void **)ptr) {
        return PyBytes_FromStringAndSize(*(char **)ptr,
                                         strlen(*(char **)ptr));
    } else {
        Py_RETURN_NONE;
    }
}

/* Z: a wchar* string, can be set from integer pointer */
static PyObject *
Z_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    PyObject *keep;
    wchar_t *buffer;
    Py_ssize_t bsize;

    if (value == Py_None) {
        *(wchar_t **)ptr = NULL;
        return Py_NewRef(value);
    }
    if (PyLong_Check(value)) {
#if SIZEOF_VOID_P == SIZEOF_LONG_LONG
        *(wchar_t **)ptr = (wchar_t *)PyLong_AsUnsignedLongLongMask(value);
#else
        *(wchar_t **)ptr = (wchar_t *)PyLong_AsUnsignedLongMask(value);
#endif
        Py_RETURN_NONE;
    }
    if (!PyUnicode_Check(value)) {
        PyErr_Format(PyExc_TypeError,
                     "unicode string or integer address expected instead of %s instance",
                     Py_TYPE(value)->tp_name);
        return NULL;
    }

    /* We must create a wchar_t* buffer from the unicode object,
       and keep it alive */
    buffer = PyUnicode_AsWideCharString(value, &bsize);
    if (!buffer)
        return NULL;
    keep = PyCapsule_New(buffer, CTYPES_CFIELD_CAPSULE_NAME_PYMEM, pymem_destructor);
    if (!keep) {
        PyMem_Free(buffer);
        return NULL;
    }
    *(wchar_t **)ptr = buffer;
    return keep;
}

static PyObject *
Z_get(void *ptr, Py_ssize_t size)
{
    wchar_t *p;
    p = *(wchar_t **)ptr;
    if (p) {
        return PyUnicode_FromWideChar(p, wcslen(p));
    } else {
        Py_RETURN_NONE;
    }
}


#ifdef MS_WIN32
/* X: COM BSTR (wide-char string to be handled handled using Windows API) */
static PyObject *
X_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    BSTR bstr;

    /* convert value into a PyUnicodeObject or NULL */
    if (Py_None == value) {
        value = NULL;
    } else if (!PyUnicode_Check(value)) {
        PyErr_Format(PyExc_TypeError,
                        "unicode string expected instead of %s instance",
                        Py_TYPE(value)->tp_name);
        return NULL;
    }

    /* create a BSTR from value */
    if (value) {
        Py_ssize_t wsize;
        wchar_t *wvalue = PyUnicode_AsWideCharString(value, &wsize);
        if (wvalue == NULL) {
            return NULL;
        }
        if ((unsigned) wsize != wsize) {
            PyErr_SetString(PyExc_ValueError, "String too long for BSTR");
            PyMem_Free(wvalue);
            return NULL;
        }
        bstr = SysAllocStringLen(wvalue, (unsigned)wsize);
        PyMem_Free(wvalue);
    } else
        bstr = NULL;

    /* free the previous contents, if any */
    if (*(BSTR *)ptr)
        SysFreeString(*(BSTR *)ptr);

    /* and store it */
    *(BSTR *)ptr = bstr;

    /* We don't need to keep any other object */
    _RET(value);
}


static PyObject *
X_get(void *ptr, Py_ssize_t size)
{
    BSTR p;
    p = *(BSTR *)ptr;
    if (p)
        return PyUnicode_FromWideChar(p, SysStringLen(p));
    else {
        /* Hm, it seems NULL pointer and zero length string are the
           same in BSTR, see Don Box, p 81
        */
        Py_RETURN_NONE;
    }
}
#endif

/* P: generic pointer */
static PyObject *
P_set(void *ptr, PyObject *value, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(void *)));
    void *v;
    if (value == Py_None) {
        *(void **)ptr = NULL;
        _RET(value);
    }

    if (!PyLong_Check(value)) {
        PyErr_SetString(PyExc_TypeError,
                        "cannot be converted to pointer");
        return NULL;
    }

#if SIZEOF_VOID_P <= SIZEOF_LONG
    v = (void *)PyLong_AsUnsignedLongMask(value);
#else
#if SIZEOF_LONG_LONG < SIZEOF_VOID_P
#   error "PyLong_AsVoidPtr: sizeof(long long) < sizeof(void*)"
#endif
    v = (void *)PyLong_AsUnsignedLongLongMask(value);
#endif

    if (PyErr_Occurred())
        return NULL;

    *(void **)ptr = v;
    _RET(value);
}

static PyObject *
P_get(void *ptr, Py_ssize_t size)
{
    assert(NUM_BITS(size) || (size == sizeof(void *)));
    if (*(void **)ptr == NULL) {
        Py_RETURN_NONE;
    }
    return PyLong_FromVoidPtr(*(void **)ptr);
}

/* Table with info about all formats.
 * Must be accessed via _ctypes_get_fielddesc, which initializes it on
 * first use. After initialization it's treated as constant & read-only.
 */

struct formattable {
/*[python input]
for nbytes in 8, 16, 32, 64:
    for sgn in 'i', 'u':
        print(f'    struct fielddesc fmt_{sgn}{nbytes};')
for code in 'sbBcdCEFgfhHiIlLqQPzuUZXvO':
    print(f'    struct fielddesc fmt_{code};')
[python start generated code]*/
    struct fielddesc fmt_i8;
    struct fielddesc fmt_u8;
    struct fielddesc fmt_i16;
    struct fielddesc fmt_u16;
    struct fielddesc fmt_i32;
    struct fielddesc fmt_u32;
    struct fielddesc fmt_i64;
    struct fielddesc fmt_u64;
    struct fielddesc fmt_s;
    struct fielddesc fmt_b;
    struct fielddesc fmt_B;
    struct fielddesc fmt_c;
    struct fielddesc fmt_d;
    struct fielddesc fmt_C;
    struct fielddesc fmt_E;
    struct fielddesc fmt_F;
    struct fielddesc fmt_g;
    struct fielddesc fmt_f;
    struct fielddesc fmt_h;
    struct fielddesc fmt_H;
    struct fielddesc fmt_i;
    struct fielddesc fmt_I;
    struct fielddesc fmt_l;
    struct fielddesc fmt_L;
    struct fielddesc fmt_q;
    struct fielddesc fmt_Q;
    struct fielddesc fmt_P;
    struct fielddesc fmt_z;
    struct fielddesc fmt_u;
    struct fielddesc fmt_U;
    struct fielddesc fmt_Z;
    struct fielddesc fmt_X;
    struct fielddesc fmt_v;
    struct fielddesc fmt_O;
/*[python end generated code: output=fa648744ec7f919d input=087d58357d4bf2c5]*/

    // bool has code '?':
    struct fielddesc fmt_bool;

    // always contains NULLs:
    struct fielddesc fmt_nil;
};

static struct formattable formattable;


/* Get fielddesc info for a fixed-width integer.
 * N.B: - must be called after (or from) _ctypes_init_fielddesc!
 *      - nbytes must be one of the supported values
 */

static inline struct fielddesc *
_ctypes_fixint_fielddesc(Py_ssize_t nbytes, bool is_signed)
{
#define _PACK(NBYTES, SGN) ((NBYTES<<2) + (SGN ? 1 : 0))
    switch (_PACK(nbytes, is_signed)) {
/*[python input]
for nbytes in 8, 16, 32, 64:
    for sgn in 'i', 'u':
        is_signed = sgn == 'i'
        print(f'    case (_PACK({nbytes // 8}, {int(is_signed)})): '
              + f'return &formattable.fmt_{sgn}{nbytes};')
[python start generated code]*/
    case (_PACK(1, 1)): return &formattable.fmt_i8;
    case (_PACK(1, 0)): return &formattable.fmt_u8;
    case (_PACK(2, 1)): return &formattable.fmt_i16;
    case (_PACK(2, 0)): return &formattable.fmt_u16;
    case (_PACK(4, 1)): return &formattable.fmt_i32;
    case (_PACK(4, 0)): return &formattable.fmt_u32;
    case (_PACK(8, 1)): return &formattable.fmt_i64;
    case (_PACK(8, 0)): return &formattable.fmt_u64;
/*[python end generated code: output=0194ba35c4d64ff3 input=ee9f6f5bb872d645]*/
#undef _PACK
    }
    /* ctypes currently only supports platforms where the basic integer types
     * (`char`, `short`, `int`, `long`, `long long`) have 1, 2, 4, or 8 bytes
     * (i.e. 8 to 64 bits).
     */
    Py_UNREACHABLE();
}


/* Macro to call _ctypes_fixint_fielddesc for a given C type. */

_Py_COMP_DIAG_PUSH
#if defined(__GNUC__) && (__GNUC__ < 14)
/* The signedness check expands to an expression that's always true or false.
 * Older GCC gives a '-Wtype-limits' warning for this, which is a GCC bug
 * (docs say it should "not warn for constant expressions"):
 *      https://gcc.gnu.org/bugzilla/show_bug.cgi?id=86647
 * Silence that warning.
 */
#pragma GCC diagnostic ignored "-Wtype-limits"
#endif

#define FIXINT_FIELDDESC_FOR(C_TYPE) \
    _ctypes_fixint_fielddesc(sizeof(C_TYPE), (C_TYPE)-1 < 0)


/* Delayed initialization. Windows cannot statically reference dynamically
   loaded addresses from DLLs. */
void
_ctypes_init_fielddesc(void)
{
    /* Fixed-width integers */

/*[python input]
for nbytes in 8, 16, 32, 64:
    for sgn in 'i', 'u':
        is_signed = sgn == 'i'
        u = 'u' if sgn == 'u' else 's'
        parts = [
            f"0",
            f'&ffi_type_{u}int{nbytes}',
            f'{sgn}{nbytes}_set',
            f'{sgn}{nbytes}_get',
            f'{sgn}{nbytes}_set_sw',
            f'{sgn}{nbytes}_get_sw',
        ]
        print(f'    formattable.fmt_{sgn}{nbytes} = (struct fielddesc){{')
        print(f'            {', '.join(parts)} }};')
[python start generated code]*/
    formattable.fmt_i8 = (struct fielddesc){
            0, &ffi_type_sint8, i8_set, i8_get, i8_set_sw, i8_get_sw };
    formattable.fmt_u8 = (struct fielddesc){
            0, &ffi_type_uint8, u8_set, u8_get, u8_set_sw, u8_get_sw };
    formattable.fmt_i16 = (struct fielddesc){
            0, &ffi_type_sint16, i16_set, i16_get, i16_set_sw, i16_get_sw };
    formattable.fmt_u16 = (struct fielddesc){
            0, &ffi_type_uint16, u16_set, u16_get, u16_set_sw, u16_get_sw };
    formattable.fmt_i32 = (struct fielddesc){
            0, &ffi_type_sint32, i32_set, i32_get, i32_set_sw, i32_get_sw };
    formattable.fmt_u32 = (struct fielddesc){
            0, &ffi_type_uint32, u32_set, u32_get, u32_set_sw, u32_get_sw };
    formattable.fmt_i64 = (struct fielddesc){
            0, &ffi_type_sint64, i64_set, i64_get, i64_set_sw, i64_get_sw };
    formattable.fmt_u64 = (struct fielddesc){
            0, &ffi_type_uint64, u64_set, u64_get, u64_set_sw, u64_get_sw };
/*[python end generated code: output=16806fe0ca3a9c4c input=850b8dd6388b1b10]*/


    /* Native C integers.
     * These use getters/setters for fixed-width ints but have their own
     * `code` and `pffi_type`.
     */

/*[python input]
for base_code, base_c_type in [
    ('b', 'char'),
    ('h', 'short'),
    ('i', 'int'),
    ('l', 'long'),
    ('q', 'long long'),
]:
    for code, c_type, ffi_type in [
        (base_code, 'signed ' + base_c_type, 's' + base_c_type),
        (base_code.upper(), 'unsigned ' + base_c_type, 'u' + base_c_type),
    ]:
        print(f'    formattable.fmt_{code} = *FIXINT_FIELDDESC_FOR({c_type});')
        print(f"    formattable.fmt_{code}.code = '{code}';")
        if base_code == 'q':
            # ffi doesn't have `long long`; keep use the fixint type
            pass
        else:
            print(f'    formattable.fmt_{code}.pffi_type = &ffi_type_{ffi_type};')
[python start generated code]*/
    formattable.fmt_b = *FIXINT_FIELDDESC_FOR(signed char);
    formattable.fmt_b.code = 'b';
    formattable.fmt_b.pffi_type = &ffi_type_schar;
    formattable.fmt_B = *FIXINT_FIELDDESC_FOR(unsigned char);
    formattable.fmt_B.code = 'B';
    formattable.fmt_B.pffi_type = &ffi_type_uchar;
    formattable.fmt_h = *FIXINT_FIELDDESC_FOR(signed short);
    formattable.fmt_h.code = 'h';
    formattable.fmt_h.pffi_type = &ffi_type_sshort;
    formattable.fmt_H = *FIXINT_FIELDDESC_FOR(unsigned short);
    formattable.fmt_H.code = 'H';
    formattable.fmt_H.pffi_type = &ffi_type_ushort;
    formattable.fmt_i = *FIXINT_FIELDDESC_FOR(signed int);
    formattable.fmt_i.code = 'i';
    formattable.fmt_i.pffi_type = &ffi_type_sint;
    formattable.fmt_I = *FIXINT_FIELDDESC_FOR(unsigned int);
    formattable.fmt_I.code = 'I';
    formattable.fmt_I.pffi_type = &ffi_type_uint;
    formattable.fmt_l = *FIXINT_FIELDDESC_FOR(signed long);
    formattable.fmt_l.code = 'l';
    formattable.fmt_l.pffi_type = &ffi_type_slong;
    formattable.fmt_L = *FIXINT_FIELDDESC_FOR(unsigned long);
    formattable.fmt_L.code = 'L';
    formattable.fmt_L.pffi_type = &ffi_type_ulong;
    formattable.fmt_q = *FIXINT_FIELDDESC_FOR(signed long long);
    formattable.fmt_q.code = 'q';
    formattable.fmt_Q = *FIXINT_FIELDDESC_FOR(unsigned long long);
    formattable.fmt_Q.code = 'Q';
/*[python end generated code: output=873c87a2e6b5075a input=ee814ca263aac18e]*/


    /* Other types have bespoke setters and getters named `@_set` and `@_get`,
     * where `@` is the type code.
     * Some have swapped variants, `@_set_sw` and `@_get_sw`
     */

#define _TABLE_ENTRY(SYMBOL, FFI_TYPE, ...)                                   \
    formattable.fmt_ ## SYMBOL =                                              \
        (struct fielddesc){(#SYMBOL)[0], (FFI_TYPE), __VA_ARGS__};            \
    ///////////////////////////////////////////////////////////////////////////

#define TABLE_ENTRY(SYMBOL, FFI_TYPE)                                         \
    _TABLE_ENTRY(SYMBOL, FFI_TYPE, SYMBOL ## _set, SYMBOL ## _get)            \
    ///////////////////////////////////////////////////////////////////////////

#define TABLE_ENTRY_SW(SYMBOL, FFI_TYPE)                                      \
    _TABLE_ENTRY(SYMBOL, FFI_TYPE, SYMBOL ## _set,                            \
        SYMBOL ## _get, SYMBOL ## _set_sw, SYMBOL ## _get_sw)                 \
    ///////////////////////////////////////////////////////////////////////////

    TABLE_ENTRY_SW(d, &ffi_type_double);
#if defined(Py_HAVE_C_COMPLEX) && defined(Py_FFI_SUPPORT_C_COMPLEX)
    TABLE_ENTRY(C, &ffi_type_complex_double);
    TABLE_ENTRY(E, &ffi_type_complex_float);
    TABLE_ENTRY(F, &ffi_type_complex_longdouble);
#endif
    TABLE_ENTRY(g, &ffi_type_longdouble);
    TABLE_ENTRY_SW(f, &ffi_type_float);
    TABLE_ENTRY(v, &ffi_type_sshort);    /* vBOOL */

    // ctypes.c_char is signed for FFI, even where C wchar_t is unsigned.
    TABLE_ENTRY(c, _ctypes_fixint_fielddesc(sizeof(char), true)->pffi_type);
    // ctypes.c_wchar is signed for FFI, even where C wchar_t is unsigned.
    TABLE_ENTRY(u, _ctypes_fixint_fielddesc(sizeof(wchar_t), true)->pffi_type);

    TABLE_ENTRY(s, &ffi_type_pointer);
    TABLE_ENTRY(P, &ffi_type_pointer);
    TABLE_ENTRY(z, &ffi_type_pointer);
    TABLE_ENTRY(U, &ffi_type_pointer);
    TABLE_ENTRY(Z, &ffi_type_pointer);
#ifdef MS_WIN32
    TABLE_ENTRY(X, &ffi_type_pointer);
#endif
    TABLE_ENTRY(O, &ffi_type_pointer);

#undef TABLE_ENTRY_SW
#undef TABLE_ENTRY
#undef _TABLE_ENTRY

    /* bool has code '?', fill it in manually */

    // ctypes.c_bool is unsigned for FFI, even where C bool is signed.
    formattable.fmt_bool = *_ctypes_fixint_fielddesc(sizeof(bool), false);
    formattable.fmt_bool.code = '?';
    formattable.fmt_bool.setfunc = bool_set;
    formattable.fmt_bool.getfunc = bool_get;
}
#undef FIXINT_FIELDDESC_FOR
_Py_COMP_DIAG_POP

struct fielddesc *
_ctypes_get_fielddesc(const char *fmt)
{
    static bool initialized = false;
    static PyMutex mutex = {0};
    PyMutex_Lock(&mutex);
    if (!initialized) {
        _ctypes_init_fielddesc();
        initialized = true;
    }
    PyMutex_Unlock(&mutex);
    struct fielddesc *result = NULL;
    switch(fmt[0]) {
/*[python input]
for code in 'sbBcdCEFgfhHiIlLqQPzuUZXvO':
    print(f"        case '{code}': result = &formattable.fmt_{code}; break;")
[python start generated code]*/
        case 's': result = &formattable.fmt_s; break;
        case 'b': result = &formattable.fmt_b; break;
        case 'B': result = &formattable.fmt_B; break;
        case 'c': result = &formattable.fmt_c; break;
        case 'd': result = &formattable.fmt_d; break;
        case 'C': result = &formattable.fmt_C; break;
        case 'E': result = &formattable.fmt_E; break;
        case 'F': result = &formattable.fmt_F; break;
        case 'g': result = &formattable.fmt_g; break;
        case 'f': result = &formattable.fmt_f; break;
        case 'h': result = &formattable.fmt_h; break;
        case 'H': result = &formattable.fmt_H; break;
        case 'i': result = &formattable.fmt_i; break;
        case 'I': result = &formattable.fmt_I; break;
        case 'l': result = &formattable.fmt_l; break;
        case 'L': result = &formattable.fmt_L; break;
        case 'q': result = &formattable.fmt_q; break;
        case 'Q': result = &formattable.fmt_Q; break;
        case 'P': result = &formattable.fmt_P; break;
        case 'z': result = &formattable.fmt_z; break;
        case 'u': result = &formattable.fmt_u; break;
        case 'U': result = &formattable.fmt_U; break;
        case 'Z': result = &formattable.fmt_Z; break;
        case 'X': result = &formattable.fmt_X; break;
        case 'v': result = &formattable.fmt_v; break;
        case 'O': result = &formattable.fmt_O; break;
/*[python end generated code: output=81a8223dda9f81f7 input=2f59666d3c024edf]*/
        case '?': result = &formattable.fmt_bool; break;
    }
    if (!result || !result->code) {
        return NULL;
    }
    assert(result->pffi_type);
    assert(result->setfunc);
    assert(result->getfunc);
    return result;
}

/*
  Ideas: Implement VARIANT in this table, using 'V' code.
*/

/*---------------- EOF ----------------*/


================================================
File: /Modules/_ctypes/ctypes.h
================================================
#if defined (__SVR4) && defined (__sun)
#   include <alloca.h>
#endif

#include "pycore_moduleobject.h"  // _PyModule_GetState()
#include "pycore_typeobject.h"    // _PyType_GetModuleState()

#if defined(Py_HAVE_C_COMPLEX) && defined(Py_FFI_SUPPORT_C_COMPLEX)
#   include "../_complex.h"       // complex
#endif

#ifndef MS_WIN32
#define max(a, b) ((a) > (b) ? (a) : (b))
#define min(a, b) ((a) < (b) ? (a) : (b))

#define PARAMFLAG_FIN 0x1
#define PARAMFLAG_FOUT 0x2
#define PARAMFLAG_FLCID 0x4
#endif

/*
 * bpo-13097: Max number of arguments CFuncPtr._argtypes_ and
 * _ctypes_callproc() will accept.
 *
 * This limit is enforced for the `alloca()` call in `_ctypes_callproc`,
 * to avoid allocating a massive buffer on the stack.
 */
#ifndef CTYPES_MAX_ARGCOUNT
  #ifdef __EMSCRIPTEN__
    #define CTYPES_MAX_ARGCOUNT 1000
  #else
    #define CTYPES_MAX_ARGCOUNT 1024
  #endif
#endif

#if defined(__has_builtin)
#if __has_builtin(__builtin_available)
#define HAVE_BUILTIN_AVAILABLE 1
#endif
#endif

#ifdef MS_WIN32
#include <Unknwn.h> // for IUnknown interface
#endif

typedef struct {
    PyTypeObject *DictRemover_Type;
    PyTypeObject *PyCArg_Type;
    PyTypeObject *PyCField_Type;
    PyTypeObject *PyCThunk_Type;
    PyTypeObject *StructParam_Type;
    PyTypeObject *PyCType_Type;
    PyTypeObject *PyCStructType_Type;
    PyTypeObject *UnionType_Type;
    PyTypeObject *PyCPointerType_Type;
    PyTypeObject *PyCArrayType_Type;
    PyTypeObject *PyCSimpleType_Type;
    PyTypeObject *PyCFuncPtrType_Type;
    PyTypeObject *PyCData_Type;
    PyTypeObject *Struct_Type;
    PyTypeObject *Union_Type;
    PyTypeObject *PyCArray_Type;
    PyTypeObject *Simple_Type;
    PyTypeObject *PyCPointer_Type;
    PyTypeObject *PyCFuncPtr_Type;
#ifdef MS_WIN32
    PyTypeObject *PyComError_Type;
#endif
    /* This dict maps ctypes types to POINTER types */
    PyObject *_ctypes_ptrtype_cache;
    /* a callable object used for unpickling:
       strong reference to _ctypes._unpickle() function */
    PyObject *_unpickle;
    PyObject *array_cache;
    PyObject *error_object_name;  // callproc.c
    PyObject *PyExc_ArgError;
    PyObject *swapped_suffix;
} ctypes_state;


extern struct PyModuleDef _ctypesmodule;


static inline ctypes_state *
get_module_state(PyObject *module)
{
    void *state = _PyModule_GetState(module);
    assert(state != NULL);
    return (ctypes_state *)state;
}

static inline ctypes_state *
get_module_state_by_class(PyTypeObject *cls)
{
    ctypes_state *state = (ctypes_state *)_PyType_GetModuleState(cls);
    assert(state != NULL);
    return state;
}

static inline ctypes_state *
get_module_state_by_def(PyTypeObject *cls)
{
    PyObject *mod = PyType_GetModuleByDef(cls, &_ctypesmodule);
    assert(mod != NULL);
    return get_module_state(mod);
}


extern PyType_Spec pyctype_type_spec;
extern PyType_Spec carg_spec;
extern PyType_Spec cfield_spec;
extern PyType_Spec cthunk_spec;

typedef struct tagPyCArgObject PyCArgObject;
typedef struct tagCDataObject CDataObject;

// GETFUNC: convert the C value at *ptr* to Python object, return the object
// SETFUNC: write content of the PyObject *value* to the location at *ptr*;
//   return a new reference to either *value*, or None for simple types
//   (see _CTYPES_DEBUG_KEEP).
// Note that the *size* arg can have different meanings depending on context:
//     for string-like arrays it's the size in bytes
//     for int-style fields it's either the type size, or bitfiled info
//         that can be unpacked using the LOW_BIT & NUM_BITS macros.
typedef PyObject *(* GETFUNC)(void *ptr, Py_ssize_t size);
typedef PyObject *(* SETFUNC)(void *ptr, PyObject *value, Py_ssize_t size);
typedef PyCArgObject *(* PARAMFUNC)(ctypes_state *st, CDataObject *obj);

/* A default buffer in CDataObject, which can be used for small C types.  If
this buffer is too small, PyMem_Malloc will be called to create a larger one,
and this one is not used.

Making CDataObject a variable size object would be a better solution, but more
difficult in the presence of PyCFuncPtrObject.  Maybe later.
*/
union value {
                char c[16];
                short s;
                int i;
                long l;
                float f;
                double d;
                long long ll;
                long double D;
};

/*
  Hm. Are there CDataObject's which do not need the b_objects member?  In
  this case we probably should introduce b_flags to mark it as present...  If
  b_objects is not present/unused b_length is unneeded as well.
*/

struct tagCDataObject {
    PyObject_HEAD
    char *b_ptr;                /* pointer to memory block */
    int  b_needsfree;           /* need _we_ free the memory? */
    CDataObject *b_base;        /* pointer to base object or NULL */
    Py_ssize_t b_size;          /* size of memory block in bytes */
    Py_ssize_t b_length;        /* number of references we need */
    Py_ssize_t b_index;         /* index of this object into base's
                               b_object list */
    PyObject *b_objects;        /* dictionary of references we need to keep, or Py_None */
    union value b_value;
};

typedef struct {
    PyObject_VAR_HEAD
    ffi_closure *pcl_write; /* the C callable, writeable */
    void *pcl_exec;         /* the C callable, executable */
    ffi_cif cif;
    int flags;
    PyObject *converters;
    PyObject *callable;
    PyObject *restype;
    SETFUNC setfunc;
    ffi_type *ffi_restype;
    ffi_type *atypes[1];
} CThunkObject;
#define CThunk_CheckExact(st, v)        Py_IS_TYPE(v, st->PyCThunk_Type)

typedef struct {
    /* First part identical to tagCDataObject */
    PyObject_HEAD
    char *b_ptr;                /* pointer to memory block */
    int  b_needsfree;           /* need _we_ free the memory? */
    CDataObject *b_base;        /* pointer to base object or NULL */
    Py_ssize_t b_size;          /* size of memory block in bytes */
    Py_ssize_t b_length;        /* number of references we need */
    Py_ssize_t b_index;         /* index of this object into base's
                                   b_object list */
    PyObject *b_objects;        /* list of references we need to keep */
    union value b_value;
    /* end of tagCDataObject, additional fields follow */

    CThunkObject *thunk;
    PyObject *callable;

    /* These two fields will override the ones in the type's stginfo if
       they are set */
    PyObject *converters;
    PyObject *argtypes;
    PyObject *restype;
    PyObject *checker;
    PyObject *errcheck;
#ifdef MS_WIN32
    int index;
    GUID *iid;
#endif
    PyObject *paramflags;
} PyCFuncPtrObject;

extern int PyCStructUnionType_update_stginfo(PyObject *fields, PyObject *type, int isStruct);
extern int PyType_stginfo(PyTypeObject *self, Py_ssize_t *psize, Py_ssize_t *palign, Py_ssize_t *plength);
extern int PyObject_stginfo(PyObject *self, Py_ssize_t *psize, Py_ssize_t *palign, Py_ssize_t *plength);



#define CDataObject_CheckExact(st, v)  Py_IS_TYPE((v), (st)->PyCData_Type)
#define CDataObject_Check(st, v)       PyObject_TypeCheck((v), (st)->PyCData_Type)
#define _CDataObject_HasExternalBuffer(v)  ((v)->b_ptr != (char *)&(v)->b_value)

#define PyCSimpleTypeObject_CheckExact(st, v)  Py_IS_TYPE((v), (st)->PyCSimpleType_Type)
#define PyCSimpleTypeObject_Check(st, v)       PyObject_TypeCheck((v), (st)->PyCSimpleType_Type)

extern struct fielddesc *_ctypes_get_fielddesc(const char *fmt);

extern PyObject *PyCData_AtAddress(ctypes_state *st, PyObject *type, void *buf);
extern PyObject *PyCData_FromBytes(ctypes_state *st, PyObject *type, char *data, Py_ssize_t length);

#define PyCArrayTypeObject_Check(st, v)   PyObject_TypeCheck((v), (st)->PyCArrayType_Type)
#define ArrayObject_Check(st, v)          PyObject_TypeCheck((v), (st)->PyCArray_Type)
#define PointerObject_Check(st, v)        PyObject_TypeCheck((v), (st)->PyCPointer_Type)
#define PyCPointerTypeObject_Check(st, v) PyObject_TypeCheck((v), (st)->PyCPointerType_Type)
#define PyCFuncPtrObject_Check(st,v)      PyObject_TypeCheck((v), (st)->PyCFuncPtr_Type)
#define PyCFuncPtrTypeObject_Check(st, v) PyObject_TypeCheck((v), (st)->PyCFuncPtrType_Type)
#define PyCStructTypeObject_Check(st, v)  PyObject_TypeCheck((v), (st)->PyCStructType_Type)

extern PyObject *
PyCArrayType_from_ctype(ctypes_state *st, PyObject *itemtype, Py_ssize_t length);

extern PyMethodDef _ctypes_module_methods[];

extern CThunkObject *_ctypes_alloc_callback(ctypes_state *st,
                                           PyObject *callable,
                                           PyObject *converters,
                                           PyObject *restype,
                                           int flags);
/* a table entry describing a predefined ctypes type */
struct fielddesc {
    char code;
    ffi_type *pffi_type; /* always statically allocated */
    SETFUNC setfunc;
    GETFUNC getfunc;
    SETFUNC setfunc_swapped;
    GETFUNC getfunc_swapped;
};

typedef struct CFieldObject {
    PyObject_HEAD
    Py_ssize_t offset;
    Py_ssize_t size;
    Py_ssize_t index;                   /* Index into CDataObject's
                                       object array */
    PyObject *proto;                    /* underlying ctype; must have StgInfo */
    GETFUNC getfunc;                    /* getter function if proto is NULL */
    SETFUNC setfunc;                    /* setter function if proto is NULL */
    int anonymous;

    PyObject *name;                     /* exact PyUnicode */
} CFieldObject;

/****************************************************************
 StgInfo

 Since Python 3.13, ctypes-specific type information is stored in the
 corresponding type object, in a `StgInfo` struct accessed by the helpers
 below.
 Before that, each type's `tp_dict` was set to a dict *subclass* that included
 the fields that are now in StgInfo. The mechanism was called "StgDict"; a few
 references to that name might remain.

 Functions for accessing StgInfo are `static inline` for performance;
 see later in this file.

 ****************************************************************

 StgInfo fields

 setfunc and getfunc is only set for simple data types, it is copied from the
 corresponding fielddesc entry.  These are functions to set and get the value
 in a memory block.
 They should probably by used by other types as well.

 proto is only used for Pointer and Array types - it points to the item type
 object.

 Probably all the magic ctypes methods (like from_param) should have C
 callable wrappers in the StgInfo.  For simple data type, for example,
 the fielddesc table could have entries for C codec from_param functions or
 other methods as well, if a subtype overrides this method in Python at
 construction time, or assigns to it later, tp_setattro should update the
 StgInfo function to a generic one.

 Currently, PyCFuncPtr types have 'converters' and 'checker' entries in their
 type dict.  They are only used to cache attributes from other entries, which
 is wrong.

 One use case is the .value attribute that all simple types have.  But some
 complex structures, like VARIANT, represent a single value also, and should
 have this attribute.

 Another use case is a _check_retval_ function, which is called when a ctypes
 type is used as return type of a function to validate and compute the return
 value.

 Common ctypes protocol:

  - setfunc: store a python value in a memory block
  - getfunc: convert data from a memory block into a python value

  - checkfunc: validate and convert a return value from a function call
  - toparamfunc: convert a python value into a function argument

*****************************************************************/

typedef struct {
    int initialized;
    Py_ssize_t size;            /* number of bytes */
    Py_ssize_t align;           /* alignment requirements */
    Py_ssize_t length;          /* number of fields */
    ffi_type ffi_type_pointer;
    PyObject *proto;            /* Only for Pointer/ArrayObject */
    SETFUNC setfunc;            /* Only for simple objects */
    GETFUNC getfunc;            /* Only for simple objects */
    PARAMFUNC paramfunc;

    /* Following fields only used by PyCFuncPtrType_Type instances */
    PyObject *argtypes;         /* tuple of CDataObjects */
    PyObject *converters;       /* tuple([t.from_param for t in argtypes]) */
    PyObject *restype;          /* CDataObject or NULL */
    PyObject *checker;
    PyObject *module;
    int flags;                  /* calling convention and such */

    /* pep3118 fields, pointers need PyMem_Free */
    char *format;
    int ndim;
    Py_ssize_t *shape;
/*      Py_ssize_t *strides;    */ /* unused in ctypes */
/*      Py_ssize_t *suboffsets; */ /* unused in ctypes */
} StgInfo;

extern int PyCStgInfo_clone(StgInfo *dst_info, StgInfo *src_info);
extern void ctype_clear_stginfo(StgInfo *info);

typedef int(* PPROC)(void);

PyObject *_ctypes_callproc(ctypes_state *st,
                    PPROC pProc,
                    PyObject *arguments,
#ifdef MS_WIN32
                    IUnknown *pIUnk,
                    GUID *iid,
#endif
                    int flags,
                    PyObject *argtypes,
                    PyObject *restype,
                    PyObject *checker);


#define FUNCFLAG_STDCALL 0x0
#define FUNCFLAG_CDECL   0x1
#define FUNCFLAG_HRESULT 0x2
#define FUNCFLAG_PYTHONAPI 0x4
#define FUNCFLAG_USE_ERRNO 0x8
#define FUNCFLAG_USE_LASTERROR 0x10

#define TYPEFLAG_ISPOINTER 0x100
#define TYPEFLAG_HASPOINTER 0x200

#define DICTFLAG_FINAL 0x1000

struct tagPyCArgObject {
    PyObject_HEAD
    ffi_type *pffi_type;
    char tag;
    union {
        char c;
        char b;
        short h;
        int i;
        long l;
        long long q;
        long double D;
        double d;
        float f;
        void *p;
#if defined(Py_HAVE_C_COMPLEX) && defined(Py_FFI_SUPPORT_C_COMPLEX)
        double complex C;
        float complex E;
        long double complex F;
#endif
    } value;
    PyObject *obj;
    Py_ssize_t size; /* for the 'V' tag */
};

#define PyCArg_CheckExact(st, v)        Py_IS_TYPE(v, st->PyCArg_Type)
extern PyCArgObject *PyCArgObject_new(ctypes_state *st);

extern PyObject *
PyCData_get(ctypes_state *st, PyObject *type, GETFUNC getfunc, PyObject *src,
          Py_ssize_t index, Py_ssize_t size, char *ptr);

extern int
PyCData_set(ctypes_state *st,
          PyObject *dst, PyObject *type, SETFUNC setfunc, PyObject *value,
          Py_ssize_t index, Py_ssize_t size, char *ptr);

extern void _ctypes_extend_error(PyObject *exc_class, const char *fmt, ...);

struct basespec {
    CDataObject *base;
    Py_ssize_t index;
    char *adr;
};

extern ffi_type *_ctypes_get_ffi_type(ctypes_state *st, PyObject *obj);

extern void _ctypes_free_closure(void *);
extern void *_ctypes_alloc_closure(void);

extern PyObject *PyCData_FromBaseObj(ctypes_state *st, PyObject *type,
                                     PyObject *base, Py_ssize_t index, char *adr);

extern int _ctypes_simple_instance(ctypes_state *st, PyObject *obj);

PyObject *_ctypes_get_errobj(ctypes_state *st, int **pspace);

#ifdef USING_MALLOC_CLOSURE_DOT_C
void Py_ffi_closure_free(void *p);
void *Py_ffi_closure_alloc(size_t size, void** codeloc);
#else
#define Py_ffi_closure_free ffi_closure_free
#define Py_ffi_closure_alloc ffi_closure_alloc
#endif


/****************************************************************
 * Accessing StgInfo -- these are inlined for performance reasons.
 */

// `PyStgInfo_From**` functions get a PyCTypeDataObject.
// These return -1 on error, 0 if "not found", 1 on OK.
// (Currently, these do not return -1 in practice. This might change
// in the future.)

//
// Common helper:
static inline int
_stginfo_from_type(ctypes_state *state, PyTypeObject *type, StgInfo **result)
{
    *result = NULL;
    if (!PyObject_IsInstance((PyObject *)type, (PyObject *)state->PyCType_Type)) {
        // not a ctypes class.
        return 0;
    }
    StgInfo *info = PyObject_GetTypeData((PyObject *)type, state->PyCType_Type);
    assert(info != NULL);
    if (!info->initialized) {
        // StgInfo is not initialized. This happens in abstract classes.
        return 0;
    }
    *result = info;
    return 1;
}
// from a type:
static inline int
PyStgInfo_FromType(ctypes_state *state, PyObject *type, StgInfo **result)
{
    return _stginfo_from_type(state, (PyTypeObject *)type, result);
}
// from an instance:
static inline int
PyStgInfo_FromObject(ctypes_state *state, PyObject *obj, StgInfo **result)
{
    return _stginfo_from_type(state, Py_TYPE(obj), result);
}
// from either a type or an instance:
static inline int
PyStgInfo_FromAny(ctypes_state *state, PyObject *obj, StgInfo **result)
{
    if (PyType_Check(obj)) {
        return _stginfo_from_type(state, (PyTypeObject *)obj, result);
    }
    return _stginfo_from_type(state, Py_TYPE(obj), result);
}

/* A variant of PyStgInfo_FromType that doesn't need the state,
 * so it can be called from finalization functions when the module
 * state is torn down.
 */
static inline StgInfo *
_PyStgInfo_FromType_NoState(PyObject *type)
{
    PyTypeObject *PyCType_Type;
    if (PyType_GetBaseByToken(Py_TYPE(type), &pyctype_type_spec, &PyCType_Type) < 0) {
        return NULL;
    }
    if (PyCType_Type == NULL) {
        PyErr_Format(PyExc_TypeError, "expected a ctypes type, got '%N'", type);
        return NULL;
    }

    StgInfo *info = PyObject_GetTypeData(type, PyCType_Type);
    Py_DECREF(PyCType_Type);
    return info;
}

// Initialize StgInfo on a newly created type
static inline StgInfo *
PyStgInfo_Init(ctypes_state *state, PyTypeObject *type)
{
    if (!PyObject_IsInstance((PyObject *)type, (PyObject *)state->PyCType_Type)) {
        PyErr_Format(PyExc_SystemError,
                     "'%s' is not a ctypes class.",
                     type->tp_name);
        return NULL;
    }
    StgInfo *info = PyObject_GetTypeData((PyObject *)type, state->PyCType_Type);
    if (info->initialized) {
        PyErr_Format(PyExc_SystemError,
                     "StgInfo of '%s' is already initialized.",
                     type->tp_name);
        return NULL;
    }
    PyObject *module = PyType_GetModule(state->PyCType_Type);
    if (!module) {
        return NULL;
    }
    info->module = Py_NewRef(module);

    info->initialized = 1;
    return info;
}


================================================
File: /Modules/_ctypes/malloc_closure.c
================================================
#ifndef Py_BUILD_CORE_BUILTIN
#  define Py_BUILD_CORE_MODULE 1
#endif

#include <Python.h>
#include <ffi.h>
#ifdef MS_WIN32
#  include <windows.h>
#else
#  include <sys/mman.h>
#  include <unistd.h>             // sysconf()
#  if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
#    define MAP_ANONYMOUS MAP_ANON
#  endif
#endif
#include "ctypes.h"

/* BLOCKSIZE can be adjusted.  Larger blocksize will take a larger memory
   overhead, but allocate less blocks from the system.  It may be that some
   systems have a limit of how many mmap'd blocks can be open.
*/

#define BLOCKSIZE _pagesize

/* #define MALLOC_CLOSURE_DEBUG */ /* enable for some debugging output */


/******************************************************************/

typedef union _tagITEM {
    ffi_closure closure;
    union _tagITEM *next;
} ITEM;

static ITEM *free_list;
static int _pagesize;

static void more_core(void)
{
    ITEM *item;
    int count, i;

/* determine the pagesize */
#ifdef MS_WIN32
    if (!_pagesize) {
        SYSTEM_INFO systeminfo;
        GetSystemInfo(&systeminfo);
        _pagesize = systeminfo.dwPageSize;
    }
#else
    if (!_pagesize) {
#ifdef _SC_PAGESIZE
        _pagesize = sysconf(_SC_PAGESIZE);
#else
        _pagesize = getpagesize();
#endif
    }
#endif

    /* calculate the number of nodes to allocate */
    count = BLOCKSIZE / sizeof(ITEM);

    /* allocate a memory block */
#ifdef MS_WIN32
    item = (ITEM *)VirtualAlloc(NULL,
                                           count * sizeof(ITEM),
                                           MEM_COMMIT,
                                           PAGE_EXECUTE_READWRITE);
    if (item == NULL)
        return;
#else
    item = (ITEM *)mmap(NULL,
                        count * sizeof(ITEM),
                        PROT_READ | PROT_WRITE | PROT_EXEC,
                        MAP_PRIVATE | MAP_ANONYMOUS,
                        -1,
                        0);
    if (item == (void *)MAP_FAILED)
        return;
#endif

#ifdef MALLOC_CLOSURE_DEBUG
    printf("block at %p allocated (%d bytes), %d ITEMs\n",
           item, count * (int)sizeof(ITEM), count);
#endif
    /* put them into the free list */
    for (i = 0; i < count; ++i) {
        item->next = free_list;
        free_list = item;
        ++item;
    }
}

/******************************************************************/

/* put the item back into the free list */
void Py_ffi_closure_free(void *p)
{
#ifdef HAVE_FFI_CLOSURE_ALLOC
#ifdef USING_APPLE_OS_LIBFFI
# ifdef HAVE_BUILTIN_AVAILABLE
    if (__builtin_available(macos 10.15, ios 13, watchos 6, tvos 13, *)) {
#  else
    if (ffi_closure_free != NULL) {
#  endif
#endif
        ffi_closure_free(p);
        return;
#ifdef USING_APPLE_OS_LIBFFI
    }
#endif
#endif
    ITEM *item = (ITEM *)p;
    item->next = free_list;
    free_list = item;
}

/* return one item from the free list, allocating more if needed */
void *Py_ffi_closure_alloc(size_t size, void** codeloc)
{
#ifdef HAVE_FFI_CLOSURE_ALLOC
#ifdef USING_APPLE_OS_LIBFFI
# ifdef HAVE_BUILTIN_AVAILABLE
    if (__builtin_available(macos 10.15, ios 13, watchos 6, tvos 13, *)) {
# else
    if (ffi_closure_alloc != NULL) {
#  endif
#endif
        return ffi_closure_alloc(size, codeloc);
#ifdef USING_APPLE_OS_LIBFFI
    }
#endif
#endif
    ITEM *item;
    if (!free_list)
        more_core();
    if (!free_list)
        return NULL;
    item = free_list;
    free_list = item->next;
#ifdef _M_ARM
    // set Thumb bit so that blx is called correctly
    *codeloc = (ITEM*)((uintptr_t)item | 1);
#else
    *codeloc = (void *)item;
#endif
    return (void *)item;
}


================================================
File: /Modules/_ctypes/stgdict.c
================================================
#ifndef Py_BUILD_CORE_BUILTIN
#  define Py_BUILD_CORE_MODULE 1
#endif

#include "Python.h"
// windows.h must be included before pycore internal headers
#ifdef MS_WIN32
#  include <windows.h>
#endif

#include "pycore_call.h"          // _PyObject_CallNoArgs()
#include "pycore_dict.h"          // _PyDict_SizeOf()
#include <ffi.h>
#ifdef MS_WIN32
#  include <malloc.h>
#endif
#include "ctypes.h"

/* This file relates to StgInfo -- type-specific information for ctypes.
 * See ctypes.h for details.
 */

int
PyCStgInfo_clone(StgInfo *dst_info, StgInfo *src_info)
{
    Py_ssize_t size;

    ctype_clear_stginfo(dst_info);
    PyMem_Free(dst_info->ffi_type_pointer.elements);
    PyMem_Free(dst_info->format);
    dst_info->format = NULL;
    PyMem_Free(dst_info->shape);
    dst_info->shape = NULL;
    dst_info->ffi_type_pointer.elements = NULL;

    memcpy(dst_info, src_info, sizeof(StgInfo));

    Py_XINCREF(dst_info->proto);
    Py_XINCREF(dst_info->argtypes);
    Py_XINCREF(dst_info->converters);
    Py_XINCREF(dst_info->restype);
    Py_XINCREF(dst_info->checker);
    Py_XINCREF(dst_info->module);

    if (src_info->format) {
        dst_info->format = PyMem_Malloc(strlen(src_info->format) + 1);
        if (dst_info->format == NULL) {
            PyErr_NoMemory();
            return -1;
        }
        strcpy(dst_info->format, src_info->format);
    }
    if (src_info->shape) {
        dst_info->shape = PyMem_Malloc(sizeof(Py_ssize_t) * src_info->ndim);
        if (dst_info->shape == NULL) {
            PyErr_NoMemory();
            return -1;
        }
        memcpy(dst_info->shape, src_info->shape,
               sizeof(Py_ssize_t) * src_info->ndim);
    }

    if (src_info->ffi_type_pointer.elements == NULL)
        return 0;
    size = sizeof(ffi_type *) * (src_info->length + 1);
    dst_info->ffi_type_pointer.elements = PyMem_Malloc(size);
    if (dst_info->ffi_type_pointer.elements == NULL) {
        PyErr_NoMemory();
        return -1;
    }
    memcpy(dst_info->ffi_type_pointer.elements,
           src_info->ffi_type_pointer.elements,
           size);
    return 0;
}

/* descr is the descriptor for a field marked as anonymous.  Get all the
 _fields_ descriptors from descr->proto, create new descriptors with offset
 and index adjusted, and stuff them into type.
 */
static int
MakeFields(PyObject *type, CFieldObject *descr,
           Py_ssize_t index, Py_ssize_t offset)
{
    Py_ssize_t i;
    PyObject *fields;
    PyObject *fieldlist;

    fields = PyObject_GetAttrString(descr->proto, "_fields_");
    if (fields == NULL)
        return -1;
    fieldlist = PySequence_Fast(fields, "_fields_ must be a sequence");
    Py_DECREF(fields);
    if (fieldlist == NULL)
        return -1;

    ctypes_state *st = get_module_state_by_class(Py_TYPE(descr));
    PyTypeObject *cfield_tp = st->PyCField_Type;
    for (i = 0; i < PySequence_Fast_GET_SIZE(fieldlist); ++i) {
        PyObject *pair = PySequence_Fast_GET_ITEM(fieldlist, i); /* borrowed */
        PyObject *fname, *ftype, *bits;
        CFieldObject *fdescr;
        CFieldObject *new_descr;
        /* Convert to PyArg_UnpackTuple... */
        if (!PyArg_ParseTuple(pair, "OO|O", &fname, &ftype, &bits)) {
            Py_DECREF(fieldlist);
            return -1;
        }
        fdescr = (CFieldObject *)PyObject_GetAttr(descr->proto, fname);
        if (fdescr == NULL) {
            Py_DECREF(fieldlist);
            return -1;
        }
        if (!Py_IS_TYPE(fdescr, cfield_tp)) {
            PyErr_SetString(PyExc_TypeError, "unexpected type");
            Py_DECREF(fdescr);
            Py_DECREF(fieldlist);
            return -1;
        }
        if (fdescr->anonymous) {
            int rc = MakeFields(type, fdescr,
                                index + fdescr->index,
                                offset + fdescr->offset);
            Py_DECREF(fdescr);
            if (rc == -1) {
                Py_DECREF(fieldlist);
                return -1;
            }
            continue;
        }
        new_descr = (CFieldObject *)cfield_tp->tp_alloc(cfield_tp, 0);
        if (new_descr == NULL) {
            Py_DECREF(fdescr);
            Py_DECREF(fieldlist);
            return -1;
        }
        assert(Py_IS_TYPE(new_descr, cfield_tp));
        new_descr->size = fdescr->size;
        new_descr->offset = fdescr->offset + offset;
        new_descr->index = fdescr->index + index;
        new_descr->proto = Py_XNewRef(fdescr->proto);
        new_descr->getfunc = fdescr->getfunc;
        new_descr->setfunc = fdescr->setfunc;

        Py_DECREF(fdescr);

        if (-1 == PyObject_SetAttr(type, fname, (PyObject *)new_descr)) {
            Py_DECREF(fieldlist);
            Py_DECREF(new_descr);
            return -1;
        }
        Py_DECREF(new_descr);
    }
    Py_DECREF(fieldlist);
    return 0;
}

/* Iterate over the names in the type's _anonymous_ attribute, if present,
 */
static int
MakeAnonFields(PyObject *type)
{
    PyObject *anon;
    PyObject *anon_names;
    Py_ssize_t i;

    if (PyObject_GetOptionalAttr(type, &_Py_ID(_anonymous_), &anon) < 0) {
        return -1;
    }
    if (anon == NULL) {
        return 0;
    }
    anon_names = PySequence_Fast(anon, "_anonymous_ must be a sequence");
    Py_DECREF(anon);
    if (anon_names == NULL)
        return -1;

    ctypes_state *st = get_module_state_by_def(Py_TYPE(type));
    PyTypeObject *cfield_tp = st->PyCField_Type;
    for (i = 0; i < PySequence_Fast_GET_SIZE(anon_names); ++i) {
        PyObject *fname = PySequence_Fast_GET_ITEM(anon_names, i); /* borrowed */
        CFieldObject *descr = (CFieldObject *)PyObject_GetAttr(type, fname);
        if (descr == NULL) {
            Py_DECREF(anon_names);
            return -1;
        }
        if (!Py_IS_TYPE(descr, cfield_tp)) {
            PyErr_Format(PyExc_AttributeError,
                         "'%U' is specified in _anonymous_ but not in "
                         "_fields_",
                         fname);
            Py_DECREF(anon_names);
            Py_DECREF(descr);
            return -1;
        }
        descr->anonymous = 1;

        /* descr is in the field descriptor. */
        if (-1 == MakeFields(type, (CFieldObject *)descr,
                             ((CFieldObject *)descr)->index,
                             ((CFieldObject *)descr)->offset)) {
            Py_DECREF(descr);
            Py_DECREF(anon_names);
            return -1;
        }
        Py_DECREF(descr);
    }

    Py_DECREF(anon_names);
    return 0;
}

/*
  Retrieve the (optional) _pack_ attribute from a type, the _fields_ attribute,
  and initialize StgInfo.  Used for Structure and Union subclasses.
*/
int
PyCStructUnionType_update_stginfo(PyObject *type, PyObject *fields, int isStruct)
{
    PyObject *tmp;
    Py_ssize_t ffi_ofs;
    int arrays_seen = 0;

    int retval = -1;
    // The following are NULL or hold strong references.
    // They're cleared on error.
    PyObject *layout_fields = NULL;
    PyObject *layout = NULL;
    PyObject *format_spec_obj = NULL;

    if (fields == NULL) {
        return 0;
    }

    ctypes_state *st = get_module_state_by_def(Py_TYPE(type));
    StgInfo *stginfo;
    if (PyStgInfo_FromType(st, type, &stginfo) < 0) {
        goto error;
    }
    if (!stginfo) {
        PyErr_SetString(PyExc_TypeError,
                        "ctypes state is not initialized");
        goto error;
    }
    PyObject *base = (PyObject *)((PyTypeObject *)type)->tp_base;
    StgInfo *baseinfo;
    if (PyStgInfo_FromType(st, base, &baseinfo) < 0) {
        goto error;
    }

    /* If this structure/union is already marked final we cannot assign
       _fields_ anymore. */

    if (stginfo->flags & DICTFLAG_FINAL) {/* is final ? */
        PyErr_SetString(PyExc_AttributeError,
                        "_fields_ is final");
        goto error;
    }

    PyObject *layout_func = _PyImport_GetModuleAttrString("ctypes._layout",
                                                          "get_layout");
    if (!layout_func) {
        goto error;
    }
    PyObject *kwnames = PyTuple_Pack(
        2,
        &_Py_ID(is_struct),
        &_Py_ID(base));
    if (!kwnames) {
        goto error;
    }
    layout = PyObject_Vectorcall(
        layout_func,
        1 + (PyObject*[]){
            NULL,
            /* positional args */
            type,
            fields,
            /* keyword args */
            isStruct ? Py_True : Py_False,
            baseinfo ? base : Py_None},
        2 | PY_VECTORCALL_ARGUMENTS_OFFSET,
        kwnames);
    Py_DECREF(kwnames);
    Py_DECREF(layout_func);
    fields = NULL; // a borrowed reference we won't be using again
    if (!layout) {
        goto error;
    }

    tmp = PyObject_GetAttr(layout, &_Py_ID(align));
    if (!tmp) {
        goto error;
    }
    Py_ssize_t total_align = PyLong_AsSsize_t(tmp);
    Py_DECREF(tmp);
    if (total_align < 0) {
        if (!PyErr_Occurred()) {
            PyErr_SetString(PyExc_ValueError,
                            "align must be a non-negative integer");
        }
        goto error;
    }

    tmp = PyObject_GetAttr(layout, &_Py_ID(size));
    if (!tmp) {
        goto error;
    }
    Py_ssize_t total_size = PyLong_AsSsize_t(tmp);
    Py_DECREF(tmp);
    if (total_size < 0) {
        if (!PyErr_Occurred()) {
            PyErr_SetString(PyExc_ValueError,
                            "size must be a non-negative integer");
        }
        goto error;
    }

    format_spec_obj = PyObject_GetAttr(layout, &_Py_ID(format_spec));
    if (!format_spec_obj) {
        goto error;
    }
    Py_ssize_t format_spec_size;
    const char *format_spec = PyUnicode_AsUTF8AndSize(format_spec_obj,
                                                      &format_spec_size);
    if (!format_spec) {
        goto error;
    }

    if (stginfo->format) {
        PyMem_Free(stginfo->format);
        stginfo->format = NULL;
    }
    stginfo->format = PyMem_Malloc(format_spec_size + 1);
    if (!stginfo->format) {
        PyErr_NoMemory();
        goto error;
    }
    memcpy(stginfo->format, format_spec, format_spec_size + 1);

    PyObject *layout_fields_obj = PyObject_GetAttr(layout, &_Py_ID(fields));
    if (!layout_fields_obj) {
        goto error;
    }
    layout_fields = PySequence_Tuple(layout_fields_obj);
    Py_DECREF(layout_fields_obj);
    if (!layout_fields) {
        goto error;
    }
    Py_CLEAR(layout);

    Py_ssize_t len = PyTuple_GET_SIZE(layout_fields);

    if (stginfo->ffi_type_pointer.elements) {
        PyMem_Free(stginfo->ffi_type_pointer.elements);
        stginfo->ffi_type_pointer.elements = NULL;
    }

    if (baseinfo) {
        stginfo->ffi_type_pointer.type = FFI_TYPE_STRUCT;
        stginfo->ffi_type_pointer.elements = PyMem_New(ffi_type *, baseinfo->length + len + 1);
        if (stginfo->ffi_type_pointer.elements == NULL) {
            PyErr_NoMemory();
            goto error;
        }
        memset(stginfo->ffi_type_pointer.elements, 0,
               sizeof(ffi_type *) * (baseinfo->length + len + 1));
        if (baseinfo->length > 0) {
            memcpy(stginfo->ffi_type_pointer.elements,
                   baseinfo->ffi_type_pointer.elements,
                   sizeof(ffi_type *) * (baseinfo->length));
        }
        ffi_ofs = baseinfo->length;
    } else {
        stginfo->ffi_type_pointer.type = FFI_TYPE_STRUCT;
        stginfo->ffi_type_pointer.elements = PyMem_New(ffi_type *, len + 1);
        if (stginfo->ffi_type_pointer.elements == NULL) {
            PyErr_NoMemory();
            goto error;
        }
        memset(stginfo->ffi_type_pointer.elements, 0,
               sizeof(ffi_type *) * (len + 1));
        ffi_ofs = 0;
    }

    for (Py_ssize_t i = 0; i < len; ++i) {
        PyObject *prop_obj = PyTuple_GET_ITEM(layout_fields, i);
        assert(prop_obj);
        if (!PyType_IsSubtype(Py_TYPE(prop_obj), st->PyCField_Type)) {
            PyErr_Format(PyExc_TypeError,
                         "fields must be of type CField, got %T", prop_obj);
            goto error;

        }
        CFieldObject *prop = (CFieldObject *)prop_obj; // borrow from prop_obj

        if (prop->index != i) {
            PyErr_Format(PyExc_ValueError,
                         "field %R index mismatch (expected %zd, got %zd)",
                         prop->name, i, prop->index);
            goto error;
        }

        if (PyCArrayTypeObject_Check(st, prop->proto)) {
            arrays_seen = 1;
        }

        StgInfo *info;
        if (PyStgInfo_FromType(st, prop->proto, &info) < 0) {
            goto error;
        }
        assert(info);

        stginfo->ffi_type_pointer.elements[ffi_ofs + i] = &info->ffi_type_pointer;
        if (info->flags & (TYPEFLAG_ISPOINTER | TYPEFLAG_HASPOINTER))
            stginfo->flags |= TYPEFLAG_HASPOINTER;
        info->flags |= DICTFLAG_FINAL; /* mark field type final */

        if (-1 == PyObject_SetAttr(type, prop->name, prop_obj)) {
            goto error;
        }
    }

    stginfo->ffi_type_pointer.alignment = Py_SAFE_DOWNCAST(total_align,
                                                           Py_ssize_t,
                                                           unsigned short);
    stginfo->ffi_type_pointer.size = total_size;

    stginfo->size = total_size;
    stginfo->align = total_align;
    stginfo->length = ffi_ofs + len;

/*
 * The value of MAX_STRUCT_SIZE depends on the platform Python is running on.
 */
#if defined(__aarch64__) || defined(__arm__) || defined(_M_ARM64) || defined(__sparc__)
#  define MAX_STRUCT_SIZE 32
#elif defined(__powerpc64__)
#  define MAX_STRUCT_SIZE 64
#else
#  define MAX_STRUCT_SIZE 16
#endif

    if (arrays_seen && (total_size <= MAX_STRUCT_SIZE)) {
        /*
         * See bpo-22273 and gh-110190. Arrays are normally treated as
         * pointers, which is fine when an array name is being passed as
         * parameter, but not when passing structures by value that contain
         * arrays.
         * Small structures passed by value are passed in registers, and in
         * order to do this, libffi needs to know the true type of the array
         * members of structs. Treating them as pointers breaks things.
         *
         * Small structures have different sizes depending on the platform
         * where Python is running on:
         *
         *      * x86-64: 16 bytes or less
         *      * Arm platforms (both 32 and 64 bit): 32 bytes or less
         *      * PowerPC 64 Little Endian: 64 bytes or less
         *
         * In that case, there can't be more than 16, 32 or 64 elements after
         * unrolling arrays, as we (will) disallow bitfields.
         * So we can collect the true ffi_type values in a fixed-size local
         * array on the stack and, if any arrays were seen, replace the
         * ffi_type_pointer.elements with a more accurate set, to allow
         * libffi to marshal them into registers correctly.
         * It means one more loop over the fields, but if we got here,
         * the structure is small, so there aren't too many of those.
         *
         * Although the passing in registers is specific to the above
         * platforms, the array-in-struct vs. pointer problem is general.
         * But we restrict the type transformation to small structs
         * nonetheless.
         *
         * Note that although a union may be small in terms of memory usage, it
         * could contain many overlapping declarations of arrays, e.g.
         *
         * union {
         *     unsigned int_8 foo [16];
         *     unsigned uint_8 bar [16];
         *     unsigned int_16 baz[8];
         *     unsigned uint_16 bozz[8];
         *     unsigned int_32 fizz[4];
         *     unsigned uint_32 buzz[4];
         * }
         *
         * which is still only 16 bytes in size. We need to convert this into
         * the following equivalent for libffi:
         *
         * union {
         *     struct { int_8 e1; int_8 e2; ... int_8 e_16; } f1;
         *     struct { uint_8 e1; uint_8 e2; ... uint_8 e_16; } f2;
         *     struct { int_16 e1; int_16 e2; ... int_16 e_8; } f3;
         *     struct { uint_16 e1; uint_16 e2; ... uint_16 e_8; } f4;
         *     struct { int_32 e1; int_32 e2; ... int_32 e_4; } f5;
         *     struct { uint_32 e1; uint_32 e2; ... uint_32 e_4; } f6;
         * }
         *
         * The same principle applies for a struct 32 or 64 bytes in size.
         *
         * So the struct/union needs setting up as follows: all non-array
         * elements copied across as is, and all array elements replaced with
         * an equivalent struct which has as many fields as the array has
         * elements, plus one NULL pointer.
         */

        Py_ssize_t num_ffi_type_pointers = 0;  /* for the dummy fields */
        Py_ssize_t num_ffi_types = 0;  /* for the dummy structures */
        size_t alloc_size;  /* total bytes to allocate */
        void *type_block;  /* to hold all the type information needed */
        ffi_type **element_types;  /* of this struct/union */
        ffi_type **dummy_types;  /* of the dummy struct elements */
        ffi_type *structs;  /* point to struct aliases of arrays */
        Py_ssize_t element_index;  /* index into element_types for this */
        Py_ssize_t dummy_index = 0; /* index into dummy field pointers */
        Py_ssize_t struct_index = 0; /* index into dummy structs */

        /* first pass to see how much memory to allocate */
        for (Py_ssize_t i = 0; i < len; ++i) {
            PyObject *prop_obj = PyTuple_GET_ITEM(layout_fields, i); // borrowed
            assert(prop_obj);
            assert(PyType_IsSubtype(Py_TYPE(prop_obj), st->PyCField_Type));
            CFieldObject *prop = (CFieldObject *)prop_obj; // borrowed

            StgInfo *info;
            if (PyStgInfo_FromType(st, prop->proto, &info) < 0) {
                goto error;
            }
            assert(info);

            if (!PyCArrayTypeObject_Check(st, prop->proto)) {
                /* Not an array. Just need an ffi_type pointer. */
                num_ffi_type_pointers++;
            }
            else {
                /* It's an array. */
                Py_ssize_t length = info->length;

                StgInfo *einfo;
                if (PyStgInfo_FromType(st, info->proto, &einfo) < 0) {
                    goto error;
                }
                if (einfo == NULL) {
                    PyErr_Format(PyExc_TypeError,
                        "second item in _fields_ tuple (index %zd) must be a C type",
                        i);
                    goto error;
                }
                /*
                 * We need one extra ffi_type to hold the struct, and one
                 * ffi_type pointer per array element + one for a NULL to
                 * mark the end.
                 */
                num_ffi_types++;
                num_ffi_type_pointers += length + 1;
            }
        }

        /*
         * At this point, we know we need storage for some ffi_types and some
         * ffi_type pointers. We'll allocate these in one block.
         * There are three sub-blocks of information: the ffi_type pointers to
         * this structure/union's elements, the ffi_type_pointers to the
         * dummy fields standing in for array elements, and the
         * ffi_types representing the dummy structures.
         */
        alloc_size = (ffi_ofs + 1 + len + num_ffi_type_pointers) * sizeof(ffi_type *) +
                        num_ffi_types * sizeof(ffi_type);
        type_block = PyMem_Malloc(alloc_size);

        if (type_block == NULL) {
            PyErr_NoMemory();
            goto error;
        }
        /*
         * the first block takes up ffi_ofs + len + 1 which is the pointers *
         * for this struct/union. The second block takes up
         * num_ffi_type_pointers, so the sum of these is ffi_ofs + len + 1 +
         * num_ffi_type_pointers as allocated above. The last bit is the
         * num_ffi_types structs.
         */
        element_types = (ffi_type **) type_block;
        dummy_types = &element_types[ffi_ofs + len + 1];
        structs = (ffi_type *) &dummy_types[num_ffi_type_pointers];

        if (num_ffi_types > 0) {
            memset(structs, 0, num_ffi_types * sizeof(ffi_type));
        }
        if (ffi_ofs && (baseinfo != NULL)) {
            memcpy(element_types,
                baseinfo->ffi_type_pointer.elements,
                ffi_ofs * sizeof(ffi_type *));
        }
        element_index = ffi_ofs;

        /* second pass to actually set the type pointers */
        for (Py_ssize_t i = 0; i < len; ++i) {
            PyObject *prop_obj = PyTuple_GET_ITEM(layout_fields, i); // borrowed
            assert(prop_obj);
            assert(PyType_IsSubtype(Py_TYPE(prop_obj), st->PyCField_Type));
            CFieldObject *prop = (CFieldObject *)prop_obj; // borrowed

            StgInfo *info;
            if (PyStgInfo_FromType(st, prop->proto, &info) < 0) {
                PyMem_Free(type_block);
                goto error;
            }
            assert(info);

            assert(element_index < (ffi_ofs + len)); /* will be used below */
            if (!PyCArrayTypeObject_Check(st, prop->proto)) {
                /* Not an array. Just copy over the element ffi_type. */
                element_types[element_index++] = &info->ffi_type_pointer;
            }
            else {
                Py_ssize_t length = info->length;
                StgInfo *einfo;
                if (PyStgInfo_FromType(st, info->proto, &einfo) < 0) {
                    PyMem_Free(type_block);
                    goto error;
                }
                if (einfo == NULL) {
                    PyMem_Free(type_block);
                    PyErr_Format(PyExc_TypeError,
                                 "second item in _fields_ tuple (index %zd) must be a C type",
                                 i);
                    goto error;
                }
                element_types[element_index++] = &structs[struct_index];
                structs[struct_index].size = length * einfo->ffi_type_pointer.size;
                structs[struct_index].alignment = einfo->ffi_type_pointer.alignment;
                structs[struct_index].type = FFI_TYPE_STRUCT;
                structs[struct_index].elements = &dummy_types[dummy_index];
                ++struct_index;
                /* Copy over the element's type, length times. */
                while (length > 0) {
                    assert(dummy_index < (num_ffi_type_pointers));
                    dummy_types[dummy_index++] = &einfo->ffi_type_pointer;
                    length--;
                }
                assert(dummy_index < (num_ffi_type_pointers));
                dummy_types[dummy_index++] = NULL;
            }
        }

        element_types[element_index] = NULL;
        /*
         * Replace the old elements with the new, taking into account
         * base class elements where necessary.
         */
        assert(stginfo->ffi_type_pointer.elements);
        PyMem_Free(stginfo->ffi_type_pointer.elements);
        stginfo->ffi_type_pointer.elements = element_types;
    }

    /* We did check that this flag was NOT set above, it must not
       have been set until now. */
    if (stginfo->flags & DICTFLAG_FINAL) {
        PyErr_SetString(PyExc_AttributeError,
                        "Structure or union cannot contain itself");
        goto error;
    }
    stginfo->flags |= DICTFLAG_FINAL;

    retval = MakeAnonFields(type);
error:
    Py_XDECREF(layout_fields);
    Py_XDECREF(layout);
    Py_XDECREF(format_spec_obj);
    return retval;
}


================================================
File: /Modules/_ctypes/clinic/_ctypes.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

#if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
#  include "pycore_runtime.h"     // _Py_SINGLETON()
#endif
#include "pycore_abstract.h"      // _PyNumber_Index()
#include "pycore_critical_section.h"// Py_BEGIN_CRITICAL_SECTION()
#include "pycore_modsupport.h"    // _PyArg_UnpackKeywords()

PyDoc_STRVAR(_ctypes_CType_Type___sizeof____doc__,
"__sizeof__($self, /)\n"
"--\n"
"\n"
"Return memory consumption of the type object.");

#define _CTYPES_CTYPE_TYPE___SIZEOF___METHODDEF    \
    {"__sizeof__", _PyCFunction_CAST(_ctypes_CType_Type___sizeof__), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, _ctypes_CType_Type___sizeof____doc__},

static PyObject *
_ctypes_CType_Type___sizeof___impl(PyObject *self, PyTypeObject *cls);

static PyObject *
_ctypes_CType_Type___sizeof__(PyObject *self, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "__sizeof__() takes no arguments");
        return NULL;
    }
    return _ctypes_CType_Type___sizeof___impl(self, cls);
}

PyDoc_STRVAR(CDataType_from_address__doc__,
"from_address($self, value, /)\n"
"--\n"
"\n"
"C.from_address(integer) -> C instance\n"
"\n"
"Access a C instance at the specified address.");

#define CDATATYPE_FROM_ADDRESS_METHODDEF    \
    {"from_address", _PyCFunction_CAST(CDataType_from_address), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, CDataType_from_address__doc__},

static PyObject *
CDataType_from_address_impl(PyObject *type, PyTypeObject *cls,
                            PyObject *value);

static PyObject *
CDataType_from_address(PyObject *type, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "from_address",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *value;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 1, /*maxpos*/ 1, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    value = args[0];
    return_value = CDataType_from_address_impl(type, cls, value);

exit:
    return return_value;
}

PyDoc_STRVAR(CDataType_from_buffer__doc__,
"from_buffer($self, obj, offset=0, /)\n"
"--\n"
"\n"
"C.from_buffer(object, offset=0) -> C instance\n"
"\n"
"Create a C instance from a writeable buffer.");

#define CDATATYPE_FROM_BUFFER_METHODDEF    \
    {"from_buffer", _PyCFunction_CAST(CDataType_from_buffer), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, CDataType_from_buffer__doc__},

static PyObject *
CDataType_from_buffer_impl(PyObject *type, PyTypeObject *cls, PyObject *obj,
                           Py_ssize_t offset);

static PyObject *
CDataType_from_buffer(PyObject *type, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", "", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "from_buffer",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[2];
    PyObject *obj;
    Py_ssize_t offset = 0;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 1, /*maxpos*/ 2, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    obj = args[0];
    if (nargs < 2) {
        goto skip_optional_posonly;
    }
    {
        Py_ssize_t ival = -1;
        PyObject *iobj = _PyNumber_Index(args[1]);
        if (iobj != NULL) {
            ival = PyLong_AsSsize_t(iobj);
            Py_DECREF(iobj);
        }
        if (ival == -1 && PyErr_Occurred()) {
            goto exit;
        }
        offset = ival;
    }
skip_optional_posonly:
    return_value = CDataType_from_buffer_impl(type, cls, obj, offset);

exit:
    return return_value;
}

PyDoc_STRVAR(CDataType_from_buffer_copy__doc__,
"from_buffer_copy($self, buffer, offset=0, /)\n"
"--\n"
"\n"
"C.from_buffer_copy(object, offset=0) -> C instance\n"
"\n"
"Create a C instance from a readable buffer.");

#define CDATATYPE_FROM_BUFFER_COPY_METHODDEF    \
    {"from_buffer_copy", _PyCFunction_CAST(CDataType_from_buffer_copy), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, CDataType_from_buffer_copy__doc__},

static PyObject *
CDataType_from_buffer_copy_impl(PyObject *type, PyTypeObject *cls,
                                Py_buffer *buffer, Py_ssize_t offset);

static PyObject *
CDataType_from_buffer_copy(PyObject *type, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", "", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "from_buffer_copy",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[2];
    Py_buffer buffer = {NULL, NULL};
    Py_ssize_t offset = 0;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 1, /*maxpos*/ 2, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (PyObject_GetBuffer(args[0], &buffer, PyBUF_SIMPLE) != 0) {
        goto exit;
    }
    if (nargs < 2) {
        goto skip_optional_posonly;
    }
    {
        Py_ssize_t ival = -1;
        PyObject *iobj = _PyNumber_Index(args[1]);
        if (iobj != NULL) {
            ival = PyLong_AsSsize_t(iobj);
            Py_DECREF(iobj);
        }
        if (ival == -1 && PyErr_Occurred()) {
            goto exit;
        }
        offset = ival;
    }
skip_optional_posonly:
    return_value = CDataType_from_buffer_copy_impl(type, cls, &buffer, offset);

exit:
    /* Cleanup for buffer */
    if (buffer.obj) {
       PyBuffer_Release(&buffer);
    }

    return return_value;
}

PyDoc_STRVAR(CDataType_in_dll__doc__,
"in_dll($self, dll, name, /)\n"
"--\n"
"\n"
"C.in_dll(dll, name) -> C instance\n"
"\n"
"Access a C instance in a dll.");

#define CDATATYPE_IN_DLL_METHODDEF    \
    {"in_dll", _PyCFunction_CAST(CDataType_in_dll), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, CDataType_in_dll__doc__},

static PyObject *
CDataType_in_dll_impl(PyObject *type, PyTypeObject *cls, PyObject *dll,
                      const char *name);

static PyObject *
CDataType_in_dll(PyObject *type, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", "", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "in_dll",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[2];
    PyObject *dll;
    const char *name;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 2, /*maxpos*/ 2, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    dll = args[0];
    if (!PyUnicode_Check(args[1])) {
        _PyArg_BadArgument("in_dll", "argument 2", "str", args[1]);
        goto exit;
    }
    Py_ssize_t name_length;
    name = PyUnicode_AsUTF8AndSize(args[1], &name_length);
    if (name == NULL) {
        goto exit;
    }
    if (strlen(name) != (size_t)name_length) {
        PyErr_SetString(PyExc_ValueError, "embedded null character");
        goto exit;
    }
    return_value = CDataType_in_dll_impl(type, cls, dll, name);

exit:
    return return_value;
}

PyDoc_STRVAR(CDataType_from_param__doc__,
"from_param($self, value, /)\n"
"--\n"
"\n"
"Convert a Python object into a function call parameter.");

#define CDATATYPE_FROM_PARAM_METHODDEF    \
    {"from_param", _PyCFunction_CAST(CDataType_from_param), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, CDataType_from_param__doc__},

static PyObject *
CDataType_from_param_impl(PyObject *type, PyTypeObject *cls, PyObject *value);

static PyObject *
CDataType_from_param(PyObject *type, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "from_param",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *value;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 1, /*maxpos*/ 1, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    value = args[0];
    return_value = CDataType_from_param_impl(type, cls, value);

exit:
    return return_value;
}

PyDoc_STRVAR(PyCPointerType_set_type__doc__,
"set_type($self, type, /)\n"
"--\n"
"\n");

#define PYCPOINTERTYPE_SET_TYPE_METHODDEF    \
    {"set_type", _PyCFunction_CAST(PyCPointerType_set_type), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, PyCPointerType_set_type__doc__},

static PyObject *
PyCPointerType_set_type_impl(PyTypeObject *self, PyTypeObject *cls,
                             PyObject *type);

static PyObject *
PyCPointerType_set_type(PyTypeObject *self, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "set_type",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *type;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 1, /*maxpos*/ 1, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    type = args[0];
    return_value = PyCPointerType_set_type_impl(self, cls, type);

exit:
    return return_value;
}

PyDoc_STRVAR(PyCPointerType_from_param__doc__,
"from_param($self, value, /)\n"
"--\n"
"\n"
"Convert a Python object into a function call parameter.");

#define PYCPOINTERTYPE_FROM_PARAM_METHODDEF    \
    {"from_param", _PyCFunction_CAST(PyCPointerType_from_param), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, PyCPointerType_from_param__doc__},

static PyObject *
PyCPointerType_from_param_impl(PyObject *type, PyTypeObject *cls,
                               PyObject *value);

static PyObject *
PyCPointerType_from_param(PyObject *type, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "from_param",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *value;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 1, /*maxpos*/ 1, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    value = args[0];
    return_value = PyCPointerType_from_param_impl(type, cls, value);

exit:
    return return_value;
}

PyDoc_STRVAR(c_wchar_p_from_param__doc__,
"from_param($self, value, /)\n"
"--\n"
"\n");

#define C_WCHAR_P_FROM_PARAM_METHODDEF    \
    {"from_param", _PyCFunction_CAST(c_wchar_p_from_param), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, c_wchar_p_from_param__doc__},

static PyObject *
c_wchar_p_from_param_impl(PyObject *type, PyTypeObject *cls, PyObject *value);

static PyObject *
c_wchar_p_from_param(PyObject *type, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "from_param",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *value;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 1, /*maxpos*/ 1, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    value = args[0];
    return_value = c_wchar_p_from_param_impl(type, cls, value);

exit:
    return return_value;
}

PyDoc_STRVAR(c_char_p_from_param__doc__,
"from_param($self, value, /)\n"
"--\n"
"\n");

#define C_CHAR_P_FROM_PARAM_METHODDEF    \
    {"from_param", _PyCFunction_CAST(c_char_p_from_param), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, c_char_p_from_param__doc__},

static PyObject *
c_char_p_from_param_impl(PyObject *type, PyTypeObject *cls, PyObject *value);

static PyObject *
c_char_p_from_param(PyObject *type, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "from_param",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *value;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 1, /*maxpos*/ 1, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    value = args[0];
    return_value = c_char_p_from_param_impl(type, cls, value);

exit:
    return return_value;
}

PyDoc_STRVAR(c_void_p_from_param__doc__,
"from_param($self, value, /)\n"
"--\n"
"\n");

#define C_VOID_P_FROM_PARAM_METHODDEF    \
    {"from_param", _PyCFunction_CAST(c_void_p_from_param), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, c_void_p_from_param__doc__},

static PyObject *
c_void_p_from_param_impl(PyObject *type, PyTypeObject *cls, PyObject *value);

static PyObject *
c_void_p_from_param(PyObject *type, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "from_param",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *value;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 1, /*maxpos*/ 1, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    value = args[0];
    return_value = c_void_p_from_param_impl(type, cls, value);

exit:
    return return_value;
}

PyDoc_STRVAR(PyCSimpleType_from_param__doc__,
"from_param($self, value, /)\n"
"--\n"
"\n"
"Convert a Python object into a function call parameter.");

#define PYCSIMPLETYPE_FROM_PARAM_METHODDEF    \
    {"from_param", _PyCFunction_CAST(PyCSimpleType_from_param), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, PyCSimpleType_from_param__doc__},

static PyObject *
PyCSimpleType_from_param_impl(PyObject *type, PyTypeObject *cls,
                              PyObject *value);

static PyObject *
PyCSimpleType_from_param(PyObject *type, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
    #  define KWTUPLE (PyObject *)&_Py_SINGLETON(tuple_empty)
    #else
    #  define KWTUPLE NULL
    #endif

    static const char * const _keywords[] = {"", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "from_param",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    PyObject *value;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 1, /*maxpos*/ 1, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    value = args[0];
    return_value = PyCSimpleType_from_param_impl(type, cls, value);

exit:
    return return_value;
}

PyDoc_STRVAR(PyCData_reduce__doc__,
"__reduce__($self, /)\n"
"--\n"
"\n");

#define PYCDATA_REDUCE_METHODDEF    \
    {"__reduce__", _PyCFunction_CAST(PyCData_reduce), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, PyCData_reduce__doc__},

static PyObject *
PyCData_reduce_impl(PyObject *myself, PyTypeObject *cls);

static PyObject *
PyCData_reduce(PyObject *myself, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "__reduce__() takes no arguments");
        return NULL;
    }
    return PyCData_reduce_impl(myself, cls);
}

#if !defined(_ctypes_CFuncPtr_errcheck_DOCSTR)
#  define _ctypes_CFuncPtr_errcheck_DOCSTR NULL
#endif
#if defined(_CTYPES_CFUNCPTR_ERRCHECK_GETSETDEF)
#  undef _CTYPES_CFUNCPTR_ERRCHECK_GETSETDEF
#  define _CTYPES_CFUNCPTR_ERRCHECK_GETSETDEF {"errcheck", (getter)_ctypes_CFuncPtr_errcheck_get, (setter)_ctypes_CFuncPtr_errcheck_set, _ctypes_CFuncPtr_errcheck_DOCSTR},
#else
#  define _CTYPES_CFUNCPTR_ERRCHECK_GETSETDEF {"errcheck", NULL, (setter)_ctypes_CFuncPtr_errcheck_set, NULL},
#endif

static int
_ctypes_CFuncPtr_errcheck_set_impl(PyCFuncPtrObject *self, PyObject *value);

static int
_ctypes_CFuncPtr_errcheck_set(PyCFuncPtrObject *self, PyObject *value, void *Py_UNUSED(context))
{
    int return_value;

    Py_BEGIN_CRITICAL_SECTION(self);
    return_value = _ctypes_CFuncPtr_errcheck_set_impl(self, value);
    Py_END_CRITICAL_SECTION();

    return return_value;
}

PyDoc_STRVAR(_ctypes_CFuncPtr_errcheck__doc__,
"a function to check for errors");
#if defined(_ctypes_CFuncPtr_errcheck_DOCSTR)
#   undef _ctypes_CFuncPtr_errcheck_DOCSTR
#endif
#define _ctypes_CFuncPtr_errcheck_DOCSTR _ctypes_CFuncPtr_errcheck__doc__

#if !defined(_ctypes_CFuncPtr_errcheck_DOCSTR)
#  define _ctypes_CFuncPtr_errcheck_DOCSTR NULL
#endif
#if defined(_CTYPES_CFUNCPTR_ERRCHECK_GETSETDEF)
#  undef _CTYPES_CFUNCPTR_ERRCHECK_GETSETDEF
#  define _CTYPES_CFUNCPTR_ERRCHECK_GETSETDEF {"errcheck", (getter)_ctypes_CFuncPtr_errcheck_get, (setter)_ctypes_CFuncPtr_errcheck_set, _ctypes_CFuncPtr_errcheck_DOCSTR},
#else
#  define _CTYPES_CFUNCPTR_ERRCHECK_GETSETDEF {"errcheck", (getter)_ctypes_CFuncPtr_errcheck_get, NULL, _ctypes_CFuncPtr_errcheck_DOCSTR},
#endif

static PyObject *
_ctypes_CFuncPtr_errcheck_get_impl(PyCFuncPtrObject *self);

static PyObject *
_ctypes_CFuncPtr_errcheck_get(PyCFuncPtrObject *self, void *Py_UNUSED(context))
{
    PyObject *return_value = NULL;

    Py_BEGIN_CRITICAL_SECTION(self);
    return_value = _ctypes_CFuncPtr_errcheck_get_impl(self);
    Py_END_CRITICAL_SECTION();

    return return_value;
}

#if !defined(_ctypes_CFuncPtr_restype_DOCSTR)
#  define _ctypes_CFuncPtr_restype_DOCSTR NULL
#endif
#if defined(_CTYPES_CFUNCPTR_RESTYPE_GETSETDEF)
#  undef _CTYPES_CFUNCPTR_RESTYPE_GETSETDEF
#  define _CTYPES_CFUNCPTR_RESTYPE_GETSETDEF {"restype", (getter)_ctypes_CFuncPtr_restype_get, (setter)_ctypes_CFuncPtr_restype_set, _ctypes_CFuncPtr_restype_DOCSTR},
#else
#  define _CTYPES_CFUNCPTR_RESTYPE_GETSETDEF {"restype", NULL, (setter)_ctypes_CFuncPtr_restype_set, NULL},
#endif

static int
_ctypes_CFuncPtr_restype_set_impl(PyCFuncPtrObject *self, PyObject *value);

static int
_ctypes_CFuncPtr_restype_set(PyCFuncPtrObject *self, PyObject *value, void *Py_UNUSED(context))
{
    int return_value;

    Py_BEGIN_CRITICAL_SECTION(self);
    return_value = _ctypes_CFuncPtr_restype_set_impl(self, value);
    Py_END_CRITICAL_SECTION();

    return return_value;
}

PyDoc_STRVAR(_ctypes_CFuncPtr_restype__doc__,
"specify the result type");
#if defined(_ctypes_CFuncPtr_restype_DOCSTR)
#   undef _ctypes_CFuncPtr_restype_DOCSTR
#endif
#define _ctypes_CFuncPtr_restype_DOCSTR _ctypes_CFuncPtr_restype__doc__

#if !defined(_ctypes_CFuncPtr_restype_DOCSTR)
#  define _ctypes_CFuncPtr_restype_DOCSTR NULL
#endif
#if defined(_CTYPES_CFUNCPTR_RESTYPE_GETSETDEF)
#  undef _CTYPES_CFUNCPTR_RESTYPE_GETSETDEF
#  define _CTYPES_CFUNCPTR_RESTYPE_GETSETDEF {"restype", (getter)_ctypes_CFuncPtr_restype_get, (setter)_ctypes_CFuncPtr_restype_set, _ctypes_CFuncPtr_restype_DOCSTR},
#else
#  define _CTYPES_CFUNCPTR_RESTYPE_GETSETDEF {"restype", (getter)_ctypes_CFuncPtr_restype_get, NULL, _ctypes_CFuncPtr_restype_DOCSTR},
#endif

static PyObject *
_ctypes_CFuncPtr_restype_get_impl(PyCFuncPtrObject *self);

static PyObject *
_ctypes_CFuncPtr_restype_get(PyCFuncPtrObject *self, void *Py_UNUSED(context))
{
    PyObject *return_value = NULL;

    Py_BEGIN_CRITICAL_SECTION(self);
    return_value = _ctypes_CFuncPtr_restype_get_impl(self);
    Py_END_CRITICAL_SECTION();

    return return_value;
}

#if !defined(_ctypes_CFuncPtr_argtypes_DOCSTR)
#  define _ctypes_CFuncPtr_argtypes_DOCSTR NULL
#endif
#if defined(_CTYPES_CFUNCPTR_ARGTYPES_GETSETDEF)
#  undef _CTYPES_CFUNCPTR_ARGTYPES_GETSETDEF
#  define _CTYPES_CFUNCPTR_ARGTYPES_GETSETDEF {"argtypes", (getter)_ctypes_CFuncPtr_argtypes_get, (setter)_ctypes_CFuncPtr_argtypes_set, _ctypes_CFuncPtr_argtypes_DOCSTR},
#else
#  define _CTYPES_CFUNCPTR_ARGTYPES_GETSETDEF {"argtypes", NULL, (setter)_ctypes_CFuncPtr_argtypes_set, NULL},
#endif

static int
_ctypes_CFuncPtr_argtypes_set_impl(PyCFuncPtrObject *self, PyObject *value);

static int
_ctypes_CFuncPtr_argtypes_set(PyCFuncPtrObject *self, PyObject *value, void *Py_UNUSED(context))
{
    int return_value;

    Py_BEGIN_CRITICAL_SECTION(self);
    return_value = _ctypes_CFuncPtr_argtypes_set_impl(self, value);
    Py_END_CRITICAL_SECTION();

    return return_value;
}

PyDoc_STRVAR(_ctypes_CFuncPtr_argtypes__doc__,
"specify the argument types");
#if defined(_ctypes_CFuncPtr_argtypes_DOCSTR)
#   undef _ctypes_CFuncPtr_argtypes_DOCSTR
#endif
#define _ctypes_CFuncPtr_argtypes_DOCSTR _ctypes_CFuncPtr_argtypes__doc__

#if !defined(_ctypes_CFuncPtr_argtypes_DOCSTR)
#  define _ctypes_CFuncPtr_argtypes_DOCSTR NULL
#endif
#if defined(_CTYPES_CFUNCPTR_ARGTYPES_GETSETDEF)
#  undef _CTYPES_CFUNCPTR_ARGTYPES_GETSETDEF
#  define _CTYPES_CFUNCPTR_ARGTYPES_GETSETDEF {"argtypes", (getter)_ctypes_CFuncPtr_argtypes_get, (setter)_ctypes_CFuncPtr_argtypes_set, _ctypes_CFuncPtr_argtypes_DOCSTR},
#else
#  define _CTYPES_CFUNCPTR_ARGTYPES_GETSETDEF {"argtypes", (getter)_ctypes_CFuncPtr_argtypes_get, NULL, _ctypes_CFuncPtr_argtypes_DOCSTR},
#endif

static PyObject *
_ctypes_CFuncPtr_argtypes_get_impl(PyCFuncPtrObject *self);

static PyObject *
_ctypes_CFuncPtr_argtypes_get(PyCFuncPtrObject *self, void *Py_UNUSED(context))
{
    PyObject *return_value = NULL;

    Py_BEGIN_CRITICAL_SECTION(self);
    return_value = _ctypes_CFuncPtr_argtypes_get_impl(self);
    Py_END_CRITICAL_SECTION();

    return return_value;
}

PyDoc_STRVAR(Simple_from_outparm__doc__,
"__ctypes_from_outparam__($self, /)\n"
"--\n"
"\n");

#define SIMPLE_FROM_OUTPARM_METHODDEF    \
    {"__ctypes_from_outparam__", _PyCFunction_CAST(Simple_from_outparm), METH_METHOD|METH_FASTCALL|METH_KEYWORDS, Simple_from_outparm__doc__},

static PyObject *
Simple_from_outparm_impl(PyObject *self, PyTypeObject *cls);

static PyObject *
Simple_from_outparm(PyObject *self, PyTypeObject *cls, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    if (nargs || (kwnames && PyTuple_GET_SIZE(kwnames))) {
        PyErr_SetString(PyExc_TypeError, "__ctypes_from_outparam__() takes no arguments");
        return NULL;
    }
    return Simple_from_outparm_impl(self, cls);
}
/*[clinic end generated code: output=cb3583522a2c5ce5 input=a9049054013a1b77]*/


================================================
File: /Modules/_ctypes/clinic/callproc.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

PyDoc_STRVAR(create_pointer_type__doc__,
"POINTER($module, type, /)\n"
"--\n"
"\n"
"Create and return a new ctypes pointer type.\n"
"\n"
"  type\n"
"    A ctypes type.\n"
"\n"
"Pointer types are cached and reused internally,\n"
"so calling this function repeatedly is cheap.");

#define CREATE_POINTER_TYPE_METHODDEF    \
    {"POINTER", (PyCFunction)create_pointer_type, METH_O, create_pointer_type__doc__},

PyDoc_STRVAR(create_pointer_inst__doc__,
"pointer($module, obj, /)\n"
"--\n"
"\n"
"Create a new pointer instance, pointing to \'obj\'.\n"
"\n"
"The returned object is of the type POINTER(type(obj)). Note that if you\n"
"just want to pass a pointer to an object to a foreign function call, you\n"
"should use byref(obj) which is much faster.");

#define CREATE_POINTER_INST_METHODDEF    \
    {"pointer", (PyCFunction)create_pointer_inst, METH_O, create_pointer_inst__doc__},
/*[clinic end generated code: output=51b311ea369e5adf input=a9049054013a1b77]*/


================================================
File: /Modules/_ctypes/clinic/cfield.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

#if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
#  include "pycore_gc.h"          // PyGC_Head
#  include "pycore_runtime.h"     // _Py_ID()
#endif
#include "pycore_abstract.h"      // _PyNumber_Index()
#include "pycore_modsupport.h"    // _PyArg_UnpackKeywords()

static PyObject *
PyCField_new_impl(PyTypeObject *type, PyObject *name, PyObject *proto,
                  Py_ssize_t size, Py_ssize_t offset, Py_ssize_t index,
                  PyObject *bit_size_obj);

static PyObject *
PyCField_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 6
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(name), &_Py_ID(type), &_Py_ID(size), &_Py_ID(offset), &_Py_ID(index), &_Py_ID(bit_size), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"name", "type", "size", "offset", "index", "bit_size", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "CField",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[6];
    PyObject * const *fastargs;
    Py_ssize_t nargs = PyTuple_GET_SIZE(args);
    Py_ssize_t noptargs = nargs + (kwargs ? PyDict_GET_SIZE(kwargs) : 0) - 5;
    PyObject *name;
    PyObject *proto;
    Py_ssize_t size;
    Py_ssize_t offset;
    Py_ssize_t index;
    PyObject *bit_size_obj = Py_None;

    fastargs = _PyArg_UnpackKeywords(_PyTuple_CAST(args)->ob_item, nargs, kwargs, NULL, &_parser,
            /*minpos*/ 5, /*maxpos*/ 6, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!fastargs) {
        goto exit;
    }
    if (!PyUnicode_Check(fastargs[0])) {
        _PyArg_BadArgument("CField", "argument 'name'", "str", fastargs[0]);
        goto exit;
    }
    name = fastargs[0];
    proto = fastargs[1];
    {
        Py_ssize_t ival = -1;
        PyObject *iobj = _PyNumber_Index(fastargs[2]);
        if (iobj != NULL) {
            ival = PyLong_AsSsize_t(iobj);
            Py_DECREF(iobj);
        }
        if (ival == -1 && PyErr_Occurred()) {
            goto exit;
        }
        size = ival;
    }
    {
        Py_ssize_t ival = -1;
        PyObject *iobj = _PyNumber_Index(fastargs[3]);
        if (iobj != NULL) {
            ival = PyLong_AsSsize_t(iobj);
            Py_DECREF(iobj);
        }
        if (ival == -1 && PyErr_Occurred()) {
            goto exit;
        }
        offset = ival;
    }
    {
        Py_ssize_t ival = -1;
        PyObject *iobj = _PyNumber_Index(fastargs[4]);
        if (iobj != NULL) {
            ival = PyLong_AsSsize_t(iobj);
            Py_DECREF(iobj);
        }
        if (ival == -1 && PyErr_Occurred()) {
            goto exit;
        }
        index = ival;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    bit_size_obj = fastargs[5];
skip_optional_pos:
    return_value = PyCField_new_impl(type, name, proto, size, offset, index, bit_size_obj);

exit:
    return return_value;
}
/*[clinic end generated code: output=6b450bdd861571e7 input=a9049054013a1b77]*/


================================================
File: /Modules/_decimal/README.txt
================================================


About
=====

_decimal.c is a wrapper for the libmpdec library. libmpdec is a fast C
library for correctly-rounded arbitrary precision decimal floating point
arithmetic. It is a complete implementation of Mike Cowlishaw/IBM's
General Decimal Arithmetic Specification.


Build process for the module
============================

As usual, the build process for _decimal.so is driven by setup.py in the top
level directory. setup.py autodetects the following build configurations:

   1) x64         - 64-bit Python, x86_64 processor (AMD, Intel)

   2) uint128     - 64-bit Python, compiler provides __uint128_t (gcc)

   3) ansi64      - 64-bit Python, ANSI C

   4) ppro        - 32-bit Python, x86 CPU, PentiumPro or later

   5) ansi32      - 32-bit Python, ANSI C

   6) ansi-legacy - 32-bit Python, compiler without uint64_t

   7) universal   - Mac OS only (multi-arch)


It is possible to override autodetection by exporting:

   PYTHON_DECIMAL_WITH_MACHINE=value, where value is one of the above options.


NOTE
====

decimal.so is not built from a static libmpdec.a since doing so led to
failures on AIX (user report) and Windows (mixing static and dynamic CRTs
causes locale problems and more).





================================================
File: /Modules/_decimal/docstrings.h
================================================
/*
 * Copyright (c) 2001 Python Software Foundation. All Rights Reserved.
 * Modified and extended by Stefan Krah.
 */


#ifndef DOCSTRINGS_H
#define DOCSTRINGS_H


#include "pymacro.h"


/******************************************************************************/
/*                                Module                                      */
/******************************************************************************/


PyDoc_STRVAR(doc__decimal,
"C decimal arithmetic module");

PyDoc_STRVAR(doc_getcontext,
"getcontext($module, /)\n--\n\n\
Get the current default context.\n\
\n");

PyDoc_STRVAR(doc_setcontext,
"setcontext($module, context, /)\n--\n\n\
Set a new default context.\n\
\n");

PyDoc_STRVAR(doc_localcontext,
"localcontext($module, /, ctx=None, **kwargs)\n--\n\n\
Return a context manager that will set the default context to a copy of ctx\n\
on entry to the with-statement and restore the previous default context when\n\
exiting the with-statement. If no context is specified, a copy of the current\n\
default context is used.\n\
\n");

#ifdef EXTRA_FUNCTIONALITY
PyDoc_STRVAR(doc_ieee_context,
"IEEEContext($module, bits, /)\n--\n\n\
Return a context object initialized to the proper values for one of the\n\
IEEE interchange formats.  The argument must be a multiple of 32 and less\n\
than IEEE_CONTEXT_MAX_BITS.  For the most common values, the constants\n\
DECIMAL32, DECIMAL64 and DECIMAL128 are provided.\n\
\n");
#endif


/******************************************************************************/
/*                       Decimal Object and Methods                           */
/******************************************************************************/

PyDoc_STRVAR(doc_decimal,
"Decimal(value=\"0\", context=None)\n--\n\n\
Construct a new Decimal object. 'value' can be an integer, string, tuple,\n\
or another Decimal object. If no value is given, return Decimal('0'). The\n\
context does not affect the conversion and is only passed to determine if\n\
the InvalidOperation trap is active.\n\
\n");

PyDoc_STRVAR(doc_adjusted,
"adjusted($self, /)\n--\n\n\
Return the adjusted exponent of the number.  Defined as exp + digits - 1.\n\
\n");

PyDoc_STRVAR(doc_as_tuple,
"as_tuple($self, /)\n--\n\n\
Return a tuple representation of the number.\n\
\n");

PyDoc_STRVAR(doc_as_integer_ratio,
"as_integer_ratio($self, /)\n--\n\n\
Decimal.as_integer_ratio() -> (int, int)\n\
\n\
Return a pair of integers, whose ratio is exactly equal to the original\n\
Decimal and with a positive denominator. The ratio is in lowest terms.\n\
Raise OverflowError on infinities and a ValueError on NaNs.\n\
\n");

PyDoc_STRVAR(doc_canonical,
"canonical($self, /)\n--\n\n\
Return the canonical encoding of the argument.  Currently, the encoding\n\
of a Decimal instance is always canonical, so this operation returns its\n\
argument unchanged.\n\
\n");

PyDoc_STRVAR(doc_compare,
"compare($self, /, other, context=None)\n--\n\n\
Compare self to other.  Return a decimal value:\n\
\n\
    a or b is a NaN ==> Decimal('NaN')\n\
    a < b           ==> Decimal('-1')\n\
    a == b          ==> Decimal('0')\n\
    a > b           ==> Decimal('1')\n\
\n");

PyDoc_STRVAR(doc_compare_signal,
"compare_signal($self, /, other, context=None)\n--\n\n\
Identical to compare, except that all NaNs signal.\n\
\n");

PyDoc_STRVAR(doc_compare_total,
"compare_total($self, /, other, context=None)\n--\n\n\
Compare two operands using their abstract representation rather than\n\
their numerical value.  Similar to the compare() method, but the result\n\
gives a total ordering on Decimal instances.  Two Decimal instances with\n\
the same numeric value but different representations compare unequal\n\
in this ordering:\n\
\n\
    >>> Decimal('12.0').compare_total(Decimal('12'))\n\
    Decimal('-1')\n\
\n\
Quiet and signaling NaNs are also included in the total ordering. The result\n\
of this function is Decimal('0') if both operands have the same representation,\n\
Decimal('-1') if the first operand is lower in the total order than the second,\n\
and Decimal('1') if the first operand is higher in the total order than the\n\
second operand. See the specification for details of the total order.\n\
\n\
This operation is unaffected by context and is quiet: no flags are changed\n\
and no rounding is performed. As an exception, the C version may raise\n\
InvalidOperation if the second operand cannot be converted exactly.\n\
\n");

PyDoc_STRVAR(doc_compare_total_mag,
"compare_total_mag($self, /, other, context=None)\n--\n\n\
Compare two operands using their abstract representation rather than their\n\
value as in compare_total(), but ignoring the sign of each operand.\n\
\n\
x.compare_total_mag(y) is equivalent to x.copy_abs().compare_total(y.copy_abs()).\n\
\n\
This operation is unaffected by context and is quiet: no flags are changed\n\
and no rounding is performed. As an exception, the C version may raise\n\
InvalidOperation if the second operand cannot be converted exactly.\n\
\n");

PyDoc_STRVAR(doc_conjugate,
"conjugate($self, /)\n--\n\n\
Return self.\n\
\n");

PyDoc_STRVAR(doc_copy_abs,
"copy_abs($self, /)\n--\n\n\
Return the absolute value of the argument.  This operation is unaffected by\n\
context and is quiet: no flags are changed and no rounding is performed.\n\
\n");

PyDoc_STRVAR(doc_copy_negate,
"copy_negate($self, /)\n--\n\n\
Return the negation of the argument.  This operation is unaffected by context\n\
and is quiet: no flags are changed and no rounding is performed.\n\
\n");

PyDoc_STRVAR(doc_copy_sign,
"copy_sign($self, /, other, context=None)\n--\n\n\
Return a copy of the first operand with the sign set to be the same as the\n\
sign of the second operand. For example:\n\
\n\
    >>> Decimal('2.3').copy_sign(Decimal('-1.5'))\n\
    Decimal('-2.3')\n\
\n\
This operation is unaffected by context and is quiet: no flags are changed\n\
and no rounding is performed. As an exception, the C version may raise\n\
InvalidOperation if the second operand cannot be converted exactly.\n\
\n");

PyDoc_STRVAR(doc_exp,
"exp($self, /, context=None)\n--\n\n\
Return the value of the (natural) exponential function e**x at the given\n\
number.  The function always uses the ROUND_HALF_EVEN mode and the result\n\
is correctly rounded.\n\
\n");

PyDoc_STRVAR(doc_from_float,
"from_float($type, f, /)\n--\n\n\
Class method that converts a float to a decimal number, exactly.\n\
Since 0.1 is not exactly representable in binary floating point,\n\
Decimal.from_float(0.1) is not the same as Decimal('0.1').\n\
\n\
    >>> Decimal.from_float(0.1)\n\
    Decimal('0.1000000000000000055511151231257827021181583404541015625')\n\
    >>> Decimal.from_float(float('nan'))\n\
    Decimal('NaN')\n\
    >>> Decimal.from_float(float('inf'))\n\
    Decimal('Infinity')\n\
    >>> Decimal.from_float(float('-inf'))\n\
    Decimal('-Infinity')\n\
\n\
\n");

PyDoc_STRVAR(doc_from_number,
"from_number($type, number, /)\n--\n\n\
Class method that converts a real number to a decimal number, exactly.\n\
\n\
    >>> Decimal.from_number(314)              # int\n\
    Decimal('314')\n\
    >>> Decimal.from_number(0.1)              # float\n\
    Decimal('0.1000000000000000055511151231257827021181583404541015625')\n\
    >>> Decimal.from_number(Decimal('3.14'))  # another decimal instance\n\
    Decimal('3.14')\n\
\n\
\n");

PyDoc_STRVAR(doc_fma,
"fma($self, /, other, third, context=None)\n--\n\n\
Fused multiply-add.  Return self*other+third with no rounding of the\n\
intermediate product self*other.\n\
\n\
    >>> Decimal(2).fma(3, 5)\n\
    Decimal('11')\n\
\n\
\n");

PyDoc_STRVAR(doc_is_canonical,
"is_canonical($self, /)\n--\n\n\
Return True if the argument is canonical and False otherwise.  Currently,\n\
a Decimal instance is always canonical, so this operation always returns\n\
True.\n\
\n");

PyDoc_STRVAR(doc_is_finite,
"is_finite($self, /)\n--\n\n\
Return True if the argument is a finite number, and False if the argument\n\
is infinite or a NaN.\n\
\n");

PyDoc_STRVAR(doc_is_infinite,
"is_infinite($self, /)\n--\n\n\
Return True if the argument is either positive or negative infinity and\n\
False otherwise.\n\
\n");

PyDoc_STRVAR(doc_is_nan,
"is_nan($self, /)\n--\n\n\
Return True if the argument is a (quiet or signaling) NaN and False\n\
otherwise.\n\
\n");

PyDoc_STRVAR(doc_is_normal,
"is_normal($self, /, context=None)\n--\n\n\
Return True if the argument is a normal finite non-zero number with an\n\
adjusted exponent greater than or equal to Emin. Return False if the\n\
argument is zero, subnormal, infinite or a NaN.\n\
\n");

PyDoc_STRVAR(doc_is_qnan,
"is_qnan($self, /)\n--\n\n\
Return True if the argument is a quiet NaN, and False otherwise.\n\
\n");

PyDoc_STRVAR(doc_is_signed,
"is_signed($self, /)\n--\n\n\
Return True if the argument has a negative sign and False otherwise.\n\
Note that both zeros and NaNs can carry signs.\n\
\n");

PyDoc_STRVAR(doc_is_snan,
"is_snan($self, /)\n--\n\n\
Return True if the argument is a signaling NaN and False otherwise.\n\
\n");

PyDoc_STRVAR(doc_is_subnormal,
"is_subnormal($self, /, context=None)\n--\n\n\
Return True if the argument is subnormal, and False otherwise. A number is\n\
subnormal if it is non-zero, finite, and has an adjusted exponent less\n\
than Emin.\n\
\n");

PyDoc_STRVAR(doc_is_zero,
"is_zero($self, /)\n--\n\n\
Return True if the argument is a (positive or negative) zero and False\n\
otherwise.\n\
\n");

PyDoc_STRVAR(doc_ln,
"ln($self, /, context=None)\n--\n\n\
Return the natural (base e) logarithm of the operand. The function always\n\
uses the ROUND_HALF_EVEN mode and the result is correctly rounded.\n\
\n");

PyDoc_STRVAR(doc_log10,
"log10($self, /, context=None)\n--\n\n\
Return the base ten logarithm of the operand. The function always uses the\n\
ROUND_HALF_EVEN mode and the result is correctly rounded.\n\
\n");

PyDoc_STRVAR(doc_logb,
"logb($self, /, context=None)\n--\n\n\
For a non-zero number, return the adjusted exponent of the operand as a\n\
Decimal instance.  If the operand is a zero, then Decimal('-Infinity') is\n\
returned and the DivisionByZero condition is raised. If the operand is\n\
an infinity then Decimal('Infinity') is returned.\n\
\n");

PyDoc_STRVAR(doc_logical_and,
"logical_and($self, /, other, context=None)\n--\n\n\
Return the digit-wise 'and' of the two (logical) operands.\n\
\n");

PyDoc_STRVAR(doc_logical_invert,
"logical_invert($self, /, context=None)\n--\n\n\
Return the digit-wise inversion of the (logical) operand.\n\
\n");

PyDoc_STRVAR(doc_logical_or,
"logical_or($self, /, other, context=None)\n--\n\n\
Return the digit-wise 'or' of the two (logical) operands.\n\
\n");

PyDoc_STRVAR(doc_logical_xor,
"logical_xor($self, /, other, context=None)\n--\n\n\
Return the digit-wise 'exclusive or' of the two (logical) operands.\n\
\n");

PyDoc_STRVAR(doc_max,
"max($self, /, other, context=None)\n--\n\n\
Maximum of self and other.  If one operand is a quiet NaN and the other is\n\
numeric, the numeric operand is returned.\n\
\n");

PyDoc_STRVAR(doc_max_mag,
"max_mag($self, /, other, context=None)\n--\n\n\
Similar to the max() method, but the comparison is done using the absolute\n\
values of the operands.\n\
\n");

PyDoc_STRVAR(doc_min,
"min($self, /, other, context=None)\n--\n\n\
Minimum of self and other. If one operand is a quiet NaN and the other is\n\
numeric, the numeric operand is returned.\n\
\n");

PyDoc_STRVAR(doc_min_mag,
"min_mag($self, /, other, context=None)\n--\n\n\
Similar to the min() method, but the comparison is done using the absolute\n\
values of the operands.\n\
\n");

PyDoc_STRVAR(doc_next_minus,
"next_minus($self, /, context=None)\n--\n\n\
Return the largest number representable in the given context (or in the\n\
current default context if no context is given) that is smaller than the\n\
given operand.\n\
\n");

PyDoc_STRVAR(doc_next_plus,
"next_plus($self, /, context=None)\n--\n\n\
Return the smallest number representable in the given context (or in the\n\
current default context if no context is given) that is larger than the\n\
given operand.\n\
\n");

PyDoc_STRVAR(doc_next_toward,
"next_toward($self, /, other, context=None)\n--\n\n\
If the two operands are unequal, return the number closest to the first\n\
operand in the direction of the second operand.  If both operands are\n\
numerically equal, return a copy of the first operand with the sign set\n\
to be the same as the sign of the second operand.\n\
\n");

PyDoc_STRVAR(doc_normalize,
"normalize($self, /, context=None)\n--\n\n\
Normalize the number by stripping the rightmost trailing zeros and\n\
converting any result equal to Decimal('0') to Decimal('0e0').  Used\n\
for producing canonical values for members of an equivalence class.\n\
For example, Decimal('32.100') and Decimal('0.321000e+2') both normalize\n\
to the equivalent value Decimal('32.1').\n\
\n");

PyDoc_STRVAR(doc_number_class,
"number_class($self, /, context=None)\n--\n\n\
Return a string describing the class of the operand.  The returned value\n\
is one of the following ten strings:\n\
\n\
    * '-Infinity', indicating that the operand is negative infinity.\n\
    * '-Normal', indicating that the operand is a negative normal number.\n\
    * '-Subnormal', indicating that the operand is negative and subnormal.\n\
    * '-Zero', indicating that the operand is a negative zero.\n\
    * '+Zero', indicating that the operand is a positive zero.\n\
    * '+Subnormal', indicating that the operand is positive and subnormal.\n\
    * '+Normal', indicating that the operand is a positive normal number.\n\
    * '+Infinity', indicating that the operand is positive infinity.\n\
    * 'NaN', indicating that the operand is a quiet NaN (Not a Number).\n\
    * 'sNaN', indicating that the operand is a signaling NaN.\n\
\n\
\n");

PyDoc_STRVAR(doc_quantize,
"quantize($self, /, exp, rounding=None, context=None)\n--\n\n\
Return a value equal to the first operand after rounding and having the\n\
exponent of the second operand.\n\
\n\
    >>> Decimal('1.41421356').quantize(Decimal('1.000'))\n\
    Decimal('1.414')\n\
\n\
Unlike other operations, if the length of the coefficient after the quantize\n\
operation would be greater than precision, then an InvalidOperation is signaled.\n\
This guarantees that, unless there is an error condition, the quantized exponent\n\
is always equal to that of the right-hand operand.\n\
\n\
Also unlike other operations, quantize never signals Underflow, even if the\n\
