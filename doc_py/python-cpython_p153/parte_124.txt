                 "unsigned unexpected null result");

            uout = F_PY_TO_U(pyresult);
            if (uout == (unsigned TYPENAME)-1 && PyErr_Occurred())
                return error(
                    "unsigned unexpected -1 result");
            if (uout != uin)
                return error(
                    "unsigned output != input");
            UNBIND(pyresult);

            in = (TYPENAME)uin;
            pyresult = F_S_TO_PY(in);
            if (pyresult == NULL)
                return error(
                    "signed unexpected null result");

            out = F_PY_TO_S(pyresult);
            if (out == (TYPENAME)-1 && PyErr_Occurred())
                return error(
                    "signed unexpected -1 result");
            if (out != in)
                return error(
                    "signed output != input");
            UNBIND(pyresult);
        }
    }

    /* Overflow tests.  The loop above ensured that all limit cases that
     * should not overflow don't overflow, so all we need to do here is
     * provoke one-over-the-limit cases (not exhaustive, but sharp).
     */
    {
        PyObject *one, *x, *y;
        TYPENAME out;
        unsigned TYPENAME uout;

        one = PyLong_FromLong(1);
        if (one == NULL)
            return error(
                "unexpected NULL from PyLong_FromLong");

        /* Unsigned complains about -1? */
        x = PyNumber_Negative(one);
        if (x == NULL)
            return error(
                "unexpected NULL from PyNumber_Negative");

        uout = F_PY_TO_U(x);
        if (uout != (unsigned TYPENAME)-1 || !PyErr_Occurred())
            return error(
                "PyLong_AsUnsignedXXX(-1) didn't complain");
        if (!PyErr_ExceptionMatches(PyExc_OverflowError))
            return error(
                "PyLong_AsUnsignedXXX(-1) raised "
                "something other than OverflowError");
        PyErr_Clear();
        UNBIND(x);

        /* Unsigned complains about 2**NBITS? */
        y = PyLong_FromLong((long)NBITS);
        if (y == NULL)
            return error(
                "unexpected NULL from PyLong_FromLong");

        x = PyNumber_Lshift(one, y); /* 1L << NBITS, == 2**NBITS */
        UNBIND(y);
        if (x == NULL)
            return error(
                "unexpected NULL from PyNumber_Lshift");

        uout = F_PY_TO_U(x);
        if (uout != (unsigned TYPENAME)-1 || !PyErr_Occurred())
            return error(
                "PyLong_AsUnsignedXXX(2**NBITS) didn't "
                "complain");
        if (!PyErr_ExceptionMatches(PyExc_OverflowError))
            return error(
                "PyLong_AsUnsignedXXX(2**NBITS) raised "
                "something other than OverflowError");
        PyErr_Clear();

        /* Signed complains about 2**(NBITS-1)?
           x still has 2**NBITS. */
        y = PyNumber_Rshift(x, one); /* 2**(NBITS-1) */
        UNBIND(x);
        if (y == NULL)
            return error(
                "unexpected NULL from PyNumber_Rshift");

        out = F_PY_TO_S(y);
        if (out != (TYPENAME)-1 || !PyErr_Occurred())
            return error(
                "PyLong_AsXXX(2**(NBITS-1)) didn't "
                "complain");
        if (!PyErr_ExceptionMatches(PyExc_OverflowError))
            return error(
                "PyLong_AsXXX(2**(NBITS-1)) raised "
                "something other than OverflowError");
        PyErr_Clear();

        /* Signed complains about -2**(NBITS-1)-1?;
           y still has 2**(NBITS-1). */
        x = PyNumber_Negative(y);  /* -(2**(NBITS-1)) */
        UNBIND(y);
        if (x == NULL)
            return error(
                "unexpected NULL from PyNumber_Negative");

        y = PyNumber_Subtract(x, one); /* -(2**(NBITS-1))-1 */
        UNBIND(x);
        if (y == NULL)
            return error(
                "unexpected NULL from PyNumber_Subtract");

        out = F_PY_TO_S(y);
        if (out != (TYPENAME)-1 || !PyErr_Occurred())
            return error(
                "PyLong_AsXXX(-2**(NBITS-1)-1) didn't "
                "complain");
        if (!PyErr_ExceptionMatches(PyExc_OverflowError))
            return error(
                "PyLong_AsXXX(-2**(NBITS-1)-1) raised "
                "something other than OverflowError");
        PyErr_Clear();
        UNBIND(y);

        Py_XDECREF(x);
        Py_XDECREF(y);
        Py_DECREF(one);
    }

    /* Test F_PY_TO_{S,U} on non-pylong input. This should raise a TypeError. */
    {
        TYPENAME out;
        unsigned TYPENAME uout;

        Py_INCREF(Py_None);

        out = F_PY_TO_S(Py_None);
        if (out != (TYPENAME)-1 || !PyErr_Occurred())
            return error("PyLong_AsXXX(None) didn't complain");
        if (!PyErr_ExceptionMatches(PyExc_TypeError))
            return error("PyLong_AsXXX(None) raised "
                         "something other than TypeError");
        PyErr_Clear();

        uout = F_PY_TO_U(Py_None);
        if (uout != (unsigned TYPENAME)-1 || !PyErr_Occurred())
            return error("PyLong_AsXXX(None) didn't complain");
        if (!PyErr_ExceptionMatches(PyExc_TypeError))
            return error("PyLong_AsXXX(None) raised "
                         "something other than TypeError");
        PyErr_Clear();

        Py_DECREF(Py_None);
    }

    return Py_NewRef(Py_None);
}


================================================
File: /Modules/_testlimitedcapi/tuple.c
================================================
#include "parts.h"
#include "util.h"


static PyObject *
tuple_check(PyObject* Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyTuple_Check(obj));
}

static PyObject *
tuple_checkexact(PyObject* Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyTuple_CheckExact(obj));
}

static PyObject *
tuple_new(PyObject* Py_UNUSED(module), PyObject *len)
{
    return PyTuple_New(PyLong_AsSsize_t(len));
}

static PyObject *
tuple_pack(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *arg1 = NULL, *arg2 = NULL;
    Py_ssize_t size;

    if (!PyArg_ParseTuple(args, "n|OO", &size, &arg1, &arg2)) {
        return NULL;
    }
    if (arg1) {
        NULLABLE(arg1);
        if (arg2) {
            NULLABLE(arg2);
            return PyTuple_Pack(size, arg1, arg2);
        }
        return PyTuple_Pack(size, arg1);
    }
    return PyTuple_Pack(size);
}

static PyObject *
tuple_size(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    RETURN_SIZE(PyTuple_Size(obj));
}

static PyObject *
tuple_getitem(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t i;
    if (!PyArg_ParseTuple(args, "On", &obj, &i)) {
        return NULL;
    }
    NULLABLE(obj);
    return Py_XNewRef(PyTuple_GetItem(obj, i));
}

static PyObject *
tuple_getslice(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t ilow, ihigh;
    if (!PyArg_ParseTuple(args, "Onn", &obj, &ilow, &ihigh)) {
        return NULL;
    }
    NULLABLE(obj);
    return PyTuple_GetSlice(obj, ilow, ihigh);
}

static PyObject *
tuple_setitem(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj, *value, *newtuple = NULL;
    Py_ssize_t i;
    if (!PyArg_ParseTuple(args, "OnO", &obj, &i, &value)) {
        return NULL;
    }
    NULLABLE(value);
    if (PyTuple_CheckExact(obj)) {
        Py_ssize_t size = PyTuple_Size(obj);
        newtuple = PyTuple_New(size);
        if (!newtuple) {
            return NULL;
        }
        for (Py_ssize_t n = 0; n < size; n++) {
            if (PyTuple_SetItem(newtuple, n,
                                Py_XNewRef(PyTuple_GetItem(obj, n))) == -1) {
                Py_DECREF(newtuple);
                return NULL;
            }
        }

        if (PyTuple_SetItem(newtuple, i, Py_XNewRef(value)) == -1) {
            Py_DECREF(newtuple);
            return NULL;
        }
        return newtuple;
    }
    else {
        NULLABLE(obj);

        if (PyTuple_SetItem(obj, i, Py_XNewRef(value)) == -1) {
            return NULL;
        }
        return Py_XNewRef(obj);
    }
}


static PyMethodDef test_methods[] = {
    {"tuple_check", tuple_check, METH_O},
    {"tuple_checkexact", tuple_checkexact, METH_O},
    {"tuple_new", tuple_new, METH_O},
    {"tuple_pack", tuple_pack, METH_VARARGS},
    {"tuple_size", tuple_size, METH_O},
    {"tuple_getitem", tuple_getitem, METH_VARARGS},
    {"tuple_getslice", tuple_getslice, METH_VARARGS},
    {"tuple_setitem", tuple_setitem, METH_VARARGS},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_Tuple(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/util.h
================================================
#define NULLABLE(x) do {                    \
        if (x == Py_None) {                 \
            x = NULL;                       \
        }                                   \
    } while (0);

#define RETURN_INT(value) do {              \
        int _ret = (value);                 \
        if (_ret == -1) {                   \
            assert(PyErr_Occurred());       \
            return NULL;                    \
        }                                   \
        assert(!PyErr_Occurred());          \
        return PyLong_FromLong(_ret);       \
    } while (0)

#define RETURN_SIZE(value) do {             \
        Py_ssize_t _ret = (value);          \
        if (_ret == -1) {                   \
            assert(PyErr_Occurred());       \
            return NULL;                    \
        }                                   \
        assert(!PyErr_Occurred());          \
        return PyLong_FromSsize_t(_ret);    \
    } while (0)

/* Marker to check that pointer value was set. */
static const char uninitialized[] = "uninitialized";
#define UNINITIALIZED_PTR ((void *)uninitialized)
/* Marker to check that Py_ssize_t value was set. */
#define UNINITIALIZED_SIZE ((Py_ssize_t)236892191)
/* Marker to check that integer value was set. */
#define UNINITIALIZED_INT (63256717)


================================================
File: /Modules/_testlimitedcapi/vectorcall_limited.c
================================================
/* Test Vectorcall in the limited API */

// Need limited C API version 3.12 for PyObject_Vectorcall()
#include "pyconfig.h"   // Py_GIL_DISABLED
#if !defined(Py_GIL_DISABLED) && !defined(Py_LIMITED_API)
#  define Py_LIMITED_API 0x030c0000
#endif

#include <stddef.h>                         // offsetof

#include "parts.h"
#include "clinic/vectorcall_limited.c.h"

/*[clinic input]
module _testlimitedcapi
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=2700057f9c1135ba]*/

static PyObject *
LimitedVectorCallClass_tpcall(PyObject *self, PyObject *args, PyObject *kwargs) {
    return PyUnicode_FromString("tp_call called");
}

static PyObject *
LimitedVectorCallClass_vectorcall(PyObject *callable,
                            PyObject *const *args,
                            size_t nargsf,
                            PyObject *kwnames) {
    return PyUnicode_FromString("vectorcall called");
}

static PyObject *
LimitedVectorCallClass_new(PyTypeObject *tp, PyTypeObject *a, PyTypeObject *kw)
{
    PyObject *self = ((allocfunc)PyType_GetSlot(tp, Py_tp_alloc))(tp, 0);
    if (!self) {
        return NULL;
    }
    *(vectorcallfunc*)((char*)self + sizeof(PyObject)) = (
        LimitedVectorCallClass_vectorcall);
    return self;
}

/*[clinic input]
_testlimitedcapi.call_vectorcall

    callable: object
    /
[clinic start generated code]*/

static PyObject *
_testlimitedcapi_call_vectorcall(PyObject *module, PyObject *callable)
/*[clinic end generated code: output=9cbb7832263a8eef input=0743636c12dccb28]*/
{
    PyObject *args[3] = { NULL, NULL, NULL };
    PyObject *kwname = NULL, *kwnames = NULL, *result = NULL;

    args[1] = PyUnicode_FromString("foo");
    if (!args[1]) {
        goto leave;
    }

    args[2] = PyUnicode_FromString("bar");
    if (!args[2]) {
        goto leave;
    }

    kwname = PyUnicode_InternFromString("baz");
    if (!kwname) {
        goto leave;
    }

    kwnames = PyTuple_New(1);
    if (!kwnames) {
        goto leave;
    }

    if (PyTuple_SetItem(kwnames, 0, kwname)) {
        goto leave;
    }

    result = PyObject_Vectorcall(
        callable,
        args + 1,
        1 | PY_VECTORCALL_ARGUMENTS_OFFSET,
        kwnames
    );

leave:
    Py_XDECREF(args[1]);
    Py_XDECREF(args[2]);
    Py_XDECREF(kwnames);

    return result;
}

/*[clinic input]
_testlimitedcapi.call_vectorcall_method

    callable: object
    /
[clinic start generated code]*/

static PyObject *
_testlimitedcapi_call_vectorcall_method(PyObject *module, PyObject *callable)
/*[clinic end generated code: output=4558323a46cc09eb input=a736f7dbf15f1be5]*/
{
    PyObject *args[3] = { NULL, NULL, NULL };
    PyObject *name = NULL, *kwname = NULL,
             *kwnames = NULL, *result = NULL;

    name = PyUnicode_FromString("f");
    if (!name) {
        goto leave;
    }

    args[0] = callable;
    args[1] = PyUnicode_FromString("foo");
    if (!args[1]) {
        goto leave;
    }

    args[2] = PyUnicode_FromString("bar");
    if (!args[2]) {
        goto leave;
    }

    kwname = PyUnicode_InternFromString("baz");
    if (!kwname) {
        goto leave;
    }

    kwnames = PyTuple_New(1);
    if (!kwnames) {
        goto leave;
    }

    if (PyTuple_SetItem(kwnames, 0, kwname)) {
        goto leave;
    }


    result = PyObject_VectorcallMethod(
        name,
        args,
        2 | PY_VECTORCALL_ARGUMENTS_OFFSET,
        kwnames
    );

leave:
    Py_XDECREF(name);
    Py_XDECREF(args[1]);
    Py_XDECREF(args[2]);
    Py_XDECREF(kwnames);

    return result;
}

static PyMemberDef LimitedVectorCallClass_members[] = {
    {"__vectorcalloffset__", Py_T_PYSSIZET, sizeof(PyObject), Py_READONLY},
    {NULL}
};

static PyType_Slot LimitedVectorallClass_slots[] = {
    {Py_tp_new, LimitedVectorCallClass_new},
    {Py_tp_call, LimitedVectorCallClass_tpcall},
    {Py_tp_members, LimitedVectorCallClass_members},
    {0},
};

static PyType_Spec LimitedVectorCallClass_spec = {
    .name = "_testlimitedcapi.LimitedVectorCallClass",
    .basicsize = (int)(sizeof(PyObject) + sizeof(vectorcallfunc)),
    .flags = Py_TPFLAGS_DEFAULT
        | Py_TPFLAGS_HAVE_VECTORCALL
        | Py_TPFLAGS_BASETYPE,
    .slots = LimitedVectorallClass_slots,
};

typedef struct {
    vectorcallfunc vfunc;
} LimitedRelativeVectorCallStruct;

static PyObject *
LimitedRelativeVectorCallClass_new(PyTypeObject *tp, PyTypeObject *a, PyTypeObject *kw)
{
    PyObject *self = ((allocfunc)PyType_GetSlot(tp, Py_tp_alloc))(tp, 0);
    if (!self) {
        return NULL;
    }
    LimitedRelativeVectorCallStruct *data = PyObject_GetTypeData(self, tp);
    data->vfunc = LimitedVectorCallClass_vectorcall;
    return self;
}


static PyType_Spec LimitedRelativeVectorCallClass_spec = {
    .name = "_testlimitedcapi.LimitedRelativeVectorCallClass",
    .basicsize = -(int)sizeof(LimitedRelativeVectorCallStruct),
    .flags = Py_TPFLAGS_DEFAULT
        | Py_TPFLAGS_HAVE_VECTORCALL,
    .slots = (PyType_Slot[]) {
        {Py_tp_new, LimitedRelativeVectorCallClass_new},
        {Py_tp_call, LimitedVectorCallClass_tpcall},
        {Py_tp_members, (PyMemberDef[]){
            {"__vectorcalloffset__", Py_T_PYSSIZET,
             offsetof(LimitedRelativeVectorCallStruct, vfunc),
             Py_READONLY | Py_RELATIVE_OFFSET},
            {NULL}
        }},
        {0}
    },
};

static PyMethodDef TestMethods[] = {
    _TESTLIMITEDCAPI_CALL_VECTORCALL_METHODDEF
    _TESTLIMITEDCAPI_CALL_VECTORCALL_METHOD_METHODDEF
    {NULL},
};

int
_PyTestLimitedCAPI_Init_VectorcallLimited(PyObject *m)
{
    if (PyModule_AddFunctions(m, TestMethods) < 0) {
        return -1;
    }

    PyObject *LimitedVectorCallClass = PyType_FromModuleAndSpec(
        m, &LimitedVectorCallClass_spec, NULL);
    if (!LimitedVectorCallClass) {
        return -1;
    }
    if (PyModule_AddType(m, (PyTypeObject *)LimitedVectorCallClass) < 0) {
        return -1;
    }
    Py_DECREF(LimitedVectorCallClass);

    PyObject *LimitedRelativeVectorCallClass = PyType_FromModuleAndSpec(
        m, &LimitedRelativeVectorCallClass_spec, NULL);
    if (!LimitedRelativeVectorCallClass) {
        return -1;
    }
    if (PyModule_AddType(m, (PyTypeObject *)LimitedRelativeVectorCallClass) < 0) {
        return -1;
    }
    Py_DECREF(LimitedRelativeVectorCallClass);

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/version.c
================================================
/* Test version macros in the limited API */

#include "pyconfig.h"  // Py_GIL_DISABLED
#ifndef Py_GIL_DISABLED
#  define Py_LIMITED_API 0x030e0000  // Added in 3.14
#endif

#include "parts.h"
#include "clinic/version.c.h"
#include <stdio.h>

/*[clinic input]
module _testlimitedcapi
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=2700057f9c1135ba]*/

/*[clinic input]
_testlimitedcapi.pack_full_version

    major: int
    minor: int
    micro: int
    level: int
    serial: int
    /
[clinic start generated code]*/

static PyObject *
_testlimitedcapi_pack_full_version_impl(PyObject *module, int major,
                                        int minor, int micro, int level,
                                        int serial)
/*[clinic end generated code: output=b87a1e9805648861 input=2a304423be61d2ac]*/
{
    uint32_t macro_result = Py_PACK_FULL_VERSION(
        major, minor, micro, level, serial);
#undef Py_PACK_FULL_VERSION
    uint32_t func_result = Py_PACK_FULL_VERSION(
        major, minor, micro, level, serial);

    assert(macro_result == func_result);
    return PyLong_FromUnsignedLong((unsigned long)func_result);
}

/*[clinic input]
_testlimitedcapi.pack_version

    major: int
    minor: int
    /
[clinic start generated code]*/

static PyObject *
_testlimitedcapi_pack_version_impl(PyObject *module, int major, int minor)
/*[clinic end generated code: output=771247bbd06e7883 input=3e39e9dcbc09e86a]*/
{
    uint32_t macro_result = Py_PACK_VERSION(major, minor);
#undef Py_PACK_VERSION
    uint32_t func_result = Py_PACK_VERSION(major, minor);

    assert(macro_result == func_result);
    return PyLong_FromUnsignedLong((unsigned long)func_result);
}

static PyMethodDef TestMethods[] = {
    _TESTLIMITEDCAPI_PACK_FULL_VERSION_METHODDEF
    _TESTLIMITEDCAPI_PACK_VERSION_METHODDEF
    {NULL},
};

int
_PyTestLimitedCAPI_Init_Version(PyObject *m)
{
    if (PyModule_AddFunctions(m, TestMethods) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testlimitedcapi/clinic/heaptype_relative.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

PyDoc_STRVAR(make_heaptype_with_member__doc__,
"make_heaptype_with_member($module, /, extra_base_size=0, basicsize=0,\n"
"                          member_offset=0, add_relative_flag=False, *,\n"
"                          member_name=\'memb\', member_flags=0,\n"
"                          member_type=-1)\n"
"--\n"
"\n");

#define MAKE_HEAPTYPE_WITH_MEMBER_METHODDEF    \
    {"make_heaptype_with_member", (PyCFunction)(void(*)(void))make_heaptype_with_member, METH_VARARGS|METH_KEYWORDS, make_heaptype_with_member__doc__},

static PyObject *
make_heaptype_with_member_impl(PyObject *module, int extra_base_size,
                               int basicsize, int member_offset,
                               int add_relative_flag,
                               const char *member_name, int member_flags,
                               int member_type);

static PyObject *
make_heaptype_with_member(PyObject *module, PyObject *args, PyObject *kwargs)
{
    PyObject *return_value = NULL;
    static char *_keywords[] = {"extra_base_size", "basicsize", "member_offset", "add_relative_flag", "member_name", "member_flags", "member_type", NULL};
    int extra_base_size = 0;
    int basicsize = 0;
    int member_offset = 0;
    int add_relative_flag = 0;
    const char *member_name = "memb";
    int member_flags = 0;
    int member_type = Py_T_BYTE;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "|iiip$sii:make_heaptype_with_member", _keywords,
        &extra_base_size, &basicsize, &member_offset, &add_relative_flag, &member_name, &member_flags, &member_type))
        goto exit;
    return_value = make_heaptype_with_member_impl(module, extra_base_size, basicsize, member_offset, add_relative_flag, member_name, member_flags, member_type);

exit:
    return return_value;
}
/*[clinic end generated code: output=01933185947faecc input=a9049054013a1b77]*/


================================================
File: /Modules/_testlimitedcapi/clinic/long.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

PyDoc_STRVAR(_testlimitedcapi_test_long_api__doc__,
"test_long_api($module, /)\n"
"--\n"
"\n");

#define _TESTLIMITEDCAPI_TEST_LONG_API_METHODDEF    \
    {"test_long_api", (PyCFunction)_testlimitedcapi_test_long_api, METH_NOARGS, _testlimitedcapi_test_long_api__doc__},

static PyObject *
_testlimitedcapi_test_long_api_impl(PyObject *module);

static PyObject *
_testlimitedcapi_test_long_api(PyObject *module, PyObject *Py_UNUSED(ignored))
{
    return _testlimitedcapi_test_long_api_impl(module);
}

PyDoc_STRVAR(_testlimitedcapi_test_longlong_api__doc__,
"test_longlong_api($module, /)\n"
"--\n"
"\n");

#define _TESTLIMITEDCAPI_TEST_LONGLONG_API_METHODDEF    \
    {"test_longlong_api", (PyCFunction)_testlimitedcapi_test_longlong_api, METH_NOARGS, _testlimitedcapi_test_longlong_api__doc__},

static PyObject *
_testlimitedcapi_test_longlong_api_impl(PyObject *module);

static PyObject *
_testlimitedcapi_test_longlong_api(PyObject *module, PyObject *Py_UNUSED(ignored))
{
    return _testlimitedcapi_test_longlong_api_impl(module);
}

PyDoc_STRVAR(_testlimitedcapi_test_long_and_overflow__doc__,
"test_long_and_overflow($module, /)\n"
"--\n"
"\n"
"Test the PyLong_AsLongAndOverflow API.\n"
"\n"
"General conversion to PY_LONG is tested by test_long_api_inner.\n"
"This test will concentrate on proper handling of overflow.");

#define _TESTLIMITEDCAPI_TEST_LONG_AND_OVERFLOW_METHODDEF    \
    {"test_long_and_overflow", (PyCFunction)_testlimitedcapi_test_long_and_overflow, METH_NOARGS, _testlimitedcapi_test_long_and_overflow__doc__},

static PyObject *
_testlimitedcapi_test_long_and_overflow_impl(PyObject *module);

static PyObject *
_testlimitedcapi_test_long_and_overflow(PyObject *module, PyObject *Py_UNUSED(ignored))
{
    return _testlimitedcapi_test_long_and_overflow_impl(module);
}

PyDoc_STRVAR(_testlimitedcapi_test_long_long_and_overflow__doc__,
"test_long_long_and_overflow($module, /)\n"
"--\n"
"\n"
"Test the PyLong_AsLongLongAndOverflow API.\n"
"\n"
"General conversion to long long is tested by test_long_api_inner.\n"
"This test will concentrate on proper handling of overflow.");

#define _TESTLIMITEDCAPI_TEST_LONG_LONG_AND_OVERFLOW_METHODDEF    \
    {"test_long_long_and_overflow", (PyCFunction)_testlimitedcapi_test_long_long_and_overflow, METH_NOARGS, _testlimitedcapi_test_long_long_and_overflow__doc__},

static PyObject *
_testlimitedcapi_test_long_long_and_overflow_impl(PyObject *module);

static PyObject *
_testlimitedcapi_test_long_long_and_overflow(PyObject *module, PyObject *Py_UNUSED(ignored))
{
    return _testlimitedcapi_test_long_long_and_overflow_impl(module);
}

PyDoc_STRVAR(_testlimitedcapi_test_long_as_size_t__doc__,
"test_long_as_size_t($module, /)\n"
"--\n"
"\n"
"Test the PyLong_As{Size,Ssize}_t API.\n"
"\n"
"At present this just tests that non-integer arguments are handled correctly.\n"
"It should be extended to test overflow handling.");

#define _TESTLIMITEDCAPI_TEST_LONG_AS_SIZE_T_METHODDEF    \
    {"test_long_as_size_t", (PyCFunction)_testlimitedcapi_test_long_as_size_t, METH_NOARGS, _testlimitedcapi_test_long_as_size_t__doc__},

static PyObject *
_testlimitedcapi_test_long_as_size_t_impl(PyObject *module);

static PyObject *
_testlimitedcapi_test_long_as_size_t(PyObject *module, PyObject *Py_UNUSED(ignored))
{
    return _testlimitedcapi_test_long_as_size_t_impl(module);
}

PyDoc_STRVAR(_testlimitedcapi_test_long_as_unsigned_long_long_mask__doc__,
"test_long_as_unsigned_long_long_mask($module, /)\n"
"--\n"
"\n");

#define _TESTLIMITEDCAPI_TEST_LONG_AS_UNSIGNED_LONG_LONG_MASK_METHODDEF    \
    {"test_long_as_unsigned_long_long_mask", (PyCFunction)_testlimitedcapi_test_long_as_unsigned_long_long_mask, METH_NOARGS, _testlimitedcapi_test_long_as_unsigned_long_long_mask__doc__},

static PyObject *
_testlimitedcapi_test_long_as_unsigned_long_long_mask_impl(PyObject *module);

static PyObject *
_testlimitedcapi_test_long_as_unsigned_long_long_mask(PyObject *module, PyObject *Py_UNUSED(ignored))
{
    return _testlimitedcapi_test_long_as_unsigned_long_long_mask_impl(module);
}

PyDoc_STRVAR(_testlimitedcapi_test_long_as_double__doc__,
"test_long_as_double($module, /)\n"
"--\n"
"\n");

#define _TESTLIMITEDCAPI_TEST_LONG_AS_DOUBLE_METHODDEF    \
    {"test_long_as_double", (PyCFunction)_testlimitedcapi_test_long_as_double, METH_NOARGS, _testlimitedcapi_test_long_as_double__doc__},

static PyObject *
_testlimitedcapi_test_long_as_double_impl(PyObject *module);

static PyObject *
_testlimitedcapi_test_long_as_double(PyObject *module, PyObject *Py_UNUSED(ignored))
{
    return _testlimitedcapi_test_long_as_double_impl(module);
}

PyDoc_STRVAR(_testlimitedcapi_PyLong_AsInt__doc__,
"PyLong_AsInt($module, arg, /)\n"
"--\n"
"\n");

#define _TESTLIMITEDCAPI_PYLONG_ASINT_METHODDEF    \
    {"PyLong_AsInt", (PyCFunction)_testlimitedcapi_PyLong_AsInt, METH_O, _testlimitedcapi_PyLong_AsInt__doc__},
/*[clinic end generated code: output=bc52b73c599f96c2 input=a9049054013a1b77]*/


================================================
File: /Modules/_testlimitedcapi/clinic/vectorcall_limited.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

PyDoc_STRVAR(_testlimitedcapi_call_vectorcall__doc__,
"call_vectorcall($module, callable, /)\n"
"--\n"
"\n");

#define _TESTLIMITEDCAPI_CALL_VECTORCALL_METHODDEF    \
    {"call_vectorcall", (PyCFunction)_testlimitedcapi_call_vectorcall, METH_O, _testlimitedcapi_call_vectorcall__doc__},

PyDoc_STRVAR(_testlimitedcapi_call_vectorcall_method__doc__,
"call_vectorcall_method($module, callable, /)\n"
"--\n"
"\n");

#define _TESTLIMITEDCAPI_CALL_VECTORCALL_METHOD_METHODDEF    \
    {"call_vectorcall_method", (PyCFunction)_testlimitedcapi_call_vectorcall_method, METH_O, _testlimitedcapi_call_vectorcall_method__doc__},
/*[clinic end generated code: output=5976b9b360e1ff30 input=a9049054013a1b77]*/


================================================
File: /Modules/_testlimitedcapi/clinic/version.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

PyDoc_STRVAR(_testlimitedcapi_pack_full_version__doc__,
"pack_full_version($module, major, minor, micro, level, serial, /)\n"
"--\n"
"\n");

#define _TESTLIMITEDCAPI_PACK_FULL_VERSION_METHODDEF    \
    {"pack_full_version", (PyCFunction)(void(*)(void))_testlimitedcapi_pack_full_version, METH_FASTCALL, _testlimitedcapi_pack_full_version__doc__},

static PyObject *
_testlimitedcapi_pack_full_version_impl(PyObject *module, int major,
                                        int minor, int micro, int level,
                                        int serial);

static PyObject *
_testlimitedcapi_pack_full_version(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    int major;
    int minor;
    int micro;
    int level;
    int serial;

    if (nargs != 5) {
        PyErr_Format(PyExc_TypeError, "pack_full_version expected 5 arguments, got %zd", nargs);
        goto exit;
    }
    major = PyLong_AsInt(args[0]);
    if (major == -1 && PyErr_Occurred()) {
        goto exit;
    }
    minor = PyLong_AsInt(args[1]);
    if (minor == -1 && PyErr_Occurred()) {
        goto exit;
    }
    micro = PyLong_AsInt(args[2]);
    if (micro == -1 && PyErr_Occurred()) {
        goto exit;
    }
    level = PyLong_AsInt(args[3]);
    if (level == -1 && PyErr_Occurred()) {
        goto exit;
    }
    serial = PyLong_AsInt(args[4]);
    if (serial == -1 && PyErr_Occurred()) {
        goto exit;
    }
    return_value = _testlimitedcapi_pack_full_version_impl(module, major, minor, micro, level, serial);

exit:
    return return_value;
}

PyDoc_STRVAR(_testlimitedcapi_pack_version__doc__,
"pack_version($module, major, minor, /)\n"
"--\n"
"\n");

#define _TESTLIMITEDCAPI_PACK_VERSION_METHODDEF    \
    {"pack_version", (PyCFunction)(void(*)(void))_testlimitedcapi_pack_version, METH_FASTCALL, _testlimitedcapi_pack_version__doc__},

static PyObject *
_testlimitedcapi_pack_version_impl(PyObject *module, int major, int minor);

static PyObject *
_testlimitedcapi_pack_version(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    int major;
    int minor;

    if (nargs != 2) {
        PyErr_Format(PyExc_TypeError, "pack_version expected 2 arguments, got %zd", nargs);
        goto exit;
    }
    major = PyLong_AsInt(args[0]);
    if (major == -1 && PyErr_Occurred()) {
        goto exit;
    }
    minor = PyLong_AsInt(args[1]);
    if (minor == -1 && PyErr_Occurred()) {
        goto exit;
    }
    return_value = _testlimitedcapi_pack_version_impl(module, major, minor);

exit:
    return return_value;
}
/*[clinic end generated code: output=aed3e226da77f2d2 input=a9049054013a1b77]*/


================================================
File: /Modules/_xxtestfuzz/README.rst
================================================
Fuzz Tests for CPython
======================

These fuzz tests are designed to be included in Google's `oss-fuzz`_ project.

oss-fuzz works against a library exposing a function of the form
``int LLVMFuzzerTestOneInput(const uint8_t* data, size_t length)``. We provide
that library (``fuzzer.c``), and include a ``_fuzz`` module for testing with
some toy values -- no fuzzing occurs in Python's test suite.

oss-fuzz will regularly pull from CPython, discover all the tests in
``fuzz_tests.txt``, and run them -- so adding a new test here means it will
automatically be run in oss-fuzz, while also being smoke-tested as part of
CPython's test suite.

In addition, the tests are run on GitHub Actions using CIFuzz for PRs to the
main branch changing relevant files.

Adding a new fuzz test
----------------------

Add the test name on a new line in ``fuzz_tests.txt``.

In ``fuzzer.c``, add a function to be run::

    static int $fuzz_test_name(const char* data, size_t size) {
        ...
        return 0;
    }


And invoke it from ``LLVMFuzzerTestOneInput``::

    #if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_$fuzz_test_name)
        rv |= _run_fuzz(data, size, $fuzz_test_name);
    #endif

Don't forget to replace ``$fuzz_test_name`` with your actual test name.

``LLVMFuzzerTestOneInput`` will run in oss-fuzz, with each test in
``fuzz_tests.txt`` run separately.

Seed data (corpus) for the test can be provided in a subfolder called
``<test_name>_corpus`` such as ``fuzz_json_loads_corpus``. A wide variety
of good input samples allows the fuzzer to more easily explore a diverse
set of paths and provides a better base to find buggy input from.

Dictionaries of tokens (see oss-fuzz documentation for more details) can
be placed in the ``dictionaries`` folder with the name of the test.
For example, ``dictionaries/fuzz_json_loads.dict`` contains JSON tokens
to guide the fuzzer.

What makes a good fuzz test
---------------------------

Libraries written in C that might handle untrusted data are worthwhile. The
more complex the logic (e.g. parsing), the more likely this is to be a useful
fuzz test. See the existing examples for reference, and refer to the
`oss-fuzz`_ docs.

.. _oss-fuzz: https://github.com/google/oss-fuzz


================================================
File: /Modules/_xxtestfuzz/_xxtestfuzz.c
================================================
#include <Python.h>
#include <stdlib.h>
#include <inttypes.h>

int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size);

static PyObject* _fuzz_run(PyObject* self, PyObject* args) {
    const char* buf;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "s#", &buf, &size)) {
        return NULL;
    }
    int rv = LLVMFuzzerTestOneInput((const uint8_t*)buf, size);
    if (PyErr_Occurred()) {
        return NULL;
    }
    if (rv != 0) {
        // Nonzero return codes are reserved for future use.
        PyErr_Format(
            PyExc_RuntimeError, "Nonzero return code from fuzzer: %d", rv);
        return NULL;
    }
    Py_RETURN_NONE;
}

static PyMethodDef module_methods[] = {
    {"run", (PyCFunction)_fuzz_run, METH_VARARGS, ""},
    {NULL},
};

static PyModuleDef_Slot module_slots[] = {
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL},
};

static struct PyModuleDef _fuzzmodule = {
        PyModuleDef_HEAD_INIT,
        "_fuzz",
        NULL,
        0,
        module_methods,
        module_slots,
        NULL,
        NULL,
        NULL
};

PyMODINIT_FUNC
PyInit__xxtestfuzz(void)
{
    return PyModuleDef_Init(&_fuzzmodule);
}


================================================
File: /Modules/_xxtestfuzz/fuzz_tests.txt
================================================
fuzz_builtin_float
fuzz_builtin_int
fuzz_builtin_unicode
fuzz_json_loads
fuzz_sre_compile
fuzz_sre_match
fuzz_csv_reader
fuzz_struct_unpack
fuzz_ast_literal_eval
fuzz_elementtree_parsewhole
fuzz_pycompile


================================================
File: /Modules/_xxtestfuzz/fuzzer.c
================================================
/* A fuzz test for CPython.

  The only exposed function is LLVMFuzzerTestOneInput, which is called by
  fuzzers and by the _fuzz module for smoke tests.

  To build exactly one fuzz test, as when running in oss-fuzz etc.,
  build with -D _Py_FUZZ_ONE and -D _Py_FUZZ_<test_name>. e.g. to build
  LLVMFuzzerTestOneInput to only run "fuzz_builtin_float", build this file with
      -D _Py_FUZZ_ONE -D _Py_FUZZ_fuzz_builtin_float.

  See the source code for LLVMFuzzerTestOneInput for details. */

#ifndef Py_BUILD_CORE
#  define Py_BUILD_CORE 1
#endif

#include <Python.h>
#include <stdlib.h>
#include <inttypes.h>

/*  Fuzz PyFloat_FromString as a proxy for float(str). */
static int fuzz_builtin_float(const char* data, size_t size) {
    PyObject* s = PyBytes_FromStringAndSize(data, size);
    if (s == NULL) return 0;
    PyObject* f = PyFloat_FromString(s);
    if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_ValueError)) {
        PyErr_Clear();
    }

    Py_XDECREF(f);
    Py_DECREF(s);
    return 0;
}

#define MAX_INT_TEST_SIZE 0x10000

/* Fuzz PyLong_FromUnicodeObject as a proxy for int(str). */
static int fuzz_builtin_int(const char* data, size_t size) {
    /* Ignore test cases with very long ints to avoid timeouts
       int("9" * 1000000) is not a very interesting test caase */
    if (size > MAX_INT_TEST_SIZE) {
        return 0;
    }
    /* Pick a random valid base. (When the fuzzed function takes extra
       parameters, it's somewhat normal to hash the input to generate those
       parameters. We want to exercise all code paths, so we do so here.) */
    int base = Py_HashBuffer(data, size) % 37;
    if (base == 1) {
        // 1 is the only number between 0 and 36 that is not a valid base.
        base = 0;
    }
    if (base == -1) {
        return 0;  // An error occurred, bail early.
    }
    if (base < 0) {
        base = -base;
    }

    PyObject* s = PyUnicode_FromStringAndSize(data, size);
    if (s == NULL) {
        if (PyErr_ExceptionMatches(PyExc_UnicodeDecodeError)) {
            PyErr_Clear();
        }
        return 0;
    }
    PyObject* l = PyLong_FromUnicodeObject(s, base);
    if (l == NULL && PyErr_ExceptionMatches(PyExc_ValueError)) {
        PyErr_Clear();
    }
    PyErr_Clear();
    Py_XDECREF(l);
    Py_DECREF(s);
    return 0;
}

/* Fuzz PyUnicode_FromStringAndSize as a proxy for unicode(str). */
static int fuzz_builtin_unicode(const char* data, size_t size) {
    PyObject* s = PyUnicode_FromStringAndSize(data, size);
    if (s == NULL && PyErr_ExceptionMatches(PyExc_UnicodeDecodeError)) {
        PyErr_Clear();
    }
    Py_XDECREF(s);
    return 0;
}


PyObject* struct_unpack_method = NULL;
PyObject* struct_error = NULL;
/* Called by LLVMFuzzerTestOneInput for initialization */
static int init_struct_unpack(void) {
    /* Import struct.unpack */
    PyObject* struct_module = PyImport_ImportModule("struct");
    if (struct_module == NULL) {
        return 0;
    }
    struct_error = PyObject_GetAttrString(struct_module, "error");
    if (struct_error == NULL) {
        return 0;
    }
    struct_unpack_method = PyObject_GetAttrString(struct_module, "unpack");
    return struct_unpack_method != NULL;
}
/* Fuzz struct.unpack(x, y) */
static int fuzz_struct_unpack(const char* data, size_t size) {
    /* Everything up to the first null byte is considered the
       format. Everything after is the buffer */
    const char* first_null = memchr(data, '\0', size);
    if (first_null == NULL) {
        return 0;
    }

    size_t format_length = first_null - data;
    size_t buffer_length = size - format_length - 1;

    PyObject* pattern = PyBytes_FromStringAndSize(data, format_length);
    if (pattern == NULL) {
        return 0;
    }
    PyObject* buffer = PyBytes_FromStringAndSize(first_null + 1, buffer_length);
    if (buffer == NULL) {
        Py_DECREF(pattern);
        return 0;
    }

    PyObject* unpacked = PyObject_CallFunctionObjArgs(
        struct_unpack_method, pattern, buffer, NULL);
    /* Ignore any overflow errors, these are easily triggered accidentally */
    if (unpacked == NULL && PyErr_ExceptionMatches(PyExc_OverflowError)) {
        PyErr_Clear();
    }
    /* The pascal format string will throw a negative size when passing 0
       like: struct.unpack('0p', b'') */
    if (unpacked == NULL && PyErr_ExceptionMatches(PyExc_SystemError)) {
        PyErr_Clear();
    }
    /* Ignore any struct.error exceptions, these can be caused by invalid
       formats or incomplete buffers both of which are common. */
    if (unpacked == NULL && PyErr_ExceptionMatches(struct_error)) {
        PyErr_Clear();
    }

    Py_XDECREF(unpacked);
    Py_DECREF(pattern);
    Py_DECREF(buffer);
    return 0;
}


#define MAX_JSON_TEST_SIZE 0x100000

PyObject* json_loads_method = NULL;
/* Called by LLVMFuzzerTestOneInput for initialization */
static int init_json_loads(void) {
    /* Import json.loads */
    PyObject* json_module = PyImport_ImportModule("json");
    if (json_module == NULL) {
        return 0;
    }
    json_loads_method = PyObject_GetAttrString(json_module, "loads");
    return json_loads_method != NULL;
}
/* Fuzz json.loads(x) */
static int fuzz_json_loads(const char* data, size_t size) {
    /* Since python supports arbitrarily large ints in JSON,
       long inputs can lead to timeouts on boring inputs like
       `json.loads("9" * 100000)` */
    if (size > MAX_JSON_TEST_SIZE) {
        return 0;
    }
    PyObject* input_bytes = PyBytes_FromStringAndSize(data, size);
    if (input_bytes == NULL) {
        return 0;
    }
    PyObject* parsed = PyObject_CallOneArg(json_loads_method, input_bytes);
    if (parsed == NULL) {
        /* Ignore ValueError as the fuzzer will more than likely
           generate some invalid json and values */
        if (PyErr_ExceptionMatches(PyExc_ValueError) ||
        /* Ignore RecursionError as the fuzzer generates long sequences of
           arrays such as `[[[...` */
            PyErr_ExceptionMatches(PyExc_RecursionError) ||
        /* Ignore unicode errors, invalid byte sequences are common */
            PyErr_ExceptionMatches(PyExc_UnicodeDecodeError)
        ) {
            PyErr_Clear();
        }
    }
    Py_DECREF(input_bytes);
    Py_XDECREF(parsed);
    return 0;
}

#define MAX_RE_TEST_SIZE 0x10000

PyObject* re_compile_method = NULL;
PyObject* re_error_exception = NULL;
int RE_FLAG_DEBUG = 0;
/* Called by LLVMFuzzerTestOneInput for initialization */
static int init_sre_compile(void) {
    /* Import sre_compile.compile and sre.error */
    PyObject* re_module = PyImport_ImportModule("re");
    if (re_module == NULL) {
        return 0;
    }
    re_compile_method = PyObject_GetAttrString(re_module, "compile");
    if (re_compile_method == NULL) {
        return 0;
    }

    re_error_exception = PyObject_GetAttrString(re_module, "error");
    if (re_error_exception == NULL) {
        return 0;
    }
    PyObject* debug_flag = PyObject_GetAttrString(re_module, "DEBUG");
    if (debug_flag == NULL) {
        return 0;
    }
    RE_FLAG_DEBUG = PyLong_AsLong(debug_flag);
    return 1;
}
/* Fuzz re.compile(x) */
static int fuzz_sre_compile(const char* data, size_t size) {
    /* Ignore really long regex patterns that will timeout the fuzzer */
    if (size > MAX_RE_TEST_SIZE) {
        return 0;
    }
    /* We treat the first 2 bytes of the input as a number for the flags */
    if (size < 2) {
        return 0;
    }
    uint16_t flags = ((uint16_t*) data)[0];
    /* We remove the SRE_FLAG_DEBUG if present. This is because it
       prints to stdout which greatly decreases fuzzing speed */
    flags &= ~RE_FLAG_DEBUG;

    /* Pull the pattern from the remaining bytes */
    PyObject* pattern_bytes = PyBytes_FromStringAndSize(data + 2, size - 2);
    if (pattern_bytes == NULL) {
        return 0;
    }
    PyObject* flags_obj = PyLong_FromUnsignedLong(flags);
    if (flags_obj == NULL) {
        Py_DECREF(pattern_bytes);
        return 0;
    }

    /* compiled = re.compile(data[2:], data[0:2] */
    PyObject* compiled = PyObject_CallFunctionObjArgs(
        re_compile_method, pattern_bytes, flags_obj, NULL);
    /* Ignore ValueError as the fuzzer will more than likely
       generate some invalid combination of flags */
    if (compiled == NULL && PyErr_ExceptionMatches(PyExc_ValueError)) {
        PyErr_Clear();
    }
    /* Ignore some common errors thrown by sre_parse:
       Overflow, Assertion, Recursion and Index */
    if (compiled == NULL && (PyErr_ExceptionMatches(PyExc_OverflowError) ||
                             PyErr_ExceptionMatches(PyExc_AssertionError) ||
                             PyErr_ExceptionMatches(PyExc_RecursionError) ||
                             PyErr_ExceptionMatches(PyExc_IndexError))
    ) {
        PyErr_Clear();
    }
    /* Ignore re.error */
    if (compiled == NULL && PyErr_ExceptionMatches(re_error_exception)) {
        PyErr_Clear();
    }

    Py_DECREF(pattern_bytes);
    Py_DECREF(flags_obj);
    Py_XDECREF(compiled);
    return 0;
}

/* Some random patterns used to test re.match.
   Be careful not to add catostraphically slow regexes here, we want to
   exercise the matching code without causing timeouts.*/
static const char* regex_patterns[] = {
    ".", "^", "abc", "abc|def", "^xxx$", "\\b", "()", "[a-zA-Z0-9]",
    "abc+", "[^A-Z]", "[x]", "(?=)", "a{z}", "a+b", "a*?", "a??", "a+?",
    "{}", "a{,}", "{", "}", "^\\(*\\d{3}\\)*( |-)*\\d{3}( |-)*\\d{4}$",
    "(?:a*)*", "a{1,2}?"
};
const size_t NUM_PATTERNS = sizeof(regex_patterns) / sizeof(regex_patterns[0]);
PyObject** compiled_patterns = NULL;
/* Called by LLVMFuzzerTestOneInput for initialization */
static int init_sre_match(void) {
    PyObject* re_module = PyImport_ImportModule("re");
    if (re_module == NULL) {
        return 0;
    }
    compiled_patterns = (PyObject**) PyMem_RawMalloc(
        sizeof(PyObject*) * NUM_PATTERNS);
    if (compiled_patterns == NULL) {
        PyErr_NoMemory();
        return 0;
    }

    /* Precompile all the regex patterns on the first run for faster fuzzing */
    for (size_t i = 0; i < NUM_PATTERNS; i++) {
        PyObject* compiled = PyObject_CallMethod(
            re_module, "compile", "y", regex_patterns[i]);
        /* Bail if any of the patterns fail to compile */
        if (compiled == NULL) {
            return 0;
        }
        compiled_patterns[i] = compiled;
    }
    return 1;
}
/* Fuzz re.match(x) */
static int fuzz_sre_match(const char* data, size_t size) {
    if (size < 1 || size > MAX_RE_TEST_SIZE) {
        return 0;
    }
    /* Use the first byte as a uint8_t specifying the index of the
       regex to use */
    unsigned char idx = (unsigned char) data[0];
    idx = idx % NUM_PATTERNS;

    /* Pull the string to match from the remaining bytes */
    PyObject* to_match = PyBytes_FromStringAndSize(data + 1, size - 1);
    if (to_match == NULL) {
        return 0;
    }

    PyObject* pattern = compiled_patterns[idx];
    PyObject* match_callable = PyObject_GetAttrString(pattern, "match");

    PyObject* matches = PyObject_CallOneArg(match_callable, to_match);

    Py_XDECREF(matches);
    Py_DECREF(match_callable);
    Py_DECREF(to_match);
    return 0;
}

#define MAX_CSV_TEST_SIZE 0x100000
PyObject* csv_module = NULL;
PyObject* csv_error = NULL;
/* Called by LLVMFuzzerTestOneInput for initialization */
static int init_csv_reader(void) {
    /* Import csv and csv.Error */
    csv_module = PyImport_ImportModule("csv");
    if (csv_module == NULL) {
        return 0;
    }
    csv_error = PyObject_GetAttrString(csv_module, "Error");
    return csv_error != NULL;
}
/* Fuzz csv.reader([x]) */
static int fuzz_csv_reader(const char* data, size_t size) {
    if (size < 1 || size > MAX_CSV_TEST_SIZE) {
        return 0;
    }
    /* Ignore non null-terminated strings since _csv can't handle
       embedded nulls */
    if (memchr(data, '\0', size) == NULL) {
        return 0;
    }

    PyObject* s = PyUnicode_FromString(data);
    /* Ignore exceptions until we have a valid string */
    if (s == NULL) {
        PyErr_Clear();
        return 0;
    }

    /* Split on \n so we can test multiple lines */
    PyObject* lines = PyObject_CallMethod(s, "split", "s", "\n");
    if (lines == NULL) {
        Py_DECREF(s);
        return 0;
    }

    PyObject* reader = PyObject_CallMethod(csv_module, "reader", "N", lines);
    if (reader) {
        /* Consume all of the reader as an iterator */
        PyObject* parsed_line;
        while ((parsed_line = PyIter_Next(reader))) {
            Py_DECREF(parsed_line);
        }
    }

    /* Ignore csv.Error because we're probably going to generate
       some bad files (embedded new-lines, unterminated quotes etc) */
    if (PyErr_ExceptionMatches(csv_error)) {
        PyErr_Clear();
    }

    Py_XDECREF(reader);
    Py_DECREF(s);
    return 0;
}

#define MAX_AST_LITERAL_EVAL_TEST_SIZE 0x100000
PyObject* ast_literal_eval_method = NULL;
/* Called by LLVMFuzzerTestOneInput for initialization */
static int init_ast_literal_eval(void) {
    PyObject* ast_module = PyImport_ImportModule("ast");
    if (ast_module == NULL) {
        return 0;
    }
    ast_literal_eval_method = PyObject_GetAttrString(ast_module, "literal_eval");
    return ast_literal_eval_method != NULL;
}
/* Fuzz ast.literal_eval(x) */
static int fuzz_ast_literal_eval(const char* data, size_t size) {
    if (size > MAX_AST_LITERAL_EVAL_TEST_SIZE) {
        return 0;
    }
    /* Ignore non null-terminated strings since ast can't handle
       embedded nulls */
    if (memchr(data, '\0', size) == NULL) {
        return 0;
    }

    PyObject* s = PyUnicode_FromString(data);
    /* Ignore exceptions until we have a valid string */
    if (s == NULL) {
        PyErr_Clear();
        return 0;
    }

    PyObject* literal = PyObject_CallOneArg(ast_literal_eval_method, s);
    /* Ignore some common errors thrown by ast.literal_eval */
    if (literal == NULL && (PyErr_ExceptionMatches(PyExc_ValueError) ||
                            PyErr_ExceptionMatches(PyExc_TypeError) ||
                            PyErr_ExceptionMatches(PyExc_SyntaxError) ||
                            PyErr_ExceptionMatches(PyExc_MemoryError) ||
                            PyErr_ExceptionMatches(PyExc_RecursionError))
    ) {
        PyErr_Clear();
    }

    Py_XDECREF(literal);
    Py_DECREF(s);
    return 0;
}

#define MAX_ELEMENTTREE_PARSEWHOLE_TEST_SIZE 0x100000
PyObject* xmlparser_type = NULL;
PyObject* bytesio_type = NULL;
/* Called by LLVMFuzzerTestOneInput for initialization */
static int init_elementtree_parsewhole(void) {
    PyObject* elementtree_module = PyImport_ImportModule("_elementtree");
    if (elementtree_module == NULL) {
        return 0;
    }
    xmlparser_type = PyObject_GetAttrString(elementtree_module, "XMLParser");
    Py_DECREF(elementtree_module);
    if (xmlparser_type == NULL) {
        return 0;
    }


    PyObject* io_module = PyImport_ImportModule("io");
    if (io_module == NULL) {
        return 0;
    }
    bytesio_type = PyObject_GetAttrString(io_module, "BytesIO");
    Py_DECREF(io_module);
    if (bytesio_type == NULL) {
        return 0;
    }

    return 1;
}
/* Fuzz _elementtree.XMLParser._parse_whole(x) */
static int fuzz_elementtree_parsewhole(const char* data, size_t size) {
    if (size > MAX_ELEMENTTREE_PARSEWHOLE_TEST_SIZE) {
        return 0;
    }

    PyObject *input = PyObject_CallFunction(bytesio_type, "y#", data, (Py_ssize_t)size);
    if (input == NULL) {
        assert(PyErr_Occurred());
        PyErr_Print();
        abort();
    }

    PyObject *xmlparser_instance = PyObject_CallObject(xmlparser_type, NULL);
    if (xmlparser_instance == NULL) {
        assert(PyErr_Occurred());
        PyErr_Print();
        abort();
    }

    PyObject *result = PyObject_CallMethod(xmlparser_instance, "_parse_whole", "O", input);
    if (result == NULL) {
        /* Ignore exception here, which can be caused by invalid XML input */
        PyErr_Clear();
    } else {
        Py_DECREF(result);
    }

    Py_DECREF(xmlparser_instance);
    Py_DECREF(input);

    return 0;
}

#define MAX_PYCOMPILE_TEST_SIZE 16384

static const int start_vals[] = {Py_eval_input, Py_single_input, Py_file_input};
const size_t NUM_START_VALS = sizeof(start_vals) / sizeof(start_vals[0]);

static const int optimize_vals[] = {-1, 0, 1, 2};
const size_t NUM_OPTIMIZE_VALS = sizeof(optimize_vals) / sizeof(optimize_vals[0]);

/* Fuzz `PyCompileStringExFlags` using a variety of input parameters.
 * That function is essentially behind the `compile` builtin */
static int fuzz_pycompile(const char* data, size_t size) {
    // Ignore overly-large inputs, and account for a NUL terminator
    if (size > MAX_PYCOMPILE_TEST_SIZE - 1) {
        return 0;
    }

    // Need 2 bytes for parameter selection
    if (size < 2) {
        return 0;
    }

    // Use first byte to determine element of `start_vals` to use
    unsigned char start_idx = (unsigned char) data[0];
    int start = start_vals[start_idx % NUM_START_VALS];

    // Use second byte to determine element of `optimize_vals` to use
    unsigned char optimize_idx = (unsigned char) data[1];
    int optimize = optimize_vals[optimize_idx % NUM_OPTIMIZE_VALS];

    char pycompile_scratch[MAX_PYCOMPILE_TEST_SIZE];

    // Create a NUL-terminated C string from the remaining input
    memcpy(pycompile_scratch, data + 2, size - 2);
    // Put a NUL terminator just after the copied data. (Space was reserved already.)
    pycompile_scratch[size - 2] = '\0';

    // XXX: instead of always using NULL for the `flags` value to
    // `Py_CompileStringExFlags`, there are many flags that conditionally
    // change parser behavior:
    //
    //     #define PyCF_TYPE_COMMENTS 0x1000
    //     #define PyCF_ALLOW_TOP_LEVEL_AWAIT 0x2000
    //     #define PyCF_ONLY_AST 0x0400
    //
    // It would be good to test various combinations of these, too.
    PyCompilerFlags *flags = NULL;

    PyObject *result = Py_CompileStringExFlags(pycompile_scratch, "<fuzz input>", start, flags, optimize);
    if (result == NULL) {
        /* Compilation failed, most likely from a syntax error. If it was a
           SystemError we abort. There's no non-bug reason to raise a
           SystemError. */
        if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_SystemError)) {
            PyErr_Print();
            abort();
        }
        PyErr_Clear();
    } else {
        Py_DECREF(result);
    }

    return 0;
}

/* Run fuzzer and abort on failure. */
static int _run_fuzz(const uint8_t *data, size_t size, int(*fuzzer)(const char* , size_t)) {
    int rv = fuzzer((const char*) data, size);
    if (PyErr_Occurred()) {
        /* Fuzz tests should handle expected errors for themselves.
           This is last-ditch check in case they didn't. */
        PyErr_Print();
        abort();
    }
    /* Someday the return value might mean something, propagate it. */
    return rv;
}

/* CPython generates a lot of leak warnings for whatever reason. */
int __lsan_is_turned_off(void) { return 1; }


int LLVMFuzzerInitialize(int *argc, char ***argv) {
    PyConfig config;
    PyConfig_InitPythonConfig(&config);
    config.install_signal_handlers = 0;
    /* Raise the limit above the default allows exercising larger things
     * now that we fall back to the _pylong module for large values. */
    config.int_max_str_digits = 8086;
    PyStatus status;
    status = PyConfig_SetBytesString(&config, &config.program_name, *argv[0]);
    if (PyStatus_Exception(status)) {
        goto fail;
    }

    status = Py_InitializeFromConfig(&config);
    if (PyStatus_Exception(status)) {
        goto fail;
    }
    PyConfig_Clear(&config);

    return 0;

fail:
    PyConfig_Clear(&config);
    Py_ExitStatusException(status);
}

/* Fuzz test interface.
   This returns the bitwise or of all fuzz test's return values.

   All fuzz tests must return 0, as all nonzero return codes are reserved for
   future use -- we propagate the return values for that future case.
   (And we bitwise or when running multiple tests to verify that normally we
   only return 0.) */
int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
    assert(Py_IsInitialized());

    int rv = 0;

#if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_builtin_float)
    rv |= _run_fuzz(data, size, fuzz_builtin_float);
#endif
#if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_builtin_int)
    rv |= _run_fuzz(data, size, fuzz_builtin_int);
#endif
#if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_builtin_unicode)
    rv |= _run_fuzz(data, size, fuzz_builtin_unicode);
#endif
#if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_struct_unpack)
    static int STRUCT_UNPACK_INITIALIZED = 0;
    if (!STRUCT_UNPACK_INITIALIZED && !init_struct_unpack()) {
        PyErr_Print();
        abort();
    } else {
        STRUCT_UNPACK_INITIALIZED = 1;
    }
    rv |= _run_fuzz(data, size, fuzz_struct_unpack);
#endif
#if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_json_loads)
    static int JSON_LOADS_INITIALIZED = 0;
    if (!JSON_LOADS_INITIALIZED && !init_json_loads()) {
        PyErr_Print();
        abort();
    } else {
        JSON_LOADS_INITIALIZED = 1;
    }

    rv |= _run_fuzz(data, size, fuzz_json_loads);
#endif
#if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_sre_compile)
    static int SRE_COMPILE_INITIALIZED = 0;
    if (!SRE_COMPILE_INITIALIZED && !init_sre_compile()) {
        PyErr_Print();
        abort();
    } else {
        SRE_COMPILE_INITIALIZED = 1;
    }

    if (SRE_COMPILE_INITIALIZED) {
        rv |= _run_fuzz(data, size, fuzz_sre_compile);
    }
#endif
#if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_sre_match)
    static int SRE_MATCH_INITIALIZED = 0;
    if (!SRE_MATCH_INITIALIZED && !init_sre_match()) {
        PyErr_Print();
        abort();
    } else {
        SRE_MATCH_INITIALIZED = 1;
    }

    rv |= _run_fuzz(data, size, fuzz_sre_match);
#endif
#if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_csv_reader)
    static int CSV_READER_INITIALIZED = 0;
    if (!CSV_READER_INITIALIZED && !init_csv_reader()) {
        PyErr_Print();
        abort();
    } else {
        CSV_READER_INITIALIZED = 1;
    }

    rv |= _run_fuzz(data, size, fuzz_csv_reader);
#endif
#if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_ast_literal_eval)
    static int AST_LITERAL_EVAL_INITIALIZED = 0;
    if (!AST_LITERAL_EVAL_INITIALIZED && !init_ast_literal_eval()) {
        PyErr_Print();
        abort();
    } else {
        AST_LITERAL_EVAL_INITIALIZED = 1;
    }

    rv |= _run_fuzz(data, size, fuzz_ast_literal_eval);
#endif
#if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_elementtree_parsewhole)
    static int ELEMENTTREE_PARSEWHOLE_INITIALIZED = 0;
    if (!ELEMENTTREE_PARSEWHOLE_INITIALIZED && !init_elementtree_parsewhole()) {
        PyErr_Print();
        abort();
    } else {
        ELEMENTTREE_PARSEWHOLE_INITIALIZED = 1;
    }

    rv |= _run_fuzz(data, size, fuzz_elementtree_parsewhole);
#endif
#if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_pycompile)
    rv |= _run_fuzz(data, size, fuzz_pycompile);
#endif
  return rv;
}


================================================
File: /Modules/_xxtestfuzz/dictionaries/fuzz_elementtree_parsewhole.dict
================================================
tok_1="<"
tok_2=">"
tok_3="/"
tok_4="<![CDATA["
tok_5="]]>"
tok_6="<?xml"
tok_6a="?>"
tok_7="version"
tok_8="encoding"
tok_9="UTF-8"
tok_9a="UTF-16"
tok_9b="ASCII"
tok_9c="LATIN-1"
tok_9d="UTF-32"
tok_9e="UTF-7"
tok_10="\""
tok_11="&"
tok_11a="&#"
tok_11b=";"
tok_12="'"
tok_13="<!--"
tok_13a="-->"
tok_14="</"
tok_15="="
tok_16="&gt;"
tok_17="&lt;"
tok_18="&amp;"
tok_19="&apos;"
tok_20="&quot;"
tok_21="&#20013;"
tok_22="&#x4e2d;"
tok_23="&#0;"
tok_24="<!ENTITY"
tok_25="SYSTEM"
tok_26="PUBLIC"
tok_27="NDATA"
tok_28="["
tok_29="]"
tok_30="\\"
tok_30a="\\x00"
tok_31="0"
tok_32="1"
tok_33="2"
tok_34="3"
tok_35="4"
tok_36="5"
tok_37="6"
tok_38="7"
tok_39="8"
tok_40="9"
tok_41="iso8859_1"
tok_42="latin_1"
tok_43="us.ascii"
tok_43a="us_ascii"
tok_43b="ascii"
tok_44="xml:"
tok_45="surrogate"
tok_46="replace"
tok_47="strict"

attr_encoding=" encoding=\"1\""
attr_generic=" a=\"1\""
attr_href=" href=\"1\""
attr_standalone=" standalone=\"no\""
attr_version=" version=\"1\""
attr_xml_base=" xml:base=\"1\""
attr_xml_id=" xml:id=\"1\""
attr_xml_lang=" xml:lang=\"1\""
attr_xml_space=" xml:space=\"1\""
attr_xmlns=" xmlns=\"1\""

entity_builtin="&lt;"
entity_decimal="&#1;"
entity_external="&a;"
entity_hex="&#x1;"

string_any="ANY"
string_brackets="[]"
string_cdata="CDATA"
string_col_fallback=":fallback"
string_col_generic=":a"
string_col_include=":include"
string_dashes="--"
string_empty="EMPTY"
string_empty_dblquotes="\"\""
string_empty_quotes="''"
string_entities="ENTITIES"
string_entity="ENTITY"
string_fixed="#FIXED"
string_id="ID"
string_idref="IDREF"
string_idrefs="IDREFS"
string_implied="#IMPLIED"
string_nmtoken="NMTOKEN"
string_nmtokens="NMTOKENS"
string_notation="NOTATION"
string_parentheses="()"
string_pcdata="#PCDATA"
string_percent="%a"
string_public="PUBLIC"
string_required="#REQUIRED"
string_schema=":schema"
string_system="SYSTEM"
string_ucs4="UCS-4"
string_utf16="UTF-16"
string_utf8="UTF-8"
string_xmlns="xmlns:"

tag_attlist="<!ATTLIST"
tag_cdata="<![CDATA["
tag_close="</a>"
tag_doctype="<!DOCTYPE"
tag_element="<!ELEMENT"
tag_entity="<!ENTITY"
tag_ignore="<![IGNORE["
tag_include="<![INCLUDE["
tag_notation="<!NOTATION"
tag_open="<a>"
tag_open_close="<a />"
tag_open_exclamation="<!"
tag_open_q="<?"
tag_sq2_close="]]>"
tag_xml_q="<?xml?>"

encoding_utf="UTF-"
encoding_iso1="ISO-8859"
encoding_iso3="ISO-10646-UCS"
encoding_iso5="ISO-LATIN-1"
encoding_jis="SHIFT_JIS"
encoding_utf7="UTF-7"
encoding_utf16le="UTF-16BE"
encoding_utf16le="UTF-16LE"
encoding_ascii="US-ASCII"
encoding_latin1="latin1"


================================================
File: /Modules/_xxtestfuzz/dictionaries/fuzz_json_loads.dict
================================================
"0"
",0"
":0"
"0:"
"-1.2e+3"

"true"
"false"
"null"

"\"\""
",\"\""
":\"\""
"\"\":"

"{}"
",{}"
":{}"
"{\"\":0}"
"{{}}"

"[]"
",[]"
":[]"
"[0]"
"[[]]"

"''"
"\\"
"\\b"
"\\f"
"\\n"
"\\r"
"\\t"
"\\u0000"
"\\x00"
"\\0"
"\\uD800\\uDC00"
"\\uDBFF\\uDFFF"



================================================
File: /Modules/_xxtestfuzz/dictionaries/fuzz_pycompile.dict
================================================
# bits of syntax
"( "
") "
"[ "
"] "
": "
", "
"; "
"{ "
"} "

# operators
"+ "
"- "
"* "
"** "
"/ "
"// "
"| "
"& "
"< "
"> "
"= "
". "
"% "
"` "
"^ "
"~ "
"@ "
"== "
"!= "
"<> "
"<< "
"<= "
">= "
">> "
"+= "
"-= "
"*= "
"** "
"/= "
"//= "
"|= "
"%= "
"&= "
"^= "
"<<= "
">>= "
"**= "
":= "
"@= "

# whitespace
"  "
":\\n  "

# type signatures and functions
"-> "
": List[int]"
": Dict[int, str]"

"# type:"
"# type: List[int]"
"# type: Dict[int, str]"

", *"
", /"
", *args"
", **kwargs"
", x=42"


# literals
"0x0a"
"0b0000"
"42"
"0o70"
"42j"
"42.01"
"-5"
"+42e-3"
"0_0_0"
"1e1_0"
".1_4"

"{}"

# variable names
"x"
"y"

# strings
"r'x'"

"b'x'"

"rb\"x\""

"br\"x\""

"f'{x + 5}'"
"f\"{x + 5}\""

"'''"
"\"\"\""

"\\u"
"\\x"

# keywords
"def "
"del "
"pass "
"break "
"continue "
"return "
"raise "
"from "
"import "
".. "
"... "
"__future__ "
"as "
"global "
"nonlocal "
"assert "
"print "
"if "
"elif "
"else: "
"while "
"try: "
"except "
"finally: "
"with "
"lambda "
"or "
"and "
"not "
"None "
"__peg_parser__"
"True "
"False "
"yield "
"async "
"await "
"for "
"in "
"is "
"class "

# shebangs and encodings
"#!"
"# coding:"
"# coding="
"# coding: latin-1"
"# coding=latin-1"
"# coding: utf-8"
"# coding=utf-8"
"# coding: ascii"
"# coding=ascii"
"# coding: cp860"
"# coding=cp860"
"# coding: gbk"
"# coding=gbk"


================================================
File: /Modules/_xxtestfuzz/dictionaries/fuzz_sre_compile.dict
================================================
"?"
"abc"
"()"
"[]"
"abc|def"
"abc|def|ghi"
"^xxx$"
"ab\\b\\d\\bcd"
"\\w|\\d"
"a*?"
"abc+"
"abc+?"
"xyz?"
"xyz??"
"xyz{0,1}"
"xyz{0,1}?"
"xyz{93}"
"xyz{1,32}"
"xyz{1,32}?"
"xyz{1,}"
"xyz{1,}?"
"a\\fb\\nc\\rd\\te\\vf"
"a\\nb\\bc"
"(?:foo)"
"(?: foo )"
"foo|(bar|baz)|quux"
"foo(?=bar)baz"
"foo(?!bar)baz"
"foo(?<=bar)baz"
"foo(?<!bar)baz"
"()"
"(?=)"
"[]"
"[x]"
"[xyz]"
"[a-zA-Z0-9]"
"[-123]"
"[^123]"
"]"
"}"
"[a-b-c]"
"[x\\dz]"
"[\\d-z]"
"[\\d-\\d]"
"[z-\\d]"
"\\cj\\cJ\\ci\\cI\\ck\\cK"
"\\c!"
"\\c_"
"\\c~"
"[\\c!]"
"[\\c_]"
"[\\c~]"
"[\\ca]"
"[\\cz]"
"[\\cA]"
"[\\cZ]"
"[\\c1]"
"\\[\\]\\{\\}\\(\\)\\%\\^\\#\\ "
"[\\[\\]\\{\\}\\(\\)\\%\\^\\#\\ ]"
"\\8"
"\\9"
"\\11"
"\\11a"
"\\011"
"\\118"
"\\111"
"\\1111"
"(x)(x)(x)\\1"
"(x)(x)(x)\\2"
"(x)(x)(x)\\3"
"(x)(x)(x)\\4"
"(x)(x)(x)\\1*"
"(x)(x)(x)\\3*"
"(x)(x)(x)\\4*"
"(x)(x)(x)(x)(x)(x)(x)(x)(x)(x)\\10"
"(x)(x)(x)(x)(x)(x)(x)(x)(x)(x)\\11"
"(a)\\1"
"(a\\1)"
"(\\1a)"
"(\\2)(\\1)"
"(?=a){0,10}a"
"(?=a){1,10}a"
"(?=a){9,10}a"
"(?!a)?a"
"\\1(a)"
"(?!(a))\\1"
"(?!\\1(a\\1)\\1)\\1"
"\\1\\2(a(?:\\1(b\\1\\2))\\2)\\1"
"[\\0]"
"[\\11]"
"[\\11a]"
"[\\011]"
"[\\00011]"
"[\\118]"
"[\\111]"
"[\\1111]"
"\\x60"
"\\x3z"
"\\c"
"\\u0034"
"\\u003z"
"foo[z]*"
"\\u{12345}"
"\\u{12345}\\u{23456}"
"\\u{12345}{3}"
"\\u{12345}*"
"\\ud808\\udf45*"
"[\\ud808\\udf45-\\ud809\\udccc]"
"a"
"a|b"
"a\\n"
"a$"
"a\\b!"
"a\\Bb"
"a*?"
"a?"
"a??"
"a{0,1}?"
"a{1,2}?"
"a+?"
"(a)"
"(a)\\1"
"(\\1a)"
"\\1(a)"
"a\\s"
"a\\S"
"a\\D"
"a\\w"
"a\\W"
"a."
"a\\q"
"a[a]"
"a[^a]"
"a[a-z]"
"a(?:b)"
"a(?=b)"
"a(?!b)"
"\\x60"
"\\u0060"
"\\cA"
"\\q"
"\\1112"
"(a)\\1"
"(?!a)?a\\1"
"(?:(?=a))a\\1"
"a{}"
"a{,}"
"a{"
"a{z}"
"a{12z}"
"a{12,"
"a{12,3b"
"{}"
"{,}"
"{"
"{z}"
"{1z}"
"{12,"
"{12,3b"
"a"
"abc"
"a[bc]d"
"a|bc"
"ab|c"
"a||bc"
"(?:ab)"
"(?:ab|cde)"
"(?:ab)|cde"
"(ab)"
"(ab|cde)"
"(ab)\\1"
"(ab|cde)\\1"
"(?:ab)?"
"(?:ab)+"
"a?"
"a+"
"a??"
"a*?"
"a+?"
"(?:a?)?"
"(?:a+)?"
"(?:a?)+"
"(?:a*)+"
"(?:a+)+"
"(?:a?)*"
"(?:a*)*"
"(?:a+)*"
"a{0}"
"(?:a+){0,0}"
"a*b"
"a+b"
"a*b|c"
"a+b|c"
"(?:a{5,1000000}){3,1000000}"
"(?:ab){4,7}"
"a\\bc"
"a\\sc"
"a\\Sc"
"a(?=b)c"
"a(?=bbb|bb)c"
"a(?!bbb|bb)c"
"\xe2\x81\xa3"
"[\xe2\x81\xa3]"
"\xed\xb0\x80"
"\xed\xa0\x80"
"(\xed\xb0\x80)\x01"
"((\xed\xa0\x80))\x02"
"\xf0\x9f\x92\xa9"
"\x01"
"\x0f"
"[-\xf0\x9f\x92\xa9]+"
"[\xf0\x9f\x92\xa9-\xf4\x8f\xbf\xbf]"
"(?<=)"
"(?<=a)"
"(?<!)"
"(?<!a)"
"(?<a>)"
"(?<a>.)"
"(?<a>.)\\k<a>"


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/c14nComment.xml
================================================
<dsig:CanonicalizationMethod xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:c14n2="http://www.w3.org/2010/xml-c14n2" Algorithm="http://www.w3.org/2010/xml-c14n2">
 <c14n2:IgnoreComments>true</c14n2:IgnoreComments>
</dsig:CanonicalizationMethod>



================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/c14nDefault.xml
================================================
<dsig:CanonicalizationMethod xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" Algorithm="http://www.w3.org/2010/xml-c14n2">
</dsig:CanonicalizationMethod>



================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/c14nPrefix.xml
================================================
<dsig:CanonicalizationMethod xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:c14n2="http://www.w3.org/2010/xml-c14n2" Algorithm="http://www.w3.org/2010/xml-c14n2">
 <c14n2:PrefixRewrite>sequential</c14n2:PrefixRewrite>
</dsig:CanonicalizationMethod>



================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/c14nPrefixQname.xml
================================================
<dsig:CanonicalizationMethod xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:c14n2="http://www.w3.org/2010/xml-c14n2" Algorithm="http://www.w3.org/2010/xml-c14n2">
  <c14n2:PrefixRewrite>sequential</c14n2:PrefixRewrite>
  <c14n2:QNameAware>
   <c14n2:QualifiedAttr Name="type" NS="http://www.w3.org/2001/XMLSchema-instance"/>
  </c14n2:QNameAware>
</dsig:CanonicalizationMethod>



================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/c14nPrefixQnameXpathElem.xml
================================================
<dsig:CanonicalizationMethod xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:c14n2="http://www.w3.org/2010/xml-c14n2" Algorithm="http://www.w3.org/2010/xml-c14n2">
  <c14n2:PrefixRewrite>sequential</c14n2:PrefixRewrite>
  <c14n2:QNameAware>
   <c14n2:Element Name="bar" NS="http://a"/>
   <c14n2:XPathElement Name="IncludedXPath" NS="http://www.w3.org/2010/xmldsig2#"/>
  </c14n2:QNameAware>
</dsig:CanonicalizationMethod>



================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/c14nQname.xml
================================================
<dsig:CanonicalizationMethod xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:c14n2="http://www.w3.org/2010/xml-c14n2" Algorithm="http://www.w3.org/2010/xml-c14n2">
  <c14n2:QNameAware>
   <c14n2:QualifiedAttr Name="type" NS="http://www.w3.org/2001/XMLSchema-instance"/>
  </c14n2:QNameAware>
</dsig:CanonicalizationMethod>



================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/c14nQnameElem.xml
================================================
<dsig:CanonicalizationMethod xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:c14n2="http://www.w3.org/2010/xml-c14n2" Algorithm="http://www.w3.org/2010/xml-c14n2">
  <c14n2:QNameAware>
   <c14n2:Element Name="bar" NS="http://a"/>
  </c14n2:QNameAware>
</dsig:CanonicalizationMethod>



================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/c14nQnameXpathElem.xml
================================================
<dsig:CanonicalizationMethod xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:c14n2="http://www.w3.org/2010/xml-c14n2" Algorithm="http://www.w3.org/2010/xml-c14n2">
  <c14n2:QNameAware>
   <c14n2:Element Name="bar" NS="http://a"/>
   <c14n2:XPathElement Name="IncludedXPath" NS="http://www.w3.org/2010/xmldsig2#"/>
  </c14n2:QNameAware>
</dsig:CanonicalizationMethod>



================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/c14nTrim.xml
================================================
<dsig:CanonicalizationMethod xmlns:dsig="http://www.w3.org/2000/09/xmldsig#" xmlns:c14n2="http://www.w3.org/2010/xml-c14n2" Algorithm="http://www.w3.org/2010/xml-c14n2">
 <c14n2:TrimTextNodes>true</c14n2:TrimTextNodes>
</dsig:CanonicalizationMethod>



================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/expat224_utf8_bug.xml
================================================
<a b='01234567890123456古人咏雪抽幽思骋妍辞竞险韵偶得一编奇绝辄擅美当时流声后代是以北门之风南山之雅梁园之简黄台之赋至今为作家称述尚矣及至洛阳之卧剡溪之兴灞桥之思亦皆传为故事钱塘沈履德先生隐居西湖两峰间孤高贞洁与雪同调方大雪满天皴肤粟背之际先生乃鹿中豹舄端居闭门或扶童曳杖踏遍六桥三竺时取古人诗讽咏之合唐宋元诸名家集句成诗得二百四十章联络通穿如出一人如呵一气气立于言表格备于篇中略无掇拾补凑之形非胸次包罗壮阔笔底驱走鲍谢欧苏诸公不能为此世称王荆公为集句擅长观其在钟山对雪仅题数篇未见有此噫嘻奇矣哉亦富矣哉予慕先生有袁安之节愧不能为慧可之立乃取新集命工传写使海内同好者知先生为博古传述之士而一新世人之耳目他日必有慕潜德阐幽光而剞劂以传者余实为之执殳矣
弘治戊午仲冬望日慈溪杨子器衵于海虞官舍序毕诗部' />


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inC14N1.xml
================================================
<?xml version="1.0"?>

<?xml-stylesheet   href="doc.xsl"
   type="text/xsl"   ?>

<!DOCTYPE doc SYSTEM "doc.dtd">

<doc>Hello, world!<!-- Comment 1 --></doc>

<?pi-without-data     ?>

<!-- Comment 2 -->

<!-- Comment 3 -->


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inC14N2.xml
================================================
<doc>
   <clean>   </clean>
   <dirty>   A   B   </dirty>
   <mixed>
      A
      <clean>   </clean>
      B
      <dirty>   A   B   </dirty>
      C
   </mixed>
</doc>


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inC14N3.xml
================================================
<!DOCTYPE doc [<!ATTLIST e9 attr CDATA "default">]>
<doc>
   <e1   />
   <e2   ></e2>
   <e3   name = "elem3"   id="elem3"   />
   <e4   name="elem4"   id="elem4"   ></e4>
   <e5 a:attr="out" b:attr="sorted" attr2="all" attr="I'm"
      xmlns:b="http://www.ietf.org"
      xmlns:a="http://www.w3.org"
      xmlns="http://example.org"/>
   <e6 xmlns="" xmlns:a="http://www.w3.org">
      <e7 xmlns="http://www.ietf.org">
         <e8 xmlns="" xmlns:a="http://www.w3.org">
            <e9 xmlns="" xmlns:a="http://www.ietf.org"/>
         </e8>
      </e7>
   </e6>
</doc> 


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inC14N4.xml
================================================
<!DOCTYPE doc [
<!ATTLIST normId id ID #IMPLIED>
<!ATTLIST normNames attr NMTOKENS #IMPLIED>
]>
<doc>
   <text>First line&#x0d;&#10;Second line</text>
   <value>&#x32;</value>
   <compute><![CDATA[value>"0" && value<"10" ?"valid":"error"]]></compute>
   <compute expr='value>"0" &amp;&amp; value&lt;"10" ?"valid":"error"'>valid</compute>
   <norm attr=' &apos;   &#x20;&#13;&#xa;&#9;   &apos; '/>
   <normNames attr='   A   &#x20;&#13;&#xa;&#9;   B   '/>
   <normId id=' &apos;&#x20;&#13;&#xa;&#9; &apos; '/>
</doc>


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inC14N5.xml
================================================
<!DOCTYPE doc [
<!ATTLIST doc attrExtEnt CDATA #IMPLIED>
<!ENTITY ent1 "Hello">
<!ENTITY ent2 SYSTEM "world.txt">
<!ENTITY entExt SYSTEM "earth.gif" NDATA gif>
<!NOTATION gif SYSTEM "viewgif.exe">
]>
<doc attrExtEnt="entExt">
   &ent1;, &ent2;!
</doc>

<!-- Let world.txt contain "world" (excluding the quotes) -->


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inC14N6.xml
================================================
<?xml version="1.0" encoding="ISO-8859-1"?>
<doc>&#169;</doc>


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inNsContent.xml
================================================
<a:foo xmlns:a="http://a" xmlns:b="http://b" xmlns:child="http://c" xmlns:soap-env="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
 <a:bar>xsd:string</a:bar>
 <dsig2:IncludedXPath xmlns:dsig2="http://www.w3.org/2010/xmldsig2#">/soap-env:body/child::b:foo[@att1 != "c:val" and @att2 != 'xsd:string']</dsig2:IncludedXPath>
</a:foo>


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inNsDefault.xml
================================================
<foo xmlns:a="http://a" xmlns:b="http://b">
 <b:bar b:att1="val" att2="val"/>
</foo>


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inNsPushdown.xml
================================================
<a:foo xmlns:a="http://a" xmlns:b="http://b" xmlns:c="http://c">
 <b:bar/>
 <b:bar/>
 <b:bar/>
 <a:bar b:att1="val"/>
</a:foo>


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inNsRedecl.xml
================================================
<foo xmlns:a="http://z3" xmlns:b="http://z2" a:att1="val1" b:att2="val2"> 
 <bar xmlns="http://z0" xmlns:a="http://z2" a:att1="val1" b:att2="val2" xmlns:b="http://z3" />
</foo>


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inNsSort.xml
================================================
<a:foo xmlns:a="http://z3" xmlns:b="http://z2" b:att1="val1" c:att3="val3" b:att2="val2" xmlns:c="http://z1" xmlns:d="http://z0">
 <c:bar/>
 <c:bar d:att3="val3"/>
</a:foo>


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inNsSuperfluous.xml
================================================
<foo xmlns:a="http://z0" xmlns:b="http://z0" a:att1="val1" b:att2="val2" xmlns="http://z0"> 
 <c:bar xmlns:a="http://z0" xmlns:c="http://z0" c:att3="val3"/>
 <d:bar xmlns:d="http://z0"/>
</foo>


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/inNsXml.xml
================================================
<foo xmlns="http://z0" xml:id="23">
  <bar xsi:type="xsd:string" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:xsd="http://www.w3.org/2001/XMLSchema">data</bar>
</foo>


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inC14N1_c14nComment.xml
================================================
<?xml-stylesheet href="doc.xsl"
   type="text/xsl"   ?>
<doc>Hello, world!<!-- Comment 1 --></doc>
<?pi-without-data?>
<!-- Comment 2 -->
<!-- Comment 3 -->

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inC14N1_c14nDefault.xml
================================================
<?xml-stylesheet href="doc.xsl"
   type="text/xsl"   ?>
<doc>Hello, world!</doc>
<?pi-without-data?>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inC14N2_c14nDefault.xml
================================================
<doc>
   <clean>   </clean>
   <dirty>   A   B   </dirty>
   <mixed>
      A
      <clean>   </clean>
      B
      <dirty>   A   B   </dirty>
      C
   </mixed>
</doc>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inC14N2_c14nTrim.xml
================================================
<doc><clean></clean><dirty>A   B</dirty><mixed>A<clean></clean>B<dirty>A   B</dirty>C</mixed></doc>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inC14N3_c14nDefault.xml
================================================
<doc>
   <e1></e1>
   <e2></e2>
   <e3 id="elem3" name="elem3"></e3>
   <e4 id="elem4" name="elem4"></e4>
   <e5 xmlns="http://example.org" xmlns:a="http://www.w3.org" xmlns:b="http://www.ietf.org" attr="I'm" attr2="all" b:attr="sorted" a:attr="out"></e5>
   <e6>
      <e7 xmlns="http://www.ietf.org">
         <e8 xmlns="">
            <e9 attr="default"></e9>
         </e8>
      </e7>
   </e6>
</doc>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inC14N3_c14nPrefix.xml
================================================
<n0:doc xmlns:n0="">
   <n0:e1></n0:e1>
   <n0:e2></n0:e2>
   <n0:e3 id="elem3" name="elem3"></n0:e3>
   <n0:e4 id="elem4" name="elem4"></n0:e4>
   <n1:e5 xmlns:n1="http://example.org" xmlns:n2="http://www.ietf.org" xmlns:n3="http://www.w3.org" attr="I'm" attr2="all" n2:attr="sorted" n3:attr="out"></n1:e5>
   <n0:e6>
      <n2:e7 xmlns:n2="http://www.ietf.org">
         <n0:e8>
            <n0:e9 attr="default"></n0:e9>
         </n0:e8>
      </n2:e7>
   </n0:e6>
</n0:doc>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inC14N3_c14nTrim.xml
================================================
<doc><e1></e1><e2></e2><e3 id="elem3" name="elem3"></e3><e4 id="elem4" name="elem4"></e4><e5 xmlns="http://example.org" xmlns:a="http://www.w3.org" xmlns:b="http://www.ietf.org" attr="I'm" attr2="all" b:attr="sorted" a:attr="out"></e5><e6><e7 xmlns="http://www.ietf.org"><e8 xmlns=""><e9 attr="default"></e9></e8></e7></e6></doc>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inC14N4_c14nDefault.xml
================================================
<doc>
   <text>First line&#xD;
Second line</text>
   <value>2</value>
   <compute>value&gt;"0" &amp;&amp; value&lt;"10" ?"valid":"error"</compute>
   <compute expr="value>&quot;0&quot; &amp;&amp; value&lt;&quot;10&quot; ?&quot;valid&quot;:&quot;error&quot;">valid</compute>
   <norm attr=" '    &#xD;&#xA;&#x9;   ' "></norm>
   <normNames attr="A &#xD;&#xA;&#x9; B"></normNames>
   <normId id="' &#xD;&#xA;&#x9; '"></normId>
</doc>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inC14N4_c14nTrim.xml
================================================
<doc><text>First line&#xD;
Second line</text><value>2</value><compute>value&gt;"0" &amp;&amp; value&lt;"10" ?"valid":"error"</compute><compute expr="value>&quot;0&quot; &amp;&amp; value&lt;&quot;10&quot; ?&quot;valid&quot;:&quot;error&quot;">valid</compute><norm attr=" '    &#xD;&#xA;&#x9;   ' "></norm><normNames attr="A &#xD;&#xA;&#x9; B"></normNames><normId id="' &#xD;&#xA;&#x9; '"></normId></doc>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inC14N5_c14nDefault.xml
================================================
<doc attrExtEnt="entExt">
   Hello, world!
</doc>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inC14N5_c14nTrim.xml
================================================
<doc attrExtEnt="entExt">Hello, world!</doc>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inC14N6_c14nDefault.xml
================================================
<doc>©</doc>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsContent_c14nDefault.xml
================================================
<a:foo xmlns:a="http://a">
 <a:bar>xsd:string</a:bar>
 <dsig2:IncludedXPath xmlns:dsig2="http://www.w3.org/2010/xmldsig2#">/soap-env:body/child::b:foo[@att1 != "c:val" and @att2 != 'xsd:string']</dsig2:IncludedXPath>
</a:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsContent_c14nPrefixQnameXpathElem.xml
================================================
<n0:foo xmlns:n0="http://a">
 <n0:bar xmlns:n1="http://www.w3.org/2001/XMLSchema">n1:string</n0:bar>
 <n4:IncludedXPath xmlns:n2="http://b" xmlns:n3="http://schemas.xmlsoap.org/wsdl/soap/" xmlns:n4="http://www.w3.org/2010/xmldsig2#">/n3:body/child::n2:foo[@att1 != "c:val" and @att2 != 'xsd:string']</n4:IncludedXPath>
</n0:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsContent_c14nQnameElem.xml
================================================
<a:foo xmlns:a="http://a">
 <a:bar xmlns:xsd="http://www.w3.org/2001/XMLSchema">xsd:string</a:bar>
 <dsig2:IncludedXPath xmlns:dsig2="http://www.w3.org/2010/xmldsig2#">/soap-env:body/child::b:foo[@att1 != "c:val" and @att2 != 'xsd:string']</dsig2:IncludedXPath>
</a:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsContent_c14nQnameXpathElem.xml
================================================
<a:foo xmlns:a="http://a">
 <a:bar xmlns:xsd="http://www.w3.org/2001/XMLSchema">xsd:string</a:bar>
 <dsig2:IncludedXPath xmlns:b="http://b" xmlns:dsig2="http://www.w3.org/2010/xmldsig2#" xmlns:soap-env="http://schemas.xmlsoap.org/wsdl/soap/">/soap-env:body/child::b:foo[@att1 != "c:val" and @att2 != 'xsd:string']</dsig2:IncludedXPath>
</a:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsDefault_c14nDefault.xml
================================================
<foo>
 <b:bar xmlns:b="http://b" att2="val" b:att1="val"></b:bar>
</foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsDefault_c14nPrefix.xml
================================================
<n0:foo xmlns:n0="">
 <n1:bar xmlns:n1="http://b" att2="val" n1:att1="val"></n1:bar>
</n0:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsPushdown_c14nDefault.xml
================================================
<a:foo xmlns:a="http://a">
 <b:bar xmlns:b="http://b"></b:bar>
 <b:bar xmlns:b="http://b"></b:bar>
 <b:bar xmlns:b="http://b"></b:bar>
 <a:bar xmlns:b="http://b" b:att1="val"></a:bar>
</a:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsPushdown_c14nPrefix.xml
================================================
<n0:foo xmlns:n0="http://a">
 <n1:bar xmlns:n1="http://b"></n1:bar>
 <n1:bar xmlns:n1="http://b"></n1:bar>
 <n1:bar xmlns:n1="http://b"></n1:bar>
 <n0:bar xmlns:n1="http://b" n1:att1="val"></n0:bar>
</n0:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsRedecl_c14nDefault.xml
================================================
<foo xmlns:a="http://z3" xmlns:b="http://z2" b:att2="val2" a:att1="val1"> 
 <bar xmlns="http://z0" xmlns:a="http://z2" xmlns:b="http://z3" a:att1="val1" b:att2="val2"></bar>
</foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsRedecl_c14nPrefix.xml
================================================
<n0:foo xmlns:n0="" xmlns:n1="http://z2" xmlns:n2="http://z3" n1:att2="val2" n2:att1="val1"> 
 <n3:bar xmlns:n3="http://z0" n1:att1="val1" n2:att2="val2"></n3:bar>
</n0:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsSort_c14nDefault.xml
================================================
<a:foo xmlns:a="http://z3" xmlns:b="http://z2" xmlns:c="http://z1" c:att3="val3" b:att1="val1" b:att2="val2">
 <c:bar></c:bar>
 <c:bar xmlns:d="http://z0" d:att3="val3"></c:bar>
</a:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsSort_c14nPrefix.xml
================================================
<n2:foo xmlns:n0="http://z1" xmlns:n1="http://z2" xmlns:n2="http://z3" n0:att3="val3" n1:att1="val1" n1:att2="val2">
 <n0:bar></n0:bar>
 <n0:bar xmlns:n3="http://z0" n3:att3="val3"></n0:bar>
</n2:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsSuperfluous_c14nDefault.xml
================================================
<foo xmlns="http://z0" xmlns:a="http://z0" xmlns:b="http://z0" a:att1="val1" b:att2="val2"> 
 <c:bar xmlns:c="http://z0" c:att3="val3"></c:bar>
 <d:bar xmlns:d="http://z0"></d:bar>
</foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsSuperfluous_c14nPrefix.xml
================================================
<n0:foo xmlns:n0="http://z0" n0:att1="val1" n0:att2="val2"> 
 <n0:bar n0:att3="val3"></n0:bar>
 <n0:bar></n0:bar>
</n0:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsXml_c14nDefault.xml
================================================
<foo xmlns="http://z0" xml:id="23">
  <bar xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xsd:string">data</bar>
</foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsXml_c14nPrefix.xml
================================================
<n0:foo xmlns:n0="http://z0" xml:id="23">
  <n0:bar xmlns:n1="http://www.w3.org/2001/XMLSchema-instance" n1:type="xsd:string">data</n0:bar>
</n0:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsXml_c14nPrefixQname.xml
================================================
<n0:foo xmlns:n0="http://z0" xml:id="23">
  <n0:bar xmlns:n1="http://www.w3.org/2001/XMLSchema" xmlns:n2="http://www.w3.org/2001/XMLSchema-instance" n2:type="n1:string">data</n0:bar>
</n0:foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/out_inNsXml_c14nQname.xml
================================================
<foo xmlns="http://z0" xml:id="23">
  <bar xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:type="xsd:string">data</bar>
</foo>

================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/simple-ns.xml
================================================
<?pi data?>
<!-- comment -->
<root xmlns='namespace'>
   <element key='value'>text</element>
   <element>text</element>tail
   <empty-element/>
</root>


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/simple.xml
================================================
<!-- comment -->
<root>
   <element key='value'>text</element>
   <element>text</element>tail
   <empty-element/>
</root>


================================================
File: /Modules/_xxtestfuzz/fuzz_elementtree_parsewhole_corpus/test.xml
================================================
<?xml version="1.0" encoding="iso-8859-1"?>
<HTML xmlns:pp="http://www.isogen.com/paul/post-processor">
<TITLE>Introduction to XSL</TITLE>
<H1>Introduction to XSL</H1>
	

	
		<HR/>
		<H2>Overview
</H2>
		<UL>
		
	<LI>1.Intro</LI>

	<LI>2.History</LI>

	<LI>3.XSL Basics</LI>

	<LI>Lunch</LI>

	<LI>4.An XML Data Model</LI>

	<LI>5.XSL Patterns</LI>

	<LI>6.XSL Templates</LI>

	<LI>7.XSL Formatting Model
</LI>

		</UL>
	


	

	
		<HR/>
		<H2>Intro</H2>
		<UL>
		
	<LI>Who am I?</LI>

	<LI>Who are you?</LI>

	<LI>Why are we here?
</LI>

		</UL>
	


	

	
		<HR/>
		<H2>History: XML and SGML</H2>
		<UL>
		
	<LI>XML is a subset of SGML.</LI>

	<LI>SGML allows the separation of abstract content from formatting.</LI>

	<LI>Also one of XML's primary virtues (in the doc publishing domain).
</LI>

		</UL>
	


	

	
		<HR/>
		<H2>History: What are stylesheets?</H2>
		<UL>
		
	<LI>Stylesheets specify the formatting of SGML/XML documents.</LI>

	<LI>Stylesheets put the &quot;style&quot; back into documents.</LI>

	<LI>New York Times content+NYT Stylesheet = NYT paper
</LI>

		</UL>
	


	

	
		<HR/>
		<H2>History: FOSI</H2>
		<UL>
		
	<LI>FOSI: &quot;Formatted Output Specification Instance&quot;
<UL>
	<LI>MIL-STD-28001
	</LI>

	<LI>FOSI's are SGML documents
	</LI>

	<LI>A stylesheet for another document
	</LI>
</UL></LI>

	<LI>Obsolete but implemented...
</LI>

		</UL>
	


	
</HTML>


================================================
File: /Modules/_xxtestfuzz/fuzz_json_loads_corpus/empty_array.json
================================================
[]


================================================
File: /Modules/_xxtestfuzz/fuzz_json_loads_corpus/empty_object.json
================================================
{}


================================================
File: /Modules/_xxtestfuzz/fuzz_json_loads_corpus/pass1.json
================================================
[
    "JSON Test Pattern pass1",
    {"object with 1 member":["array with 1 element"]},
    {},
    [],
    -42,
    true,
    false,
    null,
    {
        "integer": 1234567890,
        "real": -9876.543210,
        "e": 0.123456789e-12,
        "E": 1.234567890E+34,
        "":  23456789012E66,
        "zero": 0,
        "one": 1,
        "space": " ",
        "quote": "\"",
        "backslash": "\\",
        "controls": "\b\f\n\r\t",
        "slash": "/ & \/",
        "alpha": "abcdefghijklmnopqrstuvwyz",
        "ALPHA": "ABCDEFGHIJKLMNOPQRSTUVWYZ",
        "digit": "0123456789",
        "0123456789": "digit",
        "special": "`1~!@#$%^&*()_+-={':[,]}|;.</>?",
        "hex": "\u0123\u4567\u89AB\uCDEF\uabcd\uef4A",
        "true": true,
        "false": false,
        "null": null,
        "array":[  ],
        "object":{  },
        "address": "50 St. James Street",
        "url": "http://www.JSON.org/",
        "comment": "// /* <!-- --",
        "# -- --> */": " ",
        " s p a c e d " :[1,2 , 3

,

4 , 5        ,          6           ,7        ],"compact":[1,2,3,4,5,6,7],
        "jsontext": "{\"object with 1 member\":[\"array with 1 element\"]}",
        "quotes": "&#34; \u0022 %22 0x22 034 &#x22;",
        "\/\\\"\uCAFE\uBABE\uAB98\uFCDE\ubcda\uef4A\b\f\n\r\t`1~!@#$%^&*()_+-=[]{}|;:',./<>?"
: "A key can be any string"
    },
    0.5 ,98.6
,
99.44
,

1066,
1e1,
0.1e1,
1e-1,
1e00,2e+00,2e-00
,"rosebud"]

================================================
File: /Modules/_xxtestfuzz/fuzz_json_loads_corpus/pass2.json
================================================
[[[[[[[[[[[[[[[[[[["Not too deep"]]]]]]]]]]]]]]]]]]]

================================================
File: /Modules/_xxtestfuzz/fuzz_json_loads_corpus/pass3.json
================================================
{
    "JSON Test Pattern pass3": {
        "The outermost value": "must be an object or array.",
        "In this test": "It is an object."
    }
}


================================================
File: /Modules/_xxtestfuzz/fuzz_json_loads_corpus/simple_array.json
================================================
[1, 2, 3, "abcd", "xyz"]


================================================
File: /Modules/_xxtestfuzz/fuzz_pycompile_corpus/input1.py
================================================
from __future__ import annotations

def test() -> None:
    x: list[int] = []
    x: dict[int, str] = {}
    x: set[bytes] = {}
    print(5 + 42 * 3, x)


================================================
File: /Modules/_xxtestfuzz/fuzz_pycompile_corpus/input2.py
================================================
class Foo(metaclass=42):
    __slots__ = ['x']
    pass

foo = Foo()


================================================
File: /Modules/_xxtestfuzz/fuzz_pycompile_corpus/input3.py
================================================
def evens():
    i = 0
    while True:
        i += 1
        if i % 2 == 0:
            yield i


================================================
File: /Modules/_xxtestfuzz/fuzz_pycompile_corpus/input4.py
================================================
async def hello(name: str):
    await name
    print(name)


================================================
File: /Modules/_xxtestfuzz/fuzz_pycompile_corpus/input5.py
================================================
try:
    eval('importer exporter... really long matches')
except SyntaxError:
    print("nothing to see here")
finally:
    print("all done here")
    raise


================================================
File: /Modules/_xxtestfuzz/fuzz_pycompile_corpus/input6.py
================================================
"""Some module docstring"""
import sys

def main():
    print("Hello world!", file=sys.stderr)

if __name__ == '__main__':
    main()


================================================
File: /Modules/_xxtestfuzz/fuzz_sre_compile_corpus/anchor_links
================================================
XX<a\s*href=(.*?)[\s|>]


================================================
File: /Modules/_xxtestfuzz/fuzz_sre_compile_corpus/characters
================================================
XX^(Tim|Robert)\s+the\s+(Enchanter|Shrubber)$


================================================
File: /Modules/_xxtestfuzz/fuzz_sre_compile_corpus/isbn
================================================
XX/((978[\--– ])?[0-9][0-9\--– ]{10}[\--– ][0-9xX])|((978)?[0-9]{9}[0-9Xx])/


================================================
File: /Modules/_xxtestfuzz/fuzz_sre_compile_corpus/phone_number
================================================
XX(\+1|1)?[ \-\.]?\(?(?<areacode>[0-9]{3})\)?[ \-\.]?(?<prefix>[0-9]{3})[ \-\.]?(?<number>[0-9]{4})[ \.]*(ext|x)?[ \.]*(?<extension>[0-9]{0,5})


================================================
File: /Modules/cjkcodecs/README
================================================
To generate or modify mapping headers
-------------------------------------
Mapping headers are generated from Tools/unicode/genmap_*.py



Notes on implementation characteristics of each codecs
-----------------------------------------------------

1) Big5 codec

  The big5 codec maps the following characters as cp950 does rather
  than conforming Unicode.org's that maps to 0xFFFD.

    BIG5        Unicode     Description

    0xA15A      0x2574      SPACING UNDERSCORE
    0xA1C3      0xFFE3      SPACING HEAVY OVERSCORE
    0xA1C5      0x02CD      SPACING HEAVY UNDERSCORE
    0xA1FE      0xFF0F      LT DIAG UP RIGHT TO LOW LEFT
    0xA240      0xFF3C      LT DIAG UP LEFT TO LOW RIGHT
    0xA2CC      0x5341      HANGZHOU NUMERAL TEN
    0xA2CE      0x5345      HANGZHOU NUMERAL THIRTY

  Because unicode 0x5341, 0x5345, 0xFF0F, 0xFF3C is mapped to another
  big5 codes already, a roundtrip compatibility is not guaranteed for
  them.


2) cp932 codec

  To conform to Windows's real mapping, cp932 codec maps the following
  codepoints in addition of the official cp932 mapping.

    CP932     Unicode     Description

    0x80      0x80        UNDEFINED
    0xA0      0xF8F0      UNDEFINED
    0xFD      0xF8F1      UNDEFINED
    0xFE      0xF8F2      UNDEFINED
    0xFF      0xF8F3      UNDEFINED


3) euc-jisx0213 codec

  The euc-jisx0213 codec maps JIS X 0213 Plane 1 code 0x2140 into
  unicode U+FF3C instead of U+005C as on unicode.org's mapping.
  Because euc-jisx0213 has REVERSE SOLIDUS on 0x5c already and A140
  is shown as a full width character, mapping to U+FF3C can make
  more sense.

  The euc-jisx0213 codec is enabled to decode JIS X 0212 codes on
  codeset 2. Because JIS X 0212 and JIS X 0213 Plane 2 don't have
  overlapped by each other, it doesn't bother standard conformations
  (and JIS X 0213 Plane 2 is intended to use so.) On encoding
  sessions, the codec will try to encode kanji characters in this
  order:

    JIS X 0213 Plane 1 -> JIS X 0213 Plane 2 -> JIS X 0212


4) euc-jp codec

  The euc-jp codec is a compatibility instance on these points:
   - U+FF3C FULLWIDTH REVERSE SOLIDUS is mapped to EUC-JP A1C0 (vice versa)
   - U+00A5 YEN SIGN is mapped to EUC-JP 0x5c. (one way)
   - U+203E OVERLINE is mapped to EUC-JP 0x7e. (one way)


5) shift-jis codec

  The shift-jis codec is mapping 0x20-0x7e area to U+20-U+7E directly
  instead of using JIS X 0201 for compatibility. The differences are:
   - U+005C REVERSE SOLIDUS is mapped to SHIFT-JIS 0x5c.
   - U+007E TILDE is mapped to SHIFT-JIS 0x7e.
   - U+FF3C FULL-WIDTH REVERSE SOLIDUS is mapped to SHIFT-JIS 815f.



================================================
File: /Modules/cjkcodecs/_codecs_cn.c
================================================
/*
 * _codecs_cn.c: Codecs collection for Mainland Chinese encodings
 *
 * Written by Hye-Shik Chang <perky@FreeBSD.org>
 */

#include "cjkcodecs.h"
#include "mappings_cn.h"

/**
 * hz is predefined as 100 on AIX. So we undefine it to avoid
 * conflict against hz codec's.
 */
#ifdef _AIX
#undef hz
#endif

/* GBK and GB2312 map differently in few code points that are listed below:
 *
 *              gb2312                          gbk
 * A1A4         U+30FB KATAKANA MIDDLE DOT      U+00B7 MIDDLE DOT
 * A1AA         U+2015 HORIZONTAL BAR           U+2014 EM DASH
 * A844         undefined                       U+2015 HORIZONTAL BAR
 */

#define GBK_DECODE(dc1, dc2, writer)                                \
    if ((dc1) == 0xa1 && (dc2) == 0xaa) {                           \
        OUTCHAR(0x2014);                                            \
    }                                                               \
    else if ((dc1) == 0xa8 && (dc2) == 0x44) {                      \
        OUTCHAR(0x2015);                                            \
    }                                                               \
    else if ((dc1) == 0xa1 && (dc2) == 0xa4) {                      \
        OUTCHAR(0x00b7);                                            \
    }                                                               \
    else if (TRYMAP_DEC(gb2312, decoded, dc1 ^ 0x80, dc2 ^ 0x80)) { \
        OUTCHAR(decoded);                                           \
    }                                                               \
    else if (TRYMAP_DEC(gbkext, decoded, dc1, dc2)) {               \
        OUTCHAR(decoded);                                           \
    }

#define GBK_ENCODE(code, assi)                                         \
    if ((code) == 0x2014) {                                            \
        (assi) = 0xa1aa;                                               \
    } else if ((code) == 0x2015) {                                     \
        (assi) = 0xa844;                                               \
    } else if ((code) == 0x00b7) {                                     \
        (assi) = 0xa1a4;                                               \
    } else if ((code) != 0x30fb && TRYMAP_ENC(gbcommon, assi, code)) { \
        ;                                                              \
    }

/*
 * codecs in this file use the first byte of MultibyteCodec_State.c[8]
 * to store a 0 or 1 state value
 */
#define CN_STATE_OFFSET 0

/*
 * GB2312 codec
 */

ENCODER(gb2312)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;

        if (c < 0x80) {
            WRITEBYTE1((unsigned char)c);
            NEXT(1, 1);
            continue;
        }

        if (c > 0xFFFF)
            return 1;

        REQUIRE_OUTBUF(2);
        if (TRYMAP_ENC(gbcommon, code, c))
            ;
        else
            return 1;

        if (code & 0x8000) /* MSB set: GBK */
            return 1;

        OUTBYTE1((code >> 8) | 0x80);
        OUTBYTE2((code & 0xFF) | 0x80);
        NEXT(1, 2);
    }

    return 0;
}

DECODER(gb2312)
{
    while (inleft > 0) {
        unsigned char c = **inbuf;
        Py_UCS4 decoded;

        if (c < 0x80) {
            OUTCHAR(c);
            NEXT_IN(1);
            continue;
        }

        REQUIRE_INBUF(2);
        if (TRYMAP_DEC(gb2312, decoded, c ^ 0x80, INBYTE2 ^ 0x80)) {
            OUTCHAR(decoded);
            NEXT_IN(2);
        }
        else
            return 1;
    }

    return 0;
}


/*
 * GBK codec
 */

ENCODER(gbk)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;

        if (c < 0x80) {
            WRITEBYTE1((unsigned char)c);
            NEXT(1, 1);
            continue;
        }

        if (c > 0xFFFF)
            return 1;

        REQUIRE_OUTBUF(2);

        GBK_ENCODE(c, code)
        else
            return 1;

        OUTBYTE1((code >> 8) | 0x80);
        if (code & 0x8000)
            OUTBYTE2((code & 0xFF)); /* MSB set: GBK */
        else
            OUTBYTE2((code & 0xFF) | 0x80); /* MSB unset: GB2312 */
        NEXT(1, 2);
    }

    return 0;
}

DECODER(gbk)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1;
        Py_UCS4 decoded;

        if (c < 0x80) {
            OUTCHAR(c);
            NEXT_IN(1);
            continue;
        }

        REQUIRE_INBUF(2);

        GBK_DECODE(c, INBYTE2, writer)
        else
            return 1;

        NEXT_IN(2);
    }

    return 0;
}


/*
 * GB18030 codec
 */

ENCODER(gb18030)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;

        if (c < 0x80) {
            WRITEBYTE1(c);
            NEXT(1, 1);
            continue;
        }

        if (c >= 0x10000) {
            Py_UCS4 tc = c - 0x10000;
            assert (c <= 0x10FFFF);

            REQUIRE_OUTBUF(4);

            OUTBYTE4((unsigned char)(tc % 10) + 0x30);
            tc /= 10;
            OUTBYTE3((unsigned char)(tc % 126) + 0x81);
            tc /= 126;
            OUTBYTE2((unsigned char)(tc % 10) + 0x30);
            tc /= 10;
            OUTBYTE1((unsigned char)(tc + 0x90));

            NEXT(1, 4);
            continue;
        }

        REQUIRE_OUTBUF(2);

        GBK_ENCODE(c, code)
        else if (TRYMAP_ENC(gb18030ext, code, c))
            ;
        else {
            const struct _gb18030_to_unibmp_ranges *utrrange;

            REQUIRE_OUTBUF(4);

            for (utrrange = gb18030_to_unibmp_ranges;
                 utrrange->first != 0;
                 utrrange++)
                if (utrrange->first <= c &&
                    c <= utrrange->last) {
                    Py_UCS4 tc;

                    tc = c - utrrange->first +
                         utrrange->base;

                    OUTBYTE4((unsigned char)(tc % 10) + 0x30);
                    tc /= 10;
                    OUTBYTE3((unsigned char)(tc % 126) + 0x81);
                    tc /= 126;
                    OUTBYTE2((unsigned char)(tc % 10) + 0x30);
                    tc /= 10;
                    OUTBYTE1((unsigned char)tc + 0x81);

                    NEXT(1, 4);
                    break;
                }

            if (utrrange->first == 0)
                return 1;
            continue;
        }

        OUTBYTE1((code >> 8) | 0x80);
        if (code & 0x8000)
            OUTBYTE2((code & 0xFF)); /* MSB set: GBK or GB18030ext */
        else
            OUTBYTE2((code & 0xFF) | 0x80); /* MSB unset: GB2312 */

        NEXT(1, 2);
    }

    return 0;
}

DECODER(gb18030)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1, c2;
        Py_UCS4 decoded;

        if (c < 0x80) {
            OUTCHAR(c);
            NEXT_IN(1);
            continue;
        }

        REQUIRE_INBUF(2);

        c2 = INBYTE2;
        if (c2 >= 0x30 && c2 <= 0x39) { /* 4 bytes seq */
            const struct _gb18030_to_unibmp_ranges *utr;
            unsigned char c3, c4;
            Py_UCS4 lseq;

            REQUIRE_INBUF(4);
            c3 = INBYTE3;
            c4 = INBYTE4;
            if (c  < 0x81 || c  > 0xFE ||
                c3 < 0x81 || c3 > 0xFE ||
                c4 < 0x30 || c4 > 0x39)
                return 1;
            c -= 0x81;  c2 -= 0x30;
            c3 -= 0x81; c4 -= 0x30;

            if (c < 4) { /* U+0080 - U+FFFF */
                lseq = ((Py_UCS4)c * 10 + c2) * 1260 +
                    (Py_UCS4)c3 * 10 + c4;
                if (lseq < 39420) {
                    for (utr = gb18030_to_unibmp_ranges;
                         lseq >= (utr + 1)->base;
                         utr++) ;
                    OUTCHAR(utr->first - utr->base + lseq);
                    NEXT_IN(4);
                    continue;
                }
            }
            else if (c >= 15) { /* U+10000 - U+10FFFF */
                lseq = 0x10000 + (((Py_UCS4)c-15) * 10 + c2)
                    * 1260 + (Py_UCS4)c3 * 10 + c4;
                if (lseq <= 0x10FFFF) {
                    OUTCHAR(lseq);
                    NEXT_IN(4);
                    continue;
                }
            }
            return 1;
        }

        GBK_DECODE(c, c2, writer)
        else if (TRYMAP_DEC(gb18030ext, decoded, c, c2))
            OUTCHAR(decoded);
        else
            return 1;

        NEXT_IN(2);
    }

    return 0;
}


/*
 * HZ codec
 */

ENCODER_INIT(hz)
{
    state->c[CN_STATE_OFFSET] = 0;
    return 0;
}

ENCODER_RESET(hz)
{
    if (state->c[CN_STATE_OFFSET] != 0) {
        WRITEBYTE2('~', '}');
        state->c[CN_STATE_OFFSET] = 0;
        NEXT_OUT(2);
    }
    return 0;
}

ENCODER(hz)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;

        if (c < 0x80) {
            if (state->c[CN_STATE_OFFSET]) {
                WRITEBYTE2('~', '}');
                NEXT_OUT(2);
                state->c[CN_STATE_OFFSET] = 0;
            }
            WRITEBYTE1((unsigned char)c);
            NEXT(1, 1);
            if (c == '~') {
                WRITEBYTE1('~');
                NEXT_OUT(1);
            }
            continue;
        }

        if (c > 0xFFFF)
            return 1;

        if (TRYMAP_ENC(gbcommon, code, c))
            ;
        else
            return 1;

        if (code & 0x8000) /* MSB set: GBK */
            return 1;

        if (state->c[CN_STATE_OFFSET] == 0) {
            WRITEBYTE4('~', '{', code >> 8, code & 0xff);
            NEXT(1, 4);
            state->c[CN_STATE_OFFSET] = 1;
        }
        else {
            WRITEBYTE2(code >> 8, code & 0xff);
            NEXT(1, 2);
        }
    }

    return 0;
}

DECODER_INIT(hz)
{
    state->c[CN_STATE_OFFSET] = 0;
    return 0;
}

DECODER_RESET(hz)
{
    state->c[CN_STATE_OFFSET] = 0;
    return 0;
}

DECODER(hz)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1;
        Py_UCS4 decoded;

        if (c == '~') {
            unsigned char c2 = INBYTE2;

            REQUIRE_INBUF(2);
            if (c2 == '~' && state->c[CN_STATE_OFFSET] == 0)
                OUTCHAR('~');
            else if (c2 == '{' && state->c[CN_STATE_OFFSET] == 0)
                state->c[CN_STATE_OFFSET] = 1; /* set GB */
            else if (c2 == '\n' && state->c[CN_STATE_OFFSET] == 0)
                ; /* line-continuation */
            else if (c2 == '}' && state->c[CN_STATE_OFFSET] == 1)
                state->c[CN_STATE_OFFSET] = 0; /* set ASCII */
            else
                return 1;
            NEXT_IN(2);
            continue;
        }

        if (c & 0x80)
            return 1;

        if (state->c[CN_STATE_OFFSET] == 0) { /* ASCII mode */
            OUTCHAR(c);
            NEXT_IN(1);
        }
        else { /* GB mode */
            REQUIRE_INBUF(2);
            if (TRYMAP_DEC(gb2312, decoded, c, INBYTE2)) {
                OUTCHAR(decoded);
                NEXT_IN(2);
            }
            else
                return 1;
        }
    }

    return 0;
}


BEGIN_MAPPINGS_LIST(4)
  MAPPING_DECONLY(gb2312)
  MAPPING_DECONLY(gbkext)
  MAPPING_ENCONLY(gbcommon)
  MAPPING_ENCDEC(gb18030ext)
END_MAPPINGS_LIST

BEGIN_CODECS_LIST(4)
  CODEC_STATELESS(gb2312)
  CODEC_STATELESS(gbk)
  CODEC_STATELESS(gb18030)
  CODEC_STATEFUL(hz)
END_CODECS_LIST

I_AM_A_MODULE_FOR(cn)


================================================
File: /Modules/cjkcodecs/_codecs_hk.c
================================================
/*
 * _codecs_hk.c: Codecs collection for encodings from Hong Kong
 *
 * Written by Hye-Shik Chang <perky@FreeBSD.org>
 */

#define USING_IMPORTED_MAPS

#define CJK_MOD_SPECIFIC_STATE      \
    const encode_map *big5_encmap;  \
    const decode_map *big5_decmap;

#include "cjkcodecs.h"
#include "mappings_hk.h"

/*
 * BIG5HKSCS codec
 */

CODEC_INIT(big5hkscs)
{
    cjkcodecs_module_state *st = codec->modstate;
    if (IMPORT_MAP(tw, big5, &st->big5_encmap, &st->big5_decmap)) {
        return -1;
    }
    return 0;
}

/*
 * There are four possible pair unicode -> big5hkscs maps as in HKSCS 2004:
 *  U+00CA U+0304 -> 8862  (U+00CA alone is mapped to 8866)
 *  U+00CA U+030C -> 8864
 *  U+00EA U+0304 -> 88a3  (U+00EA alone is mapped to 88a7)
 *  U+00EA U+030C -> 88a5
 * These are handled by not mapping tables but a hand-written code.
 */
static const DBCHAR big5hkscs_pairenc_table[4] = {0x8862, 0x8864, 0x88a3, 0x88a5};

ENCODER(big5hkscs)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;
        Py_ssize_t insize;

        if (c < 0x80) {
            REQUIRE_OUTBUF(1);
            **outbuf = (unsigned char)c;
            NEXT(1, 1);
            continue;
        }

        insize = 1;
        REQUIRE_OUTBUF(2);

        if (c < 0x10000) {
            if (TRYMAP_ENC(big5hkscs_bmp, code, c)) {
                if (code == MULTIC) {
                    Py_UCS4 c2;
                    if (inlen - *inpos >= 2)
                        c2 = INCHAR2;
                    else
                        c2 = 0;

                    if (inlen - *inpos >= 2 &&
                        ((c & 0xffdf) == 0x00ca) &&
                        ((c2 & 0xfff7) == 0x0304)) {
                        code = big5hkscs_pairenc_table[
                            ((c >> 4) |
                             (c2 >> 3)) & 3];
                        insize = 2;
                    }
                    else if (inlen - *inpos < 2 &&
                             !(flags & MBENC_FLUSH))
                        return MBERR_TOOFEW;
                    else {
                        if (c == 0xca)
                            code = 0x8866;
                        else /* c == 0xea */
                            code = 0x88a7;
                    }
                }
            }
            else if (TRYMAP_ENC_ST(big5, code, c))
                ;
            else
                return 1;
        }
        else if (c < 0x20000)
            return insize;
        else if (c < 0x30000) {
            if (TRYMAP_ENC(big5hkscs_nonbmp, code, c & 0xffff))
                ;
            else
                return insize;
        }
        else
            return insize;

        OUTBYTE1(code >> 8);
        OUTBYTE2(code & 0xFF);
        NEXT(insize, 2);
    }

    return 0;
}

#define BH2S(c1, c2) (((c1) - 0x87) * (0xfe - 0x40 + 1) + ((c2) - 0x40))

DECODER(big5hkscs)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1;
        Py_UCS4 decoded;

        if (c < 0x80) {
            OUTCHAR(c);
            NEXT_IN(1);
            continue;
        }

        REQUIRE_INBUF(2);

        if (0xc6 > c || c > 0xc8 || (c < 0xc7 && INBYTE2 < 0xa1)) {
            if (TRYMAP_DEC_ST(big5, decoded, c, INBYTE2)) {
                OUTCHAR(decoded);
                NEXT_IN(2);
                continue;
            }
        }

        if (TRYMAP_DEC(big5hkscs, decoded, c, INBYTE2))
        {
            int s = BH2S(c, INBYTE2);
            const unsigned char *hintbase;

            assert(0x87 <= c && c <= 0xfe);
            assert(0x40 <= INBYTE2 && INBYTE2 <= 0xfe);

            if (BH2S(0x87, 0x40) <= s && s <= BH2S(0xa0, 0xfe)) {
                    hintbase = big5hkscs_phint_0;
                    s -= BH2S(0x87, 0x40);
            }
            else if (BH2S(0xc6,0xa1) <= s && s <= BH2S(0xc8,0xfe)){
                    hintbase = big5hkscs_phint_12130;
                    s -= BH2S(0xc6, 0xa1);
            }
            else if (BH2S(0xf9,0xd6) <= s && s <= BH2S(0xfe,0xfe)){
                    hintbase = big5hkscs_phint_21924;
                    s -= BH2S(0xf9, 0xd6);
            }
            else
                    return MBERR_INTERNAL;

            if (hintbase[s >> 3] & (1 << (s & 7))) {
                    OUTCHAR(decoded | 0x20000);
                    NEXT_IN(2);
            }
            else {
                    OUTCHAR(decoded);
                    NEXT_IN(2);
            }
            continue;
        }

        switch ((c << 8) | INBYTE2) {
        case 0x8862: OUTCHAR2(0x00ca, 0x0304); break;
        case 0x8864: OUTCHAR2(0x00ca, 0x030c); break;
        case 0x88a3: OUTCHAR2(0x00ea, 0x0304); break;
        case 0x88a5: OUTCHAR2(0x00ea, 0x030c); break;
        default: return 1;
        }

        NEXT_IN(2); /* all decoded code points are pairs, above. */
    }

    return 0;
}

BEGIN_MAPPINGS_LIST(3)
  MAPPING_DECONLY(big5hkscs)
  MAPPING_ENCONLY(big5hkscs_bmp)
  MAPPING_ENCONLY(big5hkscs_nonbmp)
END_MAPPINGS_LIST

BEGIN_CODECS_LIST(1)
  CODEC_STATELESS_WINIT(big5hkscs)
END_CODECS_LIST

I_AM_A_MODULE_FOR(hk)


================================================
File: /Modules/cjkcodecs/_codecs_iso2022.c
================================================
/*
 * _codecs_iso2022.c: Codecs collection for ISO-2022 encodings.
 *
 * Written by Hye-Shik Chang <perky@FreeBSD.org>
 */

#define USING_IMPORTED_MAPS
#define USING_BINARY_PAIR_SEARCH
#define EXTERN_JISX0213_PAIR
#define EMULATE_JISX0213_2000_ENCODE_INVALID MAP_UNMAPPABLE
#define EMULATE_JISX0213_2000_DECODE_INVALID MAP_UNMAPPABLE

#define CJK_MOD_SPECIFIC_STATE                  \
    /* kr */                                    \
    const encode_map *cp949_encmap;             \
    const decode_map *ksx1001_decmap;           \
                                                \
    /* jp */                                    \
    const encode_map *jisxcommon_encmap;        \
    const decode_map *jisx0208_decmap;          \
    const decode_map *jisx0212_decmap;          \
    const encode_map *jisx0213_bmp_encmap;      \
    const decode_map *jisx0213_1_bmp_decmap;    \
    const decode_map *jisx0213_2_bmp_decmap;    \
    const encode_map *jisx0213_emp_encmap;      \
    const decode_map *jisx0213_1_emp_decmap;    \
    const decode_map *jisx0213_2_emp_decmap;    \
                                                \
    /* cn */                                    \
    const encode_map *gbcommon_encmap;          \
    const decode_map *gb2312_decmap;


#include "cjkcodecs.h"
#include "alg_jisx0201.h"
#include "emu_jisx0213_2000.h"
#include "mappings_jisx0213_pair.h"

/* STATE

   state->c[0-3]

    00000000
    ||^^^^^|
    |+-----+----  G0-3 Character Set
    +-----------  Is G0-3 double byte?

   state->c[4]

    00000000
          ||
          |+----  Locked-Shift?
          +-----  ESC Throughout
*/

#define ESC                     0x1B
#define SO                      0x0E
#define SI                      0x0F
#define LF                      0x0A

#define MAX_ESCSEQLEN           16

#define CHARSET_ISO8859_1       'A'
#define CHARSET_ASCII           'B'
#define CHARSET_ISO8859_7       'F'
#define CHARSET_JISX0201_K      'I'
#define CHARSET_JISX0201_R      'J'

#define CHARSET_GB2312          ('A'|CHARSET_DBCS)
#define CHARSET_JISX0208        ('B'|CHARSET_DBCS)
#define CHARSET_KSX1001         ('C'|CHARSET_DBCS)
#define CHARSET_JISX0212        ('D'|CHARSET_DBCS)
#define CHARSET_GB2312_8565     ('E'|CHARSET_DBCS)
#define CHARSET_CNS11643_1      ('G'|CHARSET_DBCS)
#define CHARSET_CNS11643_2      ('H'|CHARSET_DBCS)
#define CHARSET_JISX0213_2000_1 ('O'|CHARSET_DBCS)
#define CHARSET_JISX0213_2      ('P'|CHARSET_DBCS)
#define CHARSET_JISX0213_2004_1 ('Q'|CHARSET_DBCS)
#define CHARSET_JISX0208_O      ('@'|CHARSET_DBCS)

#define CHARSET_DBCS            0x80
#define ESCMARK(mark)           ((mark) & 0x7f)

#define IS_ESCEND(c)    (((c) >= 'A' && (c) <= 'Z') || (c) == '@')
#define IS_ISO2022ESC(c2) \
        ((c2) == '(' || (c2) == ')' || (c2) == '$' || \
         (c2) == '.' || (c2) == '&')
    /* this is not a complete list of ISO-2022 escape sequence headers.
     * but, it's enough to implement CJK instances of iso-2022. */

#define MAP_UNMAPPABLE          0xFFFF
#define MAP_MULTIPLE_AVAIL      0xFFFE /* for JIS X 0213 */

#define F_SHIFTED               0x01
#define F_ESCTHROUGHOUT         0x02

#define STATE_SETG(dn, v)       do { ((state)->c[dn]) = (v); } while (0)
#define STATE_GETG(dn)          ((state)->c[dn])

#define STATE_G0                STATE_GETG(0)
#define STATE_G1                STATE_GETG(1)
#define STATE_G2                STATE_GETG(2)
#define STATE_G3                STATE_GETG(3)
#define STATE_SETG0(v)          STATE_SETG(0, v)
#define STATE_SETG1(v)          STATE_SETG(1, v)
#define STATE_SETG2(v)          STATE_SETG(2, v)
#define STATE_SETG3(v)          STATE_SETG(3, v)

#define STATE_SETFLAG(f)        do { ((state)->c[4]) |= (f); } while (0)
#define STATE_GETFLAG(f)        ((state)->c[4] & (f))
#define STATE_CLEARFLAG(f)      do { ((state)->c[4]) &= ~(f); } while (0)
#define STATE_CLEARFLAGS()      do { ((state)->c[4]) = 0; } while (0)

#define ISO2022_CONFIG          ((const struct iso2022_config *)(codec->config))
#define CONFIG_ISSET(flag)      (ISO2022_CONFIG->flags & (flag))
#define CONFIG_DESIGNATIONS     (ISO2022_CONFIG->designations)

/* iso2022_config.flags */
#define NO_SHIFT                0x01
#define USE_G2                  0x02
#define USE_JISX0208_EXT        0x04

/*-*- internal data structures -*-*/

typedef int (*iso2022_init_func)(const MultibyteCodec *codec);
typedef Py_UCS4 (*iso2022_decode_func)(const MultibyteCodec *codec,
                                       const unsigned char *data);
typedef DBCHAR (*iso2022_encode_func)(const MultibyteCodec *codec,
                                      const Py_UCS4 *data,
                                      Py_ssize_t *length);

struct iso2022_designation {
    unsigned char mark;
    unsigned char plane;
    unsigned char width;
    iso2022_init_func initializer;
    iso2022_decode_func decoder;
    iso2022_encode_func encoder;
};

struct iso2022_config {
    int flags;
    const struct iso2022_designation *designations; /* non-ascii desigs */
};

/*-*- iso-2022 codec implementation -*-*/

CODEC_INIT(iso2022)
{
    const struct iso2022_designation *desig;
    for (desig = CONFIG_DESIGNATIONS; desig->mark; desig++) {
        if (desig->initializer != NULL && desig->initializer(codec) != 0) {
            return -1;
        }
    }
    return 0;
}

ENCODER_INIT(iso2022)
{
    STATE_CLEARFLAGS();
    STATE_SETG0(CHARSET_ASCII);
    STATE_SETG1(CHARSET_ASCII);
    return 0;
}

ENCODER_RESET(iso2022)
{
    if (STATE_GETFLAG(F_SHIFTED)) {
        WRITEBYTE1(SI);
        NEXT_OUT(1);
        STATE_CLEARFLAG(F_SHIFTED);
    }
    if (STATE_G0 != CHARSET_ASCII) {
        WRITEBYTE3(ESC, '(', 'B');
        NEXT_OUT(3);
        STATE_SETG0(CHARSET_ASCII);
    }
    return 0;
}

ENCODER(iso2022)
{
    while (*inpos < inlen) {
        const struct iso2022_designation *dsg;
        DBCHAR encoded;
        Py_UCS4 c = INCHAR1;
        Py_ssize_t insize;

        if (c < 0x80) {
            if (STATE_G0 != CHARSET_ASCII) {
                WRITEBYTE3(ESC, '(', 'B');
                STATE_SETG0(CHARSET_ASCII);
                NEXT_OUT(3);
            }
            if (STATE_GETFLAG(F_SHIFTED)) {
                WRITEBYTE1(SI);
                STATE_CLEARFLAG(F_SHIFTED);
                NEXT_OUT(1);
            }
            WRITEBYTE1((unsigned char)c);
            NEXT(1, 1);
            continue;
        }

        insize = 1;

        encoded = MAP_UNMAPPABLE;
        for (dsg = CONFIG_DESIGNATIONS; dsg->mark; dsg++) {
            Py_UCS4 buf[2] = {c, 0};
            Py_ssize_t length = 1;
            encoded = dsg->encoder(codec, buf, &length);
            if (encoded == MAP_MULTIPLE_AVAIL) {
                /* this implementation won't work for pair
                 * of non-bmp characters. */
                if (inlen - *inpos < 2) {
                    if (!(flags & MBENC_FLUSH))
                        return MBERR_TOOFEW;
                    length = -1;
                }
                else {
                    buf[1] = INCHAR2;
                    length = 2;
                }
                encoded = dsg->encoder(codec, buf, &length);
                if (encoded != MAP_UNMAPPABLE) {
                    insize = length;
                    break;
                }
            }
            else if (encoded != MAP_UNMAPPABLE)
                break;
        }

        if (!dsg->mark)
            return 1;
        assert(dsg->width == 1 || dsg->width == 2);

        switch (dsg->plane) {
        case 0: /* G0 */
            if (STATE_GETFLAG(F_SHIFTED)) {
                WRITEBYTE1(SI);
                STATE_CLEARFLAG(F_SHIFTED);
                NEXT_OUT(1);
            }
            if (STATE_G0 != dsg->mark) {
                if (dsg->width == 1) {
                    WRITEBYTE3(ESC, '(', ESCMARK(dsg->mark));
                    STATE_SETG0(dsg->mark);
                    NEXT_OUT(3);
                }
                else if (dsg->mark == CHARSET_JISX0208) {
                    WRITEBYTE3(ESC, '$', ESCMARK(dsg->mark));
                    STATE_SETG0(dsg->mark);
                    NEXT_OUT(3);
                }
                else {
                    WRITEBYTE4(ESC, '$', '(',
                        ESCMARK(dsg->mark));
                    STATE_SETG0(dsg->mark);
                    NEXT_OUT(4);
                }
            }
            break;
        case 1: /* G1 */
            if (STATE_G1 != dsg->mark) {
                if (dsg->width == 1) {
                    WRITEBYTE3(ESC, ')', ESCMARK(dsg->mark));
                    STATE_SETG1(dsg->mark);
                    NEXT_OUT(3);
                }
                else {
                    WRITEBYTE4(ESC, '$', ')', ESCMARK(dsg->mark));
                    STATE_SETG1(dsg->mark);
                    NEXT_OUT(4);
                }
            }
            if (!STATE_GETFLAG(F_SHIFTED)) {
                WRITEBYTE1(SO);
                STATE_SETFLAG(F_SHIFTED);
                NEXT_OUT(1);
            }
            break;
        default: /* G2 and G3 is not supported: no encoding in
                  * CJKCodecs are using them yet */
            return MBERR_INTERNAL;
        }

        if (dsg->width == 1) {
            WRITEBYTE1((unsigned char)encoded);
            NEXT_OUT(1);
        }
        else {
            WRITEBYTE2(encoded >> 8, encoded & 0xff);
            NEXT_OUT(2);
        }
        NEXT_INCHAR(insize);
    }

    return 0;
}

DECODER_INIT(iso2022)
{
    STATE_CLEARFLAGS();
    STATE_SETG0(CHARSET_ASCII);
    STATE_SETG1(CHARSET_ASCII);
    STATE_SETG2(CHARSET_ASCII);
    return 0;
}

DECODER_RESET(iso2022)
{
    STATE_SETG0(CHARSET_ASCII);
    STATE_CLEARFLAG(F_SHIFTED);
    return 0;
}

static Py_ssize_t
iso2022processesc(const MultibyteCodec *codec, MultibyteCodec_State *state,
                  const unsigned char **inbuf, Py_ssize_t *inleft)
{
    unsigned char charset, designation;
    Py_ssize_t i, esclen = 0;

    for (i = 1;i < MAX_ESCSEQLEN;i++) {
        if (i >= *inleft)
            return MBERR_TOOFEW;
        if (IS_ESCEND((*inbuf)[i])) {
            esclen = i + 1;
            break;
        }
        else if (CONFIG_ISSET(USE_JISX0208_EXT) && i+1 < *inleft &&
                 (*inbuf)[i] == '&' && (*inbuf)[i+1] == '@') {
            i += 2;
        }
    }

    switch (esclen) {
    case 0:
        return 1; /* unterminated escape sequence */
    case 3:
        if (INBYTE2 == '$') {
            charset = INBYTE3 | CHARSET_DBCS;
            designation = 0;
        }
        else {
            charset = INBYTE3;
            if (INBYTE2 == '(')
                designation = 0;
            else if (INBYTE2 == ')')
                designation = 1;
            else if (CONFIG_ISSET(USE_G2) && INBYTE2 == '.')
                designation = 2;
            else
                return 3;
        }
        break;
    case 4:
        if (INBYTE2 != '$')
            return 4;

        charset = INBYTE4 | CHARSET_DBCS;
        if (INBYTE3 == '(')
            designation = 0;
        else if (INBYTE3 == ')')
            designation = 1;
        else
            return 4;
        break;
    case 6: /* designation with prefix */
        if (CONFIG_ISSET(USE_JISX0208_EXT) &&
            (*inbuf)[3] == ESC && (*inbuf)[4] == '$' &&
            (*inbuf)[5] == 'B') {
            charset = 'B' | CHARSET_DBCS;
            designation = 0;
        }
        else
            return 6;
        break;
    default:
        return esclen;
    }

    /* raise error when the charset is not designated for this encoding */
    if (charset != CHARSET_ASCII) {
        const struct iso2022_designation *dsg;

        for (dsg = CONFIG_DESIGNATIONS; dsg->mark; dsg++) {
            if (dsg->mark == charset)
                break;
        }
        if (!dsg->mark)
            return esclen;
    }

    STATE_SETG(designation, charset);
    *inleft -= esclen;
    (*inbuf) += esclen;
    return 0;
}

#define ISO8859_7_DECODE(c, writer)                                \
    if ((c) < 0xa0) {                                              \
        OUTCHAR(c);                                                \
    } else if ((c) < 0xc0 && (0x288f3bc9L & (1L << ((c)-0xa0)))) { \
        OUTCHAR(c);                                                \
    } else if ((c) >= 0xb4 && (c) <= 0xfe && ((c) >= 0xd4 ||       \
             (0xbffffd77L & (1L << ((c)-0xb4))))) {                \
        OUTCHAR(0x02d0 + (c));                                     \
    } else if ((c) == 0xa1) {                                      \
        OUTCHAR(0x2018);                                           \
    } else if ((c) == 0xa2) {                                      \
        OUTCHAR(0x2019);                                           \
    } else if ((c) == 0xaf) {                                      \
        OUTCHAR(0x2015);                                           \
    }

static Py_ssize_t
iso2022processg2(const MultibyteCodec *codec, MultibyteCodec_State *state,
                 const unsigned char **inbuf, Py_ssize_t *inleft,
                 _PyUnicodeWriter *writer)
{
    /* not written to use encoder, decoder functions because only few
     * encodings use G2 designations in CJKCodecs */
    if (STATE_G2 == CHARSET_ISO8859_1) {
        if (INBYTE3 < 0x80)
            OUTCHAR(INBYTE3 + 0x80);
        else
            return 3;
    }
    else if (STATE_G2 == CHARSET_ISO8859_7) {
        ISO8859_7_DECODE(INBYTE3 ^ 0x80, writer)
        else
            return 3;
    }
    else if (STATE_G2 == CHARSET_ASCII) {
        if (INBYTE3 & 0x80)
            return 3;
        else
            OUTCHAR(INBYTE3);
    }
    else
        return MBERR_INTERNAL;

    (*inbuf) += 3;
    *inleft -= 3;
    return 0;
}

DECODER(iso2022)
{
    const struct iso2022_designation *dsgcache = NULL;

    while (inleft > 0) {
        unsigned char c = INBYTE1;
        Py_ssize_t err;

        if (STATE_GETFLAG(F_ESCTHROUGHOUT)) {
            /* ESC throughout mode:
             * for non-iso2022 escape sequences */
            OUTCHAR(c); /* assume as ISO-8859-1 */
            NEXT_IN(1);
            if (IS_ESCEND(c)) {
                STATE_CLEARFLAG(F_ESCTHROUGHOUT);
            }
            continue;
        }

        switch (c) {
        case ESC:
            REQUIRE_INBUF(2);
            if (IS_ISO2022ESC(INBYTE2)) {
                err = iso2022processesc(codec, state,
                                        inbuf, &inleft);
                if (err != 0)
                    return err;
            }
            else if (CONFIG_ISSET(USE_G2) && INBYTE2 == 'N') {/* SS2 */
                REQUIRE_INBUF(3);
                err = iso2022processg2(codec, state,
                                       inbuf, &inleft, writer);
                if (err != 0)
                    return err;
            }
            else {
                OUTCHAR(ESC);
                STATE_SETFLAG(F_ESCTHROUGHOUT);
                NEXT_IN(1);
            }
            break;
        case SI:
            if (CONFIG_ISSET(NO_SHIFT))
                goto bypass;
            STATE_CLEARFLAG(F_SHIFTED);
            NEXT_IN(1);
            break;
        case SO:
            if (CONFIG_ISSET(NO_SHIFT))
                goto bypass;
            STATE_SETFLAG(F_SHIFTED);
            NEXT_IN(1);
            break;
        case LF:
            STATE_CLEARFLAG(F_SHIFTED);
            OUTCHAR(LF);
            NEXT_IN(1);
            break;
        default:
            if (c < 0x20) /* C0 */
                goto bypass;
            else if (c >= 0x80)
                return 1;
            else {
                const struct iso2022_designation *dsg;
                unsigned char charset;
                Py_UCS4 decoded;

                if (STATE_GETFLAG(F_SHIFTED))
                    charset = STATE_G1;
                else
                    charset = STATE_G0;

                if (charset == CHARSET_ASCII) {
bypass:
                    OUTCHAR(c);
                    NEXT_IN(1);
                    break;
                }

                if (dsgcache != NULL &&
                    dsgcache->mark == charset)
                        dsg = dsgcache;
                else {
                    for (dsg = CONFIG_DESIGNATIONS;
                         dsg->mark != charset
#ifdef Py_DEBUG
                            && dsg->mark != '\0'
#endif
                         ; dsg++)
                    {
                        /* noop */
                    }
                    assert(dsg->mark != '\0');
                    dsgcache = dsg;
                }

                REQUIRE_INBUF(dsg->width);
                decoded = dsg->decoder(codec, *inbuf);
                if (decoded == MAP_UNMAPPABLE)
                    return dsg->width;

                if (decoded < 0x10000) {
                    OUTCHAR(decoded);
                }
                else if (decoded < 0x30000) {
                    OUTCHAR(decoded);
                }
                else { /* JIS X 0213 pairs */
                    OUTCHAR2(decoded >> 16, decoded & 0xffff);
                }
                NEXT_IN(dsg->width);
            }
            break;
        }
    }
    return 0;
}

/*-*- mapping access functions -*-*/

static int
ksx1001_init(const MultibyteCodec *codec)
{
    cjkcodecs_module_state *st = codec->modstate;
    if (IMPORT_MAP(kr, cp949, &st->cp949_encmap, NULL) ||
        IMPORT_MAP(kr, ksx1001, NULL, &st->ksx1001_decmap))
    {
        return -1;
    }
    return 0;
}

static Py_UCS4
ksx1001_decoder(const MultibyteCodec *codec, const unsigned char *data)
{
    Py_UCS4 u;
    if (TRYMAP_DEC_ST(ksx1001, u, data[0], data[1]))
        return u;
    else
        return MAP_UNMAPPABLE;
}

static DBCHAR
ksx1001_encoder(const MultibyteCodec *codec, const Py_UCS4 *data,
                Py_ssize_t *length)
{
    DBCHAR coded;
    assert(*length == 1);
    if (*data < 0x10000) {
        if (TRYMAP_ENC_ST(cp949, coded, *data)) {
            if (!(coded & 0x8000))
                return coded;
        }
    }
    return MAP_UNMAPPABLE;
}

static int
jisx0208_init(const MultibyteCodec *codec)
{
    cjkcodecs_module_state *st = codec->modstate;
    if (IMPORT_MAP(jp, jisxcommon, &st->jisxcommon_encmap, NULL) ||
        IMPORT_MAP(jp, jisx0208, NULL, &st->jisx0208_decmap))
    {
        return -1;
    }
    return 0;
}

static Py_UCS4
jisx0208_decoder(const MultibyteCodec *codec, const unsigned char *data)
{
    Py_UCS4 u;
    if (data[0] == 0x21 && data[1] == 0x40) /* F/W REVERSE SOLIDUS */
        return 0xff3c;
    else if (TRYMAP_DEC_ST(jisx0208, u, data[0], data[1]))
        return u;
    else
        return MAP_UNMAPPABLE;
}

static DBCHAR
jisx0208_encoder(const MultibyteCodec *codec, const Py_UCS4 *data,
                 Py_ssize_t *length)
{
    DBCHAR coded;
    assert(*length == 1);
    if (*data < 0x10000) {
        if (*data == 0xff3c) /* F/W REVERSE SOLIDUS */
            return 0x2140;
        else if (TRYMAP_ENC_ST(jisxcommon, coded, *data)) {
            if (!(coded & 0x8000))
                return coded;
        }
    }
    return MAP_UNMAPPABLE;
}

static int
jisx0212_init(const MultibyteCodec *codec)
{
    cjkcodecs_module_state *st = codec->modstate;
    if (IMPORT_MAP(jp, jisxcommon, &st->jisxcommon_encmap, NULL) ||
        IMPORT_MAP(jp, jisx0212, NULL, &st->jisx0212_decmap))
    {
        return -1;
    }
    return 0;
}

static Py_UCS4
jisx0212_decoder(const MultibyteCodec *codec, const unsigned char *data)
{
    Py_UCS4 u;
    if (TRYMAP_DEC_ST(jisx0212, u, data[0], data[1]))
        return u;
    else
        return MAP_UNMAPPABLE;
}

static DBCHAR
jisx0212_encoder(const MultibyteCodec *codec, const Py_UCS4 *data,
                 Py_ssize_t *length)
{
    DBCHAR coded;
    assert(*length == 1);
    if (*data < 0x10000) {
        if (TRYMAP_ENC_ST(jisxcommon, coded, *data)) {
            if (coded & 0x8000)
                return coded & 0x7fff;
        }
    }
    return MAP_UNMAPPABLE;
}

static int
jisx0213_init(const MultibyteCodec *codec)
{
    cjkcodecs_module_state *st = codec->modstate;
    if (jisx0208_init(codec) ||
        IMPORT_MAP(jp, jisx0213_bmp, &st->jisx0213_bmp_encmap, NULL) ||
        IMPORT_MAP(jp, jisx0213_1_bmp, NULL, &st->jisx0213_1_bmp_decmap) ||
        IMPORT_MAP(jp, jisx0213_2_bmp, NULL, &st->jisx0213_2_bmp_decmap) ||
        IMPORT_MAP(jp, jisx0213_emp, &st->jisx0213_emp_encmap, NULL) ||
        IMPORT_MAP(jp, jisx0213_1_emp, NULL, &st->jisx0213_1_emp_decmap) ||
        IMPORT_MAP(jp, jisx0213_2_emp, NULL, &st->jisx0213_2_emp_decmap) ||
        IMPORT_MAP(jp, jisx0213_pair,
                   &jisx0213_pair_encmap, &jisx0213_pair_decmap))
    {
        return -1;
    }
    return 0;
}

#define config ((void *)2000)
static Py_UCS4
jisx0213_2000_1_decoder(const MultibyteCodec *codec, const unsigned char *data)
{
    Py_UCS4 u;
    EMULATE_JISX0213_2000_DECODE_PLANE1(config, u, data[0], data[1])
    else if (data[0] == 0x21 && data[1] == 0x40) /* F/W REVERSE SOLIDUS */
        return 0xff3c;
    else if (TRYMAP_DEC_ST(jisx0208, u, data[0], data[1]))
        ;
    else if (TRYMAP_DEC_ST(jisx0213_1_bmp, u, data[0], data[1]))
        ;
    else if (TRYMAP_DEC_ST(jisx0213_1_emp, u, data[0], data[1]))
        u |= 0x20000;
    else if (TRYMAP_DEC(jisx0213_pair, u, data[0], data[1]))
        ;
    else
        return MAP_UNMAPPABLE;
    return u;
}

static Py_UCS4
jisx0213_2000_2_decoder(const MultibyteCodec *codec, const unsigned char *data)
{
    Py_UCS4 u;
    EMULATE_JISX0213_2000_DECODE_PLANE2_CHAR(config, u, data[0], data[1])
    if (TRYMAP_DEC_ST(jisx0213_2_bmp, u, data[0], data[1]))
        ;
    else if (TRYMAP_DEC_ST(jisx0213_2_emp, u, data[0], data[1]))
        u |= 0x20000;
    else
        return MAP_UNMAPPABLE;
    return u;
}
#undef config

static Py_UCS4
jisx0213_2004_1_decoder(const MultibyteCodec *codec, const unsigned char *data)
{
    Py_UCS4 u;
    if (data[0] == 0x21 && data[1] == 0x40) /* F/W REVERSE SOLIDUS */
        return 0xff3c;
    else if (TRYMAP_DEC_ST(jisx0208, u, data[0], data[1]))
        ;
    else if (TRYMAP_DEC_ST(jisx0213_1_bmp, u, data[0], data[1]))
        ;
    else if (TRYMAP_DEC_ST(jisx0213_1_emp, u, data[0], data[1]))
        u |= 0x20000;
    else if (TRYMAP_DEC(jisx0213_pair, u, data[0], data[1]))
        ;
    else
        return MAP_UNMAPPABLE;
    return u;
}

static Py_UCS4
jisx0213_2004_2_decoder(const MultibyteCodec *codec, const unsigned char *data)
{
    Py_UCS4 u;
    if (TRYMAP_DEC_ST(jisx0213_2_bmp, u, data[0], data[1]))
        ;
    else if (TRYMAP_DEC_ST(jisx0213_2_emp, u, data[0], data[1]))
        u |= 0x20000;
    else
        return MAP_UNMAPPABLE;
    return u;
}

static DBCHAR
jisx0213_encoder(const MultibyteCodec *codec, const Py_UCS4 *data,
                 Py_ssize_t *length, const void *config)
{
    DBCHAR coded;

    switch (*length) {
    case 1: /* first character */
        if (*data >= 0x10000) {
            if ((*data) >> 16 == 0x20000 >> 16) {
                EMULATE_JISX0213_2000_ENCODE_EMP(config, coded, *data)
                else if (TRYMAP_ENC_ST(jisx0213_emp, coded, (*data) & 0xffff))
                    return coded;
            }
            return MAP_UNMAPPABLE;
        }

        EMULATE_JISX0213_2000_ENCODE_BMP(config, coded, *data)
        else if (TRYMAP_ENC_ST(jisx0213_bmp, coded, *data)) {
            if (coded == MULTIC)
                return MAP_MULTIPLE_AVAIL;
        }
        else if (TRYMAP_ENC_ST(jisxcommon, coded, *data)) {
            if (coded & 0x8000)
                return MAP_UNMAPPABLE;
        }
        else
            return MAP_UNMAPPABLE;
        return coded;

    case 2: /* second character of unicode pair */
        coded = find_pairencmap((ucs2_t)data[0], (ucs2_t)data[1],
                                jisx0213_pair_encmap, JISX0213_ENCPAIRS);
        if (coded != DBCINV)
            return coded;
        _Py_FALLTHROUGH;

    case -1: /* flush unterminated */
        *length = 1;
        coded = find_pairencmap((ucs2_t)data[0], 0,
                                jisx0213_pair_encmap, JISX0213_ENCPAIRS);
        if (coded == DBCINV)
            return MAP_UNMAPPABLE;
        else
            return coded;
        break;

    default:
        return MAP_UNMAPPABLE;
    }
}

static DBCHAR
jisx0213_2000_1_encoder(const MultibyteCodec *codec, const Py_UCS4 *data,
                        Py_ssize_t *length)
{
    DBCHAR coded = jisx0213_encoder(codec, data, length, (void *)2000);
    if (coded == MAP_UNMAPPABLE || coded == MAP_MULTIPLE_AVAIL)
        return coded;
    else if (coded & 0x8000)
        return MAP_UNMAPPABLE;
    else
        return coded;
}

static DBCHAR
jisx0213_2000_1_encoder_paironly(const MultibyteCodec *codec,
                                 const Py_UCS4 *data, Py_ssize_t *length)
{
    DBCHAR coded;
    Py_ssize_t ilength = *length;

    coded = jisx0213_encoder(codec, data, length, (void *)2000);
    switch (ilength) {
    case 1:
        if (coded == MAP_MULTIPLE_AVAIL)
            return MAP_MULTIPLE_AVAIL;
        else
            return MAP_UNMAPPABLE;
    case 2:
        if (*length != 2)
            return MAP_UNMAPPABLE;
        else
            return coded;
    default:
        return MAP_UNMAPPABLE;
    }
}

static DBCHAR
jisx0213_2000_2_encoder(const MultibyteCodec *codec, const Py_UCS4 *data,
                        Py_ssize_t *length)
{
    DBCHAR coded = jisx0213_encoder(codec, data, length, (void *)2000);
    if (coded == MAP_UNMAPPABLE || coded == MAP_MULTIPLE_AVAIL)
        return coded;
    else if (coded & 0x8000)
        return coded & 0x7fff;
    else
        return MAP_UNMAPPABLE;
}

static DBCHAR
jisx0213_2004_1_encoder(const MultibyteCodec *codec, const Py_UCS4 *data,
                        Py_ssize_t *length)
{
    DBCHAR coded = jisx0213_encoder(codec, data, length, NULL);
    if (coded == MAP_UNMAPPABLE || coded == MAP_MULTIPLE_AVAIL)
        return coded;
    else if (coded & 0x8000)
        return MAP_UNMAPPABLE;
    else
        return coded;
}

static DBCHAR
jisx0213_2004_1_encoder_paironly(const MultibyteCodec *codec,
                                 const Py_UCS4 *data, Py_ssize_t *length)
{
    DBCHAR coded;
    Py_ssize_t ilength = *length;

    coded = jisx0213_encoder(codec, data, length, NULL);
    switch (ilength) {
    case 1:
        if (coded == MAP_MULTIPLE_AVAIL)
            return MAP_MULTIPLE_AVAIL;
        else
            return MAP_UNMAPPABLE;
    case 2:
        if (*length != 2)
            return MAP_UNMAPPABLE;
        else
            return coded;
    default:
        return MAP_UNMAPPABLE;
    }
}

static DBCHAR
jisx0213_2004_2_encoder(const MultibyteCodec *codec, const Py_UCS4 *data,
                        Py_ssize_t *length)
{
    DBCHAR coded = jisx0213_encoder(codec, data, length, NULL);
    if (coded == MAP_UNMAPPABLE || coded == MAP_MULTIPLE_AVAIL)
        return coded;
    else if (coded & 0x8000)
        return coded & 0x7fff;
    else
        return MAP_UNMAPPABLE;
}

static Py_UCS4
jisx0201_r_decoder(const MultibyteCodec *codec, const unsigned char *data)
{
    Py_UCS4 u;
    JISX0201_R_DECODE_CHAR(*data, u)
    else
        return MAP_UNMAPPABLE;
    return u;
}

static DBCHAR
jisx0201_r_encoder(const MultibyteCodec *codec, const Py_UCS4 *data,
                   Py_ssize_t *length)
{
    DBCHAR coded;
    JISX0201_R_ENCODE(*data, coded)
    else
        return MAP_UNMAPPABLE;
    return coded;
}

static Py_UCS4
jisx0201_k_decoder(const MultibyteCodec *codec, const unsigned char *data)
{
    Py_UCS4 u;
    JISX0201_K_DECODE_CHAR(*data ^ 0x80, u)
    else
        return MAP_UNMAPPABLE;
    return u;
}

static DBCHAR
jisx0201_k_encoder(const MultibyteCodec *codec, const Py_UCS4 *data,
                   Py_ssize_t *length)
{
    DBCHAR coded;
    JISX0201_K_ENCODE(*data, coded)
    else
        return MAP_UNMAPPABLE;
    return coded - 0x80;
}

static int
gb2312_init(const MultibyteCodec *codec)
{
    cjkcodecs_module_state *st = codec->modstate;
    if (IMPORT_MAP(cn, gbcommon, &st->gbcommon_encmap, NULL) ||
        IMPORT_MAP(cn, gb2312, NULL, &st->gb2312_decmap))
    {
        return -1;
    }
    return 0;
}

static Py_UCS4
gb2312_decoder(const MultibyteCodec *codec, const unsigned char *data)
{
    Py_UCS4 u;
    if (TRYMAP_DEC_ST(gb2312, u, data[0], data[1]))
        return u;
    else
        return MAP_UNMAPPABLE;
}

static DBCHAR
gb2312_encoder(const MultibyteCodec *codec, const Py_UCS4 *data,
               Py_ssize_t *length)
{
    DBCHAR coded;
    assert(*length == 1);
    if (*data < 0x10000) {
        if (TRYMAP_ENC_ST(gbcommon, coded, *data)) {
            if (!(coded & 0x8000))
                return coded;
        }
    }
    return MAP_UNMAPPABLE;
}


static Py_UCS4
dummy_decoder(const MultibyteCodec *codec, const unsigned char *data)
{
    return MAP_UNMAPPABLE;
}

static DBCHAR
dummy_encoder(const MultibyteCodec *codec, const Py_UCS4 *data,
              Py_ssize_t *length)
{
    return MAP_UNMAPPABLE;
}

/*-*- registry tables -*-*/

#define REGISTRY_KSX1001_G0     { CHARSET_KSX1001, 0, 2,                \
                  ksx1001_init,                                         \
                  ksx1001_decoder, ksx1001_encoder }
#define REGISTRY_KSX1001_G1     { CHARSET_KSX1001, 1, 2,                \
                  ksx1001_init,                                         \
                  ksx1001_decoder, ksx1001_encoder }
#define REGISTRY_JISX0201_R     { CHARSET_JISX0201_R, 0, 1,             \
                  NULL,                                                 \
                  jisx0201_r_decoder, jisx0201_r_encoder }
#define REGISTRY_JISX0201_K     { CHARSET_JISX0201_K, 0, 1,             \
                  NULL,                                                 \
                  jisx0201_k_decoder, jisx0201_k_encoder }
#define REGISTRY_JISX0208       { CHARSET_JISX0208, 0, 2,               \
                  jisx0208_init,                                        \
                  jisx0208_decoder, jisx0208_encoder }
#define REGISTRY_JISX0208_O     { CHARSET_JISX0208_O, 0, 2,             \
                  jisx0208_init,                                        \
                  jisx0208_decoder, jisx0208_encoder }
#define REGISTRY_JISX0212       { CHARSET_JISX0212, 0, 2,               \
                  jisx0212_init,                                        \
                  jisx0212_decoder, jisx0212_encoder }
#define REGISTRY_JISX0213_2000_1 { CHARSET_JISX0213_2000_1, 0, 2,       \
                  jisx0213_init,                                        \
                  jisx0213_2000_1_decoder,                              \
                  jisx0213_2000_1_encoder }
#define REGISTRY_JISX0213_2000_1_PAIRONLY { CHARSET_JISX0213_2000_1, 0, 2, \
                  jisx0213_init,                                        \
                  jisx0213_2000_1_decoder,                              \
                  jisx0213_2000_1_encoder_paironly }
#define REGISTRY_JISX0213_2000_2 { CHARSET_JISX0213_2, 0, 2,            \
                  jisx0213_init,                                        \
                  jisx0213_2000_2_decoder,                              \
                  jisx0213_2000_2_encoder }
#define REGISTRY_JISX0213_2004_1 { CHARSET_JISX0213_2004_1, 0, 2,       \
                  jisx0213_init,                                        \
                  jisx0213_2004_1_decoder,                              \
                  jisx0213_2004_1_encoder }
#define REGISTRY_JISX0213_2004_1_PAIRONLY { CHARSET_JISX0213_2004_1, 0, 2, \
                  jisx0213_init,                                        \
                  jisx0213_2004_1_decoder,                              \
                  jisx0213_2004_1_encoder_paironly }
#define REGISTRY_JISX0213_2004_2 { CHARSET_JISX0213_2, 0, 2,            \
                  jisx0213_init,                                        \
                  jisx0213_2004_2_decoder,                              \
                  jisx0213_2004_2_encoder }
#define REGISTRY_GB2312         { CHARSET_GB2312, 0, 2,                 \
                  gb2312_init,                                          \
                  gb2312_decoder, gb2312_encoder }
#define REGISTRY_CNS11643_1     { CHARSET_CNS11643_1, 1, 2,             \
                  cns11643_init,                                        \
                  cns11643_1_decoder, cns11643_1_encoder }
#define REGISTRY_CNS11643_2     { CHARSET_CNS11643_2, 2, 2,             \
                  cns11643_init,                                        \
                  cns11643_2_decoder, cns11643_2_encoder }
#define REGISTRY_ISO8859_1      { CHARSET_ISO8859_1, 2, 1,              \
                  NULL, dummy_decoder, dummy_encoder }
#define REGISTRY_ISO8859_7      { CHARSET_ISO8859_7, 2, 1,              \
                  NULL, dummy_decoder, dummy_encoder }
#define REGISTRY_SENTINEL       { 0, }
#define CONFIGDEF(var, attrs)                                           \
    static const struct iso2022_config iso2022_##var##_config = {       \
        attrs, iso2022_##var##_designations                             \
    };

static const struct iso2022_designation iso2022_kr_designations[] = {
    REGISTRY_KSX1001_G1, REGISTRY_SENTINEL
};
CONFIGDEF(kr, 0)

static const struct iso2022_designation iso2022_jp_designations[] = {
    REGISTRY_JISX0208, REGISTRY_JISX0201_R, REGISTRY_JISX0208_O,
    REGISTRY_SENTINEL
};
CONFIGDEF(jp, NO_SHIFT | USE_JISX0208_EXT)

static const struct iso2022_designation iso2022_jp_1_designations[] = {
    REGISTRY_JISX0208, REGISTRY_JISX0212, REGISTRY_JISX0201_R,
    REGISTRY_JISX0208_O, REGISTRY_SENTINEL
};
CONFIGDEF(jp_1, NO_SHIFT | USE_JISX0208_EXT)

static const struct iso2022_designation iso2022_jp_2_designations[] = {
    REGISTRY_JISX0208, REGISTRY_JISX0212, REGISTRY_KSX1001_G0,
    REGISTRY_GB2312, REGISTRY_JISX0201_R, REGISTRY_JISX0208_O,
    REGISTRY_ISO8859_1, REGISTRY_ISO8859_7, REGISTRY_SENTINEL
};
CONFIGDEF(jp_2, NO_SHIFT | USE_G2 | USE_JISX0208_EXT)

static const struct iso2022_designation iso2022_jp_2004_designations[] = {
    REGISTRY_JISX0213_2004_1_PAIRONLY, REGISTRY_JISX0208,
    REGISTRY_JISX0213_2004_1, REGISTRY_JISX0213_2004_2, REGISTRY_SENTINEL
};
CONFIGDEF(jp_2004, NO_SHIFT | USE_JISX0208_EXT)

static const struct iso2022_designation iso2022_jp_3_designations[] = {
    REGISTRY_JISX0213_2000_1_PAIRONLY, REGISTRY_JISX0208,
    REGISTRY_JISX0213_2000_1, REGISTRY_JISX0213_2000_2, REGISTRY_SENTINEL
};
CONFIGDEF(jp_3, NO_SHIFT | USE_JISX0208_EXT)

static const struct iso2022_designation iso2022_jp_ext_designations[] = {
    REGISTRY_JISX0208, REGISTRY_JISX0212, REGISTRY_JISX0201_R,
    REGISTRY_JISX0201_K, REGISTRY_JISX0208_O, REGISTRY_SENTINEL
};
CONFIGDEF(jp_ext, NO_SHIFT | USE_JISX0208_EXT)


BEGIN_MAPPINGS_LIST(0)
  /* no mapping table here */
END_MAPPINGS_LIST

#define ISO2022_CODEC(variation)                \
NEXT_CODEC = (MultibyteCodec){                  \
    "iso2022_" #variation,                      \
    &iso2022_##variation##_config,              \
    iso2022_codec_init,                         \
    _STATEFUL_METHODS(iso2022)                  \
};

BEGIN_CODECS_LIST(7)
  ISO2022_CODEC(kr)
  ISO2022_CODEC(jp)
  ISO2022_CODEC(jp_1)
  ISO2022_CODEC(jp_2)
  ISO2022_CODEC(jp_2004)
  ISO2022_CODEC(jp_3)
  ISO2022_CODEC(jp_ext)
END_CODECS_LIST

I_AM_A_MODULE_FOR(iso2022)


================================================
File: /Modules/cjkcodecs/_codecs_jp.c
================================================
/*
 * _codecs_jp.c: Codecs collection for Japanese encodings
 *
 * Written by Hye-Shik Chang <perky@FreeBSD.org>
 */

#define USING_BINARY_PAIR_SEARCH
#define EMPBASE 0x20000

#include "cjkcodecs.h"
#include "mappings_jp.h"
#include "mappings_jisx0213_pair.h"
#include "alg_jisx0201.h"
#include "emu_jisx0213_2000.h"

/*
 * CP932 codec
 */

ENCODER(cp932)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;
        unsigned char c1, c2;

        if (c <= 0x80) {
            WRITEBYTE1((unsigned char)c);
            NEXT(1, 1);
            continue;
        }
        else if (c >= 0xff61 && c <= 0xff9f) {
            WRITEBYTE1(c - 0xfec0);
            NEXT(1, 1);
            continue;
        }
        else if (c >= 0xf8f0 && c <= 0xf8f3) {
            /* Windows compatibility */
            REQUIRE_OUTBUF(1);
            if (c == 0xf8f0)
                OUTBYTE1(0xa0);
            else
                OUTBYTE1(c - 0xf8f1 + 0xfd);
            NEXT(1, 1);
            continue;
        }

        if (c > 0xFFFF)
            return 1;
        REQUIRE_OUTBUF(2);

        if (TRYMAP_ENC(cp932ext, code, c)) {
            OUTBYTE1(code >> 8);
            OUTBYTE2(code & 0xff);
        }
        else if (TRYMAP_ENC(jisxcommon, code, c)) {
            if (code & 0x8000) /* MSB set: JIS X 0212 */
                return 1;

            /* JIS X 0208 */
            c1 = code >> 8;
            c2 = code & 0xff;
            c2 = (((c1 - 0x21) & 1) ? 0x5e : 0) + (c2 - 0x21);
            c1 = (c1 - 0x21) >> 1;
            OUTBYTE1(c1 < 0x1f ? c1 + 0x81 : c1 + 0xc1);
            OUTBYTE2(c2 < 0x3f ? c2 + 0x40 : c2 + 0x41);
        }
        else if (c >= 0xe000 && c < 0xe758) {
            /* User-defined area */
            c1 = (Py_UCS4)(c - 0xe000) / 188;
            c2 = (Py_UCS4)(c - 0xe000) % 188;
            OUTBYTE1(c1 + 0xf0);
            OUTBYTE2(c2 < 0x3f ? c2 + 0x40 : c2 + 0x41);
        }
        else
            return 1;

        NEXT(1, 2);
    }

    return 0;
}

DECODER(cp932)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1, c2;
        Py_UCS4 decoded;

        if (c <= 0x80) {
            OUTCHAR(c);
            NEXT_IN(1);
            continue;
        }
        else if (c >= 0xa0 && c <= 0xdf) {
            if (c == 0xa0)
                OUTCHAR(0xf8f0); /* half-width katakana */
            else
                OUTCHAR(0xfec0 + c);
            NEXT_IN(1);
            continue;
        }
        else if (c >= 0xfd/* && c <= 0xff*/) {
            /* Windows compatibility */
            OUTCHAR(0xf8f1 - 0xfd + c);
            NEXT_IN(1);
            continue;
        }

        REQUIRE_INBUF(2);
        c2 = INBYTE2;

        if (TRYMAP_DEC(cp932ext, decoded, c, c2))
            OUTCHAR(decoded);
        else if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)){
            if (c2 < 0x40 || (c2 > 0x7e && c2 < 0x80) || c2 > 0xfc)
                return 1;

            c = (c < 0xe0 ? c - 0x81 : c - 0xc1);
            c2 = (c2 < 0x80 ? c2 - 0x40 : c2 - 0x41);
            c = (2 * c + (c2 < 0x5e ? 0 : 1) + 0x21);
            c2 = (c2 < 0x5e ? c2 : c2 - 0x5e) + 0x21;

            if (TRYMAP_DEC(jisx0208, decoded, c, c2))
                OUTCHAR(decoded);
            else
                return 1;
        }
        else if (c >= 0xf0 && c <= 0xf9) {
            if ((c2 >= 0x40 && c2 <= 0x7e) ||
                (c2 >= 0x80 && c2 <= 0xfc))
                OUTCHAR(0xe000 + 188 * (c - 0xf0) +
                    (c2 < 0x80 ? c2 - 0x40 : c2 - 0x41));
            else
                return 1;
        }
        else
            return 1;

        NEXT_IN(2);
    }

    return 0;
}


/*
 * EUC-JIS-2004 codec
 */

ENCODER(euc_jis_2004)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;
        Py_ssize_t insize;

        if (c < 0x80) {
            WRITEBYTE1(c);
            NEXT(1, 1);
            continue;
        }

        insize = 1;

        if (c <= 0xFFFF) {
            EMULATE_JISX0213_2000_ENCODE_BMP(codec->config, code, c)
            else if (TRYMAP_ENC(jisx0213_bmp, code, c)) {
                if (code == MULTIC) {
                    if (inlen - *inpos < 2) {
                        if (flags & MBENC_FLUSH) {
                            code = find_pairencmap(
                                (ucs2_t)c, 0,
                              jisx0213_pair_encmap,
                                JISX0213_ENCPAIRS);
                            if (code == DBCINV)
                                return 1;
                        }
                        else
                            return MBERR_TOOFEW;
                    }
                    else {
                        Py_UCS4 c2 = INCHAR2;
                        code = find_pairencmap(
                            (ucs2_t)c, c2,
                            jisx0213_pair_encmap,
                            JISX0213_ENCPAIRS);
                        if (code == DBCINV) {
                            code = find_pairencmap(
                                (ucs2_t)c, 0,
                              jisx0213_pair_encmap,
                                JISX0213_ENCPAIRS);
                            if (code == DBCINV)
                                return 1;
                        } else
                            insize = 2;
                    }
                }
            }
            else if (TRYMAP_ENC(jisxcommon, code, c))
                ;
            else if (c >= 0xff61 && c <= 0xff9f) {
                /* JIS X 0201 half-width katakana */
                WRITEBYTE2(0x8e, c - 0xfec0);
                NEXT(1, 2);
                continue;
            }
            else if (c == 0xff3c)
                /* F/W REVERSE SOLIDUS (see NOTES) */
                code = 0x2140;
            else if (c == 0xff5e)
                /* F/W TILDE (see NOTES) */
                code = 0x2232;
            else
                return 1;
        }
        else if (c >> 16 == EMPBASE >> 16) {
            EMULATE_JISX0213_2000_ENCODE_EMP(codec->config, code, c)
            else if (TRYMAP_ENC(jisx0213_emp, code, c & 0xffff))
                ;
            else
                return insize;
        }
        else
            return insize;

        if (code & 0x8000) {
            /* Codeset 2 */
            WRITEBYTE3(0x8f, code >> 8, (code & 0xFF) | 0x80);
            NEXT(insize, 3);
        } else {
            /* Codeset 1 */
            WRITEBYTE2((code >> 8) | 0x80, (code & 0xFF) | 0x80);
            NEXT(insize, 2);
        }
    }

    return 0;
}

DECODER(euc_jis_2004)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1;
        Py_UCS4 code, decoded;

        if (c < 0x80) {
            OUTCHAR(c);
            NEXT_IN(1);
            continue;
        }

        if (c == 0x8e) {
            /* JIS X 0201 half-width katakana */
            unsigned char c2;

            REQUIRE_INBUF(2);
            c2 = INBYTE2;
            if (c2 >= 0xa1 && c2 <= 0xdf) {
                OUTCHAR(0xfec0 + c2);
                NEXT_IN(2);
            }
            else
                return 1;
        }
        else if (c == 0x8f) {
            unsigned char c2, c3;

            REQUIRE_INBUF(3);
            c2 = INBYTE2 ^ 0x80;
            c3 = INBYTE3 ^ 0x80;

            /* JIS X 0213 Plane 2 or JIS X 0212 (see NOTES) */
            EMULATE_JISX0213_2000_DECODE_PLANE2(codec->config, writer, c2, c3)
            else if (TRYMAP_DEC(jisx0213_2_bmp, decoded, c2, c3))
                OUTCHAR(decoded);
            else if (TRYMAP_DEC(jisx0213_2_emp, code, c2, c3)) {
                OUTCHAR(EMPBASE | code);
                NEXT_IN(3);
                continue;
            }
            else if (TRYMAP_DEC(jisx0212, decoded, c2, c3))
                OUTCHAR(decoded);
            else
                return 1;
            NEXT_IN(3);
        }
        else {
            unsigned char c2;

            REQUIRE_INBUF(2);
            c ^= 0x80;
            c2 = INBYTE2 ^ 0x80;

            /* JIS X 0213 Plane 1 */
            EMULATE_JISX0213_2000_DECODE_PLANE1(codec->config, writer, c, c2)
            else if (c == 0x21 && c2 == 0x40)
                OUTCHAR(0xff3c);
            else if (c == 0x22 && c2 == 0x32)
                OUTCHAR(0xff5e);
            else if (TRYMAP_DEC(jisx0208, decoded, c, c2))
                OUTCHAR(decoded);
            else if (TRYMAP_DEC(jisx0213_1_bmp, decoded, c, c2))
                OUTCHAR(decoded);
            else if (TRYMAP_DEC(jisx0213_1_emp, code, c, c2)) {
                OUTCHAR(EMPBASE | code);
                NEXT_IN(2);
                continue;
            }
            else if (TRYMAP_DEC(jisx0213_pair, code, c, c2)) {
                OUTCHAR2(code >> 16, code & 0xffff);
                NEXT_IN(2);
                continue;
            }
            else
                return 1;
            NEXT_IN(2);
        }
    }

    return 0;
}


/*
 * EUC-JP codec
 */

ENCODER(euc_jp)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;

        if (c < 0x80) {
            WRITEBYTE1((unsigned char)c);
            NEXT(1, 1);
            continue;
        }

        if (c > 0xFFFF)
            return 1;

        if (TRYMAP_ENC(jisxcommon, code, c))
            ;
        else if (c >= 0xff61 && c <= 0xff9f) {
            /* JIS X 0201 half-width katakana */
            WRITEBYTE2(0x8e, c - 0xfec0);
            NEXT(1, 2);
            continue;
        }
#ifndef STRICT_BUILD
        else if (c == 0xff3c) /* FULL-WIDTH REVERSE SOLIDUS */
            code = 0x2140;
        else if (c == 0xa5) { /* YEN SIGN */
            WRITEBYTE1(0x5c);
            NEXT(1, 1);
            continue;
        } else if (c == 0x203e) { /* OVERLINE */
            WRITEBYTE1(0x7e);
            NEXT(1, 1);
            continue;
        }
#endif
        else
            return 1;

        if (code & 0x8000) {
            /* JIS X 0212 */
            WRITEBYTE3(0x8f, code >> 8, (code & 0xFF) | 0x80);
            NEXT(1, 3);
        } else {
            /* JIS X 0208 */
            WRITEBYTE2((code >> 8) | 0x80, (code & 0xFF) | 0x80);
            NEXT(1, 2);
        }
    }

    return 0;
}

DECODER(euc_jp)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1;
        Py_UCS4 decoded;

        if (c < 0x80) {
            OUTCHAR(c);
            NEXT_IN(1);
            continue;
        }

        if (c == 0x8e) {
            /* JIS X 0201 half-width katakana */
            unsigned char c2;

            REQUIRE_INBUF(2);
            c2 = INBYTE2;
            if (c2 >= 0xa1 && c2 <= 0xdf) {
                OUTCHAR(0xfec0 + c2);
                NEXT_IN(2);
            }
            else
                return 1;
        }
        else if (c == 0x8f) {
            unsigned char c2, c3;

            REQUIRE_INBUF(3);
            c2 = INBYTE2;
            c3 = INBYTE3;
            /* JIS X 0212 */
            if (TRYMAP_DEC(jisx0212, decoded, c2 ^ 0x80, c3 ^ 0x80)) {
                OUTCHAR(decoded);
                NEXT_IN(3);
            }
            else
                return 1;
        }
        else {
            unsigned char c2;

            REQUIRE_INBUF(2);
            c2 = INBYTE2;
            /* JIS X 0208 */
#ifndef STRICT_BUILD
            if (c == 0xa1 && c2 == 0xc0)
                /* FULL-WIDTH REVERSE SOLIDUS */
                OUTCHAR(0xff3c);
            else
#endif
            if (TRYMAP_DEC(jisx0208, decoded, c ^ 0x80, c2 ^ 0x80))
                OUTCHAR(decoded);
            else
                return 1;
            NEXT_IN(2);
        }
    }

    return 0;
}


/*
 * SHIFT_JIS codec
 */

ENCODER(shift_jis)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;
        unsigned char c1, c2;

#ifdef STRICT_BUILD
        JISX0201_R_ENCODE(c, code)
#else
        if (c < 0x80)
            code = c;
        else if (c == 0x00a5)
            code = 0x5c; /* YEN SIGN */
        else if (c == 0x203e)
            code = 0x7e; /* OVERLINE */
#endif
        else JISX0201_K_ENCODE(c, code)
        else if (c > 0xFFFF)
            return 1;
        else
            code = NOCHAR;

        if (code < 0x80 || (code >= 0xa1 && code <= 0xdf)) {
            REQUIRE_OUTBUF(1);

            OUTBYTE1((unsigned char)code);
            NEXT(1, 1);
            continue;
        }

        REQUIRE_OUTBUF(2);

        if (code == NOCHAR) {
            if (TRYMAP_ENC(jisxcommon, code, c))
                ;
#ifndef STRICT_BUILD
            else if (c == 0xff3c)
                code = 0x2140; /* FULL-WIDTH REVERSE SOLIDUS */
#endif
            else
                return 1;

            if (code & 0x8000) /* MSB set: JIS X 0212 */
                return 1;
        }

        c1 = code >> 8;
        c2 = code & 0xff;
        c2 = (((c1 - 0x21) & 1) ? 0x5e : 0) + (c2 - 0x21);
        c1 = (c1 - 0x21) >> 1;
        OUTBYTE1(c1 < 0x1f ? c1 + 0x81 : c1 + 0xc1);
        OUTBYTE2(c2 < 0x3f ? c2 + 0x40 : c2 + 0x41);
        NEXT(1, 2);
    }

    return 0;
}

DECODER(shift_jis)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1;
        Py_UCS4 decoded;

#ifdef STRICT_BUILD
        JISX0201_R_DECODE(c, writer)
#else
        if (c < 0x80)
            OUTCHAR(c);
#endif
        else JISX0201_K_DECODE(c, writer)
        else if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xea)){
            unsigned char c1, c2;

            REQUIRE_INBUF(2);
            c2 = INBYTE2;
            if (c2 < 0x40 || (c2 > 0x7e && c2 < 0x80) || c2 > 0xfc)
                return 1;

            c1 = (c < 0xe0 ? c - 0x81 : c - 0xc1);
            c2 = (c2 < 0x80 ? c2 - 0x40 : c2 - 0x41);
            c1 = (2 * c1 + (c2 < 0x5e ? 0 : 1) + 0x21);
            c2 = (c2 < 0x5e ? c2 : c2 - 0x5e) + 0x21;

#ifndef STRICT_BUILD
            if (c1 == 0x21 && c2 == 0x40) {
                /* FULL-WIDTH REVERSE SOLIDUS */
                OUTCHAR(0xff3c);
                NEXT_IN(2);
                continue;
            }
#endif
            if (TRYMAP_DEC(jisx0208, decoded, c1, c2)) {
                OUTCHAR(decoded);
                NEXT_IN(2);
                continue;
            }
            else
                return 1;
        }
        else
            return 1;

        NEXT_IN(1); /* JIS X 0201 */
    }

    return 0;
}


/*
 * SHIFT_JIS-2004 codec
 */

ENCODER(shift_jis_2004)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code = NOCHAR;
        int c1, c2;
        Py_ssize_t insize;

        JISX0201_ENCODE(c, code)

        if (code < 0x80 || (code >= 0xa1 && code <= 0xdf)) {
            WRITEBYTE1((unsigned char)code);
            NEXT(1, 1);
            continue;
        }

        REQUIRE_OUTBUF(2);
        insize = 1;

        if (code == NOCHAR) {
            if (c <= 0xffff) {
                EMULATE_JISX0213_2000_ENCODE_BMP(codec->config, code, c)
                else if (TRYMAP_ENC(jisx0213_bmp, code, c)) {
                    if (code == MULTIC) {
                        if (inlen - *inpos < 2) {
                            if (flags & MBENC_FLUSH) {
                            code = find_pairencmap
                                ((ucs2_t)c, 0,
                              jisx0213_pair_encmap,
                                JISX0213_ENCPAIRS);
                            if (code == DBCINV)
                                return 1;
                            }
                            else
                                return MBERR_TOOFEW;
                        }
                        else {
                            Py_UCS4 ch2 = INCHAR2;
                            code = find_pairencmap(
                                (ucs2_t)c, ch2,
                              jisx0213_pair_encmap,
                                JISX0213_ENCPAIRS);
                            if (code == DBCINV) {
                            code = find_pairencmap(
                                (ucs2_t)c, 0,
                              jisx0213_pair_encmap,
                                JISX0213_ENCPAIRS);
                            if (code == DBCINV)
                                return 1;
                            }
                            else
                                insize = 2;
                        }
                    }
                }
                else if (TRYMAP_ENC(jisxcommon, code, c)) {
                    /* abandon JIS X 0212 codes */
                    if (code & 0x8000)
                        return 1;
                }
                else
                    return 1;
            }
            else if (c >> 16 == EMPBASE >> 16) {
                EMULATE_JISX0213_2000_ENCODE_EMP(codec->config, code, c)
                else if (TRYMAP_ENC(jisx0213_emp, code, c&0xffff))
                    ;
                else
                    return insize;
            }
            else
                return insize;
        }

        c1 = code >> 8;
        c2 = (code & 0xff) - 0x21;

        if (c1 & 0x80) {
            /* Plane 2 */
            if (c1 >= 0xee)
                c1 -= 0x87;
            else if (c1 >= 0xac || c1 == 0xa8)
                c1 -= 0x49;
            else
                c1 -= 0x43;
        }
        else {
            /* Plane 1 */
            c1 -= 0x21;
        }

        if (c1 & 1)
            c2 += 0x5e;
        c1 >>= 1;
        OUTBYTE1(c1 + (c1 < 0x1f ? 0x81 : 0xc1));
        OUTBYTE2(c2 + (c2 < 0x3f ? 0x40 : 0x41));

        NEXT(insize, 2);
    }

    return 0;
}

DECODER(shift_jis_2004)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1;

        JISX0201_DECODE(c, writer)
        else if ((c >= 0x81 && c <= 0x9f) || (c >= 0xe0 && c <= 0xfc)){
            unsigned char c1, c2;
            Py_UCS4 code, decoded;

            REQUIRE_INBUF(2);
            c2 = INBYTE2;
            if (c2 < 0x40 || (c2 > 0x7e && c2 < 0x80) || c2 > 0xfc)
                return 1;

            c1 = (c < 0xe0 ? c - 0x81 : c - 0xc1);
            c2 = (c2 < 0x80 ? c2 - 0x40 : c2 - 0x41);
            c1 = (2 * c1 + (c2 < 0x5e ? 0 : 1));
            c2 = (c2 < 0x5e ? c2 : c2 - 0x5e) + 0x21;

            if (c1 < 0x5e) { /* Plane 1 */
                c1 += 0x21;
                EMULATE_JISX0213_2000_DECODE_PLANE1(codec->config, writer,
                                c1, c2)
                else if (TRYMAP_DEC(jisx0208, decoded, c1, c2))
                    OUTCHAR(decoded);
                else if (TRYMAP_DEC(jisx0213_1_bmp, decoded, c1, c2))
                    OUTCHAR(decoded);
                else if (TRYMAP_DEC(jisx0213_1_emp, code, c1, c2))
                    OUTCHAR(EMPBASE | code);
                else if (TRYMAP_DEC(jisx0213_pair, code, c1, c2))
                    OUTCHAR2(code >> 16, code & 0xffff);
                else
                    return 1;
                NEXT_IN(2);
            }
            else { /* Plane 2 */
                if (c1 >= 0x67)
                    c1 += 0x07;
                else if (c1 >= 0x63 || c1 == 0x5f)
                    c1 -= 0x37;
                else
                    c1 -= 0x3d;

                EMULATE_JISX0213_2000_DECODE_PLANE2(codec->config, writer,
                                c1, c2)
                else if (TRYMAP_DEC(jisx0213_2_bmp, decoded, c1, c2))
                    OUTCHAR(decoded);
                else if (TRYMAP_DEC(jisx0213_2_emp, code, c1, c2)) {
                    OUTCHAR(EMPBASE | code);
                    NEXT_IN(2);
                    continue;
                }
                else
                    return 1;
                NEXT_IN(2);
            }
            continue;
        }
        else
            return 1;

        NEXT_IN(1); /* JIS X 0201 */
    }

    return 0;
}


BEGIN_MAPPINGS_LIST(11)
  MAPPING_DECONLY(jisx0208)
  MAPPING_DECONLY(jisx0212)
  MAPPING_ENCONLY(jisxcommon)
  MAPPING_DECONLY(jisx0213_1_bmp)
  MAPPING_DECONLY(jisx0213_2_bmp)
  MAPPING_ENCONLY(jisx0213_bmp)
  MAPPING_DECONLY(jisx0213_1_emp)
  MAPPING_DECONLY(jisx0213_2_emp)
  MAPPING_ENCONLY(jisx0213_emp)
  MAPPING_ENCDEC(jisx0213_pair)
  MAPPING_ENCDEC(cp932ext)
END_MAPPINGS_LIST

#define CODEC_CUSTOM(NAME, N, METH) \
    NEXT_CODEC = (MultibyteCodec){NAME, (void *)N, NULL, _STATELESS_METHODS(METH)};

BEGIN_CODECS_LIST(7)
  CODEC_STATELESS(shift_jis)
  CODEC_STATELESS(cp932)
  CODEC_STATELESS(euc_jp)
  CODEC_STATELESS(shift_jis_2004)
  CODEC_STATELESS(euc_jis_2004)
  CODEC_CUSTOM("euc_jisx0213", 2000, euc_jis_2004)
  CODEC_CUSTOM("shift_jisx0213", 2000, shift_jis_2004)
END_CODECS_LIST

#undef CODEC_CUSTOM

I_AM_A_MODULE_FOR(jp)


================================================
File: /Modules/cjkcodecs/_codecs_kr.c
================================================
/*
 * _codecs_kr.c: Codecs collection for Korean encodings
 *
 * Written by Hye-Shik Chang <perky@FreeBSD.org>
 */

#include "cjkcodecs.h"
#include "mappings_kr.h"

/*
 * EUC-KR codec
 */

#define EUCKR_JAMO_FIRSTBYTE    0xA4
#define EUCKR_JAMO_FILLER       0xD4

static const unsigned char u2cgk_choseong[19] = {
    0xa1, 0xa2, 0xa4, 0xa7, 0xa8, 0xa9, 0xb1, 0xb2,
    0xb3, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb,
    0xbc, 0xbd, 0xbe
};
static const unsigned char u2cgk_jungseong[21] = {
    0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6,
    0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce,
    0xcf, 0xd0, 0xd1, 0xd2, 0xd3
};
static const unsigned char u2cgk_jongseong[28] = {
    0xd4, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7,
    0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0,
    0xb1, 0xb2, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xba,
    0xbb, 0xbc, 0xbd, 0xbe
};

ENCODER(euc_kr)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;

        if (c < 0x80) {
            WRITEBYTE1((unsigned char)c);
            NEXT(1, 1);
            continue;
        }

        if (c > 0xFFFF)
            return 1;

        REQUIRE_OUTBUF(2);
        if (TRYMAP_ENC(cp949, code, c))
            ;
        else
            return 1;

        if ((code & 0x8000) == 0) {
            /* KS X 1001 coded character */
            OUTBYTE1((code >> 8) | 0x80);
            OUTBYTE2((code & 0xFF) | 0x80);
            NEXT(1, 2);
        }
        else {
            /* Mapping is found in CP949 extension,
               but we encode it in KS X 1001:1998,
               make-up sequence for EUC-KR. */

            REQUIRE_OUTBUF(8);

            /* syllable composition precedence */
            OUTBYTE1(EUCKR_JAMO_FIRSTBYTE);
            OUTBYTE2(EUCKR_JAMO_FILLER);

            /* All code points in CP949 extension are in unicode
             * Hangul Syllable area. */
            assert(0xac00 <= c && c <= 0xd7a3);
            c -= 0xac00;

            OUTBYTE3(EUCKR_JAMO_FIRSTBYTE);
            OUTBYTE4(u2cgk_choseong[c / 588]);
            NEXT_OUT(4);

            OUTBYTE1(EUCKR_JAMO_FIRSTBYTE);
            OUTBYTE2(u2cgk_jungseong[(c / 28) % 21]);
            OUTBYTE3(EUCKR_JAMO_FIRSTBYTE);
            OUTBYTE4(u2cgk_jongseong[c % 28]);
            NEXT(1, 4);
        }
    }

    return 0;
}

#define NONE    127

static const unsigned char cgk2u_choseong[] = { /* [A1, BE] */
       0,    1, NONE,    2, NONE, NONE,    3,    4,
       5, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
       6,    7,    8, NONE,    9,   10,   11,   12,
      13,   14,   15,   16,   17,   18
};
static const unsigned char cgk2u_jongseong[] = { /* [A1, BE] */
       1,    2,    3,    4,    5,    6,    7, NONE,
       8,    9,   10,   11,   12,   13,   14,   15,
      16,   17, NONE,   18,   19,   20,   21,   22,
    NONE,   23,   24,   25,   26,   27
};

DECODER(euc_kr)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1;
        Py_UCS4 decoded;

        if (c < 0x80) {
            OUTCHAR(c);
            NEXT_IN(1);
            continue;
        }

        REQUIRE_INBUF(2);

        if (c == EUCKR_JAMO_FIRSTBYTE &&
            INBYTE2 == EUCKR_JAMO_FILLER) {
            /* KS X 1001:1998 make-up sequence */
            DBCHAR cho, jung, jong;

            REQUIRE_INBUF(8);
            if ((*inbuf)[2] != EUCKR_JAMO_FIRSTBYTE ||
                (*inbuf)[4] != EUCKR_JAMO_FIRSTBYTE ||
                (*inbuf)[6] != EUCKR_JAMO_FIRSTBYTE)
                return 1;

            c = (*inbuf)[3];
            if (0xa1 <= c && c <= 0xbe)
                cho = cgk2u_choseong[c - 0xa1];
            else
                cho = NONE;

            c = (*inbuf)[5];
            jung = (0xbf <= c && c <= 0xd3) ? c - 0xbf : NONE;

            c = (*inbuf)[7];
            if (c == EUCKR_JAMO_FILLER)
                jong = 0;
            else if (0xa1 <= c && c <= 0xbe)
                jong = cgk2u_jongseong[c - 0xa1];
            else
                jong = NONE;

            if (cho == NONE || jung == NONE || jong == NONE)
                return 1;

            OUTCHAR(0xac00 + cho*588 + jung*28 + jong);
            NEXT_IN(8);
        }
        else if (TRYMAP_DEC(ksx1001, decoded, c ^ 0x80, INBYTE2 ^ 0x80)) {
            OUTCHAR(decoded);
            NEXT_IN(2);
        }
        else
            return 1;
    }

    return 0;
}
#undef NONE


/*
 * CP949 codec
 */

ENCODER(cp949)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;

        if (c < 0x80) {
            WRITEBYTE1((unsigned char)c);
            NEXT(1, 1);
            continue;
        }

        if (c > 0xFFFF)
            return 1;

        REQUIRE_OUTBUF(2);
        if (TRYMAP_ENC(cp949, code, c))
            ;
        else
            return 1;

        OUTBYTE1((code >> 8) | 0x80);
        if (code & 0x8000)
            OUTBYTE2(code & 0xFF); /* MSB set: CP949 */
        else
            OUTBYTE2((code & 0xFF) | 0x80); /* MSB unset: ks x 1001 */
        NEXT(1, 2);
    }

    return 0;
}

DECODER(cp949)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1;
        Py_UCS4 decoded;

        if (c < 0x80) {
            OUTCHAR(c);
            NEXT_IN(1);
            continue;
        }

        REQUIRE_INBUF(2);
        if (TRYMAP_DEC(ksx1001, decoded, c ^ 0x80, INBYTE2 ^ 0x80))
            OUTCHAR(decoded);
        else if (TRYMAP_DEC(cp949ext, decoded, c, INBYTE2))
            OUTCHAR(decoded);
        else
            return 1;

        NEXT_IN(2);
    }

    return 0;
}


/*
 * JOHAB codec
 */

static const unsigned char u2johabidx_choseong[32] = {
                0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11, 0x12, 0x13, 0x14,
};
static const unsigned char u2johabidx_jungseong[32] = {
                      0x03, 0x04, 0x05, 0x06, 0x07,
                0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
                0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
                0x1a, 0x1b, 0x1c, 0x1d,
};
static const unsigned char u2johabidx_jongseong[32] = {
          0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
    0x10, 0x11,       0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d,
};
static const DBCHAR u2johabjamo[] = {
            0x8841, 0x8c41, 0x8444, 0x9041, 0x8446, 0x8447, 0x9441,
    0x9841, 0x9c41, 0x844a, 0x844b, 0x844c, 0x844d, 0x844e, 0x844f,
    0x8450, 0xa041, 0xa441, 0xa841, 0x8454, 0xac41, 0xb041, 0xb441,
    0xb841, 0xbc41, 0xc041, 0xc441, 0xc841, 0xcc41, 0xd041, 0x8461,
    0x8481, 0x84a1, 0x84c1, 0x84e1, 0x8541, 0x8561, 0x8581, 0x85a1,
    0x85c1, 0x85e1, 0x8641, 0x8661, 0x8681, 0x86a1, 0x86c1, 0x86e1,
    0x8741, 0x8761, 0x8781, 0x87a1,
};

ENCODER(johab)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;

        if (c < 0x80) {
            WRITEBYTE1((unsigned char)c);
            NEXT(1, 1);
            continue;
        }

        if (c > 0xFFFF)
            return 1;

        REQUIRE_OUTBUF(2);

        if (c >= 0xac00 && c <= 0xd7a3) {
            c -= 0xac00;
            code = 0x8000 |
                (u2johabidx_choseong[c / 588] << 10) |
                (u2johabidx_jungseong[(c / 28) % 21] << 5) |
                u2johabidx_jongseong[c % 28];
        }
        else if (c >= 0x3131 && c <= 0x3163)
            code = u2johabjamo[c - 0x3131];
        else if (TRYMAP_ENC(cp949, code, c)) {
            unsigned char c1, c2, t2;
            unsigned short t1;

            assert((code & 0x8000) == 0);
            c1 = code >> 8;
            c2 = code & 0xff;
            if (((c1 >= 0x21 && c1 <= 0x2c) ||
                (c1 >= 0x4a && c1 <= 0x7d)) &&
                (c2 >= 0x21 && c2 <= 0x7e)) {
                t1 = (c1 < 0x4a ? (c1 - 0x21 + 0x1b2) :
                          (c1 - 0x21 + 0x197));
                t2 = ((t1 & 1) ? 0x5e : 0) + (c2 - 0x21);
                OUTBYTE1(t1 >> 1);
                OUTBYTE2(t2 < 0x4e ? t2 + 0x31 : t2 + 0x43);
                NEXT(1, 2);
                continue;
            }
            else
                return 1;
        }
        else
            return 1;

        OUTBYTE1(code >> 8);
        OUTBYTE2(code & 0xff);
        NEXT(1, 2);
    }

    return 0;
}

#define FILL 0xfd
#define NONE 0xff

static const unsigned char johabidx_choseong[32] = {
    NONE, FILL, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05,
    0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d,
    0x0e, 0x0f, 0x10, 0x11, 0x12, NONE, NONE, NONE,
    NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
};
static const unsigned char johabidx_jungseong[32] = {
    NONE, NONE, FILL, 0x00, 0x01, 0x02, 0x03, 0x04,
    NONE, NONE, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
    NONE, NONE, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,
    NONE, NONE, 0x11, 0x12, 0x13, 0x14, NONE, NONE,
};
static const unsigned char johabidx_jongseong[32] = {
    NONE, FILL, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
    0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e,
    0x0f, 0x10, NONE, 0x11, 0x12, 0x13, 0x14, 0x15,
    0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, NONE, NONE,
};

static const unsigned char johabjamo_choseong[32] = {
    NONE, FILL, 0x31, 0x32, 0x34, 0x37, 0x38, 0x39,
    0x41, 0x42, 0x43, 0x45, 0x46, 0x47, 0x48, 0x49,
    0x4a, 0x4b, 0x4c, 0x4d, 0x4e, NONE, NONE, NONE,
    NONE, NONE, NONE, NONE, NONE, NONE, NONE, NONE,
};
static const unsigned char johabjamo_jungseong[32] = {
    NONE, NONE, FILL, 0x4f, 0x50, 0x51, 0x52, 0x53,
    NONE, NONE, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
    NONE, NONE, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
    NONE, NONE, 0x60, 0x61, 0x62, 0x63, NONE, NONE,
};
static const unsigned char johabjamo_jongseong[32] = {
    NONE, FILL, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36,
    0x37, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
    0x40, 0x41, NONE, 0x42, 0x44, 0x45, 0x46, 0x47,
    0x48, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, NONE, NONE,
};

DECODER(johab)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1, c2;
        Py_UCS4 decoded;

        if (c < 0x80) {
            OUTCHAR(c);
            NEXT_IN(1);
            continue;
        }

        REQUIRE_INBUF(2);
        c2 = INBYTE2;

        if (c < 0xd8) {
            /* johab hangul */
            unsigned char c_cho, c_jung, c_jong;
            unsigned char i_cho, i_jung, i_jong;

            c_cho = (c >> 2) & 0x1f;
            c_jung = ((c << 3) | c2 >> 5) & 0x1f;
            c_jong = c2 & 0x1f;

            i_cho = johabidx_choseong[c_cho];
            i_jung = johabidx_jungseong[c_jung];
            i_jong = johabidx_jongseong[c_jong];

            if (i_cho == NONE || i_jung == NONE || i_jong == NONE)
                return 1;

            /* we don't use U+1100 hangul jamo yet. */
            if (i_cho == FILL) {
                if (i_jung == FILL) {
                    if (i_jong == FILL)
                        OUTCHAR(0x3000);
                    else
                        OUTCHAR(0x3100 |
                            johabjamo_jongseong[c_jong]);
                }
                else {
                    if (i_jong == FILL)
                        OUTCHAR(0x3100 |
                            johabjamo_jungseong[c_jung]);
                    else
                        return 1;
                }
            } else {
                if (i_jung == FILL) {
                    if (i_jong == FILL)
                        OUTCHAR(0x3100 |
                            johabjamo_choseong[c_cho]);
                    else
                        return 1;
                }
                else
                    OUTCHAR(0xac00 +
                        i_cho * 588 +
                        i_jung * 28 +
                        (i_jong == FILL ? 0 : i_jong));
            }
            NEXT_IN(2);
        } else {
            /* KS X 1001 except hangul jamos and syllables */
            if (c == 0xdf || c > 0xf9 ||
                c2 < 0x31 || (c2 >= 0x80 && c2 < 0x91) ||
                (c2 & 0x7f) == 0x7f ||
                (c == 0xda && (c2 >= 0xa1 && c2 <= 0xd3)))
                return 1;
            else {
                unsigned char t1, t2;

                t1 = (c < 0xe0 ? 2 * (c - 0xd9) :
                         2 * c - 0x197);
                t2 = (c2 < 0x91 ? c2 - 0x31 : c2 - 0x43);
                t1 = t1 + (t2 < 0x5e ? 0 : 1) + 0x21;
                t2 = (t2 < 0x5e ? t2 : t2 - 0x5e) + 0x21;

                if (TRYMAP_DEC(ksx1001, decoded, t1, t2)) {
                    OUTCHAR(decoded);
                    NEXT_IN(2);
                }
                else {
                    return 1;
                }
            }
        }
    }

    return 0;
}
#undef NONE
#undef FILL


BEGIN_MAPPINGS_LIST(3)
  MAPPING_DECONLY(ksx1001)
  MAPPING_ENCONLY(cp949)
  MAPPING_DECONLY(cp949ext)
END_MAPPINGS_LIST

BEGIN_CODECS_LIST(3)
  CODEC_STATELESS(euc_kr)
  CODEC_STATELESS(cp949)
  CODEC_STATELESS(johab)
END_CODECS_LIST

I_AM_A_MODULE_FOR(kr)


================================================
File: /Modules/cjkcodecs/_codecs_tw.c
================================================
/*
 * _codecs_tw.c: Codecs collection for Taiwan's encodings
 *
 * Written by Hye-Shik Chang <perky@FreeBSD.org>
 */

#include "cjkcodecs.h"
#include "mappings_tw.h"

/*
 * BIG5 codec
 */

ENCODER(big5)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;

        if (c < 0x80) {
            REQUIRE_OUTBUF(1);
            **outbuf = (unsigned char)c;
            NEXT(1, 1);
            continue;
        }

        if (c > 0xFFFF)
            return 1;

        REQUIRE_OUTBUF(2);

        if (TRYMAP_ENC(big5, code, c))
            ;
        else
            return 1;

        OUTBYTE1(code >> 8);
        OUTBYTE2(code & 0xFF);
        NEXT(1, 2);
    }

    return 0;
}

DECODER(big5)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1;
        Py_UCS4 decoded;

        if (c < 0x80) {
            OUTCHAR(c);
            NEXT_IN(1);
            continue;
        }

        REQUIRE_INBUF(2);
        if (TRYMAP_DEC(big5, decoded, c, INBYTE2)) {
            OUTCHAR(decoded);
            NEXT_IN(2);
        }
        else return 1;
    }

    return 0;
}


/*
 * CP950 codec
 */

ENCODER(cp950)
{
    while (*inpos < inlen) {
        Py_UCS4 c = INCHAR1;
        DBCHAR code;

        if (c < 0x80) {
            WRITEBYTE1((unsigned char)c);
            NEXT(1, 1);
            continue;
        }

        if (c > 0xFFFF)
            return 1;

        REQUIRE_OUTBUF(2);
        if (TRYMAP_ENC(cp950ext, code, c))
            ;
        else if (TRYMAP_ENC(big5, code, c))
            ;
        else
            return 1;

        OUTBYTE1(code >> 8);
        OUTBYTE2(code & 0xFF);
        NEXT(1, 2);
    }

    return 0;
}

DECODER(cp950)
{
    while (inleft > 0) {
        unsigned char c = INBYTE1;
        Py_UCS4 decoded;

        if (c < 0x80) {
            OUTCHAR(c);
            NEXT_IN(1);
            continue;
        }

        REQUIRE_INBUF(2);

        if (TRYMAP_DEC(cp950ext, decoded, c, INBYTE2))
            OUTCHAR(decoded);
        else if (TRYMAP_DEC(big5, decoded, c, INBYTE2))
            OUTCHAR(decoded);
        else
            return 1;

        NEXT_IN(2);
    }

    return 0;
}



BEGIN_MAPPINGS_LIST(2)
  MAPPING_ENCDEC(big5)
  MAPPING_ENCDEC(cp950ext)
END_MAPPINGS_LIST

BEGIN_CODECS_LIST(2)
  CODEC_STATELESS(big5)
  CODEC_STATELESS(cp950)
END_CODECS_LIST

I_AM_A_MODULE_FOR(tw)


================================================
File: /Modules/cjkcodecs/alg_jisx0201.h
================================================
#define JISX0201_R_ENCODE(c, assi)                      \
    if ((c) < 0x80 && (c) != 0x5c && (c) != 0x7e) {     \
        (assi) = (c);                                   \
    }                                                   \
    else if ((c) == 0x00a5) {                           \
        (assi) = 0x5c;                                  \
    }                                                   \
    else if ((c) == 0x203e) {                           \
        (assi) = 0x7e;                                  \
    }

#define JISX0201_K_ENCODE(c, assi)                      \
    if ((c) >= 0xff61 && (c) <= 0xff9f) {               \
        (assi) = (c) - 0xfec0;                          \
    }

#define JISX0201_ENCODE(c, assi)                        \
    JISX0201_R_ENCODE(c, assi)                          \
    else JISX0201_K_ENCODE(c, assi)

#define JISX0201_R_DECODE_CHAR(c, assi)                 \
    if ((c) < 0x5c) {                                   \
        (assi) = (c);                                   \
    }                                                   \
    else if ((c) == 0x5c) {                             \
        (assi) = 0x00a5;                                \
    }                                                   \
    else if ((c) < 0x7e) {                              \
        (assi) = (c);                                   \
    }                                                   \
    else if ((c) == 0x7e) {                             \
        (assi) = 0x203e;                                \
    }                                                   \
    else if ((c) == 0x7f) {                             \
        (assi) = 0x7f;                                  \
    }

#define JISX0201_R_DECODE(c, writer)                    \
    if ((c) < 0x5c) {                                   \
        OUTCHAR(c);                                     \
    }                                                   \
    else if ((c) == 0x5c) {                             \
        OUTCHAR(0x00a5);                                \
    }                                                   \
    else if ((c) < 0x7e) {                              \
        OUTCHAR(c);                                     \
    }                                                   \
    else if ((c) == 0x7e) {                             \
        OUTCHAR(0x203e);                                \
    }                                                   \
    else if ((c) == 0x7f) {                             \
        OUTCHAR(0x7f);                                  \
    }

#define JISX0201_K_DECODE(c, writer)                    \
    if ((c) >= 0xa1 && (c) <= 0xdf) {                   \
        OUTCHAR(0xfec0 + (c));                          \
    }
#define JISX0201_K_DECODE_CHAR(c, assi)                 \
    if ((c) >= 0xa1 && (c) <= 0xdf) {                   \
        (assi) = 0xfec0 + (c);                          \
    }
#define JISX0201_DECODE(c, writer)                      \
    JISX0201_R_DECODE(c, writer)                        \
    else JISX0201_K_DECODE(c, writer)


================================================
File: /Modules/cjkcodecs/cjkcodecs.h
================================================
/*
 * cjkcodecs.h: common header for cjkcodecs
 *
 * Written by Hye-Shik Chang <perky@FreeBSD.org>
 */

#ifndef _CJKCODECS_H_
#define _CJKCODECS_H_

#ifndef Py_BUILD_CORE_BUILTIN
#  define Py_BUILD_CORE_MODULE 1
#endif

#include "Python.h"
#include "multibytecodec.h"
#include "pycore_import.h"        // _PyImport_GetModuleAttrString()


/* a unicode "undefined" code point */
#define UNIINV  0xFFFE

/* internal-use DBCS code points which aren't used by any charsets */
#define NOCHAR  0xFFFF
#define MULTIC  0xFFFE
#define DBCINV  0xFFFD

/* shorter macros to save source size of mapping tables */
#define U UNIINV
#define N NOCHAR
#define M MULTIC
#define D DBCINV

struct dbcs_index {
    const ucs2_t *map;
    unsigned char bottom, top;
};
typedef struct dbcs_index decode_map;

struct widedbcs_index {
    const Py_UCS4 *map;
    unsigned char bottom, top;
};
typedef struct widedbcs_index widedecode_map;

struct unim_index {
    const DBCHAR *map;
    unsigned char bottom, top;
};
typedef struct unim_index encode_map;

struct unim_index_bytebased {
    const unsigned char *map;
    unsigned char bottom, top;
};

struct dbcs_map {
    const char *charset;
    const struct unim_index *encmap;
    const struct dbcs_index *decmap;
};

struct pair_encodemap {
    Py_UCS4 uniseq;
    DBCHAR code;
};

#ifndef CJK_MOD_SPECIFIC_STATE
#define CJK_MOD_SPECIFIC_STATE
#endif

typedef struct _cjk_mod_state {
    int num_mappings;
    int num_codecs;
    struct dbcs_map *mapping_list;
    MultibyteCodec *codec_list;

    CJK_MOD_SPECIFIC_STATE
} cjkcodecs_module_state;

static inline cjkcodecs_module_state *
get_module_state(PyObject *mod)
{
    void *state = PyModule_GetState(mod);
    assert(state != NULL);
    return (cjkcodecs_module_state *)state;
}

#define CODEC_INIT(encoding)                                            \
    static int encoding##_codec_init(const MultibyteCodec *codec)

#define ENCODER_INIT(encoding)                                          \
    static int encoding##_encode_init(                                  \
        MultibyteCodec_State *state, const MultibyteCodec *codec)
#define ENCODER(encoding)                                               \
    static Py_ssize_t encoding##_encode(                                \
        MultibyteCodec_State *state, const MultibyteCodec *codec,       \
        int kind, const void *data,                                     \
        Py_ssize_t *inpos, Py_ssize_t inlen,                            \
        unsigned char **outbuf, Py_ssize_t outleft, int flags)
#define ENCODER_RESET(encoding)                                         \
    static Py_ssize_t encoding##_encode_reset(                          \
        MultibyteCodec_State *state, const MultibyteCodec *codec,       \
        unsigned char **outbuf, Py_ssize_t outleft)

#define DECODER_INIT(encoding)                                          \
    static int encoding##_decode_init(                                  \
        MultibyteCodec_State *state, const MultibyteCodec *codec)
#define DECODER(encoding)                                               \
    static Py_ssize_t encoding##_decode(                                \
        MultibyteCodec_State *state, const MultibyteCodec *codec,       \
        const unsigned char **inbuf, Py_ssize_t inleft,                 \
        _PyUnicodeWriter *writer)
#define DECODER_RESET(encoding)                                         \
    static Py_ssize_t encoding##_decode_reset(                          \
        MultibyteCodec_State *state, const MultibyteCodec *codec)

#define NEXT_IN(i)                              \
    do {                                        \
        (*inbuf) += (i);                        \
        (inleft) -= (i);                        \
    } while (0)
#define NEXT_INCHAR(i)                          \
    do {                                        \
        (*inpos) += (i);                        \
    } while (0)
#define NEXT_OUT(o)                             \
    do {                                        \
        (*outbuf) += (o);                       \
        (outleft) -= (o);                       \
    } while (0)
#define NEXT(i, o)                              \
    do {                                        \
        NEXT_INCHAR(i);                         \
        NEXT_OUT(o);                            \
    } while (0)

#define REQUIRE_INBUF(n)                        \
    do {                                        \
        if (inleft < (n))                       \
            return MBERR_TOOFEW;                \
    } while (0)

#define REQUIRE_OUTBUF(n)                       \
    do {                                        \
        if (outleft < (n))                      \
            return MBERR_TOOSMALL;              \
    } while (0)

#define INBYTE1 ((*inbuf)[0])
#define INBYTE2 ((*inbuf)[1])
#define INBYTE3 ((*inbuf)[2])
#define INBYTE4 ((*inbuf)[3])

#define INCHAR1 (PyUnicode_READ(kind, data, *inpos))
#define INCHAR2 (PyUnicode_READ(kind, data, *inpos + 1))

#define OUTCHAR(c)                                                         \
    do {                                                                   \
        if (_PyUnicodeWriter_WriteChar(writer, (c)) < 0)                   \
            return MBERR_EXCEPTION;                                         \
    } while (0)

#define OUTCHAR2(c1, c2)                                                   \
    do {                                                                   \
        Py_UCS4 _c1 = (c1);                                                \
        Py_UCS4 _c2 = (c2);                                                \
        if (_PyUnicodeWriter_Prepare(writer, 2, Py_MAX(_c1, c2)) < 0)      \
            return MBERR_EXCEPTION;                                        \
        PyUnicode_WRITE(writer->kind, writer->data, writer->pos, _c1);     \
        PyUnicode_WRITE(writer->kind, writer->data, writer->pos + 1, _c2); \
        writer->pos += 2;                                                  \
    } while (0)

#define OUTBYTEI(c, i)                     \
    do {                                   \
        assert((unsigned char)(c) == (c)); \
        ((*outbuf)[i]) = (c);              \
    } while (0)

#define OUTBYTE1(c) OUTBYTEI(c, 0)
#define OUTBYTE2(c) OUTBYTEI(c, 1)
#define OUTBYTE3(c) OUTBYTEI(c, 2)
#define OUTBYTE4(c) OUTBYTEI(c, 3)

#define WRITEBYTE1(c1)              \
    do {                            \
        REQUIRE_OUTBUF(1);          \
        OUTBYTE1(c1);               \
    } while (0)
#define WRITEBYTE2(c1, c2)          \
    do {                            \
        REQUIRE_OUTBUF(2);          \
        OUTBYTE1(c1);               \
        OUTBYTE2(c2);               \
    } while (0)
#define WRITEBYTE3(c1, c2, c3)      \
    do {                            \
        REQUIRE_OUTBUF(3);          \
        OUTBYTE1(c1);               \
        OUTBYTE2(c2);               \
        OUTBYTE3(c3);               \
    } while (0)
#define WRITEBYTE4(c1, c2, c3, c4)  \
    do {                            \
        REQUIRE_OUTBUF(4);          \
        OUTBYTE1(c1);               \
        OUTBYTE2(c2);               \
        OUTBYTE3(c3);               \
        OUTBYTE4(c4);               \
    } while (0)

#define _TRYMAP_ENC(m, assi, val)                               \
    ((m)->map != NULL && (val) >= (m)->bottom &&                \
        (val)<= (m)->top && ((assi) = (m)->map[(val) -          \
        (m)->bottom]) != NOCHAR)
#define TRYMAP_ENC(charset, assi, uni)                     \
    _TRYMAP_ENC(&charset##_encmap[(uni) >> 8], assi, (uni) & 0xff)
#define TRYMAP_ENC_ST(charset, assi, uni) \
    _TRYMAP_ENC(&(codec->modstate->charset##_encmap)[(uni) >> 8], \
                assi, (uni) & 0xff)

#define _TRYMAP_DEC(m, assi, val)                             \
    ((m)->map != NULL &&                                        \
     (val) >= (m)->bottom &&                                    \
     (val)<= (m)->top &&                                        \
     ((assi) = (m)->map[(val) - (m)->bottom]) != UNIINV)
#define TRYMAP_DEC(charset, assi, c1, c2)                     \
    _TRYMAP_DEC(&charset##_decmap[c1], assi, c2)
#define TRYMAP_DEC_ST(charset, assi, c1, c2) \
    _TRYMAP_DEC(&(codec->modstate->charset##_decmap)[c1], assi, c2)

#define BEGIN_MAPPINGS_LIST(NUM)                                    \
static int                                                          \
add_mappings(cjkcodecs_module_state *st)                            \
{                                                                   \
    int idx = 0;                                                    \
    (void)idx;                                                      \
    st->num_mappings = NUM;                                         \
    st->mapping_list = PyMem_Calloc(NUM, sizeof(struct dbcs_map));  \
    if (st->mapping_list == NULL) {                                 \
        return -1;                                                  \
    }

#define MAPPING_ENCONLY(enc) \
    st->mapping_list[idx++] = (struct dbcs_map){#enc, (void*)enc##_encmap, NULL};
#define MAPPING_DECONLY(enc) \
    st->mapping_list[idx++] = (struct dbcs_map){#enc, NULL, (void*)enc##_decmap};
#define MAPPING_ENCDEC(enc) \
    st->mapping_list[idx++] = (struct dbcs_map){#enc, (void*)enc##_encmap, (void*)enc##_decmap};

#define END_MAPPINGS_LIST               \
    assert(st->num_mappings == idx);    \
    return 0;                           \
}

#define BEGIN_CODECS_LIST(NUM)                                  \
static int                                                      \
add_codecs(cjkcodecs_module_state *st)                          \
{                                                               \
    int idx = 0;                                                \
    (void)idx;                                                  \
    st->num_codecs = NUM;                                       \
    st->codec_list = PyMem_Calloc(NUM, sizeof(MultibyteCodec)); \
    if (st->codec_list == NULL) {                               \
        return -1;                                              \
    }

#define _STATEFUL_METHODS(enc)          \
    enc##_encode,                       \
    enc##_encode_init,                  \
    enc##_encode_reset,                 \
    enc##_decode,                       \
    enc##_decode_init,                  \
    enc##_decode_reset,
#define _STATELESS_METHODS(enc)         \
    enc##_encode, NULL, NULL,           \
    enc##_decode, NULL, NULL,

#define NEXT_CODEC \
    st->codec_list[idx++]

#define CODEC_STATEFUL(enc) \
    NEXT_CODEC = (MultibyteCodec){#enc, NULL, NULL, _STATEFUL_METHODS(enc)};
#define CODEC_STATELESS(enc) \
    NEXT_CODEC = (MultibyteCodec){#enc, NULL, NULL, _STATELESS_METHODS(enc)};
#define CODEC_STATELESS_WINIT(enc) \
    NEXT_CODEC = (MultibyteCodec){#enc, NULL, enc##_codec_init, _STATELESS_METHODS(enc)};

#define END_CODECS_LIST                         \
    assert(st->num_codecs == idx);              \
    for (int i = 0; i < st->num_codecs; i++) {  \
        st->codec_list[i].modstate = st;        \
    }                                           \
    return 0;                                   \
}



static PyObject *
getmultibytecodec(void)
{
    return _PyImport_GetModuleAttrString("_multibytecodec", "__create_codec");
}

static void
destroy_codec_capsule(PyObject *capsule)
{
    void *ptr = PyCapsule_GetPointer(capsule, CODEC_CAPSULE);
    codec_capsule *data = (codec_capsule *)ptr;
    Py_DECREF(data->cjk_module);
    PyMem_Free(ptr);
}

static codec_capsule *
capsulate_codec(PyObject *mod, const MultibyteCodec *codec)
{
    codec_capsule *data = PyMem_Malloc(sizeof(codec_capsule));
    if (data == NULL) {
        PyErr_NoMemory();
        return NULL;
    }
    data->codec = codec;
    data->cjk_module = Py_NewRef(mod);
    return data;
}

static PyObject *
_getcodec(PyObject *self, const MultibyteCodec *codec)
{
    PyObject *cofunc = getmultibytecodec();
    if (cofunc == NULL) {
        return NULL;
    }

    codec_capsule *data = capsulate_codec(self, codec);
    if (data == NULL) {
        Py_DECREF(cofunc);
        return NULL;
    }
    PyObject *codecobj = PyCapsule_New(data, CODEC_CAPSULE,
                                       destroy_codec_capsule);
    if (codecobj == NULL) {
        PyMem_Free(data);
        Py_DECREF(cofunc);
        return NULL;
    }

    PyObject *res = PyObject_CallOneArg(cofunc, codecobj);
    Py_DECREF(codecobj);
    Py_DECREF(cofunc);
    return res;
}

static PyObject *
getcodec(PyObject *self, PyObject *encoding)
{
    if (!PyUnicode_Check(encoding)) {
        PyErr_SetString(PyExc_TypeError,
                        "encoding name must be a string.");
        return NULL;
    }
    const char *enc = PyUnicode_AsUTF8(encoding);
    if (enc == NULL) {
        return NULL;
    }

    cjkcodecs_module_state *st = get_module_state(self);
    for (int i = 0; i < st->num_codecs; i++) {
        const MultibyteCodec *codec = &st->codec_list[i];
        if (strcmp(codec->encoding, enc) == 0) {
            return _getcodec(self, codec);
        }
    }

    PyErr_SetString(PyExc_LookupError,
                    "no such codec is supported.");
    return NULL;
}

static int add_mappings(cjkcodecs_module_state *);
static int add_codecs(cjkcodecs_module_state *);

static int
register_maps(PyObject *module)
{
    // Init module state.
    cjkcodecs_module_state *st = get_module_state(module);
    if (add_mappings(st) < 0) {
        return -1;
    }
    if (add_codecs(st) < 0) {
        return -1;
    }

    for (int i = 0; i < st->num_mappings; i++) {
        const struct dbcs_map *h = &st->mapping_list[i];
        char mhname[256] = "__map_";
        strcpy(mhname + sizeof("__map_") - 1, h->charset);

        PyObject *capsule = PyCapsule_New((void *)h, MAP_CAPSULE, NULL);
        if (PyModule_Add(module, mhname, capsule) < 0) {
            return -1;
        }
    }
    return 0;
}

#ifdef USING_BINARY_PAIR_SEARCH
static DBCHAR
find_pairencmap(ucs2_t body, ucs2_t modifier,
                const struct pair_encodemap *haystack, int haystacksize)
{
    int pos, min, max;
    Py_UCS4 value = body << 16 | modifier;

    min = 0;
    max = haystacksize;

    for (pos = haystacksize >> 1; min != max; pos = (min + max) >> 1) {
        if (value < haystack[pos].uniseq) {
            if (max != pos) {
                max = pos;
                continue;
            }
        }
        else if (value > haystack[pos].uniseq) {
            if (min != pos) {
                min = pos;
                continue;
            }
        }
        break;
    }

    if (value == haystack[pos].uniseq) {
        return haystack[pos].code;
    }
    return DBCINV;
}
#endif

#ifdef USING_IMPORTED_MAPS
#define IMPORT_MAP(locale, charset, encmap, decmap) \
    importmap("_codecs_" #locale, "__map_" #charset, \
              (const void**)encmap, (const void**)decmap)

static int
importmap(const char *modname, const char *symbol,
          const void **encmap, const void **decmap)
{
    PyObject *o, *mod;

    mod = PyImport_ImportModule(modname);
    if (mod == NULL)
        return -1;

    o = PyObject_GetAttrString(mod, symbol);
    if (o == NULL)
        goto errorexit;
    else if (!PyCapsule_IsValid(o, MAP_CAPSULE)) {
        PyErr_SetString(PyExc_ValueError,
                        "map data must be a Capsule.");
        goto errorexit;
    }
    else {
        struct dbcs_map *map;
        map = PyCapsule_GetPointer(o, MAP_CAPSULE);
        if (encmap != NULL)
            *encmap = map->encmap;
        if (decmap != NULL)
            *decmap = map->decmap;
        Py_DECREF(o);
    }

    Py_DECREF(mod);
    return 0;

errorexit:
    Py_DECREF(mod);
    return -1;
}
#endif

static int
_cjk_exec(PyObject *module)
{
    return register_maps(module);
}

static void
_cjk_free(void *mod)
{
    cjkcodecs_module_state *st = get_module_state((PyObject *)mod);
    PyMem_Free(st->mapping_list);
    PyMem_Free(st->codec_list);
}

static struct PyMethodDef _cjk_methods[] = {
    {"getcodec", (PyCFunction)getcodec, METH_O, ""},
    {NULL, NULL},
};

static PyModuleDef_Slot _cjk_slots[] = {
    {Py_mod_exec, _cjk_exec},
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL}
};

#define I_AM_A_MODULE_FOR(loc)                                          \
    static struct PyModuleDef _cjk_module = {                           \
        PyModuleDef_HEAD_INIT,                                          \
        .m_name = "_codecs_"#loc,                                       \
        .m_size = sizeof(cjkcodecs_module_state),                       \
        .m_methods = _cjk_methods,                                      \
        .m_slots = _cjk_slots,                                          \
        .m_free = _cjk_free,                                            \
    };                                                                  \
                                                                        \
    PyMODINIT_FUNC                                                      \
    PyInit__codecs_##loc(void)                                          \
    {                                                                   \
        return PyModuleDef_Init(&_cjk_module);                          \
    }

#endif


================================================
File: /Modules/cjkcodecs/emu_jisx0213_2000.h
================================================
/* These routines may be quite inefficient, but it's used only to emulate old
 * standards. */

#ifndef EMULATE_JISX0213_2000_ENCODE_INVALID
#  define EMULATE_JISX0213_2000_ENCODE_INVALID 1
#endif

#define EMULATE_JISX0213_2000_ENCODE_BMP(config, assi, c)               \
    if ((config) == (void *)2000 && (                                   \
                    (c) == 0x9B1C || (c) == 0x4FF1 ||                   \
                    (c) == 0x525D || (c) == 0x541E ||                   \
                    (c) == 0x5653 || (c) == 0x59F8 ||                   \
                    (c) == 0x5C5B || (c) == 0x5E77 ||                   \
                    (c) == 0x7626 || (c) == 0x7E6B)) {                  \
        return EMULATE_JISX0213_2000_ENCODE_INVALID;                    \
    }                                                                   \
    else if ((config) == (void *)2000 && (c) == 0x9B1D) {               \
        (assi) = 0x8000 | 0x7d3b;                                       \
    }

#define EMULATE_JISX0213_2000_ENCODE_EMP(config, assi, c)               \
    if ((config) == (void *)2000 && (c) == 0x20B9F) {                   \
        return EMULATE_JISX0213_2000_ENCODE_INVALID;                    \
    }

#ifndef EMULATE_JISX0213_2000_DECODE_INVALID
#  define EMULATE_JISX0213_2000_DECODE_INVALID 2
#endif

#define EMULATE_JISX0213_2000_DECODE_PLANE1(config, assi, c1, c2)       \
    if ((config) == (void *)2000 &&                                     \
                    (((c1) == 0x2E && (c2) == 0x21) ||                  \
                     ((c1) == 0x2F && (c2) == 0x7E) ||                  \
                     ((c1) == 0x4F && (c2) == 0x54) ||                  \
                     ((c1) == 0x4F && (c2) == 0x7E) ||                  \
                     ((c1) == 0x74 && (c2) == 0x27) ||                  \
                     ((c1) == 0x7E && (c2) == 0x7A) ||                  \
                     ((c1) == 0x7E && (c2) == 0x7B) ||                  \
                     ((c1) == 0x7E && (c2) == 0x7C) ||                  \
                     ((c1) == 0x7E && (c2) == 0x7D) ||                  \
                     ((c1) == 0x7E && (c2) == 0x7E))) {                 \
        return EMULATE_JISX0213_2000_DECODE_INVALID;                    \
    }

#define EMULATE_JISX0213_2000_DECODE_PLANE2(config, writer, c1, c2)     \
    if ((config) == (void *)2000 && (c1) == 0x7D && (c2) == 0x3B) {     \
        OUTCHAR(0x9B1D);                                                \
    }

#define EMULATE_JISX0213_2000_DECODE_PLANE2_CHAR(config, assi, c1, c2)  \
    if ((config) == (void *)2000 && (c1) == 0x7D && (c2) == 0x3B) {     \
        (assi) = 0x9B1D;                                                \
    }



================================================
File: /Modules/cjkcodecs/mappings_jisx0213_pair.h
================================================
// AUTO-GENERATED FILE FROM genmap_japanese.py: DO NOT EDIT
#define JISX0213_ENCPAIRS 46
#ifdef EXTERN_JISX0213_PAIR
static const struct widedbcs_index *jisx0213_pair_decmap;
static const struct pair_encodemap *jisx0213_pair_encmap;
#else
static const Py_UCS4 __jisx0213_pair_decmap[49] = {
810234010,810365082,810496154,810627226,810758298,816525466,816656538,
816787610,816918682,817049754,817574042,818163866,818426010,838283418,
15074048,U,U,U,39060224,39060225,42730240,42730241,39387904,39387905,39453440,
39453441,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,48825061,48562921,
};

static const struct widedbcs_index jisx0213_pair_decmap[256] = {
{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0
},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,
0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{
0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{__jisx0213_pair_decmap
+0,119,123},{__jisx0213_pair_decmap+5,119,126},{__jisx0213_pair_decmap+13,120,
120},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{__jisx0213_pair_decmap+14,68,102},{0,0,0
},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,
0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{
0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0
},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,
0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{
0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0
},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,
0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{
0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0
},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,
0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{
0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0
},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,
0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{
0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0
},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,
0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{
0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0
},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,
0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{
0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0
},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},{0,0,0},
};

static const struct pair_encodemap jisx0213_pair_encmap[JISX0213_ENCPAIRS] = {
{0x00e60000,0x295c},{0x00e60300,0x2b44},{0x02540000,0x2b38},{0x02540300,0x2b48
},{0x02540301,0x2b49},{0x02590000,0x2b30},{0x02590300,0x2b4c},{0x02590301,
0x2b4d},{0x025a0000,0x2b43},{0x025a0300,0x2b4e},{0x025a0301,0x2b4f},{
0x028c0000,0x2b37},{0x028c0300,0x2b4a},{0x028c0301,0x2b4b},{0x02e50000,0x2b60
},{0x02e502e9,0x2b66},{0x02e90000,0x2b64},{0x02e902e5,0x2b65},{0x304b0000,
0x242b},{0x304b309a,0x2477},{0x304d0000,0x242d},{0x304d309a,0x2478},{
0x304f0000,0x242f},{0x304f309a,0x2479},{0x30510000,0x2431},{0x3051309a,0x247a
},{0x30530000,0x2433},{0x3053309a,0x247b},{0x30ab0000,0x252b},{0x30ab309a,
0x2577},{0x30ad0000,0x252d},{0x30ad309a,0x2578},{0x30af0000,0x252f},{
0x30af309a,0x2579},{0x30b10000,0x2531},{0x30b1309a,0x257a},{0x30b30000,0x2533
},{0x30b3309a,0x257b},{0x30bb0000,0x253b},{0x30bb309a,0x257c},{0x30c40000,
0x2544},{0x30c4309a,0x257d},{0x30c80000,0x2548},{0x30c8309a,0x257e},{
0x31f70000,0x2675},{0x31f7309a,0x2678},
};
#endif


================================================
File: /Modules/cjkcodecs/multibytecodec.h
================================================
/*
 * multibytecodec.h: Common Multibyte Codec Implementation
 *
 * Written by Hye-Shik Chang <perky@FreeBSD.org>
 */

#ifndef _PYTHON_MULTIBYTECODEC_H_
#define _PYTHON_MULTIBYTECODEC_H_
#ifdef __cplusplus
extern "C" {
#endif

#include "pycore_unicodeobject.h" // _PyUnicodeWriter

#ifdef uint16_t
typedef uint16_t ucs2_t, DBCHAR;
#else
typedef unsigned short ucs2_t, DBCHAR;
#endif

/*
 * A struct that provides 8 bytes of state for multibyte
 * codecs. Codecs are free to use this how they want. Note: if you
 * need to add a new field to this struct, ensure that its byte order
 * is independent of CPU endianness so that the return value of
 * getstate doesn't differ between little and big endian CPUs.
 */
typedef struct {
    unsigned char c[8];
} MultibyteCodec_State;

struct _cjk_mod_state;
struct _multibyte_codec;

typedef int (*mbcodec_init)(const struct _multibyte_codec *codec);
typedef Py_ssize_t (*mbencode_func)(MultibyteCodec_State *state,
                        const struct _multibyte_codec *codec,
                        int kind, const void *data,
                        Py_ssize_t *inpos, Py_ssize_t inlen,
                        unsigned char **outbuf, Py_ssize_t outleft,
                        int flags);
typedef int (*mbencodeinit_func)(MultibyteCodec_State *state,
                                 const struct _multibyte_codec *codec);
typedef Py_ssize_t (*mbencodereset_func)(MultibyteCodec_State *state,
                        const struct _multibyte_codec *codec,
                        unsigned char **outbuf, Py_ssize_t outleft);
typedef Py_ssize_t (*mbdecode_func)(MultibyteCodec_State *state,
                        const struct _multibyte_codec *codec,
                        const unsigned char **inbuf, Py_ssize_t inleft,
                        _PyUnicodeWriter *writer);
typedef int (*mbdecodeinit_func)(MultibyteCodec_State *state,
                                 const struct _multibyte_codec *codec);
typedef Py_ssize_t (*mbdecodereset_func)(MultibyteCodec_State *state,
                                         const struct _multibyte_codec *codec);

typedef struct _multibyte_codec {
    const char *encoding;
    const void *config;
    mbcodec_init codecinit;
    mbencode_func encode;
    mbencodeinit_func encinit;
    mbencodereset_func encreset;
    mbdecode_func decode;
    mbdecodeinit_func decinit;
    mbdecodereset_func decreset;
    struct _cjk_mod_state *modstate;
} MultibyteCodec;

typedef struct {
    PyObject_HEAD
    const MultibyteCodec *codec;
    PyObject *cjk_module;
} MultibyteCodecObject;

#define MultibyteCodec_Check(state, op) Py_IS_TYPE((op), state->multibytecodec_type)

#define _MultibyteStatefulCodec_HEAD            \
    PyObject_HEAD                               \
    const MultibyteCodec *codec;                \
    MultibyteCodec_State state;                 \
    PyObject *errors;
typedef struct {
    _MultibyteStatefulCodec_HEAD
} MultibyteStatefulCodecContext;

#define MAXENCPENDING   2
#define _MultibyteStatefulEncoder_HEAD          \
    _MultibyteStatefulCodec_HEAD                \
    PyObject *pending;
typedef struct {
    _MultibyteStatefulEncoder_HEAD
} MultibyteStatefulEncoderContext;

#define MAXDECPENDING   8
#define _MultibyteStatefulDecoder_HEAD          \
    _MultibyteStatefulCodec_HEAD                \
    unsigned char pending[MAXDECPENDING];       \
    Py_ssize_t pendingsize;
typedef struct {
    _MultibyteStatefulDecoder_HEAD
} MultibyteStatefulDecoderContext;

typedef struct {
    _MultibyteStatefulEncoder_HEAD
} MultibyteIncrementalEncoderObject;

typedef struct {
    _MultibyteStatefulDecoder_HEAD
} MultibyteIncrementalDecoderObject;

typedef struct {
    _MultibyteStatefulDecoder_HEAD
    PyObject *stream;
} MultibyteStreamReaderObject;

typedef struct {
    _MultibyteStatefulEncoder_HEAD
    PyObject *stream;
} MultibyteStreamWriterObject;

/* positive values for illegal sequences */
#define MBERR_TOOSMALL          (-1) /* insufficient output buffer space */
#define MBERR_TOOFEW            (-2) /* incomplete input buffer */
#define MBERR_INTERNAL          (-3) /* internal runtime error */
#define MBERR_EXCEPTION         (-4) /* an exception has been raised */

#define ERROR_STRICT            (PyObject *)(1)
#define ERROR_IGNORE            (PyObject *)(2)
#define ERROR_REPLACE           (PyObject *)(3)
#define ERROR_ISCUSTOM(p)       ((p) < ERROR_STRICT || ERROR_REPLACE < (p))
#define ERROR_DECREF(p)                             \
    do {                                            \
        if (p != NULL && ERROR_ISCUSTOM(p))         \
            Py_DECREF(p);                           \
    } while (0);

#define MBENC_FLUSH             0x0001 /* encode all characters encodable */
#define MBENC_MAX               MBENC_FLUSH

typedef struct {
    const MultibyteCodec *codec;
    PyObject *cjk_module;
} codec_capsule;

#define MAP_CAPSULE "multibytecodec.map"
#define CODEC_CAPSULE "multibytecodec.codec"


#ifdef __cplusplus
}
#endif
#endif


================================================
File: /Modules/cjkcodecs/clinic/multibytecodec.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

#if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
#  include "pycore_gc.h"          // PyGC_Head
#  include "pycore_runtime.h"     // _Py_ID()
#endif
#include "pycore_modsupport.h"    // _PyArg_UnpackKeywords()

PyDoc_STRVAR(_multibytecodec_MultibyteCodec_encode__doc__,
"encode($self, /, input, errors=None)\n"
"--\n"
"\n"
"Return an encoded string version of \'input\'.\n"
"\n"
"\'errors\' may be given to set a different error handling scheme. Default is\n"
"\'strict\' meaning that encoding errors raise a UnicodeEncodeError. Other possible\n"
"values are \'ignore\', \'replace\' and \'xmlcharrefreplace\' as well as any other name\n"
"registered with codecs.register_error that can handle UnicodeEncodeErrors.");

#define _MULTIBYTECODEC_MULTIBYTECODEC_ENCODE_METHODDEF    \
    {"encode", _PyCFunction_CAST(_multibytecodec_MultibyteCodec_encode), METH_FASTCALL|METH_KEYWORDS, _multibytecodec_MultibyteCodec_encode__doc__},

static PyObject *
_multibytecodec_MultibyteCodec_encode_impl(MultibyteCodecObject *self,
                                           PyObject *input,
                                           const char *errors);

static PyObject *
_multibytecodec_MultibyteCodec_encode(MultibyteCodecObject *self, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 2
