    PyObject *name = Py_GetConstant(Py_CONSTANT_EMPTY_STR);
    if (offset == NULL || name == NULL) {
        Py_XDECREF(offset);
        Py_XDECREF(name);
        return NULL;
    }

    // These two should return the UTC singleton
    PyObject *utc_singleton_0 = PyTimeZone_FromOffset(offset);
    PyObject *utc_singleton_1 = PyTimeZone_FromOffsetAndName(offset, NULL);

    // This one will return +00:00 zone, but not the UTC singleton
    PyObject *non_utc_zone = PyTimeZone_FromOffsetAndName(offset, name);
    Py_DECREF(offset);
    Py_DECREF(name);
    if (utc_singleton_0 == NULL || utc_singleton_1 == NULL ||
        non_utc_zone == NULL)
    {
        goto error;
    }

    PyObject *rv = PyTuple_New(3);
    if (rv == NULL) {
        goto error;
    }
    PyTuple_SET_ITEM(rv, 0, utc_singleton_0);
    PyTuple_SET_ITEM(rv, 1, utc_singleton_1);
    PyTuple_SET_ITEM(rv, 2, non_utc_zone);

    return rv;
error:
    Py_XDECREF(utc_singleton_0);
    Py_XDECREF(utc_singleton_1);
    Py_XDECREF(non_utc_zone);
    return NULL;
}

static PyObject *
get_timezone_utc_capi(PyObject *self, PyObject *args)
{
    int macro = 0;
    if (!PyArg_ParseTuple(args, "|p", &macro)) {
        return NULL;
    }
    if (macro) {
        return Py_NewRef(PyDateTime_TimeZone_UTC);
    }
    return Py_NewRef(PyDateTimeAPI->TimeZone_UTC);
}

static PyObject *
get_date_fromdate(PyObject *self, PyObject *args)
{
    PyObject *rv = NULL;
    int macro;
    int year, month, day;

    if (!PyArg_ParseTuple(args, "piii", &macro, &year, &month, &day)) {
        return NULL;
    }

    if (macro) {
        rv = PyDate_FromDate(year, month, day);
    }
    else {
        rv = PyDateTimeAPI->Date_FromDate(
                year, month, day,
                PyDateTimeAPI->DateType);
    }
    return rv;
}

static PyObject *
get_datetime_fromdateandtime(PyObject *self, PyObject *args)
{
    PyObject *rv = NULL;
    int macro;
    int year, month, day;
    int hour, minute, second, microsecond;

    if (!PyArg_ParseTuple(args, "piiiiiii",
                          &macro,
                          &year, &month, &day,
                          &hour, &minute, &second, &microsecond)) {
        return NULL;
    }

    if (macro) {
        rv = PyDateTime_FromDateAndTime(
                year, month, day,
                hour, minute, second, microsecond);
    }
    else {
        rv = PyDateTimeAPI->DateTime_FromDateAndTime(
                year, month, day,
                hour, minute, second, microsecond,
                Py_None,
                PyDateTimeAPI->DateTimeType);
    }
    return rv;
}

static PyObject *
get_datetime_fromdateandtimeandfold(PyObject *self, PyObject *args)
{
    PyObject *rv = NULL;
    int macro;
    int year, month, day;
    int hour, minute, second, microsecond, fold;

    if (!PyArg_ParseTuple(args, "piiiiiiii",
                          &macro,
                          &year, &month, &day,
                          &hour, &minute, &second, &microsecond,
                          &fold)) {
        return NULL;
    }

    if (macro) {
        rv = PyDateTime_FromDateAndTimeAndFold(
                year, month, day,
                hour, minute, second, microsecond,
                fold);
    }
    else {
        rv = PyDateTimeAPI->DateTime_FromDateAndTimeAndFold(
                year, month, day,
                hour, minute, second, microsecond,
                Py_None,
                fold,
                PyDateTimeAPI->DateTimeType);
    }
    return rv;
}

static PyObject *
get_time_fromtime(PyObject *self, PyObject *args)
{
    PyObject *rv = NULL;
    int macro;
    int hour, minute, second, microsecond;

    if (!PyArg_ParseTuple(args, "piiii",
                          &macro,
                          &hour, &minute, &second, &microsecond))
    {
        return NULL;
    }

    if (macro) {
        rv = PyTime_FromTime(hour, minute, second, microsecond);
    }
    else {
        rv = PyDateTimeAPI->Time_FromTime(
                hour, minute, second, microsecond,
                Py_None,
                PyDateTimeAPI->TimeType);
    }
    return rv;
}

static PyObject *
get_time_fromtimeandfold(PyObject *self, PyObject *args)
{
    PyObject *rv = NULL;
    int macro;
    int hour, minute, second, microsecond, fold;

    if (!PyArg_ParseTuple(args, "piiiii",
                          &macro,
                          &hour, &minute, &second, &microsecond,
                          &fold)) {
        return NULL;
    }

    if (macro) {
        rv = PyTime_FromTimeAndFold(hour, minute, second, microsecond, fold);
    }
    else {
        rv = PyDateTimeAPI->Time_FromTimeAndFold(
                hour, minute, second, microsecond,
                Py_None,
                fold,
                PyDateTimeAPI->TimeType);
    }
    return rv;
}

static PyObject *
get_delta_fromdsu(PyObject *self, PyObject *args)
{
    PyObject *rv = NULL;
    int macro;
    int days, seconds, microseconds;

    if (!PyArg_ParseTuple(args, "piii",
                          &macro,
                          &days, &seconds, &microseconds)) {
        return NULL;
    }

    if (macro) {
        rv = PyDelta_FromDSU(days, seconds, microseconds);
    }
    else {
        rv = PyDateTimeAPI->Delta_FromDelta(
                days, seconds, microseconds, 1,
                PyDateTimeAPI->DeltaType);
    }

    return rv;
}

static PyObject *
get_date_fromtimestamp(PyObject *self, PyObject *args)
{
    PyObject *tsargs = NULL, *ts = NULL, *rv = NULL;
    int macro = 0;

    if (!PyArg_ParseTuple(args, "O|p", &ts, &macro)) {
        return NULL;
    }

    // Construct the argument tuple
    if ((tsargs = PyTuple_Pack(1, ts)) == NULL) {
        return NULL;
    }

    // Pass along to the API function
    if (macro) {
        rv = PyDate_FromTimestamp(tsargs);
    }
    else {
        rv = PyDateTimeAPI->Date_FromTimestamp(
                (PyObject *)PyDateTimeAPI->DateType, tsargs
        );
    }

    Py_DECREF(tsargs);
    return rv;
}

static PyObject *
get_datetime_fromtimestamp(PyObject *self, PyObject *args)
{
    int macro = 0;
    int usetz = 0;
    PyObject *tsargs = NULL, *ts = NULL, *tzinfo = Py_None, *rv = NULL;
    if (!PyArg_ParseTuple(args, "OO|pp", &ts, &tzinfo, &usetz, &macro)) {
        return NULL;
    }

    // Construct the argument tuple
    if (usetz) {
        tsargs = PyTuple_Pack(2, ts, tzinfo);
    }
    else {
        tsargs = PyTuple_Pack(1, ts);
    }

    if (tsargs == NULL) {
        return NULL;
    }

    // Pass along to the API function
    if (macro) {
        rv = PyDateTime_FromTimestamp(tsargs);
    }
    else {
        rv = PyDateTimeAPI->DateTime_FromTimestamp(
                (PyObject *)PyDateTimeAPI->DateTimeType, tsargs, NULL
        );
    }

    Py_DECREF(tsargs);
    return rv;
}

static PyObject *
test_PyDateTime_GET(PyObject *self, PyObject *obj)
{
    int year, month, day;

    year = PyDateTime_GET_YEAR(obj);
    month = PyDateTime_GET_MONTH(obj);
    day = PyDateTime_GET_DAY(obj);

    return Py_BuildValue("(iii)", year, month, day);
}

static PyObject *
test_PyDateTime_DATE_GET(PyObject *self, PyObject *obj)
{
    int hour = PyDateTime_DATE_GET_HOUR(obj);
    int minute = PyDateTime_DATE_GET_MINUTE(obj);
    int second = PyDateTime_DATE_GET_SECOND(obj);
    int microsecond = PyDateTime_DATE_GET_MICROSECOND(obj);
    PyObject *tzinfo = PyDateTime_DATE_GET_TZINFO(obj);

    return Py_BuildValue("(iiiiO)", hour, minute, second, microsecond, tzinfo);
}

static PyObject *
test_PyDateTime_TIME_GET(PyObject *self, PyObject *obj)
{
    int hour = PyDateTime_TIME_GET_HOUR(obj);
    int minute = PyDateTime_TIME_GET_MINUTE(obj);
    int second = PyDateTime_TIME_GET_SECOND(obj);
    int microsecond = PyDateTime_TIME_GET_MICROSECOND(obj);
    PyObject *tzinfo = PyDateTime_TIME_GET_TZINFO(obj);

    return Py_BuildValue("(iiiiO)", hour, minute, second, microsecond, tzinfo);
}

static PyObject *
test_PyDateTime_DELTA_GET(PyObject *self, PyObject *obj)
{
    int days = PyDateTime_DELTA_GET_DAYS(obj);
    int seconds = PyDateTime_DELTA_GET_SECONDS(obj);
    int microseconds = PyDateTime_DELTA_GET_MICROSECONDS(obj);

    return Py_BuildValue("(iii)", days, seconds, microseconds);
}

static PyMethodDef test_methods[] = {
    {"PyDateTime_DATE_GET",         test_PyDateTime_DATE_GET,       METH_O},
    {"PyDateTime_DELTA_GET",        test_PyDateTime_DELTA_GET,      METH_O},
    {"PyDateTime_GET",              test_PyDateTime_GET,            METH_O},
    {"PyDateTime_TIME_GET",         test_PyDateTime_TIME_GET,       METH_O},
    {"datetime_check_date",         datetime_check_date,            METH_VARARGS},
    {"datetime_check_datetime",     datetime_check_datetime,        METH_VARARGS},
    {"datetime_check_delta",        datetime_check_delta,           METH_VARARGS},
    {"datetime_check_time",         datetime_check_time,            METH_VARARGS},
    {"datetime_check_tzinfo",       datetime_check_tzinfo,          METH_VARARGS},
    {"get_date_fromdate",           get_date_fromdate,              METH_VARARGS},
    {"get_date_fromtimestamp",      get_date_fromtimestamp,         METH_VARARGS},
    {"get_datetime_fromdateandtime", get_datetime_fromdateandtime,  METH_VARARGS},
    {"get_datetime_fromdateandtimeandfold", get_datetime_fromdateandtimeandfold, METH_VARARGS},
    {"get_datetime_fromtimestamp",  get_datetime_fromtimestamp,     METH_VARARGS},
    {"get_delta_fromdsu",           get_delta_fromdsu,              METH_VARARGS},
    {"get_time_fromtime",           get_time_fromtime,              METH_VARARGS},
    {"get_time_fromtimeandfold",    get_time_fromtimeandfold,       METH_VARARGS},
    {"get_timezone_utc_capi",       get_timezone_utc_capi,          METH_VARARGS},
    {"get_timezones_offset_zero",   get_timezones_offset_zero,      METH_NOARGS},
    {"make_timezones_capi",         make_timezones_capi,            METH_NOARGS},
    {"test_datetime_capi",          test_datetime_capi,             METH_NOARGS},
    {NULL},
};

int
_PyTestCapi_Init_DateTime(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }
    return 0;
}


/* ---------------------------------------------------------------------------
 * Test module for subinterpreters.
 */

static int
_testcapi_datetime_exec(PyObject *mod)
{
    if (test_datetime_capi(NULL, NULL) == NULL)  {
        return -1;
    }
    return 0;
}

static PyModuleDef_Slot _testcapi_datetime_slots[] = {
    {Py_mod_exec, _testcapi_datetime_exec},
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL},
};

static struct PyModuleDef _testcapi_datetime_module = {
    PyModuleDef_HEAD_INIT,
    .m_name = "_testcapi_datetime",
    .m_size = 0,
    .m_methods = test_methods,
    .m_slots = _testcapi_datetime_slots,
};

PyMODINIT_FUNC
PyInit__testcapi_datetime(void)
{
    return PyModuleDef_Init(&_testcapi_datetime_module);
}


================================================
File: /Modules/_testcapi/dict.c
================================================
#include "parts.h"
#include "util.h"

static PyObject *
dict_containsstring(PyObject *self, PyObject *args)
{
    PyObject *obj;
    const char *key;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#", &obj, &key, &size)) {
        return NULL;
    }
    NULLABLE(obj);
    RETURN_INT(PyDict_ContainsString(obj, key));
}

static PyObject *
dict_getitemref(PyObject *self, PyObject *args)
{
    PyObject *obj, *attr_name, *value = UNINITIALIZED_PTR;
    if (!PyArg_ParseTuple(args, "OO", &obj, &attr_name)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(attr_name);

    switch (PyDict_GetItemRef(obj, attr_name, &value)) {
        case -1:
            assert(value == NULL);
            return NULL;
        case 0:
            assert(value == NULL);
            return Py_NewRef(PyExc_KeyError);
        case 1:
            return value;
        default:
            Py_FatalError("PyMapping_GetItemRef() returned invalid code");
            Py_UNREACHABLE();
    }
}

static PyObject *
dict_getitemstringref(PyObject *self, PyObject *args)
{
    PyObject *obj, *value = UNINITIALIZED_PTR;
    const char *attr_name;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#", &obj, &attr_name, &size)) {
        return NULL;
    }
    NULLABLE(obj);

    switch (PyDict_GetItemStringRef(obj, attr_name, &value)) {
        case -1:
            assert(value == NULL);
            return NULL;
        case 0:
            assert(value == NULL);
            return Py_NewRef(PyExc_KeyError);
        case 1:
            return value;
        default:
            Py_FatalError("PyDict_GetItemStringRef() returned invalid code");
            Py_UNREACHABLE();
    }
}

static PyObject *
dict_setdefault(PyObject *self, PyObject *args)
{
    PyObject *mapping, *key, *defaultobj;
    if (!PyArg_ParseTuple(args, "OOO", &mapping, &key, &defaultobj)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(key);
    NULLABLE(defaultobj);
    return PyDict_SetDefault(mapping, key, defaultobj);
}

static PyObject *
dict_setdefaultref(PyObject *self, PyObject *args)
{
    PyObject *obj, *key, *default_value, *result = UNINITIALIZED_PTR;
    if (!PyArg_ParseTuple(args, "OOO", &obj, &key, &default_value)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(key);
    NULLABLE(default_value);
    switch (PyDict_SetDefaultRef(obj, key, default_value, &result)) {
        case -1:
            assert(result == NULL);
            return NULL;
        case 0:
            assert(result == default_value);
            return result;
        case 1:
            return result;
        default:
            Py_FatalError("PyDict_SetDefaultRef() returned invalid code");
            Py_UNREACHABLE();
    }
}

static PyObject *
dict_pop(PyObject *self, PyObject *args)
{
    // Test PyDict_Pop(dict, key, &value)
    PyObject *dict, *key;
    if (!PyArg_ParseTuple(args, "OO", &dict, &key)) {
        return NULL;
    }
    NULLABLE(dict);
    NULLABLE(key);
    PyObject *result = UNINITIALIZED_PTR;
    int res = PyDict_Pop(dict, key,  &result);
    if (res < 0) {
        assert(result == NULL);
        return NULL;
    }
    if (res == 0) {
        assert(result == NULL);
        result = Py_NewRef(Py_None);
    }
    else {
        assert(result != NULL);
    }
    return Py_BuildValue("iN", res, result);
}

static PyObject *
dict_pop_null(PyObject *self, PyObject *args)
{
    // Test PyDict_Pop(dict, key, NULL)
    PyObject *dict, *key;
    if (!PyArg_ParseTuple(args, "OO", &dict, &key)) {
        return NULL;
    }
    NULLABLE(dict);
    NULLABLE(key);
    RETURN_INT(PyDict_Pop(dict, key,  NULL));
}

static PyObject *
dict_popstring(PyObject *self, PyObject *args)
{
    PyObject *dict;
    const char *key;
    Py_ssize_t key_size;
    if (!PyArg_ParseTuple(args, "Oz#", &dict, &key, &key_size)) {
        return NULL;
    }
    NULLABLE(dict);
    PyObject *result = UNINITIALIZED_PTR;
    int res = PyDict_PopString(dict, key,  &result);
    if (res < 0) {
        assert(result == NULL);
        return NULL;
    }
    if (res == 0) {
        assert(result == NULL);
        result = Py_NewRef(Py_None);
    }
    else {
        assert(result != NULL);
    }
    return Py_BuildValue("iN", res, result);
}

static PyObject *
dict_popstring_null(PyObject *self, PyObject *args)
{
    PyObject *dict;
    const char *key;
    Py_ssize_t key_size;
    if (!PyArg_ParseTuple(args, "Oz#", &dict, &key, &key_size)) {
        return NULL;
    }
    NULLABLE(dict);
    RETURN_INT(PyDict_PopString(dict, key,  NULL));
}

static PyMethodDef test_methods[] = {
    {"dict_containsstring", dict_containsstring, METH_VARARGS},
    {"dict_getitemref", dict_getitemref, METH_VARARGS},
    {"dict_getitemstringref", dict_getitemstringref, METH_VARARGS},
    {"dict_setdefault", dict_setdefault, METH_VARARGS},
    {"dict_setdefaultref", dict_setdefaultref, METH_VARARGS},
    {"dict_pop", dict_pop, METH_VARARGS},
    {"dict_pop_null", dict_pop_null, METH_VARARGS},
    {"dict_popstring", dict_popstring, METH_VARARGS},
    {"dict_popstring_null", dict_popstring_null, METH_VARARGS},
    {NULL},
};

int
_PyTestCapi_Init_Dict(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/docstring.c
================================================
#include "parts.h"


PyDoc_STRVAR(docstring_empty,
""
);

PyDoc_STRVAR(docstring_no_signature,
"This docstring has no signature."
);

PyDoc_STRVAR(docstring_with_invalid_signature,
"docstring_with_invalid_signature($module, /, boo)\n"
"\n"
"This docstring has an invalid signature."
);

PyDoc_STRVAR(docstring_with_invalid_signature2,
"docstring_with_invalid_signature2($module, /, boo)\n"
"\n"
"--\n"
"\n"
"This docstring also has an invalid signature."
);

PyDoc_STRVAR(docstring_with_signature,
"docstring_with_signature($module, /, sig)\n"
"--\n"
"\n"
"This docstring has a valid signature."
);

PyDoc_STRVAR(docstring_with_signature_but_no_doc,
"docstring_with_signature_but_no_doc($module, /, sig)\n"
"--\n"
"\n"
);

PyDoc_STRVAR(docstring_with_signature_and_extra_newlines,
"docstring_with_signature_and_extra_newlines($module, /, parameter)\n"
"--\n"
"\n"
"\n"
"This docstring has a valid signature and some extra newlines."
);

PyDoc_STRVAR(docstring_with_signature_with_defaults,
"docstring_with_signature_with_defaults(module, s='avocado',\n"
"        b=b'bytes', d=3.14, i=35, n=None, t=True, f=False,\n"
"        local=the_number_three, sys=sys.maxsize,\n"
"        exp=sys.maxsize - 1)\n"
"--\n"
"\n"
"\n"
"\n"
"This docstring has a valid signature with parameters,\n"
"and the parameters take defaults of varying types."
);

/* This is here to provide a docstring for test_descr. */
static PyObject *
test_with_docstring(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    Py_RETURN_NONE;
}

static PyMethodDef test_methods[] = {
    {"docstring_empty",
        (PyCFunction)test_with_docstring, METH_VARARGS,
        docstring_empty},
    {"docstring_no_signature",
        (PyCFunction)test_with_docstring, METH_VARARGS,
        docstring_no_signature},
    {"docstring_no_signature_noargs",
        (PyCFunction)test_with_docstring, METH_NOARGS,
        docstring_no_signature},
    {"docstring_no_signature_o",
        (PyCFunction)test_with_docstring, METH_O,
        docstring_no_signature},
    {"docstring_with_invalid_signature",
        (PyCFunction)test_with_docstring, METH_VARARGS,
        docstring_with_invalid_signature},
    {"docstring_with_invalid_signature2",
        (PyCFunction)test_with_docstring, METH_VARARGS,
        docstring_with_invalid_signature2},
    {"docstring_with_signature",
        (PyCFunction)test_with_docstring, METH_VARARGS,
        docstring_with_signature},
    {"docstring_with_signature_and_extra_newlines",
        (PyCFunction)test_with_docstring, METH_VARARGS,
        docstring_with_signature_and_extra_newlines},
    {"docstring_with_signature_but_no_doc",
        (PyCFunction)test_with_docstring, METH_VARARGS,
        docstring_with_signature_but_no_doc},
    {"docstring_with_signature_with_defaults",
        (PyCFunction)test_with_docstring, METH_VARARGS,
        docstring_with_signature_with_defaults},
    {"no_docstring",
        (PyCFunction)test_with_docstring, METH_VARARGS},
    {"test_with_docstring",
        test_with_docstring,              METH_VARARGS,
        PyDoc_STR("This is a pretty normal docstring.")},
    {"func_with_unrepresentable_signature",
        (PyCFunction)test_with_docstring, METH_VARARGS,
        PyDoc_STR(
            "func_with_unrepresentable_signature($module, /, a, b=<x>)\n"
            "--\n\n"
            "This docstring has a signature with unrepresentable default."
        )},
    {NULL},
};

static PyMethodDef DocStringNoSignatureTest_methods[] = {
    {"meth_noargs",
        (PyCFunction)test_with_docstring, METH_NOARGS,
        docstring_no_signature},
    {"meth_o",
        (PyCFunction)test_with_docstring, METH_O,
        docstring_no_signature},
    {"meth_noargs_class",
        (PyCFunction)test_with_docstring, METH_NOARGS|METH_CLASS,
        docstring_no_signature},
    {"meth_o_class",
        (PyCFunction)test_with_docstring, METH_O|METH_CLASS,
        docstring_no_signature},
    {"meth_noargs_static",
        (PyCFunction)test_with_docstring, METH_NOARGS|METH_STATIC,
        docstring_no_signature},
    {"meth_o_static",
        (PyCFunction)test_with_docstring, METH_O|METH_STATIC,
        docstring_no_signature},
    {"meth_noargs_coexist",
        (PyCFunction)test_with_docstring, METH_NOARGS|METH_COEXIST,
        docstring_no_signature},
    {"meth_o_coexist",
        (PyCFunction)test_with_docstring, METH_O|METH_COEXIST,
        docstring_no_signature},
    {NULL},
};

static PyTypeObject DocStringNoSignatureTest = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "_testcapi.DocStringNoSignatureTest",
    .tp_basicsize = sizeof(PyObject),
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_methods = DocStringNoSignatureTest_methods,
    .tp_new = PyType_GenericNew,
};

static PyMethodDef DocStringUnrepresentableSignatureTest_methods[] = {
    {"meth",
        (PyCFunction)test_with_docstring, METH_VARARGS,
        PyDoc_STR(
            "meth($self, /, a, b=<x>)\n"
            "--\n\n"
            "This docstring has a signature with unrepresentable default."
        )},
    {"classmeth",
        (PyCFunction)test_with_docstring, METH_VARARGS|METH_CLASS,
        PyDoc_STR(
            "classmeth($type, /, a, b=<x>)\n"
            "--\n\n"
            "This docstring has a signature with unrepresentable default."
        )},
    {"staticmeth",
        (PyCFunction)test_with_docstring, METH_VARARGS|METH_STATIC,
        PyDoc_STR(
            "staticmeth(a, b=<x>)\n"
            "--\n\n"
            "This docstring has a signature with unrepresentable default."
        )},
    {"with_default",
        (PyCFunction)test_with_docstring, METH_VARARGS,
        PyDoc_STR(
            "with_default($self, /, x=ONE)\n"
            "--\n\n"
            "This instance method has a default parameter value from the module scope."
        )},
    {NULL},
};

static PyTypeObject DocStringUnrepresentableSignatureTest = {
    PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "_testcapi.DocStringUnrepresentableSignatureTest",
    .tp_basicsize = sizeof(PyObject),
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_methods = DocStringUnrepresentableSignatureTest_methods,
    .tp_new = PyType_GenericNew,
};

int
_PyTestCapi_Init_Docstring(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }
    if (PyModule_AddType(mod, &DocStringNoSignatureTest) < 0) {
        return -1;
    }
    if (PyModule_AddType(mod, &DocStringUnrepresentableSignatureTest) < 0) {
        return -1;
    }
    if (PyModule_AddObject(mod, "ONE", PyLong_FromLong(1)) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testcapi/exceptions.c
================================================
// clinic/exceptions.c.h uses internal pycore_modsupport.h API
#define PYTESTCAPI_NEED_INTERNAL_API

#include "parts.h"
#include "util.h"

#include "clinic/exceptions.c.h"


/*[clinic input]
module _testcapi
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=6361033e795369fc]*/

/*[clinic input]
_testcapi.err_set_raised
    exception as exc: object
    /
[clinic start generated code]*/

static PyObject *
_testcapi_err_set_raised(PyObject *module, PyObject *exc)
/*[clinic end generated code: output=0a0c7743961fcae5 input=c5f7331864a94df9]*/
{
    Py_INCREF(exc);
    PyErr_SetRaisedException(exc);
    assert(PyErr_Occurred());
    return NULL;
}

static PyObject *
err_restore(PyObject *self, PyObject *args) {
    PyObject *type = NULL, *value = NULL, *traceback = NULL;
    switch(PyTuple_Size(args)) {
        case 3:
            traceback = PyTuple_GetItem(args, 2);
            Py_INCREF(traceback);
            _Py_FALLTHROUGH;
        case 2:
            value = PyTuple_GetItem(args, 1);
            Py_INCREF(value);
            _Py_FALLTHROUGH;
        case 1:
            type = PyTuple_GetItem(args, 0);
            Py_INCREF(type);
            break;
        default:
            PyErr_SetString(PyExc_TypeError,
                        "wrong number of arguments");
            return NULL;
    }
    PyErr_Restore(type, value, traceback);
    assert(PyErr_Occurred());
    return NULL;
}

/*[clinic input]
_testcapi.exception_print
    exception as exc: object
    legacy: bool = False
    /

To test the format of exceptions as printed out.
[clinic start generated code]*/

static PyObject *
_testcapi_exception_print_impl(PyObject *module, PyObject *exc, int legacy)
/*[clinic end generated code: output=3f04fe0c18412ae0 input=c76f42cb94136dbf]*/
{
    if (legacy) {
        PyObject *tb = NULL;
        if (PyExceptionInstance_Check(exc)) {
            tb = PyException_GetTraceback(exc);
        }
        PyErr_Display((PyObject *) Py_TYPE(exc), exc, tb);
        Py_XDECREF(tb);
    }
    else {
        PyErr_DisplayException(exc);
    }
    Py_RETURN_NONE;
}

/*[clinic input]
_testcapi.make_exception_with_doc
    name: str
    doc: str = NULL
    base: object = NULL
    dict: object = NULL

Test PyErr_NewExceptionWithDoc (also exercise PyErr_NewException). Run via Lib/test/test_exceptions.py
[clinic start generated code]*/

static PyObject *
_testcapi_make_exception_with_doc_impl(PyObject *module, const char *name,
                                       const char *doc, PyObject *base,
                                       PyObject *dict)
/*[clinic end generated code: output=439f0d963c1ce2c4 input=23a73013f8a8795a]*/
{
    return PyErr_NewExceptionWithDoc(name, doc, base, dict);
}

/*[clinic input]
_testcapi.exc_set_object
    exception as exc: object
    obj: object
    /
[clinic start generated code]*/

static PyObject *
_testcapi_exc_set_object_impl(PyObject *module, PyObject *exc, PyObject *obj)
/*[clinic end generated code: output=34c8c7c83e5c8463 input=fc530aafb1b0a360]*/
{
    PyErr_SetObject(exc, obj);
    return NULL;
}

/*[clinic input]
_testcapi.exc_set_object_fetch = _testcapi.exc_set_object
[clinic start generated code]*/

static PyObject *
_testcapi_exc_set_object_fetch_impl(PyObject *module, PyObject *exc,
                                    PyObject *obj)
/*[clinic end generated code: output=7a5ff5f6d3cf687f input=77ec686f1f95fa38]*/
{
    PyObject *type = UNINITIALIZED_PTR;
    PyObject *value = UNINITIALIZED_PTR;
    PyObject *tb = UNINITIALIZED_PTR;

    PyErr_SetObject(exc, obj);
    PyErr_Fetch(&type, &value, &tb);
    assert(type != UNINITIALIZED_PTR);
    assert(value != UNINITIALIZED_PTR);
    assert(tb != UNINITIALIZED_PTR);
    Py_XDECREF(type);
    Py_XDECREF(tb);
    return value;
}

/*[clinic input]
_testcapi.err_setstring
    exc: object
    value: str(zeroes=True, accept={robuffer, str, NoneType})
    /
[clinic start generated code]*/

static PyObject *
_testcapi_err_setstring_impl(PyObject *module, PyObject *exc,
                             const char *value, Py_ssize_t value_length)
/*[clinic end generated code: output=fba8705e5703dd3f input=e8a95fad66d9004b]*/
{
    NULLABLE(exc);
    PyErr_SetString(exc, value);
    return NULL;
}

/*[clinic input]
_testcapi.err_setfromerrnowithfilename
    error: int
    exc: object
    value: str(zeroes=True, accept={robuffer, str, NoneType})
    /
[clinic start generated code]*/

static PyObject *
_testcapi_err_setfromerrnowithfilename_impl(PyObject *module, int error,
                                            PyObject *exc, const char *value,
                                            Py_ssize_t value_length)
/*[clinic end generated code: output=d02df5749a01850e input=ff7c384234bf097f]*/
{
    NULLABLE(exc);
    errno = error;
    PyErr_SetFromErrnoWithFilename(exc, value);
    return NULL;
}

/*[clinic input]
_testcapi.raise_exception
    exception as exc: object
    num_args: int
    /
[clinic start generated code]*/

static PyObject *
_testcapi_raise_exception_impl(PyObject *module, PyObject *exc, int num_args)
/*[clinic end generated code: output=eb0a9c5d69e0542d input=83d6262c3829d088]*/
{
    PyObject *exc_args = PyTuple_New(num_args);
    if (exc_args == NULL) {
        return NULL;
    }
    for (int i = 0; i < num_args; ++i) {
        PyObject *v = PyLong_FromLong(i);
        if (v == NULL) {
            Py_DECREF(exc_args);
            return NULL;
        }
        PyTuple_SET_ITEM(exc_args, i, v);
    }
    PyErr_SetObject(exc, exc_args);
    Py_DECREF(exc_args);
    return NULL;
}

/*[clinic input]
_testcapi.raise_memoryerror
[clinic start generated code]*/

static PyObject *
_testcapi_raise_memoryerror_impl(PyObject *module)
/*[clinic end generated code: output=dd057803fb0131e6 input=6ca521bd07fb73cb]*/
{
    return PyErr_NoMemory();
}

/*[clinic input]
_testcapi.fatal_error
    message: str(accept={robuffer})
    release_gil: bool = False
    /
[clinic start generated code]*/

static PyObject *
_testcapi_fatal_error_impl(PyObject *module, const char *message,
                           int release_gil)
/*[clinic end generated code: output=9c3237116e6a03e8 input=1be357a2ccb04c8c]*/
{
    if (release_gil) {
        Py_BEGIN_ALLOW_THREADS
        Py_FatalError(message);
        Py_END_ALLOW_THREADS
    }
    else {
        Py_FatalError(message);
    }
    // Py_FatalError() does not return, but exits the process.
    Py_RETURN_NONE;
}

/*[clinic input]
_testcapi.set_exc_info
    new_type: object
    new_value: object
    new_tb: object
    /
[clinic start generated code]*/

static PyObject *
_testcapi_set_exc_info_impl(PyObject *module, PyObject *new_type,
                            PyObject *new_value, PyObject *new_tb)
/*[clinic end generated code: output=b55fa35dec31300e input=ea9f19e0f55fe5b3]*/
{
    PyObject *type = UNINITIALIZED_PTR, *value = UNINITIALIZED_PTR, *tb = UNINITIALIZED_PTR;
    PyErr_GetExcInfo(&type, &value, &tb);

    Py_INCREF(new_type);
    Py_INCREF(new_value);
    Py_INCREF(new_tb);
    PyErr_SetExcInfo(new_type, new_value, new_tb);

    PyObject *orig_exc = PyTuple_Pack(3,
            type  ? type  : Py_None,
            value ? value : Py_None,
            tb    ? tb    : Py_None);
    Py_XDECREF(type);
    Py_XDECREF(value);
    Py_XDECREF(tb);
    return orig_exc;
}

/*[clinic input]
_testcapi.set_exception
    new_exc: object
    /
[clinic start generated code]*/

static PyObject *
_testcapi_set_exception(PyObject *module, PyObject *new_exc)
/*[clinic end generated code: output=8b969b35d029e96d input=c89d4ca966c69738]*/
{
    PyObject *exc = PyErr_GetHandledException();
    assert(PyExceptionInstance_Check(exc) || exc == NULL);
    PyErr_SetHandledException(new_exc);
    return exc;
}

/*[clinic input]
_testcapi.traceback_print
    traceback: object
    file: object
    /
To test the format of tracebacks as printed out.
[clinic start generated code]*/

static PyObject *
_testcapi_traceback_print_impl(PyObject *module, PyObject *traceback,
                               PyObject *file)
/*[clinic end generated code: output=17074ecf9d95cf30 input=9423f2857b008ca8]*/
{
    if (PyTraceBack_Print(traceback, file) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}

static PyObject *
err_writeunraisable(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *exc, *obj;
    if (!PyArg_ParseTuple(args, "OO", &exc, &obj)) {
        return NULL;
    }
    NULLABLE(exc);
    NULLABLE(obj);
    if (exc) {
        PyErr_SetRaisedException(Py_NewRef(exc));
    }
    PyErr_WriteUnraisable(obj);
    Py_RETURN_NONE;
}

static PyObject *
err_formatunraisable(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *exc;
    const char *fmt;
    Py_ssize_t fmtlen;
    PyObject *objs[10] = {NULL};

    if (!PyArg_ParseTuple(args, "Oz#|OOOOOOOOOO", &exc, &fmt, &fmtlen,
            &objs[0], &objs[1], &objs[2], &objs[3], &objs[4],
            &objs[5], &objs[6], &objs[7], &objs[8], &objs[9]))
    {
        return NULL;
    }
    NULLABLE(exc);
    if (exc) {
        PyErr_SetRaisedException(Py_NewRef(exc));
    }
    PyErr_FormatUnraisable(fmt,
            objs[0], objs[1], objs[2], objs[3], objs[4],
            objs[5], objs[6], objs[7], objs[8], objs[9]);
    Py_RETURN_NONE;
}

/*[clinic input]
_testcapi.unstable_exc_prep_reraise_star
    orig: object
    excs: object
    /
To test PyUnstable_Exc_PrepReraiseStar.
[clinic start generated code]*/

static PyObject *
_testcapi_unstable_exc_prep_reraise_star_impl(PyObject *module,
                                              PyObject *orig, PyObject *excs)
/*[clinic end generated code: output=850cf008e0563c77 input=27fbcda2203eb301]*/
{
    return PyUnstable_Exc_PrepReraiseStar(orig, excs);
}

/* Test PyUnicodeEncodeError_GetStart */
static PyObject *
unicode_encode_get_start(PyObject *Py_UNUSED(module), PyObject *arg)
{
    Py_ssize_t start;
    if (PyUnicodeEncodeError_GetStart(arg, &start) < 0) {
        return NULL;
    }
    RETURN_SIZE(start);
}

/* Test PyUnicodeDecodeError_GetStart */
static PyObject *
unicode_decode_get_start(PyObject *Py_UNUSED(module), PyObject *arg)
{
    Py_ssize_t start;
    if (PyUnicodeDecodeError_GetStart(arg, &start) < 0) {
        return NULL;
    }
    RETURN_SIZE(start);
}

/* Test PyUnicodeTranslateError_GetStart */
static PyObject *
unicode_translate_get_start(PyObject *Py_UNUSED(module), PyObject *arg)
{
    Py_ssize_t start;
    if (PyUnicodeTranslateError_GetStart(arg, &start) < 0) {
        return NULL;
    }
    RETURN_SIZE(start);
}

/* Test PyUnicodeEncodeError_SetStart */
static PyObject *
unicode_encode_set_start(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *exc;
    Py_ssize_t start;
    if (PyArg_ParseTuple(args, "On", &exc, &start) < 0) {
        return NULL;
    }
    if (PyUnicodeEncodeError_SetStart(exc, start) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}

/* Test PyUnicodeDecodeError_SetStart */
static PyObject *
unicode_decode_set_start(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *exc;
    Py_ssize_t start;
    if (PyArg_ParseTuple(args, "On", &exc, &start) < 0) {
        return NULL;
    }
    if (PyUnicodeDecodeError_SetStart(exc, start) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}

/* Test PyUnicodeTranslateError_SetStart */
static PyObject *
unicode_translate_set_start(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *exc;
    Py_ssize_t start;
    if (PyArg_ParseTuple(args, "On", &exc, &start) < 0) {
        return NULL;
    }
    if (PyUnicodeTranslateError_SetStart(exc, start) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}

/* Test PyUnicodeEncodeError_GetEnd */
static PyObject *
unicode_encode_get_end(PyObject *Py_UNUSED(module), PyObject *arg)
{
    Py_ssize_t end;
    if (PyUnicodeEncodeError_GetEnd(arg, &end) < 0) {
        return NULL;
    }
    RETURN_SIZE(end);
}

/* Test PyUnicodeDecodeError_GetEnd */
static PyObject *
unicode_decode_get_end(PyObject *Py_UNUSED(module), PyObject *arg)
{
    Py_ssize_t end;
    if (PyUnicodeDecodeError_GetEnd(arg, &end) < 0) {
        return NULL;
    }
    RETURN_SIZE(end);
}

/* Test PyUnicodeTranslateError_GetEnd */
static PyObject *
unicode_translate_get_end(PyObject *Py_UNUSED(module), PyObject *arg)
{
    Py_ssize_t end;
    if (PyUnicodeTranslateError_GetEnd(arg, &end) < 0) {
        return NULL;
    }
    RETURN_SIZE(end);
}

/* Test PyUnicodeEncodeError_SetEnd */
static PyObject *
unicode_encode_set_end(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *exc;
    Py_ssize_t end;
    if (PyArg_ParseTuple(args, "On", &exc, &end) < 0) {
        return NULL;
    }
    if (PyUnicodeEncodeError_SetEnd(exc, end) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}

/* Test PyUnicodeDecodeError_SetEnd */
static PyObject *
unicode_decode_set_end(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *exc;
    Py_ssize_t end;
    if (PyArg_ParseTuple(args, "On", &exc, &end) < 0) {
        return NULL;
    }
    if (PyUnicodeDecodeError_SetEnd(exc, end) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}

/* Test PyUnicodeTranslateError_SetEnd */
static PyObject *
unicode_translate_set_end(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *exc;
    Py_ssize_t end;
    if (PyArg_ParseTuple(args, "On", &exc, &end) < 0) {
        return NULL;
    }
    if (PyUnicodeTranslateError_SetEnd(exc, end) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}

/*
 * Define the PyRecurdingInfinitelyError_Type
 */

static PyTypeObject PyRecursingInfinitelyError_Type;

static int
recurse_infinitely_error_init(PyObject *self, PyObject *args, PyObject *kwds)
{
    PyObject *type = (PyObject *)&PyRecursingInfinitelyError_Type;

    /* Instantiating this exception starts infinite recursion. */
    Py_INCREF(type);
    PyErr_SetObject(type, NULL);
    return -1;
}

static PyTypeObject PyRecursingInfinitelyError_Type = {
    .tp_name = "RecursingInfinitelyError",
    .tp_basicsize = sizeof(PyBaseExceptionObject),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_doc = PyDoc_STR("Instantiating this exception starts infinite recursion."),
    .tp_init = (initproc)recurse_infinitely_error_init,
};

static PyMethodDef test_methods[] = {
    {"err_restore",             err_restore,                     METH_VARARGS},
    {"err_writeunraisable",     err_writeunraisable,             METH_VARARGS},
    {"err_formatunraisable",    err_formatunraisable,            METH_VARARGS},
    _TESTCAPI_ERR_SET_RAISED_METHODDEF
    _TESTCAPI_EXCEPTION_PRINT_METHODDEF
    _TESTCAPI_FATAL_ERROR_METHODDEF
    _TESTCAPI_MAKE_EXCEPTION_WITH_DOC_METHODDEF
    _TESTCAPI_EXC_SET_OBJECT_METHODDEF
    _TESTCAPI_EXC_SET_OBJECT_FETCH_METHODDEF
    _TESTCAPI_ERR_SETSTRING_METHODDEF
    _TESTCAPI_ERR_SETFROMERRNOWITHFILENAME_METHODDEF
    _TESTCAPI_RAISE_EXCEPTION_METHODDEF
    _TESTCAPI_RAISE_MEMORYERROR_METHODDEF
    _TESTCAPI_SET_EXC_INFO_METHODDEF
    _TESTCAPI_SET_EXCEPTION_METHODDEF
    _TESTCAPI_TRACEBACK_PRINT_METHODDEF
    _TESTCAPI_UNSTABLE_EXC_PREP_RERAISE_STAR_METHODDEF
    {"unicode_encode_get_start", unicode_encode_get_start,       METH_O},
    {"unicode_decode_get_start", unicode_decode_get_start,       METH_O},
    {"unicode_translate_get_start", unicode_translate_get_start, METH_O},
    {"unicode_encode_set_start", unicode_encode_set_start,       METH_VARARGS},
    {"unicode_decode_set_start", unicode_decode_set_start,       METH_VARARGS},
    {"unicode_translate_set_start", unicode_translate_set_start, METH_VARARGS},
    {"unicode_encode_get_end", unicode_encode_get_end,           METH_O},
    {"unicode_decode_get_end", unicode_decode_get_end,           METH_O},
    {"unicode_translate_get_end", unicode_translate_get_end,     METH_O},
    {"unicode_encode_set_end", unicode_encode_set_end,           METH_VARARGS},
    {"unicode_decode_set_end", unicode_decode_set_end,           METH_VARARGS},
    {"unicode_translate_set_end", unicode_translate_set_end,     METH_VARARGS},
    {NULL},
};

int
_PyTestCapi_Init_Exceptions(PyObject *mod)
{
    PyRecursingInfinitelyError_Type.tp_base = (PyTypeObject *)PyExc_Exception;
    if (PyType_Ready(&PyRecursingInfinitelyError_Type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(mod, "RecursingInfinitelyError",
                              (PyObject *)&PyRecursingInfinitelyError_Type) < 0)
    {
        return -1;
    }

    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/file.c
================================================
// clinic/file.c.h uses internal pycore_modsupport.h API
#define PYTESTCAPI_NEED_INTERNAL_API

#include "parts.h"
#include "util.h"
#include "clinic/file.c.h"

/*[clinic input]
module _testcapi
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=6361033e795369fc]*/

/*[clinic input]
_testcapi.py_fopen

    path: object
    mode: str(zeroes=True, accept={robuffer, str, NoneType})
    /

Call Py_fopen(), fread(256) and Py_fclose(). Return read bytes.
[clinic start generated code]*/

static PyObject *
_testcapi_py_fopen_impl(PyObject *module, PyObject *path, const char *mode,
                        Py_ssize_t mode_length)
/*[clinic end generated code: output=69840d0cfd8b7fbb input=f3a579dd7eb60926]*/
{
    NULLABLE(path);
    FILE *fp = Py_fopen(path, mode);
    if (fp == NULL) {
        return NULL;
    }

    char buffer[256];
    size_t size = fread(buffer, 1, Py_ARRAY_LENGTH(buffer), fp);
    Py_fclose(fp);

    return PyBytes_FromStringAndSize(buffer, size);
}

static PyMethodDef test_methods[] = {
    _TESTCAPI_PY_FOPEN_METHODDEF
    {NULL},
};

int
_PyTestCapi_Init_File(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0){
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/float.c
================================================
// clinic/float.c.h uses internal pycore_modsupport.h API
#define PYTESTCAPI_NEED_INTERNAL_API

#include "parts.h"
#include "util.h"
#include "clinic/float.c.h"


/*[clinic input]
module _testcapi
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=6361033e795369fc]*/

/*[clinic input]
_testcapi.float_pack

    size: int
    d: double
    le: int
    /

Test PyFloat_Pack2(), PyFloat_Pack4() and PyFloat_Pack8()
[clinic start generated code]*/

static PyObject *
_testcapi_float_pack_impl(PyObject *module, int size, double d, int le)
/*[clinic end generated code: output=7899bd98f8b6cb04 input=52c9115121999c98]*/
{
    switch (size)
    {
    case 2:
    {
        char data[2];
        if (PyFloat_Pack2(d, data, le) < 0) {
            return NULL;
        }
        return PyBytes_FromStringAndSize(data, Py_ARRAY_LENGTH(data));
    }
    case 4:
    {
        char data[4];
        if (PyFloat_Pack4(d, data, le) < 0) {
            return NULL;
        }
        return PyBytes_FromStringAndSize(data, Py_ARRAY_LENGTH(data));
    }
    case 8:
    {
        char data[8];
        if (PyFloat_Pack8(d, data, le) < 0) {
            return NULL;
        }
        return PyBytes_FromStringAndSize(data, Py_ARRAY_LENGTH(data));
    }
    default: break;
    }

    PyErr_SetString(PyExc_ValueError, "size must 2, 4 or 8");
    return NULL;
}


/*[clinic input]
_testcapi.float_unpack

    data: str(accept={robuffer}, zeroes=True)
    le: int
    /

Test PyFloat_Unpack2(), PyFloat_Unpack4() and PyFloat_Unpack8()
[clinic start generated code]*/

static PyObject *
_testcapi_float_unpack_impl(PyObject *module, const char *data,
                            Py_ssize_t data_length, int le)
/*[clinic end generated code: output=617059f889ddbfe4 input=c095e4bb75a696cd]*/
{
    assert(!PyErr_Occurred());
    double d;
    switch (data_length)
    {
    case 2:
        d = PyFloat_Unpack2(data, le);
        break;
    case 4:
        d = PyFloat_Unpack4(data, le);
        break;
    case 8:
        d = PyFloat_Unpack8(data, le);
        break;
    default:
        PyErr_SetString(PyExc_ValueError, "data length must 2, 4 or 8 bytes");
        return NULL;
    }

    if (d == -1.0 && PyErr_Occurred()) {
        return NULL;
    }
    return PyFloat_FromDouble(d);
}

static PyMethodDef test_methods[] = {
    _TESTCAPI_FLOAT_PACK_METHODDEF
    _TESTCAPI_FLOAT_UNPACK_METHODDEF
    {NULL},
};

int
_PyTestCapi_Init_Float(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/gc.c
================================================
#include "parts.h"

static PyObject*
test_gc_control(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    int orig_enabled = PyGC_IsEnabled();
    const char* msg = "ok";
    int old_state;

    old_state = PyGC_Enable();
    msg = "Enable(1)";
    if (old_state != orig_enabled) {
        goto failed;
    }
    msg = "IsEnabled(1)";
    if (!PyGC_IsEnabled()) {
        goto failed;
    }

    old_state = PyGC_Disable();
    msg = "disable(2)";
    if (!old_state) {
        goto failed;
    }
    msg = "IsEnabled(2)";
    if (PyGC_IsEnabled()) {
        goto failed;
    }

    old_state = PyGC_Enable();
    msg = "enable(3)";
    if (old_state) {
        goto failed;
    }
    msg = "IsEnabled(3)";
    if (!PyGC_IsEnabled()) {
        goto failed;
    }

    if (!orig_enabled) {
        old_state = PyGC_Disable();
        msg = "disable(4)";
        if (old_state) {
            goto failed;
        }
        msg = "IsEnabled(4)";
        if (PyGC_IsEnabled()) {
            goto failed;
        }
    }

    Py_RETURN_NONE;

failed:
    /* Try to clean up if we can. */
    if (orig_enabled) {
        PyGC_Enable();
    } else {
        PyGC_Disable();
    }
    PyErr_Format(PyExc_ValueError, "GC control failed in %s", msg);
    return NULL;
}

static PyObject *
without_gc(PyObject *Py_UNUSED(self), PyObject *obj)
{
    PyTypeObject *tp = (PyTypeObject*)obj;
    if (!PyType_Check(obj) || !PyType_HasFeature(tp, Py_TPFLAGS_HEAPTYPE)) {
        return PyErr_Format(PyExc_TypeError, "heap type expected, got %R", obj);
    }
    if (PyType_IS_GC(tp)) {
        // Don't try this at home, kids:
        tp->tp_flags -= Py_TPFLAGS_HAVE_GC;
        tp->tp_free = PyObject_Free;
        tp->tp_traverse = NULL;
        tp->tp_clear = NULL;
    }
    assert(!PyType_IS_GC(tp));
    return Py_NewRef(obj);
}

static void
slot_tp_del(PyObject *self)
{
    PyObject *del, *res;

    /* Temporarily resurrect the object. */
    assert(Py_REFCNT(self) == 0);
    Py_SET_REFCNT(self, 1);

    /* Save the current exception, if any. */
    PyObject *exc = PyErr_GetRaisedException();

    PyObject *tp_del = PyUnicode_InternFromString("__tp_del__");
    if (tp_del == NULL) {
        PyErr_WriteUnraisable(NULL);
        PyErr_SetRaisedException(exc);
        return;
    }
    /* Execute __del__ method, if any. */
    del = _PyType_LookupRef(Py_TYPE(self), tp_del);
    Py_DECREF(tp_del);
    if (del != NULL) {
        res = PyObject_CallOneArg(del, self);
        Py_DECREF(del);
        if (res == NULL)
            PyErr_WriteUnraisable(del);
        else
            Py_DECREF(res);
    }

    /* Restore the saved exception. */
    PyErr_SetRaisedException(exc);

    /* Undo the temporary resurrection; can't use DECREF here, it would
     * cause a recursive call.
     */
    assert(Py_REFCNT(self) > 0);
    Py_SET_REFCNT(self, Py_REFCNT(self) - 1);
    if (Py_REFCNT(self) == 0) {
        /* this is the normal path out */
        return;
    }

    /* __del__ resurrected it!  Make it look like the original Py_DECREF
     * never happened.
     */
    {
        _Py_ResurrectReference(self);
    }
    assert(!PyType_IS_GC(Py_TYPE(self)) || PyObject_GC_IsTracked(self));
}

static PyObject *
with_tp_del(PyObject *self, PyObject *args)
{
    PyObject *obj;
    PyTypeObject *tp;

    if (!PyArg_ParseTuple(args, "O:with_tp_del", &obj))
        return NULL;
    tp = (PyTypeObject *) obj;
    if (!PyType_Check(obj) || !PyType_HasFeature(tp, Py_TPFLAGS_HEAPTYPE)) {
        PyErr_Format(PyExc_TypeError,
                     "heap type expected, got %R", obj);
        return NULL;
    }
    tp->tp_del = slot_tp_del;
    return Py_NewRef(obj);
}


struct gc_visit_state_basic {
    PyObject *target;
    int found;
};

static int
gc_visit_callback_basic(PyObject *obj, void *arg)
{
    struct gc_visit_state_basic *state = (struct gc_visit_state_basic *)arg;
    if (obj == state->target) {
        state->found = 1;
        return 0;
    }
    return 1;
}

static PyObject *
test_gc_visit_objects_basic(PyObject *Py_UNUSED(self),
                            PyObject *Py_UNUSED(ignored))
{
    PyObject *obj;
    struct gc_visit_state_basic state;

    obj = PyList_New(0);
    if (obj == NULL) {
        return NULL;
    }
    state.target = obj;
    state.found = 0;

    PyUnstable_GC_VisitObjects(gc_visit_callback_basic, &state);
    Py_DECREF(obj);
    if (!state.found) {
        PyErr_SetString(
             PyExc_AssertionError,
             "test_gc_visit_objects_basic: Didn't find live list");
         return NULL;
    }
    Py_RETURN_NONE;
}

static int
gc_visit_callback_exit_early(PyObject *obj, void *arg)
 {
    int *visited_i = (int *)arg;
    (*visited_i)++;
    if (*visited_i == 2) {
        return 0;
    }
    return 1;
}

static PyObject *
test_gc_visit_objects_exit_early(PyObject *Py_UNUSED(self),
                                 PyObject *Py_UNUSED(ignored))
{
    int visited_i = 0;
    PyUnstable_GC_VisitObjects(gc_visit_callback_exit_early, &visited_i);
    if (visited_i != 2) {
        PyErr_SetString(
            PyExc_AssertionError,
            "test_gc_visit_objects_exit_early: did not exit when expected");
    }
    Py_RETURN_NONE;
}

typedef struct {
    PyObject_HEAD
} ObjExtraData;

static PyObject *
obj_extra_data_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    size_t extra_size = sizeof(PyObject *);
    PyObject *obj = PyUnstable_Object_GC_NewWithExtraData(type, extra_size);
    if (obj == NULL) {
        return PyErr_NoMemory();
    }
    PyObject_GC_Track(obj);
    return obj;
}

static PyObject **
obj_extra_data_get_extra_storage(PyObject *self)
{
    return (PyObject **)((char *)self + Py_TYPE(self)->tp_basicsize);
}

static PyObject *
obj_extra_data_get(PyObject *self, void *Py_UNUSED(ignored))
{
    PyObject **extra_storage = obj_extra_data_get_extra_storage(self);
    PyObject *value = *extra_storage;
    if (!value) {
        Py_RETURN_NONE;
    }
    return Py_NewRef(value);
}

static int
obj_extra_data_set(PyObject *self, PyObject *newval, void *Py_UNUSED(ignored))
{
    PyObject **extra_storage = obj_extra_data_get_extra_storage(self);
    Py_CLEAR(*extra_storage);
    if (newval) {
        *extra_storage = Py_NewRef(newval);
    }
    return 0;
}

static PyGetSetDef obj_extra_data_getset[] = {
    {"extra", (getter)obj_extra_data_get, (setter)obj_extra_data_set, NULL},
    {NULL}
};

static int
obj_extra_data_traverse(PyObject *self, visitproc visit, void *arg)
{
    PyObject **extra_storage = obj_extra_data_get_extra_storage(self);
    PyObject *value = *extra_storage;
    Py_VISIT(value);
    return 0;
}

static int
obj_extra_data_clear(PyObject *self)
{
    PyObject **extra_storage = obj_extra_data_get_extra_storage(self);
    Py_CLEAR(*extra_storage);
    return 0;
}

static void
obj_extra_data_dealloc(PyObject *self)
{
    PyTypeObject *tp = Py_TYPE(self);
    PyObject_GC_UnTrack(self);
    obj_extra_data_clear(self);
    tp->tp_free(self);
    Py_DECREF(tp);
}

static PyType_Slot ObjExtraData_Slots[] = {
    {Py_tp_getset, obj_extra_data_getset},
    {Py_tp_dealloc, obj_extra_data_dealloc},
    {Py_tp_traverse, obj_extra_data_traverse},
    {Py_tp_clear, obj_extra_data_clear},
    {Py_tp_new, obj_extra_data_new},
    {Py_tp_free, PyObject_GC_Del},
    {0, NULL},
};

static PyType_Spec ObjExtraData_TypeSpec = {
    .name = "_testcapi.ObjExtraData",
    .basicsize = sizeof(ObjExtraData),
    .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
    .slots = ObjExtraData_Slots,
};

static PyMethodDef test_methods[] = {
    {"test_gc_control", test_gc_control, METH_NOARGS},
    {"test_gc_visit_objects_basic", test_gc_visit_objects_basic, METH_NOARGS, NULL},
    {"test_gc_visit_objects_exit_early", test_gc_visit_objects_exit_early, METH_NOARGS, NULL},
    {"without_gc", without_gc, METH_O, NULL},
    {"with_tp_del", with_tp_del, METH_VARARGS, NULL},
    {NULL}
};

int _PyTestCapi_Init_GC(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }

    PyObject *ObjExtraData_Type = PyType_FromModuleAndSpec(
        mod, &ObjExtraData_TypeSpec, NULL);
    if (ObjExtraData_Type == 0) {
        return -1;
    }
    int ret = PyModule_AddType(mod, (PyTypeObject*)ObjExtraData_Type);
    Py_DECREF(ObjExtraData_Type);
    if (ret < 0) {
        return ret;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/getargs.c
================================================
/*
 * Tests for Python/getargs.c and Python/modsupport.c;
 * APIs that parse and build arguments.
 */

#include "parts.h"

static PyObject *
parse_tuple_and_keywords(PyObject *self, PyObject *args)
{
    PyObject *sub_args;
    PyObject *sub_kwargs;
    const char *sub_format;
    PyObject *sub_keywords;

#define MAX_PARAMS 8
    double buffers[MAX_PARAMS][4]; /* double ensures alignment where necessary */
    char *keywords[MAX_PARAMS + 1]; /* space for NULL at end */

    PyObject *return_value = NULL;

    if (!PyArg_ParseTuple(args, "OOsO:parse_tuple_and_keywords",
                          &sub_args, &sub_kwargs, &sub_format, &sub_keywords))
    {
        return NULL;
    }

    if (!(PyList_CheckExact(sub_keywords) ||
        PyTuple_CheckExact(sub_keywords)))
    {
        PyErr_SetString(PyExc_ValueError,
            "parse_tuple_and_keywords: "
            "sub_keywords must be either list or tuple");
        return NULL;
    }

    memset(buffers, 0, sizeof(buffers));
    memset(keywords, 0, sizeof(keywords));

    Py_ssize_t size = PySequence_Fast_GET_SIZE(sub_keywords);
    if (size > MAX_PARAMS) {
        PyErr_SetString(PyExc_ValueError,
            "parse_tuple_and_keywords: too many keywords in sub_keywords");
        goto exit;
    }

    for (Py_ssize_t i = 0; i < size; i++) {
        PyObject *o = PySequence_Fast_GET_ITEM(sub_keywords, i);
        if (PyUnicode_Check(o)) {
            keywords[i] = (char *)PyUnicode_AsUTF8(o);
            if (keywords[i] == NULL) {
                goto exit;
            }
        }
        else if (PyBytes_Check(o)) {
            keywords[i] = PyBytes_AS_STRING(o);
        }
        else {
            PyErr_SetString(PyExc_ValueError,
                "parse_tuple_and_keywords: "
                "keywords must be str or bytes");
            goto exit;
        }
    }

    assert(MAX_PARAMS == 8);
    int result = PyArg_ParseTupleAndKeywords(sub_args, sub_kwargs,
        sub_format, keywords,
        buffers + 0, buffers + 1, buffers + 2, buffers + 3,
        buffers + 4, buffers + 5, buffers + 6, buffers + 7);

    if (result) {
        int objects_only = 1;
        int count = 0;
        for (const char *f = sub_format; *f; f++) {
            if (Py_ISALNUM(*f)) {
                if (strchr("OSUY", *f) == NULL) {
                    objects_only = 0;
                    break;
                }
                count++;
            }
        }
        if (objects_only) {
            return_value = PyTuple_New(count);
            if (return_value == NULL) {
                goto exit;
            }
            for (Py_ssize_t i = 0; i < count; i++) {
                PyObject *arg = *(PyObject **)(buffers + i);
                if (arg == NULL) {
                    arg = Py_None;
                }
                PyTuple_SET_ITEM(return_value, i, Py_NewRef(arg));
            }
        }
        else {
            return_value = Py_NewRef(Py_None);
        }
    }

exit:
    return return_value;
}

static PyObject *
get_args(PyObject *self, PyObject *args)
{
    if (args == NULL) {
        args = Py_None;
    }
    return Py_NewRef(args);
}

static PyObject *
get_kwargs(PyObject *self, PyObject *args, PyObject *kwargs)
{
    if (kwargs == NULL) {
        kwargs = Py_None;
    }
    return Py_NewRef(kwargs);
}

static PyObject *
getargs_w_star(PyObject *self, PyObject *args)
{
    Py_buffer buffer;

    if (!PyArg_ParseTuple(args, "w*:getargs_w_star", &buffer)) {
        return NULL;
    }

    if (2 <= buffer.len) {
        char *str = buffer.buf;
        str[0] = '[';
        str[buffer.len-1] = ']';
    }

    PyObject *result = PyBytes_FromStringAndSize(buffer.buf, buffer.len);
    PyBuffer_Release(&buffer);
    return result;
}

static PyObject *
getargs_w_star_opt(PyObject *self, PyObject *args)
{
    Py_buffer buffer;
    Py_buffer buf2;
    int number = 1;

    if (!PyArg_ParseTuple(args, "w*|w*i:getargs_w_star",
                          &buffer, &buf2, &number)) {
        return NULL;
    }

    if (2 <= buffer.len) {
        char *str = buffer.buf;
        str[0] = '[';
        str[buffer.len-1] = ']';
    }

    PyObject *result = PyBytes_FromStringAndSize(buffer.buf, buffer.len);
    PyBuffer_Release(&buffer);
    return result;
}

/* Test the old w and w# codes that no longer work */
static PyObject *
test_w_code_invalid(PyObject *self, PyObject *arg)
{
    static const char * const keywords[] = {"a", "b", "c", "d", NULL};
    char *formats_3[] = {"O|w#$O",
                         "O|w$O",
                         "O|w#O",
                         "O|wO",
                         NULL};
    char *formats_4[] = {"O|w#O$O",
                         "O|wO$O",
                         "O|Ow#O",
                         "O|OwO",
                         "O|Ow#$O",
                         "O|Ow$O",
                         NULL};
    size_t n;
    PyObject *args;
    PyObject *kwargs;
    PyObject *tmp;

    if (!(args = PyTuple_Pack(1, Py_None))) {
        return NULL;
    }

    kwargs = PyDict_New();
    if (!kwargs) {
        Py_DECREF(args);
        return NULL;
    }

    if (PyDict_SetItemString(kwargs, "c", Py_None)) {
        Py_DECREF(args);
        Py_XDECREF(kwargs);
        return NULL;
    }

    for (n = 0; formats_3[n]; ++n) {
        if (PyArg_ParseTupleAndKeywords(args, kwargs, formats_3[n],
                                        (char**) keywords,
                                        &tmp, &tmp, &tmp)) {
            Py_DECREF(args);
            Py_DECREF(kwargs);
            PyErr_Format(PyExc_AssertionError,
                         "test_w_code_invalid_suffix: %s",
                         formats_3[n]);
            return NULL;
        }
        else {
            if (!PyErr_ExceptionMatches(PyExc_SystemError)) {
                Py_DECREF(args);
                Py_DECREF(kwargs);
                return NULL;
            }
            PyErr_Clear();
        }
    }

    if (PyDict_DelItemString(kwargs, "c") ||
        PyDict_SetItemString(kwargs, "d", Py_None)) {

        Py_DECREF(kwargs);
        Py_DECREF(args);
        return NULL;
    }

    for (n = 0; formats_4[n]; ++n) {
        if (PyArg_ParseTupleAndKeywords(args, kwargs, formats_4[n],
                                        (char**) keywords,
                                        &tmp, &tmp, &tmp, &tmp)) {
            Py_DECREF(args);
            Py_DECREF(kwargs);
            PyErr_Format(PyExc_AssertionError,
                         "test_w_code_invalid_suffix: %s",
                         formats_4[n]);
            return NULL;
        }
        else {
            if (!PyErr_ExceptionMatches(PyExc_SystemError)) {
                Py_DECREF(args);
                Py_DECREF(kwargs);
                return NULL;
            }
            PyErr_Clear();
        }
    }

    Py_DECREF(args);
    Py_DECREF(kwargs);
    Py_RETURN_NONE;
}

static PyObject *
getargs_empty(PyObject *self, PyObject *args, PyObject *kwargs)
{
    /* Test that formats can begin with '|'. See issue #4720. */
    assert(PyTuple_CheckExact(args));
    assert(kwargs == NULL || PyDict_CheckExact(kwargs));

    int result;
    if (kwargs != NULL && PyDict_GET_SIZE(kwargs) > 0) {
        static char *kwlist[] = {NULL};
        result = PyArg_ParseTupleAndKeywords(args, kwargs, "|:getargs_empty",
                                             kwlist);
    }
    else {
        result = PyArg_ParseTuple(args, "|:getargs_empty");
    }
    if (!result) {
        return NULL;
    }
    return PyLong_FromLong(result);
}

/* Test tuple argument processing */
static PyObject *
getargs_tuple(PyObject *self, PyObject *args)
{
    int a, b, c;
    if (!PyArg_ParseTuple(args, "i(ii)", &a, &b, &c)) {
        return NULL;
    }
    return Py_BuildValue("iii", a, b, c);
}

/* test PyArg_ParseTupleAndKeywords */
static PyObject *
getargs_keywords(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *keywords[] = {"arg1","arg2","arg3","arg4","arg5", NULL};
    static const char fmt[] = "(ii)i|(i(ii))(iii)i";
    int int_args[10] = {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, fmt, keywords,
        &int_args[0], &int_args[1], &int_args[2], &int_args[3], &int_args[4],
        &int_args[5], &int_args[6], &int_args[7], &int_args[8], &int_args[9]))
    {
        return NULL;
    }
    return Py_BuildValue("iiiiiiiiii",
        int_args[0], int_args[1], int_args[2], int_args[3], int_args[4],
        int_args[5], int_args[6], int_args[7], int_args[8], int_args[9]);
}

/* test PyArg_ParseTupleAndKeywords keyword-only arguments */
static PyObject *
getargs_keyword_only(PyObject *self, PyObject *args, PyObject *kwargs)
{
    static char *keywords[] = {"required", "optional", "keyword_only", NULL};
    int required = -1;
    int optional = -1;
    int keyword_only = -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i|i$i", keywords,
                                     &required, &optional, &keyword_only))
    {
        return NULL;
    }
    return Py_BuildValue("iii", required, optional, keyword_only);
}

/* test PyArg_ParseTupleAndKeywords positional-only arguments */
static PyObject *
getargs_positional_only_and_keywords(PyObject *self, PyObject *args,
                                     PyObject *kwargs)
{
    static char *keywords[] = {"", "", "keyword", NULL};
    int required = -1;
    int optional = -1;
    int keyword = -1;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "i|ii", keywords,
                                     &required, &optional, &keyword))
    {
        return NULL;
    }
    return Py_BuildValue("iii", required, optional, keyword);
}

/* Functions to call PyArg_ParseTuple with integer format codes,
   and return the result.
*/
static PyObject *
getargs_b(PyObject *self, PyObject *args)
{
    unsigned char value;
    if (!PyArg_ParseTuple(args, "b", &value)) {
        return NULL;
    }
    return PyLong_FromUnsignedLong((unsigned long)value);
}

static PyObject *
getargs_B(PyObject *self, PyObject *args)
{
    unsigned char value;
    if (!PyArg_ParseTuple(args, "B", &value)) {
        return NULL;
    }
    return PyLong_FromUnsignedLong((unsigned long)value);
}

static PyObject *
getargs_h(PyObject *self, PyObject *args)
{
    short value;
    if (!PyArg_ParseTuple(args, "h", &value)) {
        return NULL;
    }
    return PyLong_FromLong((long)value);
}

static PyObject *
getargs_H(PyObject *self, PyObject *args)
{
    unsigned short value;
    if (!PyArg_ParseTuple(args, "H", &value)) {
        return NULL;
    }
    return PyLong_FromUnsignedLong((unsigned long)value);
}

static PyObject *
getargs_I(PyObject *self, PyObject *args)
{
    unsigned int value;
    if (!PyArg_ParseTuple(args, "I", &value)) {
        return NULL;
    }
    return PyLong_FromUnsignedLong((unsigned long)value);
}

static PyObject *
getargs_k(PyObject *self, PyObject *args)
{
    unsigned long value;
    if (!PyArg_ParseTuple(args, "k", &value)) {
        return NULL;
    }
    return PyLong_FromUnsignedLong(value);
}

static PyObject *
getargs_i(PyObject *self, PyObject *args)
{
    int value;
    if (!PyArg_ParseTuple(args, "i", &value)) {
        return NULL;
    }
    return PyLong_FromLong((long)value);
}

static PyObject *
getargs_l(PyObject *self, PyObject *args)
{
    long value;
    if (!PyArg_ParseTuple(args, "l", &value)) {
        return NULL;
    }
    return PyLong_FromLong(value);
}

static PyObject *
getargs_n(PyObject *self, PyObject *args)
{
    Py_ssize_t value;
    if (!PyArg_ParseTuple(args, "n", &value)) {
        return NULL;
    }
    return PyLong_FromSsize_t(value);
}

static PyObject *
getargs_p(PyObject *self, PyObject *args)
{
    int value;
    if (!PyArg_ParseTuple(args, "p", &value)) {
        return NULL;
    }
    return PyLong_FromLong(value);
}

static PyObject *
getargs_L(PyObject *self, PyObject *args)
{
    long long value;
    if (!PyArg_ParseTuple(args, "L", &value)) {
        return NULL;
    }
    return PyLong_FromLongLong(value);
}

static PyObject *
getargs_K(PyObject *self, PyObject *args)
{
    unsigned long long value;
    if (!PyArg_ParseTuple(args, "K", &value)) {
        return NULL;
    }
    return PyLong_FromUnsignedLongLong(value);
}

static PyObject *
getargs_f(PyObject *self, PyObject *args)
{
    float f;
    if (!PyArg_ParseTuple(args, "f", &f)) {
        return NULL;
    }
    return PyFloat_FromDouble(f);
}

static PyObject *
getargs_d(PyObject *self, PyObject *args)
{
    double d;
    if (!PyArg_ParseTuple(args, "d", &d)) {
        return NULL;
    }
    return PyFloat_FromDouble(d);
}

static PyObject *
getargs_D(PyObject *self, PyObject *args)
{
    Py_complex cval;
    if (!PyArg_ParseTuple(args, "D", &cval)) {
        return NULL;
    }
    return PyComplex_FromCComplex(cval);
}

static PyObject *
getargs_S(PyObject *self, PyObject *args)
{
    PyObject *obj;
    if (!PyArg_ParseTuple(args, "S", &obj)) {
        return NULL;
    }
    return Py_NewRef(obj);
}

static PyObject *
getargs_Y(PyObject *self, PyObject *args)
{
    PyObject *obj;
    if (!PyArg_ParseTuple(args, "Y", &obj)) {
        return NULL;
    }
    return Py_NewRef(obj);
}

static PyObject *
getargs_U(PyObject *self, PyObject *args)
{
    PyObject *obj;
    if (!PyArg_ParseTuple(args, "U", &obj)) {
        return NULL;
    }
    return Py_NewRef(obj);
}

static PyObject *
getargs_c(PyObject *self, PyObject *args)
{
    char c;
    if (!PyArg_ParseTuple(args, "c", &c)) {
        return NULL;
    }
    return PyLong_FromLong((unsigned char)c);
}

static PyObject *
getargs_C(PyObject *self, PyObject *args)
{
    int c;
    if (!PyArg_ParseTuple(args, "C", &c)) {
        return NULL;
    }
    return PyLong_FromLong(c);
}

static PyObject *
getargs_s(PyObject *self, PyObject *args)
{
    char *str;
    if (!PyArg_ParseTuple(args, "s", &str)) {
        return NULL;
    }
    return PyBytes_FromString(str);
}

static PyObject *
getargs_s_star(PyObject *self, PyObject *args)
{
    Py_buffer buffer;
    PyObject *bytes;
    if (!PyArg_ParseTuple(args, "s*", &buffer)) {
        return NULL;
    }
    bytes = PyBytes_FromStringAndSize(buffer.buf, buffer.len);
    PyBuffer_Release(&buffer);
    return bytes;
}

static PyObject *
getargs_s_hash(PyObject *self, PyObject *args)
{
    char *str;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "s#", &str, &size)) {
        return NULL;
    }
    return PyBytes_FromStringAndSize(str, size);
}

static PyObject *
getargs_z(PyObject *self, PyObject *args)
{
    char *str;
    if (!PyArg_ParseTuple(args, "z", &str)) {
        return NULL;
    }
    if (str != NULL) {
        return PyBytes_FromString(str);
    }
    Py_RETURN_NONE;
}

static PyObject *
getargs_z_star(PyObject *self, PyObject *args)
{
    Py_buffer buffer;
    PyObject *bytes;
    if (!PyArg_ParseTuple(args, "z*", &buffer)) {
        return NULL;
    }
    if (buffer.buf != NULL) {
        bytes = PyBytes_FromStringAndSize(buffer.buf, buffer.len);
    }
    else {
        bytes = Py_NewRef(Py_None);
    }
    PyBuffer_Release(&buffer);
    return bytes;
}

static PyObject *
getargs_z_hash(PyObject *self, PyObject *args)
{
    char *str;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "z#", &str, &size)) {
        return NULL;
    }
    if (str != NULL) {
        return PyBytes_FromStringAndSize(str, size);
    }
    Py_RETURN_NONE;
}

static PyObject *
getargs_y(PyObject *self, PyObject *args)
{
    char *str;
    if (!PyArg_ParseTuple(args, "y", &str)) {
        return NULL;
    }
    return PyBytes_FromString(str);
}

static PyObject *
getargs_y_star(PyObject *self, PyObject *args)
{
    Py_buffer buffer;
    if (!PyArg_ParseTuple(args, "y*", &buffer)) {
        return NULL;
    }
    PyObject *bytes = PyBytes_FromStringAndSize(buffer.buf, buffer.len);
    PyBuffer_Release(&buffer);
    return bytes;
}

static PyObject *
getargs_y_hash(PyObject *self, PyObject *args)
{
    char *str;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "y#", &str, &size)) {
        return NULL;
    }
    return PyBytes_FromStringAndSize(str, size);
}

static PyObject *
getargs_es(PyObject *self, PyObject *args)
{
    PyObject *arg;
    const char *encoding = NULL;
    char *str;

    if (!PyArg_ParseTuple(args, "O|s", &arg, &encoding)) {
        return NULL;
    }
    if (!PyArg_Parse(arg, "es", encoding, &str)) {
        return NULL;
    }
    PyObject *result = PyBytes_FromString(str);
    PyMem_Free(str);
    return result;
}

static PyObject *
getargs_et(PyObject *self, PyObject *args)
{
    PyObject *arg;
    const char *encoding = NULL;
    char *str;

    if (!PyArg_ParseTuple(args, "O|s", &arg, &encoding)) {
        return NULL;
    }
    if (!PyArg_Parse(arg, "et", encoding, &str)) {
        return NULL;
    }
    PyObject *result = PyBytes_FromString(str);
    PyMem_Free(str);
    return result;
}

static PyObject *
getargs_es_hash(PyObject *self, PyObject *args)
{
    PyObject *arg;
    const char *encoding = NULL;
    PyByteArrayObject *buffer = NULL;
    char *str = NULL;
    Py_ssize_t size;

    if (!PyArg_ParseTuple(args, "O|sY", &arg, &encoding, &buffer)) {
        return NULL;
    }
    if (buffer != NULL) {
        str = PyByteArray_AS_STRING(buffer);
        size = PyByteArray_GET_SIZE(buffer);
    }
    if (!PyArg_Parse(arg, "es#", encoding, &str, &size)) {
        return NULL;
    }
    PyObject *result = PyBytes_FromStringAndSize(str, size);
    if (buffer == NULL) {
        PyMem_Free(str);
    }
    return result;
}

static PyObject *
getargs_et_hash(PyObject *self, PyObject *args)
{
    PyObject *arg;
    const char *encoding = NULL;
    PyByteArrayObject *buffer = NULL;
    char *str = NULL;
    Py_ssize_t size;

    if (!PyArg_ParseTuple(args, "O|sY", &arg, &encoding, &buffer)) {
        return NULL;
    }
    if (buffer != NULL) {
        str = PyByteArray_AS_STRING(buffer);
        size = PyByteArray_GET_SIZE(buffer);
    }
    if (!PyArg_Parse(arg, "et#", encoding, &str, &size)) {
        return NULL;
    }
    PyObject *result = PyBytes_FromStringAndSize(str, size);
    if (buffer == NULL) {
        PyMem_Free(str);
    }
    return result;
}

static PyObject *
gh_99240_clear_args(PyObject *self, PyObject *args)
{
    char *a = NULL;
    char *b = NULL;

    if (!PyArg_ParseTuple(args, "eses", "idna", &a, "idna", &b)) {
        if (a || b) {
            PyErr_Clear();
            PyErr_SetString(PyExc_AssertionError, "Arguments are not cleared.");
        }
        return NULL;
    }
    PyMem_Free(a);
    PyMem_Free(b);
    Py_RETURN_NONE;
}

static PyMethodDef test_methods[] = {
    {"get_args",                get_args,                        METH_VARARGS},
    {"get_kwargs", _PyCFunction_CAST(get_kwargs), METH_VARARGS|METH_KEYWORDS},
    {"getargs_B",               getargs_B,                       METH_VARARGS},
    {"getargs_C",               getargs_C,                       METH_VARARGS},
    {"getargs_D",               getargs_D,                       METH_VARARGS},
    {"getargs_H",               getargs_H,                       METH_VARARGS},
    {"getargs_I",               getargs_I,                       METH_VARARGS},
    {"getargs_K",               getargs_K,                       METH_VARARGS},
    {"getargs_L",               getargs_L,                       METH_VARARGS},
    {"getargs_S",               getargs_S,                       METH_VARARGS},
    {"getargs_U",               getargs_U,                       METH_VARARGS},
    {"getargs_Y",               getargs_Y,                       METH_VARARGS},
    {"getargs_b",               getargs_b,                       METH_VARARGS},
    {"getargs_c",               getargs_c,                       METH_VARARGS},
    {"getargs_d",               getargs_d,                       METH_VARARGS},
    {"getargs_es",              getargs_es,                      METH_VARARGS},
    {"getargs_es_hash",         getargs_es_hash,                 METH_VARARGS},
    {"getargs_et",              getargs_et,                      METH_VARARGS},
    {"getargs_et_hash",         getargs_et_hash,                 METH_VARARGS},
    {"getargs_f",               getargs_f,                       METH_VARARGS},
    {"getargs_h",               getargs_h,                       METH_VARARGS},
    {"getargs_i",               getargs_i,                       METH_VARARGS},
    {"getargs_k",               getargs_k,                       METH_VARARGS},
    {"getargs_keyword_only", _PyCFunction_CAST(getargs_keyword_only), METH_VARARGS|METH_KEYWORDS},
    {"getargs_keywords", _PyCFunction_CAST(getargs_keywords), METH_VARARGS|METH_KEYWORDS},
    {"getargs_l",               getargs_l,                       METH_VARARGS},
    {"getargs_n",               getargs_n,                       METH_VARARGS},
    {"getargs_p",               getargs_p,                       METH_VARARGS},
    {"getargs_positional_only_and_keywords", _PyCFunction_CAST(getargs_positional_only_and_keywords), METH_VARARGS|METH_KEYWORDS},
    {"getargs_s",               getargs_s,                       METH_VARARGS},
    {"getargs_s_hash",          getargs_s_hash,                  METH_VARARGS},
    {"getargs_s_star",          getargs_s_star,                  METH_VARARGS},
    {"getargs_tuple",           getargs_tuple,                   METH_VARARGS},
    {"getargs_w_star",          getargs_w_star,                  METH_VARARGS},
    {"getargs_w_star_opt",      getargs_w_star_opt,              METH_VARARGS},
    {"getargs_empty",           _PyCFunction_CAST(getargs_empty), METH_VARARGS|METH_KEYWORDS},
    {"getargs_y",               getargs_y,                       METH_VARARGS},
    {"getargs_y_hash",          getargs_y_hash,                  METH_VARARGS},
    {"getargs_y_star",          getargs_y_star,                  METH_VARARGS},
    {"getargs_z",               getargs_z,                       METH_VARARGS},
    {"getargs_z_hash",          getargs_z_hash,                  METH_VARARGS},
    {"getargs_z_star",          getargs_z_star,                  METH_VARARGS},
    {"parse_tuple_and_keywords", parse_tuple_and_keywords,       METH_VARARGS},
    {"gh_99240_clear_args",     gh_99240_clear_args,             METH_VARARGS},
    {"test_w_code_invalid",     test_w_code_invalid,             METH_NOARGS},
    {NULL},
};

int
_PyTestCapi_Init_GetArgs(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/hash.c
================================================
#include "parts.h"
#include "util.h"

static PyObject *
hash_getfuncdef(PyObject *Py_UNUSED(module), PyObject *Py_UNUSED(args))
{
    // bind PyHash_GetFuncDef()
    PyHash_FuncDef *def = PyHash_GetFuncDef();

    PyObject *types = PyImport_ImportModule("types");
    if (types == NULL) {
        return NULL;
    }

    PyObject *result = PyObject_CallMethod(types, "SimpleNamespace", NULL);
    Py_DECREF(types);
    if (result == NULL) {
        return NULL;
    }

    // ignore PyHash_FuncDef.hash

    PyObject *value = PyUnicode_FromString(def->name);
    int res = PyObject_SetAttrString(result, "name", value);
    Py_DECREF(value);
    if (res < 0) {
        return NULL;
    }

    value = PyLong_FromLong(def->hash_bits);
    res = PyObject_SetAttrString(result, "hash_bits", value);
    Py_DECREF(value);
    if (res < 0) {
        return NULL;
    }

    value = PyLong_FromLong(def->seed_bits);
    res = PyObject_SetAttrString(result, "seed_bits", value);
    Py_DECREF(value);
    if (res < 0) {
        return NULL;
    }

    return result;
}


static PyObject *
long_from_hash(Py_hash_t hash)
{
    Py_BUILD_ASSERT(sizeof(long long) >= sizeof(hash));
    return PyLong_FromLongLong(hash);
}


static PyObject *
hash_pointer(PyObject *Py_UNUSED(module), PyObject *arg)
{
    void *ptr = PyLong_AsVoidPtr(arg);
    if (ptr == NULL && PyErr_Occurred()) {
        return NULL;
    }

    Py_hash_t hash = Py_HashPointer(ptr);
    return long_from_hash(hash);
}


static PyObject *
hash_buffer(PyObject *Py_UNUSED(module), PyObject *args)
{
    char *ptr;
    Py_ssize_t len;
    if (!PyArg_ParseTuple(args, "y#", &ptr, &len)) {
        return NULL;
    }

    Py_hash_t hash = Py_HashBuffer(ptr, len);
    return long_from_hash(hash);
}


static PyObject *
object_generichash(PyObject *Py_UNUSED(module), PyObject *arg)
{
    NULLABLE(arg);
    Py_hash_t hash = PyObject_GenericHash(arg);
    return long_from_hash(hash);
}


static PyMethodDef test_methods[] = {
    {"hash_getfuncdef", hash_getfuncdef, METH_NOARGS},
    {"hash_pointer", hash_pointer, METH_O},
    {"hash_buffer", hash_buffer, METH_VARARGS},
    {"object_generichash", object_generichash, METH_O},
    {NULL},
};

int
_PyTestCapi_Init_Hash(PyObject *m)
{
    return PyModule_AddFunctions(m, test_methods);
}


================================================
File: /Modules/_testcapi/heaptype.c
================================================
#include "parts.h"
#include <stddef.h>               // offsetof()


static struct PyModuleDef *_testcapimodule = NULL;  // set at initialization

/* Tests for heap types (PyType_From*) */

static PyObject *pytype_fromspec_meta(PyObject* self, PyObject *meta)
{
    if (!PyType_Check(meta)) {
        PyErr_SetString(
            PyExc_TypeError,
            "pytype_fromspec_meta: must be invoked with a type argument!");
        return NULL;
    }

    PyType_Slot HeapCTypeViaMetaclass_slots[] = {
        {0},
    };

    PyType_Spec HeapCTypeViaMetaclass_spec = {
        "_testcapi.HeapCTypeViaMetaclass",
        sizeof(PyObject),
        0,
        Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        HeapCTypeViaMetaclass_slots
    };

    return PyType_FromMetaclass(
        (PyTypeObject *) meta, NULL, &HeapCTypeViaMetaclass_spec, NULL);
}


static PyType_Slot empty_type_slots[] = {
    {0, 0},
};

static PyType_Spec MinimalMetaclass_spec = {
    .name = "_testcapi.MinimalMetaclass",
    .basicsize = sizeof(PyHeapTypeObject),
    .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .slots = empty_type_slots,
};

static PyType_Spec MinimalType_spec = {
    .name = "_testcapi.MinimalSpecType",
    .basicsize = 0,  // Updated later
    .flags = Py_TPFLAGS_DEFAULT,
    .slots = empty_type_slots,
};


static PyObject *
test_from_spec_metatype_inheritance(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    PyObject *metaclass = NULL;
    PyObject *class = NULL;
    PyObject *new = NULL;
    PyObject *subclasses = NULL;
    PyObject *result = NULL;
    int r;

    metaclass = PyType_FromSpecWithBases(&MinimalMetaclass_spec, (PyObject*)&PyType_Type);
    if (metaclass == NULL) {
        goto finally;
    }
    class = PyObject_CallFunction(metaclass, "s(){}", "TestClass");
    if (class == NULL) {
        goto finally;
    }

    MinimalType_spec.basicsize = (int)(((PyTypeObject*)class)->tp_basicsize);
    new = PyType_FromSpecWithBases(&MinimalType_spec, class);
    if (new == NULL) {
        goto finally;
    }
    if (Py_TYPE(new) != (PyTypeObject*)metaclass) {
        PyErr_SetString(PyExc_AssertionError,
                "Metaclass not set properly!");
        goto finally;
    }

    /* Assert that __subclasses__ is updated */
    subclasses = PyObject_CallMethod(class, "__subclasses__", "");
    if (!subclasses) {
        goto finally;
    }
    r = PySequence_Contains(subclasses, new);
    if (r < 0) {
        goto finally;
    }
    if (r == 0) {
        PyErr_SetString(PyExc_AssertionError,
                "subclasses not set properly!");
        goto finally;
    }

    result = Py_NewRef(Py_None);

finally:
    Py_XDECREF(metaclass);
    Py_XDECREF(class);
    Py_XDECREF(new);
    Py_XDECREF(subclasses);
    return result;
}


static PyObject *
test_from_spec_invalid_metatype_inheritance(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    PyObject *metaclass_a = NULL;
    PyObject *metaclass_b = NULL;
    PyObject *class_a = NULL;
    PyObject *class_b = NULL;
    PyObject *bases = NULL;
    PyObject *new = NULL;
    PyObject *meta_error_string = NULL;
    PyObject *exc = NULL;
    PyObject *result = NULL;
    PyObject *message = NULL;
    PyObject *args = NULL;

    metaclass_a = PyType_FromSpecWithBases(&MinimalMetaclass_spec, (PyObject*)&PyType_Type);
    if (metaclass_a == NULL) {
        goto finally;
    }
    metaclass_b = PyType_FromSpecWithBases(&MinimalMetaclass_spec, (PyObject*)&PyType_Type);
    if (metaclass_b == NULL) {
        goto finally;
    }
    class_a = PyObject_CallFunction(metaclass_a, "s(){}", "TestClassA");
    if (class_a == NULL) {
        goto finally;
    }

    class_b = PyObject_CallFunction(metaclass_b, "s(){}", "TestClassB");
    if (class_b == NULL) {
        goto finally;
    }

    bases = PyTuple_Pack(2, class_a, class_b);
    if (bases == NULL) {
        goto finally;
    }

    /*
     * The following should raise a TypeError due to a MetaClass conflict.
     */
    new = PyType_FromSpecWithBases(&MinimalType_spec, bases);
    if (new != NULL) {
        PyErr_SetString(PyExc_AssertionError,
                "MetaType conflict not recognized by PyType_FromSpecWithBases");
            goto finally;
    }

    // Assert that the correct exception was raised
    if (PyErr_ExceptionMatches(PyExc_TypeError)) {
        exc = PyErr_GetRaisedException();
        args = PyException_GetArgs(exc);
        if (!PyTuple_Check(args) || PyTuple_Size(args) != 1) {
            PyErr_SetString(PyExc_AssertionError,
                    "TypeError args are not a one-tuple");
            goto finally;
        }
        message = Py_NewRef(PyTuple_GET_ITEM(args, 0));
        meta_error_string = PyUnicode_FromString("metaclass conflict:");
        if (meta_error_string == NULL) {
            goto finally;
        }
        int res = PyUnicode_Contains(message, meta_error_string);
        if (res < 0) {
            goto finally;
        }
        if (res == 0) {
            PyErr_SetString(PyExc_AssertionError,
                    "TypeError did not include expected message.");
            goto finally;
        }
        result = Py_NewRef(Py_None);
    }
finally:
    Py_XDECREF(metaclass_a);
    Py_XDECREF(metaclass_b);
    Py_XDECREF(bases);
    Py_XDECREF(new);
    Py_XDECREF(meta_error_string);
    Py_XDECREF(exc);
    Py_XDECREF(message);
    Py_XDECREF(class_a);
    Py_XDECREF(class_b);
    Py_XDECREF(args);
    return result;
}


static PyObject *
simple_str(PyObject *self) {
    return PyUnicode_FromString("<test>");
}


static PyObject *
test_type_from_ephemeral_spec(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    // Test that a heap type can be created from a spec that's later deleted
    // (along with all its contents).
    // All necessary data must be copied and held by the class
    PyType_Spec *spec = NULL;
    char *name = NULL;
    char *doc = NULL;
    PyType_Slot *slots = NULL;
    PyObject *class = NULL;
    PyObject *instance = NULL;
    PyObject *obj = NULL;
    PyObject *result = NULL;

    /* create a spec (and all its contents) on the heap */

    const char NAME[] = "testcapi._Test";
    const char DOC[] = "a test class";

    spec = PyMem_New(PyType_Spec, 1);
    if (spec == NULL) {
        PyErr_NoMemory();
        goto finally;
    }
    name = PyMem_New(char, sizeof(NAME));
    if (name == NULL) {
        PyErr_NoMemory();
        goto finally;
    }
    memcpy(name, NAME, sizeof(NAME));

    doc = PyMem_New(char, sizeof(DOC));
    if (doc == NULL) {
        PyErr_NoMemory();
        goto finally;
    }
    memcpy(doc, DOC, sizeof(DOC));

    spec->name = name;
    spec->basicsize = sizeof(PyObject);
    spec->itemsize = 0;
    spec->flags = Py_TPFLAGS_DEFAULT;
    slots = PyMem_New(PyType_Slot, 3);
    if (slots == NULL) {
        PyErr_NoMemory();
        goto finally;
    }
    slots[0].slot = Py_tp_str;
    slots[0].pfunc = simple_str;
    slots[1].slot = Py_tp_doc;
    slots[1].pfunc = doc;
    slots[2].slot = 0;
    slots[2].pfunc = NULL;
    spec->slots = slots;

    /* create the class */

    class = PyType_FromSpec(spec);
    if (class == NULL) {
        goto finally;
    }

    /* deallocate the spec (and all contents) */

    // (Explicitly overwrite memory before freeing,
    // so bugs show themselves even without the debug allocator's help.)
    memset(spec, 0xdd, sizeof(PyType_Spec));
    PyMem_Free(spec);
    spec = NULL;
    memset(name, 0xdd, sizeof(NAME));
    PyMem_Free(name);
    name = NULL;
    memset(doc, 0xdd, sizeof(DOC));
    PyMem_Free(doc);
    doc = NULL;
    memset(slots, 0xdd, 3 * sizeof(PyType_Slot));
    PyMem_Free(slots);
    slots = NULL;

    /* check that everything works */

    PyTypeObject *class_tp = (PyTypeObject *)class;
    PyHeapTypeObject *class_ht = (PyHeapTypeObject *)class;
    assert(strcmp(class_tp->tp_name, "testcapi._Test") == 0);
    assert(strcmp(PyUnicode_AsUTF8(class_ht->ht_name), "_Test") == 0);
    assert(strcmp(PyUnicode_AsUTF8(class_ht->ht_qualname), "_Test") == 0);
    assert(strcmp(class_tp->tp_doc, "a test class") == 0);

    // call and check __str__
    instance = PyObject_CallNoArgs(class);
    if (instance == NULL) {
        goto finally;
    }
    obj = PyObject_Str(instance);
    if (obj == NULL) {
        goto finally;
    }
    assert(strcmp(PyUnicode_AsUTF8(obj), "<test>") == 0);
    Py_CLEAR(obj);

    result = Py_NewRef(Py_None);
  finally:
    PyMem_Free(spec);
    PyMem_Free(name);
    PyMem_Free(doc);
    PyMem_Free(slots);
    Py_XDECREF(class);
    Py_XDECREF(instance);
    Py_XDECREF(obj);
    return result;
}

PyType_Slot repeated_doc_slots[] = {
    {Py_tp_doc, "A class used for tests·"},
    {Py_tp_doc, "A class used for tests"},
    {0, 0},
};

PyType_Spec repeated_doc_slots_spec = {
    .name = "RepeatedDocSlotClass",
    .basicsize = sizeof(PyObject),
    .slots = repeated_doc_slots,
};

typedef struct {
    PyObject_HEAD
    int data;
} HeapCTypeWithDataObject;


static struct PyMemberDef members_to_repeat[] = {
    {"Py_T_INT", Py_T_INT, offsetof(HeapCTypeWithDataObject, data), 0, NULL},
    {NULL}
};

PyType_Slot repeated_members_slots[] = {
    {Py_tp_members, members_to_repeat},
    {Py_tp_members, members_to_repeat},
    {0, 0},
};

PyType_Spec repeated_members_slots_spec = {
    .name = "RepeatedMembersSlotClass",
    .basicsize = sizeof(HeapCTypeWithDataObject),
    .slots = repeated_members_slots,
};

static PyObject *
create_type_from_repeated_slots(PyObject *self, PyObject *variant_obj)
{
    PyObject *class = NULL;
    int variant = PyLong_AsLong(variant_obj);
    if (PyErr_Occurred()) {
        return NULL;
    }
    switch (variant) {
        case 0:
            class = PyType_FromSpec(&repeated_doc_slots_spec);
            break;
        case 1:
            class = PyType_FromSpec(&repeated_members_slots_spec);
            break;
        default:
            PyErr_SetString(PyExc_ValueError, "bad test variant");
            break;
        }
    return class;
}


static PyObject *
make_immutable_type_with_base(PyObject *self, PyObject *base)
{
    assert(PyType_Check(base));
    PyType_Spec ImmutableSubclass_spec = {
        .name = "ImmutableSubclass",
        .basicsize = (int)((PyTypeObject*)base)->tp_basicsize,
        .slots = empty_type_slots,
        .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_IMMUTABLETYPE,
    };
    return PyType_FromSpecWithBases(&ImmutableSubclass_spec, base);
}

static PyObject *
make_type_with_base(PyObject *self, PyObject *base)
{
    assert(PyType_Check(base));
    PyType_Spec ImmutableSubclass_spec = {
        .name = "_testcapi.Subclass",
        .basicsize = (int)((PyTypeObject*)base)->tp_basicsize,
        .slots = empty_type_slots,
        .flags = Py_TPFLAGS_DEFAULT,
    };
    return PyType_FromSpecWithBases(&ImmutableSubclass_spec, base);
}


static PyObject *
pyobject_getitemdata(PyObject *self, PyObject *o)
{
    void *pointer = PyObject_GetItemData(o);
    if (pointer == NULL) {
        return NULL;
    }
    return PyLong_FromVoidPtr(pointer);
}


static PyObject *
create_type_with_token(PyObject *module, PyObject *args)
{
    const char *name;
    PyObject *py_token;
    if (!PyArg_ParseTuple(args, "sO", &name, &py_token)) {
        return NULL;
    }
    void *token = PyLong_AsVoidPtr(py_token);
    if (token == Py_TP_USE_SPEC) {
        // Py_TP_USE_SPEC requires the spec that at least outlives the class
        static PyType_Slot slots[] = {
            {Py_tp_token, Py_TP_USE_SPEC},
            {0},
        };
        static PyType_Spec spec = {
            .name = "_testcapi.DefaultTokenTest",
            .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
            .slots = slots,
        };
        PyObject *type = PyType_FromMetaclass(NULL, NULL, &spec, NULL);
        if (!type) {
            return NULL;
        }
        token = PyType_GetSlot((PyTypeObject *)type, Py_tp_token);
        assert(!PyErr_Occurred());
        Py_DECREF(type);
        if (token != &spec) {
            PyErr_SetString(PyExc_AssertionError,
                            "failed to convert token from Py_TP_USE_SPEC");
            return NULL;
        }
    }
    // Test non-NULL token that must also outlive the class
    PyType_Slot slots[] = {
        {Py_tp_token, token},
        {0},
    };
    PyType_Spec spec = {
        .name = name,
        .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        .slots = slots,
    };
    return PyType_FromMetaclass(NULL, module, &spec, NULL);
}

static PyObject *
get_tp_token(PyObject *self, PyObject *type)
{
    void *token = PyType_GetSlot((PyTypeObject *)type, Py_tp_token);
    if (PyErr_Occurred()) {
        return NULL;
    }
    return PyLong_FromVoidPtr(token);
}

static PyObject *
pytype_getbasebytoken(PyObject *self, PyObject *args)
{
    PyTypeObject *type;
    PyObject *py_token, *use_mro, *need_result;
    if (!PyArg_ParseTuple(args, "OOOO",
                          &type, &py_token, &use_mro, &need_result)) {
        return NULL;
    }

    PyObject *mro_save = NULL;
    if (use_mro != Py_True) {
        // Test internal detail: PyType_GetBaseByToken works even with
        // types that are only partially initialized (or torn down):
        // if tp_mro=NULL we fall back to tp_bases.
        assert(PyType_Check(type));
        mro_save = type->tp_mro;
        type->tp_mro = NULL;
    }

    void *token = PyLong_AsVoidPtr(py_token);
    PyObject *result;
    int ret;
    if (need_result == Py_True) {
        ret = PyType_GetBaseByToken(type, token, (PyTypeObject **)&result);
    }
    else {
        result = NULL;
        ret = PyType_GetBaseByToken(type, token, NULL);
    }

    if (use_mro != Py_True) {
        type->tp_mro = mro_save;
    }
    if (ret < 0) {
        assert(result == NULL);
        return NULL;
    }
    PyObject *py_ret = PyLong_FromLong(ret);
    if (py_ret == NULL) {
        goto error;
    }
    PyObject *tuple = PyTuple_New(2);
    if (tuple == NULL) {
        goto error;
    }
    PyTuple_SET_ITEM(tuple, 0, py_ret);
    PyTuple_SET_ITEM(tuple, 1, result ? result : Py_None);
    return tuple;
error:
    Py_XDECREF(py_ret);
    Py_XDECREF(result);
    return NULL;
}


static PyMethodDef TestMethods[] = {
    {"pytype_fromspec_meta",    pytype_fromspec_meta,            METH_O},
    {"test_type_from_ephemeral_spec", test_type_from_ephemeral_spec, METH_NOARGS},
    {"create_type_from_repeated_slots",
        create_type_from_repeated_slots, METH_O},
    {"test_from_spec_metatype_inheritance", test_from_spec_metatype_inheritance,
     METH_NOARGS},
    {"test_from_spec_invalid_metatype_inheritance",
     test_from_spec_invalid_metatype_inheritance,
     METH_NOARGS},
    {"make_immutable_type_with_base", make_immutable_type_with_base, METH_O},
    {"make_type_with_base", make_type_with_base, METH_O},
    {"pyobject_getitemdata", pyobject_getitemdata, METH_O},
    {"create_type_with_token", create_type_with_token, METH_VARARGS},
    {"get_tp_token", get_tp_token, METH_O},
    {"pytype_getbasebytoken", pytype_getbasebytoken, METH_VARARGS},
    {NULL},
};


PyDoc_STRVAR(heapdocctype__doc__,
"HeapDocCType(arg1, arg2)\n"
"--\n"
"\n"
"somedoc");

typedef struct {
    PyObject_HEAD
} HeapDocCTypeObject;

static PyType_Slot HeapDocCType_slots[] = {
    {Py_tp_doc, (char*)heapdocctype__doc__},
    {0},
};

static PyType_Spec HeapDocCType_spec = {
    "_testcapi.HeapDocCType",
    sizeof(HeapDocCTypeObject),
    0,
    Py_TPFLAGS_DEFAULT,
    HeapDocCType_slots
};

typedef struct {
    PyObject_HEAD
} NullTpDocTypeObject;

static PyType_Slot NullTpDocType_slots[] = {
    {Py_tp_doc, NULL},
    {0, 0},
};

static PyType_Spec NullTpDocType_spec = {
    "_testcapi.NullTpDocType",
    sizeof(NullTpDocTypeObject),
    0,
    Py_TPFLAGS_DEFAULT,
    NullTpDocType_slots
};


PyDoc_STRVAR(heapgctype__doc__,
"A heap type with GC, and with overridden dealloc.\n\n"
"The 'value' attribute is set to 10 in __init__.");

typedef struct {
    PyObject_HEAD
    int value;
} HeapCTypeObject;

static struct PyMemberDef heapctype_members[] = {
    {"value", Py_T_INT, offsetof(HeapCTypeObject, value)},
    {NULL} /* Sentinel */
};

static int
heapctype_init(PyObject *self, PyObject *args, PyObject *kwargs)
{
    ((HeapCTypeObject *)self)->value = 10;
    return 0;
}

static int
heapgcctype_traverse(HeapCTypeObject *self, visitproc visit, void *arg)
{
    Py_VISIT(Py_TYPE(self));
    return 0;
}

static void
heapgcctype_dealloc(HeapCTypeObject *self)
{
    PyTypeObject *tp = Py_TYPE(self);
    PyObject_GC_UnTrack(self);
    PyObject_GC_Del(self);
    Py_DECREF(tp);
}

static PyType_Slot HeapGcCType_slots[] = {
    {Py_tp_init, heapctype_init},
    {Py_tp_members, heapctype_members},
    {Py_tp_dealloc, heapgcctype_dealloc},
    {Py_tp_traverse, heapgcctype_traverse},
    {Py_tp_doc, (char*)heapgctype__doc__},
    {0, 0},
};

static PyType_Spec HeapGcCType_spec = {
    "_testcapi.HeapGcCType",
    sizeof(HeapCTypeObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
    HeapGcCType_slots
};

PyDoc_STRVAR(heapctype__doc__,
"A heap type without GC, but with overridden dealloc.\n\n"
"The 'value' attribute is set to 10 in __init__.");

static void
heapctype_dealloc(HeapCTypeObject *self)
{
    PyTypeObject *tp = Py_TYPE(self);
    PyObject_Free(self);
    Py_DECREF(tp);
}

static PyType_Slot HeapCType_slots[] = {
    {Py_tp_init, heapctype_init},
    {Py_tp_members, heapctype_members},
    {Py_tp_dealloc, heapctype_dealloc},
    {Py_tp_doc, (char*)heapctype__doc__},
    {0, 0},
};

static PyType_Spec HeapCType_spec = {
    "_testcapi.HeapCType",
    sizeof(HeapCTypeObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    HeapCType_slots
};

PyDoc_STRVAR(heapctypesubclass__doc__,
"Subclass of HeapCType, without GC.\n\n"
"__init__ sets the 'value' attribute to 10 and 'value2' to 20.");

typedef struct {
    HeapCTypeObject base;
    int value2;
} HeapCTypeSubclassObject;

static int
heapctypesubclass_init(PyObject *self, PyObject *args, PyObject *kwargs)
{
    /* Call __init__ of the superclass */
    if (heapctype_init(self, args, kwargs) < 0) {
        return -1;
    }
    /* Initialize additional element */
    ((HeapCTypeSubclassObject *)self)->value2 = 20;
    return 0;
}

static struct PyMemberDef heapctypesubclass_members[] = {
    {"value2", Py_T_INT, offsetof(HeapCTypeSubclassObject, value2)},
    {NULL} /* Sentinel */
};

static PyType_Slot HeapCTypeSubclass_slots[] = {
    {Py_tp_init, heapctypesubclass_init},
    {Py_tp_members, heapctypesubclass_members},
    {Py_tp_doc, (char*)heapctypesubclass__doc__},
    {0, 0},
};

static PyType_Spec HeapCTypeSubclass_spec = {
    "_testcapi.HeapCTypeSubclass",
    sizeof(HeapCTypeSubclassObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    HeapCTypeSubclass_slots
};

PyDoc_STRVAR(heapctypewithbuffer__doc__,
"Heap type with buffer support.\n\n"
"The buffer is set to [b'1', b'2', b'3', b'4']");

typedef struct {
    HeapCTypeObject base;
    char buffer[4];
} HeapCTypeWithBufferObject;

static int
heapctypewithbuffer_getbuffer(HeapCTypeWithBufferObject *self, Py_buffer *view, int flags)
{
    self->buffer[0] = '1';
    self->buffer[1] = '2';
    self->buffer[2] = '3';
    self->buffer[3] = '4';
    return PyBuffer_FillInfo(
        view, (PyObject*)self, (void *)self->buffer, 4, 1, flags);
}

static void
heapctypewithbuffer_releasebuffer(HeapCTypeWithBufferObject *self, Py_buffer *view)
{
    assert(view->obj == (void*) self);
}

static PyType_Slot HeapCTypeWithBuffer_slots[] = {
    {Py_bf_getbuffer, heapctypewithbuffer_getbuffer},
    {Py_bf_releasebuffer, heapctypewithbuffer_releasebuffer},
    {Py_tp_doc, (char*)heapctypewithbuffer__doc__},
    {0, 0},
};

static PyType_Spec HeapCTypeWithBuffer_spec = {
    "_testcapi.HeapCTypeWithBuffer",
    sizeof(HeapCTypeWithBufferObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    HeapCTypeWithBuffer_slots
};

PyDoc_STRVAR(heapctypesubclasswithfinalizer__doc__,
"Subclass of HeapCType with a finalizer that reassigns __class__.\n\n"
"__class__ is set to plain HeapCTypeSubclass during finalization.\n"
"__init__ sets the 'value' attribute to 10 and 'value2' to 20.");

static int
heapctypesubclasswithfinalizer_init(PyObject *self, PyObject *args, PyObject *kwargs)
{
    PyTypeObject *base = (PyTypeObject *)PyType_GetSlot(Py_TYPE(self), Py_tp_base);
    initproc base_init = PyType_GetSlot(base, Py_tp_init);
    base_init(self, args, kwargs);
    return 0;
}

static void
heapctypesubclasswithfinalizer_finalize(PyObject *self)
{
    PyObject *oldtype = NULL, *newtype = NULL, *refcnt = NULL;

    /* Save the current exception, if any. */
    PyObject *exc = PyErr_GetRaisedException();

    if (_testcapimodule == NULL) {
        goto cleanup_finalize;
    }
    PyObject *m = PyState_FindModule(_testcapimodule);
    if (m == NULL) {
        goto cleanup_finalize;
    }
    oldtype = PyObject_GetAttrString(m, "HeapCTypeSubclassWithFinalizer");
    if (oldtype == NULL) {
        goto cleanup_finalize;
    }
    newtype = PyObject_GetAttrString(m, "HeapCTypeSubclass");
    if (newtype == NULL) {
        goto cleanup_finalize;
    }

    if (PyObject_SetAttrString(self, "__class__", newtype) < 0) {
        goto cleanup_finalize;
    }
    refcnt = PyLong_FromSsize_t(Py_REFCNT(oldtype));
    if (refcnt == NULL) {
        goto cleanup_finalize;
    }
    if (PyObject_SetAttrString(oldtype, "refcnt_in_del", refcnt) < 0) {
        goto cleanup_finalize;
    }
    Py_DECREF(refcnt);
    refcnt = PyLong_FromSsize_t(Py_REFCNT(newtype));
    if (refcnt == NULL) {
        goto cleanup_finalize;
    }
    if (PyObject_SetAttrString(newtype, "refcnt_in_del", refcnt) < 0) {
        goto cleanup_finalize;
    }

cleanup_finalize:
    Py_XDECREF(oldtype);
    Py_XDECREF(newtype);
    Py_XDECREF(refcnt);

    /* Restore the saved exception. */
    PyErr_SetRaisedException(exc);
}

static PyType_Slot HeapCTypeSubclassWithFinalizer_slots[] = {
    {Py_tp_init, heapctypesubclasswithfinalizer_init},
    {Py_tp_members, heapctypesubclass_members},
    {Py_tp_finalize, heapctypesubclasswithfinalizer_finalize},
    {Py_tp_doc, (char*)heapctypesubclasswithfinalizer__doc__},
    {0, 0},
};

static PyType_Spec HeapCTypeSubclassWithFinalizer_spec = {
    "_testcapi.HeapCTypeSubclassWithFinalizer",
    sizeof(HeapCTypeSubclassObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_FINALIZE,
    HeapCTypeSubclassWithFinalizer_slots
};

static PyType_Slot HeapCTypeMetaclass_slots[] = {
    {0},
};

static PyType_Spec HeapCTypeMetaclass_spec = {
    "_testcapi.HeapCTypeMetaclass",
    sizeof(PyHeapTypeObject),
    sizeof(PyMemberDef),
    Py_TPFLAGS_DEFAULT,
    HeapCTypeMetaclass_slots
};

static PyObject *
heap_ctype_metaclass_custom_tp_new(PyTypeObject *tp, PyObject *args, PyObject *kwargs)
{
    return PyType_Type.tp_new(tp, args, kwargs);
}

static PyType_Slot HeapCTypeMetaclassCustomNew_slots[] = {
    { Py_tp_new, heap_ctype_metaclass_custom_tp_new },
    {0},
};

static PyType_Spec HeapCTypeMetaclassCustomNew_spec = {
    "_testcapi.HeapCTypeMetaclassCustomNew",
    sizeof(PyHeapTypeObject),
    sizeof(PyMemberDef),
    Py_TPFLAGS_DEFAULT,
    HeapCTypeMetaclassCustomNew_slots
};

static PyType_Spec HeapCTypeMetaclassNullNew_spec = {
    .name = "_testcapi.HeapCTypeMetaclassNullNew",
    .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,
    .slots = empty_type_slots
};


typedef struct {
    PyObject_HEAD
    PyObject *dict;
} HeapCTypeWithDictObject;

static void
heapctypewithdict_dealloc(HeapCTypeWithDictObject* self)
{

    PyTypeObject *tp = Py_TYPE(self);
    Py_XDECREF(self->dict);
    PyObject_Free(self);
    Py_DECREF(tp);
}

static PyGetSetDef heapctypewithdict_getsetlist[] = {
    {"__dict__", PyObject_GenericGetDict, PyObject_GenericSetDict},
    {NULL} /* Sentinel */
};

static struct PyMemberDef heapctypewithdict_members[] = {
    {"dictobj", _Py_T_OBJECT, offsetof(HeapCTypeWithDictObject, dict)},
    {"__dictoffset__", Py_T_PYSSIZET, offsetof(HeapCTypeWithDictObject, dict), Py_READONLY},
    {NULL} /* Sentinel */
};

static PyType_Slot HeapCTypeWithDict_slots[] = {
    {Py_tp_members, heapctypewithdict_members},
    {Py_tp_getset, heapctypewithdict_getsetlist},
    {Py_tp_dealloc, heapctypewithdict_dealloc},
    {0, 0},
};

static PyType_Spec HeapCTypeWithDict_spec = {
    "_testcapi.HeapCTypeWithDict",
    sizeof(HeapCTypeWithDictObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    HeapCTypeWithDict_slots
};

static PyType_Spec HeapCTypeWithDict2_spec = {
    "_testcapi.HeapCTypeWithDict2",
    sizeof(HeapCTypeWithDictObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    HeapCTypeWithDict_slots
};

static int
heapmanaged_traverse(HeapCTypeObject *self, visitproc visit, void *arg)
{
    Py_VISIT(Py_TYPE(self));
    return PyObject_VisitManagedDict((PyObject *)self, visit, arg);
}

static int
heapmanaged_clear(HeapCTypeObject *self)
{
    PyObject_ClearManagedDict((PyObject *)self);
    return 0;
}

static void
heapmanaged_dealloc(HeapCTypeObject *self)
{
    PyTypeObject *tp = Py_TYPE(self);
    PyObject_ClearManagedDict((PyObject *)self);
    PyObject_GC_UnTrack(self);
    PyObject_GC_Del(self);
    Py_DECREF(tp);
}

static PyType_Slot HeapCTypeWithManagedDict_slots[] = {
    {Py_tp_traverse, heapmanaged_traverse},
    {Py_tp_getset, heapctypewithdict_getsetlist},
    {Py_tp_clear, heapmanaged_clear},
    {Py_tp_dealloc, heapmanaged_dealloc},
    {0, 0},
};

static PyType_Spec  HeapCTypeWithManagedDict_spec = {
    "_testcapi.HeapCTypeWithManagedDict",
    sizeof(PyObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT,
    HeapCTypeWithManagedDict_slots
};

static void
heapctypewithmanagedweakref_dealloc(PyObject* self)
{

    PyTypeObject *tp = Py_TYPE(self);
    PyObject_ClearWeakRefs(self);
    PyObject_GC_UnTrack(self);
    PyObject_GC_Del(self);
    Py_DECREF(tp);
}

static PyType_Slot HeapCTypeWithManagedWeakref_slots[] = {
    {Py_tp_traverse, heapgcctype_traverse},
    {Py_tp_getset, heapctypewithdict_getsetlist},
    {Py_tp_dealloc, heapctypewithmanagedweakref_dealloc},
    {0, 0},
};

static PyType_Spec  HeapCTypeWithManagedWeakref_spec = {
    "_testcapi.HeapCTypeWithManagedWeakref",
    sizeof(PyObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_WEAKREF,
    HeapCTypeWithManagedWeakref_slots
};

static struct PyMemberDef heapctypewithnegativedict_members[] = {
    {"dictobj", _Py_T_OBJECT, offsetof(HeapCTypeWithDictObject, dict)},
    {"__dictoffset__", Py_T_PYSSIZET, -(Py_ssize_t)sizeof(void*), Py_READONLY},
    {NULL} /* Sentinel */
};

static PyType_Slot HeapCTypeWithNegativeDict_slots[] = {
    {Py_tp_members, heapctypewithnegativedict_members},
    {Py_tp_getset, heapctypewithdict_getsetlist},
    {Py_tp_dealloc, heapctypewithdict_dealloc},
    {0, 0},
};

static PyType_Spec HeapCTypeWithNegativeDict_spec = {
    "_testcapi.HeapCTypeWithNegativeDict",
    sizeof(HeapCTypeWithDictObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    HeapCTypeWithNegativeDict_slots
};

typedef struct {
    PyObject_HEAD
    PyObject *weakreflist;
} HeapCTypeWithWeakrefObject;

static struct PyMemberDef heapctypewithweakref_members[] = {
    {"weakreflist", _Py_T_OBJECT, offsetof(HeapCTypeWithWeakrefObject, weakreflist)},
    {"__weaklistoffset__", Py_T_PYSSIZET,
      offsetof(HeapCTypeWithWeakrefObject, weakreflist), Py_READONLY},
    {NULL} /* Sentinel */
};

static void
heapctypewithweakref_dealloc(HeapCTypeWithWeakrefObject* self)
{

    PyTypeObject *tp = Py_TYPE(self);
    if (self->weakreflist != NULL)
        PyObject_ClearWeakRefs((PyObject *) self);
    Py_XDECREF(self->weakreflist);
    PyObject_Free(self);
    Py_DECREF(tp);
}

static PyType_Slot HeapCTypeWithWeakref_slots[] = {
    {Py_tp_members, heapctypewithweakref_members},
    {Py_tp_dealloc, heapctypewithweakref_dealloc},
    {0, 0},
};

static PyType_Spec HeapCTypeWithWeakref_spec = {
    "_testcapi.HeapCTypeWithWeakref",
    sizeof(HeapCTypeWithWeakrefObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    HeapCTypeWithWeakref_slots
};

static PyType_Spec HeapCTypeWithWeakref2_spec = {
    "_testcapi.HeapCTypeWithWeakref2",
    sizeof(HeapCTypeWithWeakrefObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    HeapCTypeWithWeakref_slots
};

PyDoc_STRVAR(heapctypesetattr__doc__,
"A heap type without GC, but with overridden __setattr__.\n\n"
"The 'value' attribute is set to 10 in __init__ and updated via attribute setting.");

typedef struct {
    PyObject_HEAD
    long value;
} HeapCTypeSetattrObject;

static struct PyMemberDef heapctypesetattr_members[] = {
    {"pvalue", Py_T_LONG, offsetof(HeapCTypeSetattrObject, value)},
    {NULL} /* Sentinel */
};

static int
heapctypesetattr_init(PyObject *self, PyObject *args, PyObject *kwargs)
{
    ((HeapCTypeSetattrObject *)self)->value = 10;
    return 0;
}

static void
heapctypesetattr_dealloc(HeapCTypeSetattrObject *self)
{
    PyTypeObject *tp = Py_TYPE(self);
    PyObject_Free(self);
    Py_DECREF(tp);
}

static int
heapctypesetattr_setattro(HeapCTypeSetattrObject *self, PyObject *attr, PyObject *value)
{
    PyObject *svalue = PyUnicode_FromString("value");
    if (svalue == NULL)
        return -1;
    int eq = PyObject_RichCompareBool(svalue, attr, Py_EQ);
    Py_DECREF(svalue);
    if (eq < 0)
        return -1;
    if (!eq) {
        return PyObject_GenericSetAttr((PyObject*) self, attr, value);
    }
    if (value == NULL) {
        self->value = 0;
        return 0;
    }
    PyObject *ivalue = PyNumber_Long(value);
    if (ivalue == NULL)
        return -1;
    long v = PyLong_AsLong(ivalue);
    Py_DECREF(ivalue);
    if (v == -1 && PyErr_Occurred())
        return -1;
    self->value = v;
    return 0;
}

static PyType_Slot HeapCTypeSetattr_slots[] = {
    {Py_tp_init, heapctypesetattr_init},
    {Py_tp_members, heapctypesetattr_members},
    {Py_tp_setattro, heapctypesetattr_setattro},
    {Py_tp_dealloc, heapctypesetattr_dealloc},
    {Py_tp_doc, (char*)heapctypesetattr__doc__},
    {0, 0},
};

static PyType_Spec HeapCTypeSetattr_spec = {
    "_testcapi.HeapCTypeSetattr",
    sizeof(HeapCTypeSetattrObject),
    0,
    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    HeapCTypeSetattr_slots
};

/*
 * The code below is for a test that uses PyType_FromSpec API to create a heap
 * type that simultaneously exposes
 *
 * - A regular __new__ / __init__ constructor pair
 * - A vector call handler in the type object
 *
 * A general requirement of vector call implementations is that they should
 * behave identically (except being potentially faster). The example below
 * deviates from this rule by initializing the instance with a different value.
 * This is only done here only so that we can see which path was taken and is
 * strongly discouraged in other cases.
 */

typedef struct {
    PyObject_HEAD
    long value;
} HeapCTypeVectorcallObject;

static PyObject *heapctype_vectorcall_vectorcall(PyObject *self,
                                                 PyObject *const *args_in,
                                                 size_t nargsf,
                                                 PyObject *kwargs_in)
{
    if (kwargs_in || PyVectorcall_NARGS(nargsf)) {
        return PyErr_Format(PyExc_IndexError, "HeapCTypeVectorcall() takes no arguments!");
    }

    HeapCTypeVectorcallObject *r =
        PyObject_New(HeapCTypeVectorcallObject, (PyTypeObject *) self);

    if (!r) {
        return NULL;
    }

    r->value = 1;

    return (PyObject *) r;
}

static PyObject *
heapctype_vectorcall_new(PyTypeObject* type, PyObject* args, PyObject *kwargs)
{
    if (PyTuple_GET_SIZE(args) || kwargs) {
        return PyErr_Format(PyExc_IndexError, "HeapCTypeVectorcall() takes no arguments!");
    }

    return (PyObject *) PyObject_New(HeapCTypeVectorcallObject, type);
}

static int
heapctype_vectorcall_init(PyObject *self, PyObject *args, PyObject *kwargs) {
    if (PyTuple_GET_SIZE(args) || kwargs) {
        PyErr_Format(PyExc_IndexError, "HeapCTypeVectorcall() takes no arguments!");
        return -1;
    }

    HeapCTypeVectorcallObject *o = (HeapCTypeVectorcallObject *) self;
    o->value = 2;
    return 0;
}

static struct PyMemberDef heapctype_vectorcall_members[] = {
    {"value", Py_T_LONG, offsetof(HeapCTypeVectorcallObject, value), 0, NULL},
    {NULL}
};

static PyType_Slot HeapCTypeVectorcall_slots[] = {
    {Py_tp_new, heapctype_vectorcall_new},
    {Py_tp_init, heapctype_vectorcall_init},
    {Py_tp_vectorcall, heapctype_vectorcall_vectorcall},
    {Py_tp_members, heapctype_vectorcall_members},
    {0, 0},
};

static PyType_Spec HeapCTypeVectorcall_spec = {
    "_testcapi.HeapCTypeVectorcall",
    sizeof(HeapCTypeVectorcallObject),
    0,
    Py_TPFLAGS_DEFAULT,
    HeapCTypeVectorcall_slots
};

PyDoc_STRVAR(HeapCCollection_doc,
"Tuple-like heap type that uses PyObject_GetItemData for items.");

static PyObject*
HeapCCollection_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds)
{
    PyObject *self = NULL;
    PyObject *result = NULL;

    Py_ssize_t size = PyTuple_GET_SIZE(args);
    self = subtype->tp_alloc(subtype, size);
    if (!self) {
        goto finally;
    }
    PyObject **data = PyObject_GetItemData(self);
    if (!data) {
        goto finally;
    }

    for (Py_ssize_t i = 0; i < size; i++) {
        data[i] = Py_NewRef(PyTuple_GET_ITEM(args, i));
    }

    result = self;
    self = NULL;
  finally:
    Py_XDECREF(self);
    return result;
}

static Py_ssize_t
HeapCCollection_length(PyVarObject *self)
{
    return Py_SIZE(self);
}

static PyObject*
HeapCCollection_item(PyObject *self, Py_ssize_t i)
{
    if (i < 0 || i >= Py_SIZE(self)) {
        return PyErr_Format(PyExc_IndexError, "index %zd out of range", i);
    }
    PyObject **data = PyObject_GetItemData(self);
    if (!data) {
        return NULL;
    }
    return Py_NewRef(data[i]);
}

static int
HeapCCollection_traverse(PyObject *self, visitproc visit, void *arg)
{
    PyObject **data = PyObject_GetItemData(self);
    if (!data) {
        return -1;
    }
    for (Py_ssize_t i = 0; i < Py_SIZE(self); i++) {
        Py_VISIT(data[i]);
    }
    return 0;
}

static int
HeapCCollection_clear(PyObject *self)
{
    PyObject **data = PyObject_GetItemData(self);
    if (!data) {
        return -1;
    }
    Py_ssize_t size = Py_SIZE(self);
    Py_SET_SIZE(self, 0);
    for (Py_ssize_t i = 0; i < size; i++) {
        Py_CLEAR(data[i]);
    }
    return 0;
}

static void
HeapCCollection_dealloc(PyObject *self)
{
    PyTypeObject *tp = Py_TYPE(self);
    HeapCCollection_clear(self);
    PyObject_GC_UnTrack(self);
    tp->tp_free(self);
    Py_DECREF(tp);
}

static PyType_Slot HeapCCollection_slots[] = {
    {Py_tp_new, HeapCCollection_new},
    {Py_sq_length, HeapCCollection_length},
    {Py_sq_item, HeapCCollection_item},
    {Py_tp_traverse, HeapCCollection_traverse},
    {Py_tp_clear, HeapCCollection_clear},
    {Py_tp_dealloc, HeapCCollection_dealloc},
    {Py_tp_doc, (void *)HeapCCollection_doc},
    {0, 0},
};

static PyType_Spec HeapCCollection_spec = {
    .name = "_testcapi.HeapCCollection",
    .basicsize = sizeof(PyVarObject),
    .itemsize = sizeof(PyObject*),
    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
              Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_ITEMS_AT_END),
    .slots = HeapCCollection_slots,
};

int
_PyTestCapi_Init_Heaptype(PyObject *m) {
    _testcapimodule = PyModule_GetDef(m);

    if (PyModule_AddFunctions(m, TestMethods) < 0) {
        return -1;
    }

#define ADD(name, value) do { \
        if (PyModule_Add(m, name, value) < 0) { \
            return -1; \
        } \
    } while (0)

    PyObject *HeapDocCType = PyType_FromSpec(&HeapDocCType_spec);
    ADD("HeapDocCType", HeapDocCType);

    /* bpo-41832: Add a new type to test PyType_FromSpec()
       now can accept a NULL tp_doc slot. */
    PyObject *NullTpDocType = PyType_FromSpec(&NullTpDocType_spec);
    ADD("NullTpDocType", NullTpDocType);

    PyObject *HeapGcCType = PyType_FromSpec(&HeapGcCType_spec);
    ADD("HeapGcCType", HeapGcCType);

    PyObject *HeapCType = PyType_FromSpec(&HeapCType_spec);
    if (HeapCType == NULL) {
        return -1;
    }
    PyObject *subclass_bases = PyTuple_Pack(1, HeapCType);
    Py_DECREF(HeapCType);
    if (subclass_bases == NULL) {
        return -1;
    }
    PyObject *HeapCTypeSubclass = PyType_FromSpecWithBases(&HeapCTypeSubclass_spec, subclass_bases);
    Py_DECREF(subclass_bases);
    ADD("HeapCTypeSubclass", HeapCTypeSubclass);

    PyObject *HeapCTypeWithDict = PyType_FromSpec(&HeapCTypeWithDict_spec);
    ADD("HeapCTypeWithDict", HeapCTypeWithDict);

    PyObject *HeapCTypeWithDict2 = PyType_FromSpec(&HeapCTypeWithDict2_spec);
    ADD("HeapCTypeWithDict2", HeapCTypeWithDict2);

    PyObject *HeapCTypeWithNegativeDict = PyType_FromSpec(&HeapCTypeWithNegativeDict_spec);
    ADD("HeapCTypeWithNegativeDict", HeapCTypeWithNegativeDict);

    PyObject *HeapCTypeWithManagedDict = PyType_FromSpec(&HeapCTypeWithManagedDict_spec);
    ADD("HeapCTypeWithManagedDict", HeapCTypeWithManagedDict);

    PyObject *HeapCTypeWithManagedWeakref = PyType_FromSpec(&HeapCTypeWithManagedWeakref_spec);
    ADD("HeapCTypeWithManagedWeakref", HeapCTypeWithManagedWeakref);

    PyObject *HeapCTypeWithWeakref = PyType_FromSpec(&HeapCTypeWithWeakref_spec);
    ADD("HeapCTypeWithWeakref", HeapCTypeWithWeakref);

    PyObject *HeapCTypeWithWeakref2 = PyType_FromSpec(&HeapCTypeWithWeakref2_spec);
    ADD("HeapCTypeWithWeakref2", HeapCTypeWithWeakref2);

    PyObject *HeapCTypeWithBuffer = PyType_FromSpec(&HeapCTypeWithBuffer_spec);
    ADD("HeapCTypeWithBuffer", HeapCTypeWithBuffer);

    PyObject *HeapCTypeSetattr = PyType_FromSpec(&HeapCTypeSetattr_spec);
    ADD("HeapCTypeSetattr", HeapCTypeSetattr);

    PyObject *HeapCTypeVectorcall = PyType_FromSpec(&HeapCTypeVectorcall_spec);
    ADD("HeapCTypeVectorcall", HeapCTypeVectorcall);

    PyObject *subclass_with_finalizer_bases = PyTuple_Pack(1, HeapCTypeSubclass);
    if (subclass_with_finalizer_bases == NULL) {
        return -1;
    }
    PyObject *HeapCTypeSubclassWithFinalizer = PyType_FromSpecWithBases(
        &HeapCTypeSubclassWithFinalizer_spec, subclass_with_finalizer_bases);
    Py_DECREF(subclass_with_finalizer_bases);
    ADD("HeapCTypeSubclassWithFinalizer", HeapCTypeSubclassWithFinalizer);

    PyObject *HeapCTypeMetaclass = PyType_FromMetaclass(
        &PyType_Type, m, &HeapCTypeMetaclass_spec, (PyObject *) &PyType_Type);
    ADD("HeapCTypeMetaclass", HeapCTypeMetaclass);

    PyObject *HeapCTypeMetaclassCustomNew = PyType_FromMetaclass(
        &PyType_Type, m, &HeapCTypeMetaclassCustomNew_spec, (PyObject *) &PyType_Type);
    ADD("HeapCTypeMetaclassCustomNew", HeapCTypeMetaclassCustomNew);

    PyObject *HeapCTypeMetaclassNullNew = PyType_FromMetaclass(
        &PyType_Type, m, &HeapCTypeMetaclassNullNew_spec, (PyObject *) &PyType_Type);
    ADD("HeapCTypeMetaclassNullNew", HeapCTypeMetaclassNullNew);

    ADD("Py_TP_USE_SPEC", PyLong_FromVoidPtr(Py_TP_USE_SPEC));

    PyObject *HeapCCollection = PyType_FromMetaclass(
        NULL, m, &HeapCCollection_spec, NULL);
    if (HeapCCollection == NULL) {
        return -1;
    }
    int rc = PyModule_AddType(m, (PyTypeObject *)HeapCCollection);
    Py_DECREF(HeapCCollection);
    if (rc < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/immortal.c
================================================
#include "parts.h"

int verify_immortality(PyObject *object)
{
    assert(_Py_IsImmortal(object));
    Py_ssize_t old_count = Py_REFCNT(object);
    for (int j = 0; j < 10000; j++) {
        Py_DECREF(object);
    }
    Py_ssize_t current_count = Py_REFCNT(object);
    return old_count == current_count;
}

static PyObject *
test_immortal_builtins(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    PyObject *objects[] = {Py_True, Py_False, Py_None, Py_Ellipsis};
    Py_ssize_t n = Py_ARRAY_LENGTH(objects);
    for (Py_ssize_t i = 0; i < n; i++) {
        assert(verify_immortality(objects[i]));
    }
    Py_RETURN_NONE;
}

static PyObject *
test_immortal_small_ints(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    for (int i = -5; i <= 256; i++) {
        assert(verify_immortality(PyLong_FromLong(i)));
    }
    Py_RETURN_NONE;
}

static PyMethodDef test_methods[] = {
    {"test_immortal_builtins",   test_immortal_builtins,     METH_NOARGS},
    {"test_immortal_small_ints", test_immortal_small_ints,   METH_NOARGS},
    {NULL},
};

int
_PyTestCapi_Init_Immortal(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testcapi/list.c
================================================
#include "parts.h"
#include "util.h"


static PyObject *
list_get_size(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    RETURN_SIZE(PyList_GET_SIZE(obj));
}


static PyObject *
list_get_item(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t i;
    if (!PyArg_ParseTuple(args, "On", &obj, &i)) {
        return NULL;
    }
    NULLABLE(obj);
    return Py_XNewRef(PyList_GET_ITEM(obj, i));
}


static PyObject *
list_set_item(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj, *value;
    Py_ssize_t i;
    if (!PyArg_ParseTuple(args, "OnO", &obj, &i, &value)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(value);
    PyList_SET_ITEM(obj, i, Py_XNewRef(value));
    Py_RETURN_NONE;

}


static PyObject *
list_clear(PyObject* Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    RETURN_INT(PyList_Clear(obj));
}


static PyObject *
list_extend(PyObject* Py_UNUSED(module), PyObject *args)
{
    PyObject *obj, *arg;
    if (!PyArg_ParseTuple(args, "OO", &obj, &arg)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(arg);
    RETURN_INT(PyList_Extend(obj, arg));
}


static PyMethodDef test_methods[] = {
    {"list_get_size", list_get_size, METH_O},
    {"list_get_item", list_get_item, METH_VARARGS},
    {"list_set_item", list_set_item, METH_VARARGS},
    {"list_clear", list_clear, METH_O},
    {"list_extend", list_extend, METH_VARARGS},

    {NULL},
};

int
_PyTestCapi_Init_List(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/long.c
================================================
#ifndef Py_BUILD_CORE_BUILTIN
#  define Py_BUILD_CORE_MODULE 1
#endif

#include "parts.h"
#include "util.h"
#include "clinic/long.c.h"

/*[clinic input]
module _testcapi
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=6361033e795369fc]*/


/*[clinic input]
_testcapi.call_long_compact_api
    arg: object
    /
[clinic start generated code]*/

static PyObject *
_testcapi_call_long_compact_api(PyObject *module, PyObject *arg)
/*[clinic end generated code: output=7e3894f611b1b2b7 input=87b87396967af14c]*/

{
    assert(PyLong_Check(arg));
    int is_compact = PyUnstable_Long_IsCompact((PyLongObject*)arg);
    Py_ssize_t value = -1;
    if (is_compact) {
        value = PyUnstable_Long_CompactValue((PyLongObject*)arg);
    }
    return Py_BuildValue("in", is_compact, value);
}


static PyObject *
pylong_fromunicodeobject(PyObject *module, PyObject *args)
{
    PyObject *unicode;
    int base;
    if (!PyArg_ParseTuple(args, "Oi", &unicode, &base)) {
        return NULL;
    }

    NULLABLE(unicode);
    return PyLong_FromUnicodeObject(unicode, base);
}


static PyObject *
pylong_asnativebytes(PyObject *module, PyObject *args)
{
    PyObject *v;
    Py_buffer buffer;
    Py_ssize_t n, flags;
    if (!PyArg_ParseTuple(args, "Ow*nn", &v, &buffer, &n, &flags)) {
        return NULL;
    }
    if (buffer.readonly) {
        PyErr_SetString(PyExc_TypeError, "buffer must be writable");
        PyBuffer_Release(&buffer);
        return NULL;
    }
    if (buffer.len < n) {
        PyErr_SetString(PyExc_ValueError, "buffer must be at least 'n' bytes");
        PyBuffer_Release(&buffer);
        return NULL;
    }
    Py_ssize_t res = PyLong_AsNativeBytes(v, buffer.buf, n, (int)flags);
    PyBuffer_Release(&buffer);
    return res >= 0 ? PyLong_FromSsize_t(res) : NULL;
}


static PyObject *
pylong_fromnativebytes(PyObject *module, PyObject *args)
{
    Py_buffer buffer;
    Py_ssize_t n, flags, signed_;
    if (!PyArg_ParseTuple(args, "y*nnn", &buffer, &n, &flags, &signed_)) {
        return NULL;
    }
    if (buffer.len < n) {
        PyErr_SetString(PyExc_ValueError, "buffer must be at least 'n' bytes");
        PyBuffer_Release(&buffer);
        return NULL;
    }
    PyObject *res = signed_
        ? PyLong_FromNativeBytes(buffer.buf, n, (int)flags)
        : PyLong_FromUnsignedNativeBytes(buffer.buf, n, (int)flags);
    PyBuffer_Release(&buffer);
    return res;
}


static PyObject *
pylong_getsign(PyObject *module, PyObject *arg)
{
    int sign;
    NULLABLE(arg);
    if (PyLong_GetSign(arg, &sign) == -1) {
        return NULL;
    }
    return PyLong_FromLong(sign);
}


static PyObject *
pylong_ispositive(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    RETURN_INT(PyLong_IsPositive(arg));
}


static PyObject *
pylong_isnegative(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    RETURN_INT(PyLong_IsNegative(arg));
}


static PyObject *
pylong_iszero(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    RETURN_INT(PyLong_IsZero(arg));
}


static PyObject *
pylong_aspid(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    pid_t value = PyLong_AsPid(arg);
    if (value == -1 && PyErr_Occurred()) {
        return NULL;
    }
    return PyLong_FromPid(value);
}


static PyObject *
layout_to_dict(const PyLongLayout *layout)
{
    return Py_BuildValue("{sisisisi}",
        "bits_per_digit", (int)layout->bits_per_digit,
        "digit_size", (int)layout->digit_size,
        "digits_order", (int)layout->digits_order,
        "digit_endianness", (int)layout->digit_endianness);
}


static PyObject *
pylong_export(PyObject *module, PyObject *obj)
{
    PyLongExport export_long;
    if (PyLong_Export(obj, &export_long) < 0) {
        return NULL;
    }

    if (export_long.digits == NULL) {
        assert(export_long.negative == 0);
        assert(export_long.ndigits == 0);
        assert(export_long.digits == NULL);
        PyObject *res = PyLong_FromInt64(export_long.value);
        PyLong_FreeExport(&export_long);
        return res;
    }

    assert(PyLong_GetNativeLayout()->digit_size == sizeof(digit));
    const digit *export_long_digits = export_long.digits;

    PyObject *digits = PyList_New(0);
    if (digits == NULL) {
        goto error;
    }
    for (Py_ssize_t i = 0; i < export_long.ndigits; i++) {
        PyObject *item = PyLong_FromUnsignedLong(export_long_digits[i]);
        if (item == NULL) {
            goto error;
        }

        if (PyList_Append(digits, item) < 0) {
            Py_DECREF(item);
            goto error;
        }
        Py_DECREF(item);
    }

    assert(export_long.value == 0);
    PyObject *res = Py_BuildValue("(iN)", export_long.negative, digits);

    PyLong_FreeExport(&export_long);
    assert(export_long._reserved == 0);

    return res;

error:
    Py_XDECREF(digits);
    PyLong_FreeExport(&export_long);
    return NULL;
}


static PyObject *
pylongwriter_create(PyObject *module, PyObject *args)
{
    int negative;
    PyObject *list;
    // TODO(vstinner): write test for negative ndigits and digits==NULL
    if (!PyArg_ParseTuple(args, "iO!", &negative, &PyList_Type, &list)) {
        return NULL;
    }
    Py_ssize_t ndigits = PyList_GET_SIZE(list);

    digit *digits = PyMem_Malloc((size_t)ndigits * sizeof(digit));
    if (digits == NULL) {
        return PyErr_NoMemory();
    }

    for (Py_ssize_t i = 0; i < ndigits; i++) {
        PyObject *item = PyList_GET_ITEM(list, i);

        long num = PyLong_AsLong(item);
        if (num == -1 && PyErr_Occurred()) {
            goto error;
        }

        if (num < 0 || num >= PyLong_BASE) {
            PyErr_SetString(PyExc_ValueError, "digit doesn't fit into digit");
            goto error;
        }
        digits[i] = (digit)num;
    }

    void *writer_digits;
    PyLongWriter *writer = PyLongWriter_Create(negative, ndigits,
                                               &writer_digits);
    if (writer == NULL) {
        goto error;
    }
    assert(PyLong_GetNativeLayout()->digit_size == sizeof(digit));
    memcpy(writer_digits, digits, (size_t)ndigits * sizeof(digit));
    PyObject *res = PyLongWriter_Finish(writer);
    PyMem_Free(digits);

    return res;

error:
    PyMem_Free(digits);
    return NULL;
}


static PyObject *
get_pylong_layout(PyObject *module, PyObject *Py_UNUSED(args))
{
    const PyLongLayout *layout = PyLong_GetNativeLayout();
    return layout_to_dict(layout);
}


static PyMethodDef test_methods[] = {
    _TESTCAPI_CALL_LONG_COMPACT_API_METHODDEF
    {"pylong_fromunicodeobject",    pylong_fromunicodeobject,   METH_VARARGS},
    {"pylong_asnativebytes",        pylong_asnativebytes,       METH_VARARGS},
    {"pylong_fromnativebytes",      pylong_fromnativebytes,     METH_VARARGS},
    {"pylong_getsign",              pylong_getsign,             METH_O},
    {"pylong_aspid",                pylong_aspid,               METH_O},
    {"pylong_export",               pylong_export,              METH_O},
    {"pylongwriter_create",         pylongwriter_create,        METH_VARARGS},
    {"get_pylong_layout",           get_pylong_layout,          METH_NOARGS},
    {"pylong_ispositive",           pylong_ispositive,          METH_O},
    {"pylong_isnegative",           pylong_isnegative,          METH_O},
    {"pylong_iszero",               pylong_iszero,              METH_O},
    {NULL},
};

int
_PyTestCapi_Init_Long(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testcapi/mem.c
================================================
#include "parts.h"

#include <stddef.h>


typedef struct {
    PyMemAllocatorEx alloc;

    size_t malloc_size;
    size_t calloc_nelem;
    size_t calloc_elsize;
    void *realloc_ptr;
    size_t realloc_new_size;
    void *free_ptr;
    void *ctx;
} alloc_hook_t;

static void *
hook_malloc(void *ctx, size_t size)
{
    alloc_hook_t *hook = (alloc_hook_t *)ctx;
    hook->ctx = ctx;
    hook->malloc_size = size;
    return hook->alloc.malloc(hook->alloc.ctx, size);
}

static void *
hook_calloc(void *ctx, size_t nelem, size_t elsize)
{
    alloc_hook_t *hook = (alloc_hook_t *)ctx;
    hook->ctx = ctx;
    hook->calloc_nelem = nelem;
    hook->calloc_elsize = elsize;
    return hook->alloc.calloc(hook->alloc.ctx, nelem, elsize);
}

static void *
hook_realloc(void *ctx, void *ptr, size_t new_size)
{
    alloc_hook_t *hook = (alloc_hook_t *)ctx;
    hook->ctx = ctx;
    hook->realloc_ptr = ptr;
    hook->realloc_new_size = new_size;
    return hook->alloc.realloc(hook->alloc.ctx, ptr, new_size);
}

static void
hook_free(void *ctx, void *ptr)
{
    alloc_hook_t *hook = (alloc_hook_t *)ctx;
    hook->ctx = ctx;
    hook->free_ptr = ptr;
    hook->alloc.free(hook->alloc.ctx, ptr);
}

/* Most part of the following code is inherited from the pyfailmalloc project
 * written by Victor Stinner. */
static struct {
    int installed;
    PyMemAllocatorEx raw;
    PyMemAllocatorEx mem;
    PyMemAllocatorEx obj;
} FmHook;

static struct {
    int start;
    int stop;
    Py_ssize_t count;
} FmData;

static int
fm_nomemory(void)
{
    FmData.count++;
    if (FmData.count > FmData.start &&
        (FmData.stop <= 0 || FmData.count <= FmData.stop))
    {
        return 1;
    }
    return 0;
}

static void *
hook_fmalloc(void *ctx, size_t size)
{
    PyMemAllocatorEx *alloc = (PyMemAllocatorEx *)ctx;
    if (fm_nomemory()) {
        return NULL;
    }
    return alloc->malloc(alloc->ctx, size);
}

static void *
hook_fcalloc(void *ctx, size_t nelem, size_t elsize)
{
    PyMemAllocatorEx *alloc = (PyMemAllocatorEx *)ctx;
    if (fm_nomemory()) {
        return NULL;
    }
    return alloc->calloc(alloc->ctx, nelem, elsize);
}

static void *
hook_frealloc(void *ctx, void *ptr, size_t new_size)
{
    PyMemAllocatorEx *alloc = (PyMemAllocatorEx *)ctx;
    if (fm_nomemory()) {
        return NULL;
    }
    return alloc->realloc(alloc->ctx, ptr, new_size);
}

static void
hook_ffree(void *ctx, void *ptr)
{
    PyMemAllocatorEx *alloc = (PyMemAllocatorEx *)ctx;
    alloc->free(alloc->ctx, ptr);
}

static void
fm_setup_hooks(void)
{
    if (FmHook.installed) {
        return;
    }
    FmHook.installed = 1;

    PyMemAllocatorEx alloc;
    alloc.malloc = hook_fmalloc;
    alloc.calloc = hook_fcalloc;
    alloc.realloc = hook_frealloc;
    alloc.free = hook_ffree;
    PyMem_GetAllocator(PYMEM_DOMAIN_RAW, &FmHook.raw);
    PyMem_GetAllocator(PYMEM_DOMAIN_MEM, &FmHook.mem);
    PyMem_GetAllocator(PYMEM_DOMAIN_OBJ, &FmHook.obj);

    alloc.ctx = &FmHook.raw;
    PyMem_SetAllocator(PYMEM_DOMAIN_RAW, &alloc);

    alloc.ctx = &FmHook.mem;
    PyMem_SetAllocator(PYMEM_DOMAIN_MEM, &alloc);

    alloc.ctx = &FmHook.obj;
    PyMem_SetAllocator(PYMEM_DOMAIN_OBJ, &alloc);
}

static void
fm_remove_hooks(void)
{
    if (FmHook.installed) {
        FmHook.installed = 0;
        PyMem_SetAllocator(PYMEM_DOMAIN_RAW, &FmHook.raw);
        PyMem_SetAllocator(PYMEM_DOMAIN_MEM, &FmHook.mem);
        PyMem_SetAllocator(PYMEM_DOMAIN_OBJ, &FmHook.obj);
    }
}

static PyObject *
set_nomemory(PyObject *self, PyObject *args)
{
    /* Memory allocation fails after 'start' allocation requests, and until
     * 'stop' allocation requests except when 'stop' is negative or equal
     * to 0 (default) in which case allocation failures never stop. */
    FmData.count = 0;
    FmData.stop = 0;
    if (!PyArg_ParseTuple(args, "i|i", &FmData.start, &FmData.stop)) {
        return NULL;
    }
    fm_setup_hooks();
    Py_RETURN_NONE;
}

static PyObject *
remove_mem_hooks(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    fm_remove_hooks();
    Py_RETURN_NONE;
}

static PyObject *
test_setallocators(PyMemAllocatorDomain domain)
{
    PyObject *res = NULL;
    const char *error_msg;
    alloc_hook_t hook;

    memset(&hook, 0, sizeof(hook));

    PyMemAllocatorEx alloc;
    alloc.ctx = &hook;
    alloc.malloc = &hook_malloc;
    alloc.calloc = &hook_calloc;
    alloc.realloc = &hook_realloc;
    alloc.free = &hook_free;
    PyMem_GetAllocator(domain, &hook.alloc);
    PyMem_SetAllocator(domain, &alloc);

    /* malloc, realloc, free */
    size_t size = 42;
    hook.ctx = NULL;
    void *ptr;
    switch(domain) {
        case PYMEM_DOMAIN_RAW:
            ptr = PyMem_RawMalloc(size);
            break;
        case PYMEM_DOMAIN_MEM:
            ptr = PyMem_Malloc(size);
            break;
        case PYMEM_DOMAIN_OBJ:
            ptr = PyObject_Malloc(size);
            break;
        default:
            ptr = NULL;
            break;
    }

#define CHECK_CTX(FUNC)                     \
    if (hook.ctx != &hook) {                \
        error_msg = FUNC " wrong context";  \
        goto fail;                          \
    }                                       \
    hook.ctx = NULL;  /* reset for next check */

    if (ptr == NULL) {
        error_msg = "malloc failed";
        goto fail;
    }
    CHECK_CTX("malloc");
    if (hook.malloc_size != size) {
        error_msg = "malloc invalid size";
        goto fail;
    }

    size_t size2 = 200;
    void *ptr2;
    switch(domain) {
        case PYMEM_DOMAIN_RAW:
            ptr2 = PyMem_RawRealloc(ptr, size2);
            break;
        case PYMEM_DOMAIN_MEM:
            ptr2 = PyMem_Realloc(ptr, size2);
            break;
        case PYMEM_DOMAIN_OBJ:
            ptr2 = PyObject_Realloc(ptr, size2);
            break;
        default:
            ptr2 = NULL;
            break;
    }

    if (ptr2 == NULL) {
        error_msg = "realloc failed";
        goto fail;
    }
    CHECK_CTX("realloc");
    if (hook.realloc_ptr != ptr || hook.realloc_new_size != size2) {
        error_msg = "realloc invalid parameters";
        goto fail;
    }

    switch(domain) {
        case PYMEM_DOMAIN_RAW:
            PyMem_RawFree(ptr2);
            break;
        case PYMEM_DOMAIN_MEM:
            PyMem_Free(ptr2);
            break;
        case PYMEM_DOMAIN_OBJ:
            PyObject_Free(ptr2);
            break;
    }

    CHECK_CTX("free");
    if (hook.free_ptr != ptr2) {
        error_msg = "free invalid pointer";
        goto fail;
    }

    /* calloc, free */
    size_t nelem = 2;
    size_t elsize = 5;
    switch(domain) {
        case PYMEM_DOMAIN_RAW:
            ptr = PyMem_RawCalloc(nelem, elsize);
            break;
        case PYMEM_DOMAIN_MEM:
            ptr = PyMem_Calloc(nelem, elsize);
            break;
        case PYMEM_DOMAIN_OBJ:
            ptr = PyObject_Calloc(nelem, elsize);
            break;
        default:
            ptr = NULL;
            break;
    }

    if (ptr == NULL) {
        error_msg = "calloc failed";
        goto fail;
    }
    CHECK_CTX("calloc");
    if (hook.calloc_nelem != nelem || hook.calloc_elsize != elsize) {
        error_msg = "calloc invalid nelem or elsize";
        goto fail;
    }

    hook.free_ptr = NULL;
    switch(domain) {
        case PYMEM_DOMAIN_RAW:
            PyMem_RawFree(ptr);
            break;
        case PYMEM_DOMAIN_MEM:
            PyMem_Free(ptr);
            break;
        case PYMEM_DOMAIN_OBJ:
            PyObject_Free(ptr);
            break;
    }

    CHECK_CTX("calloc free");
    if (hook.free_ptr != ptr) {
        error_msg = "calloc free invalid pointer";
        goto fail;
    }

    res = Py_NewRef(Py_None);
    goto finally;

fail:
    PyErr_SetString(PyExc_RuntimeError, error_msg);

finally:
    PyMem_SetAllocator(domain, &hook.alloc);
    return res;

#undef CHECK_CTX
}

static PyObject *
test_pyobject_setallocators(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    return test_setallocators(PYMEM_DOMAIN_OBJ);
}

static PyObject *
test_pyobject_new(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    PyObject *obj;
    PyTypeObject *type = &PyBaseObject_Type;
    PyTypeObject *var_type = &PyBytes_Type;

    // PyObject_New()
    obj = PyObject_New(PyObject, type);
    if (obj == NULL) {
        goto alloc_failed;
    }
    Py_DECREF(obj);

    // PyObject_NEW()
    obj = PyObject_NEW(PyObject, type);
    if (obj == NULL) {
        goto alloc_failed;
    }
    Py_DECREF(obj);

    // PyObject_NewVar()
    obj = PyObject_NewVar(PyObject, var_type, 3);
    if (obj == NULL) {
        goto alloc_failed;
    }
    Py_DECREF(obj);

    // PyObject_NEW_VAR()
    obj = PyObject_NEW_VAR(PyObject, var_type, 3);
    if (obj == NULL) {
        goto alloc_failed;
    }
    Py_DECREF(obj);

    Py_RETURN_NONE;

alloc_failed:
    PyErr_NoMemory();
    return NULL;
}

static PyObject *
test_pymem_alloc0(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    void *ptr;

    ptr = PyMem_RawMalloc(0);
    if (ptr == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyMem_RawMalloc(0) returns NULL");
        return NULL;
    }
    PyMem_RawFree(ptr);

    ptr = PyMem_RawCalloc(0, 0);
    if (ptr == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyMem_RawCalloc(0, 0) returns NULL");
        return NULL;
    }
    PyMem_RawFree(ptr);

    ptr = PyMem_Malloc(0);
    if (ptr == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyMem_Malloc(0) returns NULL");
        return NULL;
    }
    PyMem_Free(ptr);

    ptr = PyMem_Calloc(0, 0);
    if (ptr == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyMem_Calloc(0, 0) returns NULL");
        return NULL;
    }
    PyMem_Free(ptr);

    ptr = PyObject_Malloc(0);
    if (ptr == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyObject_Malloc(0) returns NULL");
        return NULL;
    }
    PyObject_Free(ptr);

    ptr = PyObject_Calloc(0, 0);
    if (ptr == NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                        "PyObject_Calloc(0, 0) returns NULL");
        return NULL;
    }
    PyObject_Free(ptr);

    Py_RETURN_NONE;
}

static PyObject *
test_pymem_setrawallocators(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    return test_setallocators(PYMEM_DOMAIN_RAW);
}

static PyObject *
test_pymem_setallocators(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    return test_setallocators(PYMEM_DOMAIN_MEM);
}

static PyObject *
pyobject_malloc_without_gil(PyObject *self, PyObject *args)
{
    char *buffer;

    /* Deliberate bug to test debug hooks on Python memory allocators:
       call PyObject_Malloc() without holding the GIL */
    Py_BEGIN_ALLOW_THREADS
    buffer = PyObject_Malloc(10);
    Py_END_ALLOW_THREADS

    PyObject_Free(buffer);

    Py_RETURN_NONE;
}

static PyObject *
pymem_buffer_overflow(PyObject *self, PyObject *args)
{
    char *buffer;

    /* Deliberate buffer overflow to check that PyMem_Free() detects
       the overflow when debug hooks are installed. */
    buffer = PyMem_Malloc(16);
    if (buffer == NULL) {
        PyErr_NoMemory();
        return NULL;
    }
    buffer[16] = 'x';
    PyMem_Free(buffer);

    Py_RETURN_NONE;
}

static PyObject *
pymem_api_misuse(PyObject *self, PyObject *args)
{
    char *buffer;

    /* Deliberate misusage of Python allocators:
       allococate with PyMem but release with PyMem_Raw. */
    buffer = PyMem_Malloc(16);
    PyMem_RawFree(buffer);

    Py_RETURN_NONE;
}

static PyObject *
pymem_malloc_without_gil(PyObject *self, PyObject *args)
{
    char *buffer;

    /* Deliberate bug to test debug hooks on Python memory allocators:
       call PyMem_Malloc() without holding the GIL */
    Py_BEGIN_ALLOW_THREADS
    buffer = PyMem_Malloc(10);
    Py_END_ALLOW_THREADS

    PyMem_Free(buffer);

    Py_RETURN_NONE;
}


// Tracemalloc tests
static PyObject *
tracemalloc_track(PyObject *self, PyObject *args)
{
    unsigned int domain;
    PyObject *ptr_obj;
    Py_ssize_t size;
    int release_gil = 0;

    if (!PyArg_ParseTuple(args, "IOn|i",
                          &domain, &ptr_obj, &size, &release_gil))
    {
        return NULL;
    }
    void *ptr = PyLong_AsVoidPtr(ptr_obj);
    if (PyErr_Occurred()) {
        return NULL;
    }

    int res;
    if (release_gil) {
        Py_BEGIN_ALLOW_THREADS
        res = PyTraceMalloc_Track(domain, (uintptr_t)ptr, size);
        Py_END_ALLOW_THREADS
    }
    else {
        res = PyTraceMalloc_Track(domain, (uintptr_t)ptr, size);
    }
    if (res < 0) {
        PyErr_SetString(PyExc_RuntimeError, "PyTraceMalloc_Track error");
        return NULL;
    }

    Py_RETURN_NONE;
}

static PyObject *
tracemalloc_untrack(PyObject *self, PyObject *args)
{
    unsigned int domain;
    PyObject *ptr_obj;

    if (!PyArg_ParseTuple(args, "IO", &domain, &ptr_obj)) {
        return NULL;
    }
    void *ptr = PyLong_AsVoidPtr(ptr_obj);
    if (PyErr_Occurred()) {
        return NULL;
    }

    int res = PyTraceMalloc_Untrack(domain, (uintptr_t)ptr);
    if (res < 0) {
        PyErr_SetString(PyExc_RuntimeError, "PyTraceMalloc_Untrack error");
        return NULL;
    }

    Py_RETURN_NONE;
}

static PyMethodDef test_methods[] = {
    {"pymem_api_misuse",              pymem_api_misuse,              METH_NOARGS},
    {"pymem_buffer_overflow",         pymem_buffer_overflow,         METH_NOARGS},
    {"pymem_malloc_without_gil",      pymem_malloc_without_gil,      METH_NOARGS},
    {"pyobject_malloc_without_gil",   pyobject_malloc_without_gil,   METH_NOARGS},
    {"remove_mem_hooks",              remove_mem_hooks,              METH_NOARGS,
        PyDoc_STR("Remove memory hooks.")},
    {"set_nomemory",                  (PyCFunction)set_nomemory,     METH_VARARGS,
        PyDoc_STR("set_nomemory(start:int, stop:int = 0)")},
    {"test_pymem_alloc0",             test_pymem_alloc0,             METH_NOARGS},
    {"test_pymem_setallocators",      test_pymem_setallocators,      METH_NOARGS},
    {"test_pymem_setrawallocators",   test_pymem_setrawallocators,   METH_NOARGS},
    {"test_pyobject_new",             test_pyobject_new,             METH_NOARGS},
    {"test_pyobject_setallocators",   test_pyobject_setallocators,   METH_NOARGS},

    // Tracemalloc tests
    {"tracemalloc_track",             tracemalloc_track,             METH_VARARGS},
    {"tracemalloc_untrack",           tracemalloc_untrack,           METH_VARARGS},
    {NULL},
};

int
_PyTestCapi_Init_Mem(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }

    PyObject *v;
#ifdef WITH_PYMALLOC
    v = Py_True;
#else
    v = Py_False;
#endif
    if (PyModule_AddObjectRef(mod, "WITH_PYMALLOC", v) < 0) {
        return -1;
    }

#ifdef WITH_MIMALLOC
    v = Py_True;
#else
    v = Py_False;
#endif
    if (PyModule_AddObjectRef(mod, "WITH_MIMALLOC", v) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/monitoring.c
================================================
#include "parts.h"
#include "util.h"

#include "monitoring.h"

#define Py_BUILD_CORE
#include "internal/pycore_instruments.h"

typedef struct {
    PyObject_HEAD
    PyMonitoringState *monitoring_states;
    uint64_t version;
    int num_events;
    /* Other fields */
} PyCodeLikeObject;


static PyObject *
CodeLike_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
{
    int num_events;
    if (!PyArg_ParseTuple(args, "i", &num_events)) {
        return NULL;
    }
    PyMonitoringState *states = (PyMonitoringState *)PyMem_Calloc(
            num_events, sizeof(PyMonitoringState));
    if (states == NULL) {
        return NULL;
    }
    PyCodeLikeObject *self = (PyCodeLikeObject *) type->tp_alloc(type, 0);
    if (self != NULL) {
        self->version = 0;
        self->monitoring_states = states;
        self->num_events = num_events;
    }
    else {
        PyMem_Free(states);
    }
    return (PyObject *) self;
}

static void
CodeLike_dealloc(PyCodeLikeObject *self)
{
    if (self->monitoring_states) {
        PyMem_Free(self->monitoring_states);
    }
    Py_TYPE(self)->tp_free((PyObject *) self);
}

static PyObject *
CodeLike_str(PyCodeLikeObject *self)
{
    PyObject *res = NULL;
    PyObject *sep = NULL;
    PyObject *parts = NULL;
    if (self->monitoring_states) {
        parts = PyList_New(0);
        if (parts == NULL) {
            goto end;
        }

        PyObject *heading = PyUnicode_FromString("PyCodeLikeObject");
        if (heading == NULL) {
            goto end;
        }
        int err = PyList_Append(parts, heading);
        Py_DECREF(heading);
        if (err < 0) {
            goto end;
        }

        for (int i = 0; i < self->num_events; i++) {
            PyObject *part = PyUnicode_FromFormat(" %d", self->monitoring_states[i].active);
            if (part == NULL) {
                goto end;
            }
            int err = PyList_Append(parts, part);
            Py_XDECREF(part);
            if (err < 0) {
                goto end;
            }
        }
        sep = PyUnicode_FromString(": ");
        if (sep == NULL) {
            goto end;
        }
        res = PyUnicode_Join(sep, parts);
    }
end:
    Py_XDECREF(sep);
    Py_XDECREF(parts);
    return res;
}

static PyTypeObject PyCodeLike_Type = {
    .ob_base = PyVarObject_HEAD_INIT(NULL, 0)
    .tp_name = "monitoring.CodeLike",
    .tp_doc = PyDoc_STR("CodeLike objects"),
    .tp_basicsize = sizeof(PyCodeLikeObject),
    .tp_itemsize = 0,
    .tp_flags = Py_TPFLAGS_DEFAULT,
    .tp_new = CodeLike_new,
    .tp_dealloc = (destructor) CodeLike_dealloc,
    .tp_str = (reprfunc) CodeLike_str,
};

#define RAISE_UNLESS_CODELIKE(v)  if (!Py_IS_TYPE((v), &PyCodeLike_Type)) { \
        PyErr_Format(PyExc_TypeError, "expected a code-like, got %s", Py_TYPE(v)->tp_name); \
        return NULL; \
    }

/*******************************************************************/

static PyMonitoringState *
setup_fire(PyObject *codelike, int offset, PyObject *exc)
{
    RAISE_UNLESS_CODELIKE(codelike);
    PyCodeLikeObject *cl = ((PyCodeLikeObject *)codelike);
    assert(offset >= 0 && offset < cl->num_events);
    PyMonitoringState *state = &cl->monitoring_states[offset];

    if (exc != NULL) {
        PyErr_SetRaisedException(Py_NewRef(exc));
    }
    return state;
}

static int
teardown_fire(int res, PyMonitoringState *state, PyObject *exception)
{
    if (res == -1) {
        return -1;
    }
    if (exception) {
        assert(PyErr_Occurred());
        assert(((PyObject*)Py_TYPE(exception)) == PyErr_Occurred());
    }

    else {
        assert(!PyErr_Occurred());
    }
    PyErr_Clear();
    return state->active;
}

static PyObject *
fire_event_py_start(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    if (!PyArg_ParseTuple(args, "Oi", &codelike, &offset)) {
        return NULL;
    }
    PyObject *exception = NULL;
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FirePyStartEvent(state, codelike, offset);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_py_resume(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    if (!PyArg_ParseTuple(args, "Oi", &codelike, &offset)) {
        return NULL;
    }
    PyObject *exception = NULL;
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FirePyResumeEvent(state, codelike, offset);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_py_return(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *retval;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &retval)) {
        return NULL;
    }
    PyObject *exception = NULL;
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FirePyReturnEvent(state, codelike, offset, retval);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_c_return(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *retval;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &retval)) {
        return NULL;
    }
    PyObject *exception = NULL;
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FireCReturnEvent(state, codelike, offset, retval);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_py_yield(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *retval;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &retval)) {
        return NULL;
    }
    PyObject *exception = NULL;
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FirePyYieldEvent(state, codelike, offset, retval);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_call(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *callable, *arg0;
    if (!PyArg_ParseTuple(args, "OiOO", &codelike, &offset, &callable, &arg0)) {
        return NULL;
    }
    PyObject *exception = NULL;
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FireCallEvent(state, codelike, offset, callable, arg0);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_line(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset, lineno;
    if (!PyArg_ParseTuple(args, "Oii", &codelike, &offset, &lineno)) {
        return NULL;
    }
    PyObject *exception = NULL;
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FireLineEvent(state, codelike, offset, lineno);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_jump(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *target_offset;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &target_offset)) {
        return NULL;
    }
    PyObject *exception = NULL;
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FireJumpEvent(state, codelike, offset, target_offset);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_branch_right(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *target_offset;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &target_offset)) {
        return NULL;
    }
    PyObject *exception = NULL;
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FireBranchRightEvent(state, codelike, offset, target_offset);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_branch_left(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *target_offset;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &target_offset)) {
        return NULL;
    }
    PyObject *exception = NULL;
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FireBranchLeftEvent(state, codelike, offset, target_offset);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_py_throw(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *exception;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &exception)) {
        return NULL;
    }
    NULLABLE(exception);
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FirePyThrowEvent(state, codelike, offset);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_raise(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *exception;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &exception)) {
        return NULL;
    }
    NULLABLE(exception);
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FireRaiseEvent(state, codelike, offset);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_c_raise(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *exception;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &exception)) {
        return NULL;
    }
    NULLABLE(exception);
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FireCRaiseEvent(state, codelike, offset);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_reraise(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *exception;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &exception)) {
        return NULL;
    }
    NULLABLE(exception);
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FireReraiseEvent(state, codelike, offset);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_exception_handled(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *exception;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &exception)) {
        return NULL;
    }
    NULLABLE(exception);
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FireExceptionHandledEvent(state, codelike, offset);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_py_unwind(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *exception;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &exception)) {
        return NULL;
    }
    NULLABLE(exception);
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FirePyUnwindEvent(state, codelike, offset);
    RETURN_INT(teardown_fire(res, state, exception));
}

static PyObject *
fire_event_stop_iteration(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int offset;
    PyObject *value;
    if (!PyArg_ParseTuple(args, "OiO", &codelike, &offset, &value)) {
        return NULL;
    }
    NULLABLE(value);
    PyObject *exception = NULL;
    PyMonitoringState *state = setup_fire(codelike, offset, exception);
    if (state == NULL) {
        return NULL;
    }
    int res = PyMonitoring_FireStopIterationEvent(state, codelike, offset, value);
    RETURN_INT(teardown_fire(res, state, exception));
}

/*******************************************************************/

static PyObject *
enter_scope(PyObject *self, PyObject *args)
{
    PyObject *codelike;
    int event1, event2=0;
    Py_ssize_t num_events = PyTuple_Size(args) - 1;
    if (num_events == 1) {
        if (!PyArg_ParseTuple(args, "Oi", &codelike, &event1)) {
            return NULL;
        }
    }
    else {
        assert(num_events == 2);
        if (!PyArg_ParseTuple(args, "Oii", &codelike, &event1, &event2)) {
            return NULL;
        }
    }
    RAISE_UNLESS_CODELIKE(codelike);
    PyCodeLikeObject *cl = (PyCodeLikeObject *) codelike;

    uint8_t events[] = { event1, event2 };

    PyMonitoring_EnterScope(cl->monitoring_states,
                            &cl->version,
                            events,
                            num_events);

    Py_RETURN_NONE;
}

static PyObject *
exit_scope(PyObject *self, PyObject *args)
{
    PyMonitoring_ExitScope();
    Py_RETURN_NONE;
}

static PyMethodDef TestMethods[] = {
    {"fire_event_py_start", fire_event_py_start, METH_VARARGS},
    {"fire_event_py_resume", fire_event_py_resume, METH_VARARGS},
    {"fire_event_py_return", fire_event_py_return, METH_VARARGS},
    {"fire_event_c_return", fire_event_c_return, METH_VARARGS},
    {"fire_event_py_yield", fire_event_py_yield, METH_VARARGS},
    {"fire_event_call", fire_event_call, METH_VARARGS},
    {"fire_event_line", fire_event_line, METH_VARARGS},
    {"fire_event_jump", fire_event_jump, METH_VARARGS},
    {"fire_event_branch_left", fire_event_branch_left, METH_VARARGS},
    {"fire_event_branch_right", fire_event_branch_right, METH_VARARGS},
    {"fire_event_py_throw", fire_event_py_throw, METH_VARARGS},
    {"fire_event_raise", fire_event_raise, METH_VARARGS},
    {"fire_event_c_raise", fire_event_c_raise, METH_VARARGS},
    {"fire_event_reraise", fire_event_reraise, METH_VARARGS},
    {"fire_event_exception_handled", fire_event_exception_handled, METH_VARARGS},
    {"fire_event_py_unwind", fire_event_py_unwind, METH_VARARGS},
    {"fire_event_stop_iteration", fire_event_stop_iteration, METH_VARARGS},
    {"monitoring_enter_scope", enter_scope, METH_VARARGS},
    {"monitoring_exit_scope", exit_scope, METH_VARARGS},
    {NULL},
};

int
_PyTestCapi_Init_Monitoring(PyObject *m)
{
    if (PyType_Ready(&PyCodeLike_Type) < 0) {
        return -1;
    }
    if (PyModule_AddObjectRef(m, "CodeLike", (PyObject *) &PyCodeLike_Type) < 0) {
        Py_DECREF(m);
        return -1;
    }
    if (PyModule_AddFunctions(m, TestMethods) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testcapi/numbers.c
================================================
#include "parts.h"
#include "util.h"


static PyObject *
number_check(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyNumber_Check(obj));
}

#define BINARYFUNC(funcsuffix, methsuffix)                           \
    static PyObject *                                                \
    number_##methsuffix(PyObject *Py_UNUSED(module), PyObject *args) \
    {                                                                \
        PyObject *o1, *o2;                                           \
                                                                     \
        if (!PyArg_ParseTuple(args, "OO", &o1, &o2)) {               \
            return NULL;                                             \
        }                                                            \
                                                                     \
        NULLABLE(o1);                                                \
        NULLABLE(o2);                                                \
        return PyNumber_##funcsuffix(o1, o2);                        \
    };

BINARYFUNC(Add, add)
BINARYFUNC(Subtract, subtract)
BINARYFUNC(Multiply, multiply)
BINARYFUNC(MatrixMultiply, matrixmultiply)
BINARYFUNC(FloorDivide, floordivide)
BINARYFUNC(TrueDivide, truedivide)
BINARYFUNC(Remainder, remainder)
BINARYFUNC(Divmod, divmod)

#define TERNARYFUNC(funcsuffix, methsuffix)                          \
    static PyObject *                                                \
    number_##methsuffix(PyObject *Py_UNUSED(module), PyObject *args) \
    {                                                                \
        PyObject *o1, *o2, *o3 = Py_None;                            \
                                                                     \
        if (!PyArg_ParseTuple(args, "OO|O", &o1, &o2, &o3)) {        \
            return NULL;                                             \
        }                                                            \
                                                                     \
        NULLABLE(o1);                                                \
        NULLABLE(o2);                                                \
        return PyNumber_##funcsuffix(o1, o2, o3);                    \
    };

TERNARYFUNC(Power, power)

#define UNARYFUNC(funcsuffix, methsuffix)                            \
    static PyObject *                                                \
    number_##methsuffix(PyObject *Py_UNUSED(module), PyObject *obj)  \
    {                                                                \
        NULLABLE(obj);                                               \
        return PyNumber_##funcsuffix(obj);                           \
    };

UNARYFUNC(Negative, negative)
UNARYFUNC(Positive, positive)
UNARYFUNC(Absolute, absolute)
UNARYFUNC(Invert, invert)

BINARYFUNC(Lshift, lshift)
BINARYFUNC(Rshift, rshift)
BINARYFUNC(And, and)
BINARYFUNC(Xor, xor)
BINARYFUNC(Or, or)

BINARYFUNC(InPlaceAdd, inplaceadd)
BINARYFUNC(InPlaceSubtract, inplacesubtract)
BINARYFUNC(InPlaceMultiply, inplacemultiply)
BINARYFUNC(InPlaceMatrixMultiply, inplacematrixmultiply)
BINARYFUNC(InPlaceFloorDivide, inplacefloordivide)
BINARYFUNC(InPlaceTrueDivide, inplacetruedivide)
BINARYFUNC(InPlaceRemainder, inplaceremainder)

TERNARYFUNC(InPlacePower, inplacepower)

BINARYFUNC(InPlaceLshift, inplacelshift)
BINARYFUNC(InPlaceRshift, inplacershift)
BINARYFUNC(InPlaceAnd, inplaceand)
BINARYFUNC(InPlaceXor, inplacexor)
BINARYFUNC(InPlaceOr, inplaceor)

UNARYFUNC(Long, long)
UNARYFUNC(Float, float)
UNARYFUNC(Index, index)

static PyObject *
number_tobase(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *n;
    int base;

    if (!PyArg_ParseTuple(args, "Oi", &n, &base)) {
        return NULL;
    }

    NULLABLE(n);
    return PyNumber_ToBase(n, base);
}

static PyObject *
number_asssizet(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *o, *exc;
    Py_ssize_t ret;

    if (!PyArg_ParseTuple(args, "OO", &o, &exc)) {
        return NULL;
    }

    NULLABLE(o);
    NULLABLE(exc);
    ret = PyNumber_AsSsize_t(o, exc);

    if (ret == (Py_ssize_t)(-1) && PyErr_Occurred()) {
        return NULL;
    }

    return PyLong_FromSsize_t(ret);
}


static PyMethodDef test_methods[] = {
    {"number_check", number_check, METH_O},
    {"number_add", number_add, METH_VARARGS},
    {"number_subtract", number_subtract, METH_VARARGS},
    {"number_multiply", number_multiply, METH_VARARGS},
    {"number_matrixmultiply", number_matrixmultiply, METH_VARARGS},
    {"number_floordivide", number_floordivide, METH_VARARGS},
    {"number_truedivide", number_truedivide, METH_VARARGS},
    {"number_remainder", number_remainder, METH_VARARGS},
    {"number_divmod", number_divmod, METH_VARARGS},
    {"number_power", number_power, METH_VARARGS},
    {"number_negative", number_negative, METH_O},
    {"number_positive", number_positive, METH_O},
    {"number_absolute", number_absolute, METH_O},
    {"number_invert", number_invert, METH_O},
    {"number_lshift", number_lshift, METH_VARARGS},
    {"number_rshift", number_rshift, METH_VARARGS},
    {"number_and", number_and, METH_VARARGS},
    {"number_xor", number_xor, METH_VARARGS},
    {"number_or", number_or, METH_VARARGS},
    {"number_inplaceadd", number_inplaceadd, METH_VARARGS},
    {"number_inplacesubtract", number_inplacesubtract, METH_VARARGS},
    {"number_inplacemultiply", number_inplacemultiply, METH_VARARGS},
    {"number_inplacematrixmultiply", number_inplacematrixmultiply, METH_VARARGS},
    {"number_inplacefloordivide", number_inplacefloordivide, METH_VARARGS},
    {"number_inplacetruedivide", number_inplacetruedivide, METH_VARARGS},
    {"number_inplaceremainder", number_inplaceremainder, METH_VARARGS},
    {"number_inplacepower", number_inplacepower, METH_VARARGS},
    {"number_inplacelshift", number_inplacelshift, METH_VARARGS},
    {"number_inplacershift", number_inplacershift, METH_VARARGS},
    {"number_inplaceand", number_inplaceand, METH_VARARGS},
    {"number_inplacexor", number_inplacexor, METH_VARARGS},
    {"number_inplaceor", number_inplaceor, METH_VARARGS},
    {"number_long", number_long, METH_O},
    {"number_float", number_float, METH_O},
    {"number_index", number_index, METH_O},
    {"number_tobase", number_tobase, METH_VARARGS},
    {"number_asssizet", number_asssizet, METH_VARARGS},
    {NULL},
};

int
_PyTestCapi_Init_Numbers(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/object.c
================================================
#include "parts.h"
#include "util.h"

static PyObject *
call_pyobject_print(PyObject *self, PyObject * args)
{
    PyObject *object;
    PyObject *filename;
    PyObject *print_raw;
    FILE *fp;
    int flags = 0;

    if (!PyArg_UnpackTuple(args, "call_pyobject_print", 3, 3,
                           &object, &filename, &print_raw)) {
        return NULL;
    }

    fp = Py_fopen(filename, "w+");

    if (Py_IsTrue(print_raw)) {
        flags = Py_PRINT_RAW;
    }

    if (PyObject_Print(object, fp, flags) < 0) {
        fclose(fp);
        return NULL;
    }

    fclose(fp);

    Py_RETURN_NONE;
}

static PyObject *
pyobject_print_null(PyObject *self, PyObject *args)
{
    PyObject *filename;
    FILE *fp;

    if (!PyArg_UnpackTuple(args, "call_pyobject_print", 1, 1, &filename)) {
        return NULL;
    }

    fp = Py_fopen(filename, "w+");

    if (PyObject_Print(NULL, fp, 0) < 0) {
        fclose(fp);
        return NULL;
    }

    fclose(fp);

    Py_RETURN_NONE;
}

static PyObject *
pyobject_print_noref_object(PyObject *self, PyObject *args)
{
    PyObject *test_string;
    PyObject *filename;
    FILE *fp;
    char correct_string[100];

    test_string = PyUnicode_FromString("Spam spam spam");

    Py_SET_REFCNT(test_string, 0);

    PyOS_snprintf(correct_string, 100, "<refcnt %zd at %p>",
                  Py_REFCNT(test_string), (void *)test_string);

    if (!PyArg_UnpackTuple(args, "call_pyobject_print", 1, 1, &filename)) {
        return NULL;
    }

    fp = Py_fopen(filename, "w+");

    if (PyObject_Print(test_string, fp, 0) < 0){
        fclose(fp);
        Py_SET_REFCNT(test_string, 1);
        Py_DECREF(test_string);
        return NULL;
    }

    fclose(fp);

    Py_SET_REFCNT(test_string, 1);
    Py_DECREF(test_string);

    return PyUnicode_FromString(correct_string);
}

static PyObject *
pyobject_print_os_error(PyObject *self, PyObject *args)
{
    PyObject *test_string;
    PyObject *filename;
    FILE *fp;

    test_string = PyUnicode_FromString("Spam spam spam");

    if (!PyArg_UnpackTuple(args, "call_pyobject_print", 1, 1, &filename)) {
        return NULL;
    }

    // open file in read mode to induce OSError
    fp = Py_fopen(filename, "r");

    if (PyObject_Print(test_string, fp, 0) < 0) {
        fclose(fp);
        Py_DECREF(test_string);
        return NULL;
    }

    fclose(fp);
    Py_DECREF(test_string);

    Py_RETURN_NONE;
}

static PyObject *
pyobject_clear_weakrefs_no_callbacks(PyObject *self, PyObject *obj)
{
    PyUnstable_Object_ClearWeakRefsNoCallbacks(obj);
    Py_RETURN_NONE;
}

static PyObject *
pyobject_enable_deferred_refcount(PyObject *self, PyObject *obj)
{
    int result = PyUnstable_Object_EnableDeferredRefcount(obj);
    return PyLong_FromLong(result);
}

static PyMethodDef test_methods[] = {
    {"call_pyobject_print", call_pyobject_print, METH_VARARGS},
    {"pyobject_print_null", pyobject_print_null, METH_VARARGS},
    {"pyobject_print_noref_object", pyobject_print_noref_object, METH_VARARGS},
    {"pyobject_print_os_error", pyobject_print_os_error, METH_VARARGS},
    {"pyobject_clear_weakrefs_no_callbacks", pyobject_clear_weakrefs_no_callbacks, METH_O},
    {"pyobject_enable_deferred_refcount", pyobject_enable_deferred_refcount, METH_O},
    {NULL},
};

int
_PyTestCapi_Init_Object(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/parts.h
================================================
#ifndef Py_TESTCAPI_PARTS_H
#define Py_TESTCAPI_PARTS_H

// Always enable assertions
#undef NDEBUG

#ifdef PYTESTCAPI_NEED_INTERNAL_API
#  ifndef Py_BUILD_CORE_BUILTIN
#    define Py_BUILD_CORE_MODULE 1
#  endif
#else
   // The _testcapi extension tests the public C API: header files in Include/
   // and Include/cpython/ directories. The internal C API must not be tested
   // by _testcapi: use _testinternalcapi for that.
   //
   // _testcapi C files can built with the Py_BUILD_CORE_BUILTIN macro defined
   // if one of the Modules/Setup files asks to build _testcapi as "static"
   // (gh-109723).
   //
   // The Visual Studio projects builds _testcapi with Py_BUILD_CORE_MODULE.
#  undef Py_BUILD_CORE_MODULE
#  undef Py_BUILD_CORE_BUILTIN
#endif

#include "Python.h"

#if defined(Py_BUILD_CORE) && !defined(PYTESTCAPI_NEED_INTERNAL_API)
#  error "_testcapi must test the public Python C API, not the internal C API"
#endif

int _PyTestCapi_Init_Vectorcall(PyObject *module);
int _PyTestCapi_Init_Heaptype(PyObject *module);
int _PyTestCapi_Init_Abstract(PyObject *module);
int _PyTestCapi_Init_Bytes(PyObject *module);
int _PyTestCapi_Init_Unicode(PyObject *module);
int _PyTestCapi_Init_GetArgs(PyObject *module);
int _PyTestCapi_Init_DateTime(PyObject *module);
int _PyTestCapi_Init_Docstring(PyObject *module);
int _PyTestCapi_Init_Mem(PyObject *module);
int _PyTestCapi_Init_Watchers(PyObject *module);
int _PyTestCapi_Init_Long(PyObject *module);
int _PyTestCapi_Init_Float(PyObject *module);
int _PyTestCapi_Init_Complex(PyObject *module);
int _PyTestCapi_Init_Numbers(PyObject *module);
int _PyTestCapi_Init_Dict(PyObject *module);
int _PyTestCapi_Init_Set(PyObject *module);
int _PyTestCapi_Init_List(PyObject *module);
int _PyTestCapi_Init_Tuple(PyObject *module);
int _PyTestCapi_Init_Structmember(PyObject *module);
int _PyTestCapi_Init_Exceptions(PyObject *module);
int _PyTestCapi_Init_Code(PyObject *module);
int _PyTestCapi_Init_Buffer(PyObject *module);
int _PyTestCapi_Init_PyAtomic(PyObject *module);
int _PyTestCapi_Init_Run(PyObject *module);
int _PyTestCapi_Init_File(PyObject *module);
int _PyTestCapi_Init_Codec(PyObject *module);
int _PyTestCapi_Init_Immortal(PyObject *module);
int _PyTestCapi_Init_GC(PyObject *module);
int _PyTestCapi_Init_Hash(PyObject *module);
int _PyTestCapi_Init_Time(PyObject *module);
int _PyTestCapi_Init_Monitoring(PyObject *module);
int _PyTestCapi_Init_Object(PyObject *module);
int _PyTestCapi_Init_Config(PyObject *mod);

#endif // Py_TESTCAPI_PARTS_H


================================================
File: /Modules/_testcapi/pyatomic.c
================================================
/*
 * C Extension module to smoke test pyatomic.h API.
 *
 * This only tests basic functionality, not any synchronizing ordering.
 */

#include "parts.h"

// We define atomic bitwise operations on these types
#define FOR_BITWISE_TYPES(V)    \
    V(uint8, uint8_t)           \
    V(uint16, uint16_t)         \
    V(uint32, uint32_t)         \
    V(uint64, uint64_t)         \
    V(uintptr, uintptr_t)

// We define atomic addition on these types
#define FOR_ARITHMETIC_TYPES(V) \
    FOR_BITWISE_TYPES(V)        \
    V(int, int)                 \
    V(uint, unsigned int)       \
    V(int8, int8_t)             \
    V(int16, int16_t)           \
    V(int32, int32_t)           \
    V(int64, int64_t)           \
    V(intptr, intptr_t)         \
    V(ssize, Py_ssize_t)

// We define atomic load, store, exchange, and compare_exchange on these types
#define FOR_ALL_TYPES(V)        \
    FOR_ARITHMETIC_TYPES(V)     \
    V(ptr, void*)

#define IMPL_TEST_ADD(suffix, dtype) \
static PyObject * \
test_atomic_add_##suffix(PyObject *self, PyObject *obj) { \
    dtype x = 0; \
    assert(_Py_atomic_add_##suffix(&x, 1) == 0); \
    assert(x == 1); \
    assert(_Py_atomic_add_##suffix(&x, 2) == 1); \
    assert(x == 3); \
    assert(_Py_atomic_add_##suffix(&x, -2) == 3); \
    assert(x == 1); \
    assert(_Py_atomic_add_##suffix(&x, -1) == 1); \
    assert(x == 0); \
    assert(_Py_atomic_add_##suffix(&x, -1) == 0); \
    assert(x == (dtype)-1); \
    assert(_Py_atomic_add_##suffix(&x, -2) == (dtype)-1); \
    assert(x == (dtype)-3); \
    assert(_Py_atomic_add_##suffix(&x, 2) == (dtype)-3); \
    assert(x == (dtype)-1); \
    Py_RETURN_NONE; \
}
FOR_ARITHMETIC_TYPES(IMPL_TEST_ADD)

#define IMPL_TEST_COMPARE_EXCHANGE(suffix, dtype) \
static PyObject * \
test_atomic_compare_exchange_##suffix(PyObject *self, PyObject *obj) { \
    dtype x = (dtype)0; \
    dtype y = (dtype)1; \
    dtype z = (dtype)2; \
    assert(_Py_atomic_compare_exchange_##suffix(&x, &y, z) == 0); \
    assert(x == 0); \
    assert(y == 0); \
    assert(_Py_atomic_compare_exchange_##suffix(&x, &y, z) == 1); \
    assert(x == z); \
    assert(y == 0); \
    assert(_Py_atomic_compare_exchange_##suffix(&x, &y, z) == 0); \
    assert(x == z); \
    assert(y == z); \
    Py_RETURN_NONE; \
}
FOR_ALL_TYPES(IMPL_TEST_COMPARE_EXCHANGE)

#define IMPL_TEST_EXCHANGE(suffix, dtype) \
static PyObject * \
test_atomic_exchange_##suffix(PyObject *self, PyObject *obj) { \
    dtype x = (dtype)0; \
    dtype y = (dtype)1; \
    dtype z = (dtype)2; \
    assert(_Py_atomic_exchange_##suffix(&x, y) == (dtype)0); \
    assert(x == (dtype)1); \
    assert(_Py_atomic_exchange_##suffix(&x, z) == (dtype)1); \
    assert(x == (dtype)2); \
    assert(_Py_atomic_exchange_##suffix(&x, y) == (dtype)2); \
    assert(x == (dtype)1); \
    Py_RETURN_NONE; \
}
FOR_ALL_TYPES(IMPL_TEST_EXCHANGE)

#define IMPL_TEST_LOAD_STORE(suffix, dtype) \
static PyObject * \
test_atomic_load_store_##suffix(PyObject *self, PyObject *obj) { \
    dtype x = (dtype)0; \
    dtype y = (dtype)1; \
    dtype z = (dtype)2; \
    assert(_Py_atomic_load_##suffix(&x) == (dtype)0); \
    assert(x == (dtype)0); \
    _Py_atomic_store_##suffix(&x, y); \
    assert(_Py_atomic_load_##suffix(&x) == (dtype)1); \
    assert(x == (dtype)1); \
    _Py_atomic_store_##suffix##_relaxed(&x, z); \
    assert(_Py_atomic_load_##suffix##_relaxed(&x) == (dtype)2); \
    assert(x == (dtype)2); \
    Py_RETURN_NONE; \
}
FOR_ALL_TYPES(IMPL_TEST_LOAD_STORE)

#define IMPL_TEST_AND_OR(suffix, dtype) \
static PyObject * \
test_atomic_and_or_##suffix(PyObject *self, PyObject *obj) { \
    dtype x = (dtype)0; \
    dtype y = (dtype)1; \
    dtype z = (dtype)3; \
    assert(_Py_atomic_or_##suffix(&x, z) == (dtype)0); \
    assert(x == (dtype)3); \
    assert(_Py_atomic_and_##suffix(&x, y) == (dtype)3); \
    assert(x == (dtype)1); \
    Py_RETURN_NONE; \
}
FOR_BITWISE_TYPES(IMPL_TEST_AND_OR)

static PyObject *
test_atomic_fences(PyObject *self, PyObject *obj) {
    // Just make sure that the fences compile. We are not
    // testing any synchronizing ordering.
    _Py_atomic_fence_seq_cst();
    _Py_atomic_fence_acquire();
    _Py_atomic_fence_release();
    Py_RETURN_NONE;
}

static PyObject *
test_atomic_release_acquire(PyObject *self, PyObject *obj) {
    void *x = NULL;
    void *y = &y;
    assert(_Py_atomic_load_ptr_acquire(&x) == NULL);
    _Py_atomic_store_ptr_release(&x, y);
    assert(x == y);
    assert(_Py_atomic_load_ptr_acquire(&x) == y);
    Py_RETURN_NONE;
}

static PyObject *
test_atomic_load_store_int_release_acquire(PyObject *self, PyObject *obj) { \
    int x = 0;
    int y = 1;
    int z = 2;
    assert(_Py_atomic_load_int_acquire(&x) == 0);
    _Py_atomic_store_int_release(&x, y);
    assert(x == y);
    assert(_Py_atomic_load_int_acquire(&x) == y);
    _Py_atomic_store_int_release(&x, z);
    assert(x == z);
    assert(_Py_atomic_load_int_acquire(&x) == z);
    Py_RETURN_NONE;
}

// NOTE: all tests should start with "test_atomic_" to be included
// in test_pyatomic.py

#define BIND_TEST_ADD(suffix, dtype) \
    {"test_atomic_add_" #suffix, test_atomic_add_##suffix, METH_NOARGS},
#define BIND_TEST_COMPARE_EXCHANGE(suffix, dtype) \
    {"test_atomic_compare_exchange_" #suffix, test_atomic_compare_exchange_##suffix, METH_NOARGS},
#define BIND_TEST_EXCHANGE(suffix, dtype) \
    {"test_atomic_exchange_" #suffix, test_atomic_exchange_##suffix, METH_NOARGS},
#define BIND_TEST_LOAD_STORE(suffix, dtype) \
    {"test_atomic_load_store_" #suffix, test_atomic_load_store_##suffix, METH_NOARGS},
#define BIND_TEST_AND_OR(suffix, dtype) \
    {"test_atomic_and_or_" #suffix, test_atomic_and_or_##suffix, METH_NOARGS},

static PyMethodDef test_methods[] = {
    FOR_ARITHMETIC_TYPES(BIND_TEST_ADD)
    FOR_ALL_TYPES(BIND_TEST_COMPARE_EXCHANGE)
    FOR_ALL_TYPES(BIND_TEST_EXCHANGE)
    FOR_ALL_TYPES(BIND_TEST_LOAD_STORE)
    FOR_BITWISE_TYPES(BIND_TEST_AND_OR)
    {"test_atomic_fences", test_atomic_fences, METH_NOARGS},
    {"test_atomic_release_acquire", test_atomic_release_acquire, METH_NOARGS},
    {"test_atomic_load_store_int_release_acquire", test_atomic_load_store_int_release_acquire, METH_NOARGS},
    {NULL, NULL} /* sentinel */
};

int
_PyTestCapi_Init_PyAtomic(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testcapi/run.c
================================================
#define PYTESTCAPI_NEED_INTERNAL_API
#include "parts.h"
#include "util.h"
#include "pycore_fileutils.h"     // _Py_IsValidFD()

#include <stdio.h>
#include <errno.h>


static PyObject *
run_stringflags(PyObject *mod, PyObject *pos_args)
{
    const char *str;
    Py_ssize_t size;
    int start;
    PyObject *globals = NULL;
    PyObject *locals = NULL;
    PyCompilerFlags flags = _PyCompilerFlags_INIT;
    PyCompilerFlags *pflags = NULL;
    int cf_flags = 0;
    int cf_feature_version = 0;

    if (!PyArg_ParseTuple(pos_args, "z#iO|Oii",
                          &str, &size, &start, &globals, &locals,
                          &cf_flags, &cf_feature_version)) {
        return NULL;
    }

    NULLABLE(globals);
    NULLABLE(locals);
    if (cf_flags || cf_feature_version) {
        flags.cf_flags = cf_flags;
        flags.cf_feature_version = cf_feature_version;
        pflags = &flags;
    }

    return PyRun_StringFlags(str, start, globals, locals, pflags);
}

static PyObject *
run_fileexflags(PyObject *mod, PyObject *pos_args)
{
    PyObject *result = NULL;
    const char *filename = NULL;
    Py_ssize_t filename_size;
    int start;
    PyObject *globals = NULL;
    PyObject *locals = NULL;
    int closeit = 0;
    PyCompilerFlags flags = _PyCompilerFlags_INIT;
    PyCompilerFlags *pflags = NULL;
    int cf_flags = 0;
    int cf_feature_version = 0;

    FILE *fp = NULL;

    if (!PyArg_ParseTuple(pos_args, "z#iO|Oiii",
                          &filename, &filename_size, &start, &globals, &locals,
                          &closeit, &cf_flags, &cf_feature_version)) {
        return NULL;
    }

    NULLABLE(globals);
    NULLABLE(locals);
    if (cf_flags || cf_feature_version) {
        flags.cf_flags = cf_flags;
        flags.cf_feature_version = cf_feature_version;
        pflags = &flags;
    }

    fp = fopen(filename, "r");
    if (fp == NULL) {
        PyErr_SetFromErrnoWithFilename(PyExc_OSError, filename);
        return NULL;
    }
    int fd = fileno(fp);

    result = PyRun_FileExFlags(fp, filename, start, globals, locals, closeit, pflags);

    if (closeit && result && _Py_IsValidFD(fd)) {
        PyErr_SetString(PyExc_AssertionError, "File was not closed after execution");
        Py_DECREF(result);
        fclose(fp);
        return NULL;
    }

    if (!closeit && !_Py_IsValidFD(fd)) {
        PyErr_SetString(PyExc_AssertionError, "Bad file descriptor after execution");
        Py_XDECREF(result);
        return NULL;
    }

    if (!closeit) {
        fclose(fp); /* don't need open file any more*/
    }

    return result;
}

static PyMethodDef test_methods[] = {
    {"run_stringflags", run_stringflags, METH_VARARGS},
    {"run_fileexflags", run_fileexflags, METH_VARARGS},
    {NULL},
};

int
_PyTestCapi_Init_Run(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testcapi/set.c
================================================
#include "parts.h"
#include "util.h"

static PyObject *
set_get_size(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_SIZE(PySet_GET_SIZE(obj));
}

static PyMethodDef test_methods[] = {
    {"set_get_size", set_get_size, METH_O},

    {NULL},
};

int
_PyTestCapi_Init_Set(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/structmember.c
================================================
#include "parts.h"
#include <stddef.h>   // for offsetof()


// This defines two classes that contain all the simple member types, one
// using "new" Py_-prefixed API, and the other using "old" <structmember.h>.
// They should behave identically in Python.

typedef struct {
    char bool_member;
    char byte_member;
    unsigned char ubyte_member;
    short short_member;
    unsigned short ushort_member;
    int int_member;
    unsigned int uint_member;
    long long_member;
    unsigned long ulong_member;
    Py_ssize_t pyssizet_member;
    float float_member;
    double double_member;
    char inplace_member[6];
    long long longlong_member;
    unsigned long long ulonglong_member;
    char char_member;
} all_structmembers;

typedef struct {
    PyObject_HEAD
    all_structmembers structmembers;
} test_structmembers;


static struct PyMemberDef test_members_newapi[] = {
    {"T_BOOL", Py_T_BOOL, offsetof(test_structmembers, structmembers.bool_member), 0, NULL},
    {"T_BYTE", Py_T_BYTE, offsetof(test_structmembers, structmembers.byte_member), 0, NULL},
    {"T_UBYTE", Py_T_UBYTE, offsetof(test_structmembers, structmembers.ubyte_member), 0, NULL},
    {"T_SHORT", Py_T_SHORT, offsetof(test_structmembers, structmembers.short_member), 0, NULL},
    {"T_USHORT", Py_T_USHORT, offsetof(test_structmembers, structmembers.ushort_member), 0, NULL},
    {"T_INT", Py_T_INT, offsetof(test_structmembers, structmembers.int_member), 0, NULL},
    {"T_UINT", Py_T_UINT, offsetof(test_structmembers, structmembers.uint_member), 0, NULL},
    {"T_LONG", Py_T_LONG, offsetof(test_structmembers, structmembers.long_member), 0, NULL},
    {"T_ULONG", Py_T_ULONG, offsetof(test_structmembers, structmembers.ulong_member), 0, NULL},
    {"T_PYSSIZET", Py_T_PYSSIZET, offsetof(test_structmembers, structmembers.pyssizet_member), 0, NULL},
    {"T_FLOAT", Py_T_FLOAT, offsetof(test_structmembers, structmembers.float_member), 0, NULL},
    {"T_DOUBLE", Py_T_DOUBLE, offsetof(test_structmembers, structmembers.double_member), 0, NULL},
    {"T_STRING_INPLACE", Py_T_STRING_INPLACE, offsetof(test_structmembers, structmembers.inplace_member), 0, NULL},
    {"T_LONGLONG", Py_T_LONGLONG, offsetof(test_structmembers, structmembers.longlong_member), 0, NULL},
    {"T_ULONGLONG", Py_T_ULONGLONG, offsetof(test_structmembers, structmembers.ulonglong_member), 0, NULL},
    {"T_CHAR", Py_T_CHAR, offsetof(test_structmembers, structmembers.char_member), 0, NULL},
    {NULL}
};

static PyObject *
test_structmembers_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
    static char *keywords[] = {
        "T_BOOL", "T_BYTE", "T_UBYTE", "T_SHORT", "T_USHORT",
        "T_INT", "T_UINT", "T_LONG", "T_ULONG", "T_PYSSIZET",
        "T_FLOAT", "T_DOUBLE", "T_STRING_INPLACE",
        "T_LONGLONG", "T_ULONGLONG", "T_CHAR",
        NULL};
    static const char fmt[] = "|bbBhHiIlknfds#LKc";
    test_structmembers *ob;
    const char *s = NULL;
    Py_ssize_t string_len = 0;
    ob = PyObject_New(test_structmembers, type);
    if (ob == NULL) {
        return NULL;
    }
    memset(&ob->structmembers, 0, sizeof(all_structmembers));
    if (!PyArg_ParseTupleAndKeywords(args, kwargs, fmt, keywords,
                                     &ob->structmembers.bool_member,
                                     &ob->structmembers.byte_member,
                                     &ob->structmembers.ubyte_member,
                                     &ob->structmembers.short_member,
                                     &ob->structmembers.ushort_member,
                                     &ob->structmembers.int_member,
                                     &ob->structmembers.uint_member,
                                     &ob->structmembers.long_member,
                                     &ob->structmembers.ulong_member,
                                     &ob->structmembers.pyssizet_member,
                                     &ob->structmembers.float_member,
                                     &ob->structmembers.double_member,
                                     &s, &string_len,
                                     &ob->structmembers.longlong_member,
                                     &ob->structmembers.ulonglong_member,
                                     &ob->structmembers.char_member))
    {
        Py_DECREF(ob);
        return NULL;
    }
    if (s != NULL) {
        if (string_len > 5) {
            Py_DECREF(ob);
            PyErr_SetString(PyExc_ValueError, "string too long");
            return NULL;
        }
        strcpy(ob->structmembers.inplace_member, s);
    }
    else {
        strcpy(ob->structmembers.inplace_member, "");
    }
    return (PyObject *)ob;
}

static PyType_Slot test_structmembers_slots[] = {
    {Py_tp_new, test_structmembers_new},
    {Py_tp_members, test_members_newapi},
    {0},
};

static PyType_Spec test_structmembers_spec = {
    .name = "_testcapi._test_structmembersType_NewAPI",
    .flags = Py_TPFLAGS_DEFAULT,
    .basicsize = sizeof(test_structmembers),
    .slots = test_structmembers_slots,
};

#include <structmember.h>

static struct PyMemberDef test_members[] = {
    {"T_BOOL", T_BOOL, offsetof(test_structmembers, structmembers.bool_member), 0, NULL},
    {"T_BYTE", T_BYTE, offsetof(test_structmembers, structmembers.byte_member), 0, NULL},
    {"T_UBYTE", T_UBYTE, offsetof(test_structmembers, structmembers.ubyte_member), 0, NULL},
    {"T_SHORT", T_SHORT, offsetof(test_structmembers, structmembers.short_member), 0, NULL},
    {"T_USHORT", T_USHORT, offsetof(test_structmembers, structmembers.ushort_member), 0, NULL},
    {"T_INT", T_INT, offsetof(test_structmembers, structmembers.int_member), 0, NULL},
    {"T_UINT", T_UINT, offsetof(test_structmembers, structmembers.uint_member), 0, NULL},
    {"T_LONG", T_LONG, offsetof(test_structmembers, structmembers.long_member), 0, NULL},
    {"T_ULONG", T_ULONG, offsetof(test_structmembers, structmembers.ulong_member), 0, NULL},
    {"T_PYSSIZET", T_PYSSIZET, offsetof(test_structmembers, structmembers.pyssizet_member), 0, NULL},
    {"T_FLOAT", T_FLOAT, offsetof(test_structmembers, structmembers.float_member), 0, NULL},
    {"T_DOUBLE", T_DOUBLE, offsetof(test_structmembers, structmembers.double_member), 0, NULL},
    {"T_STRING_INPLACE", T_STRING_INPLACE, offsetof(test_structmembers, structmembers.inplace_member), 0, NULL},
    {"T_LONGLONG", T_LONGLONG, offsetof(test_structmembers, structmembers.longlong_member), 0, NULL},
    {"T_ULONGLONG", T_ULONGLONG, offsetof(test_structmembers, structmembers.ulonglong_member), 0, NULL},
    {"T_CHAR", T_CHAR, offsetof(test_structmembers, structmembers.char_member), 0, NULL},
    {NULL}
};


static void
test_structmembers_free(PyObject *ob)
{
    PyObject_Free(ob);
}

/* Designated initializers would work too, but this does test the *old* API */
static PyTypeObject test_structmembersType_OldAPI= {
    PyVarObject_HEAD_INIT(NULL, 0)
    "test_structmembersType_OldAPI",
    sizeof(test_structmembers),         /* tp_basicsize */
    0,                                  /* tp_itemsize */
    test_structmembers_free,            /* destructor tp_dealloc */
    0,                                  /* tp_vectorcall_offset */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    0,                                  /* tp_as_async */
    0,                                  /* tp_repr */
    0,                                  /* tp_as_number */
    0,                                  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_hash */
    0,                                  /* tp_call */
    0,                                  /* tp_str */
    PyObject_GenericGetAttr,            /* tp_getattro */
    PyObject_GenericSetAttr,            /* tp_setattro */
    0,                                  /* tp_as_buffer */
    0,                                  /* tp_flags */
    "Type containing all structmember types",
    0,                                  /* traverseproc tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompare */
    0,                                  /* tp_weaklistoffset */
    0,                                  /* tp_iter */
    0,                                  /* tp_iternext */
    0,                                  /* tp_methods */
    test_members,                       /* tp_members */
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    test_structmembers_new,             /* tp_new */
};


int
_PyTestCapi_Init_Structmember(PyObject *m)
{
    int res;
    res = PyType_Ready(&test_structmembersType_OldAPI);
    if (res < 0) {
        return -1;
    }
    res = PyModule_AddObjectRef(
        m,
        "_test_structmembersType_OldAPI",
        (PyObject *)&test_structmembersType_OldAPI);
    if (res < 0) {
        return -1;
    }

    PyObject *test_structmembersType_NewAPI = PyType_FromModuleAndSpec(
        m, &test_structmembers_spec, NULL);
    if (!test_structmembersType_NewAPI) {
        return -1;
    }
    res = PyModule_AddType(m, (PyTypeObject*)test_structmembersType_NewAPI);
    Py_DECREF(test_structmembersType_NewAPI);
    if (res < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/time.c
================================================
#include "parts.h"


static int
pytime_from_nanoseconds(PyTime_t *tp, PyObject *obj)
{
    if (!PyLong_Check(obj)) {
        PyErr_Format(PyExc_TypeError, "expect int, got %s",
                     Py_TYPE(obj)->tp_name);
        return -1;
    }

    long long nsec = PyLong_AsLongLong(obj);
    if (nsec == -1 && PyErr_Occurred()) {
        return -1;
    }

    Py_BUILD_ASSERT(sizeof(long long) == sizeof(PyTime_t));
    *tp = (PyTime_t)nsec;
    return 0;
}


static PyObject *
test_pytime_assecondsdouble(PyObject *Py_UNUSED(self), PyObject *args)
{
    PyObject *obj;
    if (!PyArg_ParseTuple(args, "O", &obj)) {
        return NULL;
    }
    PyTime_t ts;
    if (pytime_from_nanoseconds(&ts, obj) < 0) {
        return NULL;
    }
    double d = PyTime_AsSecondsDouble(ts);
    return PyFloat_FromDouble(d);
}


static PyObject*
pytime_as_float(PyTime_t t)
{
    return PyFloat_FromDouble(PyTime_AsSecondsDouble(t));
}



static PyObject*
test_pytime_monotonic(PyObject *Py_UNUSED(self), PyObject *Py_UNUSED(args))
{
    PyTime_t t;
    int res = PyTime_Monotonic(&t);
    if (res < 0) {
        assert(t == 0);
        return NULL;
    }
    assert(res == 0);
    return pytime_as_float(t);
}


static PyObject*
test_pytime_monotonic_raw(PyObject *Py_UNUSED(self), PyObject *Py_UNUSED(args))
{
    PyTime_t t;
    int res;
    Py_BEGIN_ALLOW_THREADS
    res = PyTime_MonotonicRaw(&t);
    Py_END_ALLOW_THREADS
    if (res < 0) {
        assert(t == 0);
        PyErr_SetString(PyExc_RuntimeError, "PyTime_MonotonicRaw() failed");
        return NULL;
    }
    assert(res == 0);
    return pytime_as_float(t);
}


static PyObject*
test_pytime_perf_counter(PyObject *Py_UNUSED(self), PyObject *Py_UNUSED(args))
{
    PyTime_t t;
    int res = PyTime_PerfCounter(&t);
    if (res < 0) {
        assert(t == 0);
        return NULL;
    }
    assert(res == 0);
    return pytime_as_float(t);
}


static PyObject*
test_pytime_perf_counter_raw(PyObject *Py_UNUSED(self), PyObject *Py_UNUSED(args))
{
    PyTime_t t;
    int res;
    Py_BEGIN_ALLOW_THREADS
    res = PyTime_PerfCounterRaw(&t);
    Py_END_ALLOW_THREADS
    if (res < 0) {
        assert(t == 0);
        PyErr_SetString(PyExc_RuntimeError, "PyTime_PerfCounterRaw() failed");
        return NULL;
    }
    assert(res == 0);
    return pytime_as_float(t);
}


static PyObject*
test_pytime_time(PyObject *Py_UNUSED(self), PyObject *Py_UNUSED(args))
{
    PyTime_t t;
    int res = PyTime_Time(&t);
    if (res < 0) {
        assert(t == 0);
        return NULL;
    }
    assert(res == 0);
    return pytime_as_float(t);
}


static PyObject*
test_pytime_time_raw(PyObject *Py_UNUSED(self), PyObject *Py_UNUSED(args))
{
    PyTime_t t;
    int res;
    Py_BEGIN_ALLOW_THREADS
    res = PyTime_TimeRaw(&t);
    Py_END_ALLOW_THREADS
    if (res < 0) {
        assert(t == 0);
        PyErr_SetString(PyExc_RuntimeError, "PyTime_TimeRaw() failed");
        return NULL;
    }
    assert(res == 0);
    return pytime_as_float(t);
}


static PyMethodDef test_methods[] = {
    {"PyTime_AsSecondsDouble", test_pytime_assecondsdouble, METH_VARARGS},
    {"PyTime_Monotonic", test_pytime_monotonic, METH_NOARGS},
    {"PyTime_MonotonicRaw", test_pytime_monotonic_raw, METH_NOARGS},
    {"PyTime_PerfCounter", test_pytime_perf_counter, METH_NOARGS},
    {"PyTime_PerfCounterRaw", test_pytime_perf_counter_raw, METH_NOARGS},
    {"PyTime_Time", test_pytime_time, METH_NOARGS},
    {"PyTime_TimeRaw", test_pytime_time_raw, METH_NOARGS},
    {NULL},
};

int
_PyTestCapi_Init_Time(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }
    Py_BUILD_ASSERT(sizeof(long long) == sizeof(PyTime_t));
    if (PyModule_AddObject(m, "PyTime_MIN", PyLong_FromLongLong(PyTime_MIN)) < 0) {
        return 1;
    }
    if (PyModule_AddObject(m, "PyTime_MAX", PyLong_FromLongLong(PyTime_MAX)) < 0) {
        return 1;
    }
    return 0;
}


================================================
File: /Modules/_testcapi/tuple.c
================================================
#include "parts.h"
#include "util.h"


static PyObject *
tuple_get_size(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    RETURN_SIZE(PyTuple_GET_SIZE(obj));
}

static PyObject *
tuple_get_item(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t i;
    if (!PyArg_ParseTuple(args, "On", &obj, &i)) {
        return NULL;
    }
    NULLABLE(obj);
    return Py_XNewRef(PyTuple_GET_ITEM(obj, i));
}

static PyObject *
tuple_copy(PyObject *tuple)
{
    Py_ssize_t size = PyTuple_GET_SIZE(tuple);
    PyObject *newtuple = PyTuple_New(size);
    if (!newtuple) {
        return NULL;
    }
    for (Py_ssize_t n = 0; n < size; n++) {
        PyTuple_SET_ITEM(newtuple, n, Py_XNewRef(PyTuple_GET_ITEM(tuple, n)));
    }
    return newtuple;
}

static PyObject *
tuple_set_item(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj, *value, *newtuple;
    Py_ssize_t i;
    if (!PyArg_ParseTuple(args, "OnO", &obj, &i, &value)) {
        return NULL;
    }
    NULLABLE(value);
    if (PyTuple_CheckExact(obj)) {
        newtuple = tuple_copy(obj);
        if (!newtuple) {
            return NULL;
        }

        PyObject *val = PyTuple_GET_ITEM(newtuple, i);
        PyTuple_SET_ITEM(newtuple, i, Py_XNewRef(value));
        Py_DECREF(val);
        return newtuple;
    }
    else {
        NULLABLE(obj);

        PyObject *val = PyTuple_GET_ITEM(obj, i);
        PyTuple_SET_ITEM(obj, i, Py_XNewRef(value));
        Py_DECREF(val);
        return Py_XNewRef(obj);
    }
}

static PyObject *
_tuple_resize(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *tup;
    Py_ssize_t newsize;
    int new = 1;
    if (!PyArg_ParseTuple(args, "On|p", &tup, &newsize, &new)) {
        return NULL;
    }
    if (new) {
        tup = tuple_copy(tup);
        if (!tup) {
            return NULL;
        }
    }
    else {
        NULLABLE(tup);
        Py_XINCREF(tup);
    }
    int r = _PyTuple_Resize(&tup, newsize);
    if (r == -1) {
        assert(tup == NULL);
        return NULL;
    }
    return tup;
}

static PyObject *
_check_tuple_item_is_NULL(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t i;
    if (!PyArg_ParseTuple(args, "On", &obj, &i)) {
        return NULL;
    }
    return PyLong_FromLong(PyTuple_GET_ITEM(obj, i) == NULL);
}


static PyMethodDef test_methods[] = {
    {"tuple_get_size", tuple_get_size, METH_O},
    {"tuple_get_item", tuple_get_item, METH_VARARGS},
    {"tuple_set_item", tuple_set_item, METH_VARARGS},
    {"_tuple_resize", _tuple_resize, METH_VARARGS},
    {"_check_tuple_item_is_NULL", _check_tuple_item_is_NULL, METH_VARARGS},
    {NULL},
};

int
_PyTestCapi_Init_Tuple(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/unicode.c
================================================
#include <stddef.h>               // ptrdiff_t

#include "parts.h"
#include "util.h"

/* Test PyUnicode_New() */
static PyObject *
unicode_new(PyObject *self, PyObject *args)
{
    Py_ssize_t size;
    unsigned int maxchar;
    PyObject *result;

    if (!PyArg_ParseTuple(args, "nI", &size, &maxchar)) {
        return NULL;
    }

    result = PyUnicode_New(size, (Py_UCS4)maxchar);
    if (!result) {
        return NULL;
    }
    if (size > 0 && maxchar <= 0x10ffff &&
        PyUnicode_Fill(result, 0, size, (Py_UCS4)maxchar) < 0)
    {
        Py_DECREF(result);
        return NULL;
    }
    return result;
}


static PyObject *
unicode_copy(PyObject *unicode)
{
    PyObject *copy;

    if (!unicode) {
        return NULL;
    }
    if (!PyUnicode_Check(unicode)) {
        Py_INCREF(unicode);
        return unicode;
    }

    copy = PyUnicode_New(PyUnicode_GET_LENGTH(unicode),
                         PyUnicode_MAX_CHAR_VALUE(unicode));
    if (!copy) {
        return NULL;
    }
    if (PyUnicode_CopyCharacters(copy, 0, unicode,
                                 0, PyUnicode_GET_LENGTH(unicode)) < 0)
    {
        Py_DECREF(copy);
        return NULL;
    }
    return copy;
}


/* Test PyUnicode_Fill() */
static PyObject *
unicode_fill(PyObject *self, PyObject *args)
{
    PyObject *to, *to_copy;
    Py_ssize_t start, length, filled;
    unsigned int fill_char;

    if (!PyArg_ParseTuple(args, "OnnI", &to, &start, &length, &fill_char)) {
        return NULL;
    }

    NULLABLE(to);
    if (!(to_copy = unicode_copy(to)) && to) {
        return NULL;
    }

    filled = PyUnicode_Fill(to_copy, start, length, (Py_UCS4)fill_char);
    if (filled == -1 && PyErr_Occurred()) {
        Py_DECREF(to_copy);
        return NULL;
    }
    return Py_BuildValue("(Nn)", to_copy, filled);
}


/* Test PyUnicode_FromKindAndData() */
static PyObject *
unicode_fromkindanddata(PyObject *self, PyObject *args)
{
    int kind;
    void *buffer;
    Py_ssize_t bsize;
    Py_ssize_t size = -100;

    if (!PyArg_ParseTuple(args, "iz#|n", &kind, &buffer, &bsize, &size)) {
        return NULL;
    }

    if (size == -100) {
        size = bsize;
    }
    if (kind && size % kind) {
        PyErr_SetString(PyExc_AssertionError,
                        "invalid size in unicode_fromkindanddata()");
        return NULL;
    }
    return PyUnicode_FromKindAndData(kind, buffer, kind ? size / kind : 0);
}


// Test PyUnicode_AsUCS4().
// Part of the limited C API, but the test needs PyUnicode_FromKindAndData().
static PyObject *
unicode_asucs4(PyObject *self, PyObject *args)
{
    PyObject *unicode, *result;
    Py_UCS4 *buffer;
    int copy_null;
    Py_ssize_t str_len, buf_len;

    if (!PyArg_ParseTuple(args, "Onp:unicode_asucs4", &unicode, &str_len, &copy_null)) {
        return NULL;
    }

    NULLABLE(unicode);
    buf_len = str_len + 1;
    buffer = PyMem_NEW(Py_UCS4, buf_len);
    if (buffer == NULL) {
        return PyErr_NoMemory();
    }
    memset(buffer, 0, sizeof(Py_UCS4)*buf_len);
    buffer[str_len] = 0xffffU;

    if (!PyUnicode_AsUCS4(unicode, buffer, buf_len, copy_null)) {
        PyMem_Free(buffer);
        return NULL;
    }

    result = PyUnicode_FromKindAndData(PyUnicode_4BYTE_KIND, buffer, buf_len);
    PyMem_Free(buffer);
    return result;
}


// Test PyUnicode_AsUCS4Copy().
// Part of the limited C API, but the test needs PyUnicode_FromKindAndData().
static PyObject *
unicode_asucs4copy(PyObject *self, PyObject *args)
{
    PyObject *unicode;
    Py_UCS4 *buffer;
    PyObject *result;

    if (!PyArg_ParseTuple(args, "O", &unicode)) {
        return NULL;
    }

    NULLABLE(unicode);
    buffer = PyUnicode_AsUCS4Copy(unicode);
    if (buffer == NULL) {
        return NULL;
    }
    result = PyUnicode_FromKindAndData(PyUnicode_4BYTE_KIND,
                                       buffer,
                                       PyUnicode_GET_LENGTH(unicode) + 1);
    PyMem_FREE(buffer);
    return result;
}


/* Test PyUnicode_AsUTF8() */
static PyObject *
unicode_asutf8(PyObject *self, PyObject *args)
{
    PyObject *unicode;
    Py_ssize_t buflen;
    const char *s;

    if (!PyArg_ParseTuple(args, "On", &unicode, &buflen))
        return NULL;

    NULLABLE(unicode);
    s = PyUnicode_AsUTF8(unicode);
    if (s == NULL)
        return NULL;

    return PyBytes_FromStringAndSize(s, buflen);
}


/* Test PyUnicode_CopyCharacters() */
static PyObject *
unicode_copycharacters(PyObject *self, PyObject *args)
{
    PyObject *from, *to, *to_copy;
    Py_ssize_t from_start, to_start, how_many, copied;

    if (!PyArg_ParseTuple(args, "UnOnn", &to, &to_start,
                          &from, &from_start, &how_many)) {
        return NULL;
    }

    NULLABLE(from);
    if (!(to_copy = PyUnicode_New(PyUnicode_GET_LENGTH(to),
                                  PyUnicode_MAX_CHAR_VALUE(to)))) {
        return NULL;
    }
    if (PyUnicode_Fill(to_copy, 0, PyUnicode_GET_LENGTH(to_copy), 0U) < 0) {
        Py_DECREF(to_copy);
        return NULL;
    }

    copied = PyUnicode_CopyCharacters(to_copy, to_start, from,
                                      from_start, how_many);
    if (copied == -1 && PyErr_Occurred()) {
        Py_DECREF(to_copy);
        return NULL;
    }

    return Py_BuildValue("(Nn)", to_copy, copied);
}


// --- PyUnicodeWriter type -------------------------------------------------

typedef struct {
    PyObject_HEAD
    PyUnicodeWriter *writer;
} WriterObject;


static PyObject *
writer_new(PyTypeObject *type, PyObject *args, PyObject *kwargs)
{
    WriterObject *self = (WriterObject *)type->tp_alloc(type, 0);
    if (!self) {
        return NULL;
    }
    self->writer = NULL;
    return (PyObject*)self;
}


static int
writer_init(PyObject *self_raw, PyObject *args, PyObject *kwargs)
{
    WriterObject *self = (WriterObject *)self_raw;

    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "n", &size)) {
        return -1;
    }

    if (self->writer) {
        PyUnicodeWriter_Discard(self->writer);
    }

    self->writer = PyUnicodeWriter_Create(size);
    if (self->writer == NULL) {
        return -1;
    }
    return 0;
}


static void
writer_dealloc(PyObject *self_raw)
{
    WriterObject *self = (WriterObject *)self_raw;
    PyTypeObject *tp = Py_TYPE(self);
    if (self->writer) {
        PyUnicodeWriter_Discard(self->writer);
    }
    tp->tp_free(self);
    Py_DECREF(tp);
}


static inline int
writer_check(WriterObject *self)
{
    if (self->writer == NULL) {
        PyErr_SetString(PyExc_ValueError, "operation on finished writer");
        return -1;
    }
    return 0;
}


static PyObject*
writer_write_char(PyObject *self_raw, PyObject *args)
{
    WriterObject *self = (WriterObject *)self_raw;
    if (writer_check(self) < 0) {
        return NULL;
    }

    PyObject *str;
    if (!PyArg_ParseTuple(args, "U", &str)) {
        return NULL;
    }
    if (PyUnicode_GET_LENGTH(str) != 1) {
        PyErr_SetString(PyExc_ValueError, "expect a single character");
    }
    Py_UCS4 ch = PyUnicode_READ_CHAR(str, 0);

    if (PyUnicodeWriter_WriteChar(self->writer, ch) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}


