result is subnormal and inexact.\n\
\n\
If the exponent of the second operand is larger than that of the first, then\n\
rounding may be necessary. In this case, the rounding mode is determined by the\n\
rounding argument if given, else by the given context argument; if neither\n\
argument is given, the rounding mode of the current thread's context is used.\n\
\n");

PyDoc_STRVAR(doc_radix,
"radix($self, /)\n--\n\n\
Return Decimal(10), the radix (base) in which the Decimal class does\n\
all its arithmetic. Included for compatibility with the specification.\n\
\n");

PyDoc_STRVAR(doc_remainder_near,
"remainder_near($self, /, other, context=None)\n--\n\n\
Return the remainder from dividing self by other.  This differs from\n\
self % other in that the sign of the remainder is chosen so as to minimize\n\
its absolute value. More precisely, the return value is self - n * other\n\
where n is the integer nearest to the exact value of self / other, and\n\
if two integers are equally near then the even one is chosen.\n\
\n\
If the result is zero then its sign will be the sign of self.\n\
\n");

PyDoc_STRVAR(doc_rotate,
"rotate($self, /, other, context=None)\n--\n\n\
Return the result of rotating the digits of the first operand by an amount\n\
specified by the second operand.  The second operand must be an integer in\n\
the range -precision through precision. The absolute value of the second\n\
operand gives the number of places to rotate. If the second operand is\n\
positive then rotation is to the left; otherwise rotation is to the right.\n\
The coefficient of the first operand is padded on the left with zeros to\n\
length precision if necessary. The sign and exponent of the first operand are\n\
unchanged.\n\
\n");

PyDoc_STRVAR(doc_same_quantum,
"same_quantum($self, /, other, context=None)\n--\n\n\
Test whether self and other have the same exponent or whether both are NaN.\n\
\n\
This operation is unaffected by context and is quiet: no flags are changed\n\
and no rounding is performed. As an exception, the C version may raise\n\
InvalidOperation if the second operand cannot be converted exactly.\n\
\n");

PyDoc_STRVAR(doc_scaleb,
"scaleb($self, /, other, context=None)\n--\n\n\
Return the first operand with the exponent adjusted the second.  Equivalently,\n\
return the first operand multiplied by 10**other. The second operand must be\n\
an integer.\n\
\n");

PyDoc_STRVAR(doc_shift,
"shift($self, /, other, context=None)\n--\n\n\
Return the result of shifting the digits of the first operand by an amount\n\
specified by the second operand.  The second operand must be an integer in\n\
the range -precision through precision. The absolute value of the second\n\
operand gives the number of places to shift. If the second operand is\n\
positive, then the shift is to the left; otherwise the shift is to the\n\
right. Digits shifted into the coefficient are zeros. The sign and exponent\n\
of the first operand are unchanged.\n\
\n");

PyDoc_STRVAR(doc_sqrt,
"sqrt($self, /, context=None)\n--\n\n\
Return the square root of the argument to full precision. The result is\n\
correctly rounded using the ROUND_HALF_EVEN rounding mode.\n\
\n");

PyDoc_STRVAR(doc_to_eng_string,
"to_eng_string($self, /, context=None)\n--\n\n\
Convert to an engineering-type string.  Engineering notation has an exponent\n\
which is a multiple of 3, so there are up to 3 digits left of the decimal\n\
place. For example, Decimal('123E+1') is converted to Decimal('1.23E+3').\n\
\n\
The value of context.capitals determines whether the exponent sign is lower\n\
or upper case. Otherwise, the context does not affect the operation.\n\
\n");

PyDoc_STRVAR(doc_to_integral,
"to_integral($self, /, rounding=None, context=None)\n--\n\n\
Identical to the to_integral_value() method.  The to_integral() name has been\n\
kept for compatibility with older versions.\n\
\n");

PyDoc_STRVAR(doc_to_integral_exact,
"to_integral_exact($self, /, rounding=None, context=None)\n--\n\n\
Round to the nearest integer, signaling Inexact or Rounded as appropriate if\n\
rounding occurs.  The rounding mode is determined by the rounding parameter\n\
if given, else by the given context. If neither parameter is given, then the\n\
rounding mode of the current default context is used.\n\
\n");

PyDoc_STRVAR(doc_to_integral_value,
"to_integral_value($self, /, rounding=None, context=None)\n--\n\n\
Round to the nearest integer without signaling Inexact or Rounded.  The\n\
rounding mode is determined by the rounding parameter if given, else by\n\
the given context. If neither parameter is given, then the rounding mode\n\
of the current default context is used.\n\
\n");


/******************************************************************************/
/*                       Context Object and Methods                           */
/******************************************************************************/

PyDoc_STRVAR(doc_context,
"Context(prec=None, rounding=None, Emin=None, Emax=None, capitals=None, clamp=None, flags=None, traps=None)\n--\n\n\
The context affects almost all operations and controls rounding,\n\
Over/Underflow, raising of exceptions and much more.  A new context\n\
can be constructed as follows:\n\
\n\
    >>> c = Context(prec=28, Emin=-425000000, Emax=425000000,\n\
    ...             rounding=ROUND_HALF_EVEN, capitals=1, clamp=1,\n\
    ...             traps=[InvalidOperation, DivisionByZero, Overflow],\n\
    ...             flags=[])\n\
    >>>\n\
\n\
\n");

#ifdef EXTRA_FUNCTIONALITY
PyDoc_STRVAR(doc_ctx_apply,
"apply($self, x, /)\n--\n\n\
Apply self to Decimal x.\n\
\n");
#endif

PyDoc_STRVAR(doc_ctx_clear_flags,
"clear_flags($self, /)\n--\n\n\
Reset all flags to False.\n\
\n");

PyDoc_STRVAR(doc_ctx_clear_traps,
"clear_traps($self, /)\n--\n\n\
Set all traps to False.\n\
\n");

PyDoc_STRVAR(doc_ctx_copy,
"copy($self, /)\n--\n\n\
Return a duplicate of the context with all flags cleared.\n\
\n");

PyDoc_STRVAR(doc_ctx_copy_decimal,
"copy_decimal($self, x, /)\n--\n\n\
Return a copy of Decimal x.\n\
\n");

PyDoc_STRVAR(doc_ctx_create_decimal,
"create_decimal($self, num=\"0\", /)\n--\n\n\
Create a new Decimal instance from num, using self as the context. Unlike the\n\
Decimal constructor, this function observes the context limits.\n\
\n");

PyDoc_STRVAR(doc_ctx_create_decimal_from_float,
"create_decimal_from_float($self, f, /)\n--\n\n\
Create a new Decimal instance from float f.  Unlike the Decimal.from_float()\n\
class method, this function observes the context limits.\n\
\n");

PyDoc_STRVAR(doc_ctx_Etiny,
"Etiny($self, /)\n--\n\n\
Return a value equal to Emin - prec + 1, which is the minimum exponent value\n\
for subnormal results.  When underflow occurs, the exponent is set to Etiny.\n\
\n");

PyDoc_STRVAR(doc_ctx_Etop,
"Etop($self, /)\n--\n\n\
Return a value equal to Emax - prec + 1.  This is the maximum exponent\n\
if the _clamp field of the context is set to 1 (IEEE clamp mode).  Etop()\n\
must not be negative.\n\
\n");

PyDoc_STRVAR(doc_ctx_abs,
"abs($self, x, /)\n--\n\n\
Return the absolute value of x.\n\
\n");

PyDoc_STRVAR(doc_ctx_add,
"add($self, x, y, /)\n--\n\n\
Return the sum of x and y.\n\
\n");

PyDoc_STRVAR(doc_ctx_canonical,
"canonical($self, x, /)\n--\n\n\
Return a new instance of x.\n\
\n");

PyDoc_STRVAR(doc_ctx_compare,
"compare($self, x, y, /)\n--\n\n\
Compare x and y numerically.\n\
\n");

PyDoc_STRVAR(doc_ctx_compare_signal,
"compare_signal($self, x, y, /)\n--\n\n\
Compare x and y numerically.  All NaNs signal.\n\
\n");

PyDoc_STRVAR(doc_ctx_compare_total,
"compare_total($self, x, y, /)\n--\n\n\
Compare x and y using their abstract representation.\n\
\n");

PyDoc_STRVAR(doc_ctx_compare_total_mag,
"compare_total_mag($self, x, y, /)\n--\n\n\
Compare x and y using their abstract representation, ignoring sign.\n\
\n");

PyDoc_STRVAR(doc_ctx_copy_abs,
"copy_abs($self, x, /)\n--\n\n\
Return a copy of x with the sign set to 0.\n\
\n");

PyDoc_STRVAR(doc_ctx_copy_negate,
"copy_negate($self, x, /)\n--\n\n\
Return a copy of x with the sign inverted.\n\
\n");

PyDoc_STRVAR(doc_ctx_copy_sign,
"copy_sign($self, x, y, /)\n--\n\n\
Copy the sign from y to x.\n\
\n");

PyDoc_STRVAR(doc_ctx_divide,
"divide($self, x, y, /)\n--\n\n\
Return x divided by y.\n\
\n");

PyDoc_STRVAR(doc_ctx_divide_int,
"divide_int($self, x, y, /)\n--\n\n\
Return x divided by y, truncated to an integer.\n\
\n");

PyDoc_STRVAR(doc_ctx_divmod,
"divmod($self, x, y, /)\n--\n\n\
Return quotient and remainder of the division x / y.\n\
\n");

PyDoc_STRVAR(doc_ctx_exp,
"exp($self, x, /)\n--\n\n\
Return e ** x.\n\
\n");

PyDoc_STRVAR(doc_ctx_fma,
"fma($self, x, y, z, /)\n--\n\n\
Return x multiplied by y, plus z.\n\
\n");

PyDoc_STRVAR(doc_ctx_is_canonical,
"is_canonical($self, x, /)\n--\n\n\
Return True if x is canonical, False otherwise.\n\
\n");

PyDoc_STRVAR(doc_ctx_is_finite,
"is_finite($self, x, /)\n--\n\n\
Return True if x is finite, False otherwise.\n\
\n");

PyDoc_STRVAR(doc_ctx_is_infinite,
"is_infinite($self, x, /)\n--\n\n\
Return True if x is infinite, False otherwise.\n\
\n");

PyDoc_STRVAR(doc_ctx_is_nan,
"is_nan($self, x, /)\n--\n\n\
Return True if x is a qNaN or sNaN, False otherwise.\n\
\n");

PyDoc_STRVAR(doc_ctx_is_normal,
"is_normal($self, x, /)\n--\n\n\
Return True if x is a normal number, False otherwise.\n\
\n");

PyDoc_STRVAR(doc_ctx_is_qnan,
"is_qnan($self, x, /)\n--\n\n\
Return True if x is a quiet NaN, False otherwise.\n\
\n");

PyDoc_STRVAR(doc_ctx_is_signed,
"is_signed($self, x, /)\n--\n\n\
Return True if x is negative, False otherwise.\n\
\n");

PyDoc_STRVAR(doc_ctx_is_snan,
"is_snan($self, x, /)\n--\n\n\
Return True if x is a signaling NaN, False otherwise.\n\
\n");

PyDoc_STRVAR(doc_ctx_is_subnormal,
"is_subnormal($self, x, /)\n--\n\n\
Return True if x is subnormal, False otherwise.\n\
\n");

PyDoc_STRVAR(doc_ctx_is_zero,
"is_zero($self, x, /)\n--\n\n\
Return True if x is a zero, False otherwise.\n\
\n");

PyDoc_STRVAR(doc_ctx_ln,
"ln($self, x, /)\n--\n\n\
Return the natural (base e) logarithm of x.\n\
\n");

PyDoc_STRVAR(doc_ctx_log10,
"log10($self, x, /)\n--\n\n\
Return the base 10 logarithm of x.\n\
\n");

PyDoc_STRVAR(doc_ctx_logb,
"logb($self, x, /)\n--\n\n\
Return the exponent of the magnitude of the operand's MSD.\n\
\n");

PyDoc_STRVAR(doc_ctx_logical_and,
"logical_and($self, x, y, /)\n--\n\n\
Digit-wise and of x and y.\n\
\n");

PyDoc_STRVAR(doc_ctx_logical_invert,
"logical_invert($self, x, /)\n--\n\n\
Invert all digits of x.\n\
\n");

PyDoc_STRVAR(doc_ctx_logical_or,
"logical_or($self, x, y, /)\n--\n\n\
Digit-wise or of x and y.\n\
\n");

PyDoc_STRVAR(doc_ctx_logical_xor,
"logical_xor($self, x, y, /)\n--\n\n\
Digit-wise xor of x and y.\n\
\n");

PyDoc_STRVAR(doc_ctx_max,
"max($self, x, y, /)\n--\n\n\
Compare the values numerically and return the maximum.\n\
\n");

PyDoc_STRVAR(doc_ctx_max_mag,
"max_mag($self, x, y, /)\n--\n\n\
Compare the values numerically with their sign ignored.\n\
\n");

PyDoc_STRVAR(doc_ctx_min,
"min($self, x, y, /)\n--\n\n\
Compare the values numerically and return the minimum.\n\
\n");

PyDoc_STRVAR(doc_ctx_min_mag,
"min_mag($self, x, y, /)\n--\n\n\
Compare the values numerically with their sign ignored.\n\
\n");

PyDoc_STRVAR(doc_ctx_minus,
"minus($self, x, /)\n--\n\n\
Minus corresponds to the unary prefix minus operator in Python, but applies\n\
the context to the result.\n\
\n");

PyDoc_STRVAR(doc_ctx_multiply,
"multiply($self, x, y, /)\n--\n\n\
Return the product of x and y.\n\
\n");

PyDoc_STRVAR(doc_ctx_next_minus,
"next_minus($self, x, /)\n--\n\n\
Return the largest representable number smaller than x.\n\
\n");

PyDoc_STRVAR(doc_ctx_next_plus,
"next_plus($self, x, /)\n--\n\n\
Return the smallest representable number larger than x.\n\
\n");

PyDoc_STRVAR(doc_ctx_next_toward,
"next_toward($self, x, y, /)\n--\n\n\
Return the number closest to x, in the direction towards y.\n\
\n");

PyDoc_STRVAR(doc_ctx_normalize,
"normalize($self, x, /)\n--\n\n\
Reduce x to its simplest form. Alias for reduce(x).\n\
\n");

PyDoc_STRVAR(doc_ctx_number_class,
"number_class($self, x, /)\n--\n\n\
Return an indication of the class of x.\n\
\n");

PyDoc_STRVAR(doc_ctx_plus,
"plus($self, x, /)\n--\n\n\
Plus corresponds to the unary prefix plus operator in Python, but applies\n\
the context to the result.\n\
\n");

PyDoc_STRVAR(doc_ctx_power,
"power($self, /, a, b, modulo=None)\n--\n\n\
Compute a**b. If 'a' is negative, then 'b' must be integral. The result\n\
will be inexact unless 'a' is integral and the result is finite and can\n\
be expressed exactly in 'precision' digits.  In the Python version the\n\
result is always correctly rounded, in the C version the result is almost\n\
always correctly rounded.\n\
\n\
If modulo is given, compute (a**b) % modulo. The following restrictions\n\
hold:\n\
\n\
    * all three arguments must be integral\n\
    * 'b' must be nonnegative\n\
    * at least one of 'a' or 'b' must be nonzero\n\
    * modulo must be nonzero and less than 10**prec in absolute value\n\
\n\
\n");

PyDoc_STRVAR(doc_ctx_quantize,
"quantize($self, x, y, /)\n--\n\n\
Return a value equal to x (rounded), having the exponent of y.\n\
\n");

PyDoc_STRVAR(doc_ctx_radix,
"radix($self, /)\n--\n\n\
Return 10.\n\
\n");

PyDoc_STRVAR(doc_ctx_remainder,
"remainder($self, x, y, /)\n--\n\n\
Return the remainder from integer division.  The sign of the result,\n\
if non-zero, is the same as that of the original dividend.\n\
\n");

PyDoc_STRVAR(doc_ctx_remainder_near,
"remainder_near($self, x, y, /)\n--\n\n\
Return x - y * n, where n is the integer nearest the exact value of x / y\n\
(if the result is 0 then its sign will be the sign of x).\n\
\n");

PyDoc_STRVAR(doc_ctx_rotate,
"rotate($self, x, y, /)\n--\n\n\
Return a copy of x, rotated by y places.\n\
\n");

PyDoc_STRVAR(doc_ctx_same_quantum,
"same_quantum($self, x, y, /)\n--\n\n\
Return True if the two operands have the same exponent.\n\
\n");

PyDoc_STRVAR(doc_ctx_scaleb,
"scaleb($self, x, y, /)\n--\n\n\
Return the first operand after adding the second value to its exp.\n\
\n");

PyDoc_STRVAR(doc_ctx_shift,
"shift($self, x, y, /)\n--\n\n\
Return a copy of x, shifted by y places.\n\
\n");

PyDoc_STRVAR(doc_ctx_sqrt,
"sqrt($self, x, /)\n--\n\n\
Square root of a non-negative number to context precision.\n\
\n");

PyDoc_STRVAR(doc_ctx_subtract,
"subtract($self, x, y, /)\n--\n\n\
Return the difference between x and y.\n\
\n");

PyDoc_STRVAR(doc_ctx_to_eng_string,
"to_eng_string($self, x, /)\n--\n\n\
Convert a number to a string, using engineering notation.\n\
\n");

PyDoc_STRVAR(doc_ctx_to_integral,
"to_integral($self, x, /)\n--\n\n\
Identical to to_integral_value(x).\n\
\n");

PyDoc_STRVAR(doc_ctx_to_integral_exact,
"to_integral_exact($self, x, /)\n--\n\n\
Round to an integer. Signal if the result is rounded or inexact.\n\
\n");

PyDoc_STRVAR(doc_ctx_to_integral_value,
"to_integral_value($self, x, /)\n--\n\n\
Round to an integer.\n\
\n");

PyDoc_STRVAR(doc_ctx_to_sci_string,
"to_sci_string($self, x, /)\n--\n\n\
Convert a number to a string using scientific notation.\n\
\n");


#endif /* DOCSTRINGS_H */





================================================
File: /Modules/_decimal/libmpdec/README.txt
================================================


libmpdec
========

libmpdec is a fast C/C++ library for correctly-rounded arbitrary precision
decimal floating point arithmetic. It is a complete implementation of
Mike Cowlishaw/IBM's General Decimal Arithmetic Specification.


Files required for the Python _decimal module
=============================================

  Core files for small and medium precision arithmetic
  ----------------------------------------------------

    basearith.{c,h}  ->  Core arithmetic in base 10**9 or 10**19.
    bits.h           ->  Portable detection of least/most significant one-bit.
    constants.{c,h}  ->  Constants that are used in multiple files.
    context.c        ->  Context functions.
    io.{c,h}         ->  Conversions between mpd_t and ASCII strings,
                         mpd_t formatting (allows UTF-8 fill character).
    mpalloc.{c,h}    ->  Allocation handlers with overflow detection
                         and functions for switching between static
                         and dynamic mpd_t.
    mpdecimal.{c,h}  ->  All (quiet) functions of the specification.
    typearith.h      ->  Fast primitives for double word multiplication,
                         division etc.

    Visual Studio only:
    ~~~~~~~~~~~~~~~~~~~
      vcdiv64.asm   ->  Double word division used in typearith.h. VS 2008 does
                        not allow inline asm for x64. Also, it does not provide
                        an intrinsic for double word division.

  Files for bignum arithmetic:
  ----------------------------

    The following files implement the Fast Number Theoretic Transform
    used for multiplying coefficients with more than 1024 words (see
    mpdecimal.c: _mpd_fntmul()).

      umodarith.h        ->  Fast low level routines for unsigned modular arithmetic.
      numbertheory.{c,h} ->  Routines for setting up the Number Theoretic Transform.
      difradix2.{c,h}    ->  Decimation in frequency transform, used as the
                             "base case" by the following three files:

        fnt.{c,h}        ->  Transform arrays up to 4096 words.
        sixstep.{c,h}    ->  Transform larger arrays of length 2**n.
        fourstep.{c,h}   ->  Transform larger arrays of length 3 * 2**n.

      convolute.{c,h}    ->  Fast convolution using one of the three transform
                             functions.
      transpose.{c,h}    ->  Transpositions needed for the sixstep algorithm.
      crt.{c,h}          ->  Chinese Remainder Theorem: use information from three
                             transforms modulo three different primes to get the
                             final result.


Pointers to literature, proofs and more
=======================================

  literature/
  -----------

    REFERENCES.txt  ->  List of relevant papers.
    bignum.txt      ->  Explanation of the Fast Number Theoretic Transform (FNT).
    fnt.py          ->  Verify constants used in the FNT; Python demo for the
                        O(N**2) discrete transform.

    matrix-transform.txt -> Proof for the Matrix Fourier Transform used in
                            fourstep.c.
    six-step.txt         -> Show that the algorithm used in sixstep.c is
                            a variant of the Matrix Fourier Transform.
    mulmod-64.txt        -> Proof for the mulmod64 algorithm from
                            umodarith.h.
    mulmod-ppro.txt      -> Proof for the x87 FPU modular multiplication
                            from umodarith.h.
    umodarith.lisp       -> ACL2 proofs for many functions from umodarith.h.


Library Author
==============

  Stefan Krah <skrah@bytereef.org>





================================================
File: /Modules/_decimal/libmpdec/basearith.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"

#include <assert.h>
#include <stdio.h>

#include "basearith.h"
#include "constants.h"
#include "typearith.h"


/*********************************************************************/
/*                   Calculations in base MPD_RADIX                  */
/*********************************************************************/


/*
 * Knuth, TAOCP, Volume 2, 4.3.1:
 *    w := sum of u (len m) and v (len n)
 *    n > 0 and m >= n
 * The calling function has to handle a possible final carry.
 */
mpd_uint_t
_mpd_baseadd(mpd_uint_t *w, const mpd_uint_t *u, const mpd_uint_t *v,
             mpd_size_t m, mpd_size_t n)
{
    mpd_uint_t s;
    mpd_uint_t carry = 0;
    mpd_size_t i;

    assert(n > 0 && m >= n);

    /* add n members of u and v */
    for (i = 0; i < n; i++) {
        s = u[i] + (v[i] + carry);
        carry = (s < u[i]) | (s >= MPD_RADIX);
        w[i] = carry ? s-MPD_RADIX : s;
    }
    /* if there is a carry, propagate it */
    for (; carry && i < m; i++) {
        s = u[i] + carry;
        carry = (s == MPD_RADIX);
        w[i] = carry ? 0 : s;
    }
    /* copy the rest of u */
    for (; i < m; i++) {
        w[i] = u[i];
    }

    return carry;
}

/*
 * Add the contents of u to w. Carries are propagated further. The caller
 * has to make sure that w is big enough.
 */
void
_mpd_baseaddto(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n)
{
    mpd_uint_t s;
    mpd_uint_t carry = 0;
    mpd_size_t i;

    if (n == 0) return;

    /* add n members of u to w */
    for (i = 0; i < n; i++) {
        s = w[i] + (u[i] + carry);
        carry = (s < w[i]) | (s >= MPD_RADIX);
        w[i] = carry ? s-MPD_RADIX : s;
    }
    /* if there is a carry, propagate it */
    for (; carry; i++) {
        s = w[i] + carry;
        carry = (s == MPD_RADIX);
        w[i] = carry ? 0 : s;
    }
}

/*
 * Add v to w (len m). The calling function has to handle a possible
 * final carry. Assumption: m > 0.
 */
mpd_uint_t
_mpd_shortadd(mpd_uint_t *w, mpd_size_t m, mpd_uint_t v)
{
    mpd_uint_t s;
    mpd_uint_t carry;
    mpd_size_t i;

    assert(m > 0);

    /* add v to w */
    s = w[0] + v;
    carry = (s < v) | (s >= MPD_RADIX);
    w[0] = carry ? s-MPD_RADIX : s;

    /* if there is a carry, propagate it */
    for (i = 1; carry && i < m; i++) {
        s = w[i] + carry;
        carry = (s == MPD_RADIX);
        w[i] = carry ? 0 : s;
    }

    return carry;
}

/* Increment u. The calling function has to handle a possible carry. */
mpd_uint_t
_mpd_baseincr(mpd_uint_t *u, mpd_size_t n)
{
    mpd_uint_t s;
    mpd_uint_t carry = 1;
    mpd_size_t i;

    assert(n > 0);

    /* if there is a carry, propagate it */
    for (i = 0; carry && i < n; i++) {
        s = u[i] + carry;
        carry = (s == MPD_RADIX);
        u[i] = carry ? 0 : s;
    }

    return carry;
}

/*
 * Knuth, TAOCP, Volume 2, 4.3.1:
 *     w := difference of u (len m) and v (len n).
 *     number in u >= number in v;
 */
void
_mpd_basesub(mpd_uint_t *w, const mpd_uint_t *u, const mpd_uint_t *v,
             mpd_size_t m, mpd_size_t n)
{
    mpd_uint_t d;
    mpd_uint_t borrow = 0;
    mpd_size_t i;

    assert(m > 0 && n > 0);

    /* subtract n members of v from u */
    for (i = 0; i < n; i++) {
        d = u[i] - (v[i] + borrow);
        borrow = (u[i] < d);
        w[i] = borrow ? d + MPD_RADIX : d;
    }
    /* if there is a borrow, propagate it */
    for (; borrow && i < m; i++) {
        d = u[i] - borrow;
        borrow = (u[i] == 0);
        w[i] = borrow ? MPD_RADIX-1 : d;
    }
    /* copy the rest of u */
    for (; i < m; i++) {
        w[i] = u[i];
    }
}

/*
 * Subtract the contents of u from w. w is larger than u. Borrows are
 * propagated further, but eventually w can absorb the final borrow.
 */
void
_mpd_basesubfrom(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n)
{
    mpd_uint_t d;
    mpd_uint_t borrow = 0;
    mpd_size_t i;

    if (n == 0) return;

    /* subtract n members of u from w */
    for (i = 0; i < n; i++) {
        d = w[i] - (u[i] + borrow);
        borrow = (w[i] < d);
        w[i] = borrow ? d + MPD_RADIX : d;
    }
    /* if there is a borrow, propagate it */
    for (; borrow; i++) {
        d = w[i] - borrow;
        borrow = (w[i] == 0);
        w[i] = borrow ? MPD_RADIX-1 : d;
    }
}

/* w := product of u (len n) and v (single word) */
void
_mpd_shortmul(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n, mpd_uint_t v)
{
    mpd_uint_t hi, lo;
    mpd_uint_t carry = 0;
    mpd_size_t i;

    assert(n > 0);

    for (i=0; i < n; i++) {

        _mpd_mul_words(&hi, &lo, u[i], v);
        lo = carry + lo;
        if (lo < carry) hi++;

        _mpd_div_words_r(&carry, &w[i], hi, lo);
    }
    w[i] = carry;
}

/*
 * Knuth, TAOCP, Volume 2, 4.3.1:
 *     w := product of u (len m) and v (len n)
 *     w must be initialized to zero
 */
void
_mpd_basemul(mpd_uint_t *w, const mpd_uint_t *u, const mpd_uint_t *v,
             mpd_size_t m, mpd_size_t n)
{
    mpd_uint_t hi, lo;
    mpd_uint_t carry;
    mpd_size_t i, j;

    assert(m > 0 && n > 0);

    for (j=0; j < n; j++) {
        carry = 0;
        for (i=0; i < m; i++) {

            _mpd_mul_words(&hi, &lo, u[i], v[j]);
            lo = w[i+j] + lo;
            if (lo < w[i+j]) hi++;
            lo = carry + lo;
            if (lo < carry) hi++;

            _mpd_div_words_r(&carry, &w[i+j], hi, lo);
        }
        w[j+m] = carry;
    }
}

/*
 * Knuth, TAOCP Volume 2, 4.3.1, exercise 16:
 *     w := quotient of u (len n) divided by a single word v
 */
mpd_uint_t
_mpd_shortdiv(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n, mpd_uint_t v)
{
    mpd_uint_t hi, lo;
    mpd_uint_t rem = 0;
    mpd_size_t i;

    assert(n > 0);

    for (i=n-1; i != MPD_SIZE_MAX; i--) {

        _mpd_mul_words(&hi, &lo, rem, MPD_RADIX);
        lo = u[i] + lo;
        if (lo < u[i]) hi++;

        _mpd_div_words(&w[i], &rem, hi, lo, v);
    }

    return rem;
}

/*
 * Knuth, TAOCP Volume 2, 4.3.1:
 *     q, r := quotient and remainder of uconst (len nplusm)
 *             divided by vconst (len n)
 *     nplusm >= n
 *
 * If r is not NULL, r will contain the remainder. If r is NULL, the
 * return value indicates if there is a remainder: 1 for true, 0 for
 * false.  A return value of -1 indicates an error.
 */
int
_mpd_basedivmod(mpd_uint_t *q, mpd_uint_t *r,
                const mpd_uint_t *uconst, const mpd_uint_t *vconst,
                mpd_size_t nplusm, mpd_size_t n)
{
    mpd_uint_t ustatic[MPD_MINALLOC_MAX];
    mpd_uint_t vstatic[MPD_MINALLOC_MAX];
    mpd_uint_t *u = ustatic;
    mpd_uint_t *v = vstatic;
    mpd_uint_t d, qhat, rhat, w2[2];
    mpd_uint_t hi, lo, x;
    mpd_uint_t carry;
    mpd_size_t i, j, m;
    int retval = 0;

    assert(n > 1 && nplusm >= n);
    m = sub_size_t(nplusm, n);

    /* D1: normalize */
    d = MPD_RADIX / (vconst[n-1] + 1);

    if (nplusm >= MPD_MINALLOC_MAX) {
        if ((u = mpd_alloc(nplusm+1, sizeof *u)) == NULL) {
            return -1;
        }
    }
    if (n >= MPD_MINALLOC_MAX) {
        if ((v = mpd_alloc(n+1, sizeof *v)) == NULL) {
            mpd_free(u);
            return -1;
        }
    }

    _mpd_shortmul(u, uconst, nplusm, d);
    _mpd_shortmul(v, vconst, n, d);

    /* D2: loop */
    for (j=m; j != MPD_SIZE_MAX; j--) {
        assert(2 <= j+n && j+n <= nplusm); /* annotation for scan-build */

        /* D3: calculate qhat and rhat */
        rhat = _mpd_shortdiv(w2, u+j+n-1, 2, v[n-1]);
        qhat = w2[1] * MPD_RADIX + w2[0];

        while (1) {
            if (qhat < MPD_RADIX) {
                _mpd_singlemul(w2, qhat, v[n-2]);
                if (w2[1] <= rhat) {
                    if (w2[1] != rhat || w2[0] <= u[j+n-2]) {
                        break;
                    }
                }
            }
            qhat -= 1;
            rhat += v[n-1];
            if (rhat < v[n-1] || rhat >= MPD_RADIX) {
                break;
            }
        }
        /* D4: multiply and subtract */
        carry = 0;
        for (i=0; i <= n; i++) {

            _mpd_mul_words(&hi, &lo, qhat, v[i]);

            lo = carry + lo;
            if (lo < carry) hi++;

            _mpd_div_words_r(&hi, &lo, hi, lo);

            x = u[i+j] - lo;
            carry = (u[i+j] < x);
            u[i+j] = carry ? x+MPD_RADIX : x;
            carry += hi;
        }
        q[j] = qhat;
        /* D5: test remainder */
        if (carry) {
            q[j] -= 1;
            /* D6: add back */
            (void)_mpd_baseadd(u+j, u+j, v, n+1, n);
        }
    }

    /* D8: unnormalize */
    if (r != NULL) {
        _mpd_shortdiv(r, u, n, d);
        /* we are not interested in the return value here */
        retval = 0;
    }
    else {
        retval = !_mpd_isallzero(u, n);
    }


if (u != ustatic) mpd_free(u);
if (v != vstatic) mpd_free(v);
return retval;
}

/*
 * Left shift of src by 'shift' digits; src may equal dest.
 *
 *  dest := area of n mpd_uint_t with space for srcdigits+shift digits.
 *  src  := coefficient with length m.
 *
 * The case splits in the function are non-obvious. The following
 * equations might help:
 *
 *  Let msdigits denote the number of digits in the most significant
 *  word of src. Then 1 <= msdigits <= rdigits.
 *
 *   1) shift = q * rdigits + r
 *   2) srcdigits = qsrc * rdigits + msdigits
 *   3) destdigits = shift + srcdigits
 *                 = q * rdigits + r + qsrc * rdigits + msdigits
 *                 = q * rdigits + (qsrc * rdigits + (r + msdigits))
 *
 *  The result has q zero words, followed by the coefficient that
 *  is left-shifted by r. The case r == 0 is trivial. For r > 0, it
 *  is important to keep in mind that we always read m source words,
 *  but write m+1 destination words if r + msdigits > rdigits, m words
 *  otherwise.
 */
void
_mpd_baseshiftl(mpd_uint_t *dest, mpd_uint_t *src, mpd_size_t n, mpd_size_t m,
                mpd_size_t shift)
{
#if defined(__GNUC__) && !defined(__INTEL_COMPILER) && !defined(__clang__)
    /* spurious uninitialized warnings */
    mpd_uint_t l=l, lprev=lprev, h=h;
#else
    mpd_uint_t l, lprev, h;
#endif
    mpd_uint_t q, r;
    mpd_uint_t ph;

    assert(m > 0 && n >= m);

    _mpd_div_word(&q, &r, (mpd_uint_t)shift, MPD_RDIGITS);

    if (r != 0) {

        ph = mpd_pow10[r];

        --m; --n;
        _mpd_divmod_pow10(&h, &lprev, src[m--], MPD_RDIGITS-r);
        if (h != 0) { /* r + msdigits > rdigits <==> h != 0 */
            dest[n--] = h;
        }
        /* write m-1 shifted words */
        for (; m != MPD_SIZE_MAX; m--,n--) {
            _mpd_divmod_pow10(&h, &l, src[m], MPD_RDIGITS-r);
            dest[n] = ph * lprev + h;
            lprev = l;
        }
        /* write least significant word */
        dest[q] = ph * lprev;
    }
    else {
        while (--m != MPD_SIZE_MAX) {
            dest[m+q] = src[m];
        }
    }

    mpd_uint_zero(dest, q);
}

/*
 * Right shift of src by 'shift' digits; src may equal dest.
 * Assumption: srcdigits-shift > 0.
 *
 *  dest := area with space for srcdigits-shift digits.
 *  src  := coefficient with length 'slen'.
 *
 * The case splits in the function rely on the following equations:
 *
 *  Let msdigits denote the number of digits in the most significant
 *  word of src. Then 1 <= msdigits <= rdigits.
 *
 *  1) shift = q * rdigits + r
 *  2) srcdigits = qsrc * rdigits + msdigits
 *  3) destdigits = srcdigits - shift
 *                = qsrc * rdigits + msdigits - (q * rdigits + r)
 *                = (qsrc - q) * rdigits + msdigits - r
 *
 * Since destdigits > 0 and 1 <= msdigits <= rdigits:
 *
 *  4) qsrc >= q
 *  5) qsrc == q  ==>  msdigits > r
 *
 * The result has slen-q words if msdigits > r, slen-q-1 words otherwise.
 */
mpd_uint_t
_mpd_baseshiftr(mpd_uint_t *dest, mpd_uint_t *src, mpd_size_t slen,
                mpd_size_t shift)
{
#if defined(__GNUC__) && !defined(__INTEL_COMPILER) && !defined(__clang__)
    /* spurious uninitialized warnings */
    mpd_uint_t l=l, h=h, hprev=hprev; /* low, high, previous high */
#else
    mpd_uint_t l, h, hprev; /* low, high, previous high */
#endif
    mpd_uint_t rnd, rest;   /* rounding digit, rest */
    mpd_uint_t q, r;
    mpd_size_t i, j;
    mpd_uint_t ph;

    assert(slen > 0);

    _mpd_div_word(&q, &r, (mpd_uint_t)shift, MPD_RDIGITS);

    rnd = rest = 0;
    if (r != 0) {

        ph = mpd_pow10[MPD_RDIGITS-r];

        _mpd_divmod_pow10(&hprev, &rest, src[q], r);
        _mpd_divmod_pow10(&rnd, &rest, rest, r-1);

        if (rest == 0 && q > 0) {
            rest = !_mpd_isallzero(src, q);
        }
        /* write slen-q-1 words */
        for (j=0,i=q+1; i<slen; i++,j++) {
            _mpd_divmod_pow10(&h, &l, src[i], r);
            dest[j] = ph * l + hprev;
            hprev = h;
        }
        /* write most significant word */
        if (hprev != 0) { /* always the case if slen==q-1 */
            dest[j] = hprev;
        }
    }
    else {
        if (q > 0) {
            _mpd_divmod_pow10(&rnd, &rest, src[q-1], MPD_RDIGITS-1);
            /* is there any non-zero digit below rnd? */
            if (rest == 0) rest = !_mpd_isallzero(src, q-1);
        }
        for (j = 0; j < slen-q; j++) {
            dest[j] = src[q+j];
        }
    }

    /* 0-4  ==> rnd+rest < 0.5   */
    /* 5    ==> rnd+rest == 0.5  */
    /* 6-9  ==> rnd+rest > 0.5   */
    return (rnd == 0 || rnd == 5) ? rnd + !!rest : rnd;
}


/*********************************************************************/
/*                      Calculations in base b                       */
/*********************************************************************/

/*
 * Add v to w (len m). The calling function has to handle a possible
 * final carry. Assumption: m > 0.
 */
mpd_uint_t
_mpd_shortadd_b(mpd_uint_t *w, mpd_size_t m, mpd_uint_t v, mpd_uint_t b)
{
    mpd_uint_t s;
    mpd_uint_t carry;
    mpd_size_t i;

    assert(m > 0);

    /* add v to w */
    s = w[0] + v;
    carry = (s < v) | (s >= b);
    w[0] = carry ? s-b : s;

    /* if there is a carry, propagate it */
    for (i = 1; carry && i < m; i++) {
        s = w[i] + carry;
        carry = (s == b);
        w[i] = carry ? 0 : s;
    }

    return carry;
}

/* w := product of u (len n) and v (single word). Return carry. */
mpd_uint_t
_mpd_shortmul_c(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n, mpd_uint_t v)
{
    mpd_uint_t hi, lo;
    mpd_uint_t carry = 0;
    mpd_size_t i;

    assert(n > 0);

    for (i=0; i < n; i++) {

        _mpd_mul_words(&hi, &lo, u[i], v);
        lo = carry + lo;
        if (lo < carry) hi++;

        _mpd_div_words_r(&carry, &w[i], hi, lo);
    }

    return carry;
}

/* w := product of u (len n) and v (single word) */
mpd_uint_t
_mpd_shortmul_b(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n,
                mpd_uint_t v, mpd_uint_t b)
{
    mpd_uint_t hi, lo;
    mpd_uint_t carry = 0;
    mpd_size_t i;

    assert(n > 0);

    for (i=0; i < n; i++) {

        _mpd_mul_words(&hi, &lo, u[i], v);
        lo = carry + lo;
        if (lo < carry) hi++;

        _mpd_div_words(&carry, &w[i], hi, lo, b);
    }

    return carry;
}

/*
 * Knuth, TAOCP Volume 2, 4.3.1, exercise 16:
 *     w := quotient of u (len n) divided by a single word v
 */
mpd_uint_t
_mpd_shortdiv_b(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n,
                mpd_uint_t v, mpd_uint_t b)
{
    mpd_uint_t hi, lo;
    mpd_uint_t rem = 0;
    mpd_size_t i;

    assert(n > 0);

    for (i=n-1; i != MPD_SIZE_MAX; i--) {

        _mpd_mul_words(&hi, &lo, rem, b);
        lo = u[i] + lo;
        if (lo < u[i]) hi++;

        _mpd_div_words(&w[i], &rem, hi, lo, v);
    }

    return rem;
}


================================================
File: /Modules/_decimal/libmpdec/basearith.h
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#ifndef LIBMPDEC_BASEARITH_H_
#define LIBMPDEC_BASEARITH_H_


#include "mpdecimal.h"
#include "typearith.h"


/* Internal header file: all symbols have local scope in the DSO */
MPD_PRAGMA(MPD_HIDE_SYMBOLS_START)


mpd_uint_t _mpd_baseadd(mpd_uint_t *w, const mpd_uint_t *u, const mpd_uint_t *v,
                        mpd_size_t m, mpd_size_t n);
void _mpd_baseaddto(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n);
mpd_uint_t _mpd_shortadd(mpd_uint_t *w, mpd_size_t m, mpd_uint_t v);
mpd_uint_t _mpd_shortadd_b(mpd_uint_t *w, mpd_size_t m, mpd_uint_t v,
                           mpd_uint_t b);
mpd_uint_t _mpd_baseincr(mpd_uint_t *u, mpd_size_t n);
void _mpd_basesub(mpd_uint_t *w, const mpd_uint_t *u, const mpd_uint_t *v,
                  mpd_size_t m, mpd_size_t n);
void _mpd_basesubfrom(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n);
void _mpd_basemul(mpd_uint_t *w, const mpd_uint_t *u, const mpd_uint_t *v,
                  mpd_size_t m, mpd_size_t n);
void _mpd_shortmul(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n,
                   mpd_uint_t v);
mpd_uint_t _mpd_shortmul_c(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n,
                           mpd_uint_t v);
mpd_uint_t _mpd_shortmul_b(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n,
                           mpd_uint_t v, mpd_uint_t b);
mpd_uint_t _mpd_shortdiv(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n,
                         mpd_uint_t v);
mpd_uint_t _mpd_shortdiv_b(mpd_uint_t *w, const mpd_uint_t *u, mpd_size_t n,
                           mpd_uint_t v, mpd_uint_t b);
int _mpd_basedivmod(mpd_uint_t *q, mpd_uint_t *r, const mpd_uint_t *uconst,
                    const mpd_uint_t *vconst, mpd_size_t nplusm, mpd_size_t n);
void _mpd_baseshiftl(mpd_uint_t *dest, mpd_uint_t *src, mpd_size_t n,
                     mpd_size_t m, mpd_size_t shift);
mpd_uint_t _mpd_baseshiftr(mpd_uint_t *dest, mpd_uint_t *src, mpd_size_t slen,
                           mpd_size_t shift);



#ifdef CONFIG_64
extern const mpd_uint_t mprime_rdx;

/*
 * Algorithm from: Division by Invariant Integers using Multiplication,
 * T. Granlund and P. L. Montgomery, Proceedings of the SIGPLAN '94
 * Conference on Programming Language Design and Implementation.
 *
 * http://gmplib.org/~tege/divcnst-pldi94.pdf
 *
 * Variables from the paper and their translations (See section 8):
 *
 *  N := 64
 *  d := MPD_RADIX
 *  l := 64
 *  m' := floor((2**(64+64) - 1)/MPD_RADIX) - 2**64
 *
 * Since N-l == 0:
 *
 *  dnorm := d
 *  n2 := hi
 *  n10 := lo
 *
 * ACL2 proof: mpd-div-words-r-correct
 */
static inline void
_mpd_div_words_r(mpd_uint_t *q, mpd_uint_t *r, mpd_uint_t hi, mpd_uint_t lo)
{
    mpd_uint_t n_adj, h, l, t;
    mpd_uint_t n1_neg;

    /* n1_neg = if lo >= 2**63 then MPD_UINT_MAX else 0 */
    n1_neg = (lo & (1ULL<<63)) ? MPD_UINT_MAX : 0;
    /* n_adj = if lo >= 2**63 then lo+MPD_RADIX else lo */
    n_adj = lo + (n1_neg & MPD_RADIX);

    /* (h, l) = if lo >= 2**63 then m'*(hi+1) else m'*hi */
    _mpd_mul_words(&h, &l, mprime_rdx, hi-n1_neg);
    l = l + n_adj;
    if (l < n_adj) h++;
    t = h + hi;
    /* At this point t == qest, with q == qest or q == qest+1:
     *   1) 0 <= 2**64*hi + lo - qest*MPD_RADIX < 2*MPD_RADIX
     */

    /* t = 2**64-1 - qest = 2**64 - (qest+1) */
    t = MPD_UINT_MAX - t;

    /* (h, l) = 2**64*MPD_RADIX - (qest+1)*MPD_RADIX */
    _mpd_mul_words(&h, &l, t, MPD_RADIX);
    l = l + lo;
    if (l < lo) h++;
    h += hi;
    h -= MPD_RADIX;
    /* (h, l) = 2**64*hi + lo - (qest+1)*MPD_RADIX (mod 2**128)
     * Case q == qest+1:
     *     a) h == 0, l == r
     *     b) q := h - t == qest+1
     *     c) r := l
     * Case q == qest:
     *     a) h == MPD_UINT_MAX, l == 2**64-(MPD_RADIX-r)
     *     b) q := h - t == qest
     *     c) r := l + MPD_RADIX = r
     */

    *q = (h - t);
    *r = l + (MPD_RADIX & h);
}
#else
static inline void
_mpd_div_words_r(mpd_uint_t *q, mpd_uint_t *r, mpd_uint_t hi, mpd_uint_t lo)
{
    _mpd_div_words(q, r, hi, lo, MPD_RADIX);
}
#endif


/* Multiply two single base MPD_RADIX words, store result in array w[2]. */
static inline void
_mpd_singlemul(mpd_uint_t w[2], mpd_uint_t u, mpd_uint_t v)
{
    mpd_uint_t hi, lo;

    _mpd_mul_words(&hi, &lo, u, v);
    _mpd_div_words_r(&w[1], &w[0], hi, lo);
}

/* Multiply u (len 2) and v (len m, 1 <= m <= 2). */
static inline void
_mpd_mul_2_le2(mpd_uint_t w[4], mpd_uint_t u[2], mpd_uint_t v[2], mpd_ssize_t m)
{
    mpd_uint_t hi, lo;

    _mpd_mul_words(&hi, &lo, u[0], v[0]);
    _mpd_div_words_r(&w[1], &w[0], hi, lo);

    _mpd_mul_words(&hi, &lo, u[1], v[0]);
    lo = w[1] + lo;
    if (lo < w[1]) hi++;
    _mpd_div_words_r(&w[2], &w[1], hi, lo);
    if (m == 1) return;

    _mpd_mul_words(&hi, &lo, u[0], v[1]);
    lo = w[1] + lo;
    if (lo < w[1]) hi++;
    _mpd_div_words_r(&w[3], &w[1], hi, lo);

    _mpd_mul_words(&hi, &lo, u[1], v[1]);
    lo = w[2] + lo;
    if (lo < w[2]) hi++;
    lo = w[3] + lo;
    if (lo < w[3]) hi++;
    _mpd_div_words_r(&w[3], &w[2], hi, lo);
}


/*
 * Test if all words from data[len-1] to data[0] are zero. If len is 0, nothing
 * is tested and the coefficient is regarded as "all zero".
 */
static inline int
_mpd_isallzero(const mpd_uint_t *data, mpd_ssize_t len)
{
    while (--len >= 0) {
        if (data[len] != 0) return 0;
    }
    return 1;
}

/*
 * Test if all full words from data[len-1] to data[0] are MPD_RADIX-1
 * (all nines). Return true if len == 0.
 */
static inline int
_mpd_isallnine(const mpd_uint_t *data, mpd_ssize_t len)
{
    while (--len >= 0) {
        if (data[len] != MPD_RADIX-1) return 0;
    }
    return 1;
}


MPD_PRAGMA(MPD_HIDE_SYMBOLS_END) /* restore previous scope rules */


#endif /* LIBMPDEC_BASEARITH_H_ */


================================================
File: /Modules/_decimal/libmpdec/bench.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


static void
err_exit(const char *msg)
{
    fprintf(stderr, "%s\n", msg);
    exit(1);
}

static mpd_t *
new_mpd(void)
{
    mpd_t *x = mpd_qnew();
    if (x == NULL) {
        err_exit("out of memory");
    }

    return x;
}

/* Nonsense version of escape-time algorithm for calculating a mandelbrot
 * set. Just for benchmarking. */
static void
color_point(mpd_t *x0, mpd_t *y0, long maxiter, mpd_context_t *ctx)
{
    mpd_t *x, *y, *sq_x, *sq_y;
    mpd_t *two;

    x = new_mpd();
    y = new_mpd();
    mpd_set_u32(x, 0, ctx);
    mpd_set_u32(y, 0, ctx);

    sq_x = new_mpd();
    sq_y = new_mpd();
    mpd_set_u32(sq_x, 0, ctx);
    mpd_set_u32(sq_y, 0, ctx);

    two = new_mpd();
    mpd_set_u32(two, 2, ctx);

    for (long i = 0; i < maxiter; i++) {
        mpd_mul(y, x, y, ctx);
        mpd_mul(y, y, two, ctx);
        mpd_add(y, y, y0, ctx);

        mpd_sub(x, sq_x, sq_y, ctx);
        mpd_add(x, x, x0, ctx);

        mpd_mul(sq_x, x, x, ctx);
        mpd_mul(sq_y, y, y, ctx);
    }

    mpd_copy(x0, x, ctx);

    mpd_del(two);
    mpd_del(sq_y);
    mpd_del(sq_x);
    mpd_del(y);
    mpd_del(x);
}


int
main(int argc, char **argv)
{
    mpd_context_t ctx;
    mpd_t *x0, *y0;
    uint32_t prec = 19;
    long iter = 10000000;
    clock_t start_clock, end_clock;

    if (argc != 3) {
        err_exit("usage: bench prec iter\n");
    }
    prec = strtoul(argv[1], NULL, 10);
    iter = strtol(argv[2], NULL, 10);

    mpd_init(&ctx, prec);
    /* no more MPD_MINALLOC changes after here */

    x0 = new_mpd();
    y0 = new_mpd();
    mpd_set_string(x0, "0.222", &ctx);
    mpd_set_string(y0, "0.333", &ctx);
    if (ctx.status & MPD_Errors) {
        mpd_del(y0);
        mpd_del(x0);
        err_exit("unexpected error during conversion");
    }

    start_clock = clock();
    color_point(x0, y0, iter, &ctx);
    end_clock = clock();

    mpd_print(x0);
    fprintf(stderr, "time: %f\n\n", (double)(end_clock-start_clock)/(double)CLOCKS_PER_SEC);

    mpd_del(y0);
    mpd_del(x0);

    return 0;
}


================================================
File: /Modules/_decimal/libmpdec/bench_full.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>


static void
err_exit(const char *msg)
{
    fprintf(stderr, "%s\n", msg);
    exit(1);
}

static mpd_t *
new_mpd(void)
{
    mpd_t *x = mpd_qnew();
    if (x == NULL) {
        err_exit("out of memory");
    }

    return x;
}

/*
 * Example from: http://en.wikipedia.org/wiki/Mandelbrot_set
 *
 * Escape time algorithm for drawing the set:
 *
 * Point x0, y0 is deemed to be in the Mandelbrot set if the return
 * value is maxiter. Lower return values indicate how quickly points
 * escaped and can be used for coloring.
 */
static int
color_point(const mpd_t *x0, const mpd_t *y0, const long maxiter, mpd_context_t *ctx)
{
    mpd_t *x, *y, *sq_x, *sq_y;
    mpd_t *two, *four, *c;
    long i;

    x = new_mpd();
    y = new_mpd();
    mpd_set_u32(x, 0, ctx);
    mpd_set_u32(y, 0, ctx);

    sq_x = new_mpd();
    sq_y = new_mpd();
    mpd_set_u32(sq_x, 0, ctx);
    mpd_set_u32(sq_y, 0, ctx);

    two = new_mpd();
    four = new_mpd();
    mpd_set_u32(two, 2, ctx);
    mpd_set_u32(four, 4, ctx);

    c = new_mpd();
    mpd_set_u32(c, 0, ctx);

    for (i = 0; i < maxiter && mpd_cmp(c, four, ctx) <= 0; i++) {
        mpd_mul(y, x, y, ctx);
        mpd_mul(y, y, two, ctx);
        mpd_add(y, y, y0, ctx);

        mpd_sub(x, sq_x, sq_y, ctx);
        mpd_add(x, x, x0, ctx);

        mpd_mul(sq_x, x, x, ctx);
        mpd_mul(sq_y, y, y, ctx);
        mpd_add(c, sq_x, sq_y, ctx);
    }

    mpd_del(c);
    mpd_del(four);
    mpd_del(two);
    mpd_del(sq_y);
    mpd_del(sq_x);
    mpd_del(y);
    mpd_del(x);

    return i;
}

int
main(int argc, char **argv)
{
    mpd_context_t ctx;
    mpd_t *x0, *y0;
    mpd_t *sqrt_2, *xstep, *ystep;
    mpd_ssize_t prec = 19;

    long iter = 1000;
    int points[40][80];
    int i, j;
    clock_t start_clock, end_clock;


    if (argc != 3) {
        fprintf(stderr, "usage: ./bench prec iter\n");
        exit(1);
    }
    prec = strtoll(argv[1], NULL, 10);
    iter = strtol(argv[2], NULL, 10);

    mpd_init(&ctx, prec);
    /* no more MPD_MINALLOC changes after here */

    sqrt_2 = new_mpd();
    xstep = new_mpd();
    ystep = new_mpd();
    x0 = new_mpd();
    y0 = new_mpd();

    mpd_set_u32(sqrt_2, 2, &ctx);
    mpd_sqrt(sqrt_2, sqrt_2, &ctx);
    mpd_div_u32(xstep, sqrt_2, 40, &ctx);
    mpd_div_u32(ystep, sqrt_2, 20, &ctx);

    start_clock = clock();
    mpd_copy(y0, sqrt_2, &ctx);
    for (i = 0; i < 40; i++) {
        mpd_copy(x0, sqrt_2, &ctx);
        mpd_set_negative(x0);
        for (j = 0; j < 80; j++) {
            points[i][j] = color_point(x0, y0, iter, &ctx);
            mpd_add(x0, x0, xstep, &ctx);
        }
        mpd_sub(y0, y0, ystep, &ctx);
    }
    end_clock = clock();

#ifdef BENCH_VERBOSE
    for (i = 0; i < 40; i++) {
        for (j = 0; j < 80; j++) {
            if (points[i][j] == iter) {
                putchar('*');
            }
            else if (points[i][j] >= 10) {
                putchar('+');
            }
            else if (points[i][j] >= 5) {
                putchar('.');
            }
            else {
                putchar(' ');
            }
        }
        putchar('\n');
    }
    putchar('\n');
#else
    (void)points; /* suppress gcc warning */
#endif

    printf("time: %f\n\n", (double)(end_clock-start_clock)/(double)CLOCKS_PER_SEC);

    mpd_del(y0);
    mpd_del(x0);
    mpd_del(ystep);
    mpd_del(xstep);
    mpd_del(sqrt_2);

    return 0;
}


================================================
File: /Modules/_decimal/libmpdec/bits.h
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#ifndef LIBMPDEC_BITS_H_
#define LIBMPDEC_BITS_H_


#include "mpdecimal.h"


/* Check if n is a power of 2. */
static inline int
ispower2(mpd_size_t n)
{
    return n != 0 && (n & (n-1)) == 0;
}

#if defined(ANSI)
/*
 * Return the most significant bit position of n from 0 to 31 (63).
 * Assumptions: n != 0.
 */
static inline int
mpd_bsr(mpd_size_t n)
{
    int pos = 0;
    mpd_size_t tmp;

#ifdef CONFIG_64
    tmp = n >> 32;
    if (tmp != 0) { n = tmp; pos += 32; }
#endif
    tmp = n >> 16;
    if (tmp != 0) { n = tmp; pos += 16; }
    tmp = n >> 8;
    if (tmp != 0) { n = tmp; pos += 8; }
    tmp = n >> 4;
    if (tmp != 0) { n = tmp; pos += 4; }
    tmp = n >> 2;
    if (tmp != 0) { n = tmp; pos += 2; }
    tmp = n >> 1;
    if (tmp != 0) { n = tmp; pos += 1; }

    return pos + (int)n - 1;
}

/*
 * Return the least significant bit position of n from 0 to 31 (63).
 * Assumptions: n != 0.
 */
static inline int
mpd_bsf(mpd_size_t n)
{
    int pos;

#ifdef CONFIG_64
    pos = 63;
    if (n & 0x00000000FFFFFFFFULL) { pos -= 32; } else { n >>= 32; }
    if (n & 0x000000000000FFFFULL) { pos -= 16; } else { n >>= 16; }
    if (n & 0x00000000000000FFULL) { pos -=  8; } else { n >>=  8; }
    if (n & 0x000000000000000FULL) { pos -=  4; } else { n >>=  4; }
    if (n & 0x0000000000000003ULL) { pos -=  2; } else { n >>=  2; }
    if (n & 0x0000000000000001ULL) { pos -=  1; }
#else
    pos = 31;
    if (n & 0x000000000000FFFFUL) { pos -= 16; } else { n >>= 16; }
    if (n & 0x00000000000000FFUL) { pos -=  8; } else { n >>=  8; }
    if (n & 0x000000000000000FUL) { pos -=  4; } else { n >>=  4; }
    if (n & 0x0000000000000003UL) { pos -=  2; } else { n >>=  2; }
    if (n & 0x0000000000000001UL) { pos -=  1; }
#endif
    return pos;
}
/* END ANSI */

#elif defined(ASM)
/*
 * Bit scan reverse. Assumptions: a != 0.
 */
static inline int
mpd_bsr(mpd_size_t a)
{
    mpd_size_t retval;

    __asm__ (
#ifdef CONFIG_64
        "bsrq %1, %0\n\t"
#else
        "bsr %1, %0\n\t"
#endif
        :"=r" (retval)
        :"r" (a)
        :"cc"
    );

    return (int)retval;
}

/*
 * Bit scan forward. Assumptions: a != 0.
 */
static inline int
mpd_bsf(mpd_size_t a)
{
    mpd_size_t retval;

    __asm__ (
#ifdef CONFIG_64
        "bsfq %1, %0\n\t"
#else
        "bsf %1, %0\n\t"
#endif
        :"=r" (retval)
        :"r" (a)
        :"cc"
    );

    return (int)retval;
}
/* END ASM */

#elif defined(MASM)
#include <intrin.h>
/*
 * Bit scan reverse. Assumptions: a != 0.
 */
static inline int __cdecl
mpd_bsr(mpd_size_t a)
{
    unsigned long retval;

#ifdef CONFIG_64
    _BitScanReverse64(&retval, a);
#else
    _BitScanReverse(&retval, a);
#endif

    return (int)retval;
}

/*
 * Bit scan forward. Assumptions: a != 0.
 */
static inline int __cdecl
mpd_bsf(mpd_size_t a)
{
    unsigned long retval;

#ifdef CONFIG_64
    _BitScanForward64(&retval, a);
#else
    _BitScanForward(&retval, a);
#endif

    return (int)retval;
}
/* END MASM (_MSC_VER) */
#else
  #error "missing preprocessor definitions"
#endif /* BSR/BSF */


#endif /* LIBMPDEC_BITS_H_ */


================================================
File: /Modules/_decimal/libmpdec/constants.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"
#include "basearith.h"
#include "constants.h"


#if defined(CONFIG_64)

  /* number-theory.c */
  const mpd_uint_t mpd_moduli[3] = {
    18446744069414584321ULL, 18446744056529682433ULL, 18446742974197923841ULL
  };
  const mpd_uint_t mpd_roots[3]  = {7ULL, 10ULL, 19ULL};

  /* crt.c */
  const mpd_uint_t INV_P1_MOD_P2   = 18446744055098026669ULL;
  const mpd_uint_t INV_P1P2_MOD_P3 = 287064143708160ULL;
  const mpd_uint_t LH_P1P2 = 18446744052234715137ULL;     /* (P1*P2) % 2^64 */
  const mpd_uint_t UH_P1P2 = 18446744052234715141ULL;     /* (P1*P2) / 2^64 */

  /* transpose.c */
  const mpd_size_t mpd_bits[64] = {
    1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024,  2048, 4096, 8192, 16384,
    32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,
    16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824,
    2147483648ULL, 4294967296ULL, 8589934592ULL, 17179869184ULL, 34359738368ULL,
    68719476736ULL, 137438953472ULL, 274877906944ULL, 549755813888ULL,
    1099511627776ULL, 2199023255552ULL, 4398046511104, 8796093022208ULL,
    17592186044416ULL, 35184372088832ULL, 70368744177664ULL, 140737488355328ULL,
    281474976710656ULL, 562949953421312ULL, 1125899906842624ULL,
    2251799813685248ULL, 4503599627370496ULL, 9007199254740992ULL,
    18014398509481984ULL, 36028797018963968ULL, 72057594037927936ULL,
    144115188075855872ULL, 288230376151711744ULL, 576460752303423488ULL,
    1152921504606846976ULL, 2305843009213693952ULL, 4611686018427387904ULL,
    9223372036854775808ULL
  };

  /* mpdecimal.c */
  const mpd_uint_t mpd_pow10[MPD_RDIGITS+1] = {
    1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,
    10000000000ULL,100000000000ULL,1000000000000ULL,10000000000000ULL,
    100000000000000ULL,1000000000000000ULL,10000000000000000ULL,
    100000000000000000ULL,1000000000000000000ULL,10000000000000000000ULL
  };

  /* magic number for constant division by MPD_RADIX */
  const mpd_uint_t mprime_rdx = 15581492618384294730ULL;

#elif defined(CONFIG_32)

  /* number-theory.c */
  const mpd_uint_t mpd_moduli[3]  = {2113929217UL, 2013265921UL, 1811939329UL};
  const mpd_uint_t mpd_roots[3]   = {5UL, 31UL, 13UL};

  /* PentiumPro modular multiplication: These constants have to be loaded as
   * 80 bit long doubles, which are not supported by certain compilers. */
  const uint32_t mpd_invmoduli[3][3] = {
    {4293885170U, 2181570688U, 16352U},  /* ((long double) 1 / 2113929217UL) */
    {1698898177U, 2290649223U, 16352U},  /* ((long double) 1 / 2013265921UL) */
    {2716021846U, 2545165803U, 16352U}   /* ((long double) 1 / 1811939329UL) */
  };

  const float MPD_TWO63 = 9223372036854775808.0; /* 2^63 */

  /* crt.c */
  const mpd_uint_t INV_P1_MOD_P2   = 2013265901UL;
  const mpd_uint_t INV_P1P2_MOD_P3 = 54UL;
  const mpd_uint_t LH_P1P2 = 4127195137UL;  /* (P1*P2) % 2^32 */
  const mpd_uint_t UH_P1P2 = 990904320UL;   /* (P1*P2) / 2^32 */

  /* transpose.c */
  const mpd_size_t mpd_bits[32] = {
    1, 2, 4, 8, 16, 32, 64, 128, 256, 512,  1024,  2048, 4096, 8192, 16384,
    32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608,
    16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824,
    2147483648UL
  };

  /* mpdecimal.c */
  const mpd_uint_t mpd_pow10[MPD_RDIGITS+1] = {
    1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000
  };

#else
  #error "CONFIG_64 or CONFIG_32 must be defined."
#endif

const char * const mpd_round_string[MPD_ROUND_GUARD] = {
    "ROUND_UP",          /* round away from 0               */
    "ROUND_DOWN",        /* round toward 0 (truncate)       */
    "ROUND_CEILING",     /* round toward +infinity          */
    "ROUND_FLOOR",       /* round toward -infinity          */
    "ROUND_HALF_UP",     /* 0.5 is rounded up               */
    "ROUND_HALF_DOWN",   /* 0.5 is rounded down             */
    "ROUND_HALF_EVEN",   /* 0.5 is rounded to even          */
    "ROUND_05UP",        /* round zero or five away from 0  */
    "ROUND_TRUNC",       /* truncate, but set infinity      */
};

const char * const mpd_clamp_string[MPD_CLAMP_GUARD] = {
    "CLAMP_DEFAULT",
    "CLAMP_IEEE_754"
};


================================================
File: /Modules/_decimal/libmpdec/constants.h
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#ifndef LIBMPDEC_CONSTANTS_H_
#define LIBMPDEC_CONSTANTS_H_


#include "mpdecimal.h"

#include <stdint.h>


/* Internal header file: all symbols have local scope in the DSO */
MPD_PRAGMA(MPD_HIDE_SYMBOLS_START)


/* choice of optimized functions */
#if defined(CONFIG_64)
/* x64 */
  #define MULMOD(a, b) x64_mulmod(a, b, umod)
  #define MULMOD2C(a0, a1, w) x64_mulmod2c(a0, a1, w, umod)
  #define MULMOD2(a0, b0, a1, b1) x64_mulmod2(a0, b0, a1, b1, umod)
  #define POWMOD(base, exp) x64_powmod(base, exp, umod)
  #define SETMODULUS(modnum) std_setmodulus(modnum, &umod)
  #define SIZE3_NTT(x0, x1, x2, w3table) std_size3_ntt(x0, x1, x2, w3table, umod)
#elif defined(PPRO)
/* PentiumPro (or later) gcc inline asm */
  #define MULMOD(a, b) ppro_mulmod(a, b, &dmod, dinvmod)
  #define MULMOD2C(a0, a1, w) ppro_mulmod2c(a0, a1, w, &dmod, dinvmod)
  #define MULMOD2(a0, b0, a1, b1) ppro_mulmod2(a0, b0, a1, b1, &dmod, dinvmod)
  #define POWMOD(base, exp) ppro_powmod(base, exp, &dmod, dinvmod)
  #define SETMODULUS(modnum) ppro_setmodulus(modnum, &umod, &dmod, dinvmod)
  #define SIZE3_NTT(x0, x1, x2, w3table) ppro_size3_ntt(x0, x1, x2, w3table, umod, &dmod, dinvmod)
#else
  /* ANSI C99 */
  #define MULMOD(a, b) std_mulmod(a, b, umod)
  #define MULMOD2C(a0, a1, w) std_mulmod2c(a0, a1, w, umod)
  #define MULMOD2(a0, b0, a1, b1) std_mulmod2(a0, b0, a1, b1, umod)
  #define POWMOD(base, exp) std_powmod(base, exp, umod)
  #define SETMODULUS(modnum) std_setmodulus(modnum, &umod)
  #define SIZE3_NTT(x0, x1, x2, w3table) std_size3_ntt(x0, x1, x2, w3table, umod)
#endif

/* PentiumPro (or later) gcc inline asm */
extern const float MPD_TWO63;
extern const uint32_t mpd_invmoduli[3][3];

enum {P1, P2, P3};

extern const mpd_uint_t mpd_moduli[];
extern const mpd_uint_t mpd_roots[];
extern const mpd_size_t mpd_bits[];
extern const mpd_uint_t mpd_pow10[];

extern const mpd_uint_t INV_P1_MOD_P2;
extern const mpd_uint_t INV_P1P2_MOD_P3;
extern const mpd_uint_t LH_P1P2;
extern const mpd_uint_t UH_P1P2;


MPD_PRAGMA(MPD_HIDE_SYMBOLS_END) /* restore previous scope rules */


#endif /* LIBMPDEC_CONSTANTS_H_ */


================================================
File: /Modules/_decimal/libmpdec/context.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"

#include <signal.h>
#include <stdio.h>
#include <string.h>


void
mpd_dflt_traphandler(mpd_context_t *ctx)
{
    (void)ctx;
    raise(SIGFPE);
}

void (* mpd_traphandler)(mpd_context_t *) = mpd_dflt_traphandler;


/* Set guaranteed minimum number of coefficient words. The function may
   be used once at program start. Setting MPD_MINALLOC to out-of-bounds
   values is a catastrophic error, so in that case the function exits rather
   than relying on the user to check a return value. */
void
mpd_setminalloc(mpd_ssize_t n)
{
    static int minalloc_is_set = 0;

    if (minalloc_is_set) {
        mpd_err_warn("mpd_setminalloc: ignoring request to set "
                     "MPD_MINALLOC a second time\n");
        return;
    }
    if (n < MPD_MINALLOC_MIN || n > MPD_MINALLOC_MAX) {
        mpd_err_fatal("illegal value for MPD_MINALLOC"); /* GCOV_NOT_REACHED */
    }
    MPD_MINALLOC = n;
    minalloc_is_set = 1;
}

void
mpd_init(mpd_context_t *ctx, mpd_ssize_t prec)
{
    mpd_ssize_t ideal_minalloc;

    mpd_defaultcontext(ctx);

    if (!mpd_qsetprec(ctx, prec)) {
        mpd_addstatus_raise(ctx, MPD_Invalid_context);
        return;
    }

    ideal_minalloc = 2 * ((prec+MPD_RDIGITS-1) / MPD_RDIGITS);
    if (ideal_minalloc < MPD_MINALLOC_MIN) ideal_minalloc = MPD_MINALLOC_MIN;
    if (ideal_minalloc > MPD_MINALLOC_MAX) ideal_minalloc = MPD_MINALLOC_MAX;

    mpd_setminalloc(ideal_minalloc);
}

void
mpd_maxcontext(mpd_context_t *ctx)
{
    ctx->prec=MPD_MAX_PREC;
    ctx->emax=MPD_MAX_EMAX;
    ctx->emin=MPD_MIN_EMIN;
    ctx->round=MPD_ROUND_HALF_EVEN;
    ctx->traps=MPD_Traps;
    ctx->status=0;
    ctx->newtrap=0;
    ctx->clamp=0;
    ctx->allcr=1;
}

void
mpd_defaultcontext(mpd_context_t *ctx)
{
    ctx->prec=2*MPD_RDIGITS;
    ctx->emax=MPD_MAX_EMAX;
    ctx->emin=MPD_MIN_EMIN;
    ctx->round=MPD_ROUND_HALF_UP;
    ctx->traps=MPD_Traps;
    ctx->status=0;
    ctx->newtrap=0;
    ctx->clamp=0;
    ctx->allcr=1;
}

void
mpd_basiccontext(mpd_context_t *ctx)
{
    ctx->prec=9;
    ctx->emax=MPD_MAX_EMAX;
    ctx->emin=MPD_MIN_EMIN;
    ctx->round=MPD_ROUND_HALF_UP;
    ctx->traps=MPD_Traps|MPD_Clamped;
    ctx->status=0;
    ctx->newtrap=0;
    ctx->clamp=0;
    ctx->allcr=1;
}

int
mpd_ieee_context(mpd_context_t *ctx, int bits)
{
    if (bits <= 0 || bits > MPD_IEEE_CONTEXT_MAX_BITS || bits % 32) {
        return -1;
    }

    ctx->prec = 9 * (bits/32) - 2;
    ctx->emax = 3 * ((mpd_ssize_t)1<<(bits/16+3));
    ctx->emin = 1 - ctx->emax;
    ctx->round=MPD_ROUND_HALF_EVEN;
    ctx->traps=0;
    ctx->status=0;
    ctx->newtrap=0;
    ctx->clamp=1;
    ctx->allcr=1;

    return 0;
}

mpd_ssize_t
mpd_getprec(const mpd_context_t *ctx)
{
    return ctx->prec;
}

mpd_ssize_t
mpd_getemax(const mpd_context_t *ctx)
{
    return ctx->emax;
}

mpd_ssize_t
mpd_getemin(const mpd_context_t *ctx)
{
    return ctx->emin;
}

int
mpd_getround(const mpd_context_t *ctx)
{
    return ctx->round;
}

uint32_t
mpd_gettraps(const mpd_context_t *ctx)
{
    return ctx->traps;
}

uint32_t
mpd_getstatus(const mpd_context_t *ctx)
{
    return ctx->status;
}

int
mpd_getclamp(const mpd_context_t *ctx)
{
    return ctx->clamp;
}

int
mpd_getcr(const mpd_context_t *ctx)
{
    return ctx->allcr;
}


int
mpd_qsetprec(mpd_context_t *ctx, mpd_ssize_t prec)
{
    if (prec <= 0 || prec > MPD_MAX_PREC) {
        return 0;
    }
    ctx->prec = prec;
    return 1;
}

int
mpd_qsetemax(mpd_context_t *ctx, mpd_ssize_t emax)
{
    if (emax < 0 || emax > MPD_MAX_EMAX) {
        return 0;
    }
    ctx->emax = emax;
    return 1;
}

int
mpd_qsetemin(mpd_context_t *ctx, mpd_ssize_t emin)
{
    if (emin > 0 || emin < MPD_MIN_EMIN) {
        return 0;
    }
    ctx->emin = emin;
    return 1;
}

int
mpd_qsetround(mpd_context_t *ctx, int round)
{
    if (!(0 <= round && round < MPD_ROUND_GUARD)) {
        return 0;
    }
    ctx->round = round;
    return 1;
}

int
mpd_qsettraps(mpd_context_t *ctx, uint32_t flags)
{
    if (flags > MPD_Max_status) {
        return 0;
    }
    ctx->traps = flags;
    return 1;
}

int
mpd_qsetstatus(mpd_context_t *ctx, uint32_t flags)
{
    if (flags > MPD_Max_status) {
        return 0;
    }
    ctx->status = flags;
    return 1;
}

int
mpd_qsetclamp(mpd_context_t *ctx, int c)
{
    if (c != 0 && c != 1) {
        return 0;
    }
    ctx->clamp = c;
    return 1;
}

int
mpd_qsetcr(mpd_context_t *ctx, int c)
{
    if (c != 0 && c != 1) {
        return 0;
    }
    ctx->allcr = c;
    return 1;
}


void
mpd_addstatus_raise(mpd_context_t *ctx, uint32_t flags)
{
    ctx->status |= flags;
    if (flags&ctx->traps) {
        ctx->newtrap = (flags&ctx->traps);
        mpd_traphandler(ctx);
    }
}


================================================
File: /Modules/_decimal/libmpdec/convolute.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"
#include "bits.h"
#include "constants.h"
#include "convolute.h"
#include "fnt.h"
#include "fourstep.h"
#include "numbertheory.h"
#include "sixstep.h"
#include "umodarith.h"


/* Bignum: Fast convolution using the Number Theoretic Transform. Used for
   the multiplication of very large coefficients. */


/* Convolute the data in c1 and c2. Result is in c1. */
int
fnt_convolute(mpd_uint_t *c1, mpd_uint_t *c2, mpd_size_t n, int modnum)
{
    int (*fnt)(mpd_uint_t *, mpd_size_t, int);
    int (*inv_fnt)(mpd_uint_t *, mpd_size_t, int);
#ifdef PPRO
    double dmod;
    uint32_t dinvmod[3];
#endif
    mpd_uint_t n_inv, umod;
    mpd_size_t i;


    SETMODULUS(modnum);
    n_inv = POWMOD(n, (umod-2));

    if (ispower2(n)) {
        if (n > SIX_STEP_THRESHOLD) {
            fnt = six_step_fnt;
            inv_fnt = inv_six_step_fnt;
        }
        else {
            fnt = std_fnt;
            inv_fnt = std_inv_fnt;
        }
    }
    else {
        fnt = four_step_fnt;
        inv_fnt = inv_four_step_fnt;
    }

    if (!fnt(c1, n, modnum)) {
        return 0;
    }
    if (!fnt(c2, n, modnum)) {
        return 0;
    }
    for (i = 0; i < n-1; i += 2) {
        mpd_uint_t x0 = c1[i];
        mpd_uint_t y0 = c2[i];
        mpd_uint_t x1 = c1[i+1];
        mpd_uint_t y1 = c2[i+1];
        MULMOD2(&x0, y0, &x1, y1);
        c1[i] = x0;
        c1[i+1] = x1;
    }

    if (!inv_fnt(c1, n, modnum)) {
        return 0;
    }
    for (i = 0; i < n-3; i += 4) {
        mpd_uint_t x0 = c1[i];
        mpd_uint_t x1 = c1[i+1];
        mpd_uint_t x2 = c1[i+2];
        mpd_uint_t x3 = c1[i+3];
        MULMOD2C(&x0, &x1, n_inv);
        MULMOD2C(&x2, &x3, n_inv);
        c1[i] = x0;
        c1[i+1] = x1;
        c1[i+2] = x2;
        c1[i+3] = x3;
    }

    return 1;
}

/* Autoconvolute the data in c1. Result is in c1. */
int
fnt_autoconvolute(mpd_uint_t *c1, mpd_size_t n, int modnum)
{
    int (*fnt)(mpd_uint_t *, mpd_size_t, int);
    int (*inv_fnt)(mpd_uint_t *, mpd_size_t, int);
#ifdef PPRO
    double dmod;
    uint32_t dinvmod[3];
#endif
    mpd_uint_t n_inv, umod;
    mpd_size_t i;


    SETMODULUS(modnum);
    n_inv = POWMOD(n, (umod-2));

    if (ispower2(n)) {
        if (n > SIX_STEP_THRESHOLD) {
            fnt = six_step_fnt;
            inv_fnt = inv_six_step_fnt;
        }
        else {
            fnt = std_fnt;
            inv_fnt = std_inv_fnt;
        }
    }
    else {
        fnt = four_step_fnt;
        inv_fnt = inv_four_step_fnt;
    }

    if (!fnt(c1, n, modnum)) {
        return 0;
    }
    for (i = 0; i < n-1; i += 2) {
        mpd_uint_t x0 = c1[i];
        mpd_uint_t x1 = c1[i+1];
        MULMOD2(&x0, x0, &x1, x1);
        c1[i] = x0;
        c1[i+1] = x1;
    }

    if (!inv_fnt(c1, n, modnum)) {
        return 0;
    }
    for (i = 0; i < n-3; i += 4) {
        mpd_uint_t x0 = c1[i];
        mpd_uint_t x1 = c1[i+1];
        mpd_uint_t x2 = c1[i+2];
        mpd_uint_t x3 = c1[i+3];
        MULMOD2C(&x0, &x1, n_inv);
        MULMOD2C(&x2, &x3, n_inv);
        c1[i] = x0;
        c1[i+1] = x1;
        c1[i+2] = x2;
        c1[i+3] = x3;
    }

    return 1;
}


================================================
File: /Modules/_decimal/libmpdec/convolute.h
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#ifndef LIBMPDEC_CONVOLUTE_H_
#define LIBMPDEC_CONVOLUTE_H_


#include "mpdecimal.h"


/* Internal header file: all symbols have local scope in the DSO */
MPD_PRAGMA(MPD_HIDE_SYMBOLS_START)


#define SIX_STEP_THRESHOLD 4096

int fnt_convolute(mpd_uint_t *c1, mpd_uint_t *c2, mpd_size_t n, int modnum);
int fnt_autoconvolute(mpd_uint_t *c1, mpd_size_t n, int modnum);


MPD_PRAGMA(MPD_HIDE_SYMBOLS_END) /* restore previous scope rules */


#endif /* LIBMPDEC_CONVOLUTE_H_ */


================================================
File: /Modules/_decimal/libmpdec/crt.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"

#include <assert.h>

#include "constants.h"
#include "crt.h"
#include "numbertheory.h"
#include "typearith.h"
#include "umodarith.h"


/* Bignum: Chinese Remainder Theorem, extends the maximum transform length. */


/* Multiply P1P2 by v, store result in w. */
static inline void
_crt_mulP1P2_3(mpd_uint_t w[3], mpd_uint_t v)
{
    mpd_uint_t hi1, hi2, lo;

    _mpd_mul_words(&hi1, &lo, LH_P1P2, v);
    w[0] = lo;

    _mpd_mul_words(&hi2, &lo, UH_P1P2, v);
    lo = hi1 + lo;
    if (lo < hi1) hi2++;

    w[1] = lo;
    w[2] = hi2;
}

/* Add 3 words from v to w. The result is known to fit in w. */
static inline void
_crt_add3(mpd_uint_t w[3], mpd_uint_t v[3])
{
    mpd_uint_t carry;

    w[0] = w[0] + v[0];
    carry = (w[0] < v[0]);

    w[1] = w[1] + v[1];
    if (w[1] < v[1]) w[2]++;

    w[1] = w[1] + carry;
    if (w[1] < carry) w[2]++;

    w[2] += v[2];
}

/* Divide 3 words in u by v, store result in w, return remainder. */
static inline mpd_uint_t
_crt_div3(mpd_uint_t *w, const mpd_uint_t *u, mpd_uint_t v)
{
    mpd_uint_t r1 = u[2];
    mpd_uint_t r2;

    if (r1 < v) {
        w[2] = 0;
    }
    else {
        _mpd_div_word(&w[2], &r1, u[2], v); /* GCOV_NOT_REACHED */
    }

    _mpd_div_words(&w[1], &r2, r1, u[1], v);
    _mpd_div_words(&w[0], &r1, r2, u[0], v);

    return r1;
}


/*
 * Chinese Remainder Theorem:
 * Algorithm from Joerg Arndt, "Matters Computational",
 * Chapter 37.4.1 [http://www.jjj.de/fxt/]
 *
 * See also Knuth, TAOCP, Volume 2, 4.3.2, exercise 7.
 */

/*
 * CRT with carry: x1, x2, x3 contain numbers modulo p1, p2, p3. For each
 * triple of members of the arrays, find the unique z modulo p1*p2*p3, with
 * zmax = p1*p2*p3 - 1.
 *
 * In each iteration of the loop, split z into result[i] = z % MPD_RADIX
 * and carry = z / MPD_RADIX. Let N be the size of carry[] and cmax the
 * maximum carry.
 *
 * Limits for the 32-bit build:
 *
 *   N    = 2**96
 *   cmax = 7711435591312380274
 *
 * Limits for the 64 bit build:
 *
 *   N    = 2**192
 *   cmax = 627710135393475385904124401220046371710
 *
 * The following statements hold for both versions:
 *
 *   1) cmax + zmax < N, so the addition does not overflow.
 *
 *   2) (cmax + zmax) / MPD_RADIX == cmax.
 *
 *   3) If c <= cmax, then c_next = (c + zmax) / MPD_RADIX <= cmax.
 */
void
crt3(mpd_uint_t *x1, mpd_uint_t *x2, mpd_uint_t *x3, mpd_size_t rsize)
{
    mpd_uint_t p1 = mpd_moduli[P1];
    mpd_uint_t umod;
#ifdef PPRO
    double dmod;
    uint32_t dinvmod[3];
#endif
    mpd_uint_t a1, a2, a3;
    mpd_uint_t s;
    mpd_uint_t z[3], t[3];
    mpd_uint_t carry[3] = {0,0,0};
    mpd_uint_t hi, lo;
    mpd_size_t i;

    for (i = 0; i < rsize; i++) {

        a1 = x1[i];
        a2 = x2[i];
        a3 = x3[i];

        SETMODULUS(P2);
        s = ext_submod(a2, a1, umod);
        s = MULMOD(s, INV_P1_MOD_P2);

        _mpd_mul_words(&hi, &lo, s, p1);
        lo = lo + a1;
        if (lo < a1) hi++;

        SETMODULUS(P3);
        s = dw_submod(a3, hi, lo, umod);
        s = MULMOD(s, INV_P1P2_MOD_P3);

        z[0] = lo;
        z[1] = hi;
        z[2] = 0;

        _crt_mulP1P2_3(t, s);
        _crt_add3(z, t);
        _crt_add3(carry, z);

        x1[i] = _crt_div3(carry, carry, MPD_RADIX);
    }

    assert(carry[0] == 0 && carry[1] == 0 && carry[2] == 0);
}


================================================
File: /Modules/_decimal/libmpdec/crt.h
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#ifndef LIBMPDEC_CRT_H_
#define LIBMPDEC_CRT_H_


#include "mpdecimal.h"


/* Internal header file: all symbols have local scope in the DSO */
MPD_PRAGMA(MPD_HIDE_SYMBOLS_START)


void crt3(mpd_uint_t *x1, mpd_uint_t *x2, mpd_uint_t *x3, mpd_size_t rsize);


MPD_PRAGMA(MPD_HIDE_SYMBOLS_END) /* restore previous scope rules */


#endif /* LIBMPDEC_CRT_H_ */


================================================
File: /Modules/_decimal/libmpdec/difradix2.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"

#include <assert.h>

#include "bits.h"
#include "constants.h"
#include "difradix2.h"
#include "numbertheory.h"
#include "umodarith.h"


/* Bignum: The actual transform routine (decimation in frequency). */


/*
 * Generate index pairs (x, bitreverse(x)) and carry out the permutation.
 * n must be a power of two.
 * Algorithm due to Brent/Lehmann, see Joerg Arndt, "Matters Computational",
 * Chapter 1.14.4. [http://www.jjj.de/fxt/]
 */
static inline void
bitreverse_permute(mpd_uint_t a[], mpd_size_t n)
{
    mpd_size_t x = 0;
    mpd_size_t r = 0;
    mpd_uint_t t;

    do { /* Invariant: r = bitreverse(x) */
        if (r > x) {
            t = a[x];
            a[x] = a[r];
            a[r] = t;
        }
        /* Flip trailing consecutive 1 bits and the first zero bit
         * that absorbs a possible carry. */
        x += 1;
        /* Mirror the operation on r: Flip n_trailing_zeros(x)+1
           high bits of r. */
        r ^= (n - (n >> (mpd_bsf(x)+1)));
        /* The loop invariant is preserved. */
    } while (x < n);
}


/* Fast Number Theoretic Transform, decimation in frequency. */
void
fnt_dif2(mpd_uint_t a[], mpd_size_t n, struct fnt_params *tparams)
{
    mpd_uint_t *wtable = tparams->wtable;
    mpd_uint_t umod;
#ifdef PPRO
    double dmod;
    uint32_t dinvmod[3];
#endif
    mpd_uint_t u0, u1, v0, v1;
    mpd_uint_t w, w0, w1, wstep;
    mpd_size_t m, mhalf;
    mpd_size_t j, r;


    assert(ispower2(n));
    assert(n >= 4);

    SETMODULUS(tparams->modnum);

    /* m == n */
    mhalf = n / 2;
    for (j = 0; j < mhalf; j += 2) {

        w0 = wtable[j];
        w1 = wtable[j+1];

        u0 = a[j];
        v0 = a[j+mhalf];

        u1 = a[j+1];
        v1 = a[j+1+mhalf];

        a[j] = addmod(u0, v0, umod);
        v0 = submod(u0, v0, umod);

        a[j+1] = addmod(u1, v1, umod);
        v1 = submod(u1, v1, umod);

        MULMOD2(&v0, w0, &v1, w1);

        a[j+mhalf] = v0;
        a[j+1+mhalf] = v1;

    }

    wstep = 2;
    for (m = n/2; m >= 2; m>>=1, wstep<<=1) {

        mhalf = m / 2;

        /* j == 0 */
        for (r = 0; r < n; r += 2*m) {

            u0 = a[r];
            v0 = a[r+mhalf];

            u1 = a[m+r];
            v1 = a[m+r+mhalf];

            a[r] = addmod(u0, v0, umod);
            v0 = submod(u0, v0, umod);

            a[m+r] = addmod(u1, v1, umod);
            v1 = submod(u1, v1, umod);

            a[r+mhalf] = v0;
            a[m+r+mhalf] = v1;
        }

        for (j = 1; j < mhalf; j++) {

            w = wtable[j*wstep];

            for (r = 0; r < n; r += 2*m) {

                u0 = a[r+j];
                v0 = a[r+j+mhalf];

                u1 = a[m+r+j];
                v1 = a[m+r+j+mhalf];

                a[r+j] = addmod(u0, v0, umod);
                v0 = submod(u0, v0, umod);

                a[m+r+j] = addmod(u1, v1, umod);
                v1 = submod(u1, v1, umod);

                MULMOD2C(&v0, &v1, w);

                a[r+j+mhalf] = v0;
                a[m+r+j+mhalf] = v1;
            }

        }

    }

    bitreverse_permute(a, n);
}


================================================
File: /Modules/_decimal/libmpdec/difradix2.h
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#ifndef LIBMPDEC_DIFRADIX2_H_
#define LIBMPDEC_DIFRADIX2_H_


#include "mpdecimal.h"
#include "numbertheory.h"


/* Internal header file: all symbols have local scope in the DSO */
MPD_PRAGMA(MPD_HIDE_SYMBOLS_START)


void fnt_dif2(mpd_uint_t a[], mpd_size_t n, struct fnt_params *tparams);


MPD_PRAGMA(MPD_HIDE_SYMBOLS_END) /* restore previous scope rules */


#endif /* LIBMPDEC_DIFRADIX2_H_ */


================================================
File: /Modules/_decimal/libmpdec/fnt.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"

#include <assert.h>
#include <stdio.h>

#include "bits.h"
#include "difradix2.h"
#include "fnt.h"
#include "numbertheory.h"


/* Bignum: Fast transform for medium-sized coefficients. */


/* forward transform, sign = -1 */
int
std_fnt(mpd_uint_t *a, mpd_size_t n, int modnum)
{
    struct fnt_params *tparams;

    assert(ispower2(n));
    assert(n >= 4);
    assert(n <= 3*MPD_MAXTRANSFORM_2N);

    if ((tparams = _mpd_init_fnt_params(n, -1, modnum)) == NULL) {
        return 0;
    }
    fnt_dif2(a, n, tparams);

    mpd_free(tparams);
    return 1;
}

/* reverse transform, sign = 1 */
int
std_inv_fnt(mpd_uint_t *a, mpd_size_t n, int modnum)
{
    struct fnt_params *tparams;

    assert(ispower2(n));
    assert(n >= 4);
    assert(n <= 3*MPD_MAXTRANSFORM_2N);

    if ((tparams = _mpd_init_fnt_params(n, 1, modnum)) == NULL) {
        return 0;
    }
    fnt_dif2(a, n, tparams);

    mpd_free(tparams);
    return 1;
}


================================================
File: /Modules/_decimal/libmpdec/fnt.h
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#ifndef LIBMPDEC_FNT_H_
#define LIBMPDEC_FNT_H_


#include "mpdecimal.h"


/* Internal header file: all symbols have local scope in the DSO */
MPD_PRAGMA(MPD_HIDE_SYMBOLS_START)


int std_fnt(mpd_uint_t a[], mpd_size_t n, int modnum);
int std_inv_fnt(mpd_uint_t a[], mpd_size_t n, int modnum);


MPD_PRAGMA(MPD_HIDE_SYMBOLS_END) /* restore previous scope rules */


#endif /* LIBMPDEC_FNT_H_ */


================================================
File: /Modules/_decimal/libmpdec/fourstep.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"

#include <assert.h>

#include "constants.h"
#include "fourstep.h"
#include "numbertheory.h"
#include "sixstep.h"
#include "umodarith.h"


/* Bignum: Cache efficient Matrix Fourier Transform for arrays of the
   form 3 * 2**n (See literature/matrix-transform.txt). */


#ifndef PPRO
static inline void
std_size3_ntt(mpd_uint_t *x1, mpd_uint_t *x2, mpd_uint_t *x3,
              mpd_uint_t w3table[3], mpd_uint_t umod)
{
    mpd_uint_t r1, r2;
    mpd_uint_t w;
    mpd_uint_t s, tmp;


    /* k = 0 -> w = 1 */
    s = *x1;
    s = addmod(s, *x2, umod);
    s = addmod(s, *x3, umod);

    r1 = s;

    /* k = 1 */
    s = *x1;

    w = w3table[1];
    tmp = MULMOD(*x2, w);
    s = addmod(s, tmp, umod);

    w = w3table[2];
    tmp = MULMOD(*x3, w);
    s = addmod(s, tmp, umod);

    r2 = s;

    /* k = 2 */
    s = *x1;

    w = w3table[2];
    tmp = MULMOD(*x2, w);
    s = addmod(s, tmp, umod);

    w = w3table[1];
    tmp = MULMOD(*x3, w);
    s = addmod(s, tmp, umod);

    *x3 = s;
    *x2 = r2;
    *x1 = r1;
}
#else /* PPRO */
static inline void
ppro_size3_ntt(mpd_uint_t *x1, mpd_uint_t *x2, mpd_uint_t *x3, mpd_uint_t w3table[3],
               mpd_uint_t umod, double *dmod, uint32_t dinvmod[3])
{
    mpd_uint_t r1, r2;
    mpd_uint_t w;
    mpd_uint_t s, tmp;


    /* k = 0 -> w = 1 */
    s = *x1;
    s = addmod(s, *x2, umod);
    s = addmod(s, *x3, umod);

    r1 = s;

    /* k = 1 */
    s = *x1;

    w = w3table[1];
    tmp = ppro_mulmod(*x2, w, dmod, dinvmod);
    s = addmod(s, tmp, umod);

    w = w3table[2];
    tmp = ppro_mulmod(*x3, w, dmod, dinvmod);
    s = addmod(s, tmp, umod);

    r2 = s;

    /* k = 2 */
    s = *x1;

    w = w3table[2];
    tmp = ppro_mulmod(*x2, w, dmod, dinvmod);
    s = addmod(s, tmp, umod);

    w = w3table[1];
    tmp = ppro_mulmod(*x3, w, dmod, dinvmod);
    s = addmod(s, tmp, umod);

    *x3 = s;
    *x2 = r2;
    *x1 = r1;
}
#endif


/* forward transform, sign = -1; transform length = 3 * 2**n */
int
four_step_fnt(mpd_uint_t *a, mpd_size_t n, int modnum)
{
    mpd_size_t R = 3; /* number of rows */
    mpd_size_t C = n / 3; /* number of columns */
    mpd_uint_t w3table[3];
    mpd_uint_t kernel, w0, w1, wstep;
    mpd_uint_t *s, *p0, *p1, *p2;
    mpd_uint_t umod;
#ifdef PPRO
    double dmod;
    uint32_t dinvmod[3];
#endif
    mpd_size_t i, k;


    assert(n >= 48);
    assert(n <= 3*MPD_MAXTRANSFORM_2N);


    /* Length R transform on the columns. */
    SETMODULUS(modnum);
    _mpd_init_w3table(w3table, -1, modnum);
    for (p0=a, p1=p0+C, p2=p0+2*C; p0<a+C; p0++,p1++,p2++) {

        SIZE3_NTT(p0, p1, p2, w3table);
    }

    /* Multiply each matrix element (addressed by i*C+k) by r**(i*k). */
    kernel = _mpd_getkernel(n, -1, modnum);
    for (i = 1; i < R; i++) {
        w0 = 1;                  /* r**(i*0): initial value for k=0 */
        w1 = POWMOD(kernel, i);  /* r**(i*1): initial value for k=1 */
        wstep = MULMOD(w1, w1);  /* r**(2*i) */
        for (k = 0; k < C-1; k += 2) {
            mpd_uint_t x0 = a[i*C+k];
            mpd_uint_t x1 = a[i*C+k+1];
            MULMOD2(&x0, w0, &x1, w1);
            MULMOD2C(&w0, &w1, wstep);  /* r**(i*(k+2)) = r**(i*k) * r**(2*i) */
            a[i*C+k] = x0;
            a[i*C+k+1] = x1;
        }
    }

    /* Length C transform on the rows. */
    for (s = a; s < a+n; s += C) {
        if (!six_step_fnt(s, C, modnum)) {
            return 0;
        }
    }

#if 0
    /* An unordered transform is sufficient for convolution. */
    /* Transpose the matrix. */
    #include "transpose.h"
    transpose_3xpow2(a, R, C);
#endif

    return 1;
}

/* backward transform, sign = 1; transform length = 3 * 2**n */
int
inv_four_step_fnt(mpd_uint_t *a, mpd_size_t n, int modnum)
{
    mpd_size_t R = 3; /* number of rows */
    mpd_size_t C = n / 3; /* number of columns */
    mpd_uint_t w3table[3];
    mpd_uint_t kernel, w0, w1, wstep;
    mpd_uint_t *s, *p0, *p1, *p2;
    mpd_uint_t umod;
#ifdef PPRO
    double dmod;
    uint32_t dinvmod[3];
#endif
    mpd_size_t i, k;


    assert(n >= 48);
    assert(n <= 3*MPD_MAXTRANSFORM_2N);


#if 0
    /* An unordered transform is sufficient for convolution. */
    /* Transpose the matrix, producing an R*C matrix. */
    #include "transpose.h"
    transpose_3xpow2(a, C, R);
#endif

    /* Length C transform on the rows. */
    for (s = a; s < a+n; s += C) {
        if (!inv_six_step_fnt(s, C, modnum)) {
            return 0;
        }
    }

    /* Multiply each matrix element (addressed by i*C+k) by r**(i*k). */
    SETMODULUS(modnum);
    kernel = _mpd_getkernel(n, 1, modnum);
    for (i = 1; i < R; i++) {
        w0 = 1;
        w1 = POWMOD(kernel, i);
        wstep = MULMOD(w1, w1);
        for (k = 0; k < C; k += 2) {
            mpd_uint_t x0 = a[i*C+k];
            mpd_uint_t x1 = a[i*C+k+1];
            MULMOD2(&x0, w0, &x1, w1);
            MULMOD2C(&w0, &w1, wstep);
            a[i*C+k] = x0;
            a[i*C+k+1] = x1;
        }
    }

    /* Length R transform on the columns. */
    _mpd_init_w3table(w3table, 1, modnum);
    for (p0=a, p1=p0+C, p2=p0+2*C; p0<a+C; p0++,p1++,p2++) {

        SIZE3_NTT(p0, p1, p2, w3table);
    }

    return 1;
}


================================================
File: /Modules/_decimal/libmpdec/fourstep.h
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#ifndef LIBMPDEC_FOURSTEP_H_
#define LIBMPDEC_FOURSTEP_H_


#include "mpdecimal.h"


/* Internal header file: all symbols have local scope in the DSO */
MPD_PRAGMA(MPD_HIDE_SYMBOLS_START)


int four_step_fnt(mpd_uint_t *a, mpd_size_t n, int modnum);
int inv_four_step_fnt(mpd_uint_t *a, mpd_size_t n, int modnum);


MPD_PRAGMA(MPD_HIDE_SYMBOLS_END) /* restore previous scope rules */


#endif /* LIBMPDEC_FOURSTEP_H_ */


================================================
File: /Modules/_decimal/libmpdec/io.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"

#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <limits.h>
#include <locale.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "io.h"
#include "typearith.h"


/* This file contains functions for decimal <-> string conversions, including
   PEP-3101 formatting for numeric types. */


#if defined(__GNUC__) && !defined(__INTEL_COMPILER) && __GNUC__ >= 7
  #pragma GCC diagnostic ignored "-Wimplicit-fallthrough"
  #pragma GCC diagnostic ignored "-Wmisleading-indentation"
  #pragma GCC diagnostic ignored "-Warray-bounds"
#endif


/*
 * Work around the behavior of tolower() and strcasecmp() in certain
 * locales. For example, in tr_TR.utf8:
 *
 * tolower((unsigned char)'I') == 'I'
 *
 * u is the exact uppercase version of l; n is strlen(l) or strlen(l)+1
 */
static inline int
_mpd_strneq(const char *s, const char *l, const char *u, size_t n)
{
    while (--n != SIZE_MAX) {
        if (*s != *l && *s != *u) {
            return 0;
        }
        s++; u++; l++;
    }

    return 1;
}

static mpd_ssize_t
strtoexp(const char *s)
{
    char *end;
    mpd_ssize_t retval;

    errno = 0;
    retval = mpd_strtossize(s, &end, 10);
    if (errno == 0 && !(*s != '\0' && *end == '\0'))
        errno = EINVAL;

    return retval;
}

/*
 * Scan 'len' words. The most significant word contains 'r' digits,
 * the remaining words are full words. Skip dpoint. The string 's' must
 * consist of digits and an optional single decimal point at 'dpoint'.
 */
static void
string_to_coeff(mpd_uint_t *data, const char *s, const char *dpoint, int r,
                size_t len)
{
    int j;

    if (r > 0) {
        data[--len] = 0;
        for (j = 0; j < r; j++, s++) {
            if (s == dpoint) s++;
            data[len] = 10 * data[len] + (*s - '0');
        }
    }

    while (--len != SIZE_MAX) {
        data[len] = 0;
        for (j = 0; j < MPD_RDIGITS; j++, s++) {
            if (s == dpoint) s++;
            data[len] = 10 * data[len] + (*s - '0');
        }
    }
}

/*
 * Partially verify a numeric string of the form:
 *
 *     [cdigits][.][cdigits][eE][+-][edigits]
 *
 * If successful, return a pointer to the location of the first
 * relevant coefficient digit. This digit is either non-zero or
 * part of one of the following patterns:
 *
 *     ["0\x00", "0.\x00", "0.E", "0.e", "0E", "0e"]
 *
 * The locations of a single optional dot or indicator are stored
 * in 'dpoint' and 'exp'.
 *
 * The end of the string is stored in 'end'. If an indicator [eE]
 * occurs without trailing [edigits], the condition is caught
 * later by strtoexp().
 */
static const char *
scan_dpoint_exp(const char *s, const char **dpoint, const char **exp,
                const char **end)
{
    const char *coeff = NULL;

    *dpoint = NULL;
    *exp = NULL;
    for (; *s != '\0'; s++) {
        switch (*s) {
        case '.':
            if (*dpoint != NULL || *exp != NULL)
                return NULL;
            *dpoint = s;
            break;
        case 'E': case 'e':
            if (*exp != NULL)
                return NULL;
            *exp = s;
            if (*(s+1) == '+' || *(s+1) == '-')
                s++;
            break;
        default:
            if (!isdigit((unsigned char)*s))
                return NULL;
            if (coeff == NULL && *exp == NULL) {
                if (*s == '0') {
                    if (!isdigit((unsigned char)*(s+1)))
                        if (!(*(s+1) == '.' &&
                              isdigit((unsigned char)*(s+2))))
                            coeff = s;
                }
                else {
                    coeff = s;
                }
            }
            break;

        }
    }

    *end = s;
    return coeff;
}

/* scan the payload of a NaN */
static const char *
scan_payload(const char *s, const char **end)
{
    const char *coeff;

    while (*s == '0')
        s++;
    coeff = s;

    while (isdigit((unsigned char)*s))
        s++;
    *end = s;

    return (*s == '\0') ? coeff : NULL;
}

/* convert a character string to a decimal */
void
mpd_qset_string(mpd_t *dec, const char *s, const mpd_context_t *ctx,
                uint32_t *status)
{
    mpd_ssize_t q, r, len;
    const char *coeff, *end;
    const char *dpoint = NULL, *exp = NULL;
    size_t digits;
    uint8_t sign = MPD_POS;

    mpd_set_flags(dec, 0);
    dec->len = 0;
    dec->exp = 0;

    /* sign */
    if (*s == '+') {
        s++;
    }
    else if (*s == '-') {
        mpd_set_negative(dec);
        sign = MPD_NEG;
        s++;
    }

    if (_mpd_strneq(s, "nan", "NAN", 3)) { /* NaN */
        s += 3;
        mpd_setspecial(dec, sign, MPD_NAN);
        if (*s == '\0')
            return;
        /* validate payload: digits only */
        if ((coeff = scan_payload(s, &end)) == NULL)
            goto conversion_error;
        /* payload consists entirely of zeros */
        if (*coeff == '\0')
            return;
        digits = end - coeff;
        /* prec >= 1, clamp is 0 or 1 */
        if (digits > (size_t)(ctx->prec-ctx->clamp))
            goto conversion_error;
    } /* sNaN */
    else if (_mpd_strneq(s, "snan", "SNAN", 4)) {
        s += 4;
        mpd_setspecial(dec, sign, MPD_SNAN);
        if (*s == '\0')
            return;
        /* validate payload: digits only */
        if ((coeff = scan_payload(s, &end)) == NULL)
            goto conversion_error;
        /* payload consists entirely of zeros */
        if (*coeff == '\0')
            return;
        digits = end - coeff;
        if (digits > (size_t)(ctx->prec-ctx->clamp))
            goto conversion_error;
    }
    else if (_mpd_strneq(s, "inf", "INF", 3)) {
        s += 3;
        if (*s == '\0' || _mpd_strneq(s, "inity", "INITY", 6)) {
            /* numeric-value: infinity */
            mpd_setspecial(dec, sign, MPD_INF);
            return;
        }
        goto conversion_error;
    }
    else {
        /* scan for start of coefficient, decimal point, indicator, end */
        if ((coeff = scan_dpoint_exp(s, &dpoint, &exp, &end)) == NULL)
            goto conversion_error;

        /* numeric-value: [exponent-part] */
        if (exp) {
            /* exponent-part */
            end = exp; exp++;
            dec->exp = strtoexp(exp);
            if (errno) {
                if (!(errno == ERANGE &&
                     (dec->exp == MPD_SSIZE_MAX ||
                      dec->exp == MPD_SSIZE_MIN)))
                    goto conversion_error;
            }
        }

        digits = end - coeff;
        if (dpoint) {
            size_t fracdigits = end-dpoint-1;
            if (dpoint > coeff) digits--;

            if (fracdigits > MPD_MAX_PREC) {
                goto conversion_error;
            }
            if (dec->exp < MPD_SSIZE_MIN+(mpd_ssize_t)fracdigits) {
                dec->exp = MPD_SSIZE_MIN;
            }
            else {
                dec->exp -= (mpd_ssize_t)fracdigits;
            }
        }
        if (digits > MPD_MAX_PREC) {
            goto conversion_error;
        }
        if (dec->exp > MPD_EXP_INF) {
            dec->exp = MPD_EXP_INF;
        }
        if (dec->exp == MPD_SSIZE_MIN) {
            dec->exp = MPD_SSIZE_MIN+1;
        }
    }

    _mpd_idiv_word(&q, &r, (mpd_ssize_t)digits, MPD_RDIGITS);

    len = (r == 0) ? q : q+1;
    if (len == 0) {
        goto conversion_error; /* GCOV_NOT_REACHED */
    }
    if (!mpd_qresize(dec, len, status)) {
        mpd_seterror(dec, MPD_Malloc_error, status);
        return;
    }
    dec->len = len;

    string_to_coeff(dec->data, coeff, dpoint, (int)r, len);

    mpd_setdigits(dec);
    mpd_qfinalize(dec, ctx, status);
    return;

conversion_error:
    /* standard wants a positive NaN */
    mpd_seterror(dec, MPD_Conversion_syntax, status);
}

/* convert a character string to a decimal, use a maxcontext for conversion */
void
mpd_qset_string_exact(mpd_t *dec, const char *s, uint32_t *status)
{
    mpd_context_t maxcontext;

    mpd_maxcontext(&maxcontext);
    mpd_qset_string(dec, s, &maxcontext, status);

    if (*status & (MPD_Inexact|MPD_Rounded|MPD_Clamped)) {
        /* we want exact results */
        mpd_seterror(dec, MPD_Invalid_operation, status);
    }
    *status &= MPD_Errors;
}

/* Print word x with n decimal digits to string s. dot is either NULL
   or the location of a decimal point. */
#define EXTRACT_DIGIT(s, x, d, dot) \
        if (s == dot) *s++ = '.'; *s++ = '0' + (char)(x / d); x %= d
static inline char *
word_to_string(char *s, mpd_uint_t x, int n, char *dot)
{
    switch(n) {
#ifdef CONFIG_64
    case 20: EXTRACT_DIGIT(s, x, 10000000000000000000ULL, dot); /* GCOV_NOT_REACHED */
    case 19: EXTRACT_DIGIT(s, x, 1000000000000000000ULL, dot);
    case 18: EXTRACT_DIGIT(s, x, 100000000000000000ULL, dot);
    case 17: EXTRACT_DIGIT(s, x, 10000000000000000ULL, dot);
    case 16: EXTRACT_DIGIT(s, x, 1000000000000000ULL, dot);
    case 15: EXTRACT_DIGIT(s, x, 100000000000000ULL, dot);
    case 14: EXTRACT_DIGIT(s, x, 10000000000000ULL, dot);
    case 13: EXTRACT_DIGIT(s, x, 1000000000000ULL, dot);
    case 12: EXTRACT_DIGIT(s, x, 100000000000ULL, dot);
    case 11: EXTRACT_DIGIT(s, x, 10000000000ULL, dot);
#endif
    case 10: EXTRACT_DIGIT(s, x, 1000000000UL, dot);
    case 9:  EXTRACT_DIGIT(s, x, 100000000UL, dot);
    case 8:  EXTRACT_DIGIT(s, x, 10000000UL, dot);
    case 7:  EXTRACT_DIGIT(s, x, 1000000UL, dot);
    case 6:  EXTRACT_DIGIT(s, x, 100000UL, dot);
    case 5:  EXTRACT_DIGIT(s, x, 10000UL, dot);
    case 4:  EXTRACT_DIGIT(s, x, 1000UL, dot);
    case 3:  EXTRACT_DIGIT(s, x, 100UL, dot);
    case 2:  EXTRACT_DIGIT(s, x, 10UL, dot);
    default: if (s == dot) *s++ = '.'; *s++ = '0' + (char)x;
    }

    *s = '\0';
    return s;
}

/* Print exponent x to string s. Undefined for MPD_SSIZE_MIN. */
static inline char *
exp_to_string(char *s, mpd_ssize_t x)
{
    char sign = '+';

    if (x < 0) {
        sign = '-';
        x = -x;
    }
    *s++ = sign;

    return word_to_string(s, x, mpd_word_digits(x), NULL);
}

/* Print the coefficient of dec to string s. len(dec) > 0. */
static inline char *
coeff_to_string(char *s, const mpd_t *dec)
{
    mpd_uint_t x;
    mpd_ssize_t i;

    /* most significant word */
    x = mpd_msword(dec);
    s = word_to_string(s, x, mpd_word_digits(x), NULL);

    /* remaining full words */
    for (i=dec->len-2; i >= 0; --i) {
        x = dec->data[i];
        s = word_to_string(s, x, MPD_RDIGITS, NULL);
    }

    return s;
}

/* Print the coefficient of dec to string s. len(dec) > 0. dot is either
   NULL or a pointer to the location of a decimal point. */
static inline char *
coeff_to_string_dot(char *s, char *dot, const mpd_t *dec)
{
    mpd_uint_t x;
    mpd_ssize_t i;

    /* most significant word */
    x = mpd_msword(dec);
    s = word_to_string(s, x, mpd_word_digits(x), dot);

    /* remaining full words */
    for (i=dec->len-2; i >= 0; --i) {
        x = dec->data[i];
        s = word_to_string(s, x, MPD_RDIGITS, dot);
    }

    return s;
}

/* Format type */
#define MPD_FMT_LOWER      0x00000000
#define MPD_FMT_UPPER      0x00000001
#define MPD_FMT_TOSCI      0x00000002
#define MPD_FMT_TOENG      0x00000004
#define MPD_FMT_EXP        0x00000008
#define MPD_FMT_FIXED      0x00000010
#define MPD_FMT_PERCENT    0x00000020
#define MPD_FMT_SIGN_SPACE 0x00000040
#define MPD_FMT_SIGN_PLUS  0x00000080

/* Default place of the decimal point for MPD_FMT_TOSCI, MPD_FMT_EXP */
#define MPD_DEFAULT_DOTPLACE 1

/*
 * Set *result to the string representation of a decimal. Return the length
 * of *result, not including the terminating '\0' character.
 *
 * Formatting is done according to 'flags'. A return value of -1 with *result
 * set to NULL indicates MPD_Malloc_error.
 *
 * 'dplace' is the default place of the decimal point. It is always set to
 * MPD_DEFAULT_DOTPLACE except for zeros in combination with MPD_FMT_EXP.
 */
static mpd_ssize_t
_mpd_to_string(char **result, const mpd_t *dec, int flags, mpd_ssize_t dplace)
{
    char *decstring = NULL, *cp = NULL;
    mpd_ssize_t ldigits;
    mpd_ssize_t mem = 0, k;

    if (mpd_isspecial(dec)) {

        mem = sizeof "-Infinity%";
        if (mpd_isnan(dec) && dec->len > 0) {
            /* diagnostic code */
            mem += dec->digits;
        }
        cp = decstring = mpd_alloc(mem, sizeof *decstring);
        if (cp == NULL) {
            *result = NULL;
            return -1;
        }

        if (mpd_isnegative(dec)) {
            *cp++ = '-';
        }
        else if (flags&MPD_FMT_SIGN_SPACE) {
            *cp++ = ' ';
        }
        else if (flags&MPD_FMT_SIGN_PLUS) {
            *cp++ = '+';
        }

        if (mpd_isnan(dec)) {
            if (mpd_isqnan(dec)) {
                strcpy(cp, "NaN");
                cp += 3;
            }
            else {
                strcpy(cp, "sNaN");
                cp += 4;
            }
            if (dec->len > 0) { /* diagnostic code */
                cp = coeff_to_string(cp, dec);
            }
        }
        else if (mpd_isinfinite(dec)) {
            strcpy(cp, "Infinity");
            cp += 8;
        }
        else { /* debug */
            abort(); /* GCOV_NOT_REACHED */
        }
    }
    else {
        assert(dec->len > 0);

        /*
         * For easier manipulation of the decimal point's location
         * and the exponent that is finally printed, the number is
         * rescaled to a virtual representation with exp = 0. Here
         * ldigits denotes the number of decimal digits to the left
         * of the decimal point and remains constant once initialized.
         *
         * dplace is the location of the decimal point relative to
         * the start of the coefficient. Note that 3) always holds
         * when dplace is shifted.
         *
         *   1) ldigits := dec->digits - dec->exp
         *   2) dplace  := ldigits            (initially)
         *   3) exp     := ldigits - dplace   (initially exp = 0)
         *
         *   0.00000_.____._____000000.
         *    ^      ^    ^           ^
         *    |      |    |           |
         *    |      |    |           `- dplace >= digits
         *    |      |    `- dplace in the middle of the coefficient
         *    |      ` dplace = 1 (after the first coefficient digit)
         *    `- dplace <= 0
         */

        ldigits = dec->digits + dec->exp;

        if (flags&MPD_FMT_EXP) {
            ;
        }
        else if (flags&MPD_FMT_FIXED || (dec->exp <= 0 && ldigits > -6)) {
            /* MPD_FMT_FIXED: always use fixed point notation.
             * MPD_FMT_TOSCI, MPD_FMT_TOENG: for a certain range,
             * override exponent notation. */
            dplace = ldigits;
        }
        else if (flags&MPD_FMT_TOENG) {
            if (mpd_iszero(dec)) {
                /* If the exponent is divisible by three,
                 * dplace = 1. Otherwise, move dplace one
                 * or two places to the left. */
                dplace = -1 + mod_mpd_ssize_t(dec->exp+2, 3);
            }
            else { /* ldigits-1 is the adjusted exponent, which
                    * should be divisible by three. If not, move
                    * dplace one or two places to the right. */
                dplace += mod_mpd_ssize_t(ldigits-1, 3);
            }
        }

        /*
         * Basic space requirements:
         *
         * [-][.][coeffdigits][E][-][expdigits+1][%]['\0']
         *
         * If the decimal point lies outside of the coefficient digits,
         * space is adjusted accordingly.
         */
        if (dplace <= 0) {
            mem = -dplace + dec->digits + 2;
        }
        else if (dplace >= dec->digits) {
            mem = dplace;
        }
        else {
            mem = dec->digits;
        }
        mem += (MPD_EXPDIGITS+1+6);

        cp = decstring = mpd_alloc(mem, sizeof *decstring);
        if (cp == NULL) {
            *result = NULL;
            return -1;
        }


        if (mpd_isnegative(dec)) {
            *cp++ = '-';
        }
        else if (flags&MPD_FMT_SIGN_SPACE) {
            *cp++ = ' ';
        }
        else if (flags&MPD_FMT_SIGN_PLUS) {
            *cp++ = '+';
        }

        if (dplace <= 0) {
            /* space: -dplace+dec->digits+2 */
            *cp++ = '0';
            *cp++ = '.';
            for (k = 0; k < -dplace; k++) {
                *cp++ = '0';
            }
            cp = coeff_to_string(cp, dec);
        }
        else if (dplace >= dec->digits) {
            /* space: dplace */
            cp = coeff_to_string(cp, dec);
            for (k = 0; k < dplace-dec->digits; k++) {
                *cp++ = '0';
            }
        }
        else {
            /* space: dec->digits+1 */
            cp = coeff_to_string_dot(cp, cp+dplace, dec);
        }

        /*
         * Conditions for printing an exponent:
         *
         *   MPD_FMT_TOSCI, MPD_FMT_TOENG: only if ldigits != dplace
         *   MPD_FMT_FIXED:                never (ldigits == dplace)
         *   MPD_FMT_EXP:                  always
         */
        if (ldigits != dplace || flags&MPD_FMT_EXP) {
            /* space: expdigits+2 */
            *cp++ = (flags&MPD_FMT_UPPER) ? 'E' : 'e';
            cp = exp_to_string(cp, ldigits-dplace);
        }
    }

    if (flags&MPD_FMT_PERCENT) {
        *cp++ = '%';
    }

    assert(cp < decstring+mem);
    assert(cp-decstring < MPD_SSIZE_MAX);

    *cp = '\0';
    *result = decstring;
    return (mpd_ssize_t)(cp-decstring);
}

char *
mpd_to_sci(const mpd_t *dec, int fmt)
{
    char *res;
    int flags = MPD_FMT_TOSCI;

    flags |= fmt ? MPD_FMT_UPPER : MPD_FMT_LOWER;
    (void)_mpd_to_string(&res, dec, flags, MPD_DEFAULT_DOTPLACE);
    return res;
}

char *
mpd_to_eng(const mpd_t *dec, int fmt)
{
    char *res;
    int flags = MPD_FMT_TOENG;

    flags |= fmt ? MPD_FMT_UPPER : MPD_FMT_LOWER;
    (void)_mpd_to_string(&res, dec, flags, MPD_DEFAULT_DOTPLACE);
    return res;
}

mpd_ssize_t
mpd_to_sci_size(char **res, const mpd_t *dec, int fmt)
{
    int flags = MPD_FMT_TOSCI;

    flags |= fmt ? MPD_FMT_UPPER : MPD_FMT_LOWER;
    return _mpd_to_string(res, dec, flags, MPD_DEFAULT_DOTPLACE);
}

mpd_ssize_t
mpd_to_eng_size(char **res, const mpd_t *dec, int fmt)
{
    int flags = MPD_FMT_TOENG;

    flags |= fmt ? MPD_FMT_UPPER : MPD_FMT_LOWER;
    return _mpd_to_string(res, dec, flags, MPD_DEFAULT_DOTPLACE);
}

/* Copy a single UTF-8 char to dest. See: The Unicode Standard, version 5.2,
   chapter 3.9: Well-formed UTF-8 byte sequences. */
static int
_mpd_copy_utf8(char dest[5], const char *s)
{
    const unsigned char *cp = (const unsigned char *)s;
    unsigned char lb, ub;
    int count, i;


    if (*cp == 0) {
        /* empty string */
        dest[0] = '\0';
        return 0;
    }
    else if (*cp <= 0x7f) {
        /* ascii */
        dest[0] = *cp;
        dest[1] = '\0';
        return 1;
    }
    else if (0xc2 <= *cp && *cp <= 0xdf) {
        lb = 0x80; ub = 0xbf;
        count = 2;
    }
    else if (*cp == 0xe0) {
        lb = 0xa0; ub = 0xbf;
        count = 3;
    }
    else if (*cp <= 0xec) {
        lb = 0x80; ub = 0xbf;
        count = 3;
    }
    else if (*cp == 0xed) {
        lb = 0x80; ub = 0x9f;
        count = 3;
    }
    else if (*cp <= 0xef) {
        lb = 0x80; ub = 0xbf;
        count = 3;
    }
    else if (*cp == 0xf0) {
        lb = 0x90; ub = 0xbf;
        count = 4;
    }
    else if (*cp <= 0xf3) {
        lb = 0x80; ub = 0xbf;
        count = 4;
    }
    else if (*cp == 0xf4) {
        lb = 0x80; ub = 0x8f;
        count = 4;
    }
    else {
        /* invalid */
        goto error;
    }

    dest[0] = *cp++;
    if (*cp < lb || ub < *cp) {
        goto error;
    }
    dest[1] = *cp++;
    for (i = 2; i < count; i++) {
        if (*cp < 0x80 || 0xbf < *cp) {
            goto error;
        }
        dest[i] = *cp++;
    }
    dest[i] = '\0';

    return count;

error:
    dest[0] = '\0';
    return -1;
}

int
mpd_validate_lconv(mpd_spec_t *spec)
{
    size_t n;
#if CHAR_MAX == SCHAR_MAX
    const char *cp = spec->grouping;
    while (*cp != '\0') {
        if (*cp++ < 0) {
            return -1;
        }
    }
#endif
    n = strlen(spec->dot);
    if (n == 0 || n > 4) {
        return -1;
    }
    if (strlen(spec->sep) > 4) {
        return -1;
    }

    return 0;
}

int
mpd_parse_fmt_str(mpd_spec_t *spec, const char *fmt, int caps)
{
    char *cp = (char *)fmt;
    int have_align = 0, n;

    /* defaults */
    spec->min_width = 0;
    spec->prec = -1;
    spec->type = caps ? 'G' : 'g';
    spec->align = '>';
    spec->sign = '-';
    spec->dot = "";
    spec->sep = "";
    spec->grouping = "";


    /* presume that the first character is a UTF-8 fill character */
    if ((n = _mpd_copy_utf8(spec->fill, cp)) < 0) {
        return 0;
    }

    /* alignment directive, prefixed by a fill character */
    if (*cp && (*(cp+n) == '<' || *(cp+n) == '>' ||
                *(cp+n) == '=' || *(cp+n) == '^')) {
        cp += n;
        spec->align = *cp++;
        have_align = 1;
    } /* alignment directive */
    else {
        /* default fill character */
        spec->fill[0] = ' ';
        spec->fill[1] = '\0';
        if (*cp == '<' || *cp == '>' ||
            *cp == '=' || *cp == '^') {
            spec->align = *cp++;
            have_align = 1;
        }
    }

    /* sign formatting */
    if (*cp == '+' || *cp == '-' || *cp == ' ') {
        spec->sign = *cp++;
    }

    /* zero padding */
    if (*cp == '0') {
        /* zero padding implies alignment, which should not be
         * specified twice. */
        if (have_align) {
            return 0;
        }
        spec->align = 'z';
        spec->fill[0] = *cp++;
        spec->fill[1] = '\0';
    }

    /* minimum width */
    if (isdigit((unsigned char)*cp)) {
        if (*cp == '0') {
            return 0;
        }
        errno = 0;
        spec->min_width = mpd_strtossize(cp, &cp, 10);
        if (errno == ERANGE || errno == EINVAL) {
            return 0;
        }
    }

    /* thousands separator */
    if (*cp == ',') {
        spec->dot = ".";
        spec->sep = ",";
        spec->grouping = "\003\003";
        cp++;
    }

    /* fraction digits or significant digits */
    if (*cp == '.') {
        cp++;
        if (!isdigit((unsigned char)*cp)) {
            return 0;
        }
        errno = 0;
        spec->prec = mpd_strtossize(cp, &cp, 10);
        if (errno == ERANGE || errno == EINVAL) {
            return 0;
        }
    }

    /* type */
    if (*cp == 'E' || *cp == 'e' || *cp == 'F' || *cp == 'f' ||
        *cp == 'G' || *cp == 'g' || *cp == '%') {
        spec->type = *cp++;
    }
    else if (*cp == 'N' || *cp == 'n') {
        /* locale specific conversion */
        struct lconv *lc;
        /* separator has already been specified */
        if (*spec->sep) {
            return 0;
        }
        spec->type = *cp++;
        spec->type = (spec->type == 'N') ? 'G' : 'g';
        lc = localeconv();
        spec->dot = lc->decimal_point;
        spec->sep = lc->thousands_sep;
        spec->grouping = lc->grouping;
        if (mpd_validate_lconv(spec) < 0) {
            return 0; /* GCOV_NOT_REACHED */
        }
    }

    /* check correctness */
    if (*cp != '\0') {
        return 0;
    }

    return 1;
}

/*
 * The following functions assume that spec->min_width <= MPD_MAX_PREC, which
 * is made sure in mpd_qformat_spec. Then, even with a spec that inserts a
 * four-byte separator after each digit, nbytes in the following struct
 * cannot overflow.
 */

/* Multibyte string */
typedef struct {
    mpd_ssize_t nbytes; /* length in bytes */
    mpd_ssize_t nchars; /* length in chars */
    mpd_ssize_t cur;    /* current write index */
    char *data;
} mpd_mbstr_t;

static inline void
_mpd_bcopy(char *dest, const char *src, mpd_ssize_t n)
{
    while (--n >= 0) {
        dest[n] = src[n];
    }
}

static inline void
_mbstr_copy_char(mpd_mbstr_t *dest, const char *src, mpd_ssize_t n)
{
    dest->nbytes += n;
    dest->nchars += (n > 0 ? 1 : 0);
    dest->cur -= n;

    if (dest->data != NULL) {
        _mpd_bcopy(dest->data+dest->cur, src, n);
    }
}

static inline void
_mbstr_copy_ascii(mpd_mbstr_t *dest, const char *src, mpd_ssize_t n)
{
    dest->nbytes += n;
    dest->nchars += n;
    dest->cur -= n;

    if (dest->data != NULL) {
        _mpd_bcopy(dest->data+dest->cur, src, n);
    }
}

static inline void
_mbstr_copy_pad(mpd_mbstr_t *dest, mpd_ssize_t n)
{
    dest->nbytes += n;
    dest->nchars += n;
    dest->cur -= n;

    if (dest->data != NULL) {
        char *cp = dest->data + dest->cur;
        while (--n >= 0) {
            cp[n] = '0';
        }
    }
}

/*
 * Copy a numeric string to dest->data, adding separators in the integer
 * part according to spec->grouping. If leading zero padding is enabled
 * and the result is smaller than spec->min_width, continue adding zeros
 * and separators until the minimum width is reached.
 *
 * The final length of dest->data is stored in dest->nbytes. The number
 * of UTF-8 characters is stored in dest->nchars.
 *
 * First run (dest->data == NULL): determine the length of the result
 * string and store it in dest->nbytes.
 *
 * Second run (write to dest->data): data is written in chunks and in
 * reverse order, starting with the rest of the numeric string.
 */
static void
_mpd_add_sep_dot(mpd_mbstr_t *dest,
                 const char *sign, /* location of optional sign */
                 const char *src, mpd_ssize_t n_src, /* integer part and length */
                 const char *dot, /* location of optional decimal point */
                 const char *rest, mpd_ssize_t n_rest, /* remaining part and length */
                 const mpd_spec_t *spec)
{
    mpd_ssize_t n_sep, n_sign, consume;
    const char *g;
    int pad = 0;

    n_sign = sign ? 1 : 0;
    n_sep = (mpd_ssize_t)strlen(spec->sep);
    /* Initial write index: set to location of '\0' in the output string.
     * Irrelevant for the first run. */
    dest->cur = dest->nbytes;
    dest->nbytes = dest->nchars = 0;

    _mbstr_copy_ascii(dest, rest, n_rest);

    if (dot) {
        _mbstr_copy_char(dest, dot, (mpd_ssize_t)strlen(dot));
    }

    g = spec->grouping;
    consume = *g;
    while (1) {
        /* If the group length is 0 or CHAR_MAX or greater than the
         * number of source bytes, consume all remaining bytes. */
        if (*g == 0 || *g == CHAR_MAX || consume > n_src) {
            consume = n_src;
        }
        n_src -= consume;
        if (pad) {
            _mbstr_copy_pad(dest, consume);
        }
        else {
            _mbstr_copy_ascii(dest, src+n_src, consume);
        }

        if (n_src == 0) {
            /* Either the real source of intpart digits or the virtual
             * source of padding zeros is exhausted. */
            if (spec->align == 'z' &&
                dest->nchars + n_sign < spec->min_width) {
                /* Zero padding is set and length < min_width:
                 * Generate n_src additional characters. */
                n_src = spec->min_width - (dest->nchars + n_sign);
                /* Next iteration:
                 *   case *g == 0 || *g == CHAR_MAX:
                 *      consume all padding characters
                 *   case consume < g*:
                 *      fill remainder of current group
                 *   case consume == g*
                 *      copying is a no-op */
                consume = *g - consume;
                /* Switch on virtual source of zeros. */
                pad = 1;
                continue;
            }
            break;
        }

        if (n_sep > 0) {
            /* If padding is switched on, separators are counted
             * as padding characters. This rule does not apply if
             * the separator would be the first character of the
             * result string. */
            if (pad && n_src > 1) n_src -= 1;
            _mbstr_copy_char(dest, spec->sep, n_sep);
        }

        /* If non-NUL, use the next value for grouping. */
        if (*g && *(g+1)) g++;
        consume = *g;
    }

    if (sign) {
        _mbstr_copy_ascii(dest, sign, 1);
    }

    if (dest->data) {
        dest->data[dest->nbytes] = '\0';
    }
}

/*
 * Convert a numeric-string to its locale-specific appearance.
 * The string must have one of these forms:
 *
 *     1) [sign] digits [exponent-part]
 *     2) [sign] digits '.' [digits] [exponent-part]
 *
 * Not allowed, since _mpd_to_string() never returns this form:
 *
 *     3) [sign] '.' digits [exponent-part]
 *
 * Input: result->data := original numeric string (ASCII)
 *        result->bytes := strlen(result->data)
 *        result->nchars := strlen(result->data)
 *
 * Output: result->data := modified or original string
 *         result->bytes := strlen(result->data)
 *         result->nchars := number of characters (possibly UTF-8)
 */
static int
_mpd_apply_lconv(mpd_mbstr_t *result, const mpd_spec_t *spec, uint32_t *status)
{
    const char *sign = NULL, *intpart = NULL, *dot = NULL;
    const char *rest, *dp;
    char *decstring;
    mpd_ssize_t n_int, n_rest;

    /* original numeric string */
    dp = result->data;

    /* sign */
    if (*dp == '+' || *dp == '-' || *dp == ' ') {
        sign = dp++;
    }
    /* integer part */
    assert(isdigit((unsigned char)*dp));
    intpart = dp++;
    while (isdigit((unsigned char)*dp)) {
        dp++;
    }
    n_int = (mpd_ssize_t)(dp-intpart);
    /* decimal point */
    if (*dp == '.') {
        dp++; dot = spec->dot;
    }
    /* rest */
    rest = dp;
    n_rest = result->nbytes - (mpd_ssize_t)(dp-result->data);

    if (dot == NULL && (*spec->sep == '\0' || *spec->grouping == '\0')) {
        /* _mpd_add_sep_dot() would not change anything */
        return 1;
    }

    /* Determine the size of the new decimal string after inserting the
     * decimal point, optional separators and optional padding. */
    decstring = result->data;
    result->data = NULL;
    _mpd_add_sep_dot(result, sign, intpart, n_int, dot,
                     rest, n_rest, spec);

    result->data = mpd_alloc(result->nbytes+1, 1);
    if (result->data == NULL) {
        *status |= MPD_Malloc_error;
        mpd_free(decstring);
        return 0;
    }

    /* Perform actual writes. */
    _mpd_add_sep_dot(result, sign, intpart, n_int, dot,
                     rest, n_rest, spec);

    mpd_free(decstring);
    return 1;
}

/* Add padding to the formatted string if necessary. */
static int
_mpd_add_pad(mpd_mbstr_t *result, const mpd_spec_t *spec, uint32_t *status)
{
    if (result->nchars < spec->min_width) {
        mpd_ssize_t add_chars, add_bytes;
        size_t lpad = 0, rpad = 0;
        size_t n_fill, len, i, j;
        char align = spec->align;
        uint8_t err = 0;
        char *cp;

        n_fill = strlen(spec->fill);
        add_chars = (spec->min_width - result->nchars);
        /* max value: MPD_MAX_PREC * 4 */
        add_bytes = add_chars * (mpd_ssize_t)n_fill;

        cp = result->data = mpd_realloc(result->data,
                                        result->nbytes+add_bytes+1,
                                        sizeof *result->data, &err);
        if (err) {
            *status |= MPD_Malloc_error;
            mpd_free(result->data);
            return 0;
        }

        if (align == 'z') {
            align = '=';
        }

        if (align == '<') {
            rpad = add_chars;
        }
        else if (align == '>' || align == '=') {
            lpad = add_chars;
        }
        else { /* align == '^' */
            lpad = add_chars/2;
            rpad = add_chars-lpad;
        }

        len = result->nbytes;
        if (align == '=' && (*cp == '-' || *cp == '+' || *cp == ' ')) {
            /* leave sign in the leading position */
            cp++; len--;
        }

        memmove(cp+n_fill*lpad, cp, len);
        for (i = 0; i < lpad; i++) {
            for (j = 0; j < n_fill; j++) {
                cp[i*n_fill+j] = spec->fill[j];
            }
        }
        cp += (n_fill*lpad + len);
        for (i = 0; i < rpad; i++) {
            for (j = 0; j < n_fill; j++) {
                cp[i*n_fill+j] = spec->fill[j];
            }
        }

        result->nbytes += add_bytes;
        result->nchars += add_chars;
        result->data[result->nbytes] = '\0';
    }

    return 1;
}

/* Round a number to prec digits. The adjusted exponent stays the same
   or increases by one if rounding up crosses a power of ten boundary.
   If result->digits would exceed MPD_MAX_PREC+1, MPD_Invalid_operation
   is set and the result is NaN. */
static inline void
_mpd_round(mpd_t *result, const mpd_t *a, mpd_ssize_t prec,
           const mpd_context_t *ctx, uint32_t *status)
{
    mpd_ssize_t exp = a->exp + a->digits - prec;

    if (prec <= 0) {
        mpd_seterror(result, MPD_Invalid_operation, status); /* GCOV_NOT_REACHED */
        return; /* GCOV_NOT_REACHED */
    }
    if (mpd_isspecial(a) || mpd_iszero(a)) {
        mpd_qcopy(result, a, status); /* GCOV_NOT_REACHED */
        return; /* GCOV_NOT_REACHED */
    }

    mpd_qrescale_fmt(result, a, exp, ctx, status);
    if (result->digits > prec) {
        mpd_qrescale_fmt(result, result, exp+1, ctx, status);
    }
}

/*
 * Return the string representation of an mpd_t, formatted according to 'spec'.
 * The format specification is assumed to be valid. Memory errors are indicated
 * as usual. This function is quiet.
 */
char *
mpd_qformat_spec(const mpd_t *dec, const mpd_spec_t *spec,
                 const mpd_context_t *ctx, uint32_t *status)
{
    mpd_uint_t dt[MPD_MINALLOC_MAX];
    mpd_t tmp = {MPD_STATIC|MPD_STATIC_DATA,0,0,0,MPD_MINALLOC_MAX,dt};
    mpd_ssize_t dplace = MPD_DEFAULT_DOTPLACE;
    mpd_mbstr_t result;
    mpd_spec_t stackspec;
    char type = spec->type;
    int flags = 0;


    if (spec->min_width > MPD_MAX_PREC) {
        *status |= MPD_Invalid_operation;
        return NULL;
    }

    if (isupper((unsigned char)type)) {
        type = (char)tolower((unsigned char)type);
        flags |= MPD_FMT_UPPER;
    }
    if (spec->sign == ' ') {
        flags |= MPD_FMT_SIGN_SPACE;
    }
    else if (spec->sign == '+') {
        flags |= MPD_FMT_SIGN_PLUS;
    }

    if (mpd_isspecial(dec)) {
        if (spec->align == 'z') {
            stackspec = *spec;
            stackspec.fill[0] = ' ';
            stackspec.fill[1] = '\0';
            stackspec.align = '>';
            spec = &stackspec;
        }
        assert(strlen(spec->fill) == 1); /* annotation for scan-build */
        if (type == '%') {
            flags |= MPD_FMT_PERCENT;
        }
    }
    else {
        uint32_t workstatus = 0;
        mpd_ssize_t prec;

        switch (type) {
        case 'g': flags |= MPD_FMT_TOSCI; break;
        case 'e': flags |= MPD_FMT_EXP; break;
        case '%': flags |= MPD_FMT_PERCENT;
                  if (!mpd_qcopy(&tmp, dec, status)) {
                      return NULL;
                  }
                  tmp.exp += 2;
                  dec = &tmp;
                  type = 'f'; /* fall through */
        case 'f': flags |= MPD_FMT_FIXED; break;
        default: abort(); /* debug: GCOV_NOT_REACHED */
        }

        if (spec->prec >= 0) {
            if (spec->prec > MPD_MAX_PREC) {
                *status |= MPD_Invalid_operation;
                goto error;
            }

            switch (type) {
            case 'g':
                prec = (spec->prec == 0) ? 1 : spec->prec;
                if (dec->digits > prec) {
                    _mpd_round(&tmp, dec, prec, ctx,
                               &workstatus);
                    dec = &tmp;
                }
                break;
            case 'e':
                if (mpd_iszero(dec)) {
                    dplace = 1-spec->prec;
                }
                else {
                    _mpd_round(&tmp, dec, spec->prec+1, ctx,
                               &workstatus);
                    dec = &tmp;
                }
                break;
            case 'f':
                mpd_qrescale(&tmp, dec, -spec->prec, ctx,
                             &workstatus);
                dec = &tmp;
                break;
            }
        }

        if (type == 'f') {
            if (mpd_iszero(dec) && dec->exp > 0) {
                mpd_qrescale(&tmp, dec, 0, ctx, &workstatus);
                dec = &tmp;
            }
        }

        if (workstatus&MPD_Errors) {
            *status |= (workstatus&MPD_Errors);
            goto error;
        }
    }

    /*
     * At this point, for all scaled or non-scaled decimals:
     *   1) 1 <= digits <= MAX_PREC+1
     *   2) adjexp(scaled) = adjexp(orig) [+1]
     *   3)   case 'g': MIN_ETINY <= exp <= MAX_EMAX+1
     *        case 'e': MIN_ETINY-MAX_PREC <= exp <= MAX_EMAX+1
     *        case 'f': MIN_ETINY <= exp <= MAX_EMAX+1
     *   4) max memory alloc in _mpd_to_string:
     *        case 'g': MAX_PREC+36
     *        case 'e': MAX_PREC+36
     *        case 'f': 2*MPD_MAX_PREC+30
     */
    result.nbytes = _mpd_to_string(&result.data, dec, flags, dplace);
    result.nchars = result.nbytes;
    if (result.nbytes < 0) {
        *status |= MPD_Malloc_error;
        goto error;
    }

    if (*spec->dot != '\0' && !mpd_isspecial(dec)) {
        if (result.nchars > MPD_MAX_PREC+36) {
            /* Since a group length of one is not explicitly
             * disallowed, ensure that it is always possible to
             * insert a four byte separator after each digit. */
            *status |= MPD_Invalid_operation;
            mpd_free(result.data);
            goto error;
        }
        if (!_mpd_apply_lconv(&result, spec, status)) {
            goto error;
        }
    }

    if (spec->min_width) {
        if (!_mpd_add_pad(&result, spec, status)) {
            goto error;
        }
    }

    mpd_del(&tmp);
    return result.data;

error:
    mpd_del(&tmp);
    return NULL;
}

char *
mpd_qformat(const mpd_t *dec, const char *fmt, const mpd_context_t *ctx,
            uint32_t *status)
{
    mpd_spec_t spec;

    if (!mpd_parse_fmt_str(&spec, fmt, 1)) {
        *status |= MPD_Invalid_operation;
        return NULL;
    }

    return mpd_qformat_spec(dec, &spec, ctx, status);
}

/*
 * The specification has a *condition* called Invalid_operation and an
 * IEEE *signal* called Invalid_operation. The former corresponds to
 * MPD_Invalid_operation, the latter to MPD_IEEE_Invalid_operation.
 * MPD_IEEE_Invalid_operation comprises the following conditions:
 *
 * [MPD_Conversion_syntax, MPD_Division_impossible, MPD_Division_undefined,
 *  MPD_Fpu_error, MPD_Invalid_context, MPD_Invalid_operation,
 *  MPD_Malloc_error]
 *
 * In the following functions, 'flag' denotes the condition, 'signal'
 * denotes the IEEE signal.
 */

static const char *mpd_flag_string[MPD_NUM_FLAGS] = {
    "Clamped",
    "Conversion_syntax",
    "Division_by_zero",
    "Division_impossible",
    "Division_undefined",
    "Fpu_error",
    "Inexact",
    "Invalid_context",
    "Invalid_operation",
    "Malloc_error",
    "Not_implemented",
    "Overflow",
    "Rounded",
    "Subnormal",
    "Underflow",
};

static const char *mpd_signal_string[MPD_NUM_FLAGS] = {
    "Clamped",
    "IEEE_Invalid_operation",
    "Division_by_zero",
    "IEEE_Invalid_operation",
    "IEEE_Invalid_operation",
    "IEEE_Invalid_operation",
    "Inexact",
    "IEEE_Invalid_operation",
    "IEEE_Invalid_operation",
    "IEEE_Invalid_operation",
    "Not_implemented",
    "Overflow",
    "Rounded",
    "Subnormal",
    "Underflow",
};

/* print conditions to buffer, separated by spaces */
int
mpd_snprint_flags(char *dest, int nmemb, uint32_t flags)
{
    char *cp;
    int n, j;

    assert(nmemb >= MPD_MAX_FLAG_STRING);

    *dest = '\0'; cp = dest;
    for (j = 0; j < MPD_NUM_FLAGS; j++) {
        if (flags & (1U<<j)) {
            n = snprintf(cp, nmemb, "%s ", mpd_flag_string[j]);
            if (n < 0 || n >= nmemb) return -1;
            cp += n; nmemb -= n;
        }
    }

    if (cp != dest) {
        *(--cp) = '\0';
    }

    return (int)(cp-dest);
}

/* print conditions to buffer, in list form */
int
mpd_lsnprint_flags(char *dest, int nmemb, uint32_t flags, const char *flag_string[])
{
    char *cp;
    int n, j;

    assert(nmemb >= MPD_MAX_FLAG_LIST);
    if (flag_string == NULL) {
        flag_string = mpd_flag_string;
    }

    *dest = '[';
    *(dest+1) = '\0';
    cp = dest+1;
    --nmemb;

    for (j = 0; j < MPD_NUM_FLAGS; j++) {
        if (flags & (1U<<j)) {
            n = snprintf(cp, nmemb, "%s, ", flag_string[j]);
            if (n < 0 || n >= nmemb) return -1;
            cp += n; nmemb -= n;
        }
    }

    /* erase the last ", " */
    if (cp != dest+1) {
        cp -= 2;
    }

    *cp++ = ']';
    *cp = '\0';

    return (int)(cp-dest); /* strlen, without NUL terminator */
}

/* print signals to buffer, in list form */
int
mpd_lsnprint_signals(char *dest, int nmemb, uint32_t flags, const char *signal_string[])
{
    char *cp;
    int n, j;
    int ieee_invalid_done = 0;

    assert(nmemb >= MPD_MAX_SIGNAL_LIST);
    if (signal_string == NULL) {
        signal_string = mpd_signal_string;
    }

    *dest = '[';
    *(dest+1) = '\0';
    cp = dest+1;
    --nmemb;

    for (j = 0; j < MPD_NUM_FLAGS; j++) {
        uint32_t f = flags & (1U<<j);
        if (f) {
            if (f&MPD_IEEE_Invalid_operation) {
                if (ieee_invalid_done) {
                    continue;
                }
                ieee_invalid_done = 1;
            }
            n = snprintf(cp, nmemb, "%s, ", signal_string[j]);
            if (n < 0 || n >= nmemb) return -1;
            cp += n; nmemb -= n;
        }
    }

    /* erase the last ", " */
    if (cp != dest+1) {
        cp -= 2;
    }

    *cp++ = ']';
    *cp = '\0';

    return (int)(cp-dest); /* strlen, without NUL terminator */
}

/* The following two functions are mainly intended for debugging. */
void
mpd_fprint(FILE *file, const mpd_t *dec)
{
    char *decstring;

    decstring = mpd_to_sci(dec, 1);
    if (decstring != NULL) {
        fprintf(file, "%s\n", decstring);
        mpd_free(decstring);
    }
    else {
        fputs("mpd_fprint: output error\n", file); /* GCOV_NOT_REACHED */
    }
}

void
mpd_print(const mpd_t *dec)
{
    char *decstring;

    decstring = mpd_to_sci(dec, 1);
    if (decstring != NULL) {
        printf("%s\n", decstring);
        mpd_free(decstring);
    }
    else {
        fputs("mpd_fprint: output error\n", stderr); /* GCOV_NOT_REACHED */
    }
}


================================================
File: /Modules/_decimal/libmpdec/io.h
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#ifndef LIBMPDEC_IO_H_
#define LIBMPDEC_IO_H_


#include "mpdecimal.h"

#include <stdint.h>


#if SIZE_MAX == MPD_SIZE_MAX
  #define mpd_strtossize _mpd_strtossize
#else
#include <errno.h>

static inline mpd_ssize_t
mpd_strtossize(const char *s, char **end, int base)
{
    int64_t retval;

    errno = 0;
    retval = _mpd_strtossize(s, end, base);
    if (errno == 0 && (retval > MPD_SSIZE_MAX || retval < MPD_SSIZE_MIN)) {
        errno = ERANGE;
    }
    if (errno == ERANGE) {
        return (retval < 0) ? MPD_SSIZE_MIN : MPD_SSIZE_MAX;
    }

    return (mpd_ssize_t)retval;
}
#endif


#endif /* LIBMPDEC_IO_H_ */


================================================
File: /Modules/_decimal/libmpdec/mpalloc.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "mpalloc.h"
#include "typearith.h"


#if defined(_MSC_VER)
  #pragma warning(disable : 4232)
#endif


/* Guaranteed minimum allocation for a coefficient. May be changed once
   at program start using mpd_setminalloc(). */
mpd_ssize_t MPD_MINALLOC = MPD_MINALLOC_MIN;

/* Custom allocation and free functions */
void *(* mpd_mallocfunc)(size_t size) = malloc;
void *(* mpd_reallocfunc)(void *ptr, size_t size) = realloc;
void *(* mpd_callocfunc)(size_t nmemb, size_t size) = calloc;
void (* mpd_free)(void *ptr) = free;


/* emulate calloc if it is not available */
void *
mpd_callocfunc_em(size_t nmemb, size_t size)
{
    void *ptr;
    size_t req;
    mpd_size_t overflow;

    req = mul_size_t_overflow((mpd_size_t)nmemb, (mpd_size_t)size,
                              &overflow);
    if (overflow) {
        return NULL;
    }

    ptr = mpd_mallocfunc(req);
    if (ptr == NULL) {
        return NULL;
    }
    /* used on uint32_t or uint64_t */
    memset(ptr, 0, req);

    return ptr;
}


/* malloc with overflow checking */
void *
mpd_alloc(mpd_size_t nmemb, mpd_size_t size)
{
    mpd_size_t req, overflow;

    req = mul_size_t_overflow(nmemb, size, &overflow);
    if (overflow) {
        return NULL;
    }

    return mpd_mallocfunc(req);
}

/* calloc with overflow checking */
void *
mpd_calloc(mpd_size_t nmemb, mpd_size_t size)
{
    mpd_size_t overflow;

    (void)mul_size_t_overflow(nmemb, size, &overflow);
    if (overflow) {
        return NULL;
    }

    return mpd_callocfunc(nmemb, size);
}

/* realloc with overflow checking */
void *
mpd_realloc(void *ptr, mpd_size_t nmemb, mpd_size_t size, uint8_t *err)
{
    void *new;
    mpd_size_t req, overflow;

    req = mul_size_t_overflow(nmemb, size, &overflow);
    if (overflow) {
        *err = 1;
        return ptr;
    }

    new = mpd_reallocfunc(ptr, req);
    if (new == NULL) {
        *err = 1;
        return ptr;
    }

    return new;
}

/* struct hack malloc with overflow checking */
void *
mpd_sh_alloc(mpd_size_t struct_size, mpd_size_t nmemb, mpd_size_t size)
{
    mpd_size_t req, overflow;

    req = mul_size_t_overflow(nmemb, size, &overflow);
    if (overflow) {
        return NULL;
    }

    req = add_size_t_overflow(req, struct_size, &overflow);
    if (overflow) {
        return NULL;
    }

    return mpd_mallocfunc(req);
}


/* Allocate a new decimal with a coefficient of length 'nwords'. In case
   of an error the return value is NULL. */
mpd_t *
mpd_qnew_size(mpd_ssize_t nwords)
{
    mpd_t *result;

    nwords = (nwords < MPD_MINALLOC) ? MPD_MINALLOC : nwords;

    result = mpd_alloc(1, sizeof *result);
    if (result == NULL) {
        return NULL;
    }

    result->data = mpd_alloc(nwords, sizeof *result->data);
    if (result->data == NULL) {
        mpd_free(result);
        return NULL;
    }

    result->flags = 0;
    result->exp = 0;
    result->digits = 0;
    result->len = 0;
    result->alloc = nwords;

    return result;
}

/* Allocate a new decimal with a coefficient of length MPD_MINALLOC.
   In case of an error the return value is NULL. */
mpd_t *
mpd_qnew(void)
{
    return mpd_qnew_size(MPD_MINALLOC);
}

/* Allocate new decimal. Caller can check for NULL or MPD_Malloc_error.
   Raises on error. */
mpd_t *
mpd_new(mpd_context_t *ctx)
{
    mpd_t *result;

    result = mpd_qnew();
    if (result == NULL) {
        mpd_addstatus_raise(ctx, MPD_Malloc_error);
    }
    return result;
}

/*
 * Input: 'result' is a static mpd_t with a static coefficient.
 * Assumption: 'nwords' >= result->alloc.
 *
 * Resize the static coefficient to a larger dynamic one and copy the
 * existing data. If successful, the value of 'result' is unchanged.
 * Otherwise, set 'result' to NaN and update 'status' with MPD_Malloc_error.
 */
int
mpd_switch_to_dyn(mpd_t *result, mpd_ssize_t nwords, uint32_t *status)
{
    mpd_uint_t *p = result->data;

    assert(nwords >= result->alloc);

    result->data = mpd_alloc(nwords, sizeof *result->data);
    if (result->data == NULL) {
        result->data = p;
        mpd_set_qnan(result);
        mpd_set_positive(result);
        result->exp = result->digits = result->len = 0;
        *status |= MPD_Malloc_error;
        return 0;
    }

    memcpy(result->data, p, result->alloc * (sizeof *result->data));
    result->alloc = nwords;
    mpd_set_dynamic_data(result);
    return 1;
}

/*
 * Input: 'result' is a static mpd_t with a static coefficient.
 *
 * Convert the coefficient to a dynamic one that is initialized to zero. If
 * malloc fails, set 'result' to NaN and update 'status' with MPD_Malloc_error.
 */
int
mpd_switch_to_dyn_zero(mpd_t *result, mpd_ssize_t nwords, uint32_t *status)
{
    mpd_uint_t *p = result->data;

    result->data = mpd_calloc(nwords, sizeof *result->data);
    if (result->data == NULL) {
        result->data = p;
        mpd_set_qnan(result);
        mpd_set_positive(result);
        result->exp = result->digits = result->len = 0;
        *status |= MPD_Malloc_error;
        return 0;
    }

    result->alloc = nwords;
    mpd_set_dynamic_data(result);

    return 1;
}

/*
 * Input: 'result' is a static or a dynamic mpd_t with a dynamic coefficient.
 * Resize the coefficient to length 'nwords':
 *   Case nwords > result->alloc:
 *     If realloc is successful:
 *       'result' has a larger coefficient but the same value. Return 1.
 *     Otherwise:
 *       Set 'result' to NaN, update status with MPD_Malloc_error and return 0.
 *   Case nwords < result->alloc:
 *     If realloc is successful:
 *       'result' has a smaller coefficient. result->len is undefined. Return 1.
 *     Otherwise (unlikely):
 *       'result' is unchanged. Reuse the now oversized coefficient. Return 1.
 */
int
mpd_realloc_dyn(mpd_t *result, mpd_ssize_t nwords, uint32_t *status)
{
    uint8_t err = 0;

    result->data = mpd_realloc(result->data, nwords, sizeof *result->data, &err);
    if (!err) {
        result->alloc = nwords;
    }
    else if (nwords > result->alloc) {
        mpd_set_qnan(result);
        mpd_set_positive(result);
        result->exp = result->digits = result->len = 0;
        *status |= MPD_Malloc_error;
        return 0;
    }

    return 1;
}

/*
 * Input: 'result' is a static mpd_t with a static coefficient.
 * Assumption: 'nwords' >= result->alloc.
 *
 * Resize the static coefficient to a larger dynamic one and copy the
 * existing data.
 *
 * On failure the value of 'result' is unchanged.
 */
int
mpd_switch_to_dyn_cxx(mpd_t *result, mpd_ssize_t nwords)
{
    assert(nwords >= result->alloc);

    mpd_uint_t *data = mpd_alloc(nwords, sizeof *result->data);
    if (data == NULL) {
        return 0;
    }

    memcpy(data, result->data, result->alloc * (sizeof *result->data));
    result->data = data;
    result->alloc = nwords;
    mpd_set_dynamic_data(result);
    return 1;
}

/*
 * Input: 'result' is a static or a dynamic mpd_t with a dynamic coefficient.
 * Resize the coefficient to length 'nwords':
 *   Case nwords > result->alloc:
 *     If realloc is successful:
 *       'result' has a larger coefficient but the same value. Return 1.
 *     Otherwise:
 *       'result' has a the same coefficient. Return 0.
 *   Case nwords < result->alloc:
 *     If realloc is successful:
 *       'result' has a smaller coefficient. result->len is undefined. Return 1.
 *     Otherwise (unlikely):
 *       'result' is unchanged. Reuse the now oversized coefficient. Return 1.
 */
int
mpd_realloc_dyn_cxx(mpd_t *result, mpd_ssize_t nwords)
{
    uint8_t err = 0;

    mpd_uint_t *p = mpd_realloc(result->data, nwords, sizeof *result->data, &err);
    if (!err) {
        result->data = p;
        result->alloc = nwords;
    }
    else if (nwords > result->alloc) {
        return 0;
    }

    return 1;
}


================================================
File: /Modules/_decimal/libmpdec/mpalloc.h
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#ifndef LIBMPDEC_MPALLOC_H_
#define LIBMPDEC_MPALLOC_H_


#include "mpdecimal.h"

#include <stdint.h>


/* Internal header file: all symbols have local scope in the DSO */
MPD_PRAGMA(MPD_HIDE_SYMBOLS_START)


int mpd_switch_to_dyn(mpd_t *result, mpd_ssize_t nwords, uint32_t *status);
int mpd_switch_to_dyn_zero(mpd_t *result, mpd_ssize_t nwords, uint32_t *status);
int mpd_realloc_dyn(mpd_t *result, mpd_ssize_t nwords, uint32_t *status);

int mpd_switch_to_dyn_cxx(mpd_t *result, mpd_ssize_t nwords);
int mpd_realloc_dyn_cxx(mpd_t *result, mpd_ssize_t nwords);


MPD_PRAGMA(MPD_HIDE_SYMBOLS_END) /* restore previous scope rules */


#endif /* LIBMPDEC_MPALLOC_H_ */


================================================
File: /Modules/_decimal/libmpdec/mpdecimal.h
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#ifndef LIBMPDEC_MPDECIMAL_H_
#define LIBMPDEC_MPDECIMAL_H_


#ifndef _MSC_VER
  #include "pyconfig.h"
#endif

#ifdef __cplusplus
  #include <cinttypes>
  #include <climits>
  #include <cstdint>
  #include <cstdio>
  #include <cstdlib>
  #define MPD_UINT8_C(x) (static_cast<uint8_t>(x))
extern "C" {
#else
  #include <inttypes.h>
  #include <limits.h>
  #include <stdint.h>
  #include <stdio.h>
  #include <stdlib.h>
  #define MPD_UINT8_C(x) ((uint8_t)x)
#endif


#if (defined(__linux__) || defined(__FreeBSD__) || defined(__APPLE__)) && \
    defined(__GNUC__) && __GNUC__ >= 4 && !defined(__INTEL_COMPILER)
  #define MPD_PRAGMA(x) _Pragma(x)
  #define MPD_HIDE_SYMBOLS_START "GCC visibility push(hidden)"
  #define MPD_HIDE_SYMBOLS_END "GCC visibility pop"
#else
  #define MPD_PRAGMA(x)
  #define MPD_HIDE_SYMBOLS_START
  #define MPD_HIDE_SYMBOLS_END
#endif

#if defined(_MSC_VER)
  #define EXTINLINE extern inline
#else
  #define EXTINLINE
#endif


/* This header file is internal for the purpose of building _decimal.so.
 * All symbols should have local scope in the DSO. */
MPD_PRAGMA(MPD_HIDE_SYMBOLS_START)


/******************************************************************************/
/*                                  Version                                   */
/******************************************************************************/

#define MPD_MAJOR_VERSION 2
#define MPD_MINOR_VERSION 5
#define MPD_MICRO_VERSION 1

#define MPD_VERSION "2.5.1"

#define MPD_VERSION_HEX ((MPD_MAJOR_VERSION << 24) | \
                         (MPD_MINOR_VERSION << 16) | \
                         (MPD_MICRO_VERSION <<  8))

const char *mpd_version(void);


/******************************************************************************/
/*                              Configuration                                 */
/******************************************************************************/

#if defined(UNIVERSAL)
  #if defined(CONFIG_64) || defined(CONFIG_32)
    #error "cannot use CONFIG_64 or CONFIG_32 with UNIVERSAL."
  #endif
  #if defined(__ppc__)
    #define CONFIG_32
    #define ANSI
  #elif defined(__ppc64__)
    #define CONFIG_64
    #define ANSI
  #elif defined(__i386__)
    #define CONFIG_32
    #define ANSI
  #elif defined(__x86_64__)
    #define CONFIG_64
    #define ASM
  #elif defined(__arm64__)
    #define CONFIG_64
    #define ANSI
  #else
    #error "unknown architecture for universal build."
  #endif
#endif


/* BEGIN CONFIG_64 */
#if defined(CONFIG_64)
/* types for modular and base arithmetic */
#define MPD_UINT_MAX UINT64_MAX
#define MPD_BITS_PER_UINT 64
typedef uint64_t mpd_uint_t;  /* unsigned mod type */

#define MPD_SIZE_MAX SIZE_MAX
typedef size_t mpd_size_t; /* unsigned size type */

/* type for exp, digits, len, prec */
#define MPD_SSIZE_MAX INT64_MAX
#define MPD_SSIZE_MIN INT64_MIN
typedef int64_t mpd_ssize_t;
#define _mpd_strtossize strtoll

/* decimal arithmetic */
#define MPD_RADIX 10000000000000000000ULL  /* 10**19 */
#define MPD_RDIGITS 19
#define MPD_MAX_POW10 19
#define MPD_EXPDIGITS 19  /* MPD_EXPDIGITS <= MPD_RDIGITS+1 */

#define MPD_MAXTRANSFORM_2N 4294967296ULL      /* 2**32 */
#define MPD_MAX_PREC 999999999999999999LL
#define MPD_MAX_PREC_LOG2 64
#define MPD_ELIMIT  1000000000000000000LL
#define MPD_MAX_EMAX   999999999999999999LL    /* ELIMIT-1 */
#define MPD_MIN_EMIN  (-999999999999999999LL)  /* -EMAX */
#define MPD_MIN_ETINY (MPD_MIN_EMIN-(MPD_MAX_PREC-1))
#define MPD_EXP_INF 2000000000000000001LL
#define MPD_EXP_CLAMP (-4000000000000000001LL)
#define MPD_MAXIMPORT 105263157894736842L /* ceil((2*MPD_MAX_PREC)/MPD_RDIGITS) */
#define MPD_IEEE_CONTEXT_MAX_BITS 512     /* 16*(log2(MPD_MAX_EMAX / 3)-3) */

/* conversion specifiers */
#define PRI_mpd_uint_t PRIu64
#define PRI_mpd_ssize_t PRIi64
/* END CONFIG_64 */


/* BEGIN CONFIG_32 */
#elif defined(CONFIG_32)
/* types for modular and base arithmetic */
#define MPD_UINT_MAX UINT32_MAX
#define MPD_BITS_PER_UINT 32
typedef uint32_t mpd_uint_t;  /* unsigned mod type */

#ifndef LEGACY_COMPILER
#define MPD_UUINT_MAX UINT64_MAX
typedef uint64_t mpd_uuint_t; /* double width unsigned mod type */
#endif

#define MPD_SIZE_MAX SIZE_MAX
typedef size_t mpd_size_t; /* unsigned size type */

/* type for dec->len, dec->exp, ctx->prec */
#define MPD_SSIZE_MAX INT32_MAX
#define MPD_SSIZE_MIN INT32_MIN
typedef int32_t mpd_ssize_t;
#define _mpd_strtossize strtol

/* decimal arithmetic */
#define MPD_RADIX 1000000000UL  /* 10**9 */
#define MPD_RDIGITS 9
#define MPD_MAX_POW10 9
#define MPD_EXPDIGITS 10 /* MPD_EXPDIGITS <= MPD_RDIGITS+1 */

#define MPD_MAXTRANSFORM_2N 33554432UL /* 2**25 */
#define MPD_MAX_PREC 425000000L
#define MPD_MAX_PREC_LOG2 32
#define MPD_ELIMIT 425000001L
#define MPD_MAX_EMAX 425000000L        /* ELIMIT-1 */
#define MPD_MIN_EMIN (-425000000L)     /* -EMAX */
#define MPD_MIN_ETINY (MPD_MIN_EMIN-(MPD_MAX_PREC-1))
#define MPD_EXP_INF 1000000001L       /* allows for emax=999999999 in the tests */
#define MPD_EXP_CLAMP (-2000000001L)  /* allows for emin=-999999999 in the tests */
#define MPD_MAXIMPORT 94444445L       /* ceil((2*MPD_MAX_PREC)/MPD_RDIGITS) */
#define MPD_IEEE_CONTEXT_MAX_BITS 256 /* 16*(log2(MPD_MAX_EMAX / 3)-3) */

/* conversion specifiers */
#define PRI_mpd_uint_t PRIu32
#define PRI_mpd_ssize_t PRIi32
/* END CONFIG_32 */

#else
  #error "define CONFIG_64 or CONFIG_32"
#endif
/* END CONFIG */


#if MPD_SIZE_MAX != MPD_UINT_MAX
  #error "unsupported platform: need mpd_size_t == mpd_uint_t"
#endif


/******************************************************************************/
/*                                Context                                     */
/******************************************************************************/

enum {
    MPD_ROUND_UP,          /* round away from 0               */
    MPD_ROUND_DOWN,        /* round toward 0 (truncate)       */
    MPD_ROUND_CEILING,     /* round toward +infinity          */
    MPD_ROUND_FLOOR,       /* round toward -infinity          */
    MPD_ROUND_HALF_UP,     /* 0.5 is rounded up               */
    MPD_ROUND_HALF_DOWN,   /* 0.5 is rounded down             */
    MPD_ROUND_HALF_EVEN,   /* 0.5 is rounded to even          */
    MPD_ROUND_05UP,        /* round zero or five away from 0  */
    MPD_ROUND_TRUNC,       /* truncate, but set infinity      */
    MPD_ROUND_GUARD
};

enum { MPD_CLAMP_DEFAULT, MPD_CLAMP_IEEE_754, MPD_CLAMP_GUARD };

extern const char * const mpd_round_string[MPD_ROUND_GUARD];
extern const char * const mpd_clamp_string[MPD_CLAMP_GUARD];


typedef struct mpd_context_t {
    mpd_ssize_t prec;   /* precision */
    mpd_ssize_t emax;   /* max positive exp */
    mpd_ssize_t emin;   /* min negative exp */
    uint32_t traps;     /* status events that should be trapped */
    uint32_t status;    /* status flags */
    uint32_t newtrap;   /* set by mpd_addstatus_raise() */
    int      round;     /* rounding mode */
    int      clamp;     /* clamp mode */
    int      allcr;     /* all functions correctly rounded */
} mpd_context_t;


/* Status flags */
#define MPD_Clamped             0x00000001U
#define MPD_Conversion_syntax   0x00000002U
#define MPD_Division_by_zero    0x00000004U
#define MPD_Division_impossible 0x00000008U
#define MPD_Division_undefined  0x00000010U
#define MPD_Fpu_error           0x00000020U
#define MPD_Inexact             0x00000040U
#define MPD_Invalid_context     0x00000080U
#define MPD_Invalid_operation   0x00000100U
#define MPD_Malloc_error        0x00000200U
#define MPD_Not_implemented     0x00000400U
#define MPD_Overflow            0x00000800U
#define MPD_Rounded             0x00001000U
#define MPD_Subnormal           0x00002000U
#define MPD_Underflow           0x00004000U
#define MPD_Max_status         (0x00008000U-1U)

/* Conditions that result in an IEEE 754 exception */
#define MPD_IEEE_Invalid_operation (MPD_Conversion_syntax |   \
                                    MPD_Division_impossible | \
                                    MPD_Division_undefined |  \
                                    MPD_Fpu_error |           \
                                    MPD_Invalid_context |     \
                                    MPD_Invalid_operation |   \
                                    MPD_Malloc_error)         \

/* Errors that require the result of an operation to be set to NaN */
#define MPD_Errors (MPD_IEEE_Invalid_operation | \
                    MPD_Division_by_zero)

/* Default traps */
#define MPD_Traps (MPD_IEEE_Invalid_operation | \
                   MPD_Division_by_zero |       \
                   MPD_Overflow |               \
                   MPD_Underflow)

/* Official name */
#define MPD_Insufficient_storage MPD_Malloc_error

/* IEEE 754 interchange format contexts */
#define MPD_DECIMAL32 32
#define MPD_DECIMAL64 64
#define MPD_DECIMAL128 128


#define MPD_MINALLOC_MIN 2
#define MPD_MINALLOC_MAX 64
extern mpd_ssize_t MPD_MINALLOC;
extern void (* mpd_traphandler)(mpd_context_t *);
void mpd_dflt_traphandler(mpd_context_t *);

void mpd_setminalloc(mpd_ssize_t n);
void mpd_init(mpd_context_t *ctx, mpd_ssize_t prec);

void mpd_maxcontext(mpd_context_t *ctx);
void mpd_defaultcontext(mpd_context_t *ctx);
void mpd_basiccontext(mpd_context_t *ctx);
int mpd_ieee_context(mpd_context_t *ctx, int bits);

mpd_ssize_t mpd_getprec(const mpd_context_t *ctx);
mpd_ssize_t mpd_getemax(const mpd_context_t *ctx);
mpd_ssize_t mpd_getemin(const mpd_context_t *ctx);
int mpd_getround(const mpd_context_t *ctx);
uint32_t mpd_gettraps(const mpd_context_t *ctx);
uint32_t mpd_getstatus(const mpd_context_t *ctx);
int mpd_getclamp(const mpd_context_t *ctx);
int mpd_getcr(const mpd_context_t *ctx);

int mpd_qsetprec(mpd_context_t *ctx, mpd_ssize_t prec);
int mpd_qsetemax(mpd_context_t *ctx, mpd_ssize_t emax);
int mpd_qsetemin(mpd_context_t *ctx, mpd_ssize_t emin);
int mpd_qsetround(mpd_context_t *ctx, int newround);
int mpd_qsettraps(mpd_context_t *ctx, uint32_t flags);
int mpd_qsetstatus(mpd_context_t *ctx, uint32_t flags);
int mpd_qsetclamp(mpd_context_t *ctx, int c);
int mpd_qsetcr(mpd_context_t *ctx, int c);
void mpd_addstatus_raise(mpd_context_t *ctx, uint32_t flags);


/******************************************************************************/
/*                           Decimal Arithmetic                               */
/******************************************************************************/

/* mpd_t flags */
#define MPD_POS                 MPD_UINT8_C(0)
#define MPD_NEG                 MPD_UINT8_C(1)
#define MPD_INF                 MPD_UINT8_C(2)
#define MPD_NAN                 MPD_UINT8_C(4)
#define MPD_SNAN                MPD_UINT8_C(8)
#define MPD_SPECIAL (MPD_INF|MPD_NAN|MPD_SNAN)
#define MPD_STATIC              MPD_UINT8_C(16)
#define MPD_STATIC_DATA         MPD_UINT8_C(32)
#define MPD_SHARED_DATA         MPD_UINT8_C(64)
#define MPD_CONST_DATA          MPD_UINT8_C(128)
#define MPD_DATAFLAGS (MPD_STATIC_DATA|MPD_SHARED_DATA|MPD_CONST_DATA)

/* mpd_t */
typedef struct mpd_t {
    uint8_t flags;
    mpd_ssize_t exp;
    mpd_ssize_t digits;
    mpd_ssize_t len;
    mpd_ssize_t alloc;
    mpd_uint_t *data;
} mpd_t;


/******************************************************************************/
/*                                    Triple                                  */
/******************************************************************************/

/* status cases for getting a triple */
enum mpd_triple_class {
  MPD_TRIPLE_NORMAL,
  MPD_TRIPLE_INF,
  MPD_TRIPLE_QNAN,
  MPD_TRIPLE_SNAN,
  MPD_TRIPLE_ERROR,
};

typedef struct {
  enum mpd_triple_class tag;
  uint8_t sign;
  uint64_t hi;
  uint64_t lo;
  int64_t exp;
} mpd_uint128_triple_t;

int mpd_from_uint128_triple(mpd_t *result, const mpd_uint128_triple_t *triple, uint32_t *status);
mpd_uint128_triple_t mpd_as_uint128_triple(const mpd_t *a);


/******************************************************************************/
/*                       Quiet, thread-safe functions                         */
/******************************************************************************/

/* format specification */
typedef struct mpd_spec_t {
    mpd_ssize_t min_width; /* minimum field width */
    mpd_ssize_t prec;      /* fraction digits or significant digits */
    char type;             /* conversion specifier */
    char align;            /* alignment */
    char sign;             /* sign printing/alignment */
    char fill[5];          /* fill character */
    const char *dot;       /* decimal point */
    const char *sep;       /* thousands separator */
    const char *grouping;  /* grouping of digits */
} mpd_spec_t;

/* output to a string */
char *mpd_to_sci(const mpd_t *dec, int fmt);
char *mpd_to_eng(const mpd_t *dec, int fmt);
mpd_ssize_t mpd_to_sci_size(char **res, const mpd_t *dec, int fmt);
mpd_ssize_t mpd_to_eng_size(char **res, const mpd_t *dec, int fmt);
int mpd_validate_lconv(mpd_spec_t *spec);
int mpd_parse_fmt_str(mpd_spec_t *spec, const char *fmt, int caps);
char *mpd_qformat_spec(const mpd_t *dec, const mpd_spec_t *spec, const mpd_context_t *ctx, uint32_t *status);
char *mpd_qformat(const mpd_t *dec, const char *fmt, const mpd_context_t *ctx, uint32_t *status);

#define MPD_NUM_FLAGS 15
#define MPD_MAX_FLAG_STRING 208
#define MPD_MAX_FLAG_LIST (MPD_MAX_FLAG_STRING+18)
#define MPD_MAX_SIGNAL_LIST 121
int mpd_snprint_flags(char *dest, int nmemb, uint32_t flags);
int mpd_lsnprint_flags(char *dest, int nmemb, uint32_t flags, const char *flag_string[]);
int mpd_lsnprint_signals(char *dest, int nmemb, uint32_t flags, const char *signal_string[]);

/* output to a file */
void mpd_fprint(FILE *file, const mpd_t *dec);
void mpd_print(const mpd_t *dec);

/* assignment from a string */
void mpd_qset_string(mpd_t *dec, const char *s, const mpd_context_t *ctx, uint32_t *status);
void mpd_qset_string_exact(mpd_t *dec, const char *s, uint32_t *status);

/* set to NaN with error flags */
void mpd_seterror(mpd_t *result, uint32_t flags, uint32_t *status);
/* set a special with sign and type */
void mpd_setspecial(mpd_t *result, uint8_t sign, uint8_t type);
/* set coefficient to zero or all nines */
void mpd_zerocoeff(mpd_t *result);
void mpd_qmaxcoeff(mpd_t *result, const mpd_context_t *ctx, uint32_t *status);

/* quietly assign a C integer type to an mpd_t */
void mpd_qset_ssize(mpd_t *result, mpd_ssize_t a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qset_i32(mpd_t *result, int32_t a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qset_uint(mpd_t *result, mpd_uint_t a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qset_u32(mpd_t *result, uint32_t a, const mpd_context_t *ctx, uint32_t *status);
#ifndef LEGACY_COMPILER
void mpd_qset_i64(mpd_t *result, int64_t a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qset_u64(mpd_t *result, uint64_t a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qset_i64_exact(mpd_t *result, int64_t a, uint32_t *status);
void mpd_qset_u64_exact(mpd_t *result, uint64_t a, uint32_t *status);
#endif

/* quietly assign a C integer type to an mpd_t with a static coefficient */
void mpd_qsset_ssize(mpd_t *result, mpd_ssize_t a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qsset_i32(mpd_t *result, int32_t a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qsset_uint(mpd_t *result, mpd_uint_t a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qsset_u32(mpd_t *result, uint32_t a, const mpd_context_t *ctx, uint32_t *status);

/* quietly get a C integer type from an mpd_t */
mpd_ssize_t mpd_qget_ssize(const mpd_t *dec, uint32_t *status);
mpd_uint_t mpd_qget_uint(const mpd_t *dec, uint32_t *status);
mpd_uint_t mpd_qabs_uint(const mpd_t *dec, uint32_t *status);

int32_t mpd_qget_i32(const mpd_t *dec, uint32_t *status);
uint32_t mpd_qget_u32(const mpd_t *dec, uint32_t *status);
#ifndef LEGACY_COMPILER
int64_t mpd_qget_i64(const mpd_t *dec, uint32_t *status);
uint64_t mpd_qget_u64(const mpd_t *dec, uint32_t *status);
#endif

/* quiet functions */
int mpd_qcheck_nan(mpd_t *nanresult, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
int mpd_qcheck_nans(mpd_t *nanresult, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qfinalize(mpd_t *result, const mpd_context_t *ctx, uint32_t *status);

const char *mpd_class(const mpd_t *a, const mpd_context_t *ctx);

int mpd_qcopy(mpd_t *result, const mpd_t *a, uint32_t *status);
int mpd_qcopy_cxx(mpd_t *result, const mpd_t *a);
mpd_t *mpd_qncopy(const mpd_t *a);
int mpd_qcopy_abs(mpd_t *result, const mpd_t *a, uint32_t *status);
int mpd_qcopy_negate(mpd_t *result, const mpd_t *a, uint32_t *status);
int mpd_qcopy_sign(mpd_t *result, const mpd_t *a, const mpd_t *b, uint32_t *status);

void mpd_qand(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qinvert(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qlogb(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qor(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qscaleb(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qxor(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
int mpd_same_quantum(const mpd_t *a, const mpd_t *b);

void mpd_qrotate(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
int mpd_qshiftl(mpd_t *result, const mpd_t *a, mpd_ssize_t n, uint32_t *status);
mpd_uint_t mpd_qshiftr(mpd_t *result, const mpd_t *a, mpd_ssize_t n, uint32_t *status);
mpd_uint_t mpd_qshiftr_inplace(mpd_t *result, mpd_ssize_t n);
void mpd_qshift(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qshiftn(mpd_t *result, const mpd_t *a, mpd_ssize_t n, const mpd_context_t *ctx, uint32_t *status);

int mpd_qcmp(const mpd_t *a, const mpd_t *b, uint32_t *status);
int mpd_qcompare(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
int mpd_qcompare_signal(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
int mpd_cmp_total(const mpd_t *a, const mpd_t *b);
int mpd_cmp_total_mag(const mpd_t *a, const mpd_t *b);
int mpd_compare_total(mpd_t *result, const mpd_t *a, const mpd_t *b);
int mpd_compare_total_mag(mpd_t *result, const mpd_t *a, const mpd_t *b);

void mpd_qround_to_intx(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qround_to_int(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qtrunc(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qfloor(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qceil(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);

void mpd_qabs(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qmax(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qmax_mag(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qmin(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qmin_mag(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qminus(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qplus(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qnext_minus(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qnext_plus(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qnext_toward(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qquantize(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qrescale(mpd_t *result, const mpd_t *a, mpd_ssize_t exp, const mpd_context_t *ctx, uint32_t *status);
void mpd_qrescale_fmt(mpd_t *result, const mpd_t *a, mpd_ssize_t exp, const mpd_context_t *ctx, uint32_t *status);
void mpd_qreduce(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qadd(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qadd_ssize(mpd_t *result, const mpd_t *a, mpd_ssize_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qadd_i32(mpd_t *result, const mpd_t *a, int32_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qadd_uint(mpd_t *result, const mpd_t *a, mpd_uint_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qadd_u32(mpd_t *result, const mpd_t *a, uint32_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qsub(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qsub_ssize(mpd_t *result, const mpd_t *a, mpd_ssize_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qsub_i32(mpd_t *result, const mpd_t *a, int32_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qsub_uint(mpd_t *result, const mpd_t *a, mpd_uint_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qsub_u32(mpd_t *result, const mpd_t *a, uint32_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qmul(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qmul_ssize(mpd_t *result, const mpd_t *a, mpd_ssize_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qmul_i32(mpd_t *result, const mpd_t *a, int32_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qmul_uint(mpd_t *result, const mpd_t *a, mpd_uint_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qmul_u32(mpd_t *result, const mpd_t *a, uint32_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qfma(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_t *c, const mpd_context_t *ctx, uint32_t *status);
void mpd_qdiv(mpd_t *q, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qdiv_ssize(mpd_t *result, const mpd_t *a, mpd_ssize_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qdiv_i32(mpd_t *result, const mpd_t *a, int32_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qdiv_uint(mpd_t *result, const mpd_t *a, mpd_uint_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qdiv_u32(mpd_t *result, const mpd_t *a, uint32_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qdivint(mpd_t *q, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qrem(mpd_t *r, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qrem_near(mpd_t *r, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qdivmod(mpd_t *q, mpd_t *r, const mpd_t *a, const mpd_t *b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qpow(mpd_t *result, const mpd_t *base, const mpd_t *exp, const mpd_context_t *ctx, uint32_t *status);
void mpd_qpowmod(mpd_t *result, const mpd_t *base, const mpd_t *exp, const mpd_t *mod, const mpd_context_t *ctx, uint32_t *status);
void mpd_qexp(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qln10(mpd_t *result, mpd_ssize_t prec, uint32_t *status);
void mpd_qln(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qlog10(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qsqrt(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qinvroot(mpd_t *result, const mpd_t *a, const mpd_context_t *ctx, uint32_t *status);

#ifndef LEGACY_COMPILER
void mpd_qadd_i64(mpd_t *result, const mpd_t *a, int64_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qadd_u64(mpd_t *result, const mpd_t *a, uint64_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qsub_i64(mpd_t *result, const mpd_t *a, int64_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qsub_u64(mpd_t *result, const mpd_t *a, uint64_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qmul_i64(mpd_t *result, const mpd_t *a, int64_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qmul_u64(mpd_t *result, const mpd_t *a, uint64_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qdiv_i64(mpd_t *result, const mpd_t *a, int64_t b, const mpd_context_t *ctx, uint32_t *status);
void mpd_qdiv_u64(mpd_t *result, const mpd_t *a, uint64_t b, const mpd_context_t *ctx, uint32_t *status);
#endif


size_t mpd_sizeinbase(const mpd_t *a, uint32_t base);
void mpd_qimport_u16(mpd_t *result, const uint16_t *srcdata, size_t srclen,
                     uint8_t srcsign, uint32_t srcbase,
                     const mpd_context_t *ctx, uint32_t *status);
void mpd_qimport_u32(mpd_t *result, const uint32_t *srcdata, size_t srclen,
                     uint8_t srcsign, uint32_t srcbase,
                     const mpd_context_t *ctx, uint32_t *status);
size_t mpd_qexport_u16(uint16_t **rdata, size_t rlen, uint32_t base,
                       const mpd_t *src, uint32_t *status);
size_t mpd_qexport_u32(uint32_t **rdata, size_t rlen, uint32_t base,
                       const mpd_t *src, uint32_t *status);


/******************************************************************************/
/*                           Signalling functions                             */
/******************************************************************************/

char *mpd_format(const mpd_t *dec, const char *fmt, mpd_context_t *ctx);
void mpd_import_u16(mpd_t *result, const uint16_t *srcdata, size_t srclen, uint8_t srcsign, uint32_t base, mpd_context_t *ctx);
void mpd_import_u32(mpd_t *result, const uint32_t *srcdata, size_t srclen, uint8_t srcsign, uint32_t base, mpd_context_t *ctx);
size_t mpd_export_u16(uint16_t **rdata, size_t rlen, uint32_t base, const mpd_t *src, mpd_context_t *ctx);
size_t mpd_export_u32(uint32_t **rdata, size_t rlen, uint32_t base, const mpd_t *src, mpd_context_t *ctx);
void mpd_finalize(mpd_t *result, mpd_context_t *ctx);
int mpd_check_nan(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
int mpd_check_nans(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_set_string(mpd_t *result, const char *s, mpd_context_t *ctx);
void mpd_maxcoeff(mpd_t *result, mpd_context_t *ctx);
void mpd_sset_ssize(mpd_t *result, mpd_ssize_t a, mpd_context_t *ctx);
void mpd_sset_i32(mpd_t *result, int32_t a, mpd_context_t *ctx);
void mpd_sset_uint(mpd_t *result, mpd_uint_t a, mpd_context_t *ctx);
void mpd_sset_u32(mpd_t *result, uint32_t a, mpd_context_t *ctx);
void mpd_set_ssize(mpd_t *result, mpd_ssize_t a, mpd_context_t *ctx);
void mpd_set_i32(mpd_t *result, int32_t a, mpd_context_t *ctx);
void mpd_set_uint(mpd_t *result, mpd_uint_t a, mpd_context_t *ctx);
void mpd_set_u32(mpd_t *result, uint32_t a, mpd_context_t *ctx);
#ifndef LEGACY_COMPILER
void mpd_set_i64(mpd_t *result, int64_t a, mpd_context_t *ctx);
void mpd_set_u64(mpd_t *result, uint64_t a, mpd_context_t *ctx);
#endif
mpd_ssize_t mpd_get_ssize(const mpd_t *a, mpd_context_t *ctx);
mpd_uint_t mpd_get_uint(const mpd_t *a, mpd_context_t *ctx);
mpd_uint_t mpd_abs_uint(const mpd_t *a, mpd_context_t *ctx);
int32_t mpd_get_i32(const mpd_t *a, mpd_context_t *ctx);
uint32_t mpd_get_u32(const mpd_t *a, mpd_context_t *ctx);
#ifndef LEGACY_COMPILER
int64_t mpd_get_i64(const mpd_t *a, mpd_context_t *ctx);
uint64_t mpd_get_u64(const mpd_t *a, mpd_context_t *ctx);
#endif
void mpd_and(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_copy(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_canonical(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_copy_abs(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_copy_negate(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_copy_sign(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_invert(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_logb(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_or(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_rotate(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_scaleb(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_shiftl(mpd_t *result, const mpd_t *a, mpd_ssize_t n, mpd_context_t *ctx);
mpd_uint_t mpd_shiftr(mpd_t *result, const mpd_t *a, mpd_ssize_t n, mpd_context_t *ctx);
void mpd_shiftn(mpd_t *result, const mpd_t *a, mpd_ssize_t n, mpd_context_t *ctx);
void mpd_shift(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_xor(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_abs(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
int mpd_cmp(const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
int mpd_compare(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
int mpd_compare_signal(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_add(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_add_ssize(mpd_t *result, const mpd_t *a, mpd_ssize_t b, mpd_context_t *ctx);
void mpd_add_i32(mpd_t *result, const mpd_t *a, int32_t b, mpd_context_t *ctx);
void mpd_add_uint(mpd_t *result, const mpd_t *a, mpd_uint_t b, mpd_context_t *ctx);
void mpd_add_u32(mpd_t *result, const mpd_t *a, uint32_t b, mpd_context_t *ctx);
void mpd_sub(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_sub_ssize(mpd_t *result, const mpd_t *a, mpd_ssize_t b, mpd_context_t *ctx);
void mpd_sub_i32(mpd_t *result, const mpd_t *a, int32_t b, mpd_context_t *ctx);
void mpd_sub_uint(mpd_t *result, const mpd_t *a, mpd_uint_t b, mpd_context_t *ctx);
void mpd_sub_u32(mpd_t *result, const mpd_t *a, uint32_t b, mpd_context_t *ctx);
void mpd_div(mpd_t *q, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_div_ssize(mpd_t *result, const mpd_t *a, mpd_ssize_t b, mpd_context_t *ctx);
void mpd_div_i32(mpd_t *result, const mpd_t *a, int32_t b, mpd_context_t *ctx);
void mpd_div_uint(mpd_t *result, const mpd_t *a, mpd_uint_t b, mpd_context_t *ctx);
void mpd_div_u32(mpd_t *result, const mpd_t *a, uint32_t b, mpd_context_t *ctx);
void mpd_divmod(mpd_t *q, mpd_t *r, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_divint(mpd_t *q, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_exp(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_fma(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_t *c, mpd_context_t *ctx);
void mpd_ln(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_log10(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_max(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_max_mag(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_min(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_min_mag(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_minus(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_mul(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_mul_ssize(mpd_t *result, const mpd_t *a, mpd_ssize_t b, mpd_context_t *ctx);
void mpd_mul_i32(mpd_t *result, const mpd_t *a, int32_t b, mpd_context_t *ctx);
void mpd_mul_uint(mpd_t *result, const mpd_t *a, mpd_uint_t b, mpd_context_t *ctx);
void mpd_mul_u32(mpd_t *result, const mpd_t *a, uint32_t b, mpd_context_t *ctx);
void mpd_next_minus(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_next_plus(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_next_toward(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_plus(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_pow(mpd_t *result, const mpd_t *base, const mpd_t *exp, mpd_context_t *ctx);
void mpd_powmod(mpd_t *result, const mpd_t *base, const mpd_t *exp, const mpd_t *mod, mpd_context_t *ctx);
void mpd_quantize(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_rescale(mpd_t *result, const mpd_t *a, mpd_ssize_t exp, mpd_context_t *ctx);
void mpd_reduce(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_rem(mpd_t *r, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_rem_near(mpd_t *r, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx);
void mpd_round_to_intx(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_round_to_int(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_trunc(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_floor(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_ceil(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_sqrt(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);
void mpd_invroot(mpd_t *result, const mpd_t *a, mpd_context_t *ctx);

#ifndef LEGACY_COMPILER
void mpd_add_i64(mpd_t *result, const mpd_t *a, int64_t b, mpd_context_t *ctx);
void mpd_add_u64(mpd_t *result, const mpd_t *a, uint64_t b, mpd_context_t *ctx);
void mpd_sub_i64(mpd_t *result, const mpd_t *a, int64_t b, mpd_context_t *ctx);
void mpd_sub_u64(mpd_t *result, const mpd_t *a, uint64_t b, mpd_context_t *ctx);
void mpd_div_i64(mpd_t *result, const mpd_t *a, int64_t b, mpd_context_t *ctx);
void mpd_div_u64(mpd_t *result, const mpd_t *a, uint64_t b, mpd_context_t *ctx);
void mpd_mul_i64(mpd_t *result, const mpd_t *a, int64_t b, mpd_context_t *ctx);
void mpd_mul_u64(mpd_t *result, const mpd_t *a, uint64_t b, mpd_context_t *ctx);
#endif


/******************************************************************************/
/*                          Configuration specific                            */
/******************************************************************************/

#ifdef CONFIG_64
void mpd_qsset_i64(mpd_t *result, int64_t a, const mpd_context_t *ctx, uint32_t *status);
void mpd_qsset_u64(mpd_t *result, uint64_t a, const mpd_context_t *ctx, uint32_t *status);
void mpd_sset_i64(mpd_t *result, int64_t a, mpd_context_t *ctx);
void mpd_sset_u64(mpd_t *result, uint64_t a, mpd_context_t *ctx);
#endif


/******************************************************************************/
/*                       Get attributes of a decimal                          */
/******************************************************************************/

EXTINLINE mpd_ssize_t mpd_adjexp(const mpd_t *dec);
EXTINLINE mpd_ssize_t mpd_etiny(const mpd_context_t *ctx);
EXTINLINE mpd_ssize_t mpd_etop(const mpd_context_t *ctx);
EXTINLINE mpd_uint_t mpd_msword(const mpd_t *dec);
EXTINLINE int mpd_word_digits(mpd_uint_t word);
/* most significant digit of a word */
EXTINLINE mpd_uint_t mpd_msd(mpd_uint_t word);
/* least significant digit of a word */
EXTINLINE mpd_uint_t mpd_lsd(mpd_uint_t word);
/* coefficient size needed to store 'digits' */
EXTINLINE mpd_ssize_t mpd_digits_to_size(mpd_ssize_t digits);
/* number of digits in the exponent, undefined for MPD_SSIZE_MIN */
EXTINLINE int mpd_exp_digits(mpd_ssize_t exp);
EXTINLINE int mpd_iscanonical(const mpd_t *dec);
EXTINLINE int mpd_isfinite(const mpd_t *dec);
EXTINLINE int mpd_isinfinite(const mpd_t *dec);
EXTINLINE int mpd_isinteger(const mpd_t *dec);
EXTINLINE int mpd_isnan(const mpd_t *dec);
EXTINLINE int mpd_isnegative(const mpd_t *dec);
EXTINLINE int mpd_ispositive(const mpd_t *dec);
EXTINLINE int mpd_isqnan(const mpd_t *dec);
EXTINLINE int mpd_issigned(const mpd_t *dec);
EXTINLINE int mpd_issnan(const mpd_t *dec);
EXTINLINE int mpd_isspecial(const mpd_t *dec);
EXTINLINE int mpd_iszero(const mpd_t *dec);
/* undefined for special numbers */
EXTINLINE int mpd_iszerocoeff(const mpd_t *dec);
EXTINLINE int mpd_isnormal(const mpd_t *dec, const mpd_context_t *ctx);
EXTINLINE int mpd_issubnormal(const mpd_t *dec, const mpd_context_t *ctx);
/* odd word */
EXTINLINE int mpd_isoddword(mpd_uint_t word);
/* odd coefficient */
EXTINLINE int mpd_isoddcoeff(const mpd_t *dec);
/* odd decimal, only defined for integers */
int mpd_isodd(const mpd_t *dec);
/* even decimal, only defined for integers */
int mpd_iseven(const mpd_t *dec);
/* 0 if dec is positive, 1 if dec is negative */
EXTINLINE uint8_t mpd_sign(const mpd_t *dec);
/* 1 if dec is positive, -1 if dec is negative */
EXTINLINE int mpd_arith_sign(const mpd_t *dec);
EXTINLINE long mpd_radix(void);
EXTINLINE int mpd_isdynamic(const mpd_t *dec);
EXTINLINE int mpd_isstatic(const mpd_t *dec);
EXTINLINE int mpd_isdynamic_data(const mpd_t *dec);
EXTINLINE int mpd_isstatic_data(const mpd_t *dec);
EXTINLINE int mpd_isshared_data(const mpd_t *dec);
EXTINLINE int mpd_isconst_data(const mpd_t *dec);
EXTINLINE mpd_ssize_t mpd_trail_zeros(const mpd_t *dec);


/******************************************************************************/
/*                       Set attributes of a decimal                          */
/******************************************************************************/

/* set number of decimal digits in the coefficient */
EXTINLINE void mpd_setdigits(mpd_t *result);
EXTINLINE void mpd_set_sign(mpd_t *result, uint8_t sign);
/* copy sign from another decimal */
EXTINLINE void mpd_signcpy(mpd_t *result, const mpd_t *a);
EXTINLINE void mpd_set_infinity(mpd_t *result);
EXTINLINE void mpd_set_qnan(mpd_t *result);
EXTINLINE void mpd_set_snan(mpd_t *result);
EXTINLINE void mpd_set_negative(mpd_t *result);
EXTINLINE void mpd_set_positive(mpd_t *result);
EXTINLINE void mpd_set_dynamic(mpd_t *result);
EXTINLINE void mpd_set_static(mpd_t *result);
EXTINLINE void mpd_set_dynamic_data(mpd_t *result);
EXTINLINE void mpd_set_static_data(mpd_t *result);
EXTINLINE void mpd_set_shared_data(mpd_t *result);
EXTINLINE void mpd_set_const_data(mpd_t *result);
EXTINLINE void mpd_clear_flags(mpd_t *result);
EXTINLINE void mpd_set_flags(mpd_t *result, uint8_t flags);
EXTINLINE void mpd_copy_flags(mpd_t *result, const mpd_t *a);


/******************************************************************************/
/*                              Error Macros                                  */
/******************************************************************************/

#define mpd_err_fatal(...) \
    do {fprintf(stderr, "%s:%d: error: ", __FILE__, __LINE__); \
        fprintf(stderr, __VA_ARGS__);  fputc('\n', stderr);    \
        abort();                                               \
    } while (0)
#define mpd_err_warn(...) \
    do {fprintf(stderr, "%s:%d: warning: ", __FILE__, __LINE__); \
        fprintf(stderr, __VA_ARGS__); fputc('\n', stderr);       \
    } while (0)


/******************************************************************************/
/*                            Memory handling                                 */
/******************************************************************************/

extern void *(* mpd_mallocfunc)(size_t size);
extern void *(* mpd_callocfunc)(size_t nmemb, size_t size);
extern void *(* mpd_reallocfunc)(void *ptr, size_t size);
extern void (* mpd_free)(void *ptr);

void *mpd_callocfunc_em(size_t nmemb, size_t size);

void *mpd_alloc(mpd_size_t nmemb, mpd_size_t size);
void *mpd_calloc(mpd_size_t nmemb, mpd_size_t size);
void *mpd_realloc(void *ptr, mpd_size_t nmemb, mpd_size_t size, uint8_t *err);
void *mpd_sh_alloc(mpd_size_t struct_size, mpd_size_t nmemb, mpd_size_t size);

mpd_t *mpd_qnew(void);
mpd_t *mpd_new(mpd_context_t *ctx);
mpd_t *mpd_qnew_size(mpd_ssize_t nwords);
EXTINLINE void mpd_del(mpd_t *dec);

EXTINLINE void mpd_uint_zero(mpd_uint_t *dest, mpd_size_t len);
EXTINLINE int mpd_qresize(mpd_t *result, mpd_ssize_t nwords, uint32_t *status);
EXTINLINE int mpd_qresize_zero(mpd_t *result, mpd_ssize_t nwords, uint32_t *status);
EXTINLINE void mpd_minalloc(mpd_t *result);

int mpd_resize(mpd_t *result, mpd_ssize_t nwords, mpd_context_t *ctx);
int mpd_resize_zero(mpd_t *result, mpd_ssize_t nwords, mpd_context_t *ctx);


MPD_PRAGMA(MPD_HIDE_SYMBOLS_END) /* restore previous scope rules */


#ifdef __cplusplus
} /* END extern "C" */
#endif


#endif /* LIBMPDEC_MPDECIMAL_H_ */


================================================
File: /Modules/_decimal/libmpdec/mpsignal.c
================================================
/*
 * Copyright (c) 2008-2020 Stefan Krah. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */


#include "mpdecimal.h"

#include <stddef.h>
#include <stdint.h>


/* Signaling wrappers for the quiet functions in mpdecimal.c. */


char *
mpd_format(const mpd_t *dec, const char *fmt, mpd_context_t *ctx)
{
    char *ret;
    uint32_t status = 0;
    ret = mpd_qformat(dec, fmt, ctx, &status);
    mpd_addstatus_raise(ctx, status);
    return ret;
}

void
mpd_import_u16(mpd_t *result, const uint16_t *srcdata, size_t srclen,
               uint8_t srcsign, uint32_t base, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qimport_u16(result, srcdata, srclen, srcsign, base, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_import_u32(mpd_t *result, const uint32_t *srcdata, size_t srclen,
               uint8_t srcsign, uint32_t base, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qimport_u32(result, srcdata, srclen, srcsign, base, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

size_t
mpd_export_u16(uint16_t **rdata, size_t rlen, uint32_t base, const mpd_t *src,
               mpd_context_t *ctx)
{
    size_t n;
    uint32_t status = 0;
    n = mpd_qexport_u16(rdata, rlen, base, src, &status);
    mpd_addstatus_raise(ctx, status);
    return n;
}

size_t
mpd_export_u32(uint32_t **rdata, size_t rlen, uint32_t base, const mpd_t *src,
               mpd_context_t *ctx)
{
    size_t n;
    uint32_t status = 0;
    n = mpd_qexport_u32(rdata, rlen, base, src, &status);
    mpd_addstatus_raise(ctx, status);
    return n;
}

void
mpd_finalize(mpd_t *result, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qfinalize(result, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

int
mpd_check_nan(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    if (mpd_qcheck_nan(result, a, ctx, &status)) {
        mpd_addstatus_raise(ctx, status);
        return 1;
    }
    return 0;
}

int
mpd_check_nans(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    if (mpd_qcheck_nans(result, a, b, ctx, &status)) {
        mpd_addstatus_raise(ctx, status);
        return 1;
    }
    return 0;
}

void
mpd_set_string(mpd_t *result, const char *s, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qset_string(result, s, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_maxcoeff(mpd_t *result, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qmaxcoeff(result, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

/* set static mpd from signed integer */
void
mpd_sset_ssize(mpd_t *result, mpd_ssize_t a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsset_ssize(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_sset_i32(mpd_t *result, int32_t a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsset_i32(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

#ifdef CONFIG_64
void
mpd_sset_i64(mpd_t *result, int64_t a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsset_i64(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
#endif

/* set static mpd from unsigned integer */
void
mpd_sset_uint(mpd_t *result, mpd_uint_t a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsset_uint(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_sset_u32(mpd_t *result, uint32_t a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsset_u32(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

#ifdef CONFIG_64
void
mpd_sset_u64(mpd_t *result, uint64_t a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsset_u64(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
#endif

/* set mpd from signed integer */
void
mpd_set_ssize(mpd_t *result, mpd_ssize_t a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qset_ssize(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_set_i32(mpd_t *result, int32_t a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qset_i32(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

#ifndef LEGACY_COMPILER
void
mpd_set_i64(mpd_t *result, int64_t a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qset_i64(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
#endif

/* set mpd from unsigned integer */
void
mpd_set_uint(mpd_t *result, mpd_uint_t a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qset_uint(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_set_u32(mpd_t *result, uint32_t a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qset_u32(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

#ifndef LEGACY_COMPILER
void
mpd_set_u64(mpd_t *result, uint64_t a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qset_u64(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
#endif

/* convert mpd to signed integer */
mpd_ssize_t
mpd_get_ssize(const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_ssize_t ret;

    ret = mpd_qget_ssize(a, &status);
    mpd_addstatus_raise(ctx, status);
    return ret;
}

int32_t
mpd_get_i32(const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    int32_t ret;

    ret = mpd_qget_i32(a, &status);
    mpd_addstatus_raise(ctx, status);
    return ret;
}

#ifndef LEGACY_COMPILER
int64_t
mpd_get_i64(const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    int64_t ret;

    ret = mpd_qget_i64(a, &status);
    mpd_addstatus_raise(ctx, status);
    return ret;
}
#endif

mpd_uint_t
mpd_get_uint(const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_uint_t ret;

    ret = mpd_qget_uint(a, &status);
    mpd_addstatus_raise(ctx, status);
    return ret;
}

mpd_uint_t
mpd_abs_uint(const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_uint_t ret;

    ret = mpd_qabs_uint(a, &status);
    mpd_addstatus_raise(ctx, status);
    return ret;
}

uint32_t
mpd_get_u32(const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    uint32_t ret;

    ret = mpd_qget_u32(a, &status);
    mpd_addstatus_raise(ctx, status);
    return ret;
}

#ifndef LEGACY_COMPILER
uint64_t
mpd_get_u64(const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    uint64_t ret;

    ret = mpd_qget_u64(a, &status);
    mpd_addstatus_raise(ctx, status);
    return ret;
}
#endif

void
mpd_and(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qand(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_copy(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    if (!mpd_qcopy(result, a, &status)) {
        mpd_addstatus_raise(ctx, status);
    }
}

void
mpd_canonical(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    mpd_copy(result, a, ctx);
}

void
mpd_copy_abs(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    if (!mpd_qcopy_abs(result, a, &status)) {
        mpd_addstatus_raise(ctx, status);
    }
}

void
mpd_copy_negate(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    if (!mpd_qcopy_negate(result, a, &status)) {
        mpd_addstatus_raise(ctx, status);
    }
}

void
mpd_copy_sign(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    if (!mpd_qcopy_sign(result, a, b, &status)) {
        mpd_addstatus_raise(ctx, status);
    }
}

void
mpd_invert(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qinvert(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_logb(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qlogb(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_or(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qor(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_rotate(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qrotate(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_scaleb(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qscaleb(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_shiftl(mpd_t *result, const mpd_t *a, mpd_ssize_t n, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qshiftl(result, a, n, &status);
    mpd_addstatus_raise(ctx, status);
}

mpd_uint_t
mpd_shiftr(mpd_t *result, const mpd_t *a, mpd_ssize_t n, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_uint_t rnd;

    rnd = mpd_qshiftr(result, a, n, &status);
    mpd_addstatus_raise(ctx, status);
    return rnd;
}

void
mpd_shiftn(mpd_t *result, const mpd_t *a, mpd_ssize_t n, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qshiftn(result, a, n, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_shift(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qshift(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_xor(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qxor(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_abs(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qabs(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

int
mpd_cmp(const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    int c;
    c = mpd_qcmp(a, b, &status);
    mpd_addstatus_raise(ctx, status);
    return c;
}

int
mpd_compare(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    int c;
    c = mpd_qcompare(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
    return c;
}

int
mpd_compare_signal(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    int c;
    c = mpd_qcompare_signal(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
    return c;
}

void
mpd_add(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qadd(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_sub(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsub(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_add_ssize(mpd_t *result, const mpd_t *a, mpd_ssize_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qadd_ssize(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_add_i32(mpd_t *result, const mpd_t *a, int32_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qadd_i32(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

#ifndef LEGACY_COMPILER
void
mpd_add_i64(mpd_t *result, const mpd_t *a, int64_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qadd_i64(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
#endif

void
mpd_add_uint(mpd_t *result, const mpd_t *a, mpd_uint_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qadd_uint(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_add_u32(mpd_t *result, const mpd_t *a, uint32_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qadd_u32(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

#ifndef LEGACY_COMPILER
void
mpd_add_u64(mpd_t *result, const mpd_t *a, uint64_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qadd_u64(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
#endif

void
mpd_sub_ssize(mpd_t *result, const mpd_t *a, mpd_ssize_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsub_ssize(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_sub_i32(mpd_t *result, const mpd_t *a, int32_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsub_i32(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

#ifndef LEGACY_COMPILER
void
mpd_sub_i64(mpd_t *result, const mpd_t *a, int64_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsub_i64(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
#endif

void
mpd_sub_uint(mpd_t *result, const mpd_t *a, mpd_uint_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsub_uint(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_sub_u32(mpd_t *result, const mpd_t *a, uint32_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsub_u32(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

#ifndef LEGACY_COMPILER
void
mpd_sub_u64(mpd_t *result, const mpd_t *a, uint64_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qsub_u64(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
#endif

void
mpd_div(mpd_t *q, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qdiv(q, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_div_ssize(mpd_t *result, const mpd_t *a, mpd_ssize_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qdiv_ssize(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_div_i32(mpd_t *result, const mpd_t *a, int32_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qdiv_i32(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

#ifndef LEGACY_COMPILER
void
mpd_div_i64(mpd_t *result, const mpd_t *a, int64_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qdiv_i64(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
#endif

void
mpd_div_uint(mpd_t *result, const mpd_t *a, mpd_uint_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qdiv_uint(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_div_u32(mpd_t *result, const mpd_t *a, uint32_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qdiv_u32(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

#ifndef LEGACY_COMPILER
void
mpd_div_u64(mpd_t *result, const mpd_t *a, uint64_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qdiv_u64(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
#endif

void
mpd_divmod(mpd_t *q, mpd_t *r, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qdivmod(q, r, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_divint(mpd_t *q, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qdivint(q, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_exp(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qexp(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_fma(mpd_t *result, const mpd_t *a, const mpd_t *b, const mpd_t *c,
        mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qfma(result, a, b, c, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_ln(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qln(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_log10(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qlog10(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_max(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qmax(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_max_mag(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qmax_mag(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_min(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qmin(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_min_mag(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qmin_mag(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_minus(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qminus(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_mul(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qmul(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_mul_ssize(mpd_t *result, const mpd_t *a, mpd_ssize_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qmul_ssize(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_mul_i32(mpd_t *result, const mpd_t *a, int32_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qmul_i32(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

#ifndef LEGACY_COMPILER
void
mpd_mul_i64(mpd_t *result, const mpd_t *a, int64_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qmul_i64(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
#endif

void
mpd_mul_uint(mpd_t *result, const mpd_t *a, mpd_uint_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qmul_uint(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_mul_u32(mpd_t *result, const mpd_t *a, uint32_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qmul_u32(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

#ifndef LEGACY_COMPILER
void
mpd_mul_u64(mpd_t *result, const mpd_t *a, uint64_t b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qmul_u64(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
#endif

void
mpd_next_minus(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qnext_minus(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_next_plus(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qnext_plus(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_next_toward(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qnext_toward(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_plus(mpd_t *result, const mpd_t *a, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qplus(result, a, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_pow(mpd_t *result, const mpd_t *base, const mpd_t *exp, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qpow(result, base, exp, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_powmod(mpd_t *result, const mpd_t *base, const mpd_t *exp, const mpd_t *mod,
           mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qpowmod(result, base, exp, mod, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_quantize(mpd_t *result, const mpd_t *a, const mpd_t *b, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qquantize(result, a, b, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}

void
mpd_rescale(mpd_t *result, const mpd_t *a, mpd_ssize_t exp, mpd_context_t *ctx)
{
    uint32_t status = 0;
    mpd_qrescale(result, a, exp, ctx, &status);
    mpd_addstatus_raise(ctx, status);
}
