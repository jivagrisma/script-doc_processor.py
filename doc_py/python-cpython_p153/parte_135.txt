            PyErr_SetString(PyExc_ValueError, "cannot switch from "
                            "automatic field numbering to "
                            "manual field specification");
            return 1;
        }
    }
    return 0;
}


/************************************************************************/
/***********  Format string parsing -- integers and identifiers *********/
/************************************************************************/

static Py_ssize_t
get_integer(const SubString *str)
{
    Py_ssize_t accumulator = 0;
    Py_ssize_t digitval;
    Py_ssize_t i;

    /* empty string is an error */
    if (str->start >= str->end)
        return -1;

    for (i = str->start; i < str->end; i++) {
        digitval = Py_UNICODE_TODECIMAL(PyUnicode_READ_CHAR(str->str, i));
        if (digitval < 0)
            return -1;
        /*
           Detect possible overflow before it happens:

              accumulator * 10 + digitval > PY_SSIZE_T_MAX if and only if
              accumulator > (PY_SSIZE_T_MAX - digitval) / 10.
        */
        if (accumulator > (PY_SSIZE_T_MAX - digitval) / 10) {
            PyErr_Format(PyExc_ValueError,
                         "Too many decimal digits in format string");
            return -1;
        }
        accumulator = accumulator * 10 + digitval;
    }
    return accumulator;
}

/************************************************************************/
/******** Functions to get field objects and specification strings ******/
/************************************************************************/

/* do the equivalent of obj.name */
static PyObject *
getattr(PyObject *obj, SubString *name)
{
    PyObject *newobj;
    PyObject *str = SubString_new_object(name);
    if (str == NULL)
        return NULL;
    newobj = PyObject_GetAttr(obj, str);
    Py_DECREF(str);
    return newobj;
}

/* do the equivalent of obj[idx], where obj is a sequence */
static PyObject *
getitem_sequence(PyObject *obj, Py_ssize_t idx)
{
    return PySequence_GetItem(obj, idx);
}

/* do the equivalent of obj[idx], where obj is not a sequence */
static PyObject *
getitem_idx(PyObject *obj, Py_ssize_t idx)
{
    PyObject *newobj;
    PyObject *idx_obj = PyLong_FromSsize_t(idx);
    if (idx_obj == NULL)
        return NULL;
    newobj = PyObject_GetItem(obj, idx_obj);
    Py_DECREF(idx_obj);
    return newobj;
}

/* do the equivalent of obj[name] */
static PyObject *
getitem_str(PyObject *obj, SubString *name)
{
    PyObject *newobj;
    PyObject *str = SubString_new_object(name);
    if (str == NULL)
        return NULL;
    newobj = PyObject_GetItem(obj, str);
    Py_DECREF(str);
    return newobj;
}

typedef struct {
    /* the entire string we're parsing.  we assume that someone else
       is managing its lifetime, and that it will exist for the
       lifetime of the iterator.  can be empty */
    SubString str;

    /* index to where we are inside field_name */
    Py_ssize_t index;
} FieldNameIterator;


static int
FieldNameIterator_init(FieldNameIterator *self, PyObject *s,
                       Py_ssize_t start, Py_ssize_t end)
{
    SubString_init(&self->str, s, start, end);
    self->index = start;
    return 1;
}

static int
_FieldNameIterator_attr(FieldNameIterator *self, SubString *name)
{
    Py_UCS4 c;

    name->str = self->str.str;
    name->start = self->index;

    /* return everything until '.' or '[' */
    while (self->index < self->str.end) {
        c = PyUnicode_READ_CHAR(self->str.str, self->index++);
        switch (c) {
        case '[':
        case '.':
            /* backup so that we this character will be seen next time */
            self->index--;
            break;
        default:
            continue;
        }
        break;
    }
    /* end of string is okay */
    name->end = self->index;
    return 1;
}

static int
_FieldNameIterator_item(FieldNameIterator *self, SubString *name)
{
    int bracket_seen = 0;
    Py_UCS4 c;

    name->str = self->str.str;
    name->start = self->index;

    /* return everything until ']' */
    while (self->index < self->str.end) {
        c = PyUnicode_READ_CHAR(self->str.str, self->index++);
        switch (c) {
        case ']':
            bracket_seen = 1;
            break;
        default:
            continue;
        }
        break;
    }
    /* make sure we ended with a ']' */
    if (!bracket_seen) {
        PyErr_SetString(PyExc_ValueError, "Missing ']' in format string");
        return 0;
    }

    /* end of string is okay */
    /* don't include the ']' */
    name->end = self->index-1;
    return 1;
}

/* returns 0 on error, 1 on non-error termination, and 2 if it returns a value */
static int
FieldNameIterator_next(FieldNameIterator *self, int *is_attribute,
                       Py_ssize_t *name_idx, SubString *name)
{
    /* check at end of input */
    if (self->index >= self->str.end)
        return 1;

    switch (PyUnicode_READ_CHAR(self->str.str, self->index++)) {
    case '.':
        *is_attribute = 1;
        if (_FieldNameIterator_attr(self, name) == 0)
            return 0;
        *name_idx = -1;
        break;
    case '[':
        *is_attribute = 0;
        if (_FieldNameIterator_item(self, name) == 0)
            return 0;
        *name_idx = get_integer(name);
        if (*name_idx == -1 && PyErr_Occurred())
            return 0;
        break;
    default:
        /* Invalid character follows ']' */
        PyErr_SetString(PyExc_ValueError, "Only '.' or '[' may "
                        "follow ']' in format field specifier");
        return 0;
    }

    /* empty string is an error */
    if (name->start == name->end) {
        PyErr_SetString(PyExc_ValueError, "Empty attribute in format string");
        return 0;
    }

    return 2;
}


/* input: field_name
   output: 'first' points to the part before the first '[' or '.'
           'first_idx' is -1 if 'first' is not an integer, otherwise
                       it's the value of first converted to an integer
           'rest' is an iterator to return the rest
*/
static int
field_name_split(PyObject *str, Py_ssize_t start, Py_ssize_t end, SubString *first,
                 Py_ssize_t *first_idx, FieldNameIterator *rest,
                 AutoNumber *auto_number)
{
    Py_UCS4 c;
    Py_ssize_t i = start;
    int field_name_is_empty;
    int using_numeric_index;

    /* find the part up until the first '.' or '[' */
    while (i < end) {
        switch (c = PyUnicode_READ_CHAR(str, i++)) {
        case '[':
        case '.':
            /* backup so that we this character is available to the
               "rest" iterator */
            i--;
            break;
        default:
            continue;
        }
        break;
    }

    /* set up the return values */
    SubString_init(first, str, start, i);
    FieldNameIterator_init(rest, str, i, end);

    /* see if "first" is an integer, in which case it's used as an index */
    *first_idx = get_integer(first);
    if (*first_idx == -1 && PyErr_Occurred())
        return 0;

    field_name_is_empty = first->start >= first->end;

    /* If the field name is omitted or if we have a numeric index
       specified, then we're doing numeric indexing into args. */
    using_numeric_index = field_name_is_empty || *first_idx != -1;

    /* We always get here exactly one time for each field we're
       processing. And we get here in field order (counting by left
       braces). So this is the perfect place to handle automatic field
       numbering if the field name is omitted. */

    /* Check if we need to do the auto-numbering. It's not needed if
       we're called from string.Format routines, because it's handled
       in that class by itself. */
    if (auto_number) {
        /* Initialize our auto numbering state if this is the first
           time we're either auto-numbering or manually numbering. */
        if (auto_number->an_state == ANS_INIT && using_numeric_index)
            auto_number->an_state = field_name_is_empty ?
                ANS_AUTO : ANS_MANUAL;

        /* Make sure our state is consistent with what we're doing
           this time through. Only check if we're using a numeric
           index. */
        if (using_numeric_index)
            if (autonumber_state_error(auto_number->an_state,
                                       field_name_is_empty))
                return 0;
        /* Zero length field means we want to do auto-numbering of the
           fields. */
        if (field_name_is_empty)
            *first_idx = (auto_number->an_field_number)++;
    }

    return 1;
}


/*
    get_field_object returns the object inside {}, before the
    format_spec.  It handles getindex and getattr lookups and consumes
    the entire input string.
*/
static PyObject *
get_field_object(SubString *input, PyObject *args, PyObject *kwargs,
                 AutoNumber *auto_number)
{
    PyObject *obj = NULL;
    int ok;
    int is_attribute;
    SubString name;
    SubString first;
    Py_ssize_t index;
    FieldNameIterator rest;

    if (!field_name_split(input->str, input->start, input->end, &first,
                          &index, &rest, auto_number)) {
        goto error;
    }

    if (index == -1) {
        /* look up in kwargs */
        PyObject *key = SubString_new_object(&first);
        if (key == NULL) {
            goto error;
        }
        if (kwargs == NULL) {
            PyErr_SetObject(PyExc_KeyError, key);
            Py_DECREF(key);
            goto error;
        }
        /* Use PyObject_GetItem instead of PyDict_GetItem because this
           code is no longer just used with kwargs. It might be passed
           a non-dict when called through format_map. */
        obj = PyObject_GetItem(kwargs, key);
        Py_DECREF(key);
        if (obj == NULL) {
            goto error;
        }
    }
    else {
        /* If args is NULL, we have a format string with a positional field
           with only kwargs to retrieve it from. This can only happen when
           used with format_map(), where positional arguments are not
           allowed. */
        if (args == NULL) {
            PyErr_SetString(PyExc_ValueError, "Format string contains "
                            "positional fields");
            goto error;
        }

        /* look up in args */
        obj = PySequence_GetItem(args, index);
        if (obj == NULL) {
            PyErr_Format(PyExc_IndexError,
                         "Replacement index %zd out of range for positional "
                         "args tuple",
                         index);
             goto error;
        }
    }

    /* iterate over the rest of the field_name */
    while ((ok = FieldNameIterator_next(&rest, &is_attribute, &index,
                                        &name)) == 2) {
        PyObject *tmp;

        if (is_attribute)
            /* getattr lookup "." */
            tmp = getattr(obj, &name);
        else
            /* getitem lookup "[]" */
            if (index == -1)
                tmp = getitem_str(obj, &name);
            else
                if (PySequence_Check(obj))
                    tmp = getitem_sequence(obj, index);
                else
                    /* not a sequence */
                    tmp = getitem_idx(obj, index);
        if (tmp == NULL)
            goto error;

        /* assign to obj */
        Py_SETREF(obj, tmp);
    }
    /* end of iterator, this is the non-error case */
    if (ok == 1)
        return obj;
error:
    Py_XDECREF(obj);
    return NULL;
}

/************************************************************************/
/*****************  Field rendering functions  **************************/
/************************************************************************/

/*
    render_field() is the main function in this section.  It takes the
    field object and field specification string generated by
    get_field_and_spec, and renders the field into the output string.

    render_field calls fieldobj.__format__(format_spec) method, and
    appends to the output.
*/
static int
render_field(PyObject *fieldobj, SubString *format_spec, _PyUnicodeWriter *writer)
{
    int ok = 0;
    PyObject *result = NULL;
    PyObject *format_spec_object = NULL;
    int (*formatter) (_PyUnicodeWriter*, PyObject *, PyObject *, Py_ssize_t, Py_ssize_t) = NULL;
    int err;

    /* If we know the type exactly, skip the lookup of __format__ and just
       call the formatter directly. */
    if (PyUnicode_CheckExact(fieldobj))
        formatter = _PyUnicode_FormatAdvancedWriter;
    else if (PyLong_CheckExact(fieldobj))
        formatter = _PyLong_FormatAdvancedWriter;
    else if (PyFloat_CheckExact(fieldobj))
        formatter = _PyFloat_FormatAdvancedWriter;
    else if (PyComplex_CheckExact(fieldobj))
        formatter = _PyComplex_FormatAdvancedWriter;

    if (formatter) {
        /* we know exactly which formatter will be called when __format__ is
           looked up, so call it directly, instead. */
        err = formatter(writer, fieldobj, format_spec->str,
                        format_spec->start, format_spec->end);
        return (err == 0);
    }
    else {
        /* We need to create an object out of the pointers we have, because
           __format__ takes a string/unicode object for format_spec. */
        if (format_spec->str)
            format_spec_object = PyUnicode_Substring(format_spec->str,
                                                     format_spec->start,
                                                     format_spec->end);
        else
            format_spec_object = Py_GetConstant(Py_CONSTANT_EMPTY_STR);
        if (format_spec_object == NULL)
            goto done;

        result = PyObject_Format(fieldobj, format_spec_object);
    }
    if (result == NULL)
        goto done;

    if (_PyUnicodeWriter_WriteStr(writer, result) == -1)
        goto done;
    ok = 1;

done:
    Py_XDECREF(format_spec_object);
    Py_XDECREF(result);
    return ok;
}

static int
parse_field(SubString *str, SubString *field_name, SubString *format_spec,
            int *format_spec_needs_expanding, Py_UCS4 *conversion)
{
    /* Note this function works if the field name is zero length,
       which is good.  Zero length field names are handled later, in
       field_name_split. */

    Py_UCS4 c = 0;

    /* initialize these, as they may be empty */
    *conversion = '\0';
    SubString_init(format_spec, NULL, 0, 0);

    /* Search for the field name.  it's terminated by the end of
       the string, or a ':' or '!' */
    field_name->str = str->str;
    field_name->start = str->start;
    while (str->start < str->end) {
        switch ((c = PyUnicode_READ_CHAR(str->str, str->start++))) {
        case '{':
            PyErr_SetString(PyExc_ValueError, "unexpected '{' in field name");
            return 0;
        case '[':
            for (; str->start < str->end; str->start++)
                if (PyUnicode_READ_CHAR(str->str, str->start) == ']')
                    break;
            continue;
        case '}':
        case ':':
        case '!':
            break;
        default:
            continue;
        }
        break;
    }

    field_name->end = str->start - 1;
    if (c == '!' || c == ':') {
        Py_ssize_t count;
        /* we have a format specifier and/or a conversion */
        /* don't include the last character */

        /* see if there's a conversion specifier */
        if (c == '!') {
            /* there must be another character present */
            if (str->start >= str->end) {
                PyErr_SetString(PyExc_ValueError,
                                "end of string while looking for conversion "
                                "specifier");
                return 0;
            }
            *conversion = PyUnicode_READ_CHAR(str->str, str->start++);

            if (str->start < str->end) {
                c = PyUnicode_READ_CHAR(str->str, str->start++);
                if (c == '}')
                    return 1;
                if (c != ':') {
                    PyErr_SetString(PyExc_ValueError,
                                    "expected ':' after conversion specifier");
                    return 0;
                }
            }
        }
        format_spec->str = str->str;
        format_spec->start = str->start;
        count = 1;
        while (str->start < str->end) {
            switch ((c = PyUnicode_READ_CHAR(str->str, str->start++))) {
            case '{':
                *format_spec_needs_expanding = 1;
                count++;
                break;
            case '}':
                count--;
                if (count == 0) {
                    format_spec->end = str->start - 1;
                    return 1;
                }
                break;
            default:
                break;
            }
        }

        PyErr_SetString(PyExc_ValueError, "unmatched '{' in format spec");
        return 0;
    }
    else if (c != '}') {
        PyErr_SetString(PyExc_ValueError, "expected '}' before end of string");
        return 0;
    }

    return 1;
}

/************************************************************************/
/******* Output string allocation and escape-to-markup processing  ******/
/************************************************************************/

/* MarkupIterator breaks the string into pieces of either literal
   text, or things inside {} that need to be marked up.  it is
   designed to make it easy to wrap a Python iterator around it, for
   use with the Formatter class */

typedef struct {
    SubString str;
} MarkupIterator;

static int
MarkupIterator_init(MarkupIterator *self, PyObject *str,
                    Py_ssize_t start, Py_ssize_t end)
{
    SubString_init(&self->str, str, start, end);
    return 1;
}

/* returns 0 on error, 1 on non-error termination, and 2 if it got a
   string (or something to be expanded) */
static int
MarkupIterator_next(MarkupIterator *self, SubString *literal,
                    int *field_present, SubString *field_name,
                    SubString *format_spec, Py_UCS4 *conversion,
                    int *format_spec_needs_expanding)
{
    int at_end;
    Py_UCS4 c = 0;
    Py_ssize_t start;
    Py_ssize_t len;
    int markup_follows = 0;

    /* initialize all of the output variables */
    SubString_init(literal, NULL, 0, 0);
    SubString_init(field_name, NULL, 0, 0);
    SubString_init(format_spec, NULL, 0, 0);
    *conversion = '\0';
    *format_spec_needs_expanding = 0;
    *field_present = 0;

    /* No more input, end of iterator.  This is the normal exit
       path. */
    if (self->str.start >= self->str.end)
        return 1;

    start = self->str.start;

    /* First read any literal text. Read until the end of string, an
       escaped '{' or '}', or an unescaped '{'.  In order to never
       allocate memory and so I can just pass pointers around, if
       there's an escaped '{' or '}' then we'll return the literal
       including the brace, but no format object.  The next time
       through, we'll return the rest of the literal, skipping past
       the second consecutive brace. */
    while (self->str.start < self->str.end) {
        switch (c = PyUnicode_READ_CHAR(self->str.str, self->str.start++)) {
        case '{':
        case '}':
            markup_follows = 1;
            break;
        default:
            continue;
        }
        break;
    }

    at_end = self->str.start >= self->str.end;
    len = self->str.start - start;

    if ((c == '}') && (at_end ||
                       (c != PyUnicode_READ_CHAR(self->str.str,
                                                 self->str.start)))) {
        PyErr_SetString(PyExc_ValueError, "Single '}' encountered "
                        "in format string");
        return 0;
    }
    if (at_end && c == '{') {
        PyErr_SetString(PyExc_ValueError, "Single '{' encountered "
                        "in format string");
        return 0;
    }
    if (!at_end) {
        if (c == PyUnicode_READ_CHAR(self->str.str, self->str.start)) {
            /* escaped } or {, skip it in the input.  there is no
               markup object following us, just this literal text */
            self->str.start++;
            markup_follows = 0;
        }
        else
            len--;
    }

    /* record the literal text */
    literal->str = self->str.str;
    literal->start = start;
    literal->end = start + len;

    if (!markup_follows)
        return 2;

    /* this is markup; parse the field */
    *field_present = 1;
    if (!parse_field(&self->str, field_name, format_spec,
                     format_spec_needs_expanding, conversion))
        return 0;
    return 2;
}


/* do the !r or !s conversion on obj */
static PyObject *
do_conversion(PyObject *obj, Py_UCS4 conversion)
{
    /* XXX in pre-3.0, do we need to convert this to unicode, since it
       might have returned a string? */
    switch (conversion) {
    case 'r':
        return PyObject_Repr(obj);
    case 's':
        return PyObject_Str(obj);
    case 'a':
        return PyObject_ASCII(obj);
    default:
        if (conversion > 32 && conversion < 127) {
                /* It's the ASCII subrange; casting to char is safe
                   (assuming the execution character set is an ASCII
                   superset). */
                PyErr_Format(PyExc_ValueError,
                     "Unknown conversion specifier %c",
                     (char)conversion);
        } else
                PyErr_Format(PyExc_ValueError,
                     "Unknown conversion specifier \\x%x",
                     (unsigned int)conversion);
        return NULL;
    }
}

/* given:

   {field_name!conversion:format_spec}

   compute the result and write it to output.
   format_spec_needs_expanding is an optimization.  if it's false,
   just output the string directly, otherwise recursively expand the
   format_spec string.

   field_name is allowed to be zero length, in which case we
   are doing auto field numbering.
*/

static int
output_markup(SubString *field_name, SubString *format_spec,
              int format_spec_needs_expanding, Py_UCS4 conversion,
              _PyUnicodeWriter *writer, PyObject *args, PyObject *kwargs,
              int recursion_depth, AutoNumber *auto_number)
{
    PyObject *tmp = NULL;
    PyObject *fieldobj = NULL;
    SubString expanded_format_spec;
    SubString *actual_format_spec;
    int result = 0;

    /* convert field_name to an object */
    fieldobj = get_field_object(field_name, args, kwargs, auto_number);
    if (fieldobj == NULL)
        goto done;

    if (conversion != '\0') {
        tmp = do_conversion(fieldobj, conversion);
        if (tmp == NULL)
            goto done;

        /* do the assignment, transferring ownership: fieldobj = tmp */
        Py_SETREF(fieldobj, tmp);
        tmp = NULL;
    }

    /* if needed, recursively compute the format_spec */
    if (format_spec_needs_expanding) {
        tmp = build_string(format_spec, args, kwargs, recursion_depth-1,
                           auto_number);
        if (tmp == NULL)
            goto done;

        /* note that in the case we're expanding the format string,
           tmp must be kept around until after the call to
           render_field. */
        SubString_init(&expanded_format_spec, tmp, 0, PyUnicode_GET_LENGTH(tmp));
        actual_format_spec = &expanded_format_spec;
    }
    else
        actual_format_spec = format_spec;

    if (render_field(fieldobj, actual_format_spec, writer) == 0)
        goto done;

    result = 1;

done:
    Py_XDECREF(fieldobj);
    Py_XDECREF(tmp);

    return result;
}

/*
    do_markup is the top-level loop for the format() method.  It
    searches through the format string for escapes to markup codes, and
    calls other functions to move non-markup text to the output,
    and to perform the markup to the output.
*/
static int
do_markup(SubString *input, PyObject *args, PyObject *kwargs,
          _PyUnicodeWriter *writer, int recursion_depth, AutoNumber *auto_number)
{
    MarkupIterator iter;
    int format_spec_needs_expanding;
    int result;
    int field_present;
    SubString literal;
    SubString field_name;
    SubString format_spec;
    Py_UCS4 conversion;

    MarkupIterator_init(&iter, input->str, input->start, input->end);
    while ((result = MarkupIterator_next(&iter, &literal, &field_present,
                                         &field_name, &format_spec,
                                         &conversion,
                                         &format_spec_needs_expanding)) == 2) {
        if (literal.end != literal.start) {
            if (!field_present && iter.str.start == iter.str.end)
                writer->overallocate = 0;
            if (_PyUnicodeWriter_WriteSubstring(writer, literal.str,
                                                literal.start, literal.end) < 0)
                return 0;
        }

        if (field_present) {
            if (iter.str.start == iter.str.end)
                writer->overallocate = 0;
            if (!output_markup(&field_name, &format_spec,
                               format_spec_needs_expanding, conversion, writer,
                               args, kwargs, recursion_depth, auto_number))
                return 0;
        }
    }
    return result;
}


/*
    build_string allocates the output string and then
    calls do_markup to do the heavy lifting.
*/
static PyObject *
build_string(SubString *input, PyObject *args, PyObject *kwargs,
             int recursion_depth, AutoNumber *auto_number)
{
    _PyUnicodeWriter writer;

    /* check the recursion level */
    if (recursion_depth <= 0) {
        PyErr_SetString(PyExc_ValueError,
                        "Max string recursion exceeded");
        return NULL;
    }

    _PyUnicodeWriter_Init(&writer);
    writer.overallocate = 1;
    writer.min_length = PyUnicode_GET_LENGTH(input->str) + 100;

    if (!do_markup(input, args, kwargs, &writer, recursion_depth,
                   auto_number)) {
        _PyUnicodeWriter_Dealloc(&writer);
        return NULL;
    }

    return _PyUnicodeWriter_Finish(&writer);
}

/************************************************************************/
/*********** main routine ***********************************************/
/************************************************************************/

/* this is the main entry point */
static PyObject *
do_string_format(PyObject *self, PyObject *args, PyObject *kwargs)
{
    SubString input;

    /* PEP 3101 says only 2 levels, so that
       "{0:{1}}".format('abc', 's')            # works
       "{0:{1:{2}}}".format('abc', 's', '')    # fails
    */
    int recursion_depth = 2;

    AutoNumber auto_number;
    AutoNumber_Init(&auto_number);
    SubString_init(&input, self, 0, PyUnicode_GET_LENGTH(self));
    return build_string(&input, args, kwargs, recursion_depth, &auto_number);
}

static PyObject *
do_string_format_map(PyObject *self, PyObject *obj)
{
    return do_string_format(self, NULL, obj);
}


/************************************************************************/
/*********** formatteriterator ******************************************/
/************************************************************************/

/* This is used to implement string.Formatter.vparse().  It exists so
   Formatter can share code with the built in unicode.format() method.
   It's really just a wrapper around MarkupIterator that is callable
   from Python. */

typedef struct {
    PyObject_HEAD
    PyObject *str;
    MarkupIterator it_markup;
} formatteriterobject;

static void
formatteriter_dealloc(formatteriterobject *it)
{
    Py_XDECREF(it->str);
    PyObject_Free(it);
}

/* returns a tuple:
   (literal, field_name, format_spec, conversion)

   literal is any literal text to output.  might be zero length
   field_name is the string before the ':'.  might be None
   format_spec is the string after the ':'.  mibht be None
   conversion is either None, or the string after the '!'
*/
static PyObject *
formatteriter_next(formatteriterobject *it)
{
    SubString literal;
    SubString field_name;
    SubString format_spec;
    Py_UCS4 conversion;
    int format_spec_needs_expanding;
    int field_present;
    int result = MarkupIterator_next(&it->it_markup, &literal, &field_present,
                                     &field_name, &format_spec, &conversion,
                                     &format_spec_needs_expanding);

    /* all of the SubString objects point into it->str, so no
       memory management needs to be done on them */
    assert(0 <= result && result <= 2);
    if (result == 0 || result == 1)
        /* if 0, error has already been set, if 1, iterator is empty */
        return NULL;
    else {
        PyObject *literal_str = NULL;
        PyObject *field_name_str = NULL;
        PyObject *format_spec_str = NULL;
        PyObject *conversion_str = NULL;
        PyObject *tuple = NULL;

        literal_str = SubString_new_object(&literal);
        if (literal_str == NULL)
            goto done;

        field_name_str = SubString_new_object(&field_name);
        if (field_name_str == NULL)
            goto done;

        /* if field_name is non-zero length, return a string for
           format_spec (even if zero length), else return None */
        format_spec_str = (field_present ?
                           SubString_new_object_or_empty :
                           SubString_new_object)(&format_spec);
        if (format_spec_str == NULL)
            goto done;

        /* if the conversion is not specified, return a None,
           otherwise create a one length string with the conversion
           character */
        if (conversion == '\0') {
            conversion_str = Py_NewRef(Py_None);
        }
        else
            conversion_str = PyUnicode_FromKindAndData(PyUnicode_4BYTE_KIND,
                                                       &conversion, 1);
        if (conversion_str == NULL)
            goto done;

        tuple = PyTuple_Pack(4, literal_str, field_name_str, format_spec_str,
                             conversion_str);
    done:
        Py_XDECREF(literal_str);
        Py_XDECREF(field_name_str);
        Py_XDECREF(format_spec_str);
        Py_XDECREF(conversion_str);
        return tuple;
    }
}

static PyMethodDef formatteriter_methods[] = {
    {NULL,              NULL}           /* sentinel */
};

static PyTypeObject PyFormatterIter_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "formatteriterator",                /* tp_name */
    sizeof(formatteriterobject),        /* tp_basicsize */
    0,                                  /* tp_itemsize */
    /* methods */
    (destructor)formatteriter_dealloc,  /* tp_dealloc */
    0,                                  /* tp_vectorcall_offset */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    0,                                  /* tp_as_async */
    0,                                  /* tp_repr */
    0,                                  /* tp_as_number */
    0,                                  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_hash */
    0,                                  /* tp_call */
    0,                                  /* tp_str */
    PyObject_GenericGetAttr,            /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                 /* tp_flags */
    0,                                  /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompare */
    0,                                  /* tp_weaklistoffset */
    PyObject_SelfIter,                  /* tp_iter */
    (iternextfunc)formatteriter_next,   /* tp_iternext */
    formatteriter_methods,              /* tp_methods */
    0,
};

/* unicode_formatter_parser is used to implement
   string.Formatter.vformat.  it parses a string and returns tuples
   describing the parsed elements.  It's a wrapper around
   stringlib/string_format.h's MarkupIterator */
static PyObject *
formatter_parser(PyObject *ignored, PyObject *self)
{
    formatteriterobject *it;

    if (!PyUnicode_Check(self)) {
        PyErr_Format(PyExc_TypeError, "expected str, got %s", Py_TYPE(self)->tp_name);
        return NULL;
    }

    it = PyObject_New(formatteriterobject, &PyFormatterIter_Type);
    if (it == NULL)
        return NULL;

    /* take ownership, give the object to the iterator */
    it->str = Py_NewRef(self);

    /* initialize the contained MarkupIterator */
    MarkupIterator_init(&it->it_markup, (PyObject*)self, 0, PyUnicode_GET_LENGTH(self));
    return (PyObject *)it;
}


/************************************************************************/
/*********** fieldnameiterator ******************************************/
/************************************************************************/


/* This is used to implement string.Formatter.vparse().  It parses the
   field name into attribute and item values.  It's a Python-callable
   wrapper around FieldNameIterator */

typedef struct {
    PyObject_HEAD
    PyObject *str;
    FieldNameIterator it_field;
} fieldnameiterobject;

static void
fieldnameiter_dealloc(fieldnameiterobject *it)
{
    Py_XDECREF(it->str);
    PyObject_Free(it);
}

/* returns a tuple:
   (is_attr, value)
   is_attr is true if we used attribute syntax (e.g., '.foo')
              false if we used index syntax (e.g., '[foo]')
   value is an integer or string
*/
static PyObject *
fieldnameiter_next(fieldnameiterobject *it)
{
    int result;
    int is_attr;
    Py_ssize_t idx;
    SubString name;

    result = FieldNameIterator_next(&it->it_field, &is_attr,
                                    &idx, &name);
    if (result == 0 || result == 1)
        /* if 0, error has already been set, if 1, iterator is empty */
        return NULL;
    else {
        PyObject* result = NULL;
        PyObject* is_attr_obj = NULL;
        PyObject* obj = NULL;

        is_attr_obj = PyBool_FromLong(is_attr);
        if (is_attr_obj == NULL)
            goto done;

        /* either an integer or a string */
        if (idx != -1)
            obj = PyLong_FromSsize_t(idx);
        else
            obj = SubString_new_object(&name);
        if (obj == NULL)
            goto done;

        /* return a tuple of values */
        result = PyTuple_Pack(2, is_attr_obj, obj);

    done:
        Py_XDECREF(is_attr_obj);
        Py_XDECREF(obj);
        return result;
    }
}

static PyMethodDef fieldnameiter_methods[] = {
    {NULL,              NULL}           /* sentinel */
};

static PyTypeObject PyFieldNameIter_Type = {
    PyVarObject_HEAD_INIT(&PyType_Type, 0)
    "fieldnameiterator",                /* tp_name */
    sizeof(fieldnameiterobject),        /* tp_basicsize */
    0,                                  /* tp_itemsize */
    /* methods */
    (destructor)fieldnameiter_dealloc,  /* tp_dealloc */
    0,                                  /* tp_vectorcall_offset */
    0,                                  /* tp_getattr */
    0,                                  /* tp_setattr */
    0,                                  /* tp_as_async */
    0,                                  /* tp_repr */
    0,                                  /* tp_as_number */
    0,                                  /* tp_as_sequence */
    0,                                  /* tp_as_mapping */
    0,                                  /* tp_hash */
    0,                                  /* tp_call */
    0,                                  /* tp_str */
    PyObject_GenericGetAttr,            /* tp_getattro */
    0,                                  /* tp_setattro */
    0,                                  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                 /* tp_flags */
    0,                                  /* tp_doc */
    0,                                  /* tp_traverse */
    0,                                  /* tp_clear */
    0,                                  /* tp_richcompare */
    0,                                  /* tp_weaklistoffset */
    PyObject_SelfIter,                  /* tp_iter */
    (iternextfunc)fieldnameiter_next,   /* tp_iternext */
    fieldnameiter_methods,              /* tp_methods */
    0};

/* unicode_formatter_field_name_split is used to implement
   string.Formatter.vformat.  it takes a PEP 3101 "field name", and
   returns a tuple of (first, rest): "first", the part before the
   first '.' or '['; and "rest", an iterator for the rest of the field
   name.  it's a wrapper around stringlib/string_format.h's
   field_name_split.  The iterator it returns is a
   FieldNameIterator */
static PyObject *
formatter_field_name_split(PyObject *ignored, PyObject *self)
{
    SubString first;
    Py_ssize_t first_idx;
    fieldnameiterobject *it;

    PyObject *first_obj = NULL;
    PyObject *result = NULL;

    if (!PyUnicode_Check(self)) {
        PyErr_Format(PyExc_TypeError, "expected str, got %s", Py_TYPE(self)->tp_name);
        return NULL;
    }

    it = PyObject_New(fieldnameiterobject, &PyFieldNameIter_Type);
    if (it == NULL)
        return NULL;

    /* take ownership, give the object to the iterator.  this is
       just to keep the field_name alive */
    it->str = Py_NewRef(self);

    /* Pass in auto_number = NULL. We'll return an empty string for
       first_obj in that case. */
    if (!field_name_split((PyObject*)self, 0, PyUnicode_GET_LENGTH(self),
                          &first, &first_idx, &it->it_field, NULL))
        goto done;

    /* first becomes an integer, if possible; else a string */
    if (first_idx != -1)
        first_obj = PyLong_FromSsize_t(first_idx);
    else
        /* convert "first" into a string object */
        first_obj = SubString_new_object(&first);
    if (first_obj == NULL)
        goto done;

    /* return a tuple of values */
    result = PyTuple_Pack(2, first_obj, it);

done:
    Py_XDECREF(it);
    Py_XDECREF(first_obj);
    return result;
}


================================================
File: /Objects/stringlib/clinic/transmogrify.h.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

#if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
#  include "pycore_gc.h"          // PyGC_Head
#  include "pycore_runtime.h"     // _Py_ID()
#endif
#include "pycore_abstract.h"      // _PyNumber_Index()
#include "pycore_modsupport.h"    // _PyArg_UnpackKeywords()

PyDoc_STRVAR(stringlib_expandtabs__doc__,
"expandtabs($self, /, tabsize=8)\n"
"--\n"
"\n"
"Return a copy where all tab characters are expanded using spaces.\n"
"\n"
"If tabsize is not given, a tab size of 8 characters is assumed.");

#define STRINGLIB_EXPANDTABS_METHODDEF    \
    {"expandtabs", _PyCFunction_CAST(stringlib_expandtabs), METH_FASTCALL|METH_KEYWORDS, stringlib_expandtabs__doc__},

static PyObject *
stringlib_expandtabs_impl(PyObject *self, int tabsize);

static PyObject *
stringlib_expandtabs(PyObject *self, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 1
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(tabsize), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"tabsize", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "expandtabs",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[1];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 0;
    int tabsize = 8;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 0, /*maxpos*/ 1, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    tabsize = PyLong_AsInt(args[0]);
    if (tabsize == -1 && PyErr_Occurred()) {
        goto exit;
    }
skip_optional_pos:
    return_value = stringlib_expandtabs_impl(self, tabsize);

exit:
    return return_value;
}

PyDoc_STRVAR(stringlib_ljust__doc__,
"ljust($self, width, fillchar=b\' \', /)\n"
"--\n"
"\n"
"Return a left-justified string of length width.\n"
"\n"
"Padding is done using the specified fill character.");

#define STRINGLIB_LJUST_METHODDEF    \
    {"ljust", _PyCFunction_CAST(stringlib_ljust), METH_FASTCALL, stringlib_ljust__doc__},

static PyObject *
stringlib_ljust_impl(PyObject *self, Py_ssize_t width, char fillchar);

static PyObject *
stringlib_ljust(PyObject *self, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    Py_ssize_t width;
    char fillchar = ' ';

    if (!_PyArg_CheckPositional("ljust", nargs, 1, 2)) {
        goto exit;
    }
    {
        Py_ssize_t ival = -1;
        PyObject *iobj = _PyNumber_Index(args[0]);
        if (iobj != NULL) {
            ival = PyLong_AsSsize_t(iobj);
            Py_DECREF(iobj);
        }
        if (ival == -1 && PyErr_Occurred()) {
            goto exit;
        }
        width = ival;
    }
    if (nargs < 2) {
        goto skip_optional;
    }
    if (PyBytes_Check(args[1])) {
        if (PyBytes_GET_SIZE(args[1]) != 1) {
            PyErr_Format(PyExc_TypeError,
                "ljust(): argument 2 must be a byte string of length 1, "
                "not a bytes object of length %zd",
                PyBytes_GET_SIZE(args[1]));
            goto exit;
        }
        fillchar = PyBytes_AS_STRING(args[1])[0];
    }
    else if (PyByteArray_Check(args[1])) {
        if (PyByteArray_GET_SIZE(args[1]) != 1) {
            PyErr_Format(PyExc_TypeError,
                "ljust(): argument 2 must be a byte string of length 1, "
                "not a bytearray object of length %zd",
                PyByteArray_GET_SIZE(args[1]));
            goto exit;
        }
        fillchar = PyByteArray_AS_STRING(args[1])[0];
    }
    else {
        _PyArg_BadArgument("ljust", "argument 2", "a byte string of length 1", args[1]);
        goto exit;
    }
skip_optional:
    return_value = stringlib_ljust_impl(self, width, fillchar);

exit:
    return return_value;
}

PyDoc_STRVAR(stringlib_rjust__doc__,
"rjust($self, width, fillchar=b\' \', /)\n"
"--\n"
"\n"
"Return a right-justified string of length width.\n"
"\n"
"Padding is done using the specified fill character.");

#define STRINGLIB_RJUST_METHODDEF    \
    {"rjust", _PyCFunction_CAST(stringlib_rjust), METH_FASTCALL, stringlib_rjust__doc__},

static PyObject *
stringlib_rjust_impl(PyObject *self, Py_ssize_t width, char fillchar);

static PyObject *
stringlib_rjust(PyObject *self, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    Py_ssize_t width;
    char fillchar = ' ';

    if (!_PyArg_CheckPositional("rjust", nargs, 1, 2)) {
        goto exit;
    }
    {
        Py_ssize_t ival = -1;
        PyObject *iobj = _PyNumber_Index(args[0]);
        if (iobj != NULL) {
            ival = PyLong_AsSsize_t(iobj);
            Py_DECREF(iobj);
        }
        if (ival == -1 && PyErr_Occurred()) {
            goto exit;
        }
        width = ival;
    }
    if (nargs < 2) {
        goto skip_optional;
    }
    if (PyBytes_Check(args[1])) {
        if (PyBytes_GET_SIZE(args[1]) != 1) {
            PyErr_Format(PyExc_TypeError,
                "rjust(): argument 2 must be a byte string of length 1, "
                "not a bytes object of length %zd",
                PyBytes_GET_SIZE(args[1]));
            goto exit;
        }
        fillchar = PyBytes_AS_STRING(args[1])[0];
    }
    else if (PyByteArray_Check(args[1])) {
        if (PyByteArray_GET_SIZE(args[1]) != 1) {
            PyErr_Format(PyExc_TypeError,
                "rjust(): argument 2 must be a byte string of length 1, "
                "not a bytearray object of length %zd",
                PyByteArray_GET_SIZE(args[1]));
            goto exit;
        }
        fillchar = PyByteArray_AS_STRING(args[1])[0];
    }
    else {
        _PyArg_BadArgument("rjust", "argument 2", "a byte string of length 1", args[1]);
        goto exit;
    }
skip_optional:
    return_value = stringlib_rjust_impl(self, width, fillchar);

exit:
    return return_value;
}

PyDoc_STRVAR(stringlib_center__doc__,
"center($self, width, fillchar=b\' \', /)\n"
"--\n"
"\n"
"Return a centered string of length width.\n"
"\n"
"Padding is done using the specified fill character.");

#define STRINGLIB_CENTER_METHODDEF    \
    {"center", _PyCFunction_CAST(stringlib_center), METH_FASTCALL, stringlib_center__doc__},

static PyObject *
stringlib_center_impl(PyObject *self, Py_ssize_t width, char fillchar);

static PyObject *
stringlib_center(PyObject *self, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    Py_ssize_t width;
    char fillchar = ' ';

    if (!_PyArg_CheckPositional("center", nargs, 1, 2)) {
        goto exit;
    }
    {
        Py_ssize_t ival = -1;
        PyObject *iobj = _PyNumber_Index(args[0]);
        if (iobj != NULL) {
            ival = PyLong_AsSsize_t(iobj);
            Py_DECREF(iobj);
        }
        if (ival == -1 && PyErr_Occurred()) {
            goto exit;
        }
        width = ival;
    }
    if (nargs < 2) {
        goto skip_optional;
    }
    if (PyBytes_Check(args[1])) {
        if (PyBytes_GET_SIZE(args[1]) != 1) {
            PyErr_Format(PyExc_TypeError,
                "center(): argument 2 must be a byte string of length 1, "
                "not a bytes object of length %zd",
                PyBytes_GET_SIZE(args[1]));
            goto exit;
        }
        fillchar = PyBytes_AS_STRING(args[1])[0];
    }
    else if (PyByteArray_Check(args[1])) {
        if (PyByteArray_GET_SIZE(args[1]) != 1) {
            PyErr_Format(PyExc_TypeError,
                "center(): argument 2 must be a byte string of length 1, "
                "not a bytearray object of length %zd",
                PyByteArray_GET_SIZE(args[1]));
            goto exit;
        }
        fillchar = PyByteArray_AS_STRING(args[1])[0];
    }
    else {
        _PyArg_BadArgument("center", "argument 2", "a byte string of length 1", args[1]);
        goto exit;
    }
skip_optional:
    return_value = stringlib_center_impl(self, width, fillchar);

exit:
    return return_value;
}

PyDoc_STRVAR(stringlib_zfill__doc__,
"zfill($self, width, /)\n"
"--\n"
"\n"
"Pad a numeric string with zeros on the left, to fill a field of the given width.\n"
"\n"
"The original string is never truncated.");

#define STRINGLIB_ZFILL_METHODDEF    \
    {"zfill", (PyCFunction)stringlib_zfill, METH_O, stringlib_zfill__doc__},

static PyObject *
stringlib_zfill_impl(PyObject *self, Py_ssize_t width);

static PyObject *
stringlib_zfill(PyObject *self, PyObject *arg)
{
    PyObject *return_value = NULL;
    Py_ssize_t width;

    {
        Py_ssize_t ival = -1;
        PyObject *iobj = _PyNumber_Index(arg);
        if (iobj != NULL) {
            ival = PyLong_AsSsize_t(iobj);
            Py_DECREF(iobj);
        }
        if (ival == -1 && PyErr_Occurred()) {
            goto exit;
        }
        width = ival;
    }
    return_value = stringlib_zfill_impl(self, width);

exit:
    return return_value;
}
/*[clinic end generated code: output=0e24a10bac3ec053 input=a9049054013a1b77]*/


================================================
File: /PC/WinMain.c
================================================
/* Minimal main program -- everything is loaded from the library. */

#include "Python.h"

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <stdlib.h>  /* __argc, __wargv */

int WINAPI wWinMain(
    HINSTANCE hInstance,      /* handle to current instance */
    HINSTANCE hPrevInstance,  /* handle to previous instance */
    LPWSTR lpCmdLine,         /* pointer to command line */
    int nCmdShow              /* show state of window */
)
{
    return Py_Main(__argc, __wargv);
}


================================================
File: /PC/_testconsole.c
================================================
/* Testing module for multi-phase initialization of extension modules (PEP 489)
 */

// Need limited C API version 3.13 for Py_mod_gil
#include "pyconfig.h"   // Py_GIL_DISABLED
#ifndef Py_GIL_DISABLED
#  define Py_LIMITED_API 0x030d0000
#endif

#include "Python.h"

#ifdef MS_WINDOWS

#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#include <fcntl.h>

 /* The full definition is in iomodule. We reproduce
 enough here to get the fd, which is all we want. */
typedef struct {
    PyObject_HEAD
    int fd;
} winconsoleio;


static int execfunc(PyObject *m)
{
    return 0;
}

PyModuleDef_Slot testconsole_slots[] = {
    {Py_mod_exec, execfunc},
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL},
};

/*[python input]
class HANDLE_converter(CConverter):
    type = 'void *'
    format_unit = '"_Py_PARSE_UINTPTR"'

    def parse_arg(self, argname, displayname, *, limited_capi):
        return self.format_code("""
            {paramname} = PyLong_AsVoidPtr({argname});
            if (!{paramname} && PyErr_Occurred()) {{{{
                goto exit;
            }}}}
            """,
            argname=argname)
[python start generated code]*/
/*[python end generated code: output=da39a3ee5e6b4b0d input=380aa5c91076742b]*/
/*[python end generated code:]*/

/*[clinic input]
module _testconsole

_testconsole.write_input
    file: object
    s: Py_buffer

Writes UTF-16-LE encoded bytes to the console as if typed by a user.
[clinic start generated code]*/

static PyObject *
_testconsole_write_input_impl(PyObject *module, PyObject *file, Py_buffer *s)
/*[clinic end generated code: output=58631a8985426ad3 input=68062f1bb2e52206]*/
{
    INPUT_RECORD *rec = NULL;

    PyObject *mod = PyImport_ImportModule("_io");
    if (mod == NULL) {
        return NULL;
    }

    PyTypeObject *winconsoleio_type = (PyTypeObject *)PyObject_GetAttrString(mod, "_WindowsConsoleIO");
    Py_DECREF(mod);
    if (winconsoleio_type == NULL) {
        return NULL;
    }
    int is_subclass = PyObject_TypeCheck(file, winconsoleio_type);
    Py_DECREF(winconsoleio_type);
    if (!is_subclass) {
        PyErr_SetString(PyExc_TypeError, "expected raw console object");
        return NULL;
    }

    const wchar_t *p = (const wchar_t *)s->buf;
    DWORD size = (DWORD)s->len / sizeof(wchar_t);

    rec = (INPUT_RECORD*)PyMem_Calloc(size, sizeof(INPUT_RECORD));
    if (!rec)
        goto error;

    INPUT_RECORD *prec = rec;
    for (DWORD i = 0; i < size; ++i, ++p, ++prec) {
        prec->EventType = KEY_EVENT;
        prec->Event.KeyEvent.bKeyDown = TRUE;
        prec->Event.KeyEvent.wRepeatCount = 1;
        prec->Event.KeyEvent.uChar.UnicodeChar = *p;
    }

    HANDLE hInput = (HANDLE)_get_osfhandle(((winconsoleio*)file)->fd);
    if (hInput == INVALID_HANDLE_VALUE) {
        PyErr_SetFromErrno(PyExc_OSError);
        goto error;
    }

    DWORD total = 0;
    while (total < size) {
        DWORD wrote;
        if (!WriteConsoleInputW(hInput, &rec[total], (size - total), &wrote)) {
            PyErr_SetFromWindowsErr(0);
            goto error;
        }
        total += wrote;
    }

    PyMem_Free((void*)rec);

    Py_RETURN_NONE;
error:
    if (rec)
        PyMem_Free((void*)rec);
    return NULL;
}

/*[clinic input]
_testconsole.read_output
    file: object

Reads a str from the console as written to stdout.
[clinic start generated code]*/

static PyObject *
_testconsole_read_output_impl(PyObject *module, PyObject *file)
/*[clinic end generated code: output=876310d81a73e6d2 input=b3521f64b1b558e3]*/
{
    Py_RETURN_NONE;
}


#include "clinic\_testconsole.c.h"

PyMethodDef testconsole_methods[] = {
    _TESTCONSOLE_WRITE_INPUT_METHODDEF
    _TESTCONSOLE_READ_OUTPUT_METHODDEF
    {NULL, NULL}
};

static PyModuleDef testconsole_def = {
    PyModuleDef_HEAD_INIT,                      /* m_base */
    "_testconsole",                             /* m_name */
    PyDoc_STR("Test module for the Windows console"), /* m_doc */
    0,                                          /* m_size */
    testconsole_methods,                        /* m_methods */
    testconsole_slots,                          /* m_slots */
    NULL,                                       /* m_traverse */
    NULL,                                       /* m_clear */
    NULL,                                       /* m_free */
};

PyMODINIT_FUNC
PyInit__testconsole(PyObject *spec)
{
    return PyModuleDef_Init(&testconsole_def);
}

#endif /* MS_WINDOWS */


================================================
File: /PC/_wmimodule.cpp
================================================
//
// Helper library for querying WMI using its COM-based query API.
//
// Copyright (c) Microsoft Corporation
// Licensed to PSF under a contributor agreement
//

// Version history
//  2022-08: Initial contribution (Steve Dower)

// clinic/_wmimodule.cpp.h uses internal pycore_modsupport.h API
#ifndef Py_BUILD_CORE_BUILTIN
#  define Py_BUILD_CORE_MODULE 1
#endif

#define _WIN32_DCOM
#include <Windows.h>
#include <comdef.h>
#include <Wbemidl.h>
#include <propvarutil.h>

#include <Python.h>


#if _MSVC_LANG >= 202002L
// We can use clinic directly when the C++ compiler supports C++20
#include "clinic/_wmimodule.cpp.h"
#else
// Cannot use clinic because of missing C++20 support, so create a simpler
// API instead. This won't impact releases, so fine to omit the docstring.
static PyObject *_wmi_exec_query_impl(PyObject *module, PyObject *query);
#define _WMI_EXEC_QUERY_METHODDEF {"exec_query", _wmi_exec_query_impl, METH_O, NULL},
#endif


/*[clinic input]
module _wmi
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=7ca95dad1453d10d]*/



struct _query_data {
    LPCWSTR query;
    HANDLE writePipe;
    HANDLE readPipe;
    HANDLE initEvent;
    HANDLE connectEvent;
};


static DWORD WINAPI
_query_thread(LPVOID param)
{
    IWbemLocator *locator = NULL;
    IWbemServices *services = NULL;
    IEnumWbemClassObject* enumerator = NULL;
    HRESULT hr = S_OK;
    BSTR bstrQuery = NULL;
    struct _query_data *data = (struct _query_data*)param;

    // gh-125315: Copy the query string first, so that if the main thread gives
    // up on waiting we aren't left with a dangling pointer (and a likely crash)
    bstrQuery = SysAllocString(data->query);
    if (!bstrQuery) {
        hr = HRESULT_FROM_WIN32(ERROR_NOT_ENOUGH_MEMORY);
    }

    if (SUCCEEDED(hr)) {
        hr = CoInitializeEx(nullptr, COINIT_APARTMENTTHREADED);
    }

    if (FAILED(hr)) {
        CloseHandle(data->writePipe);
        if (bstrQuery) {
            SysFreeString(bstrQuery);
        }
        return (DWORD)hr;
    }

    hr = CoInitializeSecurity(
        NULL, -1, NULL, NULL,
        RPC_C_AUTHN_LEVEL_DEFAULT,
        RPC_C_IMP_LEVEL_IMPERSONATE,
        NULL, EOAC_NONE, NULL
    );
    // gh-96684: CoInitializeSecurity will fail if another part of the app has
    // already called it. Hopefully they passed lenient enough settings that we
    // can complete the WMI query, so keep going.
    if (hr == RPC_E_TOO_LATE) {
        hr = 0;
    }
    if (SUCCEEDED(hr)) {
        hr = CoCreateInstance(
            CLSID_WbemLocator, 0, CLSCTX_INPROC_SERVER,
            IID_IWbemLocator, (LPVOID *)&locator
        );
    }
    if (SUCCEEDED(hr) && !SetEvent(data->initEvent)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    if (SUCCEEDED(hr)) {
        hr = locator->ConnectServer(
            bstr_t(L"ROOT\\CIMV2"),
            NULL, NULL, 0, NULL, 0, 0, &services
        );
    }
    if (SUCCEEDED(hr) && !SetEvent(data->connectEvent)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    if (SUCCEEDED(hr)) {
        hr = CoSetProxyBlanket(
            services, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
            RPC_C_AUTHN_LEVEL_CALL, RPC_C_IMP_LEVEL_IMPERSONATE,
            NULL, EOAC_NONE
        );
    }
    if (SUCCEEDED(hr)) {
        hr = services->ExecQuery(
            bstr_t("WQL"),
            bstrQuery,
            WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,
            NULL,
            &enumerator
        );
    }

    // Okay, after all that, at this stage we should have an enumerator
    // to the query results and can start writing them to the pipe!
    IWbemClassObject *value = NULL;
    int startOfEnum = TRUE;
    int endOfEnum = FALSE;
    while (SUCCEEDED(hr) && !endOfEnum) {
        ULONG got = 0;
        DWORD written;
        hr = enumerator->Next(WBEM_INFINITE, 1, &value, &got);
        if (hr == WBEM_S_FALSE) {
            // Could be at the end, but still got a result this time
            endOfEnum = TRUE;
            hr = 0;
            break;
        }
        if (FAILED(hr) || got != 1 || !value) {
            continue;
        }
        if (!startOfEnum && !WriteFile(data->writePipe, (LPVOID)L"\0", 2, &written, NULL)) {
            hr = HRESULT_FROM_WIN32(GetLastError());
            break;
        }
        startOfEnum = FALSE;
        // Okay, now we have each resulting object it's time to
        // enumerate its members
        hr = value->BeginEnumeration(0);
        if (FAILED(hr)) {
            value->Release();
            break;
        }
        while (SUCCEEDED(hr)) {
            BSTR propName;
            VARIANT propValue;
            long flavor;
            hr = value->Next(0, &propName, &propValue, NULL, &flavor);
            if (hr == WBEM_S_NO_MORE_DATA) {
                hr = 0;
                break;
            }
            if (SUCCEEDED(hr) && (flavor & WBEM_FLAVOR_MASK_ORIGIN) != WBEM_FLAVOR_ORIGIN_SYSTEM) {
                WCHAR propStr[8192];
                hr = VariantToString(propValue, propStr, sizeof(propStr) / sizeof(propStr[0]));
                if (SUCCEEDED(hr)) {
                    DWORD cbStr1, cbStr2;
                    cbStr1 = (DWORD)(wcslen(propName) * sizeof(propName[0]));
                    cbStr2 = (DWORD)(wcslen(propStr) * sizeof(propStr[0]));
                    if (!WriteFile(data->writePipe, propName, cbStr1, &written, NULL) ||
                        !WriteFile(data->writePipe, (LPVOID)L"=", 2, &written, NULL) ||
                        !WriteFile(data->writePipe, propStr, cbStr2, &written, NULL) ||
                        !WriteFile(data->writePipe, (LPVOID)L"\0", 2, &written, NULL)
                    ) {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                VariantClear(&propValue);
                SysFreeString(propName);
            }
        }
        value->EndEnumeration();
        value->Release();
    }

    if (bstrQuery) {
        SysFreeString(bstrQuery);
    }
    if (enumerator) {
        enumerator->Release();
    }
    if (services) {
        services->Release();
    }
    if (locator) {
        locator->Release();
    }
    CoUninitialize();
    CloseHandle(data->writePipe);
    return (DWORD)hr;
}


static DWORD
wait_event(HANDLE event, DWORD timeout)
{
    DWORD err = 0;
    switch (WaitForSingleObject(event, timeout)) {
    case WAIT_OBJECT_0:
        break;
    case WAIT_TIMEOUT:
        err = WAIT_TIMEOUT;
        break;
    default:
        err = GetLastError();
        break;
    }
    return err;
}


/*[clinic input]
_wmi.exec_query

    query: unicode

Runs a WMI query against the local machine.

This returns a single string with 'name=value' pairs in a flat array separated
by null characters.
[clinic start generated code]*/

static PyObject *
_wmi_exec_query_impl(PyObject *module, PyObject *query)
/*[clinic end generated code: output=a62303d5bb5e003f input=48d2d0a1e1a7e3c2]*/

/*[clinic end generated code]*/
{
    PyObject *result = NULL;
    HANDLE hThread = NULL;
    int err = 0;
    WCHAR buffer[8192];
    DWORD offset = 0;
    DWORD bytesRead;
    struct _query_data data = {0};

    if (PySys_Audit("_wmi.exec_query", "O", query) < 0) {
        return NULL;
    }

    data.query = PyUnicode_AsWideCharString(query, NULL);
    if (!data.query) {
        return NULL;
    }

    if (0 != _wcsnicmp(data.query, L"select ", 7)) {
        PyMem_Free((void *)data.query);
        PyErr_SetString(PyExc_ValueError, "only SELECT queries are supported");
        return NULL;
    }

    Py_BEGIN_ALLOW_THREADS

    data.initEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    data.connectEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if (!data.initEvent || !data.connectEvent ||
        !CreatePipe(&data.readPipe, &data.writePipe, NULL, 0))
    {
        err = GetLastError();
    } else {
        hThread = CreateThread(NULL, 0, _query_thread, (LPVOID*)&data, 0, NULL);
        if (!hThread) {
            err = GetLastError();
            // Normally the thread proc closes this handle, but since we never started
            // we need to close it here.
            CloseHandle(data.writePipe);
        }
    }

    // gh-112278: If current user doesn't have permission to query the WMI, the
    // function IWbemLocator::ConnectServer will hang for 5 seconds, and there
    // is no way to specify the timeout. So we use an Event object to simulate
    // a timeout.  The initEvent will be set after COM initialization, it will
    // take a longer time when first initialized.  The connectEvent will be set
    // after connected to WMI.
    if (!err) {
        err = wait_event(data.initEvent, 1000);
        if (!err) {
            err = wait_event(data.connectEvent, 100);
        }
    }

    while (!err) {
        if (ReadFile(
            data.readPipe,
            (LPVOID)&buffer[offset / sizeof(buffer[0])],
            sizeof(buffer) - offset,
            &bytesRead,
            NULL
        )) {
            offset += bytesRead;
            if (offset >= sizeof(buffer)) {
                err = ERROR_MORE_DATA;
            }
        } else {
            err = GetLastError();
        }
    }

    if (data.readPipe) {
        CloseHandle(data.readPipe);
    }

    if (hThread) {
        // Allow the thread some time to clean up
        int thread_err;
        switch (WaitForSingleObject(hThread, 100)) {
        case WAIT_OBJECT_0:
            // Thread ended cleanly
            if (!GetExitCodeThread(hThread, (LPDWORD)&thread_err)) {
                thread_err = GetLastError();
            }
            break;
        case WAIT_TIMEOUT:
            // Probably stuck - there's not much we can do, unfortunately
            thread_err = WAIT_TIMEOUT;
            break;
        default:
            thread_err = GetLastError();
            break;
        }
        // An error on our side is more likely to be relevant than one from
        // the thread, but if we don't have one on our side we'll take theirs.
        if (err == 0 || err == ERROR_BROKEN_PIPE) {
            err = thread_err;
        }

        CloseHandle(hThread);
    }

    CloseHandle(data.initEvent);
    CloseHandle(data.connectEvent);
    hThread = NULL;

    Py_END_ALLOW_THREADS

    PyMem_Free((void *)data.query);

    if (err == ERROR_MORE_DATA) {
        PyErr_Format(PyExc_OSError, "Query returns more than %zd characters", Py_ARRAY_LENGTH(buffer));
        return NULL;
    } else if (err) {
        PyErr_SetFromWindowsErr(err);
        return NULL;
    }

    if (!offset) {
        return PyUnicode_FromStringAndSize(NULL, 0);
    }
    return PyUnicode_FromWideChar(buffer, offset  / sizeof(buffer[0]) - 1);
}


static PyMethodDef wmi_functions[] = {
    _WMI_EXEC_QUERY_METHODDEF
    { NULL, NULL, 0, NULL }
};

static PyModuleDef_Slot wmi_slots[] = {
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL},
};

static PyModuleDef wmi_def = {
    PyModuleDef_HEAD_INIT,
    "_wmi",
    NULL,          // doc
    0,             // m_size
    wmi_functions, // m_methods
    wmi_slots,     // m_slots
};

extern "C" {
    PyMODINIT_FUNC PyInit__wmi(void)
    {
        return PyModuleDef_Init(&wmi_def);
    }
}


================================================
File: /PC/classicAppCompat.can.xml
================================================
<CustomCapabilityDescriptor xmlns="http://schemas.microsoft.com/appx/2016/sccd" xmlns:s="http://schemas.microsoft.com/appx/2016/sccd"><CustomCapabilities><CustomCapability Name="Microsoft.classicAppCompat_8wekyb3d8bbwe"></CustomCapability></CustomCapabilities><AuthorizedEntities><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.7_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.8_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.9_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.13_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.14_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.15_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.16_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.17_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.7_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.7_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.8_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.8_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.9_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.9_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.13_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.13_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.14_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.14_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.15_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.15_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.16_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.16_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.17_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity><AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.17_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity></AuthorizedEntities></CustomCapabilityDescriptor>

================================================
File: /PC/classicAppCompat.sccd
================================================
<?xml version="1.0" encoding="utf-8"?>
<CustomCapabilityDescriptor xmlns="http://schemas.microsoft.com/appx/2016/sccd" xmlns:s="http://schemas.microsoft.com/appx/2016/sccd">
	<CustomCapabilities>
		<CustomCapability Name="Microsoft.classicAppCompat_8wekyb3d8bbwe"></CustomCapability>
	</CustomCapabilities>
	<AuthorizedEntities>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.7_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.8_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.9_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.13_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.14_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.15_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.16_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.17_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.7_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.7_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.8_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.8_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.9_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.9_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.10_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.12_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.13_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.13_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.14_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.14_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.15_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.15_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.16_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.16_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.17_qbz5n2kfra8p0" CertificateSignatureHash="6045e624888e299179d5ae0ceda57c9874ff6ccf889fa14b2d50f751bfb9e2f8"></AuthorizedEntity>
		<AuthorizedEntity AppPackageFamilyName="PythonSoftwareFoundation.Python.3.17_qbz5n2kfra8p0" CertificateSignatureHash="279cd652c4e252bfbe5217ac722205d7729ba409148cfa9e6d9e5b1cb94eaff1"></AuthorizedEntity>
	</AuthorizedEntities>
	<Catalog>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</Catalog></CustomCapabilityDescriptor>


================================================
File: /PC/config.c
================================================
/* Module configuration */

/* This file contains the table of built-in modules.
    See create_builtin() in import.c. */

#include "Python.h"

extern PyObject* PyInit__abc(void);
extern PyObject* PyInit_array(void);
extern PyObject* PyInit_binascii(void);
extern PyObject* PyInit_cmath(void);
extern PyObject* PyInit_errno(void);
extern PyObject* PyInit_faulthandler(void);
extern PyObject* PyInit__tracemalloc(void);
extern PyObject* PyInit_gc(void);
extern PyObject* PyInit_math(void);
extern PyObject* PyInit__md5(void);
extern PyObject* PyInit_nt(void);
extern PyObject* PyInit__operator(void);
extern PyObject* PyInit__signal(void);
extern PyObject* PyInit__sha1(void);
extern PyObject* PyInit__sha2(void);
extern PyObject* PyInit__sha3(void);
extern PyObject* PyInit__statistics(void);
extern PyObject* PyInit__sysconfig(void);
extern PyObject* PyInit__typing(void);
extern PyObject* PyInit__blake2(void);
extern PyObject* PyInit_time(void);
extern PyObject* PyInit__thread(void);
#ifdef WIN32
extern PyObject* PyInit_msvcrt(void);
extern PyObject* PyInit__locale(void);
#endif
extern PyObject* PyInit__codecs(void);
extern PyObject* PyInit__weakref(void);
/* XXX: These two should really be extracted to standalone extensions. */
extern PyObject* PyInit_xxsubtype(void);
extern PyObject* PyInit__interpreters(void);
extern PyObject* PyInit__interpchannels(void);
extern PyObject* PyInit__interpqueues(void);
extern PyObject* PyInit__random(void);
extern PyObject* PyInit_itertools(void);
extern PyObject* PyInit__collections(void);
extern PyObject* PyInit__heapq(void);
extern PyObject* PyInit__bisect(void);
extern PyObject* PyInit__symtable(void);
extern PyObject* PyInit_mmap(void);
extern PyObject* PyInit__csv(void);
extern PyObject* PyInit__sre(void);
#if defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_SYSTEM) || defined(MS_WINDOWS_GAMES)
extern PyObject* PyInit_winreg(void);
#endif
extern PyObject* PyInit__struct(void);
extern PyObject* PyInit__datetime(void);
extern PyObject* PyInit__functools(void);
extern PyObject* PyInit__json(void);
#ifdef _Py_HAVE_ZLIB
extern PyObject* PyInit_zlib(void);
#endif

extern PyObject* PyInit__multibytecodec(void);
extern PyObject* PyInit__codecs_cn(void);
extern PyObject* PyInit__codecs_hk(void);
extern PyObject* PyInit__codecs_iso2022(void);
extern PyObject* PyInit__codecs_jp(void);
extern PyObject* PyInit__codecs_kr(void);
extern PyObject* PyInit__codecs_tw(void);
extern PyObject* PyInit__winapi(void);
extern PyObject* PyInit__lsprof(void);
extern PyObject* PyInit__ast(void);
extern PyObject* PyInit__io(void);
extern PyObject* PyInit__pickle(void);
extern PyObject* PyInit_atexit(void);
extern PyObject* _PyWarnings_Init(void);
extern PyObject* PyInit__string(void);
extern PyObject* PyInit__stat(void);
extern PyObject* PyInit__opcode(void);
extern PyObject* PyInit__contextvars(void);
extern PyObject* PyInit__tokenize(void);

/* tools/freeze/makeconfig.py marker for additional "extern" */
/* -- ADDMODULE MARKER 1 -- */

extern PyObject* PyMarshal_Init(void);
extern PyObject* PyInit__imp(void);

struct _inittab _PyImport_Inittab[] = {
    {"_abc", PyInit__abc},
    {"array", PyInit_array},
    {"_ast", PyInit__ast},
    {"binascii", PyInit_binascii},
    {"cmath", PyInit_cmath},
    {"errno", PyInit_errno},
    {"faulthandler", PyInit_faulthandler},
    {"gc", PyInit_gc},
    {"math", PyInit_math},
    {"nt", PyInit_nt}, /* Use the NT os functions, not posix */
    {"_operator", PyInit__operator},
    {"_signal", PyInit__signal},
    {"_md5", PyInit__md5},
    {"_sha1", PyInit__sha1},
    {"_sha2", PyInit__sha2},
    {"_sha3", PyInit__sha3},
    {"_blake2", PyInit__blake2},
    {"_sysconfig", PyInit__sysconfig},
    {"time", PyInit_time},
    {"_thread", PyInit__thread},
    {"_tokenize", PyInit__tokenize},
    {"_typing", PyInit__typing},
    {"_statistics", PyInit__statistics},
#ifdef WIN32
    {"msvcrt", PyInit_msvcrt},
    {"_locale", PyInit__locale},
#endif
    {"_tracemalloc", PyInit__tracemalloc},
    /* XXX Should _winapi go in a WIN32 block?  not WIN64? */
    {"_winapi", PyInit__winapi},

    {"_codecs", PyInit__codecs},
    {"_weakref", PyInit__weakref},
    {"_random", PyInit__random},
    {"_bisect", PyInit__bisect},
    {"_heapq", PyInit__heapq},
    {"_lsprof", PyInit__lsprof},
    {"itertools", PyInit_itertools},
    {"_collections", PyInit__collections},
    {"_symtable", PyInit__symtable},
#if defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_GAMES)
    {"mmap", PyInit_mmap},
#endif
    {"_csv", PyInit__csv},
    {"_sre", PyInit__sre},
#if defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_SYSTEM) || defined(MS_WINDOWS_GAMES)
    {"winreg", PyInit_winreg},
#endif
    {"_struct", PyInit__struct},
    {"_datetime", PyInit__datetime},
    {"_functools", PyInit__functools},
    {"_json", PyInit__json},

    {"xxsubtype", PyInit_xxsubtype},
    {"_interpreters", PyInit__interpreters},
    {"_interpchannels", PyInit__interpchannels},
    {"_interpqueues", PyInit__interpqueues},
#ifdef _Py_HAVE_ZLIB
    {"zlib", PyInit_zlib},
#endif

    /* CJK codecs */
    {"_multibytecodec", PyInit__multibytecodec},
    {"_codecs_cn", PyInit__codecs_cn},
    {"_codecs_hk", PyInit__codecs_hk},
    {"_codecs_iso2022", PyInit__codecs_iso2022},
    {"_codecs_jp", PyInit__codecs_jp},
    {"_codecs_kr", PyInit__codecs_kr},
    {"_codecs_tw", PyInit__codecs_tw},

/* tools/freeze/makeconfig.py marker for additional "_inittab" entries */
/* -- ADDMODULE MARKER 2 -- */

    /* This module "lives in" with marshal.c */
    {"marshal", PyMarshal_Init},

    /* This lives it with import.c */
    {"_imp", PyInit__imp},

    /* These entries are here for sys.builtin_module_names */
    {"builtins", NULL},
    {"sys", NULL},
    {"_warnings", _PyWarnings_Init},
    {"_string", PyInit__string},

    {"_io", PyInit__io},
    {"_pickle", PyInit__pickle},
    {"atexit", PyInit_atexit},
    {"_stat", PyInit__stat},
    {"_opcode", PyInit__opcode},

    {"_contextvars", PyInit__contextvars},

    /* Sentinel */
    {0, 0}
};


================================================
File: /PC/config_minimal.c
================================================
/* Module configuration */

/* This file contains the table of built-in modules.
    See create_builtin() in import.c. */

#include "Python.h"

#ifdef Py_ENABLE_SHARED
/* Define extern variables omitted from minimal builds */
void *PyWin_DLLhModule = NULL;
#endif


extern PyObject* PyInit_faulthandler(void);
extern PyObject* PyInit__tracemalloc(void);
extern PyObject* PyInit_gc(void);
extern PyObject* PyInit_nt(void);
extern PyObject* PyInit__signal(void);
#if defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_SYSTEM) || defined(MS_WINDOWS_GAMES)
extern PyObject* PyInit_winreg(void);
#endif

extern PyObject* PyInit__ast(void);
extern PyObject* PyInit__io(void);
extern PyObject* PyInit_atexit(void);
extern PyObject* _PyWarnings_Init(void);
extern PyObject* PyInit__string(void);
extern PyObject* PyInit__tokenize(void);

extern PyObject* PyMarshal_Init(void);
extern PyObject* PyInit__imp(void);

struct _inittab _PyImport_Inittab[] = {
    {"_ast", PyInit__ast},
    {"faulthandler", PyInit_faulthandler},
    {"gc", PyInit_gc},
    {"nt", PyInit_nt}, /* Use the NT os functions, not posix */
    {"_signal", PyInit__signal},
    {"_tokenize", PyInit__tokenize},
    {"_tracemalloc", PyInit__tracemalloc},

#if defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_SYSTEM) || defined(MS_WINDOWS_GAMES)
    {"winreg", PyInit_winreg},
#endif

    /* This module "lives in" with marshal.c */
    {"marshal", PyMarshal_Init},

    /* This lives it with import.c */
    {"_imp", PyInit__imp},

    /* These entries are here for sys.builtin_module_names */
    {"builtins", NULL},
    {"sys", NULL},
    {"_warnings", _PyWarnings_Init},
    {"_string", PyInit__string},

    {"_io", PyInit__io},
    {"atexit", PyInit_atexit},

    /* Sentinel */
    {0, 0}
};


================================================
File: /PC/crtlicense.txt
================================================


Additional Conditions for this Windows binary build
---------------------------------------------------

This program is linked with and uses Microsoft Distributable Code,
copyrighted by Microsoft Corporation. The Microsoft Distributable Code
is embedded in each .exe, .dll and .pyd file as a result of running
the code through a linker.

If you further distribute programs that include the Microsoft
Distributable Code, you must comply with the restrictions on
distribution specified by Microsoft. In particular, you must require
distributors and external end users to agree to terms that protect the
Microsoft Distributable Code at least as much as Microsoft's own
requirements for the Distributable Code. See Microsoft's documentation
(included in its developer tools and on its website at microsoft.com)
for specific details.

Redistribution of the Windows binary build of the Python interpreter
complies with this agreement, provided that you do not:

- alter any copyright, trademark or patent notice in Microsoft's
Distributable Code;

- use Microsoft's trademarks in your programs' names or in a way that
suggests your programs come from or are endorsed by Microsoft;

- distribute Microsoft's Distributable Code to run on a platform other
than Microsoft operating systems, run-time technologies or application
platforms; or

- include Microsoft Distributable Code in malicious, deceptive or
unlawful programs.

These restrictions apply only to the Microsoft Distributable Code as
defined above, not to Python itself or any programs running on the
Python interpreter. The redistribution of the Python interpreter and
libraries is governed by the Python Software License included with this
file, or by other licenses as marked.



================================================
File: /PC/dl_nt.c
================================================
/*

Entry point for the Windows NT DLL.

About the only reason for having this, is so initall() can automatically
be called, removing that burden (and possible source of frustration if
forgotten) from the programmer.

*/

#include "Python.h"
#include "windows.h"

#ifdef Py_ENABLE_SHARED

// Python Globals
HMODULE PyWin_DLLhModule = NULL;
const char *PyWin_DLLVersionString = MS_DLL_ID;

BOOL    WINAPI  DllMain (HANDLE hInst,
                                                ULONG ul_reason_for_call,
                                                LPVOID lpReserved)
{
    switch (ul_reason_for_call)
    {
        case DLL_PROCESS_ATTACH:
            PyWin_DLLhModule = hInst;
            break;

        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}

#endif /* Py_ENABLE_SHARED */


================================================
File: /PC/errmap.h
================================================
int
winerror_to_errno(int winerror)
{
    // Unwrap FACILITY_WIN32 HRESULT errors.
    if ((winerror & 0xFFFF0000) == 0x80070000) {
        winerror &= 0x0000FFFF;
    }

    // Winsock error codes (10000-11999) are errno values.
    if (winerror >= 10000 && winerror < 12000) {
        switch (winerror) {
        case WSAEINTR:
        case WSAEBADF:
        case WSAEACCES:
        case WSAEFAULT:
        case WSAEINVAL:
        case WSAEMFILE:
            // Winsock definitions of errno values. See WinSock2.h
            return winerror - 10000;
        default:
            return winerror;
        }
    }

    switch (winerror) {
    case ERROR_FILE_NOT_FOUND:            //    2
    case ERROR_PATH_NOT_FOUND:            //    3
    case ERROR_INVALID_DRIVE:             //   15
    case ERROR_NO_MORE_FILES:             //   18
    case ERROR_BAD_NETPATH:               //   53
    case ERROR_BAD_NET_NAME:              //   67
    case ERROR_BAD_PATHNAME:              //  161
    case ERROR_FILENAME_EXCED_RANGE:      //  206
        return ENOENT;

    case ERROR_BAD_ENVIRONMENT:           //   10
        return E2BIG;

    case ERROR_BAD_FORMAT:                //   11
    case ERROR_INVALID_STARTING_CODESEG:  //  188
    case ERROR_INVALID_STACKSEG:          //  189
    case ERROR_INVALID_MODULETYPE:        //  190
    case ERROR_INVALID_EXE_SIGNATURE:     //  191
    case ERROR_EXE_MARKED_INVALID:        //  192
    case ERROR_BAD_EXE_FORMAT:            //  193
    case ERROR_ITERATED_DATA_EXCEEDS_64k: //  194
    case ERROR_INVALID_MINALLOCSIZE:      //  195
    case ERROR_DYNLINK_FROM_INVALID_RING: //  196
    case ERROR_IOPL_NOT_ENABLED:          //  197
    case ERROR_INVALID_SEGDPL:            //  198
    case ERROR_AUTODATASEG_EXCEEDS_64k:   //  199
    case ERROR_RING2SEG_MUST_BE_MOVABLE:  //  200
    case ERROR_RELOC_CHAIN_XEEDS_SEGLIM:  //  201
    case ERROR_INFLOOP_IN_RELOC_CHAIN:    //  202
        return ENOEXEC;

    case ERROR_INVALID_HANDLE:            //    6
    case ERROR_INVALID_TARGET_HANDLE:     //  114
    case ERROR_DIRECT_ACCESS_HANDLE:      //  130
        return EBADF;

    case ERROR_WAIT_NO_CHILDREN:          //  128
    case ERROR_CHILD_NOT_COMPLETE:        //  129
        return ECHILD;

    case ERROR_NO_PROC_SLOTS:             //   89
    case ERROR_MAX_THRDS_REACHED:         //  164
    case ERROR_NESTING_NOT_ALLOWED:       //  215
        return EAGAIN;

    case ERROR_ARENA_TRASHED:             //    7
    case ERROR_NOT_ENOUGH_MEMORY:         //    8
    case ERROR_INVALID_BLOCK:             //    9
    case ERROR_NOT_ENOUGH_QUOTA:          // 1816
        return ENOMEM;

    case ERROR_ACCESS_DENIED:             //    5
    case ERROR_CURRENT_DIRECTORY:         //   16
    case ERROR_WRITE_PROTECT:             //   19
    case ERROR_BAD_UNIT:                  //   20
    case ERROR_NOT_READY:                 //   21
    case ERROR_BAD_COMMAND:               //   22
    case ERROR_CRC:                       //   23
    case ERROR_BAD_LENGTH:                //   24
    case ERROR_SEEK:                      //   25
    case ERROR_NOT_DOS_DISK:              //   26
    case ERROR_SECTOR_NOT_FOUND:          //   27
    case ERROR_OUT_OF_PAPER:              //   28
    case ERROR_WRITE_FAULT:               //   29
    case ERROR_READ_FAULT:                //   30
    case ERROR_GEN_FAILURE:               //   31
    case ERROR_SHARING_VIOLATION:         //   32
    case ERROR_LOCK_VIOLATION:            //   33
    case ERROR_WRONG_DISK:                //   34
    case ERROR_SHARING_BUFFER_EXCEEDED:   //   36
    case ERROR_NETWORK_ACCESS_DENIED:     //   65
    case ERROR_CANNOT_MAKE:               //   82
    case ERROR_FAIL_I24:                  //   83
    case ERROR_DRIVE_LOCKED:              //  108
    case ERROR_SEEK_ON_DEVICE:            //  132
    case ERROR_NOT_LOCKED:                //  158
    case ERROR_LOCK_FAILED:               //  167
    case 35:                              //   35 (undefined)
        return EACCES;

    case ERROR_FILE_EXISTS:               //   80
    case ERROR_ALREADY_EXISTS:            //  183
        return EEXIST;

    case ERROR_NOT_SAME_DEVICE:           //   17
        return EXDEV;

    case ERROR_DIRECTORY:                 //  267 (bpo-12802)
        return ENOTDIR;

    case ERROR_TOO_MANY_OPEN_FILES:       //    4
        return EMFILE;

    case ERROR_DISK_FULL:                 //  112
        return ENOSPC;

    case ERROR_BROKEN_PIPE:               //  109
    case ERROR_NO_DATA:                   //  232 (bpo-13063)
        return EPIPE;

    case ERROR_DIR_NOT_EMPTY:             //  145
        return ENOTEMPTY;

    case ERROR_NO_UNICODE_TRANSLATION:    // 1113
        return EILSEQ;

    case WAIT_TIMEOUT:                    //  258
        return ETIMEDOUT;

    case ERROR_INVALID_FUNCTION:          //    1
    case ERROR_INVALID_ACCESS:            //   12
    case ERROR_INVALID_DATA:              //   13
    case ERROR_INVALID_PARAMETER:         //   87
    case ERROR_NEGATIVE_SEEK:             //  131
    default:
        return EINVAL;
    }
}


================================================
File: /PC/frozen_dllmain.c
================================================
/* FreezeDLLMain.cpp

This is a DLLMain suitable for frozen applications/DLLs on
a Windows platform.

The general problem is that many Python extension modules may define
DLL main functions, but when statically linked together to form
a frozen application, this DLLMain symbol exists multiple times.

The solution is:
* Each module checks for a frozen build, and if so, defines its DLLMain
  function as "__declspec(dllexport) DllMain%module%"
  (eg, DllMainpythoncom, or DllMainpywintypes)

* The frozen .EXE/.DLL links against this module, which provides
  the single DllMain.

* This DllMain attempts to locate and call the DllMain for each
  of the extension modules.

* This code also has hooks to "simulate" DllMain when used from
  a frozen .EXE.

At this stage, there is a static table of "possibly embedded modules".
This should change to something better, but it will work OK for now.

Note that this scheme does not handle dependencies in the order
of DllMain calls - except it does call pywintypes first :-)

As an example of how an extension module with a DllMain should be
changed, here is a snippet from the pythoncom extension module.

  // end of example code from pythoncom's DllMain.cpp
  #ifndef BUILD_FREEZE
  #define DLLMAIN DllMain
  #define DLLMAIN_DECL
  #else
  #define DLLMAIN DllMainpythoncom
  #define DLLMAIN_DECL __declspec(dllexport)
  #endif

  extern "C" DLLMAIN_DECL
  BOOL WINAPI DLLMAIN(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
  // end of example code from pythoncom's DllMain.cpp

***************************************************************************/
#include "windows.h"

static char *possibleModules[] = {
    "pywintypes",
    "pythoncom",
    "win32ui",
    NULL,
};

BOOL CallModuleDllMain(char *modName, DWORD dwReason);


/*
  Called by a frozen .EXE only, so that built-in extension
  modules are initialized correctly
*/
void PyWinFreeze_ExeInit(void)
{
    char **modName;
    for (modName = possibleModules;*modName;*modName++) {
/*              printf("Initialising '%s'\n", *modName); */
        CallModuleDllMain(*modName, DLL_PROCESS_ATTACH);
    }
}

/*
  Called by a frozen .EXE only, so that built-in extension
  modules are cleaned up
*/
void PyWinFreeze_ExeTerm(void)
{
    // Must go backwards
    char **modName;
    for (modName = possibleModules+Py_ARRAY_LENGTH(possibleModules)-2;
         modName >= possibleModules;
         *modName--) {
/*              printf("Terminating '%s'\n", *modName);*/
        CallModuleDllMain(*modName, DLL_PROCESS_DETACH);
    }
}

BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    BOOL ret = TRUE;
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
        {
            char **modName;
            for (modName = possibleModules;*modName;*modName++) {
                BOOL ok = CallModuleDllMain(*modName, dwReason);
                if (!ok)
                    ret = FALSE;
            }
            break;
        }
        case DLL_PROCESS_DETACH:
        {
            // Must go backwards
            char **modName;
            for (modName = possibleModules+Py_ARRAY_LENGTH(possibleModules)-2;
                 modName >= possibleModules;
                 *modName--)
                CallModuleDllMain(*modName, DLL_PROCESS_DETACH);
            break;
        }
    }
    return ret;
}

BOOL CallModuleDllMain(char *modName, DWORD dwReason)
{
    BOOL (WINAPI * pfndllmain)(HINSTANCE, DWORD, LPVOID);

    char funcName[255];
    HMODULE hmod = GetModuleHandleW(NULL);
    strcpy(funcName, "_DllMain");
    strcat(funcName, modName);
    strcat(funcName, "@12"); // stdcall convention.
    pfndllmain = (BOOL (WINAPI *)(HINSTANCE, DWORD, LPVOID))GetProcAddress(hmod, funcName);
    if (pfndllmain==NULL) {
        /* No function by that name exported - then that module does
           not appear in our frozen program - return OK
        */
        return TRUE;
    }
    return (*pfndllmain)(hmod, dwReason, NULL);
}



================================================
File: /PC/invalid_parameter_handler.c
================================================
#ifdef _MSC_VER

#include <stdlib.h>

#if _MSC_VER >= 1900
/* pyconfig.h uses this function in the _Py_BEGIN/END_SUPPRESS_IPH
 * macros. It does not need to be defined when building using MSVC
 * earlier than 14.0 (_MSC_VER == 1900).
 */

static void __cdecl _silent_invalid_parameter_handler(
    wchar_t const* expression,
    wchar_t const* function,
    wchar_t const* file,
    unsigned int line,
    uintptr_t pReserved) { }

_invalid_parameter_handler _Py_silent_invalid_parameter_handler = _silent_invalid_parameter_handler;

#endif

#endif


================================================
File: /PC/launcher-usage.txt
================================================
Python Launcher for Windows Version %s

usage:
%s [launcher-args] [python-args] [script [script-args]]

Launcher arguments:
-2     : Launch the latest Python 2.x version
-3     : Launch the latest Python 3.x version
-X.Y   : Launch the specified Python version

The above default to an architecture native runtime, but will select any
available. Add a "-32" to the argument to only launch 32-bit runtimes,
or add "-64" to omit 32-bit runtimes (this latter option is deprecated).

To select a specific runtime, use the -V: options.

-V:TAG         : Launch a Python runtime with the specified tag
-V:COMPANY/TAG : Launch a Python runtime from the specified company and
                 with the specified tag

-0  --list       : List the available pythons
-0p --list-paths : List with paths

If no options are given but a script is specified, the script is checked for a
shebang line. Otherwise, an active virtual environment or global default will
be selected.

See https://docs.python.org/using/windows.html#python-launcher-for-windows for
additional configuration.

The following help text is from Python:


================================================
File: /PC/msvcrtmodule.c
================================================
/*********************************************************

    msvcrtmodule.c

    A Python interface to the Microsoft Visual C Runtime
    Library, providing access to those non-portable, but
    still useful routines.

    Only ever compiled with an MS compiler, so no attempt
    has been made to avoid MS language extensions, etc...

    This may only work on NT or 95...

    Author: Mark Hammond and Guido van Rossum.
    Maintenance: Guido van Rossum.

***********************************************************/

#include "Python.h"
#include "pycore_fileutils.h"     // _Py_BEGIN_SUPPRESS_IPH
#include "malloc.h"
#include <io.h>
#include <conio.h>
#include <sys/locking.h>
#include <crtdbg.h>
#include <windows.h>

#ifdef _MSC_VER
#if _MSC_VER >= 1500 && _MSC_VER < 1600
#include <crtassem.h>
#elif _MSC_VER >= 1600
#include <crtversion.h>
#endif
#endif

/*[python input]
class HANDLE_converter(CConverter):
    type = 'void *'
    format_unit = '"_Py_PARSE_UINTPTR"'

    def parse_arg(self, argname, displayname, *, limited_capi):
        return self.format_code("""
            {paramname} = PyLong_AsVoidPtr({argname});
            if (!{paramname} && PyErr_Occurred()) {{{{
                goto exit;
            }}}}
            """,
            argname=argname)

class HANDLE_return_converter(CReturnConverter):
    type = 'void *'

    def render(self, function, data):
        self.declare(data)
        self.err_occurred_if(
            "_return_value == NULL || _return_value == INVALID_HANDLE_VALUE",
            data)
        data.return_conversion.append(
            'return_value = PyLong_FromVoidPtr(_return_value);\n')

class byte_char_return_converter(CReturnConverter):
    type = 'int'

    def render(self, function, data):
        data.declarations.append('char s[1];')
        data.return_value = 's[0]'
        data.return_conversion.append(
            'return_value = PyBytes_FromStringAndSize(s, 1);\n')

class wchar_t_return_converter(CReturnConverter):
    type = 'wchar_t'

    def render(self, function, data):
        self.declare(data)
        data.return_conversion.append(
            'return_value = PyUnicode_FromOrdinal(_return_value);\n')
[python start generated code]*/
/*[python end generated code: output=da39a3ee5e6b4b0d input=ff031be44ab3250d]*/

/*[clinic input]
module msvcrt
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=f31a87a783d036cd]*/

#include "clinic/msvcrtmodule.c.h"

/*[clinic input]
msvcrt.heapmin

Minimize the malloc() heap.

Force the malloc() heap to clean itself up and return unused blocks
to the operating system. On failure, this raises OSError.
[clinic start generated code]*/

static PyObject *
msvcrt_heapmin_impl(PyObject *module)
/*[clinic end generated code: output=1ba00f344782dc19 input=82e1771d21bde2d8]*/
{
    if (_heapmin() != 0)
        return PyErr_SetFromErrno(PyExc_OSError);

    Py_RETURN_NONE;
}
/*[clinic input]
msvcrt.locking

    fd: int
    mode: int
    nbytes: long
    /

Lock part of a file based on file descriptor fd from the C runtime.

Raises OSError on failure. The locked region of the file extends from
the current file position for nbytes bytes, and may continue beyond
the end of the file. mode must be one of the LK_* constants listed
below. Multiple regions in a file may be locked at the same time, but
may not overlap. Adjacent regions are not merged; they must be unlocked
individually.
[clinic start generated code]*/

static PyObject *
msvcrt_locking_impl(PyObject *module, int fd, int mode, long nbytes)
/*[clinic end generated code: output=a4a90deca9785a03 input=e97bd15fc4a04fef]*/
{
    int err;

    if (PySys_Audit("msvcrt.locking", "iil", fd, mode, nbytes) < 0) {
        return NULL;
    }

    Py_BEGIN_ALLOW_THREADS
    _Py_BEGIN_SUPPRESS_IPH
    err = _locking(fd, mode, nbytes);
    _Py_END_SUPPRESS_IPH
    Py_END_ALLOW_THREADS
    if (err != 0)
        return PyErr_SetFromErrno(PyExc_OSError);

    Py_RETURN_NONE;
}

/*[clinic input]
msvcrt.setmode -> long

    fd: int
    mode as flags: int
    /

Set the line-end translation mode for the file descriptor fd.

To set it to text mode, flags should be os.O_TEXT; for binary, it
should be os.O_BINARY.

Return value is the previous mode.
[clinic start generated code]*/

static long
msvcrt_setmode_impl(PyObject *module, int fd, int flags)
/*[clinic end generated code: output=24a9be5ea07ccb9b input=76e7c01f6b137f75]*/
{
    _Py_BEGIN_SUPPRESS_IPH
    flags = _setmode(fd, flags);
    _Py_END_SUPPRESS_IPH
    if (flags == -1)
        PyErr_SetFromErrno(PyExc_OSError);

    return flags;
}

/*[clinic input]
msvcrt.open_osfhandle -> long

    handle: HANDLE
    flags: int
    /

Create a C runtime file descriptor from the file handle handle.

The flags parameter should be a bitwise OR of os.O_APPEND, os.O_RDONLY,
and os.O_TEXT. The returned file descriptor may be used as a parameter
to os.fdopen() to create a file object.
[clinic start generated code]*/

static long
msvcrt_open_osfhandle_impl(PyObject *module, void *handle, int flags)
/*[clinic end generated code: output=b2fb97c4b515e4e6 input=d5db190a307cf4bb]*/
{
    if (PySys_Audit("msvcrt.open_osfhandle", "Ki", handle, flags) < 0) {
        return -1;
    }

    return _Py_open_osfhandle(handle, flags);
}

/*[clinic input]
msvcrt.get_osfhandle -> HANDLE

    fd: int
    /

Return the file handle for the file descriptor fd.

Raises OSError if fd is not recognized.
[clinic start generated code]*/

static void *
msvcrt_get_osfhandle_impl(PyObject *module, int fd)
/*[clinic end generated code: output=aca01dfe24637374 input=5fcfde9b17136aa2]*/
{
    if (PySys_Audit("msvcrt.get_osfhandle", "(i)", fd) < 0) {
        return NULL;
    }

    return _Py_get_osfhandle(fd);
}

/* Console I/O */
/*[clinic input]
msvcrt.kbhit -> long

Returns a nonzero value if a keypress is waiting to be read. Otherwise, return 0.
[clinic start generated code]*/

static long
msvcrt_kbhit_impl(PyObject *module)
/*[clinic end generated code: output=940dfce6587c1890 input=d0f4cb3289ff51e2]*/
{
    return _kbhit();
}

/*[clinic input]
msvcrt.getch -> byte_char

Read a keypress and return the resulting character as a byte string.

Nothing is echoed to the console. This call will block if a keypress is
not already available, but will not wait for Enter to be pressed. If the
pressed key was a special function key, this will return '\000' or
'\xe0'; the next call will return the keycode. The Control-C keypress
cannot be read with this function.
[clinic start generated code]*/

static int
msvcrt_getch_impl(PyObject *module)
/*[clinic end generated code: output=a4e51f0565064a7d input=37a40cf0ed0d1153]*/
{
    int ch;

    Py_BEGIN_ALLOW_THREADS
    ch = _getch();
    Py_END_ALLOW_THREADS
    return ch;
}

#ifdef MS_WINDOWS_DESKTOP

/*[clinic input]
msvcrt.getwch -> wchar_t

Wide char variant of getch(), returning a Unicode value.
[clinic start generated code]*/

static wchar_t
msvcrt_getwch_impl(PyObject *module)
/*[clinic end generated code: output=be9937494e22f007 input=27b3dec8ad823d7c]*/
{
    wchar_t ch;

    Py_BEGIN_ALLOW_THREADS
    ch = _getwch();
    Py_END_ALLOW_THREADS
    return ch;
}

#endif /* MS_WINDOWS_DESKTOP */

/*[clinic input]
msvcrt.getche -> byte_char

Similar to getch(), but the keypress will be echoed if possible.
[clinic start generated code]*/

static int
msvcrt_getche_impl(PyObject *module)
/*[clinic end generated code: output=d8f7db4fd2990401 input=43311ade9ed4a9c0]*/
{
    int ch;

    Py_BEGIN_ALLOW_THREADS
    ch = _getche();
    Py_END_ALLOW_THREADS
    return ch;
}

#ifdef MS_WINDOWS_DESKTOP

/*[clinic input]
msvcrt.getwche -> wchar_t

Wide char variant of getche(), returning a Unicode value.
[clinic start generated code]*/

static wchar_t
msvcrt_getwche_impl(PyObject *module)
/*[clinic end generated code: output=d0dae5ba3829d596 input=49337d59d1a591f8]*/
{
    wchar_t ch;

    Py_BEGIN_ALLOW_THREADS
    ch = _getwche();
    Py_END_ALLOW_THREADS
    return ch;
}

#endif /* MS_WINDOWS_DESKTOP */

/*[clinic input]
msvcrt.putch

    char: char
    /

Print the byte string char to the console without buffering.
[clinic start generated code]*/

static PyObject *
msvcrt_putch_impl(PyObject *module, char char_value)
/*[clinic end generated code: output=92ec9b81012d8f60 input=ec078dd10cb054d6]*/
{
    _Py_BEGIN_SUPPRESS_IPH
    _putch(char_value);
    _Py_END_SUPPRESS_IPH
    Py_RETURN_NONE;
}

#ifdef MS_WINDOWS_DESKTOP

/*[clinic input]
msvcrt.putwch

    unicode_char: int(accept={str})
    /

Wide char variant of putch(), accepting a Unicode value.
[clinic start generated code]*/

static PyObject *
msvcrt_putwch_impl(PyObject *module, int unicode_char)
/*[clinic end generated code: output=a3bd1a8951d28eee input=996ccd0bbcbac4c3]*/
{
    _Py_BEGIN_SUPPRESS_IPH
    _putwch(unicode_char);
    _Py_END_SUPPRESS_IPH
    Py_RETURN_NONE;

}

#endif /* MS_WINDOWS_DESKTOP */

/*[clinic input]
msvcrt.ungetch

    char: char
    /

Opposite of getch.

Cause the byte string char to be "pushed back" into the
console buffer; it will be the next character read by
getch() or getche().
[clinic start generated code]*/

static PyObject *
msvcrt_ungetch_impl(PyObject *module, char char_value)
/*[clinic end generated code: output=c6942a0efa119000 input=22f07ee9001bbf0f]*/
{
    int res;

    _Py_BEGIN_SUPPRESS_IPH
    res = _ungetch(char_value);
    _Py_END_SUPPRESS_IPH

    if (res == EOF)
        return PyErr_SetFromErrno(PyExc_OSError);
    Py_RETURN_NONE;
}

#ifdef MS_WINDOWS_DESKTOP

/*[clinic input]
msvcrt.ungetwch

    unicode_char: int(accept={str})
    /

Wide char variant of ungetch(), accepting a Unicode value.
[clinic start generated code]*/

static PyObject *
msvcrt_ungetwch_impl(PyObject *module, int unicode_char)
/*[clinic end generated code: output=e63af05438b8ba3d input=83ec0492be04d564]*/
{
    int res;

    _Py_BEGIN_SUPPRESS_IPH
    res = _ungetwch(unicode_char);
    _Py_END_SUPPRESS_IPH

    if (res == WEOF)
        return PyErr_SetFromErrno(PyExc_OSError);
    Py_RETURN_NONE;
}

#endif /* MS_WINDOWS_DESKTOP */

#ifdef _DEBUG
/*[clinic input]
msvcrt.CrtSetReportFile -> HANDLE

    type: int
    file: HANDLE
    /

Wrapper around _CrtSetReportFile.

Only available on Debug builds.
[clinic start generated code]*/

static void *
msvcrt_CrtSetReportFile_impl(PyObject *module, int type, void *file)
/*[clinic end generated code: output=9393e8c77088bbe9 input=290809b5f19e65b9]*/
{
    HANDLE res;

    _Py_BEGIN_SUPPRESS_IPH
    res = _CrtSetReportFile(type, file);
    _Py_END_SUPPRESS_IPH

    return res;
}

/*[clinic input]
msvcrt.CrtSetReportMode -> long

    type: int
    mode: int
    /

Wrapper around _CrtSetReportMode.

Only available on Debug builds.
[clinic start generated code]*/

static long
msvcrt_CrtSetReportMode_impl(PyObject *module, int type, int mode)
/*[clinic end generated code: output=b2863761523de317 input=9319d29b4319426b]*/
{
    int res;

    _Py_BEGIN_SUPPRESS_IPH
    res = _CrtSetReportMode(type, mode);
    _Py_END_SUPPRESS_IPH
    if (res == -1)
        PyErr_SetFromErrno(PyExc_OSError);
    return res;
}

/*[clinic input]
msvcrt.set_error_mode -> long

    mode: int
    /

Wrapper around _set_error_mode.

Only available on Debug builds.
[clinic start generated code]*/

static long
msvcrt_set_error_mode_impl(PyObject *module, int mode)
/*[clinic end generated code: output=ac4a09040d8ac4e3 input=046fca59c0f20872]*/
{
    long res;

    _Py_BEGIN_SUPPRESS_IPH
    res = _set_error_mode(mode);
    _Py_END_SUPPRESS_IPH

    return res;
}
#endif /* _DEBUG */

#if defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_APP) || defined(MS_WINDOWS_SYSTEM)

/*[clinic input]
msvcrt.GetErrorMode

Wrapper around GetErrorMode.
[clinic start generated code]*/

static PyObject *
msvcrt_GetErrorMode_impl(PyObject *module)
/*[clinic end generated code: output=3103fc6145913591 input=5a7fb083b6dd71fd]*/
{
    unsigned int res;

    _Py_BEGIN_SUPPRESS_IPH
    res = GetErrorMode();
    _Py_END_SUPPRESS_IPH

    return PyLong_FromUnsignedLong(res);
}

#endif /* MS_WINDOWS_APP || MS_WINDOWS_SYSTEM */

/*[clinic input]
msvcrt.SetErrorMode

    mode: unsigned_int(bitwise=True)
    /

Wrapper around SetErrorMode.
[clinic start generated code]*/

static PyObject *
msvcrt_SetErrorMode_impl(PyObject *module, unsigned int mode)
/*[clinic end generated code: output=01d529293f00da8f input=d8b167258d32d907]*/
{
    unsigned int res;

    _Py_BEGIN_SUPPRESS_IPH
    res = SetErrorMode(mode);
    _Py_END_SUPPRESS_IPH

    return PyLong_FromUnsignedLong(res);
}

/*[clinic input]
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=da39a3ee5e6b4b0d]*/

/* List of functions exported by this module */
static struct PyMethodDef msvcrt_functions[] = {
    MSVCRT_HEAPMIN_METHODDEF
    MSVCRT_LOCKING_METHODDEF
    MSVCRT_SETMODE_METHODDEF
    MSVCRT_OPEN_OSFHANDLE_METHODDEF
    MSVCRT_GET_OSFHANDLE_METHODDEF
    MSVCRT_KBHIT_METHODDEF
    MSVCRT_GETCH_METHODDEF
    MSVCRT_GETCHE_METHODDEF
    MSVCRT_PUTCH_METHODDEF
    MSVCRT_UNGETCH_METHODDEF
    MSVCRT_GETERRORMODE_METHODDEF
    MSVCRT_SETERRORMODE_METHODDEF
    MSVCRT_CRTSETREPORTFILE_METHODDEF
    MSVCRT_CRTSETREPORTMODE_METHODDEF
    MSVCRT_SET_ERROR_MODE_METHODDEF
    MSVCRT_GETWCH_METHODDEF
    MSVCRT_GETWCHE_METHODDEF
    MSVCRT_PUTWCH_METHODDEF
    MSVCRT_UNGETWCH_METHODDEF
    {NULL,                      NULL}
};

static int
insertptr(PyObject *mod, const char *name, void *value)
{
    return PyModule_Add(mod, name, PyLong_FromVoidPtr(value));
}

#define INSERTINT(MOD, NAME, VAL) do {                  \
    if (PyModule_AddIntConstant(MOD, NAME, VAL) < 0) {  \
        return -1;                                      \
    }                                                   \
} while (0)

#define INSERTPTR(MOD, NAME, PTR) do {      \
    if (insertptr(MOD, NAME, PTR) < 0) {    \
        return -1;                          \
    }                                       \
} while (0)

#define INSERTSTR(MOD, NAME, CONST) do {                    \
    if (PyModule_AddStringConstant(MOD, NAME, CONST) < 0) { \
        return -1;                                          \
    }                                                       \
} while (0)

static int
exec_module(PyObject* m)
{
    /* constants for the locking() function's mode argument */
    INSERTINT(m, "LK_LOCK", _LK_LOCK);
    INSERTINT(m, "LK_NBLCK", _LK_NBLCK);
    INSERTINT(m, "LK_NBRLCK", _LK_NBRLCK);
    INSERTINT(m, "LK_RLCK", _LK_RLCK);
    INSERTINT(m, "LK_UNLCK", _LK_UNLCK);
#ifdef MS_WINDOWS_DESKTOP
    INSERTINT(m, "SEM_FAILCRITICALERRORS", SEM_FAILCRITICALERRORS);
    INSERTINT(m, "SEM_NOALIGNMENTFAULTEXCEPT", SEM_NOALIGNMENTFAULTEXCEPT);
    INSERTINT(m, "SEM_NOGPFAULTERRORBOX", SEM_NOGPFAULTERRORBOX);
    INSERTINT(m, "SEM_NOOPENFILEERRORBOX", SEM_NOOPENFILEERRORBOX);
#endif
#ifdef _DEBUG
    INSERTINT(m, "CRT_WARN", _CRT_WARN);
    INSERTINT(m, "CRT_ERROR", _CRT_ERROR);
    INSERTINT(m, "CRT_ASSERT", _CRT_ASSERT);
    INSERTINT(m, "CRTDBG_MODE_DEBUG", _CRTDBG_MODE_DEBUG);
    INSERTINT(m, "CRTDBG_MODE_FILE", _CRTDBG_MODE_FILE);
    INSERTINT(m, "CRTDBG_MODE_WNDW", _CRTDBG_MODE_WNDW);
    INSERTINT(m, "CRTDBG_REPORT_MODE", _CRTDBG_REPORT_MODE);
    INSERTPTR(m, "CRTDBG_FILE_STDERR", _CRTDBG_FILE_STDERR);
    INSERTPTR(m, "CRTDBG_FILE_STDOUT", _CRTDBG_FILE_STDOUT);
    INSERTPTR(m, "CRTDBG_REPORT_FILE", _CRTDBG_REPORT_FILE);
    INSERTINT(m, "OUT_TO_DEFAULT", _OUT_TO_DEFAULT);
    INSERTINT(m, "OUT_TO_STDERR", _OUT_TO_STDERR);
    INSERTINT(m, "OUT_TO_MSGBOX", _OUT_TO_MSGBOX);
    INSERTINT(m, "REPORT_ERRMODE", _REPORT_ERRMODE);
#endif

#undef INSERTINT
#undef INSERTPTR

    /* constants for the crt versions */
#ifdef _VC_ASSEMBLY_PUBLICKEYTOKEN
    INSERTSTR(m, "VC_ASSEMBLY_PUBLICKEYTOKEN", _VC_ASSEMBLY_PUBLICKEYTOKEN);
#endif
#ifdef _CRT_ASSEMBLY_VERSION
    INSERTSTR(m, "CRT_ASSEMBLY_VERSION", _CRT_ASSEMBLY_VERSION);
#endif
#ifdef __LIBRARIES_ASSEMBLY_NAME_PREFIX
    INSERTSTR(m, "LIBRARIES_ASSEMBLY_NAME_PREFIX",
              __LIBRARIES_ASSEMBLY_NAME_PREFIX);
#endif

#undef INSERTSTR

    /* constants for the 2010 crt versions */
#if defined(_VC_CRT_MAJOR_VERSION) && defined (_VC_CRT_MINOR_VERSION) && defined(_VC_CRT_BUILD_VERSION) && defined(_VC_CRT_RBUILD_VERSION)
    PyObject *version = PyUnicode_FromFormat("%d.%d.%d.%d",
                                             _VC_CRT_MAJOR_VERSION,
                                             _VC_CRT_MINOR_VERSION,
                                             _VC_CRT_BUILD_VERSION,
                                             _VC_CRT_RBUILD_VERSION);
    if (PyModule_Add(m, "CRT_ASSEMBLY_VERSION", version) < 0) {
        return -1;
    }
#endif

    return 0;
}

static PyModuleDef_Slot msvcrt_slots[] = {
    {Py_mod_exec, exec_module},
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL}
};

static struct PyModuleDef msvcrtmodule = {
    .m_base = PyModuleDef_HEAD_INIT,
    .m_name = "msvcrt",
    .m_methods = msvcrt_functions,
    .m_slots = msvcrt_slots,
};

PyMODINIT_FUNC
PyInit_msvcrt(void)
{
    return PyModuleDef_Init(&msvcrtmodule);
}


================================================
File: /PC/pyconfig.h.in
================================================
#ifndef Py_CONFIG_H
#define Py_CONFIG_H

/* pyconfig.h.  NOT Generated automatically by configure.

This is a manually maintained version used for the Watcom,
Borland and Microsoft Visual C++ compilers.  It is a
standard part of the Python distribution.

WINDOWS DEFINES:
The code specific to Windows should be wrapped around one of
the following #defines

MS_WIN64 - Code specific to the MS Win64 API
MS_WIN32 - Code specific to the MS Win32 (and Win64) API (obsolete, this covers all supported APIs)
MS_WINDOWS - Code specific to Windows, but all versions.
Py_ENABLE_SHARED - Code if the Python core is built as a DLL.

Also note that neither "_M_IX86" or "_MSC_VER" should be used for
any purpose other than "Windows Intel x86 specific" and "Microsoft
compiler specific".  Therefore, these should be very rare.


NOTE: The following symbols are deprecated:
NT, USE_DL_EXPORT, USE_DL_IMPORT, DL_EXPORT, DL_IMPORT
MS_CORE_DLL.

WIN32 is still required for the locale module.

*/

/* Deprecated USE_DL_EXPORT macro - please use Py_BUILD_CORE */
#ifdef USE_DL_EXPORT
#       define Py_BUILD_CORE
#endif /* USE_DL_EXPORT */

/* Visual Studio 2005 introduces deprecation warnings for
   "insecure" and POSIX functions. The insecure functions should
   be replaced by *_s versions (according to Microsoft); the
   POSIX functions by _* versions (which, according to Microsoft,
   would be ISO C conforming). Neither renaming is feasible, so
   we just silence the warnings. */

#ifndef _CRT_SECURE_NO_DEPRECATE
#define _CRT_SECURE_NO_DEPRECATE 1
#endif
#ifndef _CRT_NONSTDC_NO_DEPRECATE
#define _CRT_NONSTDC_NO_DEPRECATE 1
#endif

#define HAVE_IO_H
#define HAVE_SYS_UTIME_H
#define HAVE_TEMPNAM
#define HAVE_TMPFILE
#define HAVE_TMPNAM
#define HAVE_CLOCK
#define HAVE_STRERROR

#include <io.h>

#define HAVE_STRFTIME
#define DONT_HAVE_SIG_ALARM
#define DONT_HAVE_SIG_PAUSE
#define LONG_BIT        32
#define WORD_BIT 32

#define MS_WIN32 /* only support win32 and greater. */
#define MS_WINDOWS
#define NT_THREADS
#define WITH_THREAD
#ifndef NETSCAPE_PI
#define USE_SOCKET
#endif

#if defined(Py_BUILD_CORE) || defined(Py_BUILD_CORE_BUILTIN) || defined(Py_BUILD_CORE_MODULE)
#include <winapifamily.h>

#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP)
#define MS_WINDOWS_DESKTOP
#endif
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
#define MS_WINDOWS_APP
#endif
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_SYSTEM)
#define MS_WINDOWS_SYSTEM
#endif
#if WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_GAMES)
#define MS_WINDOWS_GAMES
#endif

/* Define to 1 if you support windows console io */
#if defined(MS_WINDOWS_DESKTOP) || defined(MS_WINDOWS_APP) || defined(MS_WINDOWS_SYSTEM)
#define HAVE_WINDOWS_CONSOLE_IO 1
#endif
#endif /* Py_BUILD_CORE || Py_BUILD_CORE_BUILTIN || Py_BUILD_CORE_MODULE */

/* Define to 1 if you want to disable the GIL */
/* Uncomment the definition for free-threaded builds, or define it manually
 * when compiling extension modules. Note that we test with #ifdef, so
 * defining as 0 will still disable the GIL. */
#ifndef Py_GIL_DISABLED
/* #define Py_GIL_DISABLED 1 */
#endif

/* Compiler specific defines */

/* ------------------------------------------------------------------------*/
/* Microsoft C defines _MSC_VER, as does clang-cl.exe */
#ifdef _MSC_VER

/* We want COMPILER to expand to a string containing _MSC_VER's *value*.
 * This is horridly tricky, because the stringization operator only works
 * on macro arguments, and doesn't evaluate macros passed *as* arguments.
 */
#define _Py_PASTE_VERSION(SUFFIX) \
        ("[MSC v." _Py_STRINGIZE(_MSC_VER) " " SUFFIX "]")
/* e.g., this produces, after compile-time string catenation,
 *      ("[MSC v.1900 64 bit (Intel)]")
 *
 * _Py_STRINGIZE(_MSC_VER) expands to
 * _Py_STRINGIZE1(_MSC_VER) and this second macro call is scanned
 *      again for macros and so further expands to
 * _Py_STRINGIZE1(1900) which then expands to
 * "1900"
 */
#define _Py_STRINGIZE(X) _Py_STRINGIZE1(X)
#define _Py_STRINGIZE1(X) #X

/* MSVC defines _WINxx to differentiate the windows platform types

   Note that for compatibility reasons _WIN32 is defined on Win32
   *and* on Win64. For the same reasons, in Python, MS_WIN32 is
   defined on Win32 *and* Win64. Win32 only code must therefore be
   guarded as follows:
        #if defined(MS_WIN32) && !defined(MS_WIN64)
*/
#ifdef _WIN64
#define MS_WIN64
#endif

/* set the COMPILER and support tier
 *
 * win_amd64 MSVC (x86_64-pc-windows-msvc): 1
 * win32 MSVC (i686-pc-windows-msvc): 1
 * win_arm64 MSVC (aarch64-pc-windows-msvc): 3
 * other archs and ICC: 0
 */
#ifdef MS_WIN64
#if defined(_M_X64) || defined(_M_AMD64)
#if defined(__clang__)
#define COMPILER ("[Clang " __clang_version__ "] 64 bit (AMD64) with MSC v." _Py_STRINGIZE(_MSC_VER) " CRT]")
#define PY_SUPPORT_TIER 0
#elif defined(__INTEL_COMPILER)
#define COMPILER ("[ICC v." _Py_STRINGIZE(__INTEL_COMPILER) " 64 bit (amd64) with MSC v." _Py_STRINGIZE(_MSC_VER) " CRT]")
#define PY_SUPPORT_TIER 0
#else
#define COMPILER _Py_PASTE_VERSION("64 bit (AMD64)")
#define PY_SUPPORT_TIER 1
#endif /* __clang__ */
#define PYD_PLATFORM_TAG "win_amd64"
#elif defined(_M_ARM64)
#define COMPILER _Py_PASTE_VERSION("64 bit (ARM64)")
#define PY_SUPPORT_TIER 3
#define PYD_PLATFORM_TAG "win_arm64"
#else
#define COMPILER _Py_PASTE_VERSION("64 bit (Unknown)")
#define PY_SUPPORT_TIER 0
#endif
#endif /* MS_WIN64 */

/* set the version macros for the windows headers */
/* Python 3.13+ requires Windows 10 or greater */
#define Py_WINVER 0x0A00 /* _WIN32_WINNT_WIN10 */
#define Py_NTDDI NTDDI_WIN10

/* We only set these values when building Python - we don't want to force
   these values on extensions, as that will affect the prototypes and
   structures exposed in the Windows headers. Even when building Python, we
   allow a single source file to override this - they may need access to
   structures etc so it can optionally use new Windows features if it
   determines at runtime they are available.
*/
#if defined(Py_BUILD_CORE) || defined(Py_BUILD_CORE_BUILTIN) || defined(Py_BUILD_CORE_MODULE)
#ifndef NTDDI_VERSION
#define NTDDI_VERSION Py_NTDDI
#endif
#ifndef WINVER
#define WINVER Py_WINVER
#endif
#ifndef _WIN32_WINNT
#define _WIN32_WINNT Py_WINVER
#endif
#endif

/* _W64 is not defined for VC6 or eVC4 */
#ifndef _W64
#define _W64
#endif

/* Define like size_t, omitting the "unsigned" */
#ifdef MS_WIN64
typedef __int64 Py_ssize_t;
#   define PY_SSIZE_T_MAX LLONG_MAX
#else
typedef _W64 int Py_ssize_t;
#   define PY_SSIZE_T_MAX INT_MAX
#endif
#define HAVE_PY_SSIZE_T 1

#if defined(MS_WIN32) && !defined(MS_WIN64)
#if defined(_M_IX86)
#if defined(__clang__)
#define COMPILER ("[Clang " __clang_version__ "] 32 bit (Intel) with MSC v." _Py_STRINGIZE(_MSC_VER) " CRT]")
#define PY_SUPPORT_TIER 0
#elif defined(__INTEL_COMPILER)
#define COMPILER ("[ICC v." _Py_STRINGIZE(__INTEL_COMPILER) " 32 bit (Intel) with MSC v." _Py_STRINGIZE(_MSC_VER) " CRT]")
#define PY_SUPPORT_TIER 0
#else
#define COMPILER _Py_PASTE_VERSION("32 bit (Intel)")
#define PY_SUPPORT_TIER 1
#endif /* __clang__ */
#define PYD_PLATFORM_TAG "win32"
#elif defined(_M_ARM)
#define COMPILER _Py_PASTE_VERSION("32 bit (ARM)")
#define PYD_PLATFORM_TAG "win_arm32"
#define PY_SUPPORT_TIER 0
#else
#define COMPILER _Py_PASTE_VERSION("32 bit (Unknown)")
#define PY_SUPPORT_TIER 0
#endif
#endif /* MS_WIN32 && !MS_WIN64 */

typedef int pid_t;

/* define some ANSI types that are not defined in earlier Win headers */
#if _MSC_VER >= 1200
/* This file only exists in VC 6.0 or higher */
#include <basetsd.h>
#endif

#endif /* _MSC_VER */

/* ------------------------------------------------------------------------*/
/* mingw and mingw-w64 define __MINGW32__ */
#ifdef __MINGW32__

#ifdef _WIN64
#define MS_WIN64
#endif

#endif /* __MINGW32__*/

/* ------------------------------------------------------------------------*/
/* egcs/gnu-win32 defines __GNUC__ and _WIN32 */
#if defined(__GNUC__) && defined(_WIN32)
/* XXX These defines are likely incomplete, but should be easy to fix.
   They should be complete enough to build extension modules. */
/* Suggested by Rene Liebscher <R.Liebscher@gmx.de> to avoid a GCC 2.91.*
   bug that requires structure imports.  More recent versions of the
   compiler don't exhibit this bug.
*/
#if (__GNUC__==2) && (__GNUC_MINOR__<=91)
#warning "Please use an up-to-date version of gcc! (>2.91 recommended)"
#endif

#define COMPILER "[gcc]"
#define PY_LONG_LONG long long
#define PY_LLONG_MIN LLONG_MIN
#define PY_LLONG_MAX LLONG_MAX
#define PY_ULLONG_MAX ULLONG_MAX
#endif /* GNUC */

/* ------------------------------------------------------------------------*/
/* lcc-win32 defines __LCC__ */
#if defined(__LCC__)
/* XXX These defines are likely incomplete, but should be easy to fix.
   They should be complete enough to build extension modules. */

#define COMPILER "[lcc-win32]"
typedef int pid_t;
/* __declspec() is supported here too - do nothing to get the defaults */

#endif /* LCC */

/* ------------------------------------------------------------------------*/
/* End of compilers - finish up */

#ifndef NO_STDIO_H
#       include <stdio.h>
#endif

/* 64 bit ints are usually spelt __int64 unless compiler has overridden */
#ifndef PY_LONG_LONG
#       define PY_LONG_LONG __int64
#       define PY_LLONG_MAX _I64_MAX
#       define PY_LLONG_MIN _I64_MIN
#       define PY_ULLONG_MAX _UI64_MAX
#endif

/* For Windows the Python core is in a DLL by default.  Test
Py_NO_ENABLE_SHARED to find out.  Also support MS_NO_COREDLL for b/w compat */
#if !defined(MS_NO_COREDLL) && !defined(Py_NO_ENABLE_SHARED)
#       define Py_ENABLE_SHARED 1 /* standard symbol for shared library */
#       define MS_COREDLL       /* deprecated old symbol */
#endif /* !MS_NO_COREDLL && ... */

/*  All windows compilers that use this header support __declspec */
#define HAVE_DECLSPEC_DLL

/* For an MSVC DLL, we can nominate the .lib files used by extensions */
#ifdef MS_COREDLL
#       if !defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_BUILTIN)
                /* not building the core - must be an ext */
#               if defined(_MSC_VER)
                        /* So MSVC users need not specify the .lib
                        file in their Makefile */
#                       if defined(Py_GIL_DISABLED)
#                       if defined(_DEBUG)
#                               pragma comment(lib,"python314t_d.lib")
#                       elif defined(Py_LIMITED_API)
#                               pragma comment(lib,"python3t.lib")
#                       else
#                               pragma comment(lib,"python314t.lib")
#                       endif /* _DEBUG */
#                       else /* Py_GIL_DISABLED */
#                       if defined(_DEBUG)
#                               pragma comment(lib,"python314_d.lib")
#                       elif defined(Py_LIMITED_API)
#                               pragma comment(lib,"python3.lib")
#                       else
#                               pragma comment(lib,"python314.lib")
#                       endif /* _DEBUG */
#                       endif /* Py_GIL_DISABLED */
#               endif /* _MSC_VER */
#       endif /* Py_BUILD_CORE */
#endif /* MS_COREDLL */

#ifdef MS_WIN64
/* maintain "win32" sys.platform for backward compatibility of Python code,
   the Win64 API should be close enough to the Win32 API to make this
   preferable */
#       define PLATFORM "win32"
#       define SIZEOF_VOID_P 8
#       define SIZEOF_TIME_T 8
#       define SIZEOF_OFF_T 4
#       define SIZEOF_FPOS_T 8
#       define SIZEOF_HKEY 8
#       define SIZEOF_SIZE_T 8
#       define ALIGNOF_SIZE_T 8
#       define ALIGNOF_MAX_ALIGN_T 8
/* configure.ac defines HAVE_LARGEFILE_SUPPORT iff
   sizeof(off_t) > sizeof(long), and sizeof(long long) >= sizeof(off_t).
   On Win64 the second condition is not true, but if fpos_t replaces off_t
   then this is true. The uses of HAVE_LARGEFILE_SUPPORT imply that Win64
   should define this. */
#       define HAVE_LARGEFILE_SUPPORT
#elif defined(MS_WIN32)
#       define PLATFORM "win32"
#       define HAVE_LARGEFILE_SUPPORT
#       define SIZEOF_VOID_P 4
#       define SIZEOF_OFF_T 4
#       define SIZEOF_FPOS_T 8
#       define SIZEOF_HKEY 4
#       define SIZEOF_SIZE_T 4
#       define ALIGNOF_SIZE_T 4
        /* MS VS2005 changes time_t to a 64-bit type on all platforms */
#       if defined(_MSC_VER) && _MSC_VER >= 1400
#       define SIZEOF_TIME_T 8
#       else
#       define SIZEOF_TIME_T 4
#       endif
#       define ALIGNOF_MAX_ALIGN_T 8
#endif

#ifdef _DEBUG
#       define Py_DEBUG
#endif


#ifdef MS_WIN32

#define SIZEOF_SHORT 2
#define SIZEOF_INT 4
#define SIZEOF_LONG 4
#define ALIGNOF_LONG 4
#define SIZEOF_LONG_LONG 8
#define SIZEOF_DOUBLE 8
#define SIZEOF_FLOAT 4

/* VC 7.1 has them and VC 6.0 does not.  VC 6.0 has a version number of 1200.
   Microsoft eMbedded Visual C++ 4.0 has a version number of 1201 and doesn't
   define these.
   If some compiler does not provide them, modify the #if appropriately. */
#if defined(_MSC_VER)
#if _MSC_VER > 1300
#define HAVE_UINTPTR_T 1
#define HAVE_INTPTR_T 1
#else
/* VC6, VS 2002 and eVC4 don't support the C99 LL suffix for 64-bit integer literals */
#define Py_LL(x) x##I64
#endif  /* _MSC_VER > 1300  */
#endif  /* _MSC_VER */

#endif

/* define signed and unsigned exact-width 32-bit and 64-bit types, used in the
   implementation of Python integers. */
#define PY_UINT32_T uint32_t
#define PY_UINT64_T uint64_t
#define PY_INT32_T int32_t
#define PY_INT64_T int64_t

/* Fairly standard from here! */

/* Define if on AIX 3.
   System headers sometimes define this.
   We just want to avoid a redefinition error message.  */
#ifndef _ALL_SOURCE
/* #undef _ALL_SOURCE */
#endif

/* Define to empty if the keyword does not work.  */
/* #define const  */

/* Define to 1 if you have the <conio.h> header file. */
#define HAVE_CONIO_H 1

/* Define to 1 if you have the <direct.h> header file. */
#define HAVE_DIRECT_H 1

/* Define to 1 if you have the declaration of `tzname', and to 0 if you don't.
   */
#define HAVE_DECL_TZNAME 1

/* Define if you have dirent.h.  */
/* #define DIRENT 1 */

/* Define to the type of elements in the array set by `getgroups'.
   Usually this is either `int' or `gid_t'.  */
/* #undef GETGROUPS_T */

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef gid_t */

/* Define if your struct tm has tm_zone.  */
/* #undef HAVE_TM_ZONE */

/* Define if you don't have tm_zone but do have the external array
   tzname.  */
#define HAVE_TZNAME

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef mode_t */

/* Define if you don't have dirent.h, but have ndir.h.  */
/* #undef NDIR */

/* Define to `long' if <sys/types.h> doesn't define.  */
/* #undef off_t */

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef pid_t */

/* Define if the system does not provide POSIX.1 features except
   with this defined.  */
/* #undef _POSIX_1_SOURCE */

/* Define if you need to in order for stat and other things to work.  */
/* #undef _POSIX_SOURCE */

/* Define as the return type of signal handlers (int or void).  */
#define RETSIGTYPE void

/* Define to `unsigned' if <sys/types.h> doesn't define.  */
/* #undef size_t */

/* Define if you have the ANSI C header files.  */
#define STDC_HEADERS 1

/* Define if you don't have dirent.h, but have sys/dir.h.  */
/* #undef SYSDIR */

/* Define if you don't have dirent.h, but have sys/ndir.h.  */
/* #undef SYSNDIR */

/* Define if you can safely include both <sys/time.h> and <time.h>.  */
/* #undef TIME_WITH_SYS_TIME */

/* Define if your <sys/time.h> declares struct tm.  */
/* #define TM_IN_SYS_TIME 1 */

/* Define to `int' if <sys/types.h> doesn't define.  */
/* #undef uid_t */

/* Define if the closedir function returns void instead of int.  */
/* #undef VOID_CLOSEDIR */

/* Define if getpgrp() must be called as getpgrp(0)
   and (consequently) setpgrp() as setpgrp(0, 0). */
/* #undef GETPGRP_HAVE_ARGS */

/* Define this if your time.h defines altzone */
/* #define HAVE_ALTZONE */

/* Define if you have the putenv function.  */
#define HAVE_PUTENV

/* Define if your compiler supports function prototypes */
#define HAVE_PROTOTYPES

/* Define if  you can safely include both <sys/select.h> and <sys/time.h>
   (which you can't on SCO ODT 3.0). */
/* #undef SYS_SELECT_WITH_SYS_TIME */

/* Define if you want build the _decimal module using a coroutine-local rather
   than a thread-local context */
#define WITH_DECIMAL_CONTEXTVAR 1

/* Define if you want documentation strings in extension modules */
#define WITH_DOC_STRINGS 1

/* Define if you want to compile in rudimentary thread support */
/* #undef WITH_THREAD */

/* Define if you want to use the GNU readline library */
/* #define WITH_READLINE 1 */

/* Use Python's own small-block memory-allocator. */
#define WITH_PYMALLOC 1

/* Define if you want to compile in mimalloc memory allocator. */
#define WITH_MIMALLOC 1

/* Define if you have clock.  */
/* #define HAVE_CLOCK */

/* Define when any dynamic module loading is enabled */
#define HAVE_DYNAMIC_LOADING

/* Define if you have ftime.  */
#define HAVE_FTIME

/* Define if you have getpeername.  */
#define HAVE_GETPEERNAME

/* Define if you have getpgrp.  */
/* #undef HAVE_GETPGRP */

/* Define if you have getpid.  */
#define HAVE_GETPID

/* Define if you have gettimeofday.  */
/* #undef HAVE_GETTIMEOFDAY */

/* Define if you have getwd.  */
/* #undef HAVE_GETWD */

/* Define if you have lstat.  */
/* #undef HAVE_LSTAT */

/* Define if you have the mktime function.  */
#define HAVE_MKTIME

/* Define if you have nice.  */
/* #undef HAVE_NICE */

/* Define if you have readlink.  */
/* #undef HAVE_READLINK */

/* Define if you have setpgid.  */
/* #undef HAVE_SETPGID */

/* Define if you have setpgrp.  */
/* #undef HAVE_SETPGRP */

/* Define if you have setsid.  */
/* #undef HAVE_SETSID */

/* Define if you have setvbuf.  */
#define HAVE_SETVBUF

/* Define if you have siginterrupt.  */
/* #undef HAVE_SIGINTERRUPT */

/* Define to 1 if you have the `shutdown' function. */
#define HAVE_SHUTDOWN 1

/* Define if you have symlink.  */
/* #undef HAVE_SYMLINK */

/* Define if you have tcgetpgrp.  */
/* #undef HAVE_TCGETPGRP */

/* Define if you have tcsetpgrp.  */
/* #undef HAVE_TCSETPGRP */

/* Define if you have times.  */
/* #undef HAVE_TIMES */

/* Define to 1 if you have the `umask' function. */
#define HAVE_UMASK 1

/* Define if you have uname.  */
/* #undef HAVE_UNAME */

/* Define if you have waitpid.  */
/* #undef HAVE_WAITPID */

/* Define to 1 if you have the `wcsftime' function. */
#if defined(_MSC_VER) && _MSC_VER >= 1310
#define HAVE_WCSFTIME 1
#endif

/* Define to 1 if you have the `wcscoll' function. */
#define HAVE_WCSCOLL 1

/* Define to 1 if you have the `wcsxfrm' function. */
#define HAVE_WCSXFRM 1

/* Define if the zlib library has inflateCopy */
#define HAVE_ZLIB_COPY 1

/* Define if you have the <dlfcn.h> header file.  */
/* #undef HAVE_DLFCN_H */

/* Define to 1 if you have the <errno.h> header file. */
#define HAVE_ERRNO_H 1

/* Define if you have the <fcntl.h> header file.  */
#define HAVE_FCNTL_H 1

/* Define to 1 if you have the <process.h> header file. */
#define HAVE_PROCESS_H 1

/* Define to 1 if you have the <signal.h> header file. */
#define HAVE_SIGNAL_H 1

/* Define if you have the <stddef.h> header file.  */
#define HAVE_STDDEF_H 1

/* Define if you have the <sys/audioio.h> header file.  */
/* #undef HAVE_SYS_AUDIOIO_H */

/* Define if you have the <sys/param.h> header file.  */
/* #define HAVE_SYS_PARAM_H 1 */

/* Define if you have the <sys/select.h> header file.  */
/* #define HAVE_SYS_SELECT_H 1 */

/* Define to 1 if you have the <sys/stat.h> header file.  */
#define HAVE_SYS_STAT_H 1

/* Define if you have the <sys/time.h> header file.  */
/* #define HAVE_SYS_TIME_H 1 */

/* Define if you have the <sys/times.h> header file.  */
/* #define HAVE_SYS_TIMES_H 1 */

/* Define to 1 if you have the <sys/types.h> header file.  */
#define HAVE_SYS_TYPES_H 1

/* Define if you have the <sys/un.h> header file.  */
/* #define HAVE_SYS_UN_H 1 */

/* Define if you have the <sys/utime.h> header file.  */
/* #define HAVE_SYS_UTIME_H 1 */

/* Define if you have the <sys/utsname.h> header file.  */
/* #define HAVE_SYS_UTSNAME_H 1 */

/* Define if you have the <unistd.h> header file.  */
/* #define HAVE_UNISTD_H 1 */

/* Define if you have the <utime.h> header file.  */
/* #define HAVE_UTIME_H 1 */

/* Define if the compiler provides a wchar.h header file. */
#define HAVE_WCHAR_H 1

/* The size of `wchar_t', as computed by sizeof. */
#define SIZEOF_WCHAR_T 2

/* The size of `_Bool', as computed by sizeof. */
#define SIZEOF__BOOL 1

/* The size of `pid_t', as computed by sizeof. */
#define SIZEOF_PID_T SIZEOF_INT

/* Define if you have the dl library (-ldl).  */
/* #undef HAVE_LIBDL */

/* Define if you have the mpc library (-lmpc).  */
/* #undef HAVE_LIBMPC */

/* Define if you have the seq library (-lseq).  */
/* #undef HAVE_LIBSEQ */

/* Define if you have the socket library (-lsocket).  */
#define HAVE_LIBSOCKET 1

/* Define if you have the sun library (-lsun).  */
/* #undef HAVE_LIBSUN */

/* Define if you have the termcap library (-ltermcap).  */
/* #undef HAVE_LIBTERMCAP */

/* Define if you have the termlib library (-ltermlib).  */
/* #undef HAVE_LIBTERMLIB */

/* Define if you have the thread library (-lthread).  */
/* #undef HAVE_LIBTHREAD */

/* WinSock does not use a bitmask in select, and uses
   socket handles greater than FD_SETSIZE */
#define Py_SOCKET_FD_CAN_BE_GE_FD_SETSIZE

/* Define if C doubles are 64-bit IEEE 754 binary format, stored with the
   least significant byte first */
#define DOUBLE_IS_LITTLE_ENDIAN_IEEE754 1

/* Define to 1 if you have the `erf' function. */
#define HAVE_ERF 1

/* Define to 1 if you have the `erfc' function. */
#define HAVE_ERFC 1

// netdb.h functions (provided by winsock.h)
#define HAVE_GETHOSTNAME 1
#define HAVE_GETHOSTBYADDR 1
#define HAVE_GETHOSTBYNAME 1
#define HAVE_GETPROTOBYNAME 1
#define HAVE_GETSERVBYNAME 1
#define HAVE_GETSERVBYPORT 1
// sys/socket.h functions (provided by winsock.h)
#define HAVE_INET_PTON 1
#define HAVE_INET_NTOA 1
#define HAVE_ACCEPT 1
#define HAVE_BIND 1
#define HAVE_CONNECT 1
#define HAVE_GETSOCKNAME 1
#define HAVE_LISTEN 1
#define HAVE_RECVFROM 1
#define HAVE_SENDTO 1
#define HAVE_SETSOCKOPT 1
#define HAVE_SOCKET 1

/* Define to 1 if you have the `dup' function. */
#define HAVE_DUP 1

/* framework name */
#define _PYTHONFRAMEWORK ""

/* Define if libssl has X509_VERIFY_PARAM_set1_host and related function */
#define HAVE_X509_VERIFY_PARAM_SET1_HOST 1

#endif /* !Py_CONFIG_H */


================================================
File: /PC/pylauncher.rc
================================================
#include <windows.h>

#include "python_ver_rc.h"

#ifndef RT_MANIFEST
// bpo-45220: Cannot reliably #include RT_MANIFEST from
// anywhere, so we hardcode it
#define RT_MANIFEST 24
#endif
// Include the manifest file that indicates we support all
// current versions of Windows.
1 RT_MANIFEST "python.manifest"

#if defined(PY_ICON)
1 ICON DISCARDABLE "icons\python.ico"
#elif defined(PYW_ICON)
1 ICON DISCARDABLE "icons\pythonw.ico"
#else
1 ICON DISCARDABLE "icons\launcher.ico" 
2 ICON DISCARDABLE "icons\py.ico" 
3 ICON DISCARDABLE "icons\pyc.ico" 
4 ICON DISCARDABLE "icons\pyd.ico" 
5 ICON DISCARDABLE "icons\python.ico"
6 ICON DISCARDABLE "icons\pythonw.ico"
7 ICON DISCARDABLE "icons\setup.ico" 
#endif

1 USAGE "launcher-usage.txt"


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION PYVERSION64
 PRODUCTVERSION PYVERSION64
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
            VALUE "CompanyName", PYTHON_COMPANY "\0"
            VALUE "FileDescription", "Python\0"
            VALUE "FileVersion", PYTHON_VERSION
            VALUE "InternalName", "Python Launcher\0"
            VALUE "LegalCopyright", PYTHON_COPYRIGHT "\0"
            VALUE "OriginalFilename", "py" PYTHON_DEBUG_EXT ".exe\0"
            VALUE "ProductName", "Python\0"
            VALUE "ProductVersion", PYTHON_VERSION
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END

================================================
File: /PC/pyshellext.cpp
================================================
// Support back to Vista
#define _WIN32_WINNT _WIN32_WINNT_VISTA
#include <sdkddkver.h>

// Use WRL to define a classic COM class
#define __WRL_CLASSIC_COM__
#include <wrl.h>

#include <windows.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <olectl.h>
#include <strsafe.h>

#define DDWM_UPDATEWINDOW (WM_USER+3)

static HINSTANCE hModule;
static CLIPFORMAT cfDropDescription;
static CLIPFORMAT cfDragWindow;

#define CLASS_GUID "{BEA218D2-6950-497B-9434-61683EC065FE}"
static const LPCWSTR CLASS_SUBKEY = L"Software\\Classes\\CLSID\\" CLASS_GUID;
static const LPCWSTR DRAG_MESSAGE = L"Open with %1";

using namespace Microsoft::WRL;

HRESULT FilenameListCchLengthA(LPCSTR pszSource, size_t cchMax, size_t *pcchLength, size_t *pcchCount) {
    HRESULT hr = S_OK;
    size_t count = 0;
    size_t length = 0;

    while (pszSource && pszSource[0]) {
        size_t oneLength;
        hr = StringCchLengthA(pszSource, cchMax - length, &oneLength);
        if (FAILED(hr)) {
            return hr;
        }
        count += 1;
        length += oneLength + (strchr(pszSource, ' ') ? 3 : 1);
        pszSource = &pszSource[oneLength + 1];
    }

    *pcchCount = count;
    *pcchLength = length;
    return hr;
}

HRESULT FilenameListCchLengthW(LPCWSTR pszSource, size_t cchMax, size_t *pcchLength, size_t *pcchCount) {
    HRESULT hr = S_OK;
    size_t count = 0;
    size_t length = 0;

    while (pszSource && pszSource[0]) {
        size_t oneLength;
        hr = StringCchLengthW(pszSource, cchMax - length, &oneLength);
        if (FAILED(hr)) {
            return hr;
        }
        count += 1;
        length += oneLength + (wcschr(pszSource, ' ') ? 3 : 1);
        pszSource = &pszSource[oneLength + 1];
    }

    *pcchCount = count;
    *pcchLength = length;
    return hr;
}

HRESULT FilenameListCchCopyA(STRSAFE_LPSTR pszDest, size_t cchDest, LPCSTR pszSource, LPCSTR pszSeparator) {
    HRESULT hr = S_OK;
    size_t count = 0;
    size_t length = 0;

    while (pszSource[0]) {
        STRSAFE_LPSTR newDest;

        hr = StringCchCopyExA(pszDest, cchDest, pszSource, &newDest, &cchDest, 0);
        if (FAILED(hr)) {
            return hr;
        }
        pszSource += (newDest - pszDest) + 1;
        pszDest = PathQuoteSpacesA(pszDest) ? newDest + 2 : newDest;

        if (pszSource[0]) {
            hr = StringCchCopyExA(pszDest, cchDest, pszSeparator, &newDest, &cchDest, 0);
            if (FAILED(hr)) {
                return hr;
            }
            pszDest = newDest;
        }
    }

    return hr;
}

HRESULT FilenameListCchCopyW(STRSAFE_LPWSTR pszDest, size_t cchDest, LPCWSTR pszSource, LPCWSTR pszSeparator) {
    HRESULT hr = S_OK;
    size_t count = 0;
    size_t length = 0;

    while (pszSource[0]) {
        STRSAFE_LPWSTR newDest;

        hr = StringCchCopyExW(pszDest, cchDest, pszSource, &newDest, &cchDest, 0);
        if (FAILED(hr)) {
            return hr;
        }
        pszSource += (newDest - pszDest) + 1;
        pszDest = PathQuoteSpacesW(pszDest) ? newDest + 2 : newDest;

        if (pszSource[0]) {
            hr = StringCchCopyExW(pszDest, cchDest, pszSeparator, &newDest, &cchDest, 0);
            if (FAILED(hr)) {
                return hr;
            }
            pszDest = newDest;
        }
    }

    return hr;
}

class DECLSPEC_UUID(CLASS_GUID) PyShellExt : public RuntimeClass<
    RuntimeClassFlags<ClassicCom>,
    IDropTarget,
    IPersistFile
>
{
    LPOLESTR target, target_dir;
    DWORD target_mode;

    IDataObject *data_obj;

public:
    PyShellExt() : target(NULL), target_dir(NULL), target_mode(0), data_obj(NULL) {
        OutputDebugString(L"PyShellExt::PyShellExt");
    }

    ~PyShellExt() {
        if (target) {
            CoTaskMemFree(target);
        }
        if (target_dir) {
            CoTaskMemFree(target_dir);
        }
        if (data_obj) {
            data_obj->Release();
        }
    }

private:
    HRESULT UpdateDropDescription(IDataObject *pDataObj) {
        STGMEDIUM medium;
        FORMATETC fmt = {
            cfDropDescription,
            NULL,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
        };

        auto hr = pDataObj->GetData(&fmt, &medium);
        if (FAILED(hr)) {
            OutputDebugString(L"PyShellExt::UpdateDropDescription - failed to get DROPDESCRIPTION format");
            return hr;
        }
        if (!medium.hGlobal) {
            OutputDebugString(L"PyShellExt::UpdateDropDescription - DROPDESCRIPTION format had NULL hGlobal");
            ReleaseStgMedium(&medium);
            return E_FAIL;
        }
        auto dd = (DROPDESCRIPTION*)GlobalLock(medium.hGlobal);
        if (!dd) {
            OutputDebugString(L"PyShellExt::UpdateDropDescription - failed to lock DROPDESCRIPTION hGlobal");
            ReleaseStgMedium(&medium);
            return E_FAIL;
        }
        StringCchCopy(dd->szMessage, sizeof(dd->szMessage) / sizeof(dd->szMessage[0]), DRAG_MESSAGE);
        StringCchCopy(dd->szInsert, sizeof(dd->szInsert) / sizeof(dd->szInsert[0]), PathFindFileNameW(target));
        dd->type = DROPIMAGE_MOVE;

        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);

        return S_OK;
    }

    HRESULT GetDragWindow(IDataObject *pDataObj, HWND *phWnd) {
        HRESULT hr;
        HWND *pMem;
        STGMEDIUM medium;
        FORMATETC fmt = {
            cfDragWindow,
            NULL,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
        };

        hr = pDataObj->GetData(&fmt, &medium);
        if (FAILED(hr)) {
            OutputDebugString(L"PyShellExt::GetDragWindow - failed to get DragWindow format");
            return hr;
        }
        if (!medium.hGlobal) {
            OutputDebugString(L"PyShellExt::GetDragWindow - DragWindow format had NULL hGlobal");
            ReleaseStgMedium(&medium);
            return E_FAIL;
        }

        pMem = (HWND*)GlobalLock(medium.hGlobal);
        if (!pMem) {
            OutputDebugString(L"PyShellExt::GetDragWindow - failed to lock DragWindow hGlobal");
            ReleaseStgMedium(&medium);
            return E_FAIL;
        }

        *phWnd = *pMem;

        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);

        return S_OK;
    }

    HRESULT GetArguments(IDataObject *pDataObj, LPCWSTR *pArguments) {
        HRESULT hr;
        DROPFILES *pdropfiles;

        STGMEDIUM medium;
        FORMATETC fmt = {
            CF_HDROP,
            NULL,
            DVASPECT_CONTENT,
            -1,
            TYMED_HGLOBAL
        };

        hr = pDataObj->GetData(&fmt, &medium);
        if (FAILED(hr)) {
            OutputDebugString(L"PyShellExt::GetArguments - failed to get CF_HDROP format");
            return hr;
        }
        if (!medium.hGlobal) {
            OutputDebugString(L"PyShellExt::GetArguments - CF_HDROP format had NULL hGlobal");
            ReleaseStgMedium(&medium);
            return E_FAIL;
        }

        pdropfiles = (DROPFILES*)GlobalLock(medium.hGlobal);
        if (!pdropfiles) {
            OutputDebugString(L"PyShellExt::GetArguments - failed to lock CF_HDROP hGlobal");
            ReleaseStgMedium(&medium);
            return E_FAIL;
        }

        if (pdropfiles->fWide) {
            LPCWSTR files = (LPCWSTR)((char*)pdropfiles + pdropfiles->pFiles);
            size_t len, count;
            hr = FilenameListCchLengthW(files, 32767, &len, &count);
            if (SUCCEEDED(hr)) {
                LPWSTR args = (LPWSTR)CoTaskMemAlloc(sizeof(WCHAR) * (len + 1));
                if (args) {
                    hr = FilenameListCchCopyW(args, 32767, files, L" ");
                    if (SUCCEEDED(hr)) {
                        *pArguments = args;
                    } else {
                        CoTaskMemFree(args);
                    }
                } else {
                    hr = E_OUTOFMEMORY;
                }
            }
        } else {
            LPCSTR files = (LPCSTR)((char*)pdropfiles + pdropfiles->pFiles);
            size_t len, count;
            hr = FilenameListCchLengthA(files, 32767, &len, &count);
            if (SUCCEEDED(hr)) {
                LPSTR temp = (LPSTR)CoTaskMemAlloc(sizeof(CHAR) * (len + 1));
                if (temp) {
                    hr = FilenameListCchCopyA(temp, 32767, files, " ");
                    if (SUCCEEDED(hr)) {
                        int wlen = MultiByteToWideChar(CP_ACP, 0, temp, (int)len, NULL, 0);
                        if (wlen) {
                            LPWSTR args = (LPWSTR)CoTaskMemAlloc(sizeof(WCHAR) * (wlen + 1));
                            if (MultiByteToWideChar(CP_ACP, 0, temp, (int)len, args, wlen + 1)) {
                                *pArguments = args;
                            } else {
                                OutputDebugString(L"PyShellExt::GetArguments - failed to convert multi-byte to wide-char path");
                                CoTaskMemFree(args);
                                hr = E_FAIL;
                            }
                        } else {
                            OutputDebugString(L"PyShellExt::GetArguments - failed to get length of wide-char path");
                            hr = E_FAIL;
                        }
                    }
                    CoTaskMemFree(temp);
                } else {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        GlobalUnlock(medium.hGlobal);
        ReleaseStgMedium(&medium);

        return hr;
    }

    HRESULT NotifyDragWindow(HWND hwnd) {
        LRESULT res;

        if (!hwnd) {
            return S_FALSE;
        }

        res = SendMessage(hwnd, DDWM_UPDATEWINDOW, 0, NULL);

        if (res) {
            OutputDebugString(L"PyShellExt::NotifyDragWindow - failed to post DDWM_UPDATEWINDOW");
            return E_FAIL;
        }

        return S_OK;
    }

public:
    // IDropTarget implementation

    STDMETHODIMP DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect) {
        HWND hwnd;

        OutputDebugString(L"PyShellExt::DragEnter");

        pDataObj->AddRef();
        data_obj = pDataObj;

        *pdwEffect = DROPEFFECT_MOVE;

        if (FAILED(UpdateDropDescription(data_obj))) {
            OutputDebugString(L"PyShellExt::DragEnter - failed to update drop description");
        }
        if (FAILED(GetDragWindow(data_obj, &hwnd))) {
            OutputDebugString(L"PyShellExt::DragEnter - failed to get drag window");
        }
        if (FAILED(NotifyDragWindow(hwnd))) {
            OutputDebugString(L"PyShellExt::DragEnter - failed to notify drag window");
        }

        return S_OK;
    }

    STDMETHODIMP DragLeave() {
        return S_OK;
    }

    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect) {
        return S_OK;
    }

    STDMETHODIMP Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect) {
        LPCWSTR args;

        OutputDebugString(L"PyShellExt::Drop");
        *pdwEffect = DROPEFFECT_NONE;

        if (pDataObj != data_obj) {
            OutputDebugString(L"PyShellExt::Drop - unexpected data object");
            return E_FAIL;
        }

        data_obj->Release();
        data_obj = NULL;

        if (SUCCEEDED(GetArguments(pDataObj, &args))) {
            OutputDebugString(args);
            ShellExecute(NULL, NULL, target, args, target_dir, SW_NORMAL);

            CoTaskMemFree((LPVOID)args);
        } else {
            OutputDebugString(L"PyShellExt::Drop - failed to get launch arguments");
        }

        return S_OK;
    }

    // IPersistFile implementation

    STDMETHODIMP GetCurFile(LPOLESTR *ppszFileName) {
        HRESULT hr;
        size_t len;

        if (!ppszFileName) {
            return E_POINTER;
        }

        hr = StringCchLength(target, STRSAFE_MAX_CCH - 1, &len);
        if (FAILED(hr)) {
            return E_FAIL;
        }

        *ppszFileName = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR) * (len + 1));
        if (!*ppszFileName) {
            return E_OUTOFMEMORY;
        }

        hr = StringCchCopy(*ppszFileName, len + 1, target);
        if (FAILED(hr)) {
            CoTaskMemFree(*ppszFileName);
            *ppszFileName = NULL;
            return E_FAIL;
        }

        return S_OK;
    }

    STDMETHODIMP IsDirty() {
        return S_FALSE;
    }

    STDMETHODIMP Load(LPCOLESTR pszFileName, DWORD dwMode) {
        HRESULT hr;
        size_t len;

        OutputDebugString(L"PyShellExt::Load");
        OutputDebugString(pszFileName);

        hr = StringCchLength(pszFileName, STRSAFE_MAX_CCH - 1, &len);
        if (FAILED(hr)) {
            OutputDebugString(L"PyShellExt::Load - failed to get string length");
            return hr;
        }

        if (target) {
            CoTaskMemFree(target);
        }
        if (target_dir) {
            CoTaskMemFree(target_dir);
        }

        target = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR) * (len + 1));
        if (!target) {
            OutputDebugString(L"PyShellExt::Load - E_OUTOFMEMORY");
            return E_OUTOFMEMORY;
        }
        target_dir = (LPOLESTR)CoTaskMemAlloc(sizeof(WCHAR) * (len + 1));
        if (!target_dir) {
            OutputDebugString(L"PyShellExt::Load - E_OUTOFMEMORY");
            return E_OUTOFMEMORY;
        }

        hr = StringCchCopy(target, len + 1, pszFileName);
        if (FAILED(hr)) {
            OutputDebugString(L"PyShellExt::Load - failed to copy string");
            return hr;
        }

        hr = StringCchCopy(target_dir, len + 1, pszFileName);
        if (FAILED(hr)) {
            OutputDebugString(L"PyShellExt::Load - failed to copy string");
            return hr;
        }
        if (!PathRemoveFileSpecW(target_dir)) {
            OutputDebugStringW(L"PyShellExt::Load - failed to remove filespec from target");
            return E_FAIL;
        }

        OutputDebugString(target);
        target_mode = dwMode;
        OutputDebugString(L"PyShellExt::Load - S_OK");
        return S_OK;
    }

    STDMETHODIMP Save(LPCOLESTR pszFileName, BOOL fRemember) {
        return E_NOTIMPL;
    }

    STDMETHODIMP SaveCompleted(LPCOLESTR pszFileName) {
        return E_NOTIMPL;
    }

    STDMETHODIMP GetClassID(CLSID *pClassID) {
        *pClassID = __uuidof(PyShellExt);
        return S_OK;
    }
};

CoCreatableClass(PyShellExt);

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, _COM_Outptr_ void** ppv) {
    return Module<InProc>::GetModule().GetClassObject(rclsid, riid, ppv);
}

STDAPI DllCanUnloadNow() {
    return Module<InProc>::GetModule().Terminate() ? S_OK : S_FALSE;
}

STDAPI DllRegisterServer() {
    LONG res;
    SECURITY_ATTRIBUTES secattr = { sizeof(SECURITY_ATTRIBUTES), NULL, FALSE };
    LPSECURITY_ATTRIBUTES psecattr = NULL;
    HKEY key, ipsKey;
    WCHAR modname[MAX_PATH];
    DWORD modname_len;

    OutputDebugString(L"PyShellExt::DllRegisterServer");
    if (!hModule) {
        OutputDebugString(L"PyShellExt::DllRegisterServer - module handle was not set");
        return SELFREG_E_CLASS;
    }
    modname_len = GetModuleFileName(hModule, modname, MAX_PATH);
    if (modname_len == 0 ||
        (modname_len == MAX_PATH && GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        OutputDebugString(L"PyShellExt::DllRegisterServer - failed to get module file name");
        return SELFREG_E_CLASS;
    }

    DWORD disp;
    res = RegCreateKeyEx(HKEY_LOCAL_MACHINE, CLASS_SUBKEY, 0, NULL, 0,
        KEY_ALL_ACCESS, psecattr, &key, &disp);
    if (res == ERROR_ACCESS_DENIED) {
        OutputDebugString(L"PyShellExt::DllRegisterServer - failed to write per-machine registration. Attempting per-user instead.");
        res = RegCreateKeyEx(HKEY_CURRENT_USER, CLASS_SUBKEY, 0, NULL, 0,
            KEY_ALL_ACCESS, psecattr, &key, &disp);
    }
    if (res != ERROR_SUCCESS) {
        OutputDebugString(L"PyShellExt::DllRegisterServer - failed to create class key");
        return SELFREG_E_CLASS;
    }

    res = RegCreateKeyEx(key, L"InProcServer32", 0, NULL, 0,
        KEY_ALL_ACCESS, psecattr, &ipsKey, NULL);
    if (res != ERROR_SUCCESS) {
        RegCloseKey(key);
        OutputDebugString(L"PyShellExt::DllRegisterServer - failed to create InProcServer32 key");
        return SELFREG_E_CLASS;
    }

    res = RegSetValueEx(ipsKey, NULL, 0,
        REG_SZ, (LPBYTE)modname, modname_len * sizeof(modname[0]));

    if (res != ERROR_SUCCESS) {
        RegCloseKey(ipsKey);
        RegCloseKey(key);
        OutputDebugString(L"PyShellExt::DllRegisterServer - failed to set server path");
        return SELFREG_E_CLASS;
    }

    res = RegSetValueEx(ipsKey, L"ThreadingModel", 0,
        REG_SZ, (LPBYTE)(L"Apartment"), sizeof(L"Apartment"));

    RegCloseKey(ipsKey);
    RegCloseKey(key);
    if (res != ERROR_SUCCESS) {
        OutputDebugString(L"PyShellExt::DllRegisterServer - failed to set threading model");
        return SELFREG_E_CLASS;
    }

    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

    OutputDebugString(L"PyShellExt::DllRegisterServer - S_OK");
    return S_OK;
}

STDAPI DllUnregisterServer() {
    LONG res_lm, res_cu;

    res_lm = RegDeleteTree(HKEY_LOCAL_MACHINE, CLASS_SUBKEY);
    if (res_lm != ERROR_SUCCESS && res_lm != ERROR_FILE_NOT_FOUND) {
        OutputDebugString(L"PyShellExt::DllUnregisterServer - failed to delete per-machine registration");
        return SELFREG_E_CLASS;
    }

    res_cu = RegDeleteTree(HKEY_CURRENT_USER, CLASS_SUBKEY);
    if (res_cu != ERROR_SUCCESS && res_cu != ERROR_FILE_NOT_FOUND) {
        OutputDebugString(L"PyShellExt::DllUnregisterServer - failed to delete per-user registration");
        return SELFREG_E_CLASS;
    }

    if (res_lm == ERROR_FILE_NOT_FOUND && res_cu == ERROR_FILE_NOT_FOUND) {
        OutputDebugString(L"PyShellExt::DllUnregisterServer - extension was not registered");
        return SELFREG_E_CLASS;
    }

    SHChangeNotify(SHCNE_ASSOCCHANGED, SHCNF_IDLIST, NULL, NULL);

    OutputDebugString(L"PyShellExt::DllUnregisterServer - S_OK");
    return S_OK;
}

STDAPI_(BOOL) DllMain(_In_opt_ HINSTANCE hinst, DWORD reason, _In_opt_ void*) {
    if (reason == DLL_PROCESS_ATTACH) {
        hModule = hinst;

        cfDropDescription = RegisterClipboardFormat(CFSTR_DROPDESCRIPTION);
        if (!cfDropDescription) {
            OutputDebugString(L"PyShellExt::DllMain - failed to get CFSTR_DROPDESCRIPTION format");
        }
        cfDragWindow = RegisterClipboardFormat(L"DragWindow");
        if (!cfDragWindow) {
            OutputDebugString(L"PyShellExt::DllMain - failed to get DragWindow format");
        }

        DisableThreadLibraryCalls(hinst);
    }
    return TRUE;
}

================================================
File: /PC/pyshellext.def
================================================
EXPORTS
  DllRegisterServer PRIVATE
  DllUnregisterServer PRIVATE
  DllGetClassObject PRIVATE
  DllCanUnloadNow PRIVATE


================================================
File: /PC/pyshellext.rc
================================================
#include <windows.h>

#include "python_ver_rc.h"

#ifndef RT_MANIFEST
// bpo-45220: Cannot reliably #include RT_MANIFEST from
// anywhere, so we hardcode it
#define RT_MANIFEST 24
#endif

// Include the manifest file that indicates we support all
// current versions of Windows.
1 RT_MANIFEST "python.manifest"

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION PYVERSION64
 PRODUCTVERSION PYVERSION64
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
            VALUE "CompanyName", PYTHON_COMPANY "\0"
            VALUE "FileDescription", "Python\0"
            VALUE "FileVersion", PYTHON_VERSION
            VALUE "InternalName", "Python Launcher Shell Extension\0"
            VALUE "LegalCopyright", PYTHON_COPYRIGHT "\0"
            VALUE "OriginalFilename", "pyshellext" PYTHON_DEBUG_EXT ".dll\0"
            VALUE "ProductName", "Python\0"
            VALUE "ProductVersion", PYTHON_VERSION
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END

================================================
File: /PC/python.manifest
================================================
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
    <security>
      <requestedPrivileges>
        <requestedExecutionLevel level="asInvoker" uiAccess="false"/>
      </requestedPrivileges>
    </security>
  </trustInfo>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      <!-- Windows Vista -->
      <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/>
      <!-- Windows 7 -->
      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
      <!-- Windows 8 -->
      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
      <!-- Windows 8.1 -->
      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
      <!-- Windows 10 / Windows 11 -->
      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
    </application>
  </compatibility>
  <application xmlns="urn:schemas-microsoft-com:asm.v3">
    <windowsSettings>
      <longPathAware xmlns="http://schemas.microsoft.com/SMI/2016/WindowsSettings">true</longPathAware>
    </windowsSettings>
  </application>
  <dependency>
    <dependentAssembly>
      <assemblyIdentity type="win32" name="Microsoft.Windows.Common-Controls"
                        version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*" />
    </dependentAssembly>
  </dependency>
</assembly>


================================================
File: /PC/python3dll.c
================================================
/* Re-export stable Python ABI */

/* Generated by Tools/build/stable_abi.py */

#ifdef _M_IX86
#define DECORATE "_"
#else
#define DECORATE
#endif

#define EXPORT_FUNC(name) \
    __pragma(comment(linker, "/EXPORT:" DECORATE #name "=" PYTHON_DLL_NAME "." #name))
#define EXPORT_DATA(name) \
    __pragma(comment(linker, "/EXPORT:" DECORATE #name "=" PYTHON_DLL_NAME "." #name ",DATA"))

EXPORT_FUNC(_Py_BuildValue_SizeT)
EXPORT_FUNC(_Py_CheckRecursiveCall)
EXPORT_FUNC(_Py_Dealloc)
EXPORT_FUNC(_Py_DecRef)
EXPORT_FUNC(_Py_IncRef)
EXPORT_FUNC(_Py_NegativeRefcount)
EXPORT_FUNC(_Py_SetRefcnt)
EXPORT_FUNC(_Py_VaBuildValue_SizeT)
EXPORT_FUNC(_PyArg_Parse_SizeT)
EXPORT_FUNC(_PyArg_ParseTuple_SizeT)
EXPORT_FUNC(_PyArg_ParseTupleAndKeywords_SizeT)
EXPORT_FUNC(_PyArg_VaParse_SizeT)
EXPORT_FUNC(_PyArg_VaParseTupleAndKeywords_SizeT)
EXPORT_FUNC(_PyErr_BadInternalCall)
EXPORT_FUNC(_PyObject_CallFunction_SizeT)
EXPORT_FUNC(_PyObject_CallMethod_SizeT)
EXPORT_FUNC(_PyObject_GC_New)
EXPORT_FUNC(_PyObject_GC_NewVar)
EXPORT_FUNC(_PyObject_GC_Resize)
EXPORT_FUNC(_PyObject_New)
EXPORT_FUNC(_PyObject_NewVar)
EXPORT_FUNC(_PyState_AddModule)
EXPORT_FUNC(_PyThreadState_Init)
EXPORT_FUNC(_PyThreadState_Prealloc)
EXPORT_FUNC(Py_AddPendingCall)
EXPORT_FUNC(Py_AtExit)
EXPORT_FUNC(Py_BuildValue)
EXPORT_FUNC(Py_BytesMain)
EXPORT_FUNC(Py_CompileString)
EXPORT_FUNC(Py_DecodeLocale)
EXPORT_FUNC(Py_DecRef)
EXPORT_FUNC(Py_EncodeLocale)
EXPORT_FUNC(Py_EndInterpreter)
EXPORT_FUNC(Py_EnterRecursiveCall)
EXPORT_FUNC(Py_Exit)
EXPORT_FUNC(Py_FatalError)
EXPORT_FUNC(Py_Finalize)
EXPORT_FUNC(Py_FinalizeEx)
EXPORT_FUNC(Py_GenericAlias)
EXPORT_FUNC(Py_GetArgcArgv)
EXPORT_FUNC(Py_GetBuildInfo)
EXPORT_FUNC(Py_GetCompiler)
EXPORT_FUNC(Py_GetConstant)
EXPORT_FUNC(Py_GetConstantBorrowed)
EXPORT_FUNC(Py_GetCopyright)
EXPORT_FUNC(Py_GetExecPrefix)
EXPORT_FUNC(Py_GetPath)
EXPORT_FUNC(Py_GetPlatform)
EXPORT_FUNC(Py_GetPrefix)
EXPORT_FUNC(Py_GetProgramFullPath)
EXPORT_FUNC(Py_GetProgramName)
EXPORT_FUNC(Py_GetPythonHome)
EXPORT_FUNC(Py_GetRecursionLimit)
EXPORT_FUNC(Py_GetVersion)
EXPORT_FUNC(Py_IncRef)
EXPORT_FUNC(Py_Initialize)
EXPORT_FUNC(Py_InitializeEx)
EXPORT_FUNC(Py_Is)
EXPORT_FUNC(Py_IsFalse)
EXPORT_FUNC(Py_IsFinalizing)
EXPORT_FUNC(Py_IsInitialized)
EXPORT_FUNC(Py_IsNone)
EXPORT_FUNC(Py_IsTrue)
EXPORT_FUNC(Py_LeaveRecursiveCall)
EXPORT_FUNC(Py_Main)
EXPORT_FUNC(Py_MakePendingCalls)
EXPORT_FUNC(Py_NewInterpreter)
EXPORT_FUNC(Py_NewRef)
EXPORT_FUNC(Py_PACK_FULL_VERSION)
EXPORT_FUNC(Py_PACK_VERSION)
EXPORT_FUNC(Py_REFCNT)
EXPORT_FUNC(Py_ReprEnter)
EXPORT_FUNC(Py_ReprLeave)
EXPORT_FUNC(Py_SetPath)
EXPORT_FUNC(Py_SetProgramName)
EXPORT_FUNC(Py_SetPythonHome)
EXPORT_FUNC(Py_SetRecursionLimit)
EXPORT_FUNC(Py_TYPE)
EXPORT_FUNC(Py_VaBuildValue)
EXPORT_FUNC(Py_XNewRef)
EXPORT_FUNC(PyAIter_Check)
EXPORT_FUNC(PyArg_Parse)
EXPORT_FUNC(PyArg_ParseTuple)
EXPORT_FUNC(PyArg_ParseTupleAndKeywords)
EXPORT_FUNC(PyArg_UnpackTuple)
EXPORT_FUNC(PyArg_ValidateKeywordArguments)
EXPORT_FUNC(PyArg_VaParse)
EXPORT_FUNC(PyArg_VaParseTupleAndKeywords)
EXPORT_FUNC(PyBool_FromLong)
EXPORT_FUNC(PyBuffer_FillContiguousStrides)
EXPORT_FUNC(PyBuffer_FillInfo)
EXPORT_FUNC(PyBuffer_FromContiguous)
EXPORT_FUNC(PyBuffer_GetPointer)
EXPORT_FUNC(PyBuffer_IsContiguous)
EXPORT_FUNC(PyBuffer_Release)
EXPORT_FUNC(PyBuffer_SizeFromFormat)
EXPORT_FUNC(PyBuffer_ToContiguous)
EXPORT_FUNC(PyByteArray_AsString)
EXPORT_FUNC(PyByteArray_Concat)
EXPORT_FUNC(PyByteArray_FromObject)
EXPORT_FUNC(PyByteArray_FromStringAndSize)
EXPORT_FUNC(PyByteArray_Resize)
EXPORT_FUNC(PyByteArray_Size)
EXPORT_FUNC(PyBytes_AsString)
EXPORT_FUNC(PyBytes_AsStringAndSize)
EXPORT_FUNC(PyBytes_Concat)
EXPORT_FUNC(PyBytes_ConcatAndDel)
EXPORT_FUNC(PyBytes_DecodeEscape)
EXPORT_FUNC(PyBytes_FromFormat)
EXPORT_FUNC(PyBytes_FromFormatV)
EXPORT_FUNC(PyBytes_FromObject)
EXPORT_FUNC(PyBytes_FromString)
EXPORT_FUNC(PyBytes_FromStringAndSize)
EXPORT_FUNC(PyBytes_Repr)
EXPORT_FUNC(PyBytes_Size)
EXPORT_FUNC(PyCallable_Check)
EXPORT_FUNC(PyCallIter_New)
EXPORT_FUNC(PyCapsule_GetContext)
EXPORT_FUNC(PyCapsule_GetDestructor)
EXPORT_FUNC(PyCapsule_GetName)
EXPORT_FUNC(PyCapsule_GetPointer)
EXPORT_FUNC(PyCapsule_Import)
EXPORT_FUNC(PyCapsule_IsValid)
EXPORT_FUNC(PyCapsule_New)
EXPORT_FUNC(PyCapsule_SetContext)
EXPORT_FUNC(PyCapsule_SetDestructor)
EXPORT_FUNC(PyCapsule_SetName)
EXPORT_FUNC(PyCapsule_SetPointer)
EXPORT_FUNC(PyCFunction_Call)
EXPORT_FUNC(PyCFunction_GetFlags)
EXPORT_FUNC(PyCFunction_GetFunction)
EXPORT_FUNC(PyCFunction_GetSelf)
EXPORT_FUNC(PyCFunction_New)
EXPORT_FUNC(PyCFunction_NewEx)
EXPORT_FUNC(PyCMethod_New)
EXPORT_FUNC(PyCodec_BackslashReplaceErrors)
EXPORT_FUNC(PyCodec_Decode)
EXPORT_FUNC(PyCodec_Decoder)
EXPORT_FUNC(PyCodec_Encode)
EXPORT_FUNC(PyCodec_Encoder)
EXPORT_FUNC(PyCodec_IgnoreErrors)
EXPORT_FUNC(PyCodec_IncrementalDecoder)
EXPORT_FUNC(PyCodec_IncrementalEncoder)
EXPORT_FUNC(PyCodec_KnownEncoding)
EXPORT_FUNC(PyCodec_LookupError)
EXPORT_FUNC(PyCodec_NameReplaceErrors)
EXPORT_FUNC(PyCodec_Register)
EXPORT_FUNC(PyCodec_RegisterError)
EXPORT_FUNC(PyCodec_ReplaceErrors)
EXPORT_FUNC(PyCodec_StreamReader)
EXPORT_FUNC(PyCodec_StreamWriter)
EXPORT_FUNC(PyCodec_StrictErrors)
EXPORT_FUNC(PyCodec_Unregister)
EXPORT_FUNC(PyCodec_XMLCharRefReplaceErrors)
EXPORT_FUNC(PyComplex_FromDoubles)
EXPORT_FUNC(PyComplex_ImagAsDouble)
EXPORT_FUNC(PyComplex_RealAsDouble)
EXPORT_FUNC(PyDescr_NewClassMethod)
EXPORT_FUNC(PyDescr_NewGetSet)
EXPORT_FUNC(PyDescr_NewMember)
EXPORT_FUNC(PyDescr_NewMethod)
EXPORT_FUNC(PyDict_Clear)
EXPORT_FUNC(PyDict_Contains)
EXPORT_FUNC(PyDict_Copy)
EXPORT_FUNC(PyDict_DelItem)
EXPORT_FUNC(PyDict_DelItemString)
EXPORT_FUNC(PyDict_GetItem)
EXPORT_FUNC(PyDict_GetItemRef)
EXPORT_FUNC(PyDict_GetItemString)
EXPORT_FUNC(PyDict_GetItemStringRef)
EXPORT_FUNC(PyDict_GetItemWithError)
EXPORT_FUNC(PyDict_Items)
EXPORT_FUNC(PyDict_Keys)
EXPORT_FUNC(PyDict_Merge)
EXPORT_FUNC(PyDict_MergeFromSeq2)
EXPORT_FUNC(PyDict_New)
EXPORT_FUNC(PyDict_Next)
EXPORT_FUNC(PyDict_SetItem)
EXPORT_FUNC(PyDict_SetItemString)
EXPORT_FUNC(PyDict_Size)
EXPORT_FUNC(PyDict_Update)
EXPORT_FUNC(PyDict_Values)
EXPORT_FUNC(PyDictProxy_New)
EXPORT_FUNC(PyErr_BadArgument)
EXPORT_FUNC(PyErr_BadInternalCall)
EXPORT_FUNC(PyErr_CheckSignals)
EXPORT_FUNC(PyErr_Clear)
EXPORT_FUNC(PyErr_Display)
EXPORT_FUNC(PyErr_DisplayException)
EXPORT_FUNC(PyErr_ExceptionMatches)
EXPORT_FUNC(PyErr_Fetch)
EXPORT_FUNC(PyErr_Format)
EXPORT_FUNC(PyErr_FormatV)
EXPORT_FUNC(PyErr_GetExcInfo)
EXPORT_FUNC(PyErr_GetHandledException)
EXPORT_FUNC(PyErr_GetRaisedException)
EXPORT_FUNC(PyErr_GivenExceptionMatches)
EXPORT_FUNC(PyErr_NewException)
EXPORT_FUNC(PyErr_NewExceptionWithDoc)
EXPORT_FUNC(PyErr_NoMemory)
EXPORT_FUNC(PyErr_NormalizeException)
EXPORT_FUNC(PyErr_Occurred)
EXPORT_FUNC(PyErr_Print)
EXPORT_FUNC(PyErr_PrintEx)
EXPORT_FUNC(PyErr_ProgramText)
EXPORT_FUNC(PyErr_ResourceWarning)
EXPORT_FUNC(PyErr_Restore)
EXPORT_FUNC(PyErr_SetExcFromWindowsErr)
EXPORT_FUNC(PyErr_SetExcFromWindowsErrWithFilename)
EXPORT_FUNC(PyErr_SetExcFromWindowsErrWithFilenameObject)
EXPORT_FUNC(PyErr_SetExcFromWindowsErrWithFilenameObjects)
EXPORT_FUNC(PyErr_SetExcInfo)
EXPORT_FUNC(PyErr_SetFromErrno)
EXPORT_FUNC(PyErr_SetFromErrnoWithFilename)
EXPORT_FUNC(PyErr_SetFromErrnoWithFilenameObject)
EXPORT_FUNC(PyErr_SetFromErrnoWithFilenameObjects)
EXPORT_FUNC(PyErr_SetFromWindowsErr)
EXPORT_FUNC(PyErr_SetFromWindowsErrWithFilename)
EXPORT_FUNC(PyErr_SetHandledException)
EXPORT_FUNC(PyErr_SetImportError)
EXPORT_FUNC(PyErr_SetImportErrorSubclass)
EXPORT_FUNC(PyErr_SetInterrupt)
EXPORT_FUNC(PyErr_SetInterruptEx)
EXPORT_FUNC(PyErr_SetNone)
EXPORT_FUNC(PyErr_SetObject)
EXPORT_FUNC(PyErr_SetRaisedException)
EXPORT_FUNC(PyErr_SetString)
EXPORT_FUNC(PyErr_SyntaxLocation)
EXPORT_FUNC(PyErr_SyntaxLocationEx)
EXPORT_FUNC(PyErr_WarnEx)
EXPORT_FUNC(PyErr_WarnExplicit)
EXPORT_FUNC(PyErr_WarnFormat)
EXPORT_FUNC(PyErr_WriteUnraisable)
EXPORT_FUNC(PyEval_AcquireLock)
EXPORT_FUNC(PyEval_AcquireThread)
EXPORT_FUNC(PyEval_CallFunction)
EXPORT_FUNC(PyEval_CallMethod)
EXPORT_FUNC(PyEval_CallObjectWithKeywords)
EXPORT_FUNC(PyEval_EvalCode)
EXPORT_FUNC(PyEval_EvalCodeEx)
EXPORT_FUNC(PyEval_EvalFrame)
EXPORT_FUNC(PyEval_EvalFrameEx)
EXPORT_FUNC(PyEval_GetBuiltins)
EXPORT_FUNC(PyEval_GetFrame)
EXPORT_FUNC(PyEval_GetFrameBuiltins)
EXPORT_FUNC(PyEval_GetFrameGlobals)
EXPORT_FUNC(PyEval_GetFrameLocals)
EXPORT_FUNC(PyEval_GetFuncDesc)
EXPORT_FUNC(PyEval_GetFuncName)
EXPORT_FUNC(PyEval_GetGlobals)
EXPORT_FUNC(PyEval_GetLocals)
EXPORT_FUNC(PyEval_InitThreads)
EXPORT_FUNC(PyEval_ReleaseLock)
EXPORT_FUNC(PyEval_ReleaseThread)
EXPORT_FUNC(PyEval_RestoreThread)
EXPORT_FUNC(PyEval_SaveThread)
EXPORT_FUNC(PyEval_ThreadsInitialized)
EXPORT_FUNC(PyException_GetArgs)
EXPORT_FUNC(PyException_GetCause)
EXPORT_FUNC(PyException_GetContext)
EXPORT_FUNC(PyException_GetTraceback)
EXPORT_FUNC(PyException_SetArgs)
EXPORT_FUNC(PyException_SetCause)
EXPORT_FUNC(PyException_SetContext)
EXPORT_FUNC(PyException_SetTraceback)
EXPORT_FUNC(PyExceptionClass_Name)
EXPORT_FUNC(PyFile_FromFd)
EXPORT_FUNC(PyFile_GetLine)
EXPORT_FUNC(PyFile_WriteObject)
EXPORT_FUNC(PyFile_WriteString)
EXPORT_FUNC(PyFloat_AsDouble)
EXPORT_FUNC(PyFloat_FromDouble)
EXPORT_FUNC(PyFloat_FromString)
EXPORT_FUNC(PyFloat_GetInfo)
EXPORT_FUNC(PyFloat_GetMax)
EXPORT_FUNC(PyFloat_GetMin)
EXPORT_FUNC(PyFrame_GetCode)
EXPORT_FUNC(PyFrame_GetLineNumber)
EXPORT_FUNC(PyFrozenSet_New)
EXPORT_FUNC(PyGC_Collect)
EXPORT_FUNC(PyGC_Disable)
EXPORT_FUNC(PyGC_Enable)
EXPORT_FUNC(PyGC_IsEnabled)
EXPORT_FUNC(PyGILState_Ensure)
EXPORT_FUNC(PyGILState_GetThisThreadState)
EXPORT_FUNC(PyGILState_Release)
EXPORT_FUNC(PyImport_AddModule)
EXPORT_FUNC(PyImport_AddModuleObject)
EXPORT_FUNC(PyImport_AddModuleRef)
EXPORT_FUNC(PyImport_AppendInittab)
EXPORT_FUNC(PyImport_ExecCodeModule)
EXPORT_FUNC(PyImport_ExecCodeModuleEx)
EXPORT_FUNC(PyImport_ExecCodeModuleObject)
EXPORT_FUNC(PyImport_ExecCodeModuleWithPathnames)
EXPORT_FUNC(PyImport_GetImporter)
EXPORT_FUNC(PyImport_GetMagicNumber)
EXPORT_FUNC(PyImport_GetMagicTag)
EXPORT_FUNC(PyImport_GetModule)
EXPORT_FUNC(PyImport_GetModuleDict)
EXPORT_FUNC(PyImport_Import)
EXPORT_FUNC(PyImport_ImportFrozenModule)
EXPORT_FUNC(PyImport_ImportFrozenModuleObject)
EXPORT_FUNC(PyImport_ImportModule)
EXPORT_FUNC(PyImport_ImportModuleLevel)
EXPORT_FUNC(PyImport_ImportModuleLevelObject)
EXPORT_FUNC(PyImport_ImportModuleNoBlock)
EXPORT_FUNC(PyImport_ReloadModule)
EXPORT_FUNC(PyIndex_Check)
EXPORT_FUNC(PyInterpreterState_Clear)
EXPORT_FUNC(PyInterpreterState_Delete)
EXPORT_FUNC(PyInterpreterState_Get)
EXPORT_FUNC(PyInterpreterState_GetDict)
EXPORT_FUNC(PyInterpreterState_GetID)
EXPORT_FUNC(PyInterpreterState_New)
EXPORT_FUNC(PyIter_Check)
EXPORT_FUNC(PyIter_Next)
EXPORT_FUNC(PyIter_NextItem)
EXPORT_FUNC(PyIter_Send)
EXPORT_FUNC(PyList_Append)
EXPORT_FUNC(PyList_AsTuple)
EXPORT_FUNC(PyList_GetItem)
EXPORT_FUNC(PyList_GetItemRef)
EXPORT_FUNC(PyList_GetSlice)
EXPORT_FUNC(PyList_Insert)
EXPORT_FUNC(PyList_New)
EXPORT_FUNC(PyList_Reverse)
EXPORT_FUNC(PyList_SetItem)
EXPORT_FUNC(PyList_SetSlice)
EXPORT_FUNC(PyList_Size)
EXPORT_FUNC(PyList_Sort)
EXPORT_FUNC(PyLong_AsDouble)
EXPORT_FUNC(PyLong_AsInt)
EXPORT_FUNC(PyLong_AsInt32)
EXPORT_FUNC(PyLong_AsInt64)
EXPORT_FUNC(PyLong_AsLong)
EXPORT_FUNC(PyLong_AsLongAndOverflow)
EXPORT_FUNC(PyLong_AsLongLong)
EXPORT_FUNC(PyLong_AsLongLongAndOverflow)
EXPORT_FUNC(PyLong_AsSize_t)
EXPORT_FUNC(PyLong_AsSsize_t)
EXPORT_FUNC(PyLong_AsUInt32)
EXPORT_FUNC(PyLong_AsUInt64)
EXPORT_FUNC(PyLong_AsUnsignedLong)
EXPORT_FUNC(PyLong_AsUnsignedLongLong)
EXPORT_FUNC(PyLong_AsUnsignedLongLongMask)
EXPORT_FUNC(PyLong_AsUnsignedLongMask)
EXPORT_FUNC(PyLong_AsVoidPtr)
EXPORT_FUNC(PyLong_FromDouble)
EXPORT_FUNC(PyLong_FromInt32)
EXPORT_FUNC(PyLong_FromInt64)
EXPORT_FUNC(PyLong_FromLong)
EXPORT_FUNC(PyLong_FromLongLong)
EXPORT_FUNC(PyLong_FromSize_t)
EXPORT_FUNC(PyLong_FromSsize_t)
EXPORT_FUNC(PyLong_FromString)
EXPORT_FUNC(PyLong_FromUInt32)
EXPORT_FUNC(PyLong_FromUInt64)
EXPORT_FUNC(PyLong_FromUnsignedLong)
EXPORT_FUNC(PyLong_FromUnsignedLongLong)
EXPORT_FUNC(PyLong_FromVoidPtr)
EXPORT_FUNC(PyLong_GetInfo)
EXPORT_FUNC(PyMapping_Check)
EXPORT_FUNC(PyMapping_GetItemString)
EXPORT_FUNC(PyMapping_GetOptionalItem)
EXPORT_FUNC(PyMapping_GetOptionalItemString)
EXPORT_FUNC(PyMapping_HasKey)
EXPORT_FUNC(PyMapping_HasKeyString)
EXPORT_FUNC(PyMapping_HasKeyStringWithError)
EXPORT_FUNC(PyMapping_HasKeyWithError)
EXPORT_FUNC(PyMapping_Items)
EXPORT_FUNC(PyMapping_Keys)
EXPORT_FUNC(PyMapping_Length)
EXPORT_FUNC(PyMapping_SetItemString)
EXPORT_FUNC(PyMapping_Size)
EXPORT_FUNC(PyMapping_Values)
EXPORT_FUNC(PyMarshal_ReadObjectFromString)
EXPORT_FUNC(PyMarshal_WriteObjectToString)
EXPORT_FUNC(PyMem_Calloc)
EXPORT_FUNC(PyMem_Free)
EXPORT_FUNC(PyMem_Malloc)
EXPORT_FUNC(PyMem_RawCalloc)
EXPORT_FUNC(PyMem_RawFree)
EXPORT_FUNC(PyMem_RawMalloc)
EXPORT_FUNC(PyMem_RawRealloc)
EXPORT_FUNC(PyMem_Realloc)
EXPORT_FUNC(PyMember_GetOne)
EXPORT_FUNC(PyMember_SetOne)
EXPORT_FUNC(PyMemoryView_FromBuffer)
EXPORT_FUNC(PyMemoryView_FromMemory)
EXPORT_FUNC(PyMemoryView_FromObject)
EXPORT_FUNC(PyMemoryView_GetContiguous)
EXPORT_FUNC(PyModule_Add)
EXPORT_FUNC(PyModule_AddFunctions)
EXPORT_FUNC(PyModule_AddIntConstant)
EXPORT_FUNC(PyModule_AddObject)
EXPORT_FUNC(PyModule_AddObjectRef)
EXPORT_FUNC(PyModule_AddStringConstant)
EXPORT_FUNC(PyModule_AddType)
EXPORT_FUNC(PyModule_Create2)
EXPORT_FUNC(PyModule_ExecDef)
EXPORT_FUNC(PyModule_FromDefAndSpec2)
EXPORT_FUNC(PyModule_GetDef)
EXPORT_FUNC(PyModule_GetDict)
EXPORT_FUNC(PyModule_GetFilename)
EXPORT_FUNC(PyModule_GetFilenameObject)
EXPORT_FUNC(PyModule_GetName)
EXPORT_FUNC(PyModule_GetNameObject)
EXPORT_FUNC(PyModule_GetState)
EXPORT_FUNC(PyModule_New)
EXPORT_FUNC(PyModule_NewObject)
EXPORT_FUNC(PyModule_SetDocString)
EXPORT_FUNC(PyModuleDef_Init)
EXPORT_FUNC(PyNumber_Absolute)
EXPORT_FUNC(PyNumber_Add)
EXPORT_FUNC(PyNumber_And)
EXPORT_FUNC(PyNumber_AsSsize_t)
EXPORT_FUNC(PyNumber_Check)
EXPORT_FUNC(PyNumber_Divmod)
EXPORT_FUNC(PyNumber_Float)
EXPORT_FUNC(PyNumber_FloorDivide)
EXPORT_FUNC(PyNumber_Index)
EXPORT_FUNC(PyNumber_InPlaceAdd)
EXPORT_FUNC(PyNumber_InPlaceAnd)
EXPORT_FUNC(PyNumber_InPlaceFloorDivide)
EXPORT_FUNC(PyNumber_InPlaceLshift)
EXPORT_FUNC(PyNumber_InPlaceMatrixMultiply)
EXPORT_FUNC(PyNumber_InPlaceMultiply)
EXPORT_FUNC(PyNumber_InPlaceOr)
EXPORT_FUNC(PyNumber_InPlacePower)
EXPORT_FUNC(PyNumber_InPlaceRemainder)
EXPORT_FUNC(PyNumber_InPlaceRshift)
EXPORT_FUNC(PyNumber_InPlaceSubtract)
EXPORT_FUNC(PyNumber_InPlaceTrueDivide)
EXPORT_FUNC(PyNumber_InPlaceXor)
EXPORT_FUNC(PyNumber_Invert)
EXPORT_FUNC(PyNumber_Long)
EXPORT_FUNC(PyNumber_Lshift)
EXPORT_FUNC(PyNumber_MatrixMultiply)
EXPORT_FUNC(PyNumber_Multiply)
EXPORT_FUNC(PyNumber_Negative)
EXPORT_FUNC(PyNumber_Or)
EXPORT_FUNC(PyNumber_Positive)
EXPORT_FUNC(PyNumber_Power)
EXPORT_FUNC(PyNumber_Remainder)
EXPORT_FUNC(PyNumber_Rshift)
EXPORT_FUNC(PyNumber_Subtract)
EXPORT_FUNC(PyNumber_ToBase)
EXPORT_FUNC(PyNumber_TrueDivide)
EXPORT_FUNC(PyNumber_Xor)
EXPORT_FUNC(PyObject_AsCharBuffer)
EXPORT_FUNC(PyObject_ASCII)
EXPORT_FUNC(PyObject_AsFileDescriptor)
EXPORT_FUNC(PyObject_AsReadBuffer)
EXPORT_FUNC(PyObject_AsWriteBuffer)
EXPORT_FUNC(PyObject_Bytes)
EXPORT_FUNC(PyObject_Call)
EXPORT_FUNC(PyObject_CallFunction)
EXPORT_FUNC(PyObject_CallFunctionObjArgs)
EXPORT_FUNC(PyObject_CallMethod)
EXPORT_FUNC(PyObject_CallMethodObjArgs)
EXPORT_FUNC(PyObject_CallNoArgs)
EXPORT_FUNC(PyObject_CallObject)
EXPORT_FUNC(PyObject_Calloc)
EXPORT_FUNC(PyObject_CheckBuffer)
EXPORT_FUNC(PyObject_CheckReadBuffer)
EXPORT_FUNC(PyObject_ClearWeakRefs)
EXPORT_FUNC(PyObject_CopyData)
EXPORT_FUNC(PyObject_DelAttr)
EXPORT_FUNC(PyObject_DelAttrString)
EXPORT_FUNC(PyObject_DelItem)
EXPORT_FUNC(PyObject_DelItemString)
EXPORT_FUNC(PyObject_Dir)
EXPORT_FUNC(PyObject_Format)
EXPORT_FUNC(PyObject_Free)
EXPORT_FUNC(PyObject_GC_Del)
EXPORT_FUNC(PyObject_GC_IsFinalized)
EXPORT_FUNC(PyObject_GC_IsTracked)
EXPORT_FUNC(PyObject_GC_Track)
EXPORT_FUNC(PyObject_GC_UnTrack)
EXPORT_FUNC(PyObject_GenericGetAttr)
EXPORT_FUNC(PyObject_GenericGetDict)
EXPORT_FUNC(PyObject_GenericSetAttr)
EXPORT_FUNC(PyObject_GenericSetDict)
EXPORT_FUNC(PyObject_GetAIter)
EXPORT_FUNC(PyObject_GetAttr)
EXPORT_FUNC(PyObject_GetAttrString)
EXPORT_FUNC(PyObject_GetBuffer)
EXPORT_FUNC(PyObject_GetItem)
EXPORT_FUNC(PyObject_GetIter)
EXPORT_FUNC(PyObject_GetOptionalAttr)
EXPORT_FUNC(PyObject_GetOptionalAttrString)
EXPORT_FUNC(PyObject_GetTypeData)
EXPORT_FUNC(PyObject_HasAttr)
EXPORT_FUNC(PyObject_HasAttrString)
EXPORT_FUNC(PyObject_HasAttrStringWithError)
EXPORT_FUNC(PyObject_HasAttrWithError)
EXPORT_FUNC(PyObject_Hash)
EXPORT_FUNC(PyObject_HashNotImplemented)
EXPORT_FUNC(PyObject_Init)
EXPORT_FUNC(PyObject_InitVar)
EXPORT_FUNC(PyObject_IsInstance)
EXPORT_FUNC(PyObject_IsSubclass)
EXPORT_FUNC(PyObject_IsTrue)
EXPORT_FUNC(PyObject_Length)
EXPORT_FUNC(PyObject_Malloc)
EXPORT_FUNC(PyObject_Not)
EXPORT_FUNC(PyObject_Realloc)
EXPORT_FUNC(PyObject_Repr)
EXPORT_FUNC(PyObject_RichCompare)
EXPORT_FUNC(PyObject_RichCompareBool)
EXPORT_FUNC(PyObject_SelfIter)
EXPORT_FUNC(PyObject_SetAttr)
EXPORT_FUNC(PyObject_SetAttrString)
EXPORT_FUNC(PyObject_SetItem)
EXPORT_FUNC(PyObject_Size)
EXPORT_FUNC(PyObject_Str)
EXPORT_FUNC(PyObject_Type)
EXPORT_FUNC(PyObject_Vectorcall)
EXPORT_FUNC(PyObject_VectorcallMethod)
EXPORT_FUNC(PyOS_CheckStack)
EXPORT_FUNC(PyOS_double_to_string)
EXPORT_FUNC(PyOS_FSPath)
EXPORT_FUNC(PyOS_getsig)
EXPORT_FUNC(PyOS_InterruptOccurred)
EXPORT_FUNC(PyOS_mystricmp)
EXPORT_FUNC(PyOS_mystrnicmp)
EXPORT_FUNC(PyOS_setsig)
EXPORT_FUNC(PyOS_snprintf)
EXPORT_FUNC(PyOS_string_to_double)
EXPORT_FUNC(PyOS_strtol)
EXPORT_FUNC(PyOS_strtoul)
EXPORT_FUNC(PyOS_vsnprintf)
EXPORT_FUNC(PySeqIter_New)
EXPORT_FUNC(PySequence_Check)
EXPORT_FUNC(PySequence_Concat)
EXPORT_FUNC(PySequence_Contains)
EXPORT_FUNC(PySequence_Count)
EXPORT_FUNC(PySequence_DelItem)
EXPORT_FUNC(PySequence_DelSlice)
EXPORT_FUNC(PySequence_Fast)
EXPORT_FUNC(PySequence_GetItem)
EXPORT_FUNC(PySequence_GetSlice)
EXPORT_FUNC(PySequence_In)
EXPORT_FUNC(PySequence_Index)
EXPORT_FUNC(PySequence_InPlaceConcat)
EXPORT_FUNC(PySequence_InPlaceRepeat)
EXPORT_FUNC(PySequence_Length)
EXPORT_FUNC(PySequence_List)
EXPORT_FUNC(PySequence_Repeat)
EXPORT_FUNC(PySequence_SetItem)
EXPORT_FUNC(PySequence_SetSlice)
EXPORT_FUNC(PySequence_Size)
EXPORT_FUNC(PySequence_Tuple)
EXPORT_FUNC(PySet_Add)
EXPORT_FUNC(PySet_Clear)
EXPORT_FUNC(PySet_Contains)
EXPORT_FUNC(PySet_Discard)
EXPORT_FUNC(PySet_New)
EXPORT_FUNC(PySet_Pop)
EXPORT_FUNC(PySet_Size)
EXPORT_FUNC(PySlice_AdjustIndices)
EXPORT_FUNC(PySlice_GetIndices)
EXPORT_FUNC(PySlice_GetIndicesEx)
EXPORT_FUNC(PySlice_New)
EXPORT_FUNC(PySlice_Unpack)
EXPORT_FUNC(PyState_AddModule)
EXPORT_FUNC(PyState_FindModule)
EXPORT_FUNC(PyState_RemoveModule)
EXPORT_FUNC(PyStructSequence_GetItem)
EXPORT_FUNC(PyStructSequence_New)
EXPORT_FUNC(PyStructSequence_NewType)
EXPORT_FUNC(PyStructSequence_SetItem)
EXPORT_FUNC(PySys_AddWarnOption)
EXPORT_FUNC(PySys_AddWarnOptionUnicode)
EXPORT_FUNC(PySys_AddXOption)
EXPORT_FUNC(PySys_Audit)
EXPORT_FUNC(PySys_AuditTuple)
EXPORT_FUNC(PySys_FormatStderr)
EXPORT_FUNC(PySys_FormatStdout)
EXPORT_FUNC(PySys_GetObject)
EXPORT_FUNC(PySys_GetXOptions)
EXPORT_FUNC(PySys_HasWarnOptions)
EXPORT_FUNC(PySys_ResetWarnOptions)
EXPORT_FUNC(PySys_SetArgv)
EXPORT_FUNC(PySys_SetArgvEx)
EXPORT_FUNC(PySys_SetObject)
EXPORT_FUNC(PySys_SetPath)
EXPORT_FUNC(PySys_WriteStderr)
EXPORT_FUNC(PySys_WriteStdout)
EXPORT_FUNC(PyThread_acquire_lock)
EXPORT_FUNC(PyThread_acquire_lock_timed)
EXPORT_FUNC(PyThread_allocate_lock)
EXPORT_FUNC(PyThread_create_key)
EXPORT_FUNC(PyThread_delete_key)
EXPORT_FUNC(PyThread_delete_key_value)
EXPORT_FUNC(PyThread_exit_thread)
EXPORT_FUNC(PyThread_free_lock)
EXPORT_FUNC(PyThread_get_key_value)
EXPORT_FUNC(PyThread_get_stacksize)
EXPORT_FUNC(PyThread_get_thread_ident)
EXPORT_FUNC(PyThread_get_thread_native_id)
EXPORT_FUNC(PyThread_GetInfo)
EXPORT_FUNC(PyThread_init_thread)
EXPORT_FUNC(PyThread_ReInitTLS)
EXPORT_FUNC(PyThread_release_lock)
EXPORT_FUNC(PyThread_set_key_value)
EXPORT_FUNC(PyThread_set_stacksize)
EXPORT_FUNC(PyThread_start_new_thread)
EXPORT_FUNC(PyThread_tss_alloc)
EXPORT_FUNC(PyThread_tss_create)
EXPORT_FUNC(PyThread_tss_delete)
EXPORT_FUNC(PyThread_tss_free)
EXPORT_FUNC(PyThread_tss_get)
EXPORT_FUNC(PyThread_tss_is_created)
EXPORT_FUNC(PyThread_tss_set)
EXPORT_FUNC(PyThreadState_Clear)
EXPORT_FUNC(PyThreadState_Delete)
EXPORT_FUNC(PyThreadState_DeleteCurrent)
EXPORT_FUNC(PyThreadState_Get)
EXPORT_FUNC(PyThreadState_GetDict)
EXPORT_FUNC(PyThreadState_GetFrame)
EXPORT_FUNC(PyThreadState_GetID)
EXPORT_FUNC(PyThreadState_GetInterpreter)
EXPORT_FUNC(PyThreadState_New)
EXPORT_FUNC(PyThreadState_SetAsyncExc)
EXPORT_FUNC(PyThreadState_Swap)
EXPORT_FUNC(PyTraceBack_Here)
EXPORT_FUNC(PyTraceBack_Print)
EXPORT_FUNC(PyTuple_GetItem)
EXPORT_FUNC(PyTuple_GetSlice)
EXPORT_FUNC(PyTuple_New)
EXPORT_FUNC(PyTuple_Pack)
EXPORT_FUNC(PyTuple_SetItem)
EXPORT_FUNC(PyTuple_Size)
EXPORT_FUNC(PyType_ClearCache)
EXPORT_FUNC(PyType_Freeze)
EXPORT_FUNC(PyType_FromMetaclass)
EXPORT_FUNC(PyType_FromModuleAndSpec)
EXPORT_FUNC(PyType_FromSpec)
EXPORT_FUNC(PyType_FromSpecWithBases)
EXPORT_FUNC(PyType_GenericAlloc)
EXPORT_FUNC(PyType_GenericNew)
EXPORT_FUNC(PyType_GetBaseByToken)
EXPORT_FUNC(PyType_GetFlags)
EXPORT_FUNC(PyType_GetFullyQualifiedName)
EXPORT_FUNC(PyType_GetModule)
EXPORT_FUNC(PyType_GetModuleByDef)
EXPORT_FUNC(PyType_GetModuleName)
EXPORT_FUNC(PyType_GetModuleState)
EXPORT_FUNC(PyType_GetName)
EXPORT_FUNC(PyType_GetQualName)
EXPORT_FUNC(PyType_GetSlot)
EXPORT_FUNC(PyType_GetTypeDataSize)
EXPORT_FUNC(PyType_IsSubtype)
EXPORT_FUNC(PyType_Modified)
EXPORT_FUNC(PyType_Ready)
EXPORT_FUNC(PyUnicode_Append)
EXPORT_FUNC(PyUnicode_AppendAndDel)
EXPORT_FUNC(PyUnicode_AsASCIIString)
EXPORT_FUNC(PyUnicode_AsCharmapString)
EXPORT_FUNC(PyUnicode_AsDecodedObject)
EXPORT_FUNC(PyUnicode_AsDecodedUnicode)
EXPORT_FUNC(PyUnicode_AsEncodedObject)
EXPORT_FUNC(PyUnicode_AsEncodedString)
EXPORT_FUNC(PyUnicode_AsEncodedUnicode)
EXPORT_FUNC(PyUnicode_AsLatin1String)
EXPORT_FUNC(PyUnicode_AsMBCSString)
EXPORT_FUNC(PyUnicode_AsRawUnicodeEscapeString)
EXPORT_FUNC(PyUnicode_AsUCS4)
EXPORT_FUNC(PyUnicode_AsUCS4Copy)
EXPORT_FUNC(PyUnicode_AsUnicodeEscapeString)
EXPORT_FUNC(PyUnicode_AsUTF16String)
EXPORT_FUNC(PyUnicode_AsUTF32String)
EXPORT_FUNC(PyUnicode_AsUTF8AndSize)
EXPORT_FUNC(PyUnicode_AsUTF8String)
EXPORT_FUNC(PyUnicode_AsWideChar)
EXPORT_FUNC(PyUnicode_AsWideCharString)
EXPORT_FUNC(PyUnicode_BuildEncodingMap)
EXPORT_FUNC(PyUnicode_Compare)
EXPORT_FUNC(PyUnicode_CompareWithASCIIString)
EXPORT_FUNC(PyUnicode_Concat)
EXPORT_FUNC(PyUnicode_Contains)
EXPORT_FUNC(PyUnicode_Count)
EXPORT_FUNC(PyUnicode_Decode)
EXPORT_FUNC(PyUnicode_DecodeASCII)
EXPORT_FUNC(PyUnicode_DecodeCharmap)
EXPORT_FUNC(PyUnicode_DecodeCodePageStateful)
EXPORT_FUNC(PyUnicode_DecodeFSDefault)
EXPORT_FUNC(PyUnicode_DecodeFSDefaultAndSize)
EXPORT_FUNC(PyUnicode_DecodeLatin1)
EXPORT_FUNC(PyUnicode_DecodeLocale)
EXPORT_FUNC(PyUnicode_DecodeLocaleAndSize)
EXPORT_FUNC(PyUnicode_DecodeMBCS)
EXPORT_FUNC(PyUnicode_DecodeMBCSStateful)
EXPORT_FUNC(PyUnicode_DecodeRawUnicodeEscape)
EXPORT_FUNC(PyUnicode_DecodeUnicodeEscape)
EXPORT_FUNC(PyUnicode_DecodeUTF16)
EXPORT_FUNC(PyUnicode_DecodeUTF16Stateful)
EXPORT_FUNC(PyUnicode_DecodeUTF32)
EXPORT_FUNC(PyUnicode_DecodeUTF32Stateful)
EXPORT_FUNC(PyUnicode_DecodeUTF7)
EXPORT_FUNC(PyUnicode_DecodeUTF7Stateful)
EXPORT_FUNC(PyUnicode_DecodeUTF8)
EXPORT_FUNC(PyUnicode_DecodeUTF8Stateful)
EXPORT_FUNC(PyUnicode_EncodeCodePage)
EXPORT_FUNC(PyUnicode_EncodeFSDefault)
EXPORT_FUNC(PyUnicode_EncodeLocale)
EXPORT_FUNC(PyUnicode_Equal)
EXPORT_FUNC(PyUnicode_EqualToUTF8)
EXPORT_FUNC(PyUnicode_EqualToUTF8AndSize)
EXPORT_FUNC(PyUnicode_Find)
EXPORT_FUNC(PyUnicode_FindChar)
EXPORT_FUNC(PyUnicode_Format)
EXPORT_FUNC(PyUnicode_FromEncodedObject)
EXPORT_FUNC(PyUnicode_FromFormat)
EXPORT_FUNC(PyUnicode_FromFormatV)
EXPORT_FUNC(PyUnicode_FromObject)
EXPORT_FUNC(PyUnicode_FromOrdinal)
EXPORT_FUNC(PyUnicode_FromString)
EXPORT_FUNC(PyUnicode_FromStringAndSize)
EXPORT_FUNC(PyUnicode_FromWideChar)
EXPORT_FUNC(PyUnicode_FSConverter)
EXPORT_FUNC(PyUnicode_FSDecoder)
EXPORT_FUNC(PyUnicode_GetDefaultEncoding)
EXPORT_FUNC(PyUnicode_GetLength)
EXPORT_FUNC(PyUnicode_GetSize)
EXPORT_FUNC(PyUnicode_InternFromString)
EXPORT_FUNC(PyUnicode_InternImmortal)
EXPORT_FUNC(PyUnicode_InternInPlace)
EXPORT_FUNC(PyUnicode_IsIdentifier)
EXPORT_FUNC(PyUnicode_Join)
EXPORT_FUNC(PyUnicode_Partition)
EXPORT_FUNC(PyUnicode_ReadChar)
EXPORT_FUNC(PyUnicode_Replace)
EXPORT_FUNC(PyUnicode_Resize)
EXPORT_FUNC(PyUnicode_RichCompare)
EXPORT_FUNC(PyUnicode_RPartition)
EXPORT_FUNC(PyUnicode_RSplit)
EXPORT_FUNC(PyUnicode_Split)
EXPORT_FUNC(PyUnicode_Splitlines)
EXPORT_FUNC(PyUnicode_Substring)
EXPORT_FUNC(PyUnicode_Tailmatch)
EXPORT_FUNC(PyUnicode_Translate)
EXPORT_FUNC(PyUnicode_WriteChar)
EXPORT_FUNC(PyUnicodeDecodeError_Create)
EXPORT_FUNC(PyUnicodeDecodeError_GetEncoding)
EXPORT_FUNC(PyUnicodeDecodeError_GetEnd)
EXPORT_FUNC(PyUnicodeDecodeError_GetObject)
EXPORT_FUNC(PyUnicodeDecodeError_GetReason)
EXPORT_FUNC(PyUnicodeDecodeError_GetStart)
EXPORT_FUNC(PyUnicodeDecodeError_SetEnd)
EXPORT_FUNC(PyUnicodeDecodeError_SetReason)
EXPORT_FUNC(PyUnicodeDecodeError_SetStart)
EXPORT_FUNC(PyUnicodeEncodeError_GetEncoding)
EXPORT_FUNC(PyUnicodeEncodeError_GetEnd)
EXPORT_FUNC(PyUnicodeEncodeError_GetObject)
EXPORT_FUNC(PyUnicodeEncodeError_GetReason)
EXPORT_FUNC(PyUnicodeEncodeError_GetStart)
EXPORT_FUNC(PyUnicodeEncodeError_SetEnd)
EXPORT_FUNC(PyUnicodeEncodeError_SetReason)
EXPORT_FUNC(PyUnicodeEncodeError_SetStart)
EXPORT_FUNC(PyUnicodeTranslateError_GetEnd)
EXPORT_FUNC(PyUnicodeTranslateError_GetObject)
EXPORT_FUNC(PyUnicodeTranslateError_GetReason)
EXPORT_FUNC(PyUnicodeTranslateError_GetStart)
EXPORT_FUNC(PyUnicodeTranslateError_SetEnd)
EXPORT_FUNC(PyUnicodeTranslateError_SetReason)
EXPORT_FUNC(PyUnicodeTranslateError_SetStart)
EXPORT_FUNC(PyVectorcall_Call)
EXPORT_FUNC(PyVectorcall_NARGS)
EXPORT_FUNC(PyWeakref_GetObject)
EXPORT_FUNC(PyWeakref_GetRef)
EXPORT_FUNC(PyWeakref_NewProxy)
EXPORT_FUNC(PyWeakref_NewRef)
EXPORT_FUNC(PyWrapper_New)

EXPORT_DATA(_Py_EllipsisObject)
EXPORT_DATA(_Py_FalseStruct)
EXPORT_DATA(_Py_NoneStruct)
EXPORT_DATA(_Py_NotImplementedStruct)
EXPORT_DATA(_Py_RefTotal)
EXPORT_DATA(_Py_SwappedOp)
EXPORT_DATA(_Py_TrueStruct)
EXPORT_DATA(_PyWeakref_CallableProxyType)
EXPORT_DATA(_PyWeakref_ProxyType)
EXPORT_DATA(_PyWeakref_RefType)
EXPORT_DATA(Py_FileSystemDefaultEncodeErrors)
EXPORT_DATA(Py_FileSystemDefaultEncoding)
EXPORT_DATA(Py_GenericAliasType)
EXPORT_DATA(Py_HasFileSystemDefaultEncoding)
EXPORT_DATA(Py_UTF8Mode)
EXPORT_DATA(Py_Version)
EXPORT_DATA(PyBaseObject_Type)
EXPORT_DATA(PyBool_Type)
EXPORT_DATA(PyByteArray_Type)
EXPORT_DATA(PyByteArrayIter_Type)
EXPORT_DATA(PyBytes_Type)
EXPORT_DATA(PyBytesIter_Type)
EXPORT_DATA(PyCallIter_Type)
EXPORT_DATA(PyCapsule_Type)
EXPORT_DATA(PyCFunction_Type)
EXPORT_DATA(PyClassMethodDescr_Type)
EXPORT_DATA(PyComplex_Type)
EXPORT_DATA(PyDict_Type)
EXPORT_DATA(PyDictItems_Type)
EXPORT_DATA(PyDictIterItem_Type)
EXPORT_DATA(PyDictIterKey_Type)
EXPORT_DATA(PyDictIterValue_Type)
EXPORT_DATA(PyDictKeys_Type)
EXPORT_DATA(PyDictProxy_Type)
EXPORT_DATA(PyDictRevIterItem_Type)
EXPORT_DATA(PyDictRevIterKey_Type)
EXPORT_DATA(PyDictRevIterValue_Type)
EXPORT_DATA(PyDictValues_Type)
EXPORT_DATA(PyEllipsis_Type)
EXPORT_DATA(PyEnum_Type)
EXPORT_DATA(PyExc_ArithmeticError)
EXPORT_DATA(PyExc_AssertionError)
EXPORT_DATA(PyExc_AttributeError)
EXPORT_DATA(PyExc_BaseException)
EXPORT_DATA(PyExc_BaseExceptionGroup)
EXPORT_DATA(PyExc_BlockingIOError)
EXPORT_DATA(PyExc_BrokenPipeError)
EXPORT_DATA(PyExc_BufferError)
EXPORT_DATA(PyExc_BytesWarning)
EXPORT_DATA(PyExc_ChildProcessError)
EXPORT_DATA(PyExc_ConnectionAbortedError)
EXPORT_DATA(PyExc_ConnectionError)
EXPORT_DATA(PyExc_ConnectionRefusedError)
EXPORT_DATA(PyExc_ConnectionResetError)
EXPORT_DATA(PyExc_DeprecationWarning)
EXPORT_DATA(PyExc_EncodingWarning)
EXPORT_DATA(PyExc_EnvironmentError)
EXPORT_DATA(PyExc_EOFError)
EXPORT_DATA(PyExc_Exception)
EXPORT_DATA(PyExc_FileExistsError)
EXPORT_DATA(PyExc_FileNotFoundError)
EXPORT_DATA(PyExc_FloatingPointError)
EXPORT_DATA(PyExc_FutureWarning)
EXPORT_DATA(PyExc_GeneratorExit)
EXPORT_DATA(PyExc_ImportError)
EXPORT_DATA(PyExc_ImportWarning)
EXPORT_DATA(PyExc_IndentationError)
EXPORT_DATA(PyExc_IndexError)
EXPORT_DATA(PyExc_InterruptedError)
EXPORT_DATA(PyExc_IOError)
EXPORT_DATA(PyExc_IsADirectoryError)
EXPORT_DATA(PyExc_KeyboardInterrupt)
EXPORT_DATA(PyExc_KeyError)
EXPORT_DATA(PyExc_LookupError)
EXPORT_DATA(PyExc_MemoryError)
EXPORT_DATA(PyExc_ModuleNotFoundError)
EXPORT_DATA(PyExc_NameError)
EXPORT_DATA(PyExc_NotADirectoryError)
EXPORT_DATA(PyExc_NotImplementedError)
EXPORT_DATA(PyExc_OSError)
EXPORT_DATA(PyExc_OverflowError)
EXPORT_DATA(PyExc_PendingDeprecationWarning)
EXPORT_DATA(PyExc_PermissionError)
EXPORT_DATA(PyExc_ProcessLookupError)
EXPORT_DATA(PyExc_RecursionError)
EXPORT_DATA(PyExc_ReferenceError)
EXPORT_DATA(PyExc_ResourceWarning)
EXPORT_DATA(PyExc_RuntimeError)
EXPORT_DATA(PyExc_RuntimeWarning)
EXPORT_DATA(PyExc_StopAsyncIteration)
EXPORT_DATA(PyExc_StopIteration)
EXPORT_DATA(PyExc_SyntaxError)
EXPORT_DATA(PyExc_SyntaxWarning)
EXPORT_DATA(PyExc_SystemError)
EXPORT_DATA(PyExc_SystemExit)
EXPORT_DATA(PyExc_TabError)
EXPORT_DATA(PyExc_TimeoutError)
EXPORT_DATA(PyExc_TypeError)
EXPORT_DATA(PyExc_UnboundLocalError)
EXPORT_DATA(PyExc_UnicodeDecodeError)
EXPORT_DATA(PyExc_UnicodeEncodeError)
EXPORT_DATA(PyExc_UnicodeError)
EXPORT_DATA(PyExc_UnicodeTranslateError)
EXPORT_DATA(PyExc_UnicodeWarning)
EXPORT_DATA(PyExc_UserWarning)
EXPORT_DATA(PyExc_ValueError)
EXPORT_DATA(PyExc_Warning)
EXPORT_DATA(PyExc_WindowsError)
EXPORT_DATA(PyExc_ZeroDivisionError)
EXPORT_DATA(PyFilter_Type)
EXPORT_DATA(PyFloat_Type)
EXPORT_DATA(PyFrozenSet_Type)
EXPORT_DATA(PyGetSetDescr_Type)
EXPORT_DATA(PyList_Type)
EXPORT_DATA(PyListIter_Type)
EXPORT_DATA(PyListRevIter_Type)
EXPORT_DATA(PyLong_Type)
EXPORT_DATA(PyLongRangeIter_Type)
EXPORT_DATA(PyMap_Type)
EXPORT_DATA(PyMemberDescr_Type)
EXPORT_DATA(PyMemoryView_Type)
EXPORT_DATA(PyMethodDescr_Type)
EXPORT_DATA(PyModule_Type)
EXPORT_DATA(PyModuleDef_Type)
EXPORT_DATA(PyOS_InputHook)
EXPORT_DATA(PyProperty_Type)
EXPORT_DATA(PyRange_Type)
EXPORT_DATA(PyRangeIter_Type)
EXPORT_DATA(PyReversed_Type)
EXPORT_DATA(PySeqIter_Type)
EXPORT_DATA(PySet_Type)
EXPORT_DATA(PySetIter_Type)
EXPORT_DATA(PySlice_Type)
EXPORT_DATA(PyStructSequence_UnnamedField)
EXPORT_DATA(PySuper_Type)
EXPORT_DATA(PyTraceBack_Type)
EXPORT_DATA(PyTuple_Type)
EXPORT_DATA(PyTupleIter_Type)
EXPORT_DATA(PyType_Type)
EXPORT_DATA(PyUnicode_Type)
EXPORT_DATA(PyUnicodeIter_Type)
EXPORT_DATA(PyWrapperDescr_Type)
EXPORT_DATA(PyZip_Type)


================================================
File: /PC/python_exe.rc
================================================
// Resource script for Python console EXEs.

#include "python_ver_rc.h"

#ifndef RT_MANIFEST
// bpo-45220: Cannot reliably #include RT_MANIFEST from
// anywhere, so we hardcode it
#define RT_MANIFEST 24
#endif

// Include the manifest file that indicates we support all
// current versions of Windows.
1 RT_MANIFEST "python.manifest"

1 ICON DISCARDABLE "icons\python.ico" 


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION PYVERSION64
 PRODUCTVERSION PYVERSION64
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
            VALUE "CompanyName", PYTHON_COMPANY "\0"
            VALUE "FileDescription", "Python\0"
            VALUE "FileVersion", PYTHON_VERSION
            VALUE "InternalName", "Python Console\0"
            VALUE "LegalCopyright", PYTHON_COPYRIGHT "\0"
            VALUE "OriginalFilename", "python" PYTHON_DEBUG_EXT ".exe\0"
            VALUE "ProductName", "Python\0"
            VALUE "ProductVersion", PYTHON_VERSION
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END


================================================
File: /PC/python_nt.rc
================================================
// Resource script for Python core DLL.

#include "python_ver_rc.h"

#ifndef RT_MANIFEST
// bpo-45220: Cannot reliably #include RT_MANIFEST from
// anywhere, so we hardcode it
#define RT_MANIFEST 24
#endif

// Include the manifest file that indicates we support all
// current versions of Windows.
2 RT_MANIFEST "python.manifest"

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION PYVERSION64
 PRODUCTVERSION PYVERSION64
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_DLL
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
            VALUE "CompanyName", PYTHON_COMPANY "\0"
            VALUE "FileDescription", "Python Core\0"
            VALUE "FileVersion", PYTHON_VERSION
            VALUE "InternalName", "Python DLL\0"
            VALUE "LegalCopyright", PYTHON_COPYRIGHT "\0"
            VALUE "OriginalFilename", ORIGINAL_FILENAME "\0"
            VALUE "ProductName", "Python\0"
            VALUE "ProductVersion", PYTHON_VERSION
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END


================================================
File: /PC/python_uwp.cpp
================================================
/* Main program when embedded in a UWP application on Windows */

#include "Python.h"
#include <string.h>

#define WIN32_LEAN_AND_MEAN
#include <Windows.h>
#include <shellapi.h>
#include <shlobj.h>

#include <string>

#include <appmodel.h>
#include <winrt\Windows.ApplicationModel.h>
#include <winrt\Windows.Storage.h>

#ifdef PYTHONW
#ifdef _DEBUG
const wchar_t *PROGNAME = L"pythonw_d.exe";
#else
const wchar_t *PROGNAME = L"pythonw.exe";
#endif
#else
#ifdef _DEBUG
const wchar_t *PROGNAME = L"python_d.exe";
#else
const wchar_t *PROGNAME = L"python.exe";
#endif
#endif

static std::wstring
get_package_family()
{
    try {
        UINT32 nameLength = MAX_PATH;
        std::wstring name;
        name.resize(nameLength);
        DWORD rc = GetCurrentPackageFamilyName(&nameLength, name.data());
        if (rc == ERROR_SUCCESS) {
            name.resize(nameLength - 1);
            return name;
        }
        else if (rc != ERROR_INSUFFICIENT_BUFFER) {
            throw rc;
        }
        name.resize(nameLength);
        rc = GetCurrentPackageFamilyName(&nameLength, name.data());
        if (rc != ERROR_SUCCESS) {
            throw rc;
        }
        name.resize(nameLength - 1);
        return name;
    }
    catch (...) {
    }

    return std::wstring();
}

static std::wstring
get_user_base()
{
    try {
        const auto appData = winrt::Windows::Storage::ApplicationData::Current();
        if (appData) {
            const auto localCache = appData.LocalCacheFolder();
            if (localCache) {
                std::wstring path { localCache.Path().c_str() };
                if (!path.empty()) {
                    return path + L"\\local-packages";
                }
            }
        }
    } catch (...) {
    }

    return std::wstring();
}

static std::wstring
get_package_home()
{
    try {
        UINT32 pathLength = MAX_PATH;
        std::wstring path;
        path.resize(pathLength);
        DWORD rc = GetCurrentPackagePath(&pathLength, path.data());
        if (rc == ERROR_SUCCESS) {
            path.resize(pathLength - 1);
            return path;
        }
        else if (rc != ERROR_INSUFFICIENT_BUFFER) {
            throw rc;
        }
        path.resize(pathLength);
        rc = GetCurrentPackagePath(&pathLength, path.data());
        if (rc != ERROR_SUCCESS) {
            throw rc;
        }
        path.resize(pathLength - 1);
        return path;
    }
    catch (...) {
    }

    return std::wstring();
}

static PyStatus
set_process_name(PyConfig *config)
{
    PyStatus status = PyStatus_Ok();
    std::wstring executable;

    const auto home = get_package_home();
    const auto family = get_package_family();

    if (!family.empty()) {
        PWSTR localAppData;
        if (SUCCEEDED(SHGetKnownFolderPath(FOLDERID_LocalAppData, 0,
                                           NULL, &localAppData))) {
            executable = std::wstring(localAppData)
                         + L"\\Microsoft\\WindowsApps\\"
                         + family
                         + L"\\"
                         + PROGNAME;

            CoTaskMemFree(localAppData);
        }
    }

    /* Only use module filename if we don't have a home */
    if (home.empty() && executable.empty()) {
        executable.resize(MAX_PATH);
        while (true) {
            DWORD len = GetModuleFileNameW(
                NULL, executable.data(), (DWORD)executable.size());
            if (len == 0) {
                executable.clear();
                break;
            } else if (len == executable.size() &&
                       GetLastError() == ERROR_INSUFFICIENT_BUFFER) {
                executable.resize(len * 2);
            } else {
                executable.resize(len);
                break;
            }
        }
        size_t i = executable.find_last_of(L"/\\");
        if (i == std::wstring::npos) {
            executable = PROGNAME;
        } else {
            executable.replace(i + 1, std::wstring::npos, PROGNAME);
        }
    }

    if (!home.empty()) {
        status = PyConfig_SetString(config, &config->home, home.c_str());
        if (PyStatus_Exception(status)) {
            return status;
        }
    }

    const wchar_t *launcherPath = _wgetenv(L"__PYVENV_LAUNCHER__");
    if (launcherPath) {
        if (!executable.empty()) {
            status = PyConfig_SetString(config, &config->base_executable,
                                        executable.c_str());
            if (PyStatus_Exception(status)) {
                return status;
            }
        }

        status = PyConfig_SetString(
            config, &config->executable, launcherPath);

        /* bpo-35873: Clear the environment variable to avoid it being
        * inherited by child processes. */
        _wputenv_s(L"__PYVENV_LAUNCHER__", L"");
    } else if (!executable.empty()) {
        status = PyConfig_SetString(
            config, &config->executable, executable.c_str());
    }

    return status;
}

int
wmain(int argc, wchar_t **argv)
{
    PyStatus status;
    PyPreConfig preconfig;
    PyConfig config;

    const wchar_t *moduleName = NULL;
    const wchar_t *p = wcsrchr(argv[0], L'\\');
    if (!p) {
        p = argv[0];
    }
    if (p) {
        if (*p == L'\\') {
            p++;
        }

        if (wcsnicmp(p, L"pip", 3) == 0) {
            moduleName = L"pip";
        } else if (wcsnicmp(p, L"idle", 4) == 0) {
            moduleName = L"idlelib";
        }
    }

    PyPreConfig_InitPythonConfig(&preconfig);
    if (!moduleName) {
        status = Py_PreInitializeFromArgs(&preconfig, argc, argv);
        if (PyStatus_Exception(status)) {
            goto fail_without_config;
        }
    }

    PyConfig_InitPythonConfig(&config);

    status = PyConfig_SetArgv(&config, argc, argv);
    if (PyStatus_Exception(status)) {
        goto fail;
    }
    if (moduleName) {
        config.parse_argv = 0;
    }

    status = set_process_name(&config);
    if (PyStatus_Exception(status)) {
        goto fail;
    }

    p = _wgetenv(L"PYTHONUSERBASE");
    if (!p || !*p) {
        _wputenv_s(L"PYTHONUSERBASE", get_user_base().c_str());
    }

    if (moduleName) {
        status = PyConfig_SetString(&config, &config.run_module, moduleName);
        if (PyStatus_Exception(status)) {
            goto fail;
        }
        status = PyConfig_SetString(&config, &config.run_filename, NULL);
        if (PyStatus_Exception(status)) {
            goto fail;
        }
        status = PyConfig_SetString(&config, &config.run_command, NULL);
        if (PyStatus_Exception(status)) {
            goto fail;
        }
    }

    status = Py_InitializeFromConfig(&config);
    if (PyStatus_Exception(status)) {
        goto fail;
    }
    PyConfig_Clear(&config);

    return Py_RunMain();

fail:
    PyConfig_Clear(&config);
fail_without_config:
    if (PyStatus_IsExit(status)) {
        return status.exitcode;
    }
    assert(PyStatus_Exception(status));
    Py_ExitStatusException(status);
    /* Unreachable code */
    return 0;
}

#ifdef PYTHONW

int WINAPI wWinMain(
    HINSTANCE hInstance,      /* handle to current instance */
    HINSTANCE hPrevInstance,  /* handle to previous instance */
    LPWSTR lpCmdLine,         /* pointer to command line */
    int nCmdShow              /* show state of window */
)
{
    return wmain(__argc, __wargv);
}

#endif


================================================
File: /PC/python_ver_rc.h
================================================
// Resource script for Python core DLL.
// Currently only holds version information.
//
#pragma code_page(1252)
#include "winver.h"

#define PYTHON_COMPANY   "Python Software Foundation"
#define PYTHON_COPYRIGHT "Copyright \xA9 2001 Python Software Foundation. Copyright \xA9 2000 BeOpen.com. Copyright \xA9 1995-2001 CNRI. Copyright \xA9 1991-1995 SMC."

#define MS_WINDOWS
#include "modsupport.h"
#include "patchlevel.h"
#ifdef _DEBUG
#   define PYTHON_DEBUG_EXT "_d"
#else
#   define PYTHON_DEBUG_EXT
#endif

/* e.g., 3.3.0a1
 * PY_VERSION comes from patchlevel.h
 */
#define PYTHON_VERSION PY_VERSION "\0"

/* 64-bit version number as comma-separated list of 4 16-bit ints */
#if PY_MICRO_VERSION > 64
#   error "PY_MICRO_VERSION > 64"
#endif
#if PY_RELEASE_LEVEL > 99
#   error "PY_RELEASE_LEVEL > 99"
#endif
#if PY_RELEASE_SERIAL > 9
#   error "PY_RELEASE_SERIAL > 9"
#endif
#define PYVERSION64 PY_MAJOR_VERSION, PY_MINOR_VERSION, FIELD3, PYTHON_API_VERSION


================================================
File: /PC/pythonw_exe.rc
================================================
// Resource script for Python console EXEs.

#include "python_ver_rc.h"

#ifndef RT_MANIFEST
// bpo-45220: Cannot reliably #include RT_MANIFEST from
// anywhere, so we hardcode it
#define RT_MANIFEST 24
#endif

// Include the manifest file that indicates we support all
// current versions of Windows.
1 RT_MANIFEST "python.manifest"

1 ICON DISCARDABLE "icons\pythonw.ico" 


/////////////////////////////////////////////////////////////////////////////
//
// Version
//

VS_VERSION_INFO VERSIONINFO
 FILEVERSION PYVERSION64
 PRODUCTVERSION PYVERSION64
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_APP
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
            VALUE "CompanyName", PYTHON_COMPANY "\0"
            VALUE "FileDescription", "Python\0"
            VALUE "FileVersion", PYTHON_VERSION
            VALUE "InternalName", "Python Application\0"
            VALUE "LegalCopyright", PYTHON_COPYRIGHT "\0"
            VALUE "OriginalFilename", "pythonw" PYTHON_DEBUG_EXT ".exe\0"
            VALUE "ProductName", "Python\0"
            VALUE "ProductVersion", PYTHON_VERSION
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END


================================================
File: /PC/readme.txt
================================================
Welcome to the "PC" subdirectory of the Python distribution
***********************************************************

This "PC" subdirectory contains complete project files to make
several older PC ports of Python, as well as all the PC-specific
Python source files.  It should be located in the root of the
Python distribution, and there should be directories "Modules",
"Objects", "Python", etc. in the parent directory of this "PC"
subdirectory.  Be sure to read the documentation in the Python
distribution.

Python requires library files such as string.py to be available in
one or more library directories.  The search path of libraries is
set up when Python starts.  To see the current Python library search
path, start Python and enter "import sys" and "print sys.path".

All PC ports use this scheme to try to set up a module search path:

  1) The script location; the current directory without script.
  2) The PYTHONPATH variable, if set.
  3) Paths specified in the Registry.
  4) Default directories lib, lib/win, lib/test, lib/tkinter;
     these are searched relative to the environment variable
     PYTHONHOME, if set, or relative to the executable and its
     ancestors, if a landmark file (Lib/string.py) is found ,
     or the current directory (not useful).
  5) The directory containing the executable.

The best installation strategy is to put the Python executable and
DLL in some convenient directory such as
C:/python, and copy all library files and subdirectories (using XCOPY)
to C:/python/lib.  Then you don't need to set PYTHONPATH.  Otherwise,
set the environment variable PYTHONPATH to your Python search path.
For example,
   set PYTHONPATH=.;d:\python\lib;d:\python\lib\win;d:\python\lib\dos-8x3

There are several add-in modules to build Python programs which use
the native Windows operating environment.  The ports here just make
"QuickWin" and DOS Python versions which support a character-mode
(console) environment.  Look in www.python.org for Tkinter, PythonWin,
WPY and wxPython.

To make a Python port, start the Integrated Development Environment
(IDE) of your compiler, and read in the native "project file"
(or makefile) provided.  This will enable you to change any source
files or build settings so you can make custom builds.

pyconfig.h    An important configuration file specific to PC's.

config.c    The list of C modules to include in the Python PC
            version.  Manually edit this file to add or
            remove Python modules.


Additional files and subdirectories for 32-bit Windows
======================================================

python_nt.rc   Resource compiler input for python15.dll.

dl_nt.c
               Additional sources used for 32-bit Windows features.


Note for Windows 3.x and DOS users
==================================

Neither Windows 3.x nor DOS is supported any more.  The last Python
version that supported these was Python 1.5.2; the support files were
present in Python 2.0 but weren't updated, and it is not our intention
to support these platforms for Python 2.x.


================================================
File: /PC/sqlite3.rc
================================================
// Resource script for Sqlite DLL.

#include <winver.h>

#ifndef RT_MANIFEST
// bpo-45220: Cannot reliably #include RT_MANIFEST from
// anywhere, so we hardcode it
#define RT_MANIFEST 24
#endif

// Include the manifest file that indicates we support all
// current versions of Windows.
2 RT_MANIFEST "python.manifest"

/////////////////////////////////////////////////////////////////////////////
//
// Version
//

#define _S(x) #x
#define S(x) _S(x)

VS_VERSION_INFO VERSIONINFO
 FILEVERSION SQLITE_MAJOR_VERSION, SQLITE_MINOR_VERSION, SQLITE_MICRO_VERSION, SQLITE_PATCH_VERSION
 PRODUCTVERSION SQLITE_MAJOR_VERSION, SQLITE_MINOR_VERSION, SQLITE_MICRO_VERSION, SQLITE_PATCH_VERSION
 FILEFLAGSMASK 0x3fL
#ifdef _DEBUG
 FILEFLAGS VS_FF_DEBUG
#else
 FILEFLAGS 0x0L
#endif
 FILEOS VOS__WINDOWS32
 FILETYPE VFT_DLL
 FILESUBTYPE 0x0L
BEGIN
    BLOCK "StringFileInfo"
    BEGIN
        BLOCK "000004b0"
        BEGIN
            VALUE "CompanyName", "SQLite3\0"
            VALUE "FileDescription", "SQLite3\0"
            VALUE "FileVersion", S(SQLITE_VERSION) "\0"
            VALUE "InternalName", "SQLite3 DLL\0"
            VALUE "LegalCopyright", "Unspecified\0"
            VALUE "OriginalFilename", "sqlite3.dll\0"
            VALUE "ProductName", "SQLite3\0"
            VALUE "ProductVersion", S(SQLITE_VERSION) "\0"
        END
    END
    BLOCK "VarFileInfo"
    BEGIN
        VALUE "Translation", 0x0, 1200
    END
END


================================================
File: /PC/store_info.txt
================================================
# Overview

NOTE: This file requires more content.

Since Python 3.7.2, releases have been made through the Microsoft Store
to allow easy installation on Windows 10.0.17763.0 and later.

# Building

To build the store package, the PC/layout script should be used.
Execute the directory with the build of Python to package, and pass
"-h" for full command-line options.

To sideload test builds, you will need a local certificate.
Instructions are available at
https://docs.microsoft.com/windows/uwp/packaging/create-certificate-package-signing.

After exporting your certificate, you will need the subject name and
SHA256 hash. The `certutil -dump <cert file>` command will display this
information.

To build for sideloading, use these commands in PowerShell:

```
$env:APPX_DATA_PUBLISHER=<your certificate subject name>
$env:APPX_DATA_SHA256=<your certificate SHA256>
$env:SigningCertificateFile=<your certificate file>

python PC/layout --copy <layout directory> --include-appxmanifest
Tools/msi/make_appx.ps1 <layout directory> python.msix -sign

Add-AppxPackage python.msix
```

(Note that only the last command requires PowerShell, and the others
can be used from Command Prompt. You can also double-click to install
the final package.)

To build for publishing to the Store, use these commands:

```
$env:APPX_DATA_PUBLISHER = $null
$env:APPX_DATA_SHA256 = $null

python PC/layout --copy <layout directory> --preset-appxmanifest --precompile
Tools/msi/make_appx.ps1 <layout directory> python.msix
```

Note that this package cannot be installed locally. It may only be
added to a submission for the store.


# Submission Metadata

This file contains the text that we use to fill out the store listing
for the Microsoft Store. It needs to be entered manually when creating
a new submission via the dashboard at
https://partner.microsoft.com/dashboard.

We keep it here for convenience and to allow it to be updated via pull
requests.

When submitting a new app, the HeadlessAppBypass waiver will be needed.
To request this, send an email to PartnerOps@microsoft.com with the app
ID (12 character token available from the dashboard). The waiver needs
to be applied *before* uploading the package (as of November 2019).

Ensure that the new app is named "Python.3.X", where X is the minor
version of the release. If the name provided initially does not match
the name used when building the package, the upload will fail. The
display name shown to users can be set later.

## Title

Python 3.9

## Short Title

Python

## Description

Python is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple but effective approach to object-oriented programming. Pythons elegant syntax and dynamic typing, together with its interpreted nature, make it an ideal language for scripting and rapid application development in many areas on most platforms.

The Python interpreter and the extensive standard library are freely available in source or binary form for all major platforms from the Python web site, https://www.python.org/, and may be freely distributed. The same site also contains distributions of and pointers to many free third party Python modules, programs and tools, and additional documentation.

The Python interpreter is easily extended with new functions and data types implemented in C or C++ (or other languages callable from C). Python is also suitable as an extension language for customizable applications.

## ShortDescription

The Python 3.9 interpreter and runtime.

## Copyright Trademark Information

(c) Python Software Foundation

## Additional License Terms

Visit https://docs.python.org/3.9/license.html for latest license terms.

PSF LICENSE AGREEMENT FOR PYTHON 3.9

1. This LICENSE AGREEMENT is between the Python Software Foundation ("PSF"), and
   the Individual or Organization ("Licensee") accessing and otherwise using Python
   3.9 software in source or binary form and its associated documentation.

2. Subject to the terms and conditions of this License Agreement, PSF hereby
   grants Licensee a nonexclusive, royalty-free, world-wide license to reproduce,
   analyze, test, perform and/or display publicly, prepare derivative works,
   distribute, and otherwise use Python 3.9 alone or in any derivative
   version, provided, however, that PSF's License Agreement and PSF's notice of
   copyright, i.e., "Copyright  2001 Python Software Foundation; All Rights
   Reserved" are retained in Python 3.9 alone or in any derivative version
   prepared by Licensee.

3. In the event Licensee prepares a derivative work that is based on or
   incorporates Python 3.9 or any part thereof, and wants to make the
   derivative work available to others as provided herein, then Licensee hereby
   agrees to include in any such work a brief summary of the changes made to Python
   3.9.

4. PSF is making Python 3.9 available to Licensee on an "AS IS" basis.
   PSF MAKES NO REPRESENTATIONS OR WARRANTIES, EXPRESS OR IMPLIED.  BY WAY OF
   EXAMPLE, BUT NOT LIMITATION, PSF MAKES NO AND DISCLAIMS ANY REPRESENTATION OR
   WARRANTY OF MERCHANTABILITY OR FITNESS FOR ANY PARTICULAR PURPOSE OR THAT THE
   USE OF PYTHON 3.9 WILL NOT INFRINGE ANY THIRD PARTY RIGHTS.

5. PSF SHALL NOT BE LIABLE TO LICENSEE OR ANY OTHER USERS OF PYTHON 3.9
   FOR ANY INCIDENTAL, SPECIAL, OR CONSEQUENTIAL DAMAGES OR LOSS AS A RESULT OF
   MODIFYING, DISTRIBUTING, OR OTHERWISE USING PYTHON 3.9, OR ANY DERIVATIVE
   THEREOF, EVEN IF ADVISED OF THE POSSIBILITY THEREOF.

6. This License Agreement will automatically terminate upon a material breach of
   its terms and conditions.

7. Nothing in this License Agreement shall be deemed to create any relationship
   of agency, partnership, or joint venture between PSF and Licensee.  This License
   Agreement does not grant permission to use PSF trademarks or trade name in a
   trademark sense to endorse or promote products or services of Licensee, or any
   third party.

8. By copying, installing or otherwise using Python 3.9, Licensee agrees
   to be bound by the terms and conditions of this License Agreement.

## Features

* Easy to install Python runtime
* Supported by core CPython team
* Find Python, Pip and Idle on PATH

## Search Terms

* Python
* Scripting
* Interpreter



================================================
File: /PC/validate_ucrtbase.py
================================================
'''
This script gets the version number from ucrtbased.dll and checks
whether it is a version with a known issue.
'''

import sys

from ctypes import (c_buffer, POINTER, byref, create_unicode_buffer,
                    Structure, WinDLL)
from ctypes.wintypes import DWORD, HANDLE

class VS_FIXEDFILEINFO(Structure):
    _fields_ = [
        ("dwSignature", DWORD),
        ("dwStrucVersion", DWORD),
        ("dwFileVersionMS", DWORD),
        ("dwFileVersionLS", DWORD),
        ("dwProductVersionMS", DWORD),
        ("dwProductVersionLS", DWORD),
        ("dwFileFlagsMask", DWORD),
        ("dwFileFlags", DWORD),
        ("dwFileOS", DWORD),
        ("dwFileType", DWORD),
        ("dwFileSubtype", DWORD),
        ("dwFileDateMS", DWORD),
        ("dwFileDateLS", DWORD),
    ]

kernel32 = WinDLL('kernel32')
version = WinDLL('version')

if len(sys.argv) < 2:
    print('Usage: validate_ucrtbase.py <ucrtbase|ucrtbased>')
    sys.exit(2)

try:
    ucrtbased = WinDLL(sys.argv[1])
except OSError:
    print('Cannot find ucrtbased.dll')
    # This likely means that VS is not installed, but that is an
    # obvious enough problem if you're trying to produce a debug
    # build that we don't need to fail here.
    sys.exit(0)

# We will immediately double the length up to MAX_PATH, but the
# path may be longer, so we retry until the returned string is
# shorter than our buffer.
name_len = actual_len = 130
while actual_len == name_len:
    name_len *= 2
    name = create_unicode_buffer(name_len)
    actual_len = kernel32.GetModuleFileNameW(HANDLE(ucrtbased._handle),
                                             name, len(name))
    if not actual_len:
        print('Failed to get full module name.')
        sys.exit(2)

size = version.GetFileVersionInfoSizeW(name, None)
if not size:
    print('Failed to get size of version info.')
    sys.exit(2)

ver_block = c_buffer(size)
if (not version.GetFileVersionInfoW(name, None, size, ver_block) or
    not ver_block):
    print('Failed to get version info.')
    sys.exit(2)

pvi = POINTER(VS_FIXEDFILEINFO)()
if not version.VerQueryValueW(ver_block, "", byref(pvi), byref(DWORD())):
    print('Failed to get version value from info.')
    sys.exit(2)

ver = (
    pvi.contents.dwProductVersionMS >> 16,
    pvi.contents.dwProductVersionMS & 0xFFFF,
    pvi.contents.dwProductVersionLS >> 16,
    pvi.contents.dwProductVersionLS & 0xFFFF,
)

print('{} is version {}.{}.{}.{}'.format(name.value, *ver))

if ver < (10, 0, 10586):
    print('WARN: ucrtbased contains known issues. '
          'Please update the Windows 10 SDK.')
    print('See:')
    print('  http://bugs.python.org/issue27705')
    print('  https://developer.microsoft.com/en-US/windows/downloads/windows-10-sdk')
    sys.exit(1)


================================================
File: /PC/venvlauncher.c
================================================
/*
 * venv redirector for Windows
 *
 * This launcher looks for a nearby pyvenv.cfg to find the correct home
 * directory, and then launches the original Python executable from it.
 * The name of this executable is passed as argv[0].
 */

#define __STDC_WANT_LIB_EXT1__ 1

#include <windows.h>
#include <pathcch.h>
#include <fcntl.h>
#include <io.h>
#include <shlobj.h>
#include <stdio.h>
#include <stdbool.h>
#include <tchar.h>
#include <assert.h>

#define MS_WINDOWS
#include "patchlevel.h"

#define MAXLEN PATHCCH_MAX_CCH
#define MSGSIZE 1024

#define RC_NO_STD_HANDLES   100
#define RC_CREATE_PROCESS   101
#define RC_NO_PYTHON        103
#define RC_NO_MEMORY        104
#define RC_NO_VENV_CFG      106
#define RC_BAD_VENV_CFG     107
#define RC_NO_COMMANDLINE   108
#define RC_INTERNAL_ERROR   109

// This should always be defined when we build for real,
// but it's handy to have a definition for quick testing
#ifndef EXENAME
#define EXENAME L"python.exe"
#endif

#ifndef CFGNAME
#define CFGNAME L"pyvenv.cfg"
#endif

static FILE * log_fp = NULL;

void
debug(wchar_t * format, ...)
{
    va_list va;

    if (log_fp != NULL) {
        wchar_t buffer[MAXLEN];
        int r = 0;
        va_start(va, format);
        r = vswprintf_s(buffer, MAXLEN, format, va);
        va_end(va);

        if (r <= 0) {
            return;
        }
        fwprintf(log_fp, L"%ls\n", buffer);
        while (r && isspace(buffer[r])) {
            buffer[r--] = L'\0';
        }
        if (buffer[0]) {
            OutputDebugStringW(buffer);
        }
    }
}


void
formatWinerror(int rc, wchar_t * message, int size)
{
    FormatMessageW(
        FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
        NULL, rc, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
        message, size, NULL);
}


void
winerror(int err, wchar_t * format, ... )
{
    va_list va;
    wchar_t message[MSGSIZE];
    wchar_t win_message[MSGSIZE];
    int len;

    if (err == 0) {
        err = GetLastError();
    }

    va_start(va, format);
    len = _vsnwprintf_s(message, MSGSIZE, _TRUNCATE, format, va);
    va_end(va);

    formatWinerror(err, win_message, MSGSIZE);
    if (len >= 0) {
        _snwprintf_s(&message[len], MSGSIZE - len, _TRUNCATE, L": %ls",
                     win_message);
    }

#if !defined(_WINDOWS)
    fwprintf(stderr, L"%ls\n", message);
#else
    MessageBoxW(NULL, message, L"Python venv launcher is sorry to say ...",
               MB_OK);
#endif
}


void
error(wchar_t * format, ... )
{
    va_list va;
    wchar_t message[MSGSIZE];

    va_start(va, format);
    _vsnwprintf_s(message, MSGSIZE, _TRUNCATE, format, va);
    va_end(va);

#if !defined(_WINDOWS)
    fwprintf(stderr, L"%ls\n", message);
#else
    MessageBoxW(NULL, message, L"Python venv launcher is sorry to say ...",
               MB_OK);
#endif
}


bool
isEnvVarSet(const wchar_t *name)
{
    /* only looking for non-empty, which means at least one character
       and the null terminator */
    return GetEnvironmentVariableW(name, NULL, 0) >= 2;
}


bool
join(wchar_t *buffer, size_t bufferLength, const wchar_t *fragment)
{
    if (SUCCEEDED(PathCchCombineEx(buffer, bufferLength, buffer, fragment, PATHCCH_ALLOW_LONG_PATHS))) {
        return true;
    }
    return false;
}


bool
split_parent(wchar_t *buffer, size_t bufferLength)
{
    return SUCCEEDED(PathCchRemoveFileSpec(buffer, bufferLength));
}


/*
 * Path calculation
 */

int
calculate_pyvenvcfg_path(wchar_t *pyvenvcfg_path, size_t maxlen)
{
    if (!pyvenvcfg_path) {
        error(L"invalid buffer provided");
        return RC_INTERNAL_ERROR;
    }
    if ((DWORD)maxlen != maxlen) {
        error(L"path buffer is too large");
        return RC_INTERNAL_ERROR;
    }
    if (!GetModuleFileNameW(NULL, pyvenvcfg_path, (DWORD)maxlen)) {
        winerror(GetLastError(), L"failed to read executable directory");
        return RC_NO_COMMANDLINE;
    }
    // Remove 'python.exe' from our path
    if (!split_parent(pyvenvcfg_path, maxlen)) {
        error(L"failed to remove segment from '%ls'", pyvenvcfg_path);
        return RC_NO_COMMANDLINE;
    }
    // Replace with 'pyvenv.cfg'
    if (!join(pyvenvcfg_path, maxlen, CFGNAME)) {
        error(L"failed to append '%ls' to '%ls'", CFGNAME, pyvenvcfg_path);
        return RC_NO_MEMORY;
    }
    // If it exists, return
    if (GetFileAttributesW(pyvenvcfg_path) != INVALID_FILE_ATTRIBUTES) {
        return 0;
    }
    // Otherwise, remove 'pyvenv.cfg' and (probably) 'Scripts'
    if (!split_parent(pyvenvcfg_path, maxlen) ||
        !split_parent(pyvenvcfg_path, maxlen)) {
        error(L"failed to remove segments from '%ls'", pyvenvcfg_path);
        return RC_NO_COMMANDLINE;
    }
    // Replace 'pyvenv.cfg'
    if (!join(pyvenvcfg_path, maxlen, CFGNAME)) {
        error(L"failed to append '%ls' to '%ls'", CFGNAME, pyvenvcfg_path);
        return RC_NO_MEMORY;
    }
    // If it exists, return
    if (GetFileAttributesW(pyvenvcfg_path) != INVALID_FILE_ATTRIBUTES) {
        return 0;
    }
    // Otherwise, we fail
    winerror(GetLastError(), L"failed to locate %ls", CFGNAME);
    return RC_NO_VENV_CFG;
}


/*
 * pyvenv.cfg parsing
 */

static int
find_home_value(const char *buffer, DWORD maxlen, const char **start, DWORD *length)
{
    if (!buffer || !start || !length) {
        error(L"invalid find_home_value parameters()");
        return 0;
    }
    for (const char *s = strstr(buffer, "home");
         s && (size_t)((ptrdiff_t)s - (ptrdiff_t)buffer) < maxlen;
         s = strstr(s + 1, "\nhome")
    ) {
        if (*s == '\n') {
            ++s;
        }
        for (int i = 4; i > 0 && *s; --i, ++s);

        while (*s && iswspace(*s)) {
            ++s;
        }
        if (*s != L'=') {
            continue;
        }

        do {
            ++s;
        } while (*s && iswspace(*s));

        *start = s;
        char *nl = strchr(s, '\n');
        if (nl) {
            while (nl != s && iswspace(nl[-1])) {
                --nl;
            }
            *length = (DWORD)((ptrdiff_t)nl - (ptrdiff_t)s);
        } else {
            *length = (DWORD)strlen(s);
        }
        return 1;
    }
    return 0;
}


int
read_home(const wchar_t *pyvenv_cfg, wchar_t *home_path, size_t maxlen)
{
    HANDLE hFile = CreateFileW(pyvenv_cfg, GENERIC_READ,
        FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,
        NULL, OPEN_EXISTING, 0, NULL);

    if (hFile == INVALID_HANDLE_VALUE) {
        winerror(GetLastError(), L"failed to open '%ls'", pyvenv_cfg);
        return RC_BAD_VENV_CFG;
    }

    // 8192 characters ought to be enough for anyone
    // (doubled compared to the old implementation!)
    char buffer[8192];
    DWORD len;
    if (!ReadFile(hFile, buffer, sizeof(buffer) - 1, &len, NULL)) {
        winerror(GetLastError(), L"failed to read '%ls'", pyvenv_cfg);
        CloseHandle(hFile);
        return RC_BAD_VENV_CFG;
    }
    CloseHandle(hFile);
    // Ensure null termination
    buffer[len] = '\0';

    char *home;
    DWORD home_len;
    if (!find_home_value(buffer, sizeof(buffer), &home, &home_len)) {
        error(L"no home= specified in '%ls'", pyvenv_cfg);
        return RC_BAD_VENV_CFG;
    }

    if ((DWORD)maxlen != maxlen) {
        maxlen = 8192;
    }
    len = MultiByteToWideChar(CP_UTF8, 0, home, home_len, home_path, (DWORD)maxlen);
    if (!len) {
        winerror(GetLastError(), L"failed to decode home setting in '%ls'", pyvenv_cfg);
        return RC_BAD_VENV_CFG;
    }
    home_path[len] = L'\0';

    return 0;
}


int
locate_python(wchar_t *path, size_t maxlen)
{
    if (!join(path, maxlen, EXENAME)) {
        error(L"failed to append %ls to '%ls'", EXENAME, path);
        return RC_NO_MEMORY;
    }

    if (GetFileAttributesW(path) == INVALID_FILE_ATTRIBUTES) {
        winerror(GetLastError(), L"did not find executable at '%ls'", path);
        return RC_NO_PYTHON;
    }

    return 0;
}


int
smuggle_path()
{
    wchar_t buffer[MAXLEN];
    // We could use argv[0], but that may be wrong in certain rare cases (if the
    // user is doing something weird like symlinks to venv redirectors), and
    // what we _really_ want is the directory of the venv. We always copy the
    // redirectors, so if we've made the venv, this will be correct.
    DWORD len = GetModuleFileNameW(NULL, buffer, MAXLEN);
    if (!len) {
        winerror(GetLastError(), L"Failed to get own executable path");
        return RC_INTERNAL_ERROR;
    }
    buffer[len] = L'\0';
    debug(L"Setting __PYVENV_LAUNCHER__ = '%s'", buffer);

    if (!SetEnvironmentVariableW(L"__PYVENV_LAUNCHER__", buffer)) {
        winerror(GetLastError(), L"Failed to set launcher environment");
        return RC_INTERNAL_ERROR;
    }

    return 0;
}

/*
 * Process creation
 */

static BOOL
safe_duplicate_handle(HANDLE in, HANDLE * pout, const wchar_t *name)
{
    BOOL ok;
    HANDLE process = GetCurrentProcess();
    DWORD rc;

    *pout = NULL;
    ok = DuplicateHandle(process, in, process, pout, 0, TRUE,
                         DUPLICATE_SAME_ACCESS);
    if (!ok) {
        rc = GetLastError();
        if (rc == ERROR_INVALID_HANDLE) {
            debug(L"DuplicateHandle(%ls) returned ERROR_INVALID_HANDLE\n", name);
            ok = TRUE;
        }
        else {
            debug(L"DuplicateHandle(%ls) returned %d\n", name, rc);
        }
    }
    return ok;
}

static BOOL WINAPI
ctrl_c_handler(DWORD code)
{
    return TRUE;    /* We just ignore all control events. */
}

static int
launch(const wchar_t *executable, wchar_t *cmdline)
{
    HANDLE job;
    JOBOBJECT_EXTENDED_LIMIT_INFORMATION info;
    DWORD rc;
    BOOL ok;
    STARTUPINFOW si;
    PROCESS_INFORMATION pi;

#if defined(_WINDOWS)
    /*
    When explorer launches a Windows (GUI) application, it displays
    the "app starting" (the "pointer + hourglass") cursor for a number
    of seconds, or until the app does something UI-ish (eg, creating a
    window, or fetching a message).  As this launcher doesn't do this
    directly, that cursor remains even after the child process does these
    things.  We avoid that by doing a simple post+get message.
    See http://bugs.python.org/issue17290
    */
    MSG msg;

    PostMessage(0, 0, 0, 0);
    GetMessage(&msg, 0, 0, 0);
#endif

    debug(L"run_child: about to run '%ls' with '%ls'\n", executable, cmdline);
    job = CreateJobObject(NULL, NULL);
    ok = QueryInformationJobObject(job, JobObjectExtendedLimitInformation,
                                   &info, sizeof(info), &rc);
    if (!ok || (rc != sizeof(info)) || !job) {
        winerror(GetLastError(), L"Job information querying failed");
        return RC_CREATE_PROCESS;
    }
    info.BasicLimitInformation.LimitFlags |= JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE |
                                             JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK;
    ok = SetInformationJobObject(job, JobObjectExtendedLimitInformation, &info,
                                 sizeof(info));
    if (!ok) {
        winerror(GetLastError(), L"Job information setting failed");
        return RC_CREATE_PROCESS;
    }
    memset(&si, 0, sizeof(si));
    GetStartupInfoW(&si);
    ok = safe_duplicate_handle(GetStdHandle(STD_INPUT_HANDLE), &si.hStdInput, L"stdin");
    if (!ok) {
        return RC_NO_STD_HANDLES;
    }
    ok = safe_duplicate_handle(GetStdHandle(STD_OUTPUT_HANDLE), &si.hStdOutput, L"stdout");
    if (!ok) {
        return RC_NO_STD_HANDLES;
    }
    ok = safe_duplicate_handle(GetStdHandle(STD_ERROR_HANDLE), &si.hStdError, L"stderr");
    if (!ok) {
        return RC_NO_STD_HANDLES;
    }

    ok = SetConsoleCtrlHandler(ctrl_c_handler, TRUE);
    if (!ok) {
        winerror(GetLastError(), L"control handler setting failed");
        return RC_CREATE_PROCESS;
    }

    si.dwFlags = STARTF_USESTDHANDLES;
    ok = CreateProcessW(executable, cmdline, NULL, NULL, TRUE,
                        0, NULL, NULL, &si, &pi);
    if (!ok) {
        winerror(GetLastError(), L"Unable to create process using '%ls'", cmdline);
        return RC_CREATE_PROCESS;
    }
    AssignProcessToJobObject(job, pi.hProcess);
    CloseHandle(pi.hThread);
    WaitForSingleObjectEx(pi.hProcess, INFINITE, FALSE);
    ok = GetExitCodeProcess(pi.hProcess, &rc);
    if (!ok) {
        winerror(GetLastError(), L"Failed to get exit code of process");
        return RC_CREATE_PROCESS;
    }
    debug(L"child process exit code: %d", rc);
    return rc;
}


int
process(int argc, wchar_t ** argv)
{
    int exitCode;
    wchar_t pyvenvcfg_path[MAXLEN];
    wchar_t home_path[MAXLEN];

    if (isEnvVarSet(L"PYLAUNCHER_DEBUG")) {
        setvbuf(stderr, (char *)NULL, _IONBF, 0);
        log_fp = stderr;
    }

    exitCode = calculate_pyvenvcfg_path(pyvenvcfg_path, MAXLEN);
    if (exitCode) return exitCode;

    exitCode = read_home(pyvenvcfg_path, home_path, MAXLEN);
    if (exitCode) return exitCode;

    exitCode = locate_python(home_path, MAXLEN);
    if (exitCode) return exitCode;

    // We do not update argv[0] to point at the target runtime, and so we do not
    // pass through our original argv[0] in an environment variable.
    exitCode = smuggle_path();
    if (exitCode) return exitCode;

    exitCode = launch(home_path, GetCommandLineW());
    return exitCode;
}


#if defined(_WINDOWS)

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPWSTR lpstrCmd, int nShow)
{
    return process(__argc, __wargv);
}

#else

int cdecl wmain(int argc, wchar_t ** argv)
{
    return process(argc, argv);
}

#endif


================================================
File: /PC/winsound.c
================================================
/* Author: Toby Dickenson <htrd90@zepler.org>
 *
 * Copyright (c) 1999 Toby Dickenson
 *
 * Permission to use this software in any way is granted without
 * fee, provided that the copyright notice above appears in all
 * copies. This software is provided "as is" without any warranty.
 */

/* Modified by Guido van Rossum */
/* Beep added by Mark Hammond */
/* Win9X Beep and platform identification added by Uncle Timmy */

/* Example:

   import winsound
   import time

   # Play wav file
   winsound.PlaySound('c:/windows/media/Chord.wav', winsound.SND_FILENAME)

   # Play sound from control panel settings
   winsound.PlaySound('SystemQuestion', winsound.SND_ALIAS)

   # Play wav file from memory
   data=open('c:/windows/media/Chimes.wav',"rb").read()
   winsound.PlaySound(data, winsound.SND_MEMORY)

   # Start playing the first bit of wav file asynchronously
   winsound.PlaySound('c:/windows/media/Chord.wav',
                   winsound.SND_FILENAME|winsound.SND_ASYNC)
   # But don't let it go for too long...
   time.sleep(0.1)
   # ...Before stopping it
   winsound.PlaySound(None, 0)
*/

// Need limited C API version 3.13 for Py_mod_gil
#include "pyconfig.h"  // Py_GIL_DISABLED
#ifndef Py_GIL_DISABLED
#  define Py_LIMITED_API 0x030d0000
#endif

#include <Python.h>
#include <windows.h>
#include <mmsystem.h>

PyDoc_STRVAR(sound_module_doc,
"PlaySound(sound, flags) - play a sound\n"
"SND_FILENAME - sound is a wav file name\n"
"SND_ALIAS - sound is a registry sound association name\n"
"SND_LOOP - Play the sound repeatedly; must also specify SND_ASYNC\n"
"SND_MEMORY - sound is a memory image of a wav file\n"
"SND_PURGE - stop all instances of the specified sound\n"
"SND_ASYNC - PlaySound returns immediately\n"
"SND_NODEFAULT - Do not play a default beep if the sound can not be found\n"
"SND_NOSTOP - Do not interrupt any sounds currently playing\n"  // Raising RuntimeError if needed
"SND_NOWAIT - Return immediately if the sound driver is busy\n" // Without any errors
"\n"
"Beep(frequency, duration) - Make a beep through the PC speaker.\n"
"MessageBeep(type) - Call Windows MessageBeep.");

/*[clinic input]
module winsound
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=a18401142d97b8d5]*/

#include "clinic/winsound.c.h"
