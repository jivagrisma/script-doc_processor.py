    int fd;
    int exit = 0;
    PyThreadState *tstate;
    char *header;
    size_t header_len;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
        "O|iOi:dump_traceback_later", kwlist,
        &timeout_obj, &repeat, &file, &exit))
        return NULL;

    if (_PyTime_FromSecondsObject(&timeout, timeout_obj,
                                  _PyTime_ROUND_TIMEOUT) < 0) {
        return NULL;
    }
    timeout_us = _PyTime_AsMicroseconds(timeout, _PyTime_ROUND_TIMEOUT);
    if (timeout_us <= 0) {
        PyErr_SetString(PyExc_ValueError, "timeout must be greater than 0");
        return NULL;
    }
    /* Limit to LONG_MAX seconds for format_timeout() */
    if (timeout_us > PY_TIMEOUT_MAX || timeout_us / SEC_TO_US > LONG_MAX) {
        PyErr_SetString(PyExc_OverflowError,
                        "timeout value is too large");
        return NULL;
    }

    tstate = get_thread_state();
    if (tstate == NULL) {
        return NULL;
    }

    fd = faulthandler_get_fileno(&file);
    if (fd < 0) {
        return NULL;
    }

    if (!thread.running) {
        thread.running = PyThread_allocate_lock();
        if (!thread.running) {
            return PyErr_NoMemory();
        }
    }
    if (!thread.cancel_event) {
        thread.cancel_event = PyThread_allocate_lock();
        if (!thread.cancel_event || !thread.running) {
            return PyErr_NoMemory();
        }

        /* cancel_event starts to be acquired: it's only released to cancel
           the thread. */
        PyThread_acquire_lock(thread.cancel_event, 1);
    }

    /* format the timeout */
    header = format_timeout(timeout_us);
    if (header == NULL) {
        return PyErr_NoMemory();
    }
    header_len = strlen(header);

    /* Cancel previous thread, if running */
    cancel_dump_traceback_later();

    Py_XINCREF(file);
    Py_XSETREF(thread.file, file);
    thread.fd = fd;
    /* the downcast is safe: we check that 0 < timeout_us < PY_TIMEOUT_MAX */
    thread.timeout_us = (PY_TIMEOUT_T)timeout_us;
    thread.repeat = repeat;
    thread.interp = PyThreadState_GetInterpreter(tstate);
    thread.exit = exit;
    thread.header = header;
    thread.header_len = header_len;

    /* Arm these locks to serve as events when released */
    PyThread_acquire_lock(thread.running, 1);

    if (PyThread_start_new_thread(faulthandler_thread, NULL) == PYTHREAD_INVALID_THREAD_ID) {
        PyThread_release_lock(thread.running);
        Py_CLEAR(thread.file);
        PyMem_Free(header);
        thread.header = NULL;
        PyErr_SetString(PyExc_RuntimeError,
                        "unable to start watchdog thread");
        return NULL;
    }

    Py_RETURN_NONE;
}

static PyObject*
faulthandler_cancel_dump_traceback_later_py(PyObject *self,
                                            PyObject *Py_UNUSED(ignored))
{
    cancel_dump_traceback_later();
    Py_RETURN_NONE;
}


#ifdef FAULTHANDLER_USER
static int
faulthandler_register(int signum, int chain, _Py_sighandler_t *previous_p)
{
#ifdef HAVE_SIGACTION
    struct sigaction action;
    action.sa_handler = faulthandler_user;
    sigemptyset(&action.sa_mask);
    /* if the signal is received while the kernel is executing a system
       call, try to restart the system call instead of interrupting it and
       return EINTR. */
    action.sa_flags = SA_RESTART;
    if (chain) {
        /* do not prevent the signal from being received from within its
           own signal handler */
        action.sa_flags = SA_NODEFER;
    }
#ifdef FAULTHANDLER_USE_ALT_STACK
    assert(stack.ss_sp != NULL);
    /* Call the signal handler on an alternate signal stack
       provided by sigaltstack() */
    action.sa_flags |= SA_ONSTACK;
#endif
    return sigaction(signum, &action, previous_p);
#else
    _Py_sighandler_t previous;
    previous = signal(signum, faulthandler_user);
    if (previous_p != NULL) {
        *previous_p = previous;
    }
    return (previous == SIG_ERR);
#endif
}

/* Handler of user signals (e.g. SIGUSR1).

   Dump the traceback of the current thread, or of all threads if
   thread.all_threads is true.

   This function is signal safe and should only call signal safe functions. */

static void
faulthandler_user(int signum)
{
    user_signal_t *user;
    int save_errno = errno;

    user = &user_signals[signum];
    if (!user->enabled)
        return;

    faulthandler_dump_traceback(user->fd, user->all_threads, user->interp);

#ifdef HAVE_SIGACTION
    if (user->chain) {
        (void)sigaction(signum, &user->previous, NULL);
        errno = save_errno;

        /* call the previous signal handler */
        raise(signum);

        save_errno = errno;
        (void)faulthandler_register(signum, user->chain, NULL);
        errno = save_errno;
    }
#else
    if (user->chain && user->previous != NULL) {
        errno = save_errno;
        /* call the previous signal handler */
        user->previous(signum);
    }
#endif
}

static int
check_signum(int signum)
{
    for (size_t i=0; i < faulthandler_nsignals; i++) {
        if (faulthandler_handlers[i].signum == signum) {
            PyErr_Format(PyExc_RuntimeError,
                         "signal %i cannot be registered, "
                         "use enable() instead",
                         signum);
            return 0;
        }
    }
    if (signum < 1 || Py_NSIG <= signum) {
        PyErr_SetString(PyExc_ValueError, "signal number out of range");
        return 0;
    }
    return 1;
}

static PyObject*
faulthandler_register_py(PyObject *self,
                         PyObject *args, PyObject *kwargs)
{
    static char *kwlist[] = {"signum", "file", "all_threads", "chain", NULL};
    int signum;
    PyObject *file = NULL;
    int all_threads = 1;
    int chain = 0;
    int fd;
    user_signal_t *user;
    _Py_sighandler_t previous;
    PyThreadState *tstate;
    int err;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs,
        "i|Opp:register", kwlist,
        &signum, &file, &all_threads, &chain))
        return NULL;

    if (!check_signum(signum))
        return NULL;

    tstate = get_thread_state();
    if (tstate == NULL)
        return NULL;

    fd = faulthandler_get_fileno(&file);
    if (fd < 0)
        return NULL;

    if (user_signals == NULL) {
        user_signals = PyMem_Calloc(Py_NSIG, sizeof(user_signal_t));
        if (user_signals == NULL)
            return PyErr_NoMemory();
    }
    user = &user_signals[signum];

    if (!user->enabled) {
#ifdef FAULTHANDLER_USE_ALT_STACK
        if (faulthandler_allocate_stack() < 0) {
            return NULL;
        }
#endif

        err = faulthandler_register(signum, chain, &previous);
        if (err) {
            PyErr_SetFromErrno(PyExc_OSError);
            return NULL;
        }

        user->previous = previous;
    }

    Py_XINCREF(file);
    Py_XSETREF(user->file, file);
    user->fd = fd;
    user->all_threads = all_threads;
    user->chain = chain;
    user->interp = PyThreadState_GetInterpreter(tstate);
    user->enabled = 1;

    Py_RETURN_NONE;
}

static int
faulthandler_unregister(user_signal_t *user, int signum)
{
    if (!user->enabled)
        return 0;
    user->enabled = 0;
#ifdef HAVE_SIGACTION
    (void)sigaction(signum, &user->previous, NULL);
#else
    (void)signal(signum, user->previous);
#endif
    Py_CLEAR(user->file);
    user->fd = -1;
    return 1;
}

static PyObject*
faulthandler_unregister_py(PyObject *self, PyObject *args)
{
    int signum;
    user_signal_t *user;
    int change;

    if (!PyArg_ParseTuple(args, "i:unregister", &signum))
        return NULL;

    if (!check_signum(signum))
        return NULL;

    if (user_signals == NULL)
        Py_RETURN_FALSE;

    user = &user_signals[signum];
    change = faulthandler_unregister(user, signum);
    return PyBool_FromLong(change);
}
#endif   /* FAULTHANDLER_USER */


static void
faulthandler_suppress_crash_report(void)
{
#ifdef MS_WINDOWS_DESKTOP
    UINT mode;

    /* Configure Windows to not display the Windows Error Reporting dialog */
    mode = SetErrorMode(SEM_NOGPFAULTERRORBOX);
    SetErrorMode(mode | SEM_NOGPFAULTERRORBOX);
#endif

#ifdef HAVE_SYS_RESOURCE_H
    struct rlimit rl;

    /* Disable creation of core dump */
    if (getrlimit(RLIMIT_CORE, &rl) == 0) {
        rl.rlim_cur = 0;
        setrlimit(RLIMIT_CORE, &rl);
    }
#endif

#ifdef _MSC_VER
    /* Visual Studio: configure abort() to not display an error message nor
       open a popup asking to report the fault. */
    _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);
#endif
}

static PyObject* _Py_NO_SANITIZE_UNDEFINED
faulthandler_read_null(PyObject *self, PyObject *args)
{
    volatile int *x;
    volatile int y;

    faulthandler_suppress_crash_report();
    x = NULL;
    y = *x;
    return PyLong_FromLong(y);

}

static void
faulthandler_raise_sigsegv(void)
{
    faulthandler_suppress_crash_report();
#if defined(MS_WINDOWS)
    /* For SIGSEGV, faulthandler_fatal_error() restores the previous signal
       handler and then gives back the execution flow to the program (without
       explicitly calling the previous error handler). In a normal case, the
       SIGSEGV was raised by the kernel because of a fault, and so if the
       program retries to execute the same instruction, the fault will be
       raised again.

       Here the fault is simulated by a fake SIGSEGV signal raised by the
       application. We have to raise SIGSEGV at lease twice: once for
       faulthandler_fatal_error(), and one more time for the previous signal
       handler. */
    while(1)
        raise(SIGSEGV);
#else
    raise(SIGSEGV);
#endif
}

static PyObject *
faulthandler_sigsegv(PyObject *self, PyObject *args)
{
    int release_gil = 0;
    if (!PyArg_ParseTuple(args, "|i:_sigsegv", &release_gil))
        return NULL;

    if (release_gil) {
        Py_BEGIN_ALLOW_THREADS
        faulthandler_raise_sigsegv();
        Py_END_ALLOW_THREADS
    } else {
        faulthandler_raise_sigsegv();
    }
    Py_RETURN_NONE;
}

static void _Py_NO_RETURN
faulthandler_fatal_error_thread(void *plock)
{
    Py_FatalError("in new thread");
}

static PyObject *
faulthandler_fatal_error_c_thread(PyObject *self, PyObject *args)
{
    long tid;
    PyThread_type_lock lock;

    faulthandler_suppress_crash_report();

    lock = PyThread_allocate_lock();
    if (lock == NULL)
        return PyErr_NoMemory();

    PyThread_acquire_lock(lock, WAIT_LOCK);

    tid = PyThread_start_new_thread(faulthandler_fatal_error_thread, lock);
    if (tid == -1) {
        PyThread_free_lock(lock);
        PyErr_SetString(PyExc_RuntimeError, "unable to start the thread");
        return NULL;
    }

    /* wait until the thread completes: it will never occur, since Py_FatalError()
       exits the process immediately. */
    PyThread_acquire_lock(lock, WAIT_LOCK);
    PyThread_release_lock(lock);
    PyThread_free_lock(lock);

    Py_RETURN_NONE;
}

static PyObject* _Py_NO_SANITIZE_UNDEFINED
faulthandler_sigfpe(PyObject *self, PyObject *args)
{
    faulthandler_suppress_crash_report();

    /* Do an integer division by zero: raise a SIGFPE on Intel CPU, but not on
       PowerPC. Use volatile to disable compile-time optimizations. */
    volatile int x = 1, y = 0, z;
    z = x / y;

    /* If the division by zero didn't raise a SIGFPE (e.g. on PowerPC),
       raise it manually. */
    raise(SIGFPE);

    /* This line is never reached, but we pretend to make something with z
       to silence a compiler warning. */
    return PyLong_FromLong(z);
}

static PyObject *
faulthandler_sigabrt(PyObject *self, PyObject *args)
{
    faulthandler_suppress_crash_report();
    abort();
    Py_RETURN_NONE;
}

#if defined(FAULTHANDLER_USE_ALT_STACK)
#define FAULTHANDLER_STACK_OVERFLOW

static uintptr_t
stack_overflow(uintptr_t min_sp, uintptr_t max_sp, size_t *depth)
{
    /* Allocate (at least) 4096 bytes on the stack at each call.

       bpo-23654, bpo-38965: use volatile keyword to prevent tail call
       optimization. */
    volatile unsigned char buffer[4096];
    uintptr_t sp = (uintptr_t)&buffer;
    *depth += 1;
    if (sp < min_sp || max_sp < sp)
        return sp;
    buffer[0] = 1;
    buffer[4095] = 0;
    return stack_overflow(min_sp, max_sp, depth);
}

static PyObject *
faulthandler_stack_overflow(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    size_t depth, size;
    uintptr_t sp = (uintptr_t)&depth;
    uintptr_t stop, lower_limit, upper_limit;

    faulthandler_suppress_crash_report();
    depth = 0;

    if (STACK_OVERFLOW_MAX_SIZE <= sp) {
        lower_limit = sp - STACK_OVERFLOW_MAX_SIZE;
    }
    else {
        lower_limit = 0;
    }

    if (UINTPTR_MAX - STACK_OVERFLOW_MAX_SIZE >= sp) {
        upper_limit = sp + STACK_OVERFLOW_MAX_SIZE;
    }
    else {
        upper_limit = UINTPTR_MAX;
    }

    stop = stack_overflow(lower_limit, upper_limit, &depth);
    if (sp < stop)
        size = stop - sp;
    else
        size = sp - stop;
    PyErr_Format(PyExc_RuntimeError,
        "unable to raise a stack overflow (allocated %zu bytes "
        "on the stack, %zu recursive calls)",
        size, depth);
    return NULL;
}
#endif   /* defined(FAULTHANDLER_USE_ALT_STACK) && defined(HAVE_SIGACTION) */


static int
faulthandler_traverse(PyObject *module, visitproc visit, void *arg)
{
    Py_VISIT(thread.file);
#ifdef FAULTHANDLER_USER
    if (user_signals != NULL) {
        for (size_t signum=0; signum < Py_NSIG; signum++)
            Py_VISIT(user_signals[signum].file);
    }
#endif
    Py_VISIT(fatal_error.file);
    return 0;
}

#ifdef MS_WINDOWS
static PyObject *
faulthandler_raise_exception(PyObject *self, PyObject *args)
{
    unsigned int code, flags = 0;
    if (!PyArg_ParseTuple(args, "I|I:_raise_exception", &code, &flags))
        return NULL;
    faulthandler_suppress_crash_report();
    RaiseException(code, flags, 0, NULL);
    Py_RETURN_NONE;
}
#endif

PyDoc_STRVAR(module_doc,
"faulthandler module.");

static PyMethodDef module_methods[] = {
    {"enable",
     _PyCFunction_CAST(faulthandler_py_enable), METH_VARARGS|METH_KEYWORDS,
     PyDoc_STR("enable($module, /, file=sys.stderr, all_threads=True)\n--\n\n"
               "Enable the fault handler.")},
    {"disable", faulthandler_disable_py, METH_NOARGS,
     PyDoc_STR("disable($module, /)\n--\n\n"
               "Disable the fault handler.")},
    {"is_enabled", faulthandler_is_enabled, METH_NOARGS,
     PyDoc_STR("is_enabled($module, /)\n--\n\n"
               "Check if the handler is enabled.")},
    {"dump_traceback",
     _PyCFunction_CAST(faulthandler_dump_traceback_py), METH_VARARGS|METH_KEYWORDS,
     PyDoc_STR("dump_traceback($module, /, file=sys.stderr, all_threads=True)\n--\n\n"
               "Dump the traceback of the current thread, or of all threads "
               "if all_threads is True, into file.")},
    {"dump_traceback_later",
     _PyCFunction_CAST(faulthandler_dump_traceback_later), METH_VARARGS|METH_KEYWORDS,
     PyDoc_STR("dump_traceback_later($module, /, timeout, repeat=False, file=sys.stderr, exit=False)\n--\n\n"
               "Dump the traceback of all threads in timeout seconds,\n"
               "or each timeout seconds if repeat is True. If exit is True, "
               "call _exit(1) which is not safe.")},
    {"cancel_dump_traceback_later",
     faulthandler_cancel_dump_traceback_later_py, METH_NOARGS,
     PyDoc_STR("cancel_dump_traceback_later($module, /)\n--\n\n"
               "Cancel the previous call to dump_traceback_later().")},
#ifdef FAULTHANDLER_USER
    {"register",
     _PyCFunction_CAST(faulthandler_register_py), METH_VARARGS|METH_KEYWORDS,
     PyDoc_STR("register($module, /, signum, file=sys.stderr, all_threads=True, chain=False)\n--\n\n"
               "Register a handler for the signal 'signum': dump the "
               "traceback of the current thread, or of all threads if "
               "all_threads is True, into file.")},
    {"unregister",
     _PyCFunction_CAST(faulthandler_unregister_py), METH_VARARGS,
     PyDoc_STR("unregister($module, signum, /)\n--\n\n"
               "Unregister the handler of the signal "
               "'signum' registered by register().")},
#endif
    {"_read_null", faulthandler_read_null, METH_NOARGS,
     PyDoc_STR("_read_null($module, /)\n--\n\n"
               "Read from NULL, raise "
               "a SIGSEGV or SIGBUS signal depending on the platform.")},
    {"_sigsegv", faulthandler_sigsegv, METH_VARARGS,
     PyDoc_STR("_sigsegv($module, release_gil=False, /)\n--\n\n"
               "Raise a SIGSEGV signal.")},
    {"_fatal_error_c_thread", faulthandler_fatal_error_c_thread, METH_NOARGS,
     PyDoc_STR("_fatal_error_c_thread($module, /)\n--\n\n"
               "Call Py_FatalError() in a new C thread.")},
    {"_sigabrt", faulthandler_sigabrt, METH_NOARGS,
     PyDoc_STR("_sigabrt($module, /)\n--\n\n"
               "Raise a SIGABRT signal.")},
    {"_sigfpe", (PyCFunction)faulthandler_sigfpe, METH_NOARGS,
     PyDoc_STR("_sigfpe($module, /)\n--\n\n"
               "Raise a SIGFPE signal.")},
#ifdef FAULTHANDLER_STACK_OVERFLOW
    {"_stack_overflow", faulthandler_stack_overflow, METH_NOARGS,
     PyDoc_STR("_stack_overflow($module, /)\n--\n\n"
               "Recursive call to raise a stack overflow.")},
#endif
#ifdef MS_WINDOWS
    {"_raise_exception", faulthandler_raise_exception, METH_VARARGS,
     PyDoc_STR("_raise_exception($module, code, flags=0, /)\n--\n\n"
               "Call RaiseException(code, flags).")},
#endif
    {NULL, NULL}  /* sentinel */
};

static int
PyExec_faulthandler(PyObject *module) {
    /* Add constants for unit tests */
#ifdef MS_WINDOWS
    /* RaiseException() codes (prefixed by an underscore) */
    if (PyModule_AddIntConstant(module, "_EXCEPTION_ACCESS_VIOLATION",
                                EXCEPTION_ACCESS_VIOLATION)) {
        return -1;
    }
    if (PyModule_AddIntConstant(module, "_EXCEPTION_INT_DIVIDE_BY_ZERO",
                                EXCEPTION_INT_DIVIDE_BY_ZERO)) {
        return -1;
    }
    if (PyModule_AddIntConstant(module, "_EXCEPTION_STACK_OVERFLOW",
                                EXCEPTION_STACK_OVERFLOW)) {
        return -1;
    }

    /* RaiseException() flags (prefixed by an underscore) */
    if (PyModule_AddIntConstant(module, "_EXCEPTION_NONCONTINUABLE",
                                EXCEPTION_NONCONTINUABLE)) {
        return -1;
    }
    if (PyModule_AddIntConstant(module, "_EXCEPTION_NONCONTINUABLE_EXCEPTION",
                                EXCEPTION_NONCONTINUABLE_EXCEPTION)) {
        return -1;
    }
#endif
    return 0;
}

static PyModuleDef_Slot faulthandler_slots[] = {
    {Py_mod_exec, PyExec_faulthandler},
    // XXX gh-103092: fix isolation.
    //{Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL}
};

static struct PyModuleDef module_def = {
    PyModuleDef_HEAD_INIT,
    .m_name = "faulthandler",
    .m_doc = module_doc,
    .m_methods = module_methods,
    .m_traverse = faulthandler_traverse,
    .m_slots = faulthandler_slots
};

PyMODINIT_FUNC
PyInit_faulthandler(void)
{
    return PyModuleDef_Init(&module_def);
}

static int
faulthandler_init_enable(void)
{
    PyObject *enable = _PyImport_GetModuleAttrString("faulthandler", "enable");
    if (enable == NULL) {
        return -1;
    }

    PyObject *res = PyObject_CallNoArgs(enable);
    Py_DECREF(enable);
    if (res == NULL) {
        return -1;
    }
    Py_DECREF(res);

    return 0;
}

PyStatus
_PyFaulthandler_Init(int enable)
{
#ifdef FAULTHANDLER_USE_ALT_STACK
    memset(&stack, 0, sizeof(stack));
    stack.ss_flags = 0;
    /* bpo-21131: allocate dedicated stack of SIGSTKSZ*2 bytes, instead of just
       SIGSTKSZ bytes. Calling the previous signal handler in faulthandler
       signal handler uses more than SIGSTKSZ bytes of stack memory on some
       platforms. */
    stack.ss_size = SIGSTKSZ * 2;
#ifdef AT_MINSIGSTKSZ
    /* bpo-46968: Query Linux for minimal stack size to ensure signal delivery
       for the hardware running CPython. This OS feature is available in
       Linux kernel version >= 5.14 */
    unsigned long at_minstack_size = getauxval(AT_MINSIGSTKSZ);
    if (at_minstack_size != 0) {
        stack.ss_size = SIGSTKSZ + at_minstack_size;
    }
#endif
#endif

    memset(&thread, 0, sizeof(thread));

    if (enable) {
        if (faulthandler_init_enable() < 0) {
            return _PyStatus_ERR("failed to enable faulthandler");
        }
    }
    return _PyStatus_OK();
}

void _PyFaulthandler_Fini(void)
{
    /* later */
    if (thread.cancel_event) {
        cancel_dump_traceback_later();
        PyThread_release_lock(thread.cancel_event);
        PyThread_free_lock(thread.cancel_event);
        thread.cancel_event = NULL;
    }
    if (thread.running) {
        PyThread_free_lock(thread.running);
        thread.running = NULL;
    }

#ifdef FAULTHANDLER_USER
    /* user */
    if (user_signals != NULL) {
        for (size_t signum=0; signum < Py_NSIG; signum++) {
            faulthandler_unregister(&user_signals[signum], signum);
        }
        PyMem_Free(user_signals);
        user_signals = NULL;
    }
#endif

    /* fatal */
    faulthandler_disable();

#ifdef FAULTHANDLER_USE_ALT_STACK
    if (stack.ss_sp != NULL) {
        /* Fetch the current alt stack */
        stack_t current_stack;
        memset(&current_stack, 0, sizeof(current_stack));
        if (sigaltstack(NULL, &current_stack) == 0) {
            if (current_stack.ss_sp == stack.ss_sp) {
                /* The current alt stack is the one that we installed.
                 It is safe to restore the old stack that we found when
                 we installed ours */
                sigaltstack(&old_stack, NULL);
            } else {
                /* Someone switched to a different alt stack and didn't
                   restore ours when they were done (if they're done).
                   There's not much we can do in this unlikely case */
            }
        }
        PyMem_Free(stack.ss_sp);
        stack.ss_sp = NULL;
    }
#endif
}


================================================
File: /Modules/fcntlmodule.c
================================================
/* fcntl module */

// Need limited C API version 3.13 for PyLong_AsInt()
#include "pyconfig.h"   // Py_GIL_DISABLED
#ifndef Py_GIL_DISABLED
#  define Py_LIMITED_API 0x030d0000
#endif

#include "Python.h"

#include <errno.h>                // EINTR
#include <fcntl.h>                // fcntl()
#include <string.h>               // memcpy()
#include <sys/ioctl.h>            // ioctl()
#ifdef HAVE_SYS_FILE_H
#  include <sys/file.h>           // flock()
#endif
#ifdef HAVE_LINUX_FS_H
#  include <linux/fs.h>
#endif
#ifdef HAVE_STROPTS_H
#  include <stropts.h>            // I_FLUSHBAND
#endif

/*[clinic input]
module fcntl
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=124b58387c158179]*/

#include "clinic/fcntlmodule.c.h"

/*[clinic input]
fcntl.fcntl

    fd: fildes
    cmd as code: int
    arg: object(c_default='NULL') = 0
    /

Perform the operation `cmd` on file descriptor fd.

The values used for `cmd` are operating system dependent, and are available
as constants in the fcntl module, using the same names as used in
the relevant C header files.  The argument arg is optional, and
defaults to 0; it may be an int or a string.  If arg is given as a string,
the return value of fcntl is a string of that length, containing the
resulting value put in the arg buffer by the operating system.  The length
of the arg string is not allowed to exceed 1024 bytes.  If the arg given
is an integer or if none is specified, the result value is an integer
corresponding to the return value of the fcntl call in the C code.
[clinic start generated code]*/

static PyObject *
fcntl_fcntl_impl(PyObject *module, int fd, int code, PyObject *arg)
/*[clinic end generated code: output=888fc93b51c295bd input=7955340198e5f334]*/
{
    unsigned int int_arg = 0;
    int ret;
    char *str;
    Py_ssize_t len;
    char buf[1024];
    int async_err = 0;

    if (PySys_Audit("fcntl.fcntl", "iiO", fd, code, arg ? arg : Py_None) < 0) {
        return NULL;
    }

    if (arg != NULL) {
        int parse_result;

        if (PyArg_Parse(arg, "s#", &str, &len)) {
            if ((size_t)len > sizeof buf) {
                PyErr_SetString(PyExc_ValueError,
                                "fcntl string arg too long");
                return NULL;
            }
            memcpy(buf, str, len);
            do {
                Py_BEGIN_ALLOW_THREADS
                ret = fcntl(fd, code, buf);
                Py_END_ALLOW_THREADS
            } while (ret == -1 && errno == EINTR && !(async_err = PyErr_CheckSignals()));
            if (ret < 0) {
                return !async_err ? PyErr_SetFromErrno(PyExc_OSError) : NULL;
            }
            return PyBytes_FromStringAndSize(buf, len);
        }

        PyErr_Clear();
        parse_result = PyArg_Parse(arg,
            "I;fcntl requires a file or file descriptor,"
            " an integer and optionally a third integer or a string",
            &int_arg);
        if (!parse_result) {
          return NULL;
        }
    }

    do {
        Py_BEGIN_ALLOW_THREADS
        ret = fcntl(fd, code, (int)int_arg);
        Py_END_ALLOW_THREADS
    } while (ret == -1 && errno == EINTR && !(async_err = PyErr_CheckSignals()));
    if (ret < 0) {
        return !async_err ? PyErr_SetFromErrno(PyExc_OSError) : NULL;
    }
    return PyLong_FromLong((long)ret);
}


/*[clinic input]
fcntl.ioctl

    fd: fildes
    request as code: unsigned_long(bitwise=True)
    arg as ob_arg: object(c_default='NULL') = 0
    mutate_flag as mutate_arg: bool = True
    /

Perform the operation `request` on file descriptor `fd`.

The values used for `request` are operating system dependent, and are available
as constants in the fcntl or termios library modules, using the same names as
used in the relevant C header files.

The argument `arg` is optional, and defaults to 0; it may be an int or a
buffer containing character data (most likely a string or an array).

If the argument is a mutable buffer (such as an array) and if the
mutate_flag argument (which is only allowed in this case) is true then the
buffer is (in effect) passed to the operating system and changes made by
the OS will be reflected in the contents of the buffer after the call has
returned.  The return value is the integer returned by the ioctl system
call.

If the argument is a mutable buffer and the mutable_flag argument is false,
the behavior is as if a string had been passed.

If the argument is an immutable buffer (most likely a string) then a copy
of the buffer is passed to the operating system and the return value is a
string of the same length containing whatever the operating system put in
the buffer.  The length of the arg buffer in this case is not allowed to
exceed 1024 bytes.

If the arg given is an integer or if none is specified, the result value is
an integer corresponding to the return value of the ioctl call in the C
code.
[clinic start generated code]*/

static PyObject *
fcntl_ioctl_impl(PyObject *module, int fd, unsigned long code,
                 PyObject *ob_arg, int mutate_arg)
/*[clinic end generated code: output=3d8eb6828666cea1 input=cee70f6a27311e58]*/
{
#define IOCTL_BUFSZ 1024
    /* We use the unsigned non-checked 'I' format for the 'code' parameter
       because the system expects it to be a 32bit bit field value
       regardless of it being passed as an int or unsigned long on
       various platforms.  See the termios.TIOCSWINSZ constant across
       platforms for an example of this.

       If any of the 64bit platforms ever decide to use more than 32bits
       in their unsigned long ioctl codes this will break and need
       special casing based on the platform being built on.
     */
    int arg = 0;
    int ret;
    Py_buffer pstr;
    char *str;
    Py_ssize_t len;
    char buf[IOCTL_BUFSZ+1];  /* argument plus NUL byte */

    if (PySys_Audit("fcntl.ioctl", "ikO", fd, code,
                    ob_arg ? ob_arg : Py_None) < 0) {
        return NULL;
    }

    if (ob_arg != NULL) {
        if (PyArg_Parse(ob_arg, "w*:ioctl", &pstr)) {
            char *arg;
            str = pstr.buf;
            len = pstr.len;

            if (mutate_arg) {
                if (len <= IOCTL_BUFSZ) {
                    memcpy(buf, str, len);
                    buf[len] = '\0';
                    arg = buf;
                }
                else {
                    arg = str;
                }
            }
            else {
                if (len > IOCTL_BUFSZ) {
                    PyBuffer_Release(&pstr);
                    PyErr_SetString(PyExc_ValueError,
                        "ioctl string arg too long");
                    return NULL;
                }
                else {
                    memcpy(buf, str, len);
                    buf[len] = '\0';
                    arg = buf;
                }
            }
            if (buf == arg) {
                Py_BEGIN_ALLOW_THREADS /* think array.resize() */
                ret = ioctl(fd, code, arg);
                Py_END_ALLOW_THREADS
            }
            else {
                ret = ioctl(fd, code, arg);
            }
            if (mutate_arg && (len <= IOCTL_BUFSZ)) {
                memcpy(str, buf, len);
            }
            if (ret < 0) {
                PyErr_SetFromErrno(PyExc_OSError);
                PyBuffer_Release(&pstr);
                return NULL;
            }
            PyBuffer_Release(&pstr);
            if (mutate_arg) {
                return PyLong_FromLong(ret);
            }
            else {
                return PyBytes_FromStringAndSize(buf, len);
            }
        }

        PyErr_Clear();
        if (PyArg_Parse(ob_arg, "s*:ioctl", &pstr)) {
            str = pstr.buf;
            len = pstr.len;
            if (len > IOCTL_BUFSZ) {
                PyBuffer_Release(&pstr);
                PyErr_SetString(PyExc_ValueError,
                                "ioctl string arg too long");
                return NULL;
            }
            memcpy(buf, str, len);
            buf[len] = '\0';
            Py_BEGIN_ALLOW_THREADS
            ret = ioctl(fd, code, buf);
            Py_END_ALLOW_THREADS
            if (ret < 0) {
                PyErr_SetFromErrno(PyExc_OSError);
                PyBuffer_Release(&pstr);
                return NULL;
            }
            PyBuffer_Release(&pstr);
            return PyBytes_FromStringAndSize(buf, len);
        }

        PyErr_Clear();
        if (!PyArg_Parse(ob_arg,
             "i;ioctl requires a file or file descriptor,"
             " an integer and optionally an integer or buffer argument",
             &arg)) {
          return NULL;
        }
        // Fall-through to outside the 'if' statement.
    }
    Py_BEGIN_ALLOW_THREADS
    ret = ioctl(fd, code, arg);
    Py_END_ALLOW_THREADS
    if (ret < 0) {
        PyErr_SetFromErrno(PyExc_OSError);
        return NULL;
    }
    return PyLong_FromLong((long)ret);
#undef IOCTL_BUFSZ
}

/*[clinic input]
fcntl.flock

    fd: fildes
    operation as code: int
    /

Perform the lock operation `operation` on file descriptor `fd`.

See the Unix manual page for flock(2) for details (On some systems, this
function is emulated using fcntl()).
[clinic start generated code]*/

static PyObject *
fcntl_flock_impl(PyObject *module, int fd, int code)
/*[clinic end generated code: output=84059e2b37d2fc64 input=0bfc00f795953452]*/
{
    int ret;
    int async_err = 0;

    if (PySys_Audit("fcntl.flock", "ii", fd, code) < 0) {
        return NULL;
    }

#ifdef HAVE_FLOCK
    do {
        Py_BEGIN_ALLOW_THREADS
        ret = flock(fd, code);
        Py_END_ALLOW_THREADS
    } while (ret == -1 && errno == EINTR && !(async_err = PyErr_CheckSignals()));
#else

#ifndef LOCK_SH
#define LOCK_SH         1       /* shared lock */
#define LOCK_EX         2       /* exclusive lock */
#define LOCK_NB         4       /* don't block when locking */
#define LOCK_UN         8       /* unlock */
#endif
    {
        struct flock l;
        if (code == LOCK_UN)
            l.l_type = F_UNLCK;
        else if (code & LOCK_SH)
            l.l_type = F_RDLCK;
        else if (code & LOCK_EX)
            l.l_type = F_WRLCK;
        else {
            PyErr_SetString(PyExc_ValueError,
                            "unrecognized flock argument");
            return NULL;
        }
        l.l_whence = l.l_start = l.l_len = 0;
        do {
            Py_BEGIN_ALLOW_THREADS
            ret = fcntl(fd, (code & LOCK_NB) ? F_SETLK : F_SETLKW, &l);
            Py_END_ALLOW_THREADS
        } while (ret == -1 && errno == EINTR && !(async_err = PyErr_CheckSignals()));
    }
#endif /* HAVE_FLOCK */
    if (ret < 0) {
        return !async_err ? PyErr_SetFromErrno(PyExc_OSError) : NULL;
    }
    Py_RETURN_NONE;
}


/*[clinic input]
fcntl.lockf

    fd: fildes
    cmd as code: int
    len as lenobj: object(c_default='NULL') = 0
    start as startobj: object(c_default='NULL') = 0
    whence: int = 0
    /

A wrapper around the fcntl() locking calls.

`fd` is the file descriptor of the file to lock or unlock, and operation is one
of the following values:

    LOCK_UN - unlock
    LOCK_SH - acquire a shared lock
    LOCK_EX - acquire an exclusive lock

When operation is LOCK_SH or LOCK_EX, it can also be bitwise ORed with
LOCK_NB to avoid blocking on lock acquisition.  If LOCK_NB is used and the
lock cannot be acquired, an OSError will be raised and the exception will
have an errno attribute set to EACCES or EAGAIN (depending on the operating
system -- for portability, check for either value).

`len` is the number of bytes to lock, with the default meaning to lock to
EOF.  `start` is the byte offset, relative to `whence`, to that the lock
starts.  `whence` is as with fileobj.seek(), specifically:

    0 - relative to the start of the file (SEEK_SET)
    1 - relative to the current buffer position (SEEK_CUR)
    2 - relative to the end of the file (SEEK_END)
[clinic start generated code]*/

static PyObject *
fcntl_lockf_impl(PyObject *module, int fd, int code, PyObject *lenobj,
                 PyObject *startobj, int whence)
/*[clinic end generated code: output=4985e7a172e7461a input=5480479fc63a04b8]*/
{
    int ret;
    int async_err = 0;

    if (PySys_Audit("fcntl.lockf", "iiOOi", fd, code, lenobj ? lenobj : Py_None,
                    startobj ? startobj : Py_None, whence) < 0) {
        return NULL;
    }

#ifndef LOCK_SH
#define LOCK_SH         1       /* shared lock */
#define LOCK_EX         2       /* exclusive lock */
#define LOCK_NB         4       /* don't block when locking */
#define LOCK_UN         8       /* unlock */
#endif  /* LOCK_SH */
    {
        struct flock l;
        if (code == LOCK_UN)
            l.l_type = F_UNLCK;
        else if (code & LOCK_SH)
            l.l_type = F_RDLCK;
        else if (code & LOCK_EX)
            l.l_type = F_WRLCK;
        else {
            PyErr_SetString(PyExc_ValueError,
                            "unrecognized lockf argument");
            return NULL;
        }
        l.l_start = l.l_len = 0;
        if (startobj != NULL) {
#if !defined(HAVE_LARGEFILE_SUPPORT)
            l.l_start = PyLong_AsLong(startobj);
#else
            l.l_start = PyLong_Check(startobj) ?
                            PyLong_AsLongLong(startobj) :
                    PyLong_AsLong(startobj);
#endif
            if (PyErr_Occurred())
                return NULL;
        }
        if (lenobj != NULL) {
#if !defined(HAVE_LARGEFILE_SUPPORT)
            l.l_len = PyLong_AsLong(lenobj);
#else
            l.l_len = PyLong_Check(lenobj) ?
                            PyLong_AsLongLong(lenobj) :
                    PyLong_AsLong(lenobj);
#endif
            if (PyErr_Occurred())
                return NULL;
        }
        l.l_whence = whence;
        do {
            Py_BEGIN_ALLOW_THREADS
            ret = fcntl(fd, (code & LOCK_NB) ? F_SETLK : F_SETLKW, &l);
            Py_END_ALLOW_THREADS
        } while (ret == -1 && errno == EINTR && !(async_err = PyErr_CheckSignals()));
    }
    if (ret < 0) {
        return !async_err ? PyErr_SetFromErrno(PyExc_OSError) : NULL;
    }
    Py_RETURN_NONE;
}

/* List of functions */

static PyMethodDef fcntl_methods[] = {
    FCNTL_FCNTL_METHODDEF
    FCNTL_IOCTL_METHODDEF
    FCNTL_FLOCK_METHODDEF
    FCNTL_LOCKF_METHODDEF
    {NULL, NULL}  /* sentinel */
};


PyDoc_STRVAR(module_doc,
"This module performs file control and I/O control on file\n\
descriptors.  It is an interface to the fcntl() and ioctl() Unix\n\
routines.  File descriptors can be obtained with the fileno() method of\n\
a file or socket object.");

/* Module initialisation */


static int
all_ins(PyObject* m)
{
    if (PyModule_AddIntMacro(m, LOCK_SH)) return -1;
    if (PyModule_AddIntMacro(m, LOCK_EX)) return -1;
    if (PyModule_AddIntMacro(m, LOCK_NB)) return -1;
    if (PyModule_AddIntMacro(m, LOCK_UN)) return -1;
/* GNU extensions, as of glibc 2.2.4 */
#ifdef LOCK_MAND
    if (PyModule_AddIntMacro(m, LOCK_MAND)) return -1;
#endif
#ifdef LOCK_READ
    if (PyModule_AddIntMacro(m, LOCK_READ)) return -1;
#endif
#ifdef LOCK_WRITE
    if (PyModule_AddIntMacro(m, LOCK_WRITE)) return -1;
#endif
#ifdef LOCK_RW
    if (PyModule_AddIntMacro(m, LOCK_RW)) return -1;
#endif

#ifdef F_DUPFD
    if (PyModule_AddIntMacro(m, F_DUPFD)) return -1;
#endif
#ifdef F_DUPFD_CLOEXEC
    if (PyModule_AddIntMacro(m, F_DUPFD_CLOEXEC)) return -1;
#endif
#ifdef F_GETFD
    if (PyModule_AddIntMacro(m, F_GETFD)) return -1;
#endif
#ifdef F_SETFD
    if (PyModule_AddIntMacro(m, F_SETFD)) return -1;
#endif
#ifdef F_GETFL
    if (PyModule_AddIntMacro(m, F_GETFL)) return -1;
#endif
#ifdef F_SETFL
    if (PyModule_AddIntMacro(m, F_SETFL)) return -1;
#endif
#ifdef F_GETLK
    if (PyModule_AddIntMacro(m, F_GETLK)) return -1;
#endif
#ifdef F_SETLK
    if (PyModule_AddIntMacro(m, F_SETLK)) return -1;
#endif
#ifdef F_SETLKW
    if (PyModule_AddIntMacro(m, F_SETLKW)) return -1;
#endif
#ifdef F_OFD_GETLK
    if (PyModule_AddIntMacro(m, F_OFD_GETLK)) return -1;
#endif
#ifdef F_OFD_SETLK
    if (PyModule_AddIntMacro(m, F_OFD_SETLK)) return -1;
#endif
#ifdef F_OFD_SETLKW
    if (PyModule_AddIntMacro(m, F_OFD_SETLKW)) return -1;
#endif
#ifdef F_GETOWN
    if (PyModule_AddIntMacro(m, F_GETOWN)) return -1;
#endif
#ifdef F_SETOWN
    if (PyModule_AddIntMacro(m, F_SETOWN)) return -1;
#endif
#ifdef F_GETPATH
    if (PyModule_AddIntMacro(m, F_GETPATH)) return -1;
#endif
#ifdef F_GETSIG
    if (PyModule_AddIntMacro(m, F_GETSIG)) return -1;
#endif
#ifdef F_SETSIG
    if (PyModule_AddIntMacro(m, F_SETSIG)) return -1;
#endif
#ifdef F_RDLCK
    if (PyModule_AddIntMacro(m, F_RDLCK)) return -1;
#endif
#ifdef F_WRLCK
    if (PyModule_AddIntMacro(m, F_WRLCK)) return -1;
#endif
#ifdef F_UNLCK
    if (PyModule_AddIntMacro(m, F_UNLCK)) return -1;
#endif
/* LFS constants */
#ifdef F_GETLK64
    if (PyModule_AddIntMacro(m, F_GETLK64)) return -1;
#endif
#ifdef F_SETLK64
    if (PyModule_AddIntMacro(m, F_SETLK64)) return -1;
#endif
#ifdef F_SETLKW64
    if (PyModule_AddIntMacro(m, F_SETLKW64)) return -1;
#endif
/* GNU extensions, as of glibc 2.2.4. */
#ifdef FASYNC
    if (PyModule_AddIntMacro(m, FASYNC)) return -1;
#endif
#ifdef F_SETLEASE
    if (PyModule_AddIntMacro(m, F_SETLEASE)) return -1;
#endif
#ifdef F_GETLEASE
    if (PyModule_AddIntMacro(m, F_GETLEASE)) return -1;
#endif
#ifdef F_NOTIFY
    if (PyModule_AddIntMacro(m, F_NOTIFY)) return -1;
#endif
/* Old BSD flock(). */
#ifdef F_EXLCK
    if (PyModule_AddIntMacro(m, F_EXLCK)) return -1;
#endif
#ifdef F_SHLCK
    if (PyModule_AddIntMacro(m, F_SHLCK)) return -1;
#endif

/* Linux specifics */
#ifdef F_SETPIPE_SZ
    if (PyModule_AddIntMacro(m, F_SETPIPE_SZ)) return -1;
#endif
#ifdef F_GETPIPE_SZ
    if (PyModule_AddIntMacro(m, F_GETPIPE_SZ)) return -1;
#endif

/* On Android, FICLONE is blocked by SELinux. */
#ifndef __ANDROID__
#ifdef FICLONE
    if (PyModule_AddIntMacro(m, FICLONE)) return -1;
#endif
#ifdef FICLONERANGE
    if (PyModule_AddIntMacro(m, FICLONERANGE)) return -1;
#endif
#endif

#ifdef F_GETOWN_EX
    // since Linux 2.6.32
    if (PyModule_AddIntMacro(m, F_GETOWN_EX)) return -1;
    if (PyModule_AddIntMacro(m, F_SETOWN_EX)) return -1;
    if (PyModule_AddIntMacro(m, F_OWNER_TID)) return -1;
    if (PyModule_AddIntMacro(m, F_OWNER_PID)) return -1;
    if (PyModule_AddIntMacro(m, F_OWNER_PGRP)) return -1;
#endif
#ifdef F_GET_RW_HINT
    // since Linux 4.13
    if (PyModule_AddIntMacro(m, F_GET_RW_HINT)) return -1;
    if (PyModule_AddIntMacro(m, F_SET_RW_HINT)) return -1;
    if (PyModule_AddIntMacro(m, F_GET_FILE_RW_HINT)) return -1;
    if (PyModule_AddIntMacro(m, F_SET_FILE_RW_HINT)) return -1;
#ifndef RWH_WRITE_LIFE_NOT_SET  // typo in Linux < 5.5
# define RWH_WRITE_LIFE_NOT_SET RWF_WRITE_LIFE_NOT_SET
#endif
    if (PyModule_AddIntMacro(m, RWH_WRITE_LIFE_NOT_SET)) return -1;
    if (PyModule_AddIntMacro(m, RWH_WRITE_LIFE_NONE)) return -1;
    if (PyModule_AddIntMacro(m, RWH_WRITE_LIFE_SHORT)) return -1;
    if (PyModule_AddIntMacro(m, RWH_WRITE_LIFE_MEDIUM)) return -1;
    if (PyModule_AddIntMacro(m, RWH_WRITE_LIFE_LONG)) return -1;
    if (PyModule_AddIntMacro(m, RWH_WRITE_LIFE_EXTREME)) return -1;
#endif

/* OS X specifics */
#ifdef F_FULLFSYNC
    if (PyModule_AddIntMacro(m, F_FULLFSYNC)) return -1;
#endif
#ifdef F_NOCACHE
    if (PyModule_AddIntMacro(m, F_NOCACHE)) return -1;
#endif

/* FreeBSD specifics */
#ifdef F_DUP2FD
    if (PyModule_AddIntMacro(m, F_DUP2FD)) return -1;
#endif
#ifdef F_DUP2FD_CLOEXEC
    if (PyModule_AddIntMacro(m, F_DUP2FD_CLOEXEC)) return -1;
#endif
#ifdef F_READAHEAD
    if (PyModule_AddIntMacro(m, F_READAHEAD)) return -1;
#endif
#ifdef F_RDAHEAD
    if (PyModule_AddIntMacro(m, F_RDAHEAD)) return -1;
#endif
#ifdef F_ISUNIONSTACK
    if (PyModule_AddIntMacro(m, F_ISUNIONSTACK)) return -1;
#endif
#ifdef F_KINFO
    if (PyModule_AddIntMacro(m, F_KINFO)) return -1;
#endif

/* NetBSD specifics */
#ifdef F_CLOSEM
    if (PyModule_AddIntMacro(m, F_CLOSEM)) return -1;
#endif
#ifdef F_MAXFD
    if (PyModule_AddIntMacro(m, F_MAXFD)) return -1;
#endif
#ifdef F_GETNOSIGPIPE
    if (PyModule_AddIntMacro(m, F_GETNOSIGPIPE)) return -1;
#endif
#ifdef F_SETNOSIGPIPE
    if (PyModule_AddIntMacro(m, F_SETNOSIGPIPE)) return -1;
#endif

/* For F_{GET|SET}FL */
#ifdef FD_CLOEXEC
    if (PyModule_AddIntMacro(m, FD_CLOEXEC)) return -1;
#endif

/* For F_NOTIFY */
#ifdef DN_ACCESS
    if (PyModule_AddIntMacro(m, DN_ACCESS)) return -1;
#endif
#ifdef DN_MODIFY
    if (PyModule_AddIntMacro(m, DN_MODIFY)) return -1;
#endif
#ifdef DN_CREATE
    if (PyModule_AddIntMacro(m, DN_CREATE)) return -1;
#endif
#ifdef DN_DELETE
    if (PyModule_AddIntMacro(m, DN_DELETE)) return -1;
#endif
#ifdef DN_RENAME
    if (PyModule_AddIntMacro(m, DN_RENAME)) return -1;
#endif
#ifdef DN_ATTRIB
    if (PyModule_AddIntMacro(m, DN_ATTRIB)) return -1;
#endif
#ifdef DN_MULTISHOT
    if (PyModule_AddIntMacro(m, DN_MULTISHOT)) return -1;
#endif

#ifdef HAVE_STROPTS_H
    /* Unix 98 guarantees that these are in stropts.h. */
    if (PyModule_AddIntMacro(m, I_PUSH)) return -1;
    if (PyModule_AddIntMacro(m, I_POP)) return -1;
    if (PyModule_AddIntMacro(m, I_LOOK)) return -1;
    if (PyModule_AddIntMacro(m, I_FLUSH)) return -1;
    if (PyModule_AddIntMacro(m, I_FLUSHBAND)) return -1;
    if (PyModule_AddIntMacro(m, I_SETSIG)) return -1;
    if (PyModule_AddIntMacro(m, I_GETSIG)) return -1;
    if (PyModule_AddIntMacro(m, I_FIND)) return -1;
    if (PyModule_AddIntMacro(m, I_PEEK)) return -1;
    if (PyModule_AddIntMacro(m, I_SRDOPT)) return -1;
    if (PyModule_AddIntMacro(m, I_GRDOPT)) return -1;
    if (PyModule_AddIntMacro(m, I_NREAD)) return -1;
    if (PyModule_AddIntMacro(m, I_FDINSERT)) return -1;
    if (PyModule_AddIntMacro(m, I_STR)) return -1;
    if (PyModule_AddIntMacro(m, I_SWROPT)) return -1;
#ifdef I_GWROPT
    /* despite the comment above, old-ish glibcs miss a couple... */
    if (PyModule_AddIntMacro(m, I_GWROPT)) return -1;
#endif
    if (PyModule_AddIntMacro(m, I_SENDFD)) return -1;
    if (PyModule_AddIntMacro(m, I_RECVFD)) return -1;
    if (PyModule_AddIntMacro(m, I_LIST)) return -1;
    if (PyModule_AddIntMacro(m, I_ATMARK)) return -1;
    if (PyModule_AddIntMacro(m, I_CKBAND)) return -1;
    if (PyModule_AddIntMacro(m, I_GETBAND)) return -1;
    if (PyModule_AddIntMacro(m, I_CANPUT)) return -1;
    if (PyModule_AddIntMacro(m, I_SETCLTIME)) return -1;
#ifdef I_GETCLTIME
    if (PyModule_AddIntMacro(m, I_GETCLTIME)) return -1;
#endif
    if (PyModule_AddIntMacro(m, I_LINK)) return -1;
    if (PyModule_AddIntMacro(m, I_UNLINK)) return -1;
    if (PyModule_AddIntMacro(m, I_PLINK)) return -1;
    if (PyModule_AddIntMacro(m, I_PUNLINK)) return -1;
#endif
#ifdef F_ADD_SEALS
    /* Linux: file sealing for memfd_create() */
    if (PyModule_AddIntMacro(m, F_ADD_SEALS)) return -1;
    if (PyModule_AddIntMacro(m, F_GET_SEALS)) return -1;
    if (PyModule_AddIntMacro(m, F_SEAL_SEAL)) return -1;
    if (PyModule_AddIntMacro(m, F_SEAL_SHRINK)) return -1;
    if (PyModule_AddIntMacro(m, F_SEAL_GROW)) return -1;
    if (PyModule_AddIntMacro(m, F_SEAL_WRITE)) return -1;
#ifdef F_SEAL_FUTURE_WRITE
    if (PyModule_AddIntMacro(m, F_SEAL_FUTURE_WRITE)) return -1;
#endif
#endif
    return 0;
}

static int
fcntl_exec(PyObject *module)
{
    if (all_ins(module) < 0) {
        return -1;
    }
    return 0;
}

static PyModuleDef_Slot fcntl_slots[] = {
    {Py_mod_exec, fcntl_exec},
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL}
};

static struct PyModuleDef fcntlmodule = {
    PyModuleDef_HEAD_INIT,
    .m_name = "fcntl",
    .m_doc = module_doc,
    .m_size = 0,
    .m_methods = fcntl_methods,
    .m_slots = fcntl_slots,
};

PyMODINIT_FUNC
PyInit_fcntl(void)
{
    return PyModuleDef_Init(&fcntlmodule);
}


================================================
File: /Modules/gc_weakref.txt
================================================
Intro
=====

The basic rule for dealing with weakref callbacks (and __del__ methods too,
for that matter) during cyclic gc:

    Once gc has computed the set of unreachable objects, no Python-level
    code can be allowed to access an unreachable object.

If that can happen, then the Python code can resurrect unreachable objects
too, and gc can't detect that without starting over.  Since gc eventually
runs tp_clear on all unreachable objects, if an unreachable object is
resurrected then tp_clear will eventually be called on it (or may already
have been called before resurrection).  At best (and this has been an
historically common bug), tp_clear empties an instance's __dict__, and
"impossible" AttributeErrors result.  At worst, tp_clear leaves behind an
insane object at the C level, and segfaults result (historically, most
often by setting a class's mro pointer to NULL, after which attribute
lookups performed by the class can segfault).

OTOH, it's OK to run Python-level code that can't access unreachable
objects, and sometimes that's necessary.  The chief example is the callback
attached to a reachable weakref W to an unreachable object O.  Since O is
going away, and W is still alive, the callback must be invoked.  Because W
is still alive, everything reachable from its callback is also reachable,
so it's also safe to invoke the callback (although that's trickier than it
sounds, since other reachable weakrefs to other unreachable objects may
still exist, and be accessible to the callback -- there are lots of painful
details like this covered in the rest of this file).

Python 2.4/2.3.5
================

The "Before 2.3.3" section below turned out to be wrong in some ways, but
I'm leaving it as-is because it's more right than wrong, and serves as a
wonderful example of how painful analysis can miss not only the forest for
the trees, but also miss the trees for the aphids sucking the trees
dry <wink>.

The primary thing it missed is that when a weakref to a piece of cyclic
trash (CT) exists, then any call to any Python code whatsoever can end up
materializing a strong reference to that weakref's CT referent, and so
possibly resurrect an insane object (one for which cyclic gc has called-- or
will call before it's done --tp_clear()).  It's not even necessarily that a
weakref callback or __del__ method does something nasty on purpose:  as
soon as we execute Python code, threads other than the gc thread can run
too, and they can do ordinary things with weakrefs that end up resurrecting
CT while gc is running.

    https://bugs.python.org/issue1055820

shows how innocent it can be, and also how nasty.  Variants of the three
focused test cases attached to that bug report are now part of Python's
standard Lib/test/test_gc.py.

Jim Fulton gave the best nutshell summary of the new (in 2.4 and 2.3.5)
approach:

    Clearing cyclic trash can call Python code.  If there are weakrefs to
    any of the cyclic trash, then those weakrefs can be used to resurrect
    the objects.  Therefore, *before* clearing cyclic trash, we need to
    remove any weakrefs.  If any of the weakrefs being removed have
    callbacks, then we need to save the callbacks and call them *after* all
    of the weakrefs have been cleared.

Alas, doing just that much doesn't work, because it overlooks what turned
out to be the much subtler problems that were fixed earlier, and described
below.  We do clear all weakrefs to CT now before breaking cycles, but not
all callbacks encountered can be run later.  That's explained in horrid
detail below.

Older text follows, with a some later comments in [] brackets:

Before 2.3.3
============

Before 2.3.3, Python's cyclic gc didn't pay any attention to weakrefs.
Segfaults in Zope3 resulted.

weakrefs in Python are designed to, at worst, let *other* objects learn
that a given object has died, via a callback function.  The weakly
referenced object itself is not passed to the callback, and the presumption
is that the weakly referenced object is unreachable trash at the time the
callback is invoked.

That's usually true, but not always.  Suppose a weakly referenced object
becomes part of a clump of cyclic trash.  When enough cycles are broken by
cyclic gc that the object is reclaimed, the callback is invoked.  If it's
possible for the callback to get at objects in the cycle(s), then it may be
possible for those objects to access (via strong references in the cycle)
the weakly referenced object being torn down, or other objects in the cycle
that have already suffered a tp_clear() call.  There's no guarantee that an
object is in a sane state after tp_clear().  Bad things (including
segfaults) can happen right then, during the callback's execution, or can
happen at any later time if the callback manages to resurrect an insane
object.

[That missed that, in addition, a weakref to CT can exist outside CT, and
 any callback into Python can use such a non-CT weakref to resurrect its CT
 referent.  The same bad kinds of things can happen then.]

Note that if it's possible for the callback to get at objects in the trash
cycles, it must also be the case that the callback itself is part of the
trash cycles.  Else the callback would have acted as an external root to
the current collection, and nothing reachable from it would be in cyclic
trash either.

[Except that a non-CT callback can also use a non-CT weakref to get at
 CT objects.]

More, if the callback itself is in cyclic trash, then the weakref to which
the callback is attached must also be trash, and for the same kind of
reason:  if the weakref acted as an external root, then the callback could
not have been cyclic trash.

So a problem here requires that a weakref, that weakref's callback, and the
weakly referenced object, all be in cyclic trash at the same time.  This
isn't easy to stumble into by accident while Python is running, and, indeed,
it took quite a while to dream up failing test cases.  Zope3 saw segfaults
during shutdown, during the second call of gc in Py_Finalize, after most
modules had been torn down.  That creates many trash cycles (esp. those
involving classes), making the problem much more likely.  Once you
know what's required to provoke the problem, though, it's easy to create
tests that segfault before shutdown.

In 2.3.3, before breaking cycles, we first clear all the weakrefs with
callbacks in cyclic trash.  Since the weakrefs *are* trash, and there's no
defined-- or even predictable --order in which tp_clear() gets called on
cyclic trash, it's defensible to first clear weakrefs with callbacks.  It's
a feature of Python's weakrefs too that when a weakref goes away, the
callback (if any) associated with it is thrown away too, unexecuted.

[In 2.4/2.3.5, we first clear all weakrefs to CT objects, whether or not
 those weakrefs are themselves CT, and whether or not they have callbacks.
 The callbacks (if any) on non-CT weakrefs (if any) are invoked later,
 after all weakrefs-to-CT have been cleared.  The callbacks (if any) on CT
 weakrefs (if any) are never invoked, for the excruciating reasons
 explained here.]

Just that much is almost enough to prevent problems, by throwing away
*almost* all the weakref callbacks that could get triggered by gc.  The
problem remaining is that clearing a weakref with a callback decrefs the
callback object, and the callback object may *itself* be weakly referenced,
via another weakref with another callback.  So the process of clearing
weakrefs can trigger callbacks attached to other weakrefs, and those
latter weakrefs may or may not be part of cyclic trash.

So, to prevent any Python code from running while gc is invoking tp_clear()
on all the objects in cyclic trash,

[That was always wrong:  we can't stop Python code from running when gc
 is breaking cycles.  If an object with a __del__ method is not itself in
 a cycle, but is reachable only from CT, then breaking cycles will, as a
 matter of course, drop the refcount on that object to 0, and its __del__
 will run right then.  What we can and must stop is running any Python
 code that could access CT.]
                                     it's not quite enough just to invoke
tp_clear() on weakrefs with callbacks first.  Instead the weakref module
grew a new private function (_PyWeakref_ClearRef) that does only part of
tp_clear():  it removes the weakref from the weakly-referenced object's list
of weakrefs, but does not decref the callback object.  So calling
_PyWeakref_ClearRef(wr) ensures that wr's callback object will never
trigger, and (unlike weakref's tp_clear()) also prevents any callback
associated *with* wr's callback object from triggering.

[Although we may trigger such callbacks later, as explained below.]

Then we can call tp_clear on all the cyclic objects and never trigger
Python code.

[As above, not so:  it means never trigger Python code that can access CT.]

After we do that, the callback objects still need to be decref'ed.  Callbacks
(if any) *on* the callback objects that were also part of cyclic trash won't
get invoked, because we cleared all trash weakrefs with callbacks at the
start.  Callbacks on the callback objects that were not part of cyclic trash
acted as external roots to everything reachable from them, so nothing
reachable from them was part of cyclic trash, so gc didn't do any damage to
objects reachable from them, and it's safe to call them at the end of gc.

[That's so.  In addition, now we also invoke (if any) the callbacks on
 non-CT weakrefs to CT objects, during the same pass that decrefs the
 callback objects.]

An alternative would have been to treat objects with callbacks like objects
with __del__ methods, refusing to collect them, appending them to gc.garbage
instead.  That would have been much easier.  Jim Fulton gave a strong
argument against that (on Python-Dev):

    There's a big difference between __del__ and weakref callbacks.
    The __del__ method is "internal" to a design.  When you design a
    class with a del method, you know you have to avoid including the
    class in cycles.

    Now, suppose you have a design that makes has no __del__ methods but
    that does use cyclic data structures.  You reason about the design,
    run tests, and convince yourself you don't have a leak.

    Now, suppose some external code creates a weakref to one of your
    objects.  All of a sudden, you start leaking.  You can look at your
    code all you want and you won't find a reason for the leak.

IOW, a class designer can out-think __del__ problems, but has no control
over who creates weakrefs to his classes or class instances.  The class
user has little chance either of predicting when the weakrefs he creates
may end up in cycles.

Callbacks on weakref callbacks are executed in an arbitrary order, and
that's not good (a primary reason not to collect cycles with objects with
__del__ methods is to avoid running finalizers in an arbitrary order).
However, a weakref callback on a weakref callback has got to be rare.
It's possible to do such a thing, so gc has to be robust against it, but
I doubt anyone has done it outside the test case I wrote for it.

[The callbacks (if any) on non-CT weakrefs to CT objects are also executed
 in an arbitrary order now.  But they were before too, depending on the
 vagaries of when tp_clear() happened to break enough cycles to trigger
 them.  People simply shouldn't try to use __del__ or weakref callbacks to
 do fancy stuff.]


================================================
File: /Modules/gcmodule.c
================================================
/*
 * Python interface to the garbage collector.
 *
 * See Python/gc.c for the implementation of the garbage collector.
 */

#include "Python.h"
#include "pycore_gc.h"
#include "pycore_object.h"      // _PyObject_IS_GC()
#include "pycore_pystate.h"     // _PyInterpreterState_GET()
#include "pycore_tuple.h"       // _PyTuple_FromArray()

typedef struct _gc_runtime_state GCState;

static GCState *
get_gc_state(void)
{
    PyInterpreterState *interp = _PyInterpreterState_GET();
    return &interp->gc;
}

/*[clinic input]
module gc
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=b5c9690ecc842d79]*/
#include "clinic/gcmodule.c.h"

/*[clinic input]
gc.enable

Enable automatic garbage collection.
[clinic start generated code]*/

static PyObject *
gc_enable_impl(PyObject *module)
/*[clinic end generated code: output=45a427e9dce9155c input=81ac4940ca579707]*/
{
    PyGC_Enable();
    Py_RETURN_NONE;
}

/*[clinic input]
gc.disable

Disable automatic garbage collection.
[clinic start generated code]*/

static PyObject *
gc_disable_impl(PyObject *module)
/*[clinic end generated code: output=97d1030f7aa9d279 input=8c2e5a14e800d83b]*/
{
    PyGC_Disable();
    Py_RETURN_NONE;
}

/*[clinic input]
gc.isenabled -> bool

Returns true if automatic garbage collection is enabled.
[clinic start generated code]*/

static int
gc_isenabled_impl(PyObject *module)
/*[clinic end generated code: output=1874298331c49130 input=30005e0422373b31]*/
{
    return PyGC_IsEnabled();
}

/*[clinic input]
gc.collect -> Py_ssize_t

    generation: int(c_default="NUM_GENERATIONS - 1") = 2

Run the garbage collector.

With no arguments, run a full collection.  The optional argument
may be an integer specifying which generation to collect.  A ValueError
is raised if the generation number is invalid.

The number of unreachable objects is returned.
[clinic start generated code]*/

static Py_ssize_t
gc_collect_impl(PyObject *module, int generation)
/*[clinic end generated code: output=b697e633043233c7 input=40720128b682d879]*/
{
    PyThreadState *tstate = _PyThreadState_GET();

    if (generation < 0 || generation >= NUM_GENERATIONS) {
        _PyErr_SetString(tstate, PyExc_ValueError, "invalid generation");
        return -1;
    }

    return _PyGC_Collect(tstate, generation, _Py_GC_REASON_MANUAL);
}

/*[clinic input]
gc.set_debug

    flags: int
        An integer that can have the following bits turned on:
          DEBUG_STATS - Print statistics during collection.
          DEBUG_COLLECTABLE - Print collectable objects found.
          DEBUG_UNCOLLECTABLE - Print unreachable but uncollectable objects
            found.
          DEBUG_SAVEALL - Save objects to gc.garbage rather than freeing them.
          DEBUG_LEAK - Debug leaking programs (everything but STATS).
    /

Set the garbage collection debugging flags.

Debugging information is written to sys.stderr.
[clinic start generated code]*/

static PyObject *
gc_set_debug_impl(PyObject *module, int flags)
/*[clinic end generated code: output=7c8366575486b228 input=5e5ce15e84fbed15]*/
{
    GCState *gcstate = get_gc_state();
    gcstate->debug = flags;
    Py_RETURN_NONE;
}

/*[clinic input]
gc.get_debug -> int

Get the garbage collection debugging flags.
[clinic start generated code]*/

static int
gc_get_debug_impl(PyObject *module)
/*[clinic end generated code: output=91242f3506cd1e50 input=91a101e1c3b98366]*/
{
    GCState *gcstate = get_gc_state();
    return gcstate->debug;
}

/*[clinic input]
gc.set_threshold

    threshold0: int
    [
    threshold1: int
    [
    threshold2: int
    ]
    ]
    /

Set the collection thresholds (the collection frequency).

Setting 'threshold0' to zero disables collection.
[clinic start generated code]*/

static PyObject *
gc_set_threshold_impl(PyObject *module, int threshold0, int group_right_1,
                      int threshold1, int group_right_2, int threshold2)
/*[clinic end generated code: output=2e3c7c7dd59060f3 input=0d9612db50984eec]*/
{
    GCState *gcstate = get_gc_state();

    gcstate->young.threshold = threshold0;
    if (group_right_1) {
        gcstate->old[0].threshold = threshold1;
    }
    if (group_right_2) {
        gcstate->old[1].threshold = threshold2;
    }
    Py_RETURN_NONE;
}

/*[clinic input]
gc.get_threshold

Return the current collection thresholds.
[clinic start generated code]*/

static PyObject *
gc_get_threshold_impl(PyObject *module)
/*[clinic end generated code: output=7902bc9f41ecbbd8 input=286d79918034d6e6]*/
{
    GCState *gcstate = get_gc_state();
    return Py_BuildValue("(iii)",
                         gcstate->young.threshold,
                         gcstate->old[0].threshold,
                         0);
}

/*[clinic input]
gc.get_count

Return a three-tuple of the current collection counts.
[clinic start generated code]*/

static PyObject *
gc_get_count_impl(PyObject *module)
/*[clinic end generated code: output=354012e67b16398f input=a392794a08251751]*/
{
    GCState *gcstate = get_gc_state();

#ifdef Py_GIL_DISABLED
    _PyThreadStateImpl *tstate = (_PyThreadStateImpl *)_PyThreadState_GET();
    struct _gc_thread_state *gc = &tstate->gc;

    // Flush the local allocation count to the global count
    _Py_atomic_add_int(&gcstate->young.count, (int)gc->alloc_count);
    gc->alloc_count = 0;
#endif

    return Py_BuildValue("(iii)",
                         gcstate->young.count,
                         gcstate->old[gcstate->visited_space].count,
                         gcstate->old[gcstate->visited_space^1].count);
}

/*[clinic input]
gc.get_referrers

    *objs: tuple

Return the list of objects that directly refer to any of 'objs'.
[clinic start generated code]*/

static PyObject *
gc_get_referrers_impl(PyObject *module, PyObject *objs)
/*[clinic end generated code: output=929d6dff26f609b9 input=9102be7ebee69ee3]*/
{
    if (PySys_Audit("gc.get_referrers", "(O)", objs) < 0) {
        return NULL;
    }

    PyInterpreterState *interp = _PyInterpreterState_GET();
    return _PyGC_GetReferrers(interp, objs);
}

/* Append obj to list; return true if error (out of memory), false if OK. */
static int
referentsvisit(PyObject *obj, void *arg)
{
    PyObject *list = arg;
    return PyList_Append(list, obj) < 0;
}

static int
append_referrents(PyObject *result, PyObject *args)
{
    for (Py_ssize_t i = 0; i < PyTuple_GET_SIZE(args); i++) {
        PyObject *obj = PyTuple_GET_ITEM(args, i);
        if (!_PyObject_IS_GC(obj)) {
            continue;
        }

        traverseproc traverse = Py_TYPE(obj)->tp_traverse;
        if (!traverse) {
            continue;
        }
        if (traverse(obj, referentsvisit, result)) {
            return -1;
        }
    }
    return 0;
}

/*[clinic input]
gc.get_referents

    *objs: tuple

Return the list of objects that are directly referred to by 'objs'.
[clinic start generated code]*/

static PyObject *
gc_get_referents_impl(PyObject *module, PyObject *objs)
/*[clinic end generated code: output=6dfde40cd1588e1d input=55c078a6d0248fe0]*/
{
    if (PySys_Audit("gc.get_referents", "(O)", objs) < 0) {
        return NULL;
    }
    PyInterpreterState *interp = _PyInterpreterState_GET();
    PyObject *result = PyList_New(0);

    if (result == NULL) {
        return NULL;
    }

    // NOTE: stop the world is a no-op in default build
    _PyEval_StopTheWorld(interp);
    int err = append_referrents(result, objs);
    _PyEval_StartTheWorld(interp);

    if (err < 0) {
        Py_CLEAR(result);
    }

    return result;
}

/*[clinic input]
gc.get_objects
    generation: Py_ssize_t(accept={int, NoneType}, c_default="-1") = None
        Generation to extract the objects from.

Return a list of objects tracked by the collector (excluding the list returned).

If generation is not None, return only the objects tracked by the collector
that are in that generation.
[clinic start generated code]*/

static PyObject *
gc_get_objects_impl(PyObject *module, Py_ssize_t generation)
/*[clinic end generated code: output=48b35fea4ba6cb0e input=ef7da9df9806754c]*/
{
    if (PySys_Audit("gc.get_objects", "n", generation) < 0) {
        return NULL;
    }

    if (generation >= NUM_GENERATIONS) {
        return PyErr_Format(PyExc_ValueError,
                            "generation parameter must be less than the number of "
                            "available generations (%i)",
                            NUM_GENERATIONS);
    }

    if (generation < -1) {
        PyErr_SetString(PyExc_ValueError,
                        "generation parameter cannot be negative");
        return NULL;
    }

    PyInterpreterState *interp = _PyInterpreterState_GET();
    return _PyGC_GetObjects(interp, (int)generation);
}

/*[clinic input]
gc.get_stats

Return a list of dictionaries containing per-generation statistics.
[clinic start generated code]*/

static PyObject *
gc_get_stats_impl(PyObject *module)
/*[clinic end generated code: output=a8ab1d8a5d26f3ab input=1ef4ed9d17b1a470]*/
{
    int i;
    struct gc_generation_stats stats[NUM_GENERATIONS], *st;

    /* To get consistent values despite allocations while constructing
       the result list, we use a snapshot of the running stats. */
    GCState *gcstate = get_gc_state();
    for (i = 0; i < NUM_GENERATIONS; i++) {
        stats[i] = gcstate->generation_stats[i];
    }

    PyObject *result = PyList_New(0);
    if (result == NULL)
        return NULL;

    for (i = 0; i < NUM_GENERATIONS; i++) {
        PyObject *dict;
        st = &stats[i];
        dict = Py_BuildValue("{snsnsn}",
                             "collections", st->collections,
                             "collected", st->collected,
                             "uncollectable", st->uncollectable
                            );
        if (dict == NULL)
            goto error;
        if (PyList_Append(result, dict)) {
            Py_DECREF(dict);
            goto error;
        }
        Py_DECREF(dict);
    }
    return result;

error:
    Py_XDECREF(result);
    return NULL;
}


/*[clinic input]
gc.is_tracked -> bool

    obj: object
    /

Returns true if the object is tracked by the garbage collector.

Simple atomic objects will return false.
[clinic start generated code]*/

static int
gc_is_tracked_impl(PyObject *module, PyObject *obj)
/*[clinic end generated code: output=91c8d086b7f47a33 input=423b98ec680c3126]*/
{
    return PyObject_GC_IsTracked(obj);
}

/*[clinic input]
gc.is_finalized -> bool

    obj: object
    /

Returns true if the object has been already finalized by the GC.
[clinic start generated code]*/

static int
gc_is_finalized_impl(PyObject *module, PyObject *obj)
/*[clinic end generated code: output=401ff5d6fc660429 input=ca4d111c8f8c4e3a]*/
{
    return PyObject_GC_IsFinalized(obj);
}

/*[clinic input]
gc.freeze

Freeze all current tracked objects and ignore them for future collections.

This can be used before a POSIX fork() call to make the gc copy-on-write friendly.
Note: collection before a POSIX fork() call may free pages for future allocation
which can cause copy-on-write.
[clinic start generated code]*/

static PyObject *
gc_freeze_impl(PyObject *module)
/*[clinic end generated code: output=502159d9cdc4c139 input=b602b16ac5febbe5]*/
{
    PyInterpreterState *interp = _PyInterpreterState_GET();
    _PyGC_Freeze(interp);
    Py_RETURN_NONE;
}

/*[clinic input]
gc.unfreeze

Unfreeze all objects in the permanent generation.

Put all objects in the permanent generation back into oldest generation.
[clinic start generated code]*/

static PyObject *
gc_unfreeze_impl(PyObject *module)
/*[clinic end generated code: output=1c15f2043b25e169 input=2dd52b170f4cef6c]*/
{
    PyInterpreterState *interp = _PyInterpreterState_GET();
    _PyGC_Unfreeze(interp);
    Py_RETURN_NONE;
}

/*[clinic input]
gc.get_freeze_count -> Py_ssize_t

Return the number of objects in the permanent generation.
[clinic start generated code]*/

static Py_ssize_t
gc_get_freeze_count_impl(PyObject *module)
/*[clinic end generated code: output=61cbd9f43aa032e1 input=45ffbc65cfe2a6ed]*/
{
    PyInterpreterState *interp = _PyInterpreterState_GET();
    return _PyGC_GetFreezeCount(interp);
}


PyDoc_STRVAR(gc__doc__,
"This module provides access to the garbage collector for reference cycles.\n"
"\n"
"enable() -- Enable automatic garbage collection.\n"
"disable() -- Disable automatic garbage collection.\n"
"isenabled() -- Returns true if automatic collection is enabled.\n"
"collect() -- Do a full collection right now.\n"
"get_count() -- Return the current collection counts.\n"
"get_stats() -- Return list of dictionaries containing per-generation stats.\n"
"set_debug() -- Set debugging flags.\n"
"get_debug() -- Get debugging flags.\n"
"set_threshold() -- Set the collection thresholds.\n"
"get_threshold() -- Return the current the collection thresholds.\n"
"get_objects() -- Return a list of all objects tracked by the collector.\n"
"is_tracked() -- Returns true if a given object is tracked.\n"
"is_finalized() -- Returns true if a given object has been already finalized.\n"
"get_referrers() -- Return the list of objects that refer to an object.\n"
"get_referents() -- Return the list of objects that an object refers to.\n"
"freeze() -- Freeze all tracked objects and ignore them for future collections.\n"
"unfreeze() -- Unfreeze all objects in the permanent generation.\n"
"get_freeze_count() -- Return the number of objects in the permanent generation.\n");

static PyMethodDef GcMethods[] = {
    GC_ENABLE_METHODDEF
    GC_DISABLE_METHODDEF
    GC_ISENABLED_METHODDEF
    GC_SET_DEBUG_METHODDEF
    GC_GET_DEBUG_METHODDEF
    GC_GET_COUNT_METHODDEF
    GC_SET_THRESHOLD_METHODDEF
    GC_GET_THRESHOLD_METHODDEF
    GC_COLLECT_METHODDEF
    GC_GET_OBJECTS_METHODDEF
    GC_GET_STATS_METHODDEF
    GC_IS_TRACKED_METHODDEF
    GC_IS_FINALIZED_METHODDEF
    GC_GET_REFERRERS_METHODDEF
    GC_GET_REFERENTS_METHODDEF
    GC_FREEZE_METHODDEF
    GC_UNFREEZE_METHODDEF
    GC_GET_FREEZE_COUNT_METHODDEF
    {NULL,      NULL}           /* Sentinel */
};

static int
gcmodule_exec(PyObject *module)
{
    GCState *gcstate = get_gc_state();

    /* garbage and callbacks are initialized by _PyGC_Init() early in
     * interpreter lifecycle. */
    assert(gcstate->garbage != NULL);
    if (PyModule_AddObjectRef(module, "garbage", gcstate->garbage) < 0) {
        return -1;
    }
    assert(gcstate->callbacks != NULL);
    if (PyModule_AddObjectRef(module, "callbacks", gcstate->callbacks) < 0) {
        return -1;
    }

#define ADD_INT(NAME) if (PyModule_AddIntConstant(module, #NAME, _PyGC_ ## NAME) < 0) { return -1; }
    ADD_INT(DEBUG_STATS);
    ADD_INT(DEBUG_COLLECTABLE);
    ADD_INT(DEBUG_UNCOLLECTABLE);
    ADD_INT(DEBUG_SAVEALL);
    ADD_INT(DEBUG_LEAK);
#undef ADD_INT
    return 0;
}

static PyModuleDef_Slot gcmodule_slots[] = {
    {Py_mod_exec, gcmodule_exec},
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL}
};

static struct PyModuleDef gcmodule = {
    PyModuleDef_HEAD_INIT,
    .m_name = "gc",
    .m_doc = gc__doc__,
    .m_size = 0,  // per interpreter state, see: get_gc_state()
    .m_methods = GcMethods,
    .m_slots = gcmodule_slots
};

PyMODINIT_FUNC
PyInit_gc(void)
{
    return PyModuleDef_Init(&gcmodule);
}


================================================
File: /Modules/getaddrinfo.c
================================================
/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * "#ifdef FAITH" part is local hack for supporting IPv4-v6 translator.
 *
 * Issues to be discussed:
 * - Thread safe-ness must be checked.
 * - Return values.  There are nonstandard return values defined and used
 *   in the source code.  This is because RFC2133 is silent about which error
 *   code must be returned for which situation.
 * - PF_UNSPEC case would be handled in getipnodebyname() with the AI_ALL flag.
 */

#if 0
#include <sys/types.h>
#include <sys/param.h>
#include <sys/sysctl.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netdb.h>
#include <resolv.h>
#include <string.h>
#include <stdlib.h>
#include <stddef.h>
#include <unistd.h>

#include "addrinfo.h"
#endif

#if defined(__KAME__) && defined(ENABLE_IPV6)
# define FAITH
#endif

#ifdef HAVE_NETDB_H
#define HAVE_GETADDRINFO 1

#define SUCCESS 0
#define GAI_ANY 0
#define YES 1
#define NO  0

#ifdef FAITH
static int translate = NO;
static struct in6_addr faith_prefix = IN6ADDR_GAI_ANY_INIT;
#endif

static const char in_addrany[] = { 0, 0, 0, 0 };
static const char in6_addrany[] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
static const char in_loopback[] = { 127, 0, 0, 1 };
static const char in6_loopback[] = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1
};

struct sockinet {
    u_char      si_len;
    u_char      si_family;
    u_short     si_port;
};

static struct gai_afd {
    int a_af;
    int a_addrlen;
    int a_socklen;
    int a_off;
    const char *a_addrany;
    const char *a_loopback;
} gai_afdl [] = {
#ifdef ENABLE_IPV6
#define N_INET6 0
    {PF_INET6, sizeof(struct in6_addr),
     sizeof(struct sockaddr_in6),
     offsetof(struct sockaddr_in6, sin6_addr),
     in6_addrany, in6_loopback},
#define N_INET  1
#else
#define N_INET  0
#endif
    {PF_INET, sizeof(struct in_addr),
     sizeof(struct sockaddr_in),
     offsetof(struct sockaddr_in, sin_addr),
     in_addrany, in_loopback},
    {0, 0, 0, 0, NULL, NULL},
};

#ifdef ENABLE_IPV6
#define PTON_MAX        16
#else
#define PTON_MAX        4
#endif

#ifndef IN_MULTICAST
#define IN_MULTICAST(i)     (((i) & 0xf0000000U) == 0xe0000000U)
#endif

#ifndef IN_EXPERIMENTAL
#define IN_EXPERIMENTAL(i)  (((i) & 0xe0000000U) == 0xe0000000U)
#endif

#ifndef IN_LOOPBACKNET
#define IN_LOOPBACKNET      127
#endif

static int get_name(const char *, struct gai_afd *,
                          struct addrinfo **, char *, struct addrinfo *,
                          int);
static int get_addr(const char *, int, struct addrinfo **,
                        struct addrinfo *, int);
static int str_isnumber(const char *);

static const char * const ai_errlist[] = {
    "success.",
    "address family for hostname not supported.",       /* EAI_ADDRFAMILY */
    "temporary failure in name resolution.",            /* EAI_AGAIN      */
    "invalid value for ai_flags.",                      /* EAI_BADFLAGS   */
    "non-recoverable failure in name resolution.",      /* EAI_FAIL       */
    "ai_family not supported.",                         /* EAI_FAMILY     */
    "memory allocation failure.",                       /* EAI_MEMORY     */
    "no address associated with hostname.",             /* EAI_NODATA     */
    "hostname nor servname provided, or not known.",/* EAI_NONAME     */
    "servname not supported for ai_socktype.",          /* EAI_SERVICE    */
    "ai_socktype not supported.",                       /* EAI_SOCKTYPE   */
    "system error returned in errno.",                  /* EAI_SYSTEM     */
    "invalid value for hints.",                         /* EAI_BADHINTS   */
    "resolved protocol is unknown.",                    /* EAI_PROTOCOL   */
    "unknown error.",                                   /* EAI_MAX        */
};

#define GET_CANONNAME(ai, str) \
if (pai->ai_flags & AI_CANONNAME) {\
    if (((ai)->ai_canonname = (char *)malloc(strlen(str) + 1)) != NULL) {\
        strcpy((ai)->ai_canonname, (str));\
    } else {\
        error = EAI_MEMORY;\
        goto free;\
    }\
}

#ifdef HAVE_SOCKADDR_SA_LEN
#define GET_AI(ai, gai_afd, addr, port) {\
    char *p;\
    if (((ai) = (struct addrinfo *)malloc(sizeof(struct addrinfo) +\
                                          ((gai_afd)->a_socklen)))\
        == NULL) goto free;\
    memcpy(ai, pai, sizeof(struct addrinfo));\
    (ai)->ai_addr = (struct sockaddr *)((ai) + 1);\
    memset((ai)->ai_addr, 0, (gai_afd)->a_socklen);\
    (ai)->ai_addr->sa_len = (ai)->ai_addrlen = (gai_afd)->a_socklen;\
    (ai)->ai_addr->sa_family = (ai)->ai_family = (gai_afd)->a_af;\
    ((struct sockinet *)(ai)->ai_addr)->si_port = port;\
    p = (char *)((ai)->ai_addr);\
    memcpy(p + (gai_afd)->a_off, (addr), (gai_afd)->a_addrlen);\
}
#else
#define GET_AI(ai, gai_afd, addr, port) {\
    char *p;\
    if (((ai) = (struct addrinfo *)malloc(sizeof(struct addrinfo) +\
                                          ((gai_afd)->a_socklen)))\
        == NULL) goto free;\
    memcpy(ai, pai, sizeof(struct addrinfo));\
    (ai)->ai_addr = (struct sockaddr *)((ai) + 1);\
    memset((ai)->ai_addr, 0, (gai_afd)->a_socklen);\
    (ai)->ai_addrlen = (gai_afd)->a_socklen;\
    (ai)->ai_addr->sa_family = (ai)->ai_family = (gai_afd)->a_af;\
    ((struct sockinet *)(ai)->ai_addr)->si_port = port;\
    p = (char *)((ai)->ai_addr);\
    memcpy(p + (gai_afd)->a_off, (addr), (gai_afd)->a_addrlen);\
}
#endif

#define ERR(err) { error = (err); goto bad; }

const char *
gai_strerror(int ecode)
{
    if (ecode < 0 || ecode > EAI_MAX)
        ecode = EAI_MAX;
    return ai_errlist[ecode];
}

void
freeaddrinfo(struct addrinfo *ai)
{
    struct addrinfo *next;

    do {
        next = ai->ai_next;
        if (ai->ai_canonname)
            free(ai->ai_canonname);
        /* no need to free(ai->ai_addr) */
        free(ai);
    } while ((ai = next) != NULL);
}

static int
str_isnumber(const char *p)
{
    unsigned char *q = (unsigned char *)p;
    while (*q) {
        if (!Py_ISDIGIT(*q)) {
            return NO;
        }
        q++;
    }
    return YES;
}

int
getaddrinfo(const char*hostname, const char*servname,
            const struct addrinfo *hints, struct addrinfo **res)
{
    struct addrinfo sentinel;
    struct addrinfo *top = NULL;
    struct addrinfo *cur;
    int i, error = 0;
    char pton[PTON_MAX];
    struct addrinfo ai;
    struct addrinfo *pai;
    u_short port;

#ifdef FAITH
    static int firsttime = 1;

    if (firsttime) {
        /* translator hack */
        {
            const char *q = getenv("GAI");
            if (q && inet_pton(AF_INET6, q, &faith_prefix) == 1)
                translate = YES;
        }
        firsttime = 0;
    }
#endif

    /* initialize file static vars */
    sentinel.ai_next = NULL;
    cur = &sentinel;
    pai = &ai;
    pai->ai_flags = 0;
    pai->ai_family = PF_UNSPEC;
    pai->ai_socktype = GAI_ANY;
    pai->ai_protocol = GAI_ANY;
    pai->ai_addrlen = 0;
    pai->ai_canonname = NULL;
    pai->ai_addr = NULL;
    pai->ai_next = NULL;
    port = GAI_ANY;

    if (hostname == NULL && servname == NULL)
        return EAI_NONAME;
    if (hints) {
        /* error check for hints */
        if (hints->ai_addrlen || hints->ai_canonname ||
            hints->ai_addr || hints->ai_next)
            ERR(EAI_BADHINTS); /* xxx */
        if (hints->ai_flags & ~AI_MASK)
            ERR(EAI_BADFLAGS);
        switch (hints->ai_family) {
        case PF_UNSPEC:
        case PF_INET:
#ifdef ENABLE_IPV6
        case PF_INET6:
#endif
            break;
        default:
            ERR(EAI_FAMILY);
        }
        memcpy(pai, hints, sizeof(*pai));
        switch (pai->ai_socktype) {
        case GAI_ANY:
            switch (pai->ai_protocol) {
            case GAI_ANY:
                break;
            case IPPROTO_UDP:
                pai->ai_socktype = SOCK_DGRAM;
                break;
            case IPPROTO_TCP:
                pai->ai_socktype = SOCK_STREAM;
                break;
            default:
                pai->ai_socktype = SOCK_RAW;
                break;
            }
            break;
        case SOCK_RAW:
            break;
        case SOCK_DGRAM:
            if (pai->ai_protocol != IPPROTO_UDP &&
                pai->ai_protocol != GAI_ANY)
                ERR(EAI_BADHINTS);                      /*xxx*/
            pai->ai_protocol = IPPROTO_UDP;
            break;
        case SOCK_STREAM:
            if (pai->ai_protocol != IPPROTO_TCP &&
                pai->ai_protocol != GAI_ANY)
                ERR(EAI_BADHINTS);                      /*xxx*/
            pai->ai_protocol = IPPROTO_TCP;
            break;
        default:
            ERR(EAI_SOCKTYPE);
            /* unreachable */
        }
    }

    /*
     * service port
     */
    if (servname) {
        if (str_isnumber(servname)) {
            if (pai->ai_socktype == GAI_ANY) {
                /* caller accept *GAI_ANY* socktype */
                pai->ai_socktype = SOCK_DGRAM;
                pai->ai_protocol = IPPROTO_UDP;
            }
            long maybe_port = strtol(servname, NULL, 10);
            if (maybe_port < 0 || maybe_port > 0xffff) {
                ERR(EAI_SERVICE);
            }
            port = htons((u_short)maybe_port);
        } else {
            struct servent *sp;
            const char *proto;

            proto = NULL;
            switch (pai->ai_socktype) {
            case GAI_ANY:
                proto = NULL;
                break;
            case SOCK_DGRAM:
                proto = "udp";
                break;
            case SOCK_STREAM:
                proto = "tcp";
                break;
            default:
                fprintf(stderr, "panic!\n");
                break;
            }
            if ((sp = getservbyname(servname, proto)) == NULL)
                ERR(EAI_SERVICE);
            port = sp->s_port;
            if (pai->ai_socktype == GAI_ANY) {
                if (strcmp(sp->s_proto, "udp") == 0) {
                    pai->ai_socktype = SOCK_DGRAM;
                    pai->ai_protocol = IPPROTO_UDP;
                } else if (strcmp(sp->s_proto, "tcp") == 0) {
                    pai->ai_socktype = SOCK_STREAM;
                    pai->ai_protocol = IPPROTO_TCP;
                } else
                    ERR(EAI_PROTOCOL);                          /*xxx*/
            }
        }
    }

    /*
     * hostname == NULL.
     * passive socket -> anyaddr (0.0.0.0 or ::)
     * non-passive socket -> localhost (127.0.0.1 or ::1)
     */
    if (hostname == NULL) {
        struct gai_afd *gai_afd;

        for (gai_afd = &gai_afdl[0]; gai_afd->a_af; gai_afd++) {
            if (!(pai->ai_family == PF_UNSPEC
               || pai->ai_family == gai_afd->a_af)) {
                continue;
            }

            if (pai->ai_flags & AI_PASSIVE) {
                GET_AI(cur->ai_next, gai_afd, gai_afd->a_addrany, port);
                /* xxx meaningless?
                 * GET_CANONNAME(cur->ai_next, "anyaddr");
                 */
            } else {
                GET_AI(cur->ai_next, gai_afd, gai_afd->a_loopback,
                    port);
                /* xxx meaningless?
                 * GET_CANONNAME(cur->ai_next, "localhost");
                 */
            }
            cur = cur->ai_next;
        }
        top = sentinel.ai_next;
        if (top)
            goto good;
        else
            ERR(EAI_FAMILY);
    }

    /* hostname as numeric name */
    for (i = 0; gai_afdl[i].a_af; i++) {
        if (inet_pton(gai_afdl[i].a_af, hostname, pton)) {
            u_long v4a;
#ifdef ENABLE_IPV6
            u_char pfx;
#endif

            switch (gai_afdl[i].a_af) {
            case AF_INET:
                v4a = ((struct in_addr *)pton)->s_addr;
                v4a = ntohl(v4a);
                if (IN_MULTICAST(v4a) || IN_EXPERIMENTAL(v4a))
                    pai->ai_flags &= ~AI_CANONNAME;
                v4a >>= IN_CLASSA_NSHIFT;
                if (v4a == 0 || v4a == IN_LOOPBACKNET)
                    pai->ai_flags &= ~AI_CANONNAME;
                break;
#ifdef ENABLE_IPV6
            case AF_INET6:
                pfx = ((struct in6_addr *)pton)->s6_addr[0];
                if (pfx == 0 || pfx == 0xfe || pfx == 0xff)
                    pai->ai_flags &= ~AI_CANONNAME;
                break;
#endif
            }

            if (pai->ai_family == gai_afdl[i].a_af ||
                pai->ai_family == PF_UNSPEC) {
                if (! (pai->ai_flags & AI_CANONNAME)) {
                    GET_AI(top, &gai_afdl[i], pton, port);
                    goto good;
                }
                /*
                 * if AI_CANONNAME and if reverse lookup
                 * fail, return ai anyway to pacify
                 * calling application.
                 *
                 * XXX getaddrinfo() is a name->address
                 * translation function, and it looks strange
                 * that we do addr->name translation here.
                 */
                get_name(pton, &gai_afdl[i], &top, pton, pai, port);
                goto good;
            } else
                ERR(EAI_FAMILY);                        /*xxx*/
        }
    }

    if (pai->ai_flags & AI_NUMERICHOST)
        ERR(EAI_NONAME);

    /* hostname as alphabetical name */
    error = get_addr(hostname, pai->ai_family, &top, pai, port);
    if (error == 0) {
        if (top) {
 good:
            *res = top;
            return SUCCESS;
        } else
            error = EAI_FAIL;
    }
 free:
    if (top)
        freeaddrinfo(top);
 bad:
    *res = NULL;
    return error;
}

static int
get_name(addr, gai_afd, res, numaddr, pai, port0)
    const char *addr;
    struct gai_afd *gai_afd;
    struct addrinfo **res;
    char *numaddr;
    struct addrinfo *pai;
    int port0;
{
    u_short port = port0 & 0xffff;
    struct hostent *hp;
    struct addrinfo *cur;
    int error = 0;
#ifdef ENABLE_IPV6
    int h_error;
#endif

#ifdef ENABLE_IPV6
    hp = getipnodebyaddr(addr, gai_afd->a_addrlen, gai_afd->a_af, &h_error);
#else
    hp = gethostbyaddr(addr, gai_afd->a_addrlen, AF_INET);
#endif
    if (hp && hp->h_name && hp->h_name[0] && hp->h_addr_list[0]) {
        GET_AI(cur, gai_afd, hp->h_addr_list[0], port);
        GET_CANONNAME(cur, hp->h_name);
    } else
        GET_AI(cur, gai_afd, numaddr, port);

#ifdef ENABLE_IPV6
    if (hp)
        freehostent(hp);
#endif
    *res = cur;
    return SUCCESS;
 free:
    if (cur)
        freeaddrinfo(cur);
#ifdef ENABLE_IPV6
    if (hp)
        freehostent(hp);
#endif
 /* bad: */
    *res = NULL;
    return error;
}

static int
get_addr(hostname, af, res, pai, port0)
    const char *hostname;
    int af;
    struct addrinfo **res;
    struct addrinfo *pai;
    int port0;
{
    u_short port = port0 & 0xffff;
    struct addrinfo sentinel;
    struct hostent *hp;
    struct addrinfo *top, *cur;
    struct gai_afd *gai_afd;
    int i, error = 0, h_error;
    char *ap;

    top = NULL;
    sentinel.ai_next = NULL;
    cur = &sentinel;
#ifdef ENABLE_IPV6
    if (af == AF_UNSPEC) {
        hp = getipnodebyname(hostname, AF_INET6,
                        AI_ADDRCONFIG|AI_ALL|AI_V4MAPPED, &h_error);
    } else
        hp = getipnodebyname(hostname, af, AI_ADDRCONFIG, &h_error);
#else
    hp = gethostbyname(hostname);
    h_error = h_errno;
#endif
    if (hp == NULL) {
        switch (h_error) {
        case HOST_NOT_FOUND:
        case NO_DATA:
            error = EAI_NODATA;
            break;
        case TRY_AGAIN:
            error = EAI_AGAIN;
            break;
        case NO_RECOVERY:
        default:
            error = EAI_FAIL;
            break;
        }
        goto free;
    }

    if ((hp->h_name == NULL) || (hp->h_name[0] == 0) ||
        (hp->h_addr_list[0] == NULL)) {
        error = EAI_FAIL;
        goto free;
    }

    for (i = 0; (ap = hp->h_addr_list[i]) != NULL; i++) {
        switch (af) {
#ifdef ENABLE_IPV6
        case AF_INET6:
            gai_afd = &gai_afdl[N_INET6];
            break;
#endif
#ifndef ENABLE_IPV6
        default:                /* AF_UNSPEC */
#endif
        case AF_INET:
            gai_afd = &gai_afdl[N_INET];
            break;
#ifdef ENABLE_IPV6
        default:                /* AF_UNSPEC */
            if (IN6_IS_ADDR_V4MAPPED((struct in6_addr *)ap)) {
                ap += sizeof(struct in6_addr) -
                    sizeof(struct in_addr);
                gai_afd = &gai_afdl[N_INET];
            } else
                gai_afd = &gai_afdl[N_INET6];
            break;
#endif
        }
#ifdef FAITH
        if (translate && gai_afd->a_af == AF_INET) {
            struct in6_addr *in6;

            GET_AI(cur->ai_next, &gai_afdl[N_INET6], ap, port);
            in6 = &((struct sockaddr_in6 *)cur->ai_next->ai_addr)->sin6_addr;
            memcpy(&in6->s6_addr32[0], &faith_prefix,
                sizeof(struct in6_addr) - sizeof(struct in_addr));
            memcpy(&in6->s6_addr32[3], ap, sizeof(struct in_addr));
        } else
#endif /* FAITH */
        GET_AI(cur->ai_next, gai_afd, ap, port);
        if (cur == &sentinel) {
            top = cur->ai_next;
            GET_CANONNAME(top, hp->h_name);
        }
        cur = cur->ai_next;
    }
#ifdef ENABLE_IPV6
    freehostent(hp);
#endif
    *res = top;
    return SUCCESS;
 free:
    if (top)
        freeaddrinfo(top);
#ifdef ENABLE_IPV6
    if (hp)
        freehostent(hp);
#endif
/* bad: */
    *res = NULL;
    return error;
}

#endif // HAVE_NETDB_H


================================================
File: /Modules/getbuildinfo.c
================================================
#ifndef Py_BUILD_CORE_BUILTIN
#  define Py_BUILD_CORE_MODULE 1
#endif

#include "Python.h"
#include "pycore_pylifecycle.h"   // _Py_gitidentifier()

#ifndef DONT_HAVE_STDIO_H
#include <stdio.h>
#endif

#ifndef DATE
#ifdef __DATE__
#define DATE __DATE__
#else
#define DATE "xx/xx/xx"
#endif
#endif

#ifndef TIME
#ifdef __TIME__
#define TIME __TIME__
#else
#define TIME "xx:xx:xx"
#endif
#endif

/* XXX Only unix build process has been tested */
#ifndef GITVERSION
#define GITVERSION ""
#endif
#ifndef GITTAG
#define GITTAG ""
#endif
#ifndef GITBRANCH
#define GITBRANCH ""
#endif

static int initialized = 0;
static char buildinfo[50 + sizeof(GITVERSION) +
                      ((sizeof(GITTAG) > sizeof(GITBRANCH)) ?
                       sizeof(GITTAG) : sizeof(GITBRANCH))];

const char *
Py_GetBuildInfo(void)
{
    if (initialized) {
        return buildinfo;
    }
    initialized = 1;
    const char *revision = _Py_gitversion();
    const char *sep = *revision ? ":" : "";
    const char *gitid = _Py_gitidentifier();
    if (!(*gitid)) {
        gitid = "main";
    }
    PyOS_snprintf(buildinfo, sizeof(buildinfo),
                  "%s%s%s, %.20s, %.9s", gitid, sep, revision,
                  DATE, TIME);
    return buildinfo;
}

const char *
_Py_gitversion(void)
{
    return GITVERSION;
}

const char *
_Py_gitidentifier(void)
{
    const char *gittag, *gitid;
    gittag = GITTAG;
    if ((*gittag) && strcmp(gittag, "undefined") != 0)
        gitid = gittag;
    else
        gitid = GITBRANCH;
    return gitid;
}


================================================
File: /Modules/getnameinfo.c
================================================
/*
 * Copyright (C) 1995, 1996, 1997, and 1998 WIDE Project.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE PROJECT AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE PROJECT OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Issues to be discussed:
 * - Thread safe-ness must be checked
 * - Return values.  There seems to be no standard for return value (RFC2133)
 *   but INRIA implementation returns EAI_xxx defined for getaddrinfo().
 */

#if 0
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <arpa/nameser.h>
#include <netdb.h>
#include <resolv.h>
#include <string.h>
#include <stddef.h>

#include "addrinfo.h"
#endif

#ifdef HAVE_NETDB_H
#define HAVE_GETNAMEINFO 1

#define SUCCESS 0
#define YES 1
#define NO  0

static struct gni_afd {
    int a_af;
    int a_addrlen;
    int a_socklen;
    int a_off;
} gni_afdl [] = {
#ifdef ENABLE_IPV6
    {PF_INET6, sizeof(struct in6_addr), sizeof(struct sockaddr_in6),
        offsetof(struct sockaddr_in6, sin6_addr)},
#endif
    {PF_INET, sizeof(struct in_addr), sizeof(struct sockaddr_in),
        offsetof(struct sockaddr_in, sin_addr)},
    {0, 0, 0},
};

struct gni_sockinet {
    u_char      si_len;
    u_char      si_family;
    u_short     si_port;
};

#define ENI_NOSOCKET    0
#define ENI_NOSERVNAME  1
#define ENI_NOHOSTNAME  2
#define ENI_MEMORY      3
#define ENI_SYSTEM      4
#define ENI_FAMILY      5
#define ENI_SALEN       6

/* forward declaration to make gcc happy */
int getnameinfo(const struct sockaddr *, size_t, char *, size_t,
                          char *, size_t, int);

int
getnameinfo(sa, salen, host, hostlen, serv, servlen, flags)
    const struct sockaddr *sa;
    size_t salen;
    char *host;
    size_t hostlen;
    char *serv;
    size_t servlen;
    int flags;
{
    struct gni_afd *gni_afd;
    struct servent *sp;
    struct hostent *hp;
    u_short port;
    int family, len, i;
    char *addr, *p;
    u_long v4a;
#ifdef ENABLE_IPV6
    u_char pfx;
    int h_error;
#endif
    char numserv[512];
    char numaddr[512];

    if (sa == NULL)
        return ENI_NOSOCKET;

#ifdef HAVE_SOCKADDR_SA_LEN
    len = sa->sa_len;
    if (len != salen) return ENI_SALEN;
#else
    len = salen;
#endif

    family = sa->sa_family;
    for (i = 0; gni_afdl[i].a_af; i++)
        if (gni_afdl[i].a_af == family) {
            gni_afd = &gni_afdl[i];
            goto found;
        }
    return ENI_FAMILY;

 found:
    if (len != gni_afd->a_socklen) return ENI_SALEN;

    port = ((struct gni_sockinet *)sa)->si_port; /* network byte order */
    addr = (char *)sa + gni_afd->a_off;

    if (serv == NULL || servlen == 0) {
        /* what we should do? */
    } else if (flags & NI_NUMERICSERV) {
        sprintf(numserv, "%d", ntohs(port));
        if (strlen(numserv) > servlen)
            return ENI_MEMORY;
        strcpy(serv, numserv);
    } else {
        sp = getservbyport(port, (flags & NI_DGRAM) ? "udp" : "tcp");
        if (sp) {
            if (strlen(sp->s_name) > servlen)
                return ENI_MEMORY;
            strcpy(serv, sp->s_name);
        } else
            return ENI_NOSERVNAME;
    }

    switch (sa->sa_family) {
    case AF_INET:
        v4a = ((struct sockaddr_in *)sa)->sin_addr.s_addr;
        if (IN_MULTICAST(v4a) || IN_EXPERIMENTAL(v4a))
            flags |= NI_NUMERICHOST;
        v4a >>= IN_CLASSA_NSHIFT;
        if (v4a == 0 || v4a == IN_LOOPBACKNET)
            flags |= NI_NUMERICHOST;
        break;
#ifdef ENABLE_IPV6
    case AF_INET6:
        pfx = ((struct sockaddr_in6 *)sa)->sin6_addr.s6_addr[0];
        if (pfx == 0 || pfx == 0xfe || pfx == 0xff)
            flags |= NI_NUMERICHOST;
        break;
#endif
    }
    if (host == NULL || hostlen == 0) {
        /* what should we do? */
    } else if (flags & NI_NUMERICHOST) {
        if (inet_ntop(gni_afd->a_af, addr, numaddr, sizeof(numaddr))
            == NULL)
            return ENI_SYSTEM;
        if (strlen(numaddr) > hostlen)
            return ENI_MEMORY;
        strcpy(host, numaddr);
    } else {
#ifdef ENABLE_IPV6
        hp = getipnodebyaddr(addr, gni_afd->a_addrlen, gni_afd->a_af, &h_error);
#else
        hp = gethostbyaddr(addr, gni_afd->a_addrlen, gni_afd->a_af);
#endif

        if (hp) {
            if (flags & NI_NOFQDN) {
                p = strchr(hp->h_name, '.');
                if (p) *p = '\0';
            }
            if (strlen(hp->h_name) > hostlen) {
#ifdef ENABLE_IPV6
                freehostent(hp);
#endif
                return ENI_MEMORY;
            }
            strcpy(host, hp->h_name);
#ifdef ENABLE_IPV6
            freehostent(hp);
#endif
        } else {
            if (flags & NI_NAMEREQD)
                return ENI_NOHOSTNAME;
            if (inet_ntop(gni_afd->a_af, addr, numaddr, sizeof(numaddr))
                == NULL)
                return ENI_NOHOSTNAME;
            if (strlen(numaddr) > hostlen)
                return ENI_MEMORY;
            strcpy(host, numaddr);
        }
    }
    return SUCCESS;
}
#endif // HAVE_NETDB_H


================================================
File: /Modules/getpath.c
================================================
/* Return the initial module search path. */

#include "Python.h"
#include "pycore_fileutils.h"     // _Py_abspath()
#include "pycore_initconfig.h"    // _PyStatus_EXCEPTION()
#include "pycore_pathconfig.h"    // _PyPathConfig_ReadGlobal()
#include "pycore_pymem.h"         // _PyMem_RawWcsdup()
#include "pycore_pystate.h"       // _PyThreadState_GET()

#include "marshal.h"              // PyMarshal_ReadObjectFromString
#include "osdefs.h"               // DELIM
#include <wchar.h>

#ifdef MS_WINDOWS
#  include <windows.h>            // GetFullPathNameW(), MAX_PATH
#  include <pathcch.h>
#endif

#ifdef __APPLE__
#  include <mach-o/dyld.h>
#endif

#ifdef HAVE_DLFCN_H
#  include <dlfcn.h>
#endif

/* Reference the precompiled getpath.py */
#include "Python/frozen_modules/getpath.h"

#if (!defined(PREFIX) || !defined(EXEC_PREFIX) \
        || !defined(VERSION) || !defined(VPATH) \
        || !defined(PLATLIBDIR))
#error "PREFIX, EXEC_PREFIX, VERSION, VPATH and PLATLIBDIR macros must be defined"
#endif

#if !defined(PYTHONPATH)
#define PYTHONPATH NULL
#endif

#if !defined(PYDEBUGEXT)
#define PYDEBUGEXT NULL
#endif

#if !defined(PYWINVER)
#ifdef MS_DLL_ID
#define PYWINVER MS_DLL_ID
#else
#define PYWINVER NULL
#endif
#endif

#if !defined(EXE_SUFFIX)
#if defined(MS_WINDOWS) || defined(__CYGWIN__) || defined(__MINGW32__)
#define EXE_SUFFIX L".exe"
#else
#define EXE_SUFFIX NULL
#endif
#endif


/* HELPER FUNCTIONS for getpath.py */

static PyObject *
getpath_abspath(PyObject *Py_UNUSED(self), PyObject *args)
{
    PyObject *r = NULL;
    PyObject *pathobj;
    wchar_t *path;
    if (!PyArg_ParseTuple(args, "U", &pathobj)) {
        return NULL;
    }
    Py_ssize_t len;
    path = PyUnicode_AsWideCharString(pathobj, &len);
    if (path) {
        wchar_t *abs;
        if (_Py_abspath((const wchar_t *)_Py_normpath(path, -1), &abs) == 0 && abs) {
            r = PyUnicode_FromWideChar(abs, -1);
            PyMem_RawFree((void *)abs);
        } else {
            PyErr_SetString(PyExc_OSError, "failed to make path absolute");
        }
        PyMem_Free((void *)path);
    }
    return r;
}


static PyObject *
getpath_basename(PyObject *Py_UNUSED(self), PyObject *args)
{
    PyObject *path;
    if (!PyArg_ParseTuple(args, "U", &path)) {
        return NULL;
    }
    Py_ssize_t end = PyUnicode_GET_LENGTH(path);
    Py_ssize_t pos = PyUnicode_FindChar(path, SEP, 0, end, -1);
    if (pos < 0) {
        return Py_NewRef(path);
    }
    return PyUnicode_Substring(path, pos + 1, end);
}


static PyObject *
getpath_dirname(PyObject *Py_UNUSED(self), PyObject *args)
{
    PyObject *path;
    if (!PyArg_ParseTuple(args, "U", &path)) {
        return NULL;
    }
    Py_ssize_t end = PyUnicode_GET_LENGTH(path);
    Py_ssize_t pos = PyUnicode_FindChar(path, SEP, 0, end, -1);
    if (pos < 0) {
        return Py_GetConstant(Py_CONSTANT_EMPTY_STR);
    }
    return PyUnicode_Substring(path, 0, pos);
}


static PyObject *
getpath_isabs(PyObject *Py_UNUSED(self), PyObject *args)
{
    PyObject *r = NULL;
    PyObject *pathobj;
    const wchar_t *path;
    if (!PyArg_ParseTuple(args, "U", &pathobj)) {
        return NULL;
    }
    path = PyUnicode_AsWideCharString(pathobj, NULL);
    if (path) {
        r = _Py_isabs(path) ? Py_True : Py_False;
        PyMem_Free((void *)path);
    }
    return Py_XNewRef(r);
}


static PyObject *
getpath_hassuffix(PyObject *Py_UNUSED(self), PyObject *args)
{
    PyObject *r = NULL;
    PyObject *pathobj;
    PyObject *suffixobj;
    const wchar_t *path;
    const wchar_t *suffix;
    if (!PyArg_ParseTuple(args, "UU", &pathobj, &suffixobj)) {
        return NULL;
    }
    Py_ssize_t len, suffixLen;
    path = PyUnicode_AsWideCharString(pathobj, &len);
    if (path) {
        suffix = PyUnicode_AsWideCharString(suffixobj, &suffixLen);
        if (suffix) {
            if (suffixLen > len ||
#ifdef MS_WINDOWS
                wcsicmp(&path[len - suffixLen], suffix) != 0
#else
                wcscmp(&path[len - suffixLen], suffix) != 0
#endif
            ) {
                r = Py_NewRef(Py_False);
            } else {
                r = Py_NewRef(Py_True);
            }
            PyMem_Free((void *)suffix);
        }
        PyMem_Free((void *)path);
    }
    return r;
}


static PyObject *
getpath_isdir(PyObject *Py_UNUSED(self), PyObject *args)
{
    PyObject *r = NULL;
    PyObject *pathobj;
    const wchar_t *path;
    if (!PyArg_ParseTuple(args, "U", &pathobj)) {
        return NULL;
    }
    path = PyUnicode_AsWideCharString(pathobj, NULL);
    if (path) {
#ifdef MS_WINDOWS
        DWORD attr = GetFileAttributesW(path);
        r = (attr != INVALID_FILE_ATTRIBUTES) &&
            (attr & FILE_ATTRIBUTE_DIRECTORY) ? Py_True : Py_False;
#else
        struct stat st;
        r = (_Py_wstat(path, &st) == 0) && S_ISDIR(st.st_mode) ? Py_True : Py_False;
#endif
        PyMem_Free((void *)path);
    }
    return Py_XNewRef(r);
}


static PyObject *
getpath_isfile(PyObject *Py_UNUSED(self), PyObject *args)
{
    PyObject *r = NULL;
    PyObject *pathobj;
    const wchar_t *path;
    if (!PyArg_ParseTuple(args, "U", &pathobj)) {
        return NULL;
    }
    path = PyUnicode_AsWideCharString(pathobj, NULL);
    if (path) {
#ifdef MS_WINDOWS
        DWORD attr = GetFileAttributesW(path);
        r = (attr != INVALID_FILE_ATTRIBUTES) &&
            !(attr & FILE_ATTRIBUTE_DIRECTORY) ? Py_True : Py_False;
#else
        struct stat st;
        r = (_Py_wstat(path, &st) == 0) && S_ISREG(st.st_mode) ? Py_True : Py_False;
#endif
        PyMem_Free((void *)path);
    }
    return Py_XNewRef(r);
}


static PyObject *
getpath_isxfile(PyObject *Py_UNUSED(self), PyObject *args)
{
    PyObject *r = NULL;
    PyObject *pathobj;
    const wchar_t *path;
    Py_ssize_t cchPath;
    if (!PyArg_ParseTuple(args, "U", &pathobj)) {
        return NULL;
    }
    path = PyUnicode_AsWideCharString(pathobj, &cchPath);
    if (path) {
#ifdef MS_WINDOWS
        DWORD attr = GetFileAttributesW(path);
        r = (attr != INVALID_FILE_ATTRIBUTES) &&
            !(attr & FILE_ATTRIBUTE_DIRECTORY) &&
            (cchPath >= 4) &&
            (CompareStringOrdinal(path + cchPath - 4, -1, L".exe", -1, 1 /* ignore case */) == CSTR_EQUAL)
            ? Py_True : Py_False;
#else
        struct stat st;
        r = (_Py_wstat(path, &st) == 0) &&
            S_ISREG(st.st_mode) &&
            (st.st_mode & 0111)
            ? Py_True : Py_False;
#endif
        PyMem_Free((void *)path);
    }
    return Py_XNewRef(r);
}


static PyObject *
getpath_joinpath(PyObject *Py_UNUSED(self), PyObject *args)
{
    if (!PyTuple_Check(args)) {
        PyErr_SetString(PyExc_TypeError, "requires tuple of arguments");
        return NULL;
    }
    Py_ssize_t n = PyTuple_GET_SIZE(args);
    if (n == 0) {
        return Py_GetConstant(Py_CONSTANT_EMPTY_STR);
    }
    /* Convert all parts to wchar and accumulate max final length */
    wchar_t **parts = (wchar_t **)PyMem_Malloc(n * sizeof(wchar_t *));
    if (parts == NULL) {
        PyErr_NoMemory();
        return NULL;
    }
    memset(parts, 0, n * sizeof(wchar_t *));
    Py_ssize_t cchFinal = 0;
    Py_ssize_t first = 0;

    for (Py_ssize_t i = 0; i < n; ++i) {
        PyObject *s = PyTuple_GET_ITEM(args, i);
        Py_ssize_t cch;
        if (s == Py_None) {
            cch = 0;
        } else if (PyUnicode_Check(s)) {
            parts[i] = PyUnicode_AsWideCharString(s, &cch);
            if (!parts[i]) {
                cchFinal = -1;
                break;
            }
            if (_Py_isabs(parts[i])) {
                first = i;
            }
        } else {
            PyErr_SetString(PyExc_TypeError, "all arguments to joinpath() must be str or None");
            cchFinal = -1;
            break;
        }
        cchFinal += cch + 1;
    }

    wchar_t *final = cchFinal > 0 ? (wchar_t *)PyMem_Malloc(cchFinal * sizeof(wchar_t)) : NULL;
    if (!final) {
        for (Py_ssize_t i = 0; i < n; ++i) {
            PyMem_Free(parts[i]);
        }
        PyMem_Free(parts);
        if (cchFinal) {
            PyErr_NoMemory();
            return NULL;
        }
        return Py_GetConstant(Py_CONSTANT_EMPTY_STR);
    }

    final[0] = '\0';
    /* Now join all the paths. The final result should be shorter than the buffer */
    for (Py_ssize_t i = 0; i < n; ++i) {
        if (!parts[i]) {
            continue;
        }
        if (i >= first && final) {
            if (!final[0]) {
                /* final is definitely long enough to fit any individual part */
                wcscpy(final, parts[i]);
            } else if (_Py_add_relfile(final, parts[i], cchFinal) < 0) {
                /* if we fail, keep iterating to free memory, but stop adding parts */
                PyMem_Free(final);
                final = NULL;
            }
        }
        PyMem_Free(parts[i]);
    }
    PyMem_Free(parts);
    if (!final) {
        PyErr_SetString(PyExc_SystemError, "failed to join paths");
        return NULL;
    }
    PyObject *r = PyUnicode_FromWideChar(_Py_normpath(final, -1), -1);
    PyMem_Free(final);
    return r;
}


static PyObject *
getpath_readlines(PyObject *Py_UNUSED(self), PyObject *args)
{
    PyObject *r = NULL;
    PyObject *pathobj;
    const wchar_t *path;
    if (!PyArg_ParseTuple(args, "U", &pathobj)) {
        return NULL;
    }
    path = PyUnicode_AsWideCharString(pathobj, NULL);
    if (!path) {
        return NULL;
    }
    FILE *fp = _Py_wfopen(path, L"rb");
    if (!fp) {
        PyErr_SetFromErrno(PyExc_OSError);
        PyMem_Free((void *)path);
        return NULL;
    }
    PyMem_Free((void *)path);

    r = PyList_New(0);
    if (!r) {
        fclose(fp);
        return NULL;
    }
    const size_t MAX_FILE = 32 * 1024;
    char *buffer = (char *)PyMem_Malloc(MAX_FILE);
    if (!buffer) {
        Py_DECREF(r);
        fclose(fp);
        return NULL;
    }

    size_t cb = fread(buffer, 1, MAX_FILE, fp);
    fclose(fp);
    if (!cb) {
        return r;
    }
    if (cb >= MAX_FILE) {
        Py_DECREF(r);
        PyErr_SetString(PyExc_MemoryError,
            "cannot read file larger than 32KB during initialization");
        return NULL;
    }
    buffer[cb] = '\0';

    size_t len;
    wchar_t *wbuffer = _Py_DecodeUTF8_surrogateescape(buffer, cb, &len);
    PyMem_Free((void *)buffer);
    if (!wbuffer) {
        Py_DECREF(r);
        PyErr_NoMemory();
        return NULL;
    }

    wchar_t *p1 = wbuffer;
    wchar_t *p2 = p1;
    while ((p2 = wcschr(p1, L'\n')) != NULL) {
        Py_ssize_t cb = p2 - p1;
        while (cb >= 0 && (p1[cb] == L'\n' || p1[cb] == L'\r')) {
            --cb;
        }
        PyObject *u = PyUnicode_FromWideChar(p1, cb >= 0 ? cb + 1 : 0);
        if (!u || PyList_Append(r, u) < 0) {
            Py_XDECREF(u);
            Py_CLEAR(r);
            break;
        }
        Py_DECREF(u);
        p1 = p2 + 1;
    }
    if (r && p1 && *p1) {
        PyObject *u = PyUnicode_FromWideChar(p1, -1);
        if (!u || PyList_Append(r, u) < 0) {
            Py_CLEAR(r);
        }
        Py_XDECREF(u);
    }
    PyMem_RawFree(wbuffer);
    return r;
}


static PyObject *
getpath_realpath(PyObject *Py_UNUSED(self) , PyObject *args)
{
    PyObject *pathobj;
    if (!PyArg_ParseTuple(args, "U", &pathobj)) {
        return NULL;
    }
#if defined(HAVE_READLINK)
    /* This readlink calculation only resolves a symlinked file, and
       does not resolve any path segments. This is consistent with
       prior releases, however, the realpath implementation below is
       potentially correct in more cases. */
    PyObject *r = NULL;
    int nlink = 0;
    wchar_t *path = PyUnicode_AsWideCharString(pathobj, NULL);
    if (!path) {
        goto done;
    }
    wchar_t *path2 = _PyMem_RawWcsdup(path);
    PyMem_Free((void *)path);
    path = path2;
    while (path) {
        wchar_t resolved[MAXPATHLEN + 1];
        int linklen = _Py_wreadlink(path, resolved, Py_ARRAY_LENGTH(resolved));
        if (linklen == -1) {
            r = PyUnicode_FromWideChar(path, -1);
            break;
        }
        if (_Py_isabs(resolved)) {
            PyMem_RawFree((void *)path);
            path = _PyMem_RawWcsdup(resolved);
        } else {
            wchar_t *s = wcsrchr(path, SEP);
            if (s) {
                *s = L'\0';
            }
            path2 = _Py_join_relfile(path, resolved);
            if (path2) {
                path2 = _Py_normpath(path2, -1);
            }
            PyMem_RawFree((void *)path);
            path = path2;
        }
        nlink++;
        /* 40 is the Linux kernel 4.2 limit */
        if (nlink >= 40) {
            PyErr_SetString(PyExc_OSError, "maximum number of symbolic links reached");
            break;
        }
    }
    if (!path) {
        PyErr_NoMemory();
    }
done:
    PyMem_RawFree((void *)path);
    return r;

#elif defined(HAVE_REALPATH)
    PyObject *r = NULL;
    struct stat st;
    const char *narrow = NULL;
    wchar_t *path = PyUnicode_AsWideCharString(pathobj, NULL);
    if (!path) {
        goto done;
    }
    narrow = Py_EncodeLocale(path, NULL);
    if (!narrow) {
        PyErr_NoMemory();
        goto done;
    }
    if (lstat(narrow, &st)) {
        PyErr_SetFromErrno(PyExc_OSError);
        goto done;
    }
    if (!S_ISLNK(st.st_mode)) {
        r = Py_NewRef(pathobj);
        goto done;
    }
    wchar_t resolved[MAXPATHLEN+1];
    if (_Py_wrealpath(path, resolved, MAXPATHLEN) == NULL) {
        PyErr_SetFromErrno(PyExc_OSError);
    } else {
        r = PyUnicode_FromWideChar(resolved, -1);
    }
done:
    PyMem_Free((void *)path);
    PyMem_Free((void *)narrow);
    return r;
#elif defined(MS_WINDOWS)
    HANDLE hFile;
    wchar_t resolved[MAXPATHLEN+1];
    int len = 0, err;
    Py_ssize_t pathlen;
    PyObject *result;

    wchar_t *path = PyUnicode_AsWideCharString(pathobj, &pathlen);
    if (!path) {
        return NULL;
    }
    if (wcslen(path) != pathlen) {
        PyErr_SetString(PyExc_ValueError, "path contains embedded nulls");
        return NULL;
    }

    Py_BEGIN_ALLOW_THREADS
    hFile = CreateFileW(path, 0, 0, NULL, OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS, NULL);
    if (hFile != INVALID_HANDLE_VALUE) {
        len = GetFinalPathNameByHandleW(hFile, resolved, MAXPATHLEN, VOLUME_NAME_DOS);
        err = len ? 0 : GetLastError();
        CloseHandle(hFile);
    } else {
        err = GetLastError();
    }
    Py_END_ALLOW_THREADS

    if (err) {
        PyErr_SetFromWindowsErr(err);
        result = NULL;
    } else if (len <= MAXPATHLEN) {
        const wchar_t *p = resolved;
        if (0 == wcsncmp(p, L"\\\\?\\", 4)) {
            if (GetFileAttributesW(&p[4]) != INVALID_FILE_ATTRIBUTES) {
                p += 4;
                len -= 4;
            }
        }
        if (CompareStringOrdinal(path, (int)pathlen, p, len, TRUE) == CSTR_EQUAL) {
            result = Py_NewRef(pathobj);
        } else {
            result = PyUnicode_FromWideChar(p, len);
        }
    } else {
        result = Py_NewRef(pathobj);
    }
    PyMem_Free(path);
    return result;
#endif

    return Py_NewRef(pathobj);
}


static PyMethodDef getpath_methods[] = {
    {"abspath", getpath_abspath, METH_VARARGS, NULL},
    {"basename", getpath_basename, METH_VARARGS, NULL},
    {"dirname", getpath_dirname, METH_VARARGS, NULL},
    {"hassuffix", getpath_hassuffix, METH_VARARGS, NULL},
    {"isabs", getpath_isabs, METH_VARARGS, NULL},
    {"isdir", getpath_isdir, METH_VARARGS, NULL},
    {"isfile", getpath_isfile, METH_VARARGS, NULL},
    {"isxfile", getpath_isxfile, METH_VARARGS, NULL},
    {"joinpath", getpath_joinpath, METH_VARARGS, NULL},
    {"readlines", getpath_readlines, METH_VARARGS, NULL},
    {"realpath", getpath_realpath, METH_VARARGS, NULL},
    {NULL, NULL, 0, NULL}
};


/* Two implementations of warn() to use depending on whether warnings
   are enabled or not. */

static PyObject *
getpath_warn(PyObject *Py_UNUSED(self), PyObject *args)
{
    PyObject *msgobj;
    if (!PyArg_ParseTuple(args, "U", &msgobj)) {
        return NULL;
    }
    fprintf(stderr, "%s\n", PyUnicode_AsUTF8(msgobj));
    Py_RETURN_NONE;
}


static PyObject *
getpath_nowarn(PyObject *Py_UNUSED(self), PyObject *args)
{
    Py_RETURN_NONE;
}


static PyMethodDef getpath_warn_method = {"warn", getpath_warn, METH_VARARGS, NULL};
static PyMethodDef getpath_nowarn_method = {"warn", getpath_nowarn, METH_VARARGS, NULL};

/* Add the helper functions to the dict */
static int
funcs_to_dict(PyObject *dict, int warnings)
{
    for (PyMethodDef *m = getpath_methods; m->ml_name; ++m) {
        PyObject *f = PyCFunction_NewEx(m, NULL, NULL);
        if (!f) {
            return 0;
        }
        if (PyDict_SetItemString(dict, m->ml_name, f) < 0) {
            Py_DECREF(f);
            return 0;
        }
        Py_DECREF(f);
    }
    PyMethodDef *m2 = warnings ? &getpath_warn_method : &getpath_nowarn_method;
    PyObject *f = PyCFunction_NewEx(m2, NULL, NULL);
    if (!f) {
        return 0;
    }
    if (PyDict_SetItemString(dict, m2->ml_name, f) < 0) {
        Py_DECREF(f);
        return 0;
    }
    Py_DECREF(f);
    return 1;
}


/* Add a wide-character string constant to the dict */
static int
wchar_to_dict(PyObject *dict, const char *key, const wchar_t *s)
{
    PyObject *u;
    int r;
    if (s && s[0]) {
        u = PyUnicode_FromWideChar(s, -1);
        if (!u) {
            return 0;
        }
    } else {
        u = Py_NewRef(Py_None);
    }
    r = PyDict_SetItemString(dict, key, u) == 0;
    Py_DECREF(u);
    return r;
}


/* Add a narrow string constant to the dict, using default locale decoding */
static int
decode_to_dict(PyObject *dict, const char *key, const char *s)
{
    PyObject *u = NULL;
    int r;
    if (s && s[0]) {
        size_t len;
        const wchar_t *w = Py_DecodeLocale(s, &len);
        if (w) {
            u = PyUnicode_FromWideChar(w, len);
            PyMem_RawFree((void *)w);
        }
        if (!u) {
            return 0;
        }
    } else {
        u = Py_NewRef(Py_None);
    }
    r = PyDict_SetItemString(dict, key, u) == 0;
    Py_DECREF(u);
    return r;
}

/* Add an environment variable to the dict, optionally clearing it afterwards */
static int
env_to_dict(PyObject *dict, const char *key, int and_clear)
{
    PyObject *u = NULL;
    int r = 0;
    assert(strncmp(key, "ENV_", 4) == 0);
    assert(strlen(key) < 64);
#ifdef MS_WINDOWS
    wchar_t wkey[64];
    // Quick convert to wchar_t, since we know key is ASCII
    wchar_t *wp = wkey;
    for (const char *p = &key[4]; *p; ++p) {
        assert(*p < 128);
        *wp++ = *p;
    }
    *wp = L'\0';
    const wchar_t *v = _wgetenv(wkey);
    if (v) {
        u = PyUnicode_FromWideChar(v, -1);
        if (!u) {
            PyErr_Clear();
        }
    }
#else
    const char *v = getenv(&key[4]);
    if (v) {
        size_t len;
        const wchar_t *w = Py_DecodeLocale(v, &len);
        if (w) {
            u = PyUnicode_FromWideChar(w, len);
            if (!u) {
                PyErr_Clear();
            }
            PyMem_RawFree((void *)w);
        }
    }
#endif
    if (u) {
        r = PyDict_SetItemString(dict, key, u) == 0;
        Py_DECREF(u);
    } else {
        r = PyDict_SetItemString(dict, key, Py_None) == 0;
    }
    if (r && and_clear) {
#ifdef MS_WINDOWS
        _wputenv_s(wkey, L"");
#else
        unsetenv(&key[4]);
#endif
    }
    return r;
}


/* Add an integer constant to the dict */
static int
int_to_dict(PyObject *dict, const char *key, int v)
{
    PyObject *o;
    int r;
    o = PyLong_FromLong(v);
    if (!o) {
        return 0;
    }
    r = PyDict_SetItemString(dict, key, o) == 0;
    Py_DECREF(o);
    return r;
}


#ifdef MS_WINDOWS
static int
winmodule_to_dict(PyObject *dict, const char *key, HMODULE mod)
{
    wchar_t *buffer = NULL;
    for (DWORD cch = 256; buffer == NULL && cch < (1024 * 1024); cch *= 2) {
        buffer = (wchar_t*)PyMem_RawMalloc(cch * sizeof(wchar_t));
        if (buffer) {
            if (GetModuleFileNameW(mod, buffer, cch) == cch) {
                PyMem_RawFree(buffer);
                buffer = NULL;
            }
        }
    }
    int r = wchar_to_dict(dict, key, buffer);
    PyMem_RawFree(buffer);
    return r;
}
#endif


/* Add the current executable's path to the dict */
static int
progname_to_dict(PyObject *dict, const char *key)
{
#ifdef MS_WINDOWS
    return winmodule_to_dict(dict, key, NULL);
#elif defined(__APPLE__)
    char *path;
    uint32_t pathLen = 256;
    while (pathLen) {
        path = PyMem_RawMalloc((pathLen + 1) * sizeof(char));
        if (!path) {
            return 0;
        }
        if (_NSGetExecutablePath(path, &pathLen) != 0) {
            PyMem_RawFree(path);
            continue;
        }
        // Only keep if the path is absolute
        if (path[0] == SEP) {
            int r = decode_to_dict(dict, key, path);
            PyMem_RawFree(path);
            return r;
        }
        // Fall back and store None
        PyMem_RawFree(path);
        break;
    }
#endif
    return PyDict_SetItemString(dict, key, Py_None) == 0;
}


/* Add the runtime library's path to the dict */
static int
library_to_dict(PyObject *dict, const char *key)
{
/* macOS framework builds do not link against a libpython dynamic library, but
   instead link against a macOS Framework. */
#if defined(Py_ENABLE_SHARED) || defined(WITH_NEXT_FRAMEWORK)

#ifdef MS_WINDOWS
    extern HMODULE PyWin_DLLhModule;
    if (PyWin_DLLhModule) {
        return winmodule_to_dict(dict, key, PyWin_DLLhModule);
    }
#endif

#if HAVE_DLADDR
    Dl_info libpython_info;
    if (dladdr(&Py_Initialize, &libpython_info) && libpython_info.dli_fname) {
        return decode_to_dict(dict, key, libpython_info.dli_fname);
    }
#endif
#endif

    return PyDict_SetItemString(dict, key, Py_None) == 0;
}


PyObject *
_Py_Get_Getpath_CodeObject(void)
{
    return PyMarshal_ReadObjectFromString(
        (const char*)_Py_M__getpath, sizeof(_Py_M__getpath));
}


/* Perform the actual path calculation.

   When compute_path_config is 0, this only reads any initialised path
   config values into the PyConfig struct. For example, Py_SetHome() or
   Py_SetPath(). The only error should be due to failed memory allocation.

   When compute_path_config is 1, full path calculation is performed.
   The GIL must be held, and there may be filesystem access, side
   effects, and potential unraisable errors that are reported directly
   to stderr.

   Calling this function multiple times on the same PyConfig is only
   safe because already-configured values are not recalculated. To
   actually recalculate paths, you need a clean PyConfig.
*/
PyStatus
_PyConfig_InitPathConfig(PyConfig *config, int compute_path_config)
{
    PyStatus status = _PyPathConfig_ReadGlobal(config);

    if (_PyStatus_EXCEPTION(status) || !compute_path_config) {
        return status;
    }

    if (!_PyThreadState_GET()) {
        return PyStatus_Error("cannot calculate path configuration without GIL");
    }

    PyObject *configDict = _PyConfig_AsDict(config);
    if (!configDict) {
        PyErr_Clear();
        return PyStatus_NoMemory();
    }

    PyObject *dict = PyDict_New();
    if (!dict) {
        PyErr_Clear();
        Py_DECREF(configDict);
        return PyStatus_NoMemory();
    }

    if (PyDict_SetItemString(dict, "config", configDict) < 0) {
        PyErr_Clear();
        Py_DECREF(configDict);
        Py_DECREF(dict);
        return PyStatus_NoMemory();
    }
    /* reference now held by dict */
    Py_DECREF(configDict);

    PyObject *co = _Py_Get_Getpath_CodeObject();
    if (!co || !PyCode_Check(co)) {
        PyErr_Clear();
        Py_XDECREF(co);
        Py_DECREF(dict);
        return PyStatus_Error("error reading frozen getpath.py");
    }

#ifdef MS_WINDOWS
    PyObject *winreg = PyImport_ImportModule("winreg");
    if (!winreg || PyDict_SetItemString(dict, "winreg", winreg) < 0) {
        PyErr_Clear();
        Py_XDECREF(winreg);
        if (PyDict_SetItemString(dict, "winreg", Py_None) < 0) {
            PyErr_Clear();
            Py_DECREF(co);
            Py_DECREF(dict);
            return PyStatus_Error("error importing winreg module");
        }
    } else {
        Py_DECREF(winreg);
    }
#endif

    if (
#ifdef MS_WINDOWS
        !decode_to_dict(dict, "os_name", "nt") ||
#elif defined(__APPLE__)
        !decode_to_dict(dict, "os_name", "darwin") ||
#else
        !decode_to_dict(dict, "os_name", "posix") ||
#endif
#ifdef WITH_NEXT_FRAMEWORK
        !int_to_dict(dict, "WITH_NEXT_FRAMEWORK", 1) ||
#else
        !int_to_dict(dict, "WITH_NEXT_FRAMEWORK", 0) ||
#endif
        !decode_to_dict(dict, "PREFIX", PREFIX) ||
        !decode_to_dict(dict, "EXEC_PREFIX", EXEC_PREFIX) ||
        !decode_to_dict(dict, "PYTHONPATH", PYTHONPATH) ||
        !decode_to_dict(dict, "VPATH", VPATH) ||
        !decode_to_dict(dict, "PLATLIBDIR", PLATLIBDIR) ||
        !decode_to_dict(dict, "PYDEBUGEXT", PYDEBUGEXT) ||
        !int_to_dict(dict, "VERSION_MAJOR", PY_MAJOR_VERSION) ||
        !int_to_dict(dict, "VERSION_MINOR", PY_MINOR_VERSION) ||
        !decode_to_dict(dict, "PYWINVER", PYWINVER) ||
        !wchar_to_dict(dict, "EXE_SUFFIX", EXE_SUFFIX) ||
        !env_to_dict(dict, "ENV_PATH", 0) ||
        !env_to_dict(dict, "ENV_PYTHONHOME", 0) ||
        !env_to_dict(dict, "ENV_PYTHONEXECUTABLE", 0) ||
        !env_to_dict(dict, "ENV___PYVENV_LAUNCHER__", 1) ||
        !progname_to_dict(dict, "real_executable") ||
        !library_to_dict(dict, "library") ||
        !wchar_to_dict(dict, "executable_dir", NULL) ||
        !wchar_to_dict(dict, "py_setpath", _PyPathConfig_GetGlobalModuleSearchPath()) ||
        !funcs_to_dict(dict, config->pathconfig_warnings) ||
#ifdef Py_GIL_DISABLED
        !decode_to_dict(dict, "ABI_THREAD", "t") ||
#else
        !decode_to_dict(dict, "ABI_THREAD", "") ||
#endif
#ifndef MS_WINDOWS
        PyDict_SetItemString(dict, "winreg", Py_None) < 0 ||
#endif
        PyDict_SetItemString(dict, "__builtins__", PyEval_GetBuiltins()) < 0
    ) {
        Py_DECREF(co);
        Py_DECREF(dict);
        PyErr_FormatUnraisable("Exception ignored in preparing getpath");
        return PyStatus_Error("error evaluating initial values");
    }

    PyObject *r = PyEval_EvalCode(co, dict, dict);
    Py_DECREF(co);

    if (!r) {
        Py_DECREF(dict);
        PyErr_FormatUnraisable("Exception ignored in running getpath");
        return PyStatus_Error("error evaluating path");
    }
    Py_DECREF(r);

    if (_PyConfig_FromDict(config, configDict) < 0) {
        PyErr_FormatUnraisable("Exception ignored in reading getpath results");
        Py_DECREF(dict);
        return PyStatus_Error("error getting getpath results");
    }

    Py_DECREF(dict);

    return _PyStatus_OK();
}


================================================
File: /Modules/getpath.py
================================================
# ******************************************************************************
# getpath.py
# ******************************************************************************

# This script is designed to be precompiled to bytecode, frozen into the
# main binary, and then directly evaluated. It is not an importable module,
# and does not import any other modules (besides winreg on Windows).
# Rather, the values listed below must be specified in the globals dict
# used when evaluating the bytecode.

# See _PyConfig_InitPathConfig in Modules/getpath.c for the execution.

# ******************************************************************************
# REQUIRED GLOBALS
# ******************************************************************************

# ** Helper functions **
# abspath(path)     -- make relative paths absolute against CWD
# basename(path)    -- the filename of path
# dirname(path)     -- the directory name of path
# hassuffix(path, suffix) -- returns True if path has suffix
# isabs(path)       -- path is absolute or not
# isdir(path)       -- path exists and is a directory
# isfile(path)      -- path exists and is a file
# isxfile(path)     -- path exists and is an executable file
# joinpath(*paths)  -- combine the paths
# readlines(path)   -- a list of each line of text in the UTF-8 encoded file
# realpath(path)    -- resolves symlinks in path
# warn(message)     -- print a warning (if enabled)

# ** Values known at compile time **
# os_name           -- [in] one of 'nt', 'posix', 'darwin'
# PREFIX            -- [in] sysconfig.get_config_var(...)
# EXEC_PREFIX       -- [in] sysconfig.get_config_var(...)
# PYTHONPATH        -- [in] sysconfig.get_config_var(...)
# WITH_NEXT_FRAMEWORK   -- [in] sysconfig.get_config_var(...)
# VPATH             -- [in] sysconfig.get_config_var(...)
# PLATLIBDIR        -- [in] sysconfig.get_config_var(...)
# PYDEBUGEXT        -- [in, opt] '_d' on Windows for debug builds
# EXE_SUFFIX        -- [in, opt] '.exe' on Windows/Cygwin/similar
# VERSION_MAJOR     -- [in] sys.version_info.major
# VERSION_MINOR     -- [in] sys.version_info.minor
# ABI_THREAD        -- [in] either 't' for free-threaded builds or ''
# PYWINVER          -- [in] the Windows platform-specific version (e.g. 3.8-32)

# ** Values read from the environment **
#   There is no need to check the use_environment flag before reading
#   these, as the flag will be tested in this script.
#   Also note that ENV_PYTHONPATH is read from config['pythonpath_env']
#   to allow for embedders who choose to specify it via that struct.
# ENV_PATH                -- [in] getenv(...)
# ENV_PYTHONHOME          -- [in] getenv(...)
# ENV_PYTHONEXECUTABLE    -- [in] getenv(...)
# ENV___PYVENV_LAUNCHER__ -- [in] getenv(...)

# ** Values calculated at runtime **
# config            -- [in/out] dict of the PyConfig structure
# real_executable   -- [in, optional] resolved path to main process
#   On Windows and macOS, read directly from the running process
#   Otherwise, leave None and it will be calculated from executable
# executable_dir    -- [in, optional] real directory containing binary
#   If None, will be calculated from real_executable or executable
# py_setpath        -- [in] argument provided to Py_SetPath
#   If None, 'prefix' and 'exec_prefix' may be updated in config
# library           -- [in, optional] path of dylib/DLL/so
#   Only used for locating ._pth files
# winreg            -- [in, optional] the winreg module (only on Windows)

# ******************************************************************************
# HIGH-LEVEL ALGORITHM
# ******************************************************************************

# IMPORTANT: The code is the actual specification at time of writing.
# This prose description is based on the original comment from the old
# getpath.c to help capture the intent, but should not be considered
# a specification.

# Search in some common locations for the associated Python libraries.

# Two directories must be found, the platform independent directory
# (prefix), containing the common .py and .pyc files, and the platform
# dependent directory (exec_prefix), containing the shared library
# modules.  Note that prefix and exec_prefix can be the same directory,
# but for some installations, they are different.

# This script carries out separate searches for prefix and exec_prefix.
# Each search tries a number of different locations until a ``landmark''
# file or directory is found.  If no prefix or exec_prefix is found, a
# warning message is issued and the preprocessor defined PREFIX and
# EXEC_PREFIX are used (even though they will not work); python carries on
# as best as is possible, but most imports will fail.

# Before any searches are done, the location of the executable is
# determined.  If Py_SetPath() was called, or if we are running on
# Windows, the 'real_executable' path is used (if known).  Otherwise,
# we use the config-specified program name or default to argv[0].
# If this has one or more slashes in it, it is made absolute against
# the current working directory.  If it only contains a name, it must
# have been invoked from the shell's path, so we search $PATH for the
# named executable and use that.  If the executable was not found on
# $PATH (or there was no $PATH environment variable), the original
# argv[0] string is used.

# At this point, provided Py_SetPath was not used, the
# __PYVENV_LAUNCHER__ variable may override the executable (on macOS,
# the PYTHON_EXECUTABLE variable may also override). This allows
# certain launchers that run Python as a subprocess to properly
# specify the executable path. They are not intended for users.

# Next, the executable location is examined to see if it is a symbolic
# link.  If so, the link is realpath-ed and the directory of the link
# target is used for the remaining searches.  The same steps are
# performed for prefix and for exec_prefix, but with different landmarks.

# Step 1. Are we running in a virtual environment? Unless 'home' has
# been specified another way, check for a pyvenv.cfg and use its 'home'
# property to override the executable dir used later for prefix searches.
# We do not activate the venv here - that is performed later by site.py.

# Step 2. Is there a ._pth file? A ._pth file lives adjacent to the
# runtime library (if any) or the actual executable (not the symlink),
# and contains precisely the intended contents of sys.path as relative
# paths (to its own location). Its presence also enables isolated mode
# and suppresses other environment variable usage. Unless already
# specified by Py_SetHome(), the directory containing the ._pth file is
# set as 'home'.

# Step 3. Are we running python out of the build directory?  This is
# checked by looking for the BUILDDIR_TXT file, which contains the
# relative path to the platlib dir. The executable_dir value is
# derived from joining the VPATH preprocessor variable to the
# directory containing pybuilddir.txt. If it is not found, the
# BUILD_LANDMARK file is found, which is part of the source tree.
# prefix is then found by searching up for a file that should only
# exist in the source tree, and the stdlib dir is set to prefix/Lib.

# Step 4. If 'home' is set, either by Py_SetHome(), ENV_PYTHONHOME,
# a pyvenv.cfg file, ._pth file, or by detecting a build directory, it
# is assumed to point to prefix and exec_prefix. $PYTHONHOME can be a
# single directory, which is used for both, or the prefix and exec_prefix
# directories separated by DELIM (colon on POSIX; semicolon on Windows).

# Step 5. Try to find prefix and exec_prefix relative to executable_dir,
# backtracking up the path until it is exhausted.  This is the most common
# step to succeed.  Note that if prefix and exec_prefix are different,
# exec_prefix is more likely to be found; however if exec_prefix is a
# subdirectory of prefix, both will be found.

# Step 6. Search the directories pointed to by the preprocessor variables
# PREFIX and EXEC_PREFIX.  These are supplied by the Makefile but can be
# passed in as options to the configure script.

# That's it!

# Well, almost.  Once we have determined prefix and exec_prefix, the
# preprocessor variable PYTHONPATH is used to construct a path.  Each
# relative path on PYTHONPATH is prefixed with prefix.  Then the directory
# containing the shared library modules is appended.  The environment
# variable $PYTHONPATH is inserted in front of it all. On POSIX, if we are
# in a build directory, both prefix and exec_prefix are reset to the
# corresponding preprocessor variables (so sys.prefix will reflect the
# installation location, even though sys.path points into the build
# directory).  This seems to make more sense given that currently the only
# known use of sys.prefix and sys.exec_prefix is for the ILU installation
# process to find the installed Python tree.

# An embedding application can use Py_SetPath() to override all of
# these automatic path computations.


# ******************************************************************************
# PLATFORM CONSTANTS
# ******************************************************************************

platlibdir = config.get('platlibdir') or PLATLIBDIR
ABI_THREAD = ABI_THREAD or ''

if os_name == 'posix' or os_name == 'darwin':
    BUILDDIR_TXT = 'pybuilddir.txt'
    BUILD_LANDMARK = 'Modules/Setup.local'
    DEFAULT_PROGRAM_NAME = f'python{VERSION_MAJOR}'
    STDLIB_SUBDIR = f'{platlibdir}/python{VERSION_MAJOR}.{VERSION_MINOR}{ABI_THREAD}'
    STDLIB_LANDMARKS = [f'{STDLIB_SUBDIR}/os.py', f'{STDLIB_SUBDIR}/os.pyc']
    PLATSTDLIB_LANDMARK = f'{platlibdir}/python{VERSION_MAJOR}.{VERSION_MINOR}{ABI_THREAD}/lib-dynload'
    BUILDSTDLIB_LANDMARKS = ['Lib/os.py']
    VENV_LANDMARK = 'pyvenv.cfg'
    ZIP_LANDMARK = f'{platlibdir}/python{VERSION_MAJOR}{VERSION_MINOR}{ABI_THREAD}.zip'
    DELIM = ':'
    SEP = '/'

elif os_name == 'nt':
    BUILDDIR_TXT = 'pybuilddir.txt'
    BUILD_LANDMARK = f'{VPATH}\\Modules\\Setup.local'
    DEFAULT_PROGRAM_NAME = f'python'
    STDLIB_SUBDIR = 'Lib'
    STDLIB_LANDMARKS = [f'{STDLIB_SUBDIR}\\os.py', f'{STDLIB_SUBDIR}\\os.pyc']
    PLATSTDLIB_LANDMARK = f'{platlibdir}'
    BUILDSTDLIB_LANDMARKS = ['Lib\\os.py']
    VENV_LANDMARK = 'pyvenv.cfg'
    ZIP_LANDMARK = f'python{VERSION_MAJOR}{VERSION_MINOR}{PYDEBUGEXT or ""}.zip'
    WINREG_KEY = f'SOFTWARE\\Python\\PythonCore\\{PYWINVER}\\PythonPath'
    DELIM = ';'
    SEP = '\\'


# ******************************************************************************
# HELPER FUNCTIONS (note that we prefer C functions for performance)
# ******************************************************************************

def search_up(prefix, *landmarks, test=isfile):
    while prefix:
        if any(test(joinpath(prefix, f)) for f in landmarks):
            return prefix
        prefix = dirname(prefix)


# ******************************************************************************
# READ VARIABLES FROM config
# ******************************************************************************

program_name = config.get('program_name')
home = config.get('home')
executable = config.get('executable')
base_executable = config.get('base_executable')
prefix = config.get('prefix')
exec_prefix = config.get('exec_prefix')
base_prefix = config.get('base_prefix')
base_exec_prefix = config.get('base_exec_prefix')
ENV_PYTHONPATH = config['pythonpath_env']
use_environment = config.get('use_environment', 1)

pythonpath = config.get('module_search_paths')
pythonpath_was_set = config.get('module_search_paths_set')
stdlib_dir = config.get('stdlib_dir')
stdlib_dir_was_set_in_config = bool(stdlib_dir)

real_executable_dir = None
platstdlib_dir = None

# ******************************************************************************
# CALCULATE program_name
# ******************************************************************************

if not program_name:
    try:
        program_name = config.get('orig_argv', [])[0]
    except IndexError:
        pass

if not program_name:
    program_name = DEFAULT_PROGRAM_NAME

if EXE_SUFFIX and not hassuffix(program_name, EXE_SUFFIX) and isxfile(program_name + EXE_SUFFIX):
    program_name = program_name + EXE_SUFFIX


# ******************************************************************************
# CALCULATE executable
# ******************************************************************************

if py_setpath:
    # When Py_SetPath has been called, executable defaults to
    # the real executable path.
    if not executable:
        executable = real_executable

if not executable and SEP in program_name:
    # Resolve partial path program_name against current directory
    executable = abspath(program_name)

if not executable:
    # All platforms default to real_executable if known at this
    # stage. POSIX does not set this value.
    executable = real_executable
elif os_name == 'darwin':
    # QUIRK: On macOS we may know the real executable path, but
    # if our caller has lied to us about it (e.g. most of
    # test_embed), we need to use their path in order to detect
    # whether we are in a build tree. This is true even if the
    # executable path was provided in the config.
    real_executable = executable

if not executable and program_name and ENV_PATH:
    # Resolve names against PATH.
    # NOTE: The use_environment value is ignored for this lookup.
    # To properly isolate, launch Python with a full path.
    for p in ENV_PATH.split(DELIM):
        p = joinpath(p, program_name)
        if isxfile(p):
            executable = p
            break

if not executable:
    executable = ''
    # When we cannot calculate the executable, subsequent searches
    # look in the current working directory. Here, we emulate that
    # (the former getpath.c would do it apparently by accident).
    executable_dir = abspath('.')
    # Also need to set this fallback in case we are running from a
    # build directory with an invalid argv0 (i.e. test_sys.test_executable)
    real_executable_dir = executable_dir

if ENV_PYTHONEXECUTABLE or ENV___PYVENV_LAUNCHER__:
    # If set, these variables imply that we should be using them as
    # sys.executable and when searching for venvs. However, we should
    # use the argv0 path for prefix calculation

    if os_name == 'darwin' and WITH_NEXT_FRAMEWORK:
        # In a framework build the binary in {sys.exec_prefix}/bin is
        # a stub executable that execs the real interpreter in an
        # embedded app bundle. That bundle is an implementation detail
        # and should not affect base_executable.
        base_executable = f"{dirname(library)}/bin/python{VERSION_MAJOR}.{VERSION_MINOR}"
    else:
        # Use the real executable as our base, or argv[0] otherwise
        # (on Windows, argv[0] is likely to be ENV___PYVENV_LAUNCHER__; on
        # other platforms, real_executable is likely to be empty)
        base_executable = real_executable or executable

    if not real_executable:
        real_executable = base_executable
        #real_executable_dir = dirname(real_executable)
    executable = ENV_PYTHONEXECUTABLE or ENV___PYVENV_LAUNCHER__
    executable_dir = dirname(executable)


# ******************************************************************************
# CALCULATE (default) home
# ******************************************************************************

# Used later to distinguish between Py_SetPythonHome and other
# ways that it may have been set
home_was_set = False

if home:
    home_was_set = True
elif use_environment and ENV_PYTHONHOME and not py_setpath:
    home = ENV_PYTHONHOME


# ******************************************************************************
# READ pyvenv.cfg
# ******************************************************************************

venv_prefix = None

# Calling Py_SetPath() will override venv detection.
# Calling Py_SetPythonHome() or setting $PYTHONHOME will override the 'home' key
# specified in pyvenv.cfg.
if not py_setpath:
    try:
        # prefix2 is just to avoid calculating dirname again later,
        # as the path in venv_prefix is the more common case.
        venv_prefix2 = executable_dir or dirname(executable)
        venv_prefix = dirname(venv_prefix2)
        try:
            # Read pyvenv.cfg from one level above executable
            pyvenvcfg = readlines(joinpath(venv_prefix, VENV_LANDMARK))
        except (FileNotFoundError, PermissionError):
            # Try the same directory as executable
            pyvenvcfg = readlines(joinpath(venv_prefix2, VENV_LANDMARK))
            venv_prefix = venv_prefix2
    except (FileNotFoundError, PermissionError):
        venv_prefix = None
        pyvenvcfg = []

    # Search for the 'home' key in pyvenv.cfg. Currently, we don't consider the
    # presence of a pyvenv.cfg file without a 'home' key to signify the
    # existence of a virtual environment — we quietly ignore them.
    # XXX: If we don't find a 'home' key, we don't look for another pyvenv.cfg!
    for line in pyvenvcfg:
        key, had_equ, value = line.partition('=')
        if had_equ and key.strip().lower() == 'home':
            # If PYTHONHOME was set, ignore 'home' from pyvenv.cfg.
            if home:
                break
            # Override executable_dir/real_executable_dir with the value from 'home'.
            # These values may be later used to calculate prefix/base_prefix, if a more
            # reliable source — like the runtime library (libpython) path — isn't available.
            executable_dir = real_executable_dir = value.strip()
            # If base_executable — which points to the Python interpreted from
            # the base installation — isn't set (eg. when embedded), try to find
            # it in 'home'.
            if not base_executable:
                # First try to resolve symlinked executables, since that may be
                # more accurate than assuming the executable in 'home'.
                try:
                    base_executable = realpath(executable)
                    if base_executable == executable:
                        # No change, so probably not a link. Clear it and fall back
                        base_executable = ''
                except OSError:
                    pass
                if not base_executable:
                    base_executable = joinpath(executable_dir, basename(executable))
                    # It's possible "python" is executed from within a posix venv but that
                    # "python" is not available in the "home" directory as the standard
                    # `make install` does not create it and distros often do not provide it.
                    #
                    # In this case, try to fall back to known alternatives
                    if os_name != 'nt' and not isfile(base_executable):
                        base_exe = basename(executable)
                        for candidate in (DEFAULT_PROGRAM_NAME, f'python{VERSION_MAJOR}.{VERSION_MINOR}'):
                            candidate += EXE_SUFFIX if EXE_SUFFIX else ''
                            if base_exe == candidate:
                                continue
                            candidate = joinpath(executable_dir, candidate)
                            # Only set base_executable if the candidate exists.
                            # If no candidate succeeds, subsequent errors related to
                            # base_executable (like FileNotFoundError) remain in the
                            # context of the original executable name
                            if isfile(candidate):
                                base_executable = candidate
                                break
            break
    else:
        # We didn't find a 'home' key in pyvenv.cfg (no break), reset venv_prefix.
        venv_prefix = None


# ******************************************************************************
# CALCULATE base_executable, real_executable AND executable_dir
# ******************************************************************************

if not base_executable:
    base_executable = executable or real_executable or ''

if not real_executable:
    real_executable = base_executable

if real_executable:
    try:
        real_executable = realpath(real_executable)
    except OSError as ex:
        # Only warn if the file actually exists and was unresolvable
        # Otherwise users who specify a fake executable may get spurious warnings.
        if isfile(real_executable):
            warn(f'Failed to find real location of {real_executable}')

if not executable_dir and os_name == 'darwin' and library:
    # QUIRK: macOS checks adjacent to its library early
    library_dir = dirname(library)
    if any(isfile(joinpath(library_dir, p)) for p in STDLIB_LANDMARKS):
        # Exceptions here should abort the whole process (to match
        # previous behavior)
        executable_dir = realpath(library_dir)
        real_executable_dir = executable_dir

# If we do not have the executable's directory, we can calculate it.
# This is the directory used to find prefix/exec_prefix if necessary.
if not executable_dir and real_executable:
    executable_dir = real_executable_dir = dirname(real_executable)

# If we do not have the real executable's directory, we calculate it.
# This is the directory used to detect build layouts.
if not real_executable_dir and real_executable:
    real_executable_dir = dirname(real_executable)

# ******************************************************************************
# DETECT _pth FILE
# ******************************************************************************

# The contents of an optional ._pth file are used to totally override
# sys.path calculation. Its presence also implies isolated mode and
# no-site (unless explicitly requested)
pth = None
pth_dir = None

# Calling Py_SetPythonHome() or Py_SetPath() will override ._pth search,
# but environment variables and command-line options cannot.
if not py_setpath and not home_was_set:
    # 1. Check adjacent to the main DLL/dylib/so (if set)
    # 2. Check adjacent to the original executable
    # 3. Check adjacent to our actual executable
    # This may allow a venv to override the base_executable's
    # ._pth file, but it cannot override the library's one.
    for p in [library, executable, real_executable]:
        if p:
            if os_name == 'nt' and (hassuffix(p, 'exe') or hassuffix(p, 'dll')):
                p = p.rpartition('.')[0]
            p += '._pth'
            try:
                pth = readlines(p)
                pth_dir = dirname(p)
                break
            except OSError:
                pass

    # If we found a ._pth file, disable environment and home
    # detection now. Later, we will do the rest.
    if pth_dir:
        use_environment = 0
        home = pth_dir
        pythonpath = []


# ******************************************************************************
# CHECK FOR BUILD DIRECTORY
# ******************************************************************************

build_prefix = None

if ((not home_was_set and real_executable_dir and not py_setpath)
        or config.get('_is_python_build', 0) > 0):
    # Detect a build marker and use it to infer prefix, exec_prefix,
    # stdlib_dir and the platstdlib_dir directories.
    try:
        platstdlib_dir = joinpath(
            real_executable_dir,
            readlines(joinpath(real_executable_dir, BUILDDIR_TXT))[0],
        )
        build_prefix = joinpath(real_executable_dir, VPATH)
    except IndexError:
        # File exists but is empty
        platstdlib_dir = real_executable_dir
        build_prefix = joinpath(real_executable_dir, VPATH)
    except (FileNotFoundError, PermissionError):
        if isfile(joinpath(real_executable_dir, BUILD_LANDMARK)):
            build_prefix = joinpath(real_executable_dir, VPATH)
            if os_name == 'nt':
                # QUIRK: Windows builds need platstdlib_dir to be the executable
                # dir. Normally the builddir marker handles this, but in this
                # case we need to correct manually.
                platstdlib_dir = real_executable_dir

    if build_prefix:
        if os_name == 'nt':
            # QUIRK: No searching for more landmarks on Windows
            build_stdlib_prefix = build_prefix
        else:
            build_stdlib_prefix = search_up(build_prefix, *BUILDSTDLIB_LANDMARKS)
        # Use the build prefix for stdlib when not explicitly set
        if not stdlib_dir_was_set_in_config:
            if build_stdlib_prefix:
                stdlib_dir = joinpath(build_stdlib_prefix, 'Lib')
            else:
                stdlib_dir = joinpath(build_prefix, 'Lib')
        # Only use the build prefix for prefix if it hasn't already been set
        if not prefix:
            prefix = build_stdlib_prefix
        # Do not warn, because 'prefix' never equals 'build_prefix' on POSIX
        #elif not venv_prefix and prefix != build_prefix:
        #    warn('Detected development environment but prefix is already set')
        if not exec_prefix:
            exec_prefix = build_prefix
        # Do not warn, because 'exec_prefix' never equals 'build_prefix' on POSIX
        #elif not venv_prefix and exec_prefix != build_prefix:
        #    warn('Detected development environment but exec_prefix is already set')
        config['_is_python_build'] = 1


# ******************************************************************************
# CALCULATE prefix AND exec_prefix
# ******************************************************************************

if py_setpath:
    # As documented, calling Py_SetPath will force both prefix
    # and exec_prefix to the empty string.
    prefix = exec_prefix = ''

else:
    # Read prefix and exec_prefix from explicitly set home
    if home:
        # When multiple paths are listed with ':' or ';' delimiters,
        # split into prefix:exec_prefix
        prefix, had_delim, exec_prefix = home.partition(DELIM)
        if not had_delim:
            exec_prefix = prefix
        # Reset the standard library directory if it was not explicitly set
        if not stdlib_dir_was_set_in_config:
            stdlib_dir = None


    # First try to detect prefix by looking alongside our runtime library, if known
    if library and not prefix:
        library_dir = dirname(library)
        if ZIP_LANDMARK:
            if os_name == 'nt':
                # QUIRK: Windows does not search up for ZIP file
                if isfile(joinpath(library_dir, ZIP_LANDMARK)):
                    prefix = library_dir
            else:
                prefix = search_up(library_dir, ZIP_LANDMARK)
        if STDLIB_SUBDIR and STDLIB_LANDMARKS and not prefix:
            if any(isfile(joinpath(library_dir, f)) for f in STDLIB_LANDMARKS):
                prefix = library_dir
                if not stdlib_dir_was_set_in_config:
                    stdlib_dir = joinpath(prefix, STDLIB_SUBDIR)


    # Detect prefix by looking for zip file
    if ZIP_LANDMARK and executable_dir and not prefix:
        if os_name == 'nt':
            # QUIRK: Windows does not search up for ZIP file
            if isfile(joinpath(executable_dir, ZIP_LANDMARK)):
                prefix = executable_dir
        else:
            prefix = search_up(executable_dir, ZIP_LANDMARK)
        if prefix and not stdlib_dir_was_set_in_config:
            stdlib_dir = joinpath(prefix, STDLIB_SUBDIR)
            if not isdir(stdlib_dir):
                stdlib_dir = None


    # Detect prefix by searching from our executable location for the stdlib_dir
    if STDLIB_SUBDIR and STDLIB_LANDMARKS and executable_dir and not prefix:
        prefix = search_up(executable_dir, *STDLIB_LANDMARKS)
        if prefix and not stdlib_dir:
            stdlib_dir = joinpath(prefix, STDLIB_SUBDIR)

    if PREFIX and not prefix:
        prefix = PREFIX
        if not any(isfile(joinpath(prefix, f)) for f in STDLIB_LANDMARKS):
            warn('Could not find platform independent libraries <prefix>')

    if not prefix:
        prefix = abspath('')
        warn('Could not find platform independent libraries <prefix>')


    # Detect exec_prefix by searching from executable for the platstdlib_dir
    if PLATSTDLIB_LANDMARK and not exec_prefix:
        if os_name == 'nt':
            # QUIRK: Windows always assumed these were the same
            # gh-100320: Our PYDs are assumed to be relative to the Lib directory
            # (that is, prefix) rather than the executable (that is, executable_dir)
            exec_prefix = prefix
        if not exec_prefix and prefix and isdir(joinpath(prefix, PLATSTDLIB_LANDMARK)):
            exec_prefix = prefix
        if not exec_prefix and executable_dir:
            exec_prefix = search_up(executable_dir, PLATSTDLIB_LANDMARK, test=isdir)
        if not exec_prefix and EXEC_PREFIX:
            exec_prefix = EXEC_PREFIX
        if not exec_prefix or not isdir(joinpath(exec_prefix, PLATSTDLIB_LANDMARK)):
            if os_name == 'nt':
                # QUIRK: If DLLs is missing on Windows, don't warn, just assume
                # that they're in exec_prefix
                if not platstdlib_dir:
                    # gh-98790: We set platstdlib_dir here to avoid adding "DLLs" into
                    # sys.path when it doesn't exist in the platstdlib place, which
                    # would give Lib packages precedence over executable_dir where our
                    # PYDs *probably* live. Ideally, whoever changes our layout will tell
                    # us what the layout is, but in the past this worked, so it should
                    # keep working.
                    platstdlib_dir = exec_prefix
            else:
                warn('Could not find platform dependent libraries <exec_prefix>')


    # Fallback: assume exec_prefix == prefix
    if not exec_prefix:
        exec_prefix = prefix


    if not prefix or not exec_prefix:
        warn('Consider setting $PYTHONHOME to <prefix>[:<exec_prefix>]')


# For a venv, update the main prefix/exec_prefix but leave the base ones unchanged
if venv_prefix:
    if not base_prefix:
        base_prefix = prefix
    if not base_exec_prefix:
        base_exec_prefix = exec_prefix
    prefix = exec_prefix = venv_prefix


# After calculating prefix and exec_prefix, use their values for base_prefix and
# base_exec_prefix if they haven't been set.
if not base_prefix:
    base_prefix = prefix
if not base_exec_prefix:
    base_exec_prefix = exec_prefix


# ******************************************************************************
# UPDATE pythonpath (sys.path)
# ******************************************************************************

if py_setpath:
    # If Py_SetPath was called then it overrides any existing search path
    config['module_search_paths'] = py_setpath.split(DELIM)
    config['module_search_paths_set'] = 1

elif not pythonpath_was_set:
    # If pythonpath was already explicitly set or calculated, we leave it alone.
    # This won't matter in normal use, but if an embedded host is trying to
    # recalculate paths while running then we do not want to change it.
    pythonpath = []

    # First add entries from the process environment
    if use_environment and ENV_PYTHONPATH:
        for p in ENV_PYTHONPATH.split(DELIM):
            pythonpath.append(abspath(p))

    # Then add the default zip file
    if os_name == 'nt':
        # QUIRK: Windows uses the library directory rather than the prefix
        if library:
            library_dir = dirname(library)
        else:
            library_dir = executable_dir
        pythonpath.append(joinpath(library_dir, ZIP_LANDMARK))
    elif build_prefix:
        # QUIRK: POSIX uses the default prefix when in the build directory
        pythonpath.append(joinpath(PREFIX, ZIP_LANDMARK))
    else:
        pythonpath.append(joinpath(base_prefix, ZIP_LANDMARK))

    if os_name == 'nt' and use_environment and winreg:
        # QUIRK: Windows also lists paths in the registry. Paths are stored
        # as the default value of each subkey of
        # {HKCU,HKLM}\Software\Python\PythonCore\{winver}\PythonPath
        # where winver is sys.winver (typically '3.x' or '3.x-32')
        for hk in (winreg.HKEY_CURRENT_USER, winreg.HKEY_LOCAL_MACHINE):
            try:
                key = winreg.OpenKeyEx(hk, WINREG_KEY)
                try:
                    i = 0
                    while True:
                        try:
                            v = winreg.QueryValue(key, winreg.EnumKey(key, i))
                        except OSError:
                            break
                        if isinstance(v, str):
                            pythonpath.extend(v.split(DELIM))
                        i += 1
                    # Paths from the core key get appended last, but only
                    # when home was not set and we haven't found our stdlib
                    # some other way.
                    if not home and not stdlib_dir:
                        v = winreg.QueryValue(key, None)
                        if isinstance(v, str):
                            pythonpath.extend(v.split(DELIM))
                finally:
                    winreg.CloseKey(key)
            except OSError:
                pass

    # Then add any entries compiled into the PYTHONPATH macro.
    if PYTHONPATH:
        for p in PYTHONPATH.split(DELIM):
            pythonpath.append(joinpath(base_prefix, p))

    # Then add stdlib_dir and platstdlib_dir
    if not stdlib_dir and base_prefix:
        stdlib_dir = joinpath(base_prefix, STDLIB_SUBDIR)
    if not platstdlib_dir and base_exec_prefix:
        platstdlib_dir = joinpath(base_exec_prefix, PLATSTDLIB_LANDMARK)

    if os_name == 'nt':
        # QUIRK: Windows generates paths differently
        if platstdlib_dir:
            pythonpath.append(platstdlib_dir)
        if stdlib_dir:
            pythonpath.append(stdlib_dir)
        if executable_dir and executable_dir not in pythonpath:
            # QUIRK: the executable directory is on sys.path
            # We keep it low priority, so that properly installed modules are
            # found first. It may be earlier in the order if we found some
            # reason to put it there.
            pythonpath.append(executable_dir)
    else:
        if stdlib_dir:
            pythonpath.append(stdlib_dir)
        if platstdlib_dir:
            pythonpath.append(platstdlib_dir)

    config['module_search_paths'] = pythonpath
    config['module_search_paths_set'] = 1


# ******************************************************************************
# POSIX prefix/exec_prefix QUIRKS
# ******************************************************************************

# QUIRK: Non-Windows replaces prefix/exec_prefix with defaults when running
# in build directory. This happens after pythonpath calculation.
# Virtual environments using the build directory Python still keep their prefix.
if os_name != 'nt' and build_prefix:
    if not venv_prefix:
        prefix = config.get('prefix') or PREFIX
        exec_prefix = config.get('exec_prefix') or EXEC_PREFIX or prefix
    base_prefix = config.get('base_prefix') or PREFIX
    base_exec_prefix = config.get('base_exec_prefix') or EXEC_PREFIX or base_prefix


# ******************************************************************************
# SET pythonpath FROM _PTH FILE
# ******************************************************************************

if pth:
    config['isolated'] = 1
    config['use_environment'] = 0
    config['site_import'] = 0
    config['safe_path'] = 1
    pythonpath = []
    for line in pth:
        line = line.partition('#')[0].strip()
        if not line:
            pass
        elif line == 'import site':
            config['site_import'] = 1
        elif line.startswith('import '):
            warn("unsupported 'import' line in ._pth file")
        else:
            pythonpath.append(joinpath(pth_dir, line))
    config['module_search_paths'] = pythonpath
    config['module_search_paths_set'] = 1

# ******************************************************************************
# UPDATE config FROM CALCULATED VALUES
# ******************************************************************************

config['program_name'] = program_name
config['home'] = home
config['executable'] = executable
config['base_executable'] = base_executable
config['prefix'] = prefix
config['exec_prefix'] = exec_prefix
config['base_prefix'] = base_prefix
config['base_exec_prefix'] = base_exec_prefix

config['platlibdir'] = platlibdir
# test_embed expects empty strings, not None
config['stdlib_dir'] = stdlib_dir or ''
config['platstdlib_dir'] = platstdlib_dir or ''


================================================
File: /Modules/getpath_noop.c
================================================
/* Implements the getpath API for compiling with no functionality */

#include "Python.h"
#include "pycore_pathconfig.h"

PyStatus
_PyConfig_InitPathConfig(PyConfig *config, int compute_path_config)
{
    return PyStatus_Error("path configuration is unsupported");
}


================================================
File: /Modules/grpmodule.c
================================================
/* UNIX group file access module */

// Argument Clinic uses the internal C API
#ifndef Py_BUILD_CORE_BUILTIN
#  define Py_BUILD_CORE_MODULE 1
#endif

#include "Python.h"
#include "posixmodule.h"

#include <errno.h>                // ERANGE
#include <grp.h>                  // getgrgid_r()
#include <string.h>               // memcpy()
#include <unistd.h>               // sysconf()

#include "clinic/grpmodule.c.h"
/*[clinic input]
module grp
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=cade63f2ed1bd9f8]*/

static PyStructSequence_Field struct_group_type_fields[] = {
   {"gr_name", "group name"},
   {"gr_passwd", "password"},
   {"gr_gid", "group id"},
   {"gr_mem", "group members"},
   {0}
};

PyDoc_STRVAR(struct_group__doc__,
"grp.struct_group: Results from getgr*() routines.\n\n\
This object may be accessed either as a tuple of\n\
  (gr_name,gr_passwd,gr_gid,gr_mem)\n\
or via the object attributes as named in the above tuple.\n");

static PyStructSequence_Desc struct_group_type_desc = {
   "grp.struct_group",
   struct_group__doc__,
   struct_group_type_fields,
   4,
};


typedef struct {
  PyTypeObject *StructGrpType;
} grpmodulestate;

static inline grpmodulestate*
get_grp_state(PyObject *module)
{
    void *state = PyModule_GetState(module);
    assert(state != NULL);
    return (grpmodulestate *)state;
}

static struct PyModuleDef grpmodule;

#define DEFAULT_BUFFER_SIZE 1024

static PyObject *
mkgrent(PyObject *module, struct group *p)
{
    int setIndex = 0;
    PyObject *v, *w;
    char **member;

    v = PyStructSequence_New(get_grp_state(module)->StructGrpType);
    if (v == NULL)
        return NULL;

    if ((w = PyList_New(0)) == NULL) {
        Py_DECREF(v);
        return NULL;
    }
    for (member = p->gr_mem; ; member++) {
        char *group_member;
        // member can be misaligned
        memcpy(&group_member, member, sizeof(group_member));
        if (group_member == NULL) {
            break;
        }
        PyObject *x = PyUnicode_DecodeFSDefault(group_member);
        if (x == NULL || PyList_Append(w, x) != 0) {
            Py_XDECREF(x);
            Py_DECREF(w);
            Py_DECREF(v);
            return NULL;
        }
        Py_DECREF(x);
    }

#define SET(i,val) PyStructSequence_SetItem(v, i, val)
    SET(setIndex++, PyUnicode_DecodeFSDefault(p->gr_name));
    if (p->gr_passwd)
            SET(setIndex++, PyUnicode_DecodeFSDefault(p->gr_passwd));
    else {
            SET(setIndex++, Py_None);
            Py_INCREF(Py_None);
    }
    SET(setIndex++, _PyLong_FromGid(p->gr_gid));
    SET(setIndex++, w);
#undef SET

    if (PyErr_Occurred()) {
        Py_DECREF(v);
        return NULL;
    }

    return v;
}

/*[clinic input]
grp.getgrgid

    id: object

Return the group database entry for the given numeric group ID.

If id is not valid, raise KeyError.
[clinic start generated code]*/

static PyObject *
grp_getgrgid_impl(PyObject *module, PyObject *id)
/*[clinic end generated code: output=30797c289504a1ba input=15fa0e2ccf5cda25]*/
{
    PyObject *retval = NULL;
    int nomem = 0;
    char *buf = NULL, *buf2 = NULL;
    gid_t gid;
    struct group *p;

    if (!_Py_Gid_Converter(id, &gid)) {
        return NULL;
    }
#ifdef HAVE_GETGRGID_R
    int status;
    Py_ssize_t bufsize;
    /* Note: 'grp' will be used via pointer 'p' on getgrgid_r success. */
    struct group grp;

    Py_BEGIN_ALLOW_THREADS
    bufsize = sysconf(_SC_GETGR_R_SIZE_MAX);
    if (bufsize == -1) {
        bufsize = DEFAULT_BUFFER_SIZE;
    }

    while (1) {
        buf2 = PyMem_RawRealloc(buf, bufsize);
        if (buf2 == NULL) {
            p = NULL;
            nomem = 1;
            break;
        }
        buf = buf2;
        status = getgrgid_r(gid, &grp, buf, bufsize, &p);
        if (status != 0) {
            p = NULL;
        }
        if (p != NULL || status != ERANGE) {
            break;
        }
        if (bufsize > (PY_SSIZE_T_MAX >> 1)) {
            nomem = 1;
            break;
        }
        bufsize <<= 1;
    }

    Py_END_ALLOW_THREADS
#else
    p = getgrgid(gid);
#endif
    if (p == NULL) {
        PyMem_RawFree(buf);
        if (nomem == 1) {
            return PyErr_NoMemory();
        }
        PyObject *gid_obj = _PyLong_FromGid(gid);
        if (gid_obj == NULL)
            return NULL;
        PyErr_Format(PyExc_KeyError, "getgrgid(): gid not found: %S", gid_obj);
        Py_DECREF(gid_obj);
        return NULL;
    }
    retval = mkgrent(module, p);
#ifdef HAVE_GETGRGID_R
    PyMem_RawFree(buf);
#endif
    return retval;
}

/*[clinic input]
grp.getgrnam

    name: unicode

Return the group database entry for the given group name.

If name is not valid, raise KeyError.
[clinic start generated code]*/

static PyObject *
grp_getgrnam_impl(PyObject *module, PyObject *name)
/*[clinic end generated code: output=67905086f403c21c input=08ded29affa3c863]*/
{
    char *buf = NULL, *buf2 = NULL, *name_chars;
    int nomem = 0;
    struct group *p;
    PyObject *bytes, *retval = NULL;

    if ((bytes = PyUnicode_EncodeFSDefault(name)) == NULL)
        return NULL;
    /* check for embedded null bytes */
    if (PyBytes_AsStringAndSize(bytes, &name_chars, NULL) == -1)
        goto out;
#ifdef HAVE_GETGRNAM_R
    int status;
    Py_ssize_t bufsize;
    /* Note: 'grp' will be used via pointer 'p' on getgrnam_r success. */
    struct group grp;

    Py_BEGIN_ALLOW_THREADS
    bufsize = sysconf(_SC_GETGR_R_SIZE_MAX);
    if (bufsize == -1) {
        bufsize = DEFAULT_BUFFER_SIZE;
    }

    while(1) {
        buf2 = PyMem_RawRealloc(buf, bufsize);
        if (buf2 == NULL) {
            p = NULL;
            nomem = 1;
            break;
        }
        buf = buf2;
        status = getgrnam_r(name_chars, &grp, buf, bufsize, &p);
        if (status != 0) {
            p = NULL;
        }
        if (p != NULL || status != ERANGE) {
            break;
        }
        if (bufsize > (PY_SSIZE_T_MAX >> 1)) {
            nomem = 1;
            break;
        }
        bufsize <<= 1;
    }

    Py_END_ALLOW_THREADS
#else
    p = getgrnam(name_chars);
#endif
    if (p == NULL) {
        if (nomem == 1) {
            PyErr_NoMemory();
        }
        else {
            PyErr_Format(PyExc_KeyError, "getgrnam(): name not found: %R", name);
        }
        goto out;
    }
    retval = mkgrent(module, p);
out:
    PyMem_RawFree(buf);
    Py_DECREF(bytes);
    return retval;
}

/*[clinic input]
grp.getgrall

Return a list of all available group entries, in arbitrary order.

An entry whose name starts with '+' or '-' represents an instruction
to use YP/NIS and may not be accessible via getgrnam or getgrgid.
[clinic start generated code]*/

static PyObject *
grp_getgrall_impl(PyObject *module)
/*[clinic end generated code: output=585dad35e2e763d7 input=d7df76c825c367df]*/
{
    PyObject *d = PyList_New(0);
    if (d == NULL) {
        return NULL;
    }

    static PyMutex getgrall_mutex = {0};
    PyMutex_Lock(&getgrall_mutex);
    setgrent();

    struct group *p;
    while ((p = getgrent()) != NULL) {
        // gh-126316: Don't release the mutex around mkgrent() since
        // setgrent()/endgrent() are not reentrant / thread-safe. A deadlock
        // is unlikely since mkgrent() should not be able to call arbitrary
        // Python code.
        PyObject *v = mkgrent(module, p);
        if (v == NULL || PyList_Append(d, v) != 0) {
            Py_XDECREF(v);
            Py_CLEAR(d);
            goto done;
        }
        Py_DECREF(v);
    }

done:
    endgrent();
    PyMutex_Unlock(&getgrall_mutex);
    return d;
}

static PyMethodDef grp_methods[] = {
    GRP_GETGRGID_METHODDEF
    GRP_GETGRNAM_METHODDEF
    GRP_GETGRALL_METHODDEF
    {NULL, NULL}
};

PyDoc_STRVAR(grp__doc__,
"Access to the Unix group database.\n\
\n\
Group entries are reported as 4-tuples containing the following fields\n\
from the group database, in order:\n\
\n\
  gr_name   - name of the group\n\
  gr_passwd - group password (encrypted); often empty\n\
  gr_gid    - numeric ID of the group\n\
  gr_mem    - list of members\n\
\n\
The gid is an integer, name and password are strings.  (Note that most\n\
users are not explicitly listed as members of the groups they are in\n\
according to the password database.  Check both databases to get\n\
complete membership information.)");

static int
grpmodule_exec(PyObject *module)
{
    grpmodulestate *state = get_grp_state(module);

    state->StructGrpType = PyStructSequence_NewType(&struct_group_type_desc);
    if (state->StructGrpType == NULL) {
        return -1;
    }
    if (PyModule_AddType(module, state->StructGrpType) < 0) {
        return -1;
    }
    return 0;
}

static PyModuleDef_Slot grpmodule_slots[] = {
    {Py_mod_exec, grpmodule_exec},
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL}
};

static int grpmodule_traverse(PyObject *m, visitproc visit, void *arg) {
    Py_VISIT(get_grp_state(m)->StructGrpType);
    return 0;
}

static int grpmodule_clear(PyObject *m) {
    Py_CLEAR(get_grp_state(m)->StructGrpType);
    return 0;
}

static void grpmodule_free(void *m) {
    grpmodule_clear((PyObject *)m);
}

static struct PyModuleDef grpmodule = {
    PyModuleDef_HEAD_INIT,
    .m_name = "grp",
    .m_doc = grp__doc__,
    .m_size = sizeof(grpmodulestate),
    .m_methods = grp_methods,
    .m_slots = grpmodule_slots,
    .m_traverse = grpmodule_traverse,
    .m_clear = grpmodule_clear,
    .m_free = grpmodule_free,
};

PyMODINIT_FUNC
PyInit_grp(void)
{
   return PyModuleDef_Init(&grpmodule);
}


================================================
File: /Modules/hashlib.h
================================================
/* Common code for use by all hashlib related modules. */

#include "pycore_lock.h"        // PyMutex

/*
 * Given a PyObject* obj, fill in the Py_buffer* viewp with the result
 * of PyObject_GetBuffer.  Sets an exception and issues the erraction
 * on any errors, e.g. 'return NULL' or 'goto error'.
 */
#define GET_BUFFER_VIEW_OR_ERROR(obj, viewp, erraction) do { \
        if (PyUnicode_Check((obj))) { \
            PyErr_SetString(PyExc_TypeError, \
                            "Strings must be encoded before hashing");\
            erraction; \
        } \
        if (!PyObject_CheckBuffer((obj))) { \
            PyErr_SetString(PyExc_TypeError, \
                            "object supporting the buffer API required"); \
            erraction; \
        } \
        if (PyObject_GetBuffer((obj), (viewp), PyBUF_SIMPLE) == -1) { \
            erraction; \
        } \
        if ((viewp)->ndim > 1) { \
            PyErr_SetString(PyExc_BufferError, \
                            "Buffer must be single dimension"); \
            PyBuffer_Release((viewp)); \
            erraction; \
        } \
    } while(0)

#define GET_BUFFER_VIEW_OR_ERROUT(obj, viewp) \
    GET_BUFFER_VIEW_OR_ERROR(obj, viewp, return NULL)

/*
 * Helper code to synchronize access to the hash object when the GIL is
 * released around a CPU consuming hashlib operation. All code paths that
 * access a mutable part of obj must be enclosed in an ENTER_HASHLIB /
 * LEAVE_HASHLIB block or explicitly acquire and release the lock inside
 * a PY_BEGIN / END_ALLOW_THREADS block if they wish to release the GIL for
 * an operation.
 *
 * These only drop the GIL if the lock acquisition itself is likely to
 * block. Thus the non-blocking acquire gating the GIL release for a
 * blocking lock acquisition. The intent of these macros is to surround
 * the assumed always "fast" operations that you aren't releasing the
 * GIL around.  Otherwise use code similar to what you see in hash
 * function update() methods.
 */

#include "pythread.h"
#define ENTER_HASHLIB(obj) \
    if ((obj)->use_mutex) { \
        PyMutex_Lock(&(obj)->mutex); \
    }
#define LEAVE_HASHLIB(obj) \
    if ((obj)->use_mutex) { \
        PyMutex_Unlock(&(obj)->mutex); \
    }

#ifdef Py_GIL_DISABLED
#define HASHLIB_INIT_MUTEX(obj) \
    do { \
        (obj)->mutex = (PyMutex){0}; \
        (obj)->use_mutex = true; \
    } while (0)
#else
#define HASHLIB_INIT_MUTEX(obj) \
    do { \
        (obj)->mutex = (PyMutex){0}; \
        (obj)->use_mutex = false; \
    } while (0)
#endif

/* TODO(gpshead): We should make this a module or class attribute
 * to allow the user to optimize based on the platform they're using. */
#define HASHLIB_GIL_MINSIZE 2048



================================================
File: /Modules/ld_so_aix.in
================================================
#!/bin/sh
#
#   ========================================================================
#   FILE:           ld_so_aix
#   TYPE:           executable, uses makexp_aix
#   SYSTEM:         AIX
#
#   DESCRIPTION:    Creates a shareable .o from a set of pre-compiled
#                   (unshared) .o files
#
#   USAGE:          ld_so_aix [CC] [arguments]
#
#   ARGUMENTS:      Same as for "ld". The following arguments are processed
#                   or supplied by this script (those marked with an asterisk
#                   can be overridden from command line):
#
#                       Argument                     Default value
#                   (*) -o [OutputFileName]          -o shr.o
#                   (*) -e [EntryPointLabel]         -e init[OutputBaseName]
#                   (*) -bE:[ExportFile]             -bE:[OutputBaseName].exp
#                   (*) -bI:[ImportFile]             -bI:./python.exp
#                       -bM:[ModuleType]             -bM:SRE
#                       -bhalt:[Number]              -bhalt:4
#                       -T[Number]                   -T512
#                       -H[Number]                   -H512
#                       -lm
#
#                   The compiler specific ("-lc" or "-lc_r", "-lpthreads",...)
#                   arguments will be automatically passed to "ld" according
#                   to the CC command provided as a first argument to this
#                   script. Usually, the same CC command was used to produce
#                   the pre-compiled .o file(s).
#
#   NOTES:          1.  Since "ld_so_aix" was originally written for building
#                       shared modules for the Python interpreter, the -e and
#                       -bI default values match Python's conventions. In
#                       Python, the entry point for a shared module is based
#                       on the module's name (e.g., the "mathmodule" will
#                       expect an  entry point of "initmath").
#                   2.  The script accepts multiple .o or .a input files and
#                       creates a single (shared) output file. The export list
#                       that is created is based on the output file's basename
#                       with the suffix ".exp".
#                   3.  The resulting shared object file is left in the
#                       current directory.
#                   4.  Uncommenting the "echo" lines gives detailed output
#                       about the commands executed in the script.
#
#
#   HISTORY:        Oct-1996    -- Support added for multiple .o files --
#                               -- and optional arguments processing.  --
#                   Chris Myers (myers@tc.cornell.edu), Keith Kwok
#                   (kkwok@tc.cornell.edu) and Vladimir Marangozov
#
#                   Aug-6-1996  -- Take care of the compiler specific  --
#                               -- args by leaving CC to invoke "ld".  --
#                   Vladimir Marangozov
#
#                   Jul-1-1996  -- Make sure to use /usr/ccs/bin/ld    --
#                               -- Use makexp_aix for the export list. --
#                   Vladimir Marangozov     (Vladimir.Marangozov@imag.fr)
#
#                   Manus Hand (mhand@csn.net) -- Initial code -- 6/24/96
#   ========================================================================
#

usage="Usage: ld_so_aix [CC command] [ld arguments]"
if test ! -n "$*"; then
  echo $usage; exit 2
fi

makexp=`dirname $0`/makexp_aix
test -x "${makexp}" || makexp="@abs_srcdir@/makexp_aix"

# Check for existence of compiler.
CC=$1; shift
whichcc=`which $CC`

if test ! -x "$whichcc"; then
  echo "ld_so_aix: Compiler '$CC' not found; exiting."
  exit 2
fi

if test ! -n "$*"; then
  echo $usage; exit 2
fi

# Default import file for Python
# Can be overridden by providing a -bI: argument.
impfile="./python.exp"

# Parse arguments
while test -n "$1"
do
  case "$1" in
    -e | -Wl,-e)
        if test -z "$2"; then
	  echo "ld_so_aix: The -e flag needs a parameter; exiting."; exit 2
	else
	  shift; entry=$1
	fi
	;;
    -e* | -Wl,-e*)
	entry=`echo $1 | sed -e "s/-Wl,//" -e "s/-e//"`
	;;
    -o)
	if test -z "$2"; then
	  echo "ld_so_aix: The -o flag needs a parameter; exiting."; exit 2
	else
	  shift; objfile=$1
	fi
	;;
    -o*)
	objfile=`echo $1 | sed "s/-o//"`
	;;
    -bI:* | -Wl,-bI:*)
	impfile=`echo $1 | sed -e "s/-Wl,//" -e "s/-bI://"`
	;;
    -bE:* | -Wl,-bE:*)
	expfile=`echo $1 | sed -e "s/-Wl,//" -e "s/-bE://"`
	;;
    *.o | *.a)
	objs="$objs $1"
	args="$args $1"
	;;
    -bM:* | -Wl,-bM:* | -H* | -Wl,-H* | -T* | -Wl,-T* | -lm)
	;;
    *)
        args="$args $1"
	;;
  esac
  shift
done

if test "$objfile" = "libpython@VERSION@@ABIFLAGS@.so"; then
  ldsocoremode="true"
fi

if test -z "$objs"; then
  echo "ld_so_aix: No input files; exiting."
  exit 2
elif test ! -r "$impfile" -a -z "$ldsocoremode"; then
  echo "ld_so_aix: Import file '$impfile' not found or not readable; exiting."
  exit 2
fi

# If -o wasn't specified, assume "-o shr.o"
if test -z "$objfile"; then
  objfile=shr.o
fi

filename=`basename $objfile | sed "s/\.[^.]*$//"`

# If -bE: wasn't specified, assume "-bE:$filename.exp"
if test -z "$expfile"; then
  expfile="$filename.exp"
fi

# Default entry symbol for Python modules = init[modulename]
# Can be overridden by providing a -e argument.
if test -z "$entry"; then
  entry=PyInit_`echo $filename | sed "s/module.*//"`
fi

#echo "ld_so_aix: Debug info section"
#echo "  -> output file : $objfile"
#echo "  -> import file : $impfile"
#echo "  -> export file : $expfile"
#echo "  -> entry point : $entry"
#echo "  -> object files: $objs"
#echo "  -> CC arguments: $args"

if test -z "$ldsocoremode"; then
  CCOPT="-Wl,-e$entry -Wl,-bE:$expfile -Wl,-bI:$impfile -Wl,-bhalt:4"
else
  CCOPT="-Wl,-bnoentry -Wl,-bE:$expfile -Wl,-bhalt:4"
fi
CCOPT="$CCOPT -Wl,-bM:SRE -Wl,-T512 -Wl,-H512 -Wl,-brtl -Wl,-bnortllib -lm -o $objfile"

CCARGS="$args"

# Export list generation.
#echo $makexp $expfile "$objfile" $objs
$makexp $expfile "$objfile" $objs

# Perform the link.
#echo $CC $CCOPT $CCARGS
$CC $CCOPT $CCARGS
retval=$?

# Delete the module's export list file.
# Comment this line if you need it.
rm -f $expfile

exit $retval


================================================
File: /Modules/main.c
================================================
/* Python interpreter main program */

#include "Python.h"
#include "pycore_call.h"          // _PyObject_CallNoArgs()
#include "pycore_initconfig.h"    // _PyArgv
#include "pycore_interp.h"        // _PyInterpreterState.sysdict
#include "pycore_long.h"          // _PyLong_GetOne()
#include "pycore_pathconfig.h"    // _PyPathConfig_ComputeSysPath0()
#include "pycore_pylifecycle.h"   // _Py_PreInitializeFromPyArgv()
#include "pycore_pystate.h"       // _PyInterpreterState_GET()
#include "pycore_pythonrun.h"     // _PyRun_AnyFileObject()

/* Includes for exit_sigint() */
#include <stdio.h>                // perror()
#ifdef HAVE_SIGNAL_H
#  include <signal.h>             // SIGINT
#endif
#if defined(HAVE_GETPID) && defined(HAVE_UNISTD_H)
#  include <unistd.h>             // getpid()
#endif
#ifdef MS_WINDOWS
#  include <windows.h>            // STATUS_CONTROL_C_EXIT
#endif
/* End of includes for exit_sigint() */

#define COPYRIGHT \
    "Type \"help\", \"copyright\", \"credits\" or \"license\" " \
    "for more information."

/* --- pymain_init() ---------------------------------------------- */

static PyStatus
pymain_init(const _PyArgv *args)
{
    PyStatus status;

    status = _PyRuntime_Initialize();
    if (_PyStatus_EXCEPTION(status)) {
        return status;
    }

    PyPreConfig preconfig;
    PyPreConfig_InitPythonConfig(&preconfig);

    status = _Py_PreInitializeFromPyArgv(&preconfig, args);
    if (_PyStatus_EXCEPTION(status)) {
        return status;
    }

    PyConfig config;
    PyConfig_InitPythonConfig(&config);

    /* pass NULL as the config: config is read from command line arguments,
       environment variables, configuration files */
    if (args->use_bytes_argv) {
        status = PyConfig_SetBytesArgv(&config, args->argc, args->bytes_argv);
    }
    else {
        status = PyConfig_SetArgv(&config, args->argc, args->wchar_argv);
    }
    if (_PyStatus_EXCEPTION(status)) {
        goto done;
    }

    status = Py_InitializeFromConfig(&config);
    if (_PyStatus_EXCEPTION(status)) {
        goto done;
    }
    status = _PyStatus_OK();

done:
    PyConfig_Clear(&config);
    return status;
}


/* --- pymain_run_python() ---------------------------------------- */

/* Non-zero if filename, command (-c) or module (-m) is set
   on the command line */
static inline int config_run_code(const PyConfig *config)
{
    return (config->run_command != NULL
            || config->run_filename != NULL
            || config->run_module != NULL);
}


/* Return non-zero if stdin is a TTY or if -i command line option is used */
static int
stdin_is_interactive(const PyConfig *config)
{
    return (isatty(fileno(stdin)) || config->interactive);
}


/* Display the current Python exception and return an exitcode */
static int
pymain_err_print(int *exitcode_p)
{
    int exitcode;
    if (_Py_HandleSystemExit(&exitcode)) {
        *exitcode_p = exitcode;
        return 1;
    }

    PyErr_Print();
    return 0;
}


static int
pymain_exit_err_print(void)
{
    int exitcode = 1;
    pymain_err_print(&exitcode);
    return exitcode;
}


/* Write an exitcode into *exitcode and return 1 if we have to exit Python.
   Return 0 otherwise. */
static int
pymain_get_importer(const wchar_t *filename, PyObject **importer_p, int *exitcode)
{
    PyObject *sys_path0 = NULL, *importer;

    sys_path0 = PyUnicode_FromWideChar(filename, wcslen(filename));
    if (sys_path0 == NULL) {
        goto error;
    }

    importer = PyImport_GetImporter(sys_path0);
    if (importer == NULL) {
        goto error;
    }

    if (importer == Py_None) {
        Py_DECREF(sys_path0);
        Py_DECREF(importer);
        return 0;
    }

    Py_DECREF(importer);
    *importer_p = sys_path0;
    return 0;

error:
    Py_XDECREF(sys_path0);

    PySys_WriteStderr("Failed checking if argv[0] is an import path entry\n");
    return pymain_err_print(exitcode);
}


static int
pymain_sys_path_add_path0(PyInterpreterState *interp, PyObject *path0)
{
    PyObject *sys_path;
    PyObject *sysdict = interp->sysdict;
    if (sysdict != NULL) {
        sys_path = PyDict_GetItemWithError(sysdict, &_Py_ID(path));
        if (sys_path == NULL && PyErr_Occurred()) {
            return -1;
        }
    }
    else {
        sys_path = NULL;
    }
    if (sys_path == NULL) {
        PyErr_SetString(PyExc_RuntimeError, "unable to get sys.path");
        return -1;
    }

    if (PyList_Insert(sys_path, 0, path0)) {
        return -1;
    }
    return 0;
}


static void
pymain_header(const PyConfig *config)
{
    if (config->quiet) {
        return;
    }

    if (!config->verbose && (config_run_code(config) || !stdin_is_interactive(config))) {
        return;
    }

    fprintf(stderr, "Python %s on %s\n", Py_GetVersion(), Py_GetPlatform());
    if (config->site_import) {
        fprintf(stderr, "%s\n", COPYRIGHT);
    }
}


static void
pymain_import_readline(const PyConfig *config)
{
    if (config->isolated) {
        return;
    }
    if (!config->inspect && config_run_code(config)) {
        return;
    }
    if (!isatty(fileno(stdin))) {
        return;
    }

    PyObject *mod = PyImport_ImportModule("readline");
    if (mod == NULL) {
        PyErr_Clear();
    }
    else {
        Py_DECREF(mod);
    }
    mod = PyImport_ImportModule("rlcompleter");
    if (mod == NULL) {
        PyErr_Clear();
    }
    else {
        Py_DECREF(mod);
    }
}


static int
pymain_run_command(wchar_t *command)
{
    PyObject *unicode, *bytes;
    int ret;

    unicode = PyUnicode_FromWideChar(command, -1);
    if (unicode == NULL) {
        goto error;
    }

    if (PySys_Audit("cpython.run_command", "O", unicode) < 0) {
        return pymain_exit_err_print();
    }

    bytes = PyUnicode_AsUTF8String(unicode);
    Py_DECREF(unicode);
    if (bytes == NULL) {
        goto error;
    }

    PyCompilerFlags cf = _PyCompilerFlags_INIT;
    cf.cf_flags |= PyCF_IGNORE_COOKIE;
    ret = _PyRun_SimpleStringFlagsWithName(PyBytes_AsString(bytes), "<string>", &cf);
    Py_DECREF(bytes);
    return (ret != 0);

error:
    PySys_WriteStderr("Unable to decode the command from the command line:\n");
    return pymain_exit_err_print();
}


static int
pymain_start_pyrepl_no_main(void)
{
    int res = 0;
    PyObject *console = NULL;
    PyObject *empty_tuple = NULL;
    PyObject *kwargs = NULL;
    PyObject *console_result = NULL;

    PyObject *pyrepl = PyImport_ImportModule("_pyrepl.main");
    if (pyrepl == NULL) {
        fprintf(stderr, "Could not import _pyrepl.main\n");
        res = pymain_exit_err_print();
        goto done;
    }
    console = PyObject_GetAttrString(pyrepl, "interactive_console");
    if (console == NULL) {
        fprintf(stderr, "Could not access _pyrepl.main.interactive_console\n");
        res = pymain_exit_err_print();
        goto done;
    }
    empty_tuple = PyTuple_New(0);
    if (empty_tuple == NULL) {
        res = pymain_exit_err_print();
        goto done;
    }
    kwargs = PyDict_New();
    if (kwargs == NULL) {
        res = pymain_exit_err_print();
        goto done;
    }
    if (!PyDict_SetItemString(kwargs, "pythonstartup", _PyLong_GetOne())) {
        _PyRuntime.signals.unhandled_keyboard_interrupt = 0;
        console_result = PyObject_Call(console, empty_tuple, kwargs);
        if (!console_result && PyErr_Occurred() == PyExc_KeyboardInterrupt) {
            _PyRuntime.signals.unhandled_keyboard_interrupt = 1;
        }
        if (console_result == NULL) {
            res = pymain_exit_err_print();
        }
    }
done:
    Py_XDECREF(console_result);
    Py_XDECREF(kwargs);
    Py_XDECREF(empty_tuple);
    Py_XDECREF(console);
    Py_XDECREF(pyrepl);
    return res;
}


static int
pymain_run_module(const wchar_t *modname, int set_argv0)
{
    PyObject *module, *runpy, *runmodule, *runargs, *result;
    if (PySys_Audit("cpython.run_module", "u", modname) < 0) {
        return pymain_exit_err_print();
    }
    runpy = PyImport_ImportModule("runpy");
    if (runpy == NULL) {
        fprintf(stderr, "Could not import runpy module\n");
        return pymain_exit_err_print();
    }
    runmodule = PyObject_GetAttrString(runpy, "_run_module_as_main");
    if (runmodule == NULL) {
        fprintf(stderr, "Could not access runpy._run_module_as_main\n");
        Py_DECREF(runpy);
        return pymain_exit_err_print();
    }
    module = PyUnicode_FromWideChar(modname, wcslen(modname));
    if (module == NULL) {
        fprintf(stderr, "Could not convert module name to unicode\n");
        Py_DECREF(runpy);
        Py_DECREF(runmodule);
        return pymain_exit_err_print();
    }
    runargs = PyTuple_Pack(2, module, set_argv0 ? Py_True : Py_False);
    if (runargs == NULL) {
        fprintf(stderr,
            "Could not create arguments for runpy._run_module_as_main\n");
        Py_DECREF(runpy);
        Py_DECREF(runmodule);
        Py_DECREF(module);
        return pymain_exit_err_print();
    }
    _PyRuntime.signals.unhandled_keyboard_interrupt = 0;
    result = PyObject_Call(runmodule, runargs, NULL);
    if (!result && PyErr_Occurred() == PyExc_KeyboardInterrupt) {
        _PyRuntime.signals.unhandled_keyboard_interrupt = 1;
    }
    Py_DECREF(runpy);
    Py_DECREF(runmodule);
    Py_DECREF(module);
    Py_DECREF(runargs);
    if (result == NULL) {
        return pymain_exit_err_print();
    }
    Py_DECREF(result);
    return 0;
}


static int
pymain_run_file_obj(PyObject *program_name, PyObject *filename,
                    int skip_source_first_line)
{
    if (PySys_Audit("cpython.run_file", "O", filename) < 0) {
        return pymain_exit_err_print();
    }

    FILE *fp = Py_fopen(filename, "rb");
    if (fp == NULL) {
        // Ignore the OSError
        PyErr_Clear();
        // TODO(picnixz): strerror() is locale dependent but not PySys_FormatStderr().
        PySys_FormatStderr("%S: can't open file %R: [Errno %d] %s\n",
                           program_name, filename, errno, strerror(errno));
        return 2;
    }

    if (skip_source_first_line) {
        int ch;
        /* Push back first newline so line numbers remain the same */
        while ((ch = getc(fp)) != EOF) {
            if (ch == '\n') {
                (void)ungetc(ch, fp);
                break;
            }
        }
    }

    struct _Py_stat_struct sb;
    if (_Py_fstat_noraise(fileno(fp), &sb) == 0 && S_ISDIR(sb.st_mode)) {
        PySys_FormatStderr("%S: %R is a directory, cannot continue\n",
                           program_name, filename);
        fclose(fp);
        return 1;
    }

    // Call pending calls like signal handlers (SIGINT)
    if (Py_MakePendingCalls() == -1) {
        fclose(fp);
        return pymain_exit_err_print();
    }

    /* PyRun_AnyFileExFlags(closeit=1) calls fclose(fp) before running code */
    PyCompilerFlags cf = _PyCompilerFlags_INIT;
    int run = _PyRun_AnyFileObject(fp, filename, 1, &cf);
    return (run != 0);
}

static int
pymain_run_file(const PyConfig *config)
{
    PyObject *filename = PyUnicode_FromWideChar(config->run_filename, -1);
    if (filename == NULL) {
        PyErr_Print();
        return -1;
    }
    PyObject *program_name = PyUnicode_FromWideChar(config->program_name, -1);
    if (program_name == NULL) {
        Py_DECREF(filename);
        PyErr_Print();
        return -1;
    }

    int res = pymain_run_file_obj(program_name, filename,
                                  config->skip_source_first_line);
    Py_DECREF(filename);
    Py_DECREF(program_name);
    return res;
}


static int
pymain_run_startup(PyConfig *config, int *exitcode)
{
    int ret;
    if (!config->use_environment) {
        return 0;
    }
    PyObject *startup = NULL;
#ifdef MS_WINDOWS
    const wchar_t *env = _wgetenv(L"PYTHONSTARTUP");
    if (env == NULL || env[0] == L'\0') {
        return 0;
    }
    startup = PyUnicode_FromWideChar(env, wcslen(env));
    if (startup == NULL) {
        goto error;
    }
#else
    const char *env = _Py_GetEnv(config->use_environment, "PYTHONSTARTUP");
    if (env == NULL) {
        return 0;
    }
    startup = PyUnicode_DecodeFSDefault(env);
    if (startup == NULL) {
        goto error;
    }
#endif
    if (PySys_Audit("cpython.run_startup", "O", startup) < 0) {
        goto error;
    }

    FILE *fp = Py_fopen(startup, "r");
    if (fp == NULL) {
        int save_errno = errno;
        PyErr_Clear();
        PySys_WriteStderr("Could not open PYTHONSTARTUP\n");

        errno = save_errno;
        PyErr_SetFromErrnoWithFilenameObjects(PyExc_OSError, startup, NULL);
        goto error;
    }

    PyCompilerFlags cf = _PyCompilerFlags_INIT;
    (void) _PyRun_SimpleFileObject(fp, startup, 0, &cf);
    PyErr_Clear();
    fclose(fp);
    ret = 0;

done:
    Py_XDECREF(startup);
    return ret;

error:
    ret = pymain_err_print(exitcode);
    goto done;
}


/* Write an exitcode into *exitcode and return 1 if we have to exit Python.
   Return 0 otherwise. */
static int
pymain_run_interactive_hook(int *exitcode)
{
    PyObject *sys, *hook, *result;
    sys = PyImport_ImportModule("sys");
    if (sys == NULL) {
        goto error;
    }

    hook = PyObject_GetAttrString(sys, "__interactivehook__");
    Py_DECREF(sys);
    if (hook == NULL) {
        PyErr_Clear();
        return 0;
    }

    if (PySys_Audit("cpython.run_interactivehook", "O", hook) < 0) {
        goto error;
    }

    result = _PyObject_CallNoArgs(hook);
    Py_DECREF(hook);
    if (result == NULL) {
        goto error;
    }
    Py_DECREF(result);

    return 0;

error:
    PySys_WriteStderr("Failed calling sys.__interactivehook__\n");
    return pymain_err_print(exitcode);
}


static void
pymain_set_inspect(PyConfig *config, int inspect)
{
    config->inspect = inspect;
_Py_COMP_DIAG_PUSH
_Py_COMP_DIAG_IGNORE_DEPR_DECLS
    Py_InspectFlag = inspect;
_Py_COMP_DIAG_POP
}


static int
pymain_run_stdin(PyConfig *config)
{
    if (stdin_is_interactive(config)) {
        // do exit on SystemExit
        pymain_set_inspect(config, 0);

        int exitcode;
        if (pymain_run_startup(config, &exitcode)) {
            return exitcode;
        }

        if (pymain_run_interactive_hook(&exitcode)) {
            return exitcode;
        }
    }

    /* call pending calls like signal handlers (SIGINT) */
    if (Py_MakePendingCalls() == -1) {
        return pymain_exit_err_print();
    }

    if (PySys_Audit("cpython.run_stdin", NULL) < 0) {
        return pymain_exit_err_print();
    }

    if (!isatty(fileno(stdin))
        || _Py_GetEnv(config->use_environment, "PYTHON_BASIC_REPL")) {
        PyCompilerFlags cf = _PyCompilerFlags_INIT;
        int run = PyRun_AnyFileExFlags(stdin, "<stdin>", 0, &cf);
        return (run != 0);
    }
    int run = pymain_run_module(L"_pyrepl", 0);
    return (run != 0);
}


static void
pymain_repl(PyConfig *config, int *exitcode)
{
    /* Check this environment variable at the end, to give programs the
       opportunity to set it from Python. */
    if (!config->inspect && _Py_GetEnv(config->use_environment, "PYTHONINSPECT")) {
        pymain_set_inspect(config, 1);
    }

    if (!(config->inspect && stdin_is_interactive(config) && config_run_code(config))) {
        return;
    }

    pymain_set_inspect(config, 0);
    if (pymain_run_interactive_hook(exitcode)) {
        return;
    }

    if (PySys_Audit("cpython.run_stdin", NULL) < 0) {
        return;
    }

    if (!isatty(fileno(stdin))
        || _Py_GetEnv(config->use_environment, "PYTHON_BASIC_REPL")) {
        PyCompilerFlags cf = _PyCompilerFlags_INIT;
        int run = PyRun_AnyFileExFlags(stdin, "<stdin>", 0, &cf);
        *exitcode = (run != 0);
        return;
    }
    int run = pymain_start_pyrepl_no_main();
    *exitcode = (run != 0);
    return;
}


static void
pymain_run_python(int *exitcode)
{
    PyObject *main_importer_path = NULL;
    PyInterpreterState *interp = _PyInterpreterState_GET();
    /* pymain_run_stdin() modify the config */
    PyConfig *config = (PyConfig*)_PyInterpreterState_GetConfig(interp);

    /* ensure path config is written into global variables */
    if (_PyStatus_EXCEPTION(_PyPathConfig_UpdateGlobal(config))) {
        goto error;
    }

    // XXX Calculate config->sys_path_0 in getpath.py.
    // The tricky part is that we can't check the path importers yet
    // at that point.
    assert(config->sys_path_0 == NULL);

    if (config->run_filename != NULL) {
        /* If filename is a package (ex: directory or ZIP file) which contains
           __main__.py, main_importer_path is set to filename and will be
           prepended to sys.path.

           Otherwise, main_importer_path is left unchanged. */
        if (pymain_get_importer(config->run_filename, &main_importer_path,
                                exitcode)) {
            return;
        }
    }

    // import readline and rlcompleter before script dir is added to sys.path
    pymain_import_readline(config);

    PyObject *path0 = NULL;
    if (main_importer_path != NULL) {
        path0 = Py_NewRef(main_importer_path);
    }
    else if (!config->safe_path) {
        int res = _PyPathConfig_ComputeSysPath0(&config->argv, &path0);
        if (res < 0) {
            goto error;
        }
        else if (res == 0) {
            Py_CLEAR(path0);
        }
    }
    // XXX Apply config->sys_path_0 in init_interp_main().  We have
    // to be sure to get readline/rlcompleter imported at the correct time.
    if (path0 != NULL) {
        wchar_t *wstr = PyUnicode_AsWideCharString(path0, NULL);
        if (wstr == NULL) {
            Py_DECREF(path0);
            goto error;
        }
        config->sys_path_0 = _PyMem_RawWcsdup(wstr);
        PyMem_Free(wstr);
        if (config->sys_path_0 == NULL) {
            Py_DECREF(path0);
            goto error;
        }
        int res = pymain_sys_path_add_path0(interp, path0);
        Py_DECREF(path0);
        if (res < 0) {
            goto error;
        }
    }

    pymain_header(config);

    _PyInterpreterState_SetRunningMain(interp);
    assert(!PyErr_Occurred());

    if (config->run_command) {
        *exitcode = pymain_run_command(config->run_command);
    }
    else if (config->run_module) {
        *exitcode = pymain_run_module(config->run_module, 1);
    }
    else if (main_importer_path != NULL) {
        *exitcode = pymain_run_module(L"__main__", 0);
    }
    else if (config->run_filename != NULL) {
        *exitcode = pymain_run_file(config);
    }
    else {
        *exitcode = pymain_run_stdin(config);
    }

    pymain_repl(config, exitcode);
    goto done;

error:
    *exitcode = pymain_exit_err_print();

done:
    _PyInterpreterState_SetNotRunningMain(interp);
    Py_XDECREF(main_importer_path);
}


/* --- pymain_main() ---------------------------------------------- */

static void
pymain_free(void)
{
    _PyImport_Fini2();

    /* Free global variables which cannot be freed in Py_Finalize():
       configuration options set before Py_Initialize() which should
       remain valid after Py_Finalize(), since
       Py_Initialize()-Py_Finalize() can be called multiple times. */
    _PyPathConfig_ClearGlobal();
    _Py_ClearArgcArgv();
    _PyRuntime_Finalize();
}


static int
exit_sigint(void)
{
    /* bpo-1054041: We need to exit via the
     * SIG_DFL handler for SIGINT if KeyboardInterrupt went unhandled.
     * If we don't, a calling process such as a shell may not know
     * about the user's ^C.  https://www.cons.org/cracauer/sigint.html */
#if defined(HAVE_GETPID) && defined(HAVE_KILL) && !defined(MS_WINDOWS)
    if (PyOS_setsig(SIGINT, SIG_DFL) == SIG_ERR) {
        perror("signal");  /* Impossible in normal environments. */
    } else {
        kill(getpid(), SIGINT);
    }
    /* If setting SIG_DFL failed, or kill failed to terminate us,
     * there isn't much else we can do aside from an error code. */
#endif  /* HAVE_GETPID && !MS_WINDOWS */
#ifdef MS_WINDOWS
    /* cmd.exe detects this, prints ^C, and offers to terminate. */
    /* https://msdn.microsoft.com/en-us/library/cc704588.aspx */
    return STATUS_CONTROL_C_EXIT;
#else
    return SIGINT + 128;
#endif  /* !MS_WINDOWS */
}


static void _Py_NO_RETURN
pymain_exit_error(PyStatus status)
{
    if (_PyStatus_IS_EXIT(status)) {
        /* If it's an error rather than a regular exit, leave Python runtime
           alive: Py_ExitStatusException() uses the current exception and use
           sys.stdout in this case. */
        pymain_free();
    }
    Py_ExitStatusException(status);
}


int
Py_RunMain(void)
{
    int exitcode = 0;

    pymain_run_python(&exitcode);

    if (Py_FinalizeEx() < 0) {
        /* Value unlikely to be confused with a non-error exit status or
           other special meaning */
        exitcode = 120;
    }

    pymain_free();

    if (_PyRuntime.signals.unhandled_keyboard_interrupt) {
        exitcode = exit_sigint();
    }

    return exitcode;
}


static int
pymain_main(_PyArgv *args)
{
    PyStatus status = pymain_init(args);
    if (_PyStatus_IS_EXIT(status)) {
        pymain_free();
        return status.exitcode;
    }
    if (_PyStatus_EXCEPTION(status)) {
        pymain_exit_error(status);
    }

    return Py_RunMain();
}


int
Py_Main(int argc, wchar_t **argv)
{
    _PyArgv args = {
        .argc = argc,
        .use_bytes_argv = 0,
        .bytes_argv = NULL,
        .wchar_argv = argv};
    return pymain_main(&args);
}


int
Py_BytesMain(int argc, char **argv)
{
    _PyArgv args = {
        .argc = argc,
        .use_bytes_argv = 1,
        .bytes_argv = argv,
        .wchar_argv = NULL};
    return pymain_main(&args);
}


================================================
File: /Modules/makesetup
================================================
#! /bin/sh
set -e

# Convert templates into Makefile and config.c, based on the module
# definitions found in the file Setup.
#
# Usage: makesetup [-s dir] [-c file] [-m file] [Setup] ... [-n [Setup] ...]
#
# Options:
# -s directory: alternative source directory (default .)
# -l directory: library source directory (default derived from $0)
# -c file:      alternative config.c template (default $libdir/config.c.in)
# -c -:         don't write config.c
# -m file:      alternative Makefile template (default ./Makefile.pre)
# -m -:         don't write Makefile
#
# Remaining arguments are one or more Setup files (default ./Setup).
# Setup files after a -n option are used for their variables, modules
# and libraries but not for their .o files.
#
# See Setup for a description of the format of the Setup file.
#
# The following edits are made:
#
# Copying config.c.in to config.c:
# - insert an identifying comment at the start
# - for each <module> mentioned in Setup before *noconfig*:
#   + insert 'extern PyObject* PyInit_<module>(void);' before MARKER 1
#   + insert '{"<module>", PyInit_<module>},' before MARKER 2
#
# Copying Makefile.pre to Makefile:
# - insert an identifying comment at the start
# - replace _MODBUILT_NAMES_ by the list of *static* and *shared* modules
#   from Setup
# - replace _MODBSHARED_NAMES_ by the list of *shared* modules from Setup
# - replace _MODDISABLED_NAMES_ by the list of *disabled* modules from Setup
# - replace _MODOBJS_ by the list of objects from Setup (except for
#   Setup files after a -n option)
# - replace _MODLIBS_ by the list of libraries from Setup
# - for each object file mentioned in Setup, append a rule
#   '<file>.o: <file>.c; <build commands>' to the end of the Makefile
# - for each module mentioned in Setup, append a rule
#   which creates a shared library version to the end of the Makefile
# - for each variable definition found in Setup, insert the definition
#   before the comment 'Definitions added by makesetup'

# Loop over command line options
usage='
usage: makesetup [-s srcdir] [-l libdir] [-c config.c.in] [-m Makefile.pre]
                 [Setup] ... [-n [Setup] ...]'
srcdir='.'
libdir=''
config=''
makepre=''
noobjects=''
doconfig=yes
while :
do
	case $1 in
	-s)	shift; srcdir=$1; shift;;
	-l)	shift; libdir=$1; shift;;
	-c)	shift; config=$1; shift;;
	-m)	shift; makepre=$1; shift;;
	--)	shift; break;;
	-n)	noobjects=yes;;
	-*)	echo "$usage" 1>&2; exit 2;;
	*)	break;;
	esac
done

# Set default libdir and config if not set by command line
# (Not all systems have dirname)
case $libdir in
'')	case $0 in
	*/*)	libdir=`echo $0 | sed 's,/[^/]*$,,'`;;
	*)	libdir=.;;
	esac;;
esac
case $config in
'')	config=$libdir/config.c.in;;
esac
case $makepre in
'')	makepre=Makefile.pre;;
esac

# Newline for sed i and a commands
NL='\
'

# Main loop
for i in ${*-Setup}
do
	case $i in
	-n)	echo '*noobjects*';;
	*)	echo '*doconfig*'; cat "$i";;
	esac
done |
sed -e 's/[ 	]*#.*//' -e '/^[ 	]*$/d' |
(
	rulesf="@rules.$$"
	trap 'rm -f $rulesf' 0 1 2 3
	echo "
# Rules appended by makesetup
" >$rulesf
	DEFS=
	BUILT=
	BUILT_SHARED=
	DISABLED=
	CONFIGURED=
	MODS=
	SHAREDMODS=
	OBJS=
	LIBS=
	LOCALLIBS=
	BASELIBS=
	while read line
	do
		# to handle backslashes for sh's that don't automatically
		# continue a read when the last char is a backslash
		while echo $line | grep '\\$' > /dev/null
		do
			read extraline
			line=`echo $line| sed s/.$//`$extraline
		done

		# Output DEFS in reverse order so first definition overrides
		case $line in
		*=*)	DEFS="$line$NL$DEFS"; continue;;
		'include '*)	DEFS="$line$NL$DEFS"; continue;;
		'*noobjects*')
			case $noobjects in
			yes)	;;
			*)	LOCALLIBS=$LIBS; LIBS=;;
			esac
			noobjects=yes;
			continue;;
		'*doconfig*')	doconfig=yes; continue;;
		'*static*')	doconfig=yes; continue;;
		'*noconfig*')	doconfig=no; continue;;
		'*shared*')	doconfig=no; continue;;
		'*disabled*')	doconfig=disabled; continue;;
		esac
		srcs=
		cpps=
		libs=
		mods=
		mods_upper=
		skip=
		for arg in $line
		do
			case $skip in
			libs)	libs="$libs $arg"; skip=; continue;;
			cpps)	cpps="$cpps $arg"; skip=; continue;;
			srcs)	srcs="$srcs $arg"; skip=; continue;;
			esac
			case $arg in
			-framework)	libs="$libs $arg"; skip=libs;
				        # OSX/OSXS/Darwin framework link cmd
					;;
			-[IDUCfF]*)	cpps="$cpps $arg";;
			-Xcompiler)	skip=cpps;;
			-Xlinker)	libs="$libs $arg"; skip=libs;;
			-rpath)		libs="$libs $arg"; skip=libs;;
			--rpath)	libs="$libs $arg"; skip=libs;;
			-[A-Zl]*)	libs="$libs $arg";;
			*.a)		libs="$libs $arg";;
			*.so)		libs="$libs $arg";;
			*.sl)		libs="$libs $arg";;
			/*.o)		libs="$libs $arg";;
			*.def)		libs="$libs $arg";;
			*.o)		srcs="$srcs `basename $arg .o`.c";;
			*.[cC])		srcs="$srcs $arg";;
			*.m)		srcs="$srcs $arg";; # Objective-C src
			*.cc)		srcs="$srcs $arg";;
			*.c++)		srcs="$srcs $arg";;
			*.cxx)		srcs="$srcs $arg";;
			*.cpp)		srcs="$srcs $arg";;
			\$\(*_CFLAGS\))		cpps="$cpps $arg";;
			\$\(*_INCLUDES\))	cpps="$cpps $arg";;
			\$\(*_LIBS\))		libs="$libs $arg";;
			\$\(*_LDFLAGS\))	libs="$libs $arg";;
			\$\(*_RPATH\))		libs="$libs $arg";;
			\$*)		libs="$libs $arg"
					cpps="$cpps $arg";;
			*.*)		echo 1>&2 "bad word $arg in $line"
					exit 1;;
			-u)		skip=libs; libs="$libs -u";;
			[a-zA-Z_]*)
					mods="$mods $arg"
					mods_upper=$(echo $mods | tr '[a-z]' '[A-Z]');;
			*)		echo 1>&2 "bad word $arg in $line"
					exit 1;;
			esac
		done
		if test -z "$cpps" -a -z "$libs"; then
			cpps="\$(MODULE_${mods_upper}_CFLAGS)"
			libs="\$(MODULE_${mods_upper}_LDFLAGS)"
		fi
		for mod in $mods
		do
			case $CONFIGURED in
			*,${mod},*)
				# Detected multiple rules for a module, first rule wins. This
				# allows users to disable modules in Setup.local.
				echo 1>&2 "maksetup: '$mod' was handled by previous rule."
				continue 2;;
			esac
			CONFIGURED="$CONFIGURED,${mod},"
		done
		case $doconfig in
		yes)
			LIBS="$LIBS $libs"
			MODS="$MODS $mods"
			BUILT="$BUILT $mods"
			;;
		no)
			BUILT="$BUILT $mods"
			;;
		disabled)
			DISABLED="$DISABLED $mods"
			continue
			;;
		esac
		case $noobjects in
		yes)	continue;;
		esac
		objs=''
		for src in $srcs
		do
			case $src in
			*.c)   obj=`basename $src .c`.o; cc='$(CC)';;
			*.cc)  obj=`basename $src .cc`.o; cc='$(CXX)';;
			*.c++) obj=`basename $src .c++`.o; cc='$(CXX)';;
			*.C)   obj=`basename $src .C`.o; cc='$(CXX)';;
			*.cxx) obj=`basename $src .cxx`.o; cc='$(CXX)';;
			*.cpp) obj=`basename $src .cpp`.o; cc='$(CXX)';;
			*.m)   obj=`basename $src .m`.o; cc='$(CC)';; # Obj-C
			*)     continue;;
			esac
			case $src in
			*/*) obj="$srcdir/`dirname $src`/$obj";;
			*)   obj="$srcdir/$obj";;
			esac
			objs="$objs $obj"
			case $src in
			glmodule.c) ;;
			/*) ;;
			\$*) ;;
			*) src='$(srcdir)/'"$srcdir/$src";;
			esac
			# custom flags first, PY_STDMODULE_CFLAGS may contain -I with system libmpdec
			case $doconfig in
			no)
				cc="$cc $cpps \$(PY_STDMODULE_CFLAGS) \$(CCSHARED)"
				rule="$obj: $src \$(MODULE_${mods_upper}_DEPS) \$(MODULE_DEPS_SHARED) \$(PYTHON_HEADERS); $cc -c $src -o $obj"
				;;
			*)
				cc="$cc $cpps \$(PY_BUILTIN_MODULE_CFLAGS)"
				rule="$obj: $src \$(MODULE_${mods_upper}_DEPS) \$(MODULE_DEPS_STATIC) \$(PYTHON_HEADERS); $cc -c $src -o $obj"
				;;
			esac
			echo "$rule" >>$rulesf
		done
		case $doconfig in
		yes)	OBJS="$OBJS $objs";;
		esac
		for mod in $mods
		do
			file="$srcdir/$mod\$(EXT_SUFFIX)"
			case $doconfig in
			no)
				SHAREDMODS="$SHAREDMODS $file"
				BUILT_SHARED="$BUILT_SHARED $mod"
				;;
			esac
			rule="$file: $objs"
			rule="$rule; \$(BLDSHARED) $objs $libs \$(LIBPYTHON) -o $file"
			echo "$rule" >>$rulesf
		done
	done

	case $SHAREDMODS in
	'')	;;
	*)	DEFS="SHAREDMODS=$SHAREDMODS$NL$DEFS";;
	esac

	case $noobjects in
	yes)	BASELIBS=$LIBS;;
	*)	LOCALLIBS=$LIBS;;
	esac
	LIBS='$(LOCALMODLIBS) $(BASEMODLIBS)'
	DEFS="BASEMODLIBS=$BASELIBS$NL$DEFS"
	DEFS="LOCALMODLIBS=$LOCALLIBS$NL$DEFS"

	EXTDECLS=
	INITBITS=
	for mod in $MODS
	do
		EXTDECLS="${EXTDECLS}extern PyObject* PyInit_$mod(void);$NL"
		INITBITS="${INITBITS}    {\"$mod\", PyInit_$mod},$NL"
	done


	case $config in
	-)  ;;
	*)  sed -e "
		1i$NL/* Generated automatically from $config by makesetup. */
		/MARKER 1/i$NL$EXTDECLS

		/MARKER 2/i$NL$INITBITS

		" $config >config.c
	    ;;
	esac

	case $makepre in
	-)	;;
	*)
		# macOS' sed has issues with 'a' command. Use 'r' command with an
		# external replacement file instead.
		sedf="@sed.in.$$"
		sedr="@sed.replace.$$"
		trap 'rm -f $sedf $sedr' 0 1 2 3
		echo "$NL$NL$DEFS" | sed 's/\\$//' > $sedr
		echo "1i\\" >$sedf
		str="# Generated automatically from $makepre by makesetup."
		echo "$str" >>$sedf
		echo "s%_MODBUILT_NAMES_%$BUILT%" >>$sedf
		echo "s%_MODSHARED_NAMES_%$BUILT_SHARED%" >>$sedf
		echo "s%_MODDISABLED_NAMES_%$DISABLED%" >>$sedf
		echo "s%_MODOBJS_%$OBJS%" >>$sedf
		echo "s%_MODLIBS_%$LIBS%" >>$sedf
		echo "/Definitions added by makesetup/r $sedr" >>$sedf
		sed -f $sedf $makepre >Makefile
		cat $rulesf >>Makefile
		rm -f $sedf $sedr
	    ;;
	esac

	rm -f $rulesf
)


================================================
File: /Modules/makexp_aix
================================================
#!/bin/sh
#
# ===========================================================================
# FILE:         makexp_aix
# TYPE:         standalone executable
# SYSTEM:	    AIX
#
# DESCRIPTION:  This script creates an export list of ALL global symbols
#               from a list of object or archive files.
#
# USAGE:        makexp_aix <OutputFile> "<FirstLine>" <InputFile> ...
#
#               where:
#                      <OutputFile> is the target export list filename.
#                      <FirstLine> is the path/file string to be appended
#                         after the "#!" symbols in the first line of the
#                         export file. Passing "" means deferred resolution.
#                      <InputFile> is an object (.o) or an archive file (.a).
#
# HISTORY:
#		3-Apr-1998  -- remove C++ entries of the form Class::method
#		Vladimir Marangozov
#
#               1-Jul-1996  -- added header information
#               Vladimir Marangozov
#
#               28-Jun-1996 -- initial code
#               Vladimir Marangozov           (Vladimir.Marangozov@imag.fr)
# ==========================================================================

# Variables
expFileName=$1
toAppendStr=$2
shift; shift;
inputFiles=$*
automsg="Generated automatically by makexp_aix"
notemsg="NOTE: lists _all_ global symbols defined in the above file(s)."
curwdir=`pwd`

# Create the export file and setup the header info
echo "#!"$toAppendStr > $expFileName
echo "*" >> $expFileName
echo "* $automsg  (`date -u`)" >> $expFileName
echo "*" >> $expFileName
echo "* Base Directory: $curwdir" >> $expFileName
echo "* Input File(s) : $inputFiles" >> $expFileName
echo "*" >> $expFileName
echo "* $notemsg" >> $expFileName
echo "*" >> $expFileName

# Extract the symbol list using 'nm'
# Here are some hidden tricks:
# - Use the -B flag to have a standard BSD representation
#   of the symbol list.
# - Use the -x flag to have a hex representation of the symbol
#   values. This fills the leading whitespaces, thus simplifying
#   the sed statement.
# - Eliminate all entries except those with either "B", "D"
#   or "T" key letters. We are interested only in the global
#   (extern) BSS, DATA and TEXT symbols. With the same statement
#   we eliminate object member lines relevant to AIX 4.
# - Eliminate entries containing a dot. We can have a dot only
#   as a symbol prefix, but such symbols are undefined externs.
# - Eliminate everything including the key letter, so that we're
#   left with just the symbol name.
# - Eliminate all entries containing two colons, like Class::method
#

/usr/ccs/bin/nm -Bex -X32_64 $inputFiles \
| sed -e '/ [^BDT] /d' -e '/\./d' -e 's/.* [BDT] //' -e '/::/d'	\
| sort | uniq >> $expFileName


================================================
File: /Modules/md5module.c
================================================
/* MD5 module */

/* This module provides an interface to the MD5 algorithm */

/* See below for information about the original code this module was
   based upon. Additional work performed by:

   Andrew Kuchling (amk@amk.ca)
   Greg Stein (gstein@lyra.org)
   Trevor Perrin (trevp@trevp.net)

   Copyright (C) 2005-2007   Gregory P. Smith (greg@krypto.org)
   Licensed to PSF under a Contributor Agreement.

*/

/* MD5 objects */

#ifndef Py_BUILD_CORE_BUILTIN
#  define Py_BUILD_CORE_MODULE 1
#endif

#include "Python.h"
#include "hashlib.h"

/*[clinic input]
module _md5
class MD5Type "MD5object *" "&PyType_Type"
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=6e5261719957a912]*/

/* Some useful types */

#if SIZEOF_INT == 4
typedef unsigned int MD5_INT32; /* 32-bit integer */
typedef long long MD5_INT64; /* 64-bit integer */
#else
/* not defined. compilation will die. */
#endif

/* The MD5 block size and message digest sizes, in bytes */

#define MD5_BLOCKSIZE    64
#define MD5_DIGESTSIZE   16

#include "_hacl/Hacl_Hash_MD5.h"


typedef struct {
    PyObject_HEAD
    // Prevents undefined behavior via multiple threads entering the C API.
    bool use_mutex;
    PyMutex mutex;
    Hacl_Hash_MD5_state_t *hash_state;
} MD5object;

#include "clinic/md5module.c.h"


typedef struct {
    PyTypeObject* md5_type;
} MD5State;

static inline MD5State*
md5_get_state(PyObject *module)
{
    void *state = PyModule_GetState(module);
    assert(state != NULL);
    return (MD5State *)state;
}

static MD5object *
newMD5object(MD5State * st)
{
    MD5object *md5 = (MD5object *)PyObject_GC_New(MD5object, st->md5_type);
    if (!md5) {
        return NULL;
    }
    HASHLIB_INIT_MUTEX(md5);

    PyObject_GC_Track(md5);
    return md5;
}

/* Internal methods for a hash object */
static int
MD5_traverse(PyObject *ptr, visitproc visit, void *arg)
{
    Py_VISIT(Py_TYPE(ptr));
    return 0;
}

static void
MD5_dealloc(MD5object *ptr)
{
    Hacl_Hash_MD5_free(ptr->hash_state);
    PyTypeObject *tp = Py_TYPE((PyObject*)ptr);
    PyObject_GC_UnTrack(ptr);
    PyObject_GC_Del(ptr);
    Py_DECREF(tp);
}


/* External methods for a hash object */

/*[clinic input]
MD5Type.copy

    cls: defining_class

Return a copy of the hash object.
[clinic start generated code]*/

static PyObject *
MD5Type_copy_impl(MD5object *self, PyTypeObject *cls)
/*[clinic end generated code: output=bf055e08244bf5ee input=d89087dcfb2a8620]*/
{
    MD5State *st = PyType_GetModuleState(cls);

    MD5object *newobj;
    if ((newobj = newMD5object(st))==NULL)
        return NULL;

    ENTER_HASHLIB(self);
    newobj->hash_state = Hacl_Hash_MD5_copy(self->hash_state);
    LEAVE_HASHLIB(self);
    return (PyObject *)newobj;
}

/*[clinic input]
MD5Type.digest

Return the digest value as a bytes object.
[clinic start generated code]*/

static PyObject *
MD5Type_digest_impl(MD5object *self)
/*[clinic end generated code: output=eb691dc4190a07ec input=bc0c4397c2994be6]*/
{
    unsigned char digest[MD5_DIGESTSIZE];
    ENTER_HASHLIB(self);
    Hacl_Hash_MD5_digest(self->hash_state, digest);
    LEAVE_HASHLIB(self);
    return PyBytes_FromStringAndSize((const char *)digest, MD5_DIGESTSIZE);
}

/*[clinic input]
MD5Type.hexdigest

Return the digest value as a string of hexadecimal digits.
[clinic start generated code]*/

static PyObject *
MD5Type_hexdigest_impl(MD5object *self)
/*[clinic end generated code: output=17badced1f3ac932 input=b60b19de644798dd]*/
{
    unsigned char digest[MD5_DIGESTSIZE];
    ENTER_HASHLIB(self);
    Hacl_Hash_MD5_digest(self->hash_state, digest);
    LEAVE_HASHLIB(self);

    const char *hexdigits = "0123456789abcdef";
    char digest_hex[MD5_DIGESTSIZE * 2];
    char *str = digest_hex;
    for (size_t i=0; i < MD5_DIGESTSIZE; i++) {
        unsigned char byte = digest[i];
        *str++ = hexdigits[byte >> 4];
        *str++ = hexdigits[byte & 0x0f];
    }
    return PyUnicode_FromStringAndSize(digest_hex, sizeof(digest_hex));
}

static void update(Hacl_Hash_MD5_state_t *state, uint8_t *buf, Py_ssize_t len) {
#if PY_SSIZE_T_MAX > UINT32_MAX
  while (len > UINT32_MAX) {
    Hacl_Hash_MD5_update(state, buf, UINT32_MAX);
    len -= UINT32_MAX;
    buf += UINT32_MAX;
  }
#endif
  Hacl_Hash_MD5_update(state, buf, (uint32_t) len);
}

/*[clinic input]
MD5Type.update

    obj: object
    /

Update this hash object's state with the provided string.
[clinic start generated code]*/

static PyObject *
MD5Type_update(MD5object *self, PyObject *obj)
/*[clinic end generated code: output=f6ad168416338423 input=6e1efcd9ecf17032]*/
{
    Py_buffer buf;

    GET_BUFFER_VIEW_OR_ERROUT(obj, &buf);

    if (!self->use_mutex && buf.len >= HASHLIB_GIL_MINSIZE) {
        self->use_mutex = true;
    }
    if (self->use_mutex) {
        Py_BEGIN_ALLOW_THREADS
        PyMutex_Lock(&self->mutex);
        update(self->hash_state, buf.buf, buf.len);
        PyMutex_Unlock(&self->mutex);
        Py_END_ALLOW_THREADS
    } else {
        update(self->hash_state, buf.buf, buf.len);
    }

    PyBuffer_Release(&buf);
    Py_RETURN_NONE;
}

static PyMethodDef MD5_methods[] = {
    MD5TYPE_COPY_METHODDEF
    MD5TYPE_DIGEST_METHODDEF
    MD5TYPE_HEXDIGEST_METHODDEF
    MD5TYPE_UPDATE_METHODDEF
    {NULL,        NULL}         /* sentinel */
};

static PyObject *
MD5_get_block_size(PyObject *self, void *closure)
{
    return PyLong_FromLong(MD5_BLOCKSIZE);
}

static PyObject *
MD5_get_name(PyObject *self, void *closure)
{
    return PyUnicode_FromStringAndSize("md5", 3);
}

static PyObject *
md5_get_digest_size(PyObject *self, void *closure)
{
    return PyLong_FromLong(MD5_DIGESTSIZE);
}

static PyGetSetDef MD5_getseters[] = {
    {"block_size",
     (getter)MD5_get_block_size, NULL,
     NULL,
     NULL},
    {"name",
     (getter)MD5_get_name, NULL,
     NULL,
     NULL},
    {"digest_size",
     (getter)md5_get_digest_size, NULL,
     NULL,
     NULL},
    {NULL}  /* Sentinel */
};

static PyType_Slot md5_type_slots[] = {
    {Py_tp_dealloc, MD5_dealloc},
    {Py_tp_methods, MD5_methods},
    {Py_tp_getset, MD5_getseters},
    {Py_tp_traverse, MD5_traverse},
    {0,0}
};

static PyType_Spec md5_type_spec = {
    .name = "_md5.md5",
    .basicsize =  sizeof(MD5object),
    .flags = (Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION |
              Py_TPFLAGS_IMMUTABLETYPE | Py_TPFLAGS_HAVE_GC),
    .slots = md5_type_slots
};

/* The single module-level function: new() */

/*[clinic input]
_md5.md5

    string: object(c_default="NULL") = b''
    *
    usedforsecurity: bool = True

Return a new MD5 hash object; optionally initialized with a string.
[clinic start generated code]*/

static PyObject *
_md5_md5_impl(PyObject *module, PyObject *string, int usedforsecurity)
/*[clinic end generated code: output=587071f76254a4ac input=7a144a1905636985]*/
{
    MD5object *new;
    Py_buffer buf;

    if (string)
        GET_BUFFER_VIEW_OR_ERROUT(string, &buf);

    MD5State *st = md5_get_state(module);
    if ((new = newMD5object(st)) == NULL) {
        if (string)
            PyBuffer_Release(&buf);
        return NULL;
    }

    new->hash_state = Hacl_Hash_MD5_malloc();

    if (PyErr_Occurred()) {
        Py_DECREF(new);
        if (string)
            PyBuffer_Release(&buf);
        return NULL;
    }
    if (string) {
        if (buf.len >= HASHLIB_GIL_MINSIZE) {
            /* We do not initialize self->lock here as this is the constructor
             * where it is not yet possible to have concurrent access. */
            Py_BEGIN_ALLOW_THREADS
            update(new->hash_state, buf.buf, buf.len);
            Py_END_ALLOW_THREADS
        } else {
            update(new->hash_state, buf.buf, buf.len);
        }
        PyBuffer_Release(&buf);
    }

    return (PyObject *)new;
}


/* List of functions exported by this module */

static struct PyMethodDef MD5_functions[] = {
    _MD5_MD5_METHODDEF
    {NULL,      NULL}            /* Sentinel */
};

static int
_md5_traverse(PyObject *module, visitproc visit, void *arg)
{
    MD5State *state = md5_get_state(module);
    Py_VISIT(state->md5_type);
    return 0;
}

static int
_md5_clear(PyObject *module)
{
    MD5State *state = md5_get_state(module);
    Py_CLEAR(state->md5_type);
    return 0;
}

static void
_md5_free(void *module)
{
    _md5_clear((PyObject *)module);
}

/* Initialize this module. */
static int
md5_exec(PyObject *m)
{
    MD5State *st = md5_get_state(m);

    st->md5_type = (PyTypeObject *)PyType_FromModuleAndSpec(
        m, &md5_type_spec, NULL);

    if (PyModule_AddObjectRef(m, "MD5Type", (PyObject *)st->md5_type) < 0) {
        return -1;
    }

    return 0;
}

static PyModuleDef_Slot _md5_slots[] = {
    {Py_mod_exec, md5_exec},
    {Py_mod_multiple_interpreters, Py_MOD_PER_INTERPRETER_GIL_SUPPORTED},
    {Py_mod_gil, Py_MOD_GIL_NOT_USED},
    {0, NULL}
};


static struct PyModuleDef _md5module = {
        PyModuleDef_HEAD_INIT,
        .m_name = "_md5",
        .m_size = sizeof(MD5State),
        .m_methods = MD5_functions,
        .m_slots = _md5_slots,
        .m_traverse = _md5_traverse,
        .m_clear = _md5_clear,
        .m_free = _md5_free,
};

PyMODINIT_FUNC
PyInit__md5(void)
{
    return PyModuleDef_Init(&_md5module);
}


================================================
File: /Modules/posixmodule.h
================================================
/* Declarations shared between the different POSIX-related modules */

#ifndef Py_POSIXMODULE_H
#define Py_POSIXMODULE_H
#ifdef __cplusplus
extern "C" {
#endif

#ifdef HAVE_SYS_TYPES_H
#  include <sys/types.h>          // uid_t
#endif

#ifndef MS_WINDOWS
extern PyObject* _PyLong_FromUid(uid_t);

// Export for 'grp' shared extension
PyAPI_FUNC(PyObject*) _PyLong_FromGid(gid_t);

// Export for '_posixsubprocess' shared extension
PyAPI_FUNC(int) _Py_Uid_Converter(PyObject *, uid_t *);

// Export for 'grp' shared extension
PyAPI_FUNC(int) _Py_Gid_Converter(PyObject *, gid_t *);
#endif   // !MS_WINDOWS

#if (defined(PYPTHREAD_SIGMASK) || defined(HAVE_SIGWAIT) \
     || defined(HAVE_SIGWAITINFO) || defined(HAVE_SIGTIMEDWAIT))
#  define HAVE_SIGSET_T
#endif

extern int _Py_Sigset_Converter(PyObject *, void *);

#ifdef __cplusplus
}
#endif
#endif   // !Py_POSIXMODULE_H


================================================
File: /Modules/pwdmodule.c
================================================

/* UNIX password file access module */

// Need limited C API version 3.13 for PyMem_RawRealloc()
#include "pyconfig.h"   // Py_GIL_DISABLED
#ifndef Py_GIL_DISABLED
#  define Py_LIMITED_API 0x030d0000
#endif

#include "Python.h"
#include "posixmodule.h"

#include <errno.h>                // ERANGE
