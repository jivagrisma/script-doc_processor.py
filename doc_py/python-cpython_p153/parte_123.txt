static PyObject*
writer_write_utf8(PyObject *self_raw, PyObject *args)
{
    WriterObject *self = (WriterObject *)self_raw;
    if (writer_check(self) < 0) {
        return NULL;
    }

    char *str;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "yn", &str, &size)) {
        return NULL;
    }

    if (PyUnicodeWriter_WriteUTF8(self->writer, str, size) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}


static PyObject*
writer_write_widechar(PyObject *self_raw, PyObject *args)
{
    WriterObject *self = (WriterObject *)self_raw;
    if (writer_check(self) < 0) {
        return NULL;
    }

    PyObject *str;
    if (!PyArg_ParseTuple(args, "U", &str)) {
        return NULL;
    }

    Py_ssize_t size;
    wchar_t *wstr = PyUnicode_AsWideCharString(str, &size);
    if (wstr == NULL) {
        return NULL;
    }

    int res = PyUnicodeWriter_WriteWideChar(self->writer, wstr, size);
    PyMem_Free(wstr);
    if (res < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}


static PyObject*
writer_write_ucs4(PyObject *self_raw, PyObject *args)
{
    WriterObject *self = (WriterObject *)self_raw;
    if (writer_check(self) < 0) {
        return NULL;
    }

    PyObject *str;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Un", &str, &size)) {
        return NULL;
    }
    Py_ssize_t len = PyUnicode_GET_LENGTH(str);
    size = Py_MIN(size, len);

    Py_UCS4 *ucs4 = PyUnicode_AsUCS4Copy(str);
    if (ucs4 == NULL) {
        return NULL;
    }

    int res = PyUnicodeWriter_WriteUCS4(self->writer, ucs4, size);
    PyMem_Free(ucs4);
    if (res < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}


static PyObject*
writer_write_str(PyObject *self_raw, PyObject *args)
{
    WriterObject *self = (WriterObject *)self_raw;
    if (writer_check(self) < 0) {
        return NULL;
    }

    PyObject *obj;
    if (!PyArg_ParseTuple(args, "O", &obj)) {
        return NULL;
    }

    if (PyUnicodeWriter_WriteStr(self->writer, obj) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}


static PyObject*
writer_write_repr(PyObject *self_raw, PyObject *args)
{
    WriterObject *self = (WriterObject *)self_raw;
    if (writer_check(self) < 0) {
        return NULL;
    }

    PyObject *obj;
    if (!PyArg_ParseTuple(args, "O", &obj)) {
        return NULL;
    }

    if (PyUnicodeWriter_WriteRepr(self->writer, obj) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}


static PyObject*
writer_write_substring(PyObject *self_raw, PyObject *args)
{
    WriterObject *self = (WriterObject *)self_raw;
    if (writer_check(self) < 0) {
        return NULL;
    }

    PyObject *str;
    Py_ssize_t start, end;
    if (!PyArg_ParseTuple(args, "Unn", &str, &start, &end)) {
        return NULL;
    }

    if (PyUnicodeWriter_WriteSubstring(self->writer, str, start, end) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}


static PyObject*
writer_decodeutf8stateful(PyObject *self_raw, PyObject *args)
{
    WriterObject *self = (WriterObject *)self_raw;
    if (writer_check(self) < 0) {
        return NULL;
    }

    const char *str;
    Py_ssize_t len;
    const char *errors;
    int use_consumed = 0;
    if (!PyArg_ParseTuple(args, "yny|i", &str, &len, &errors, &use_consumed)) {
        return NULL;
    }

    Py_ssize_t consumed = 12345;
    Py_ssize_t *pconsumed = use_consumed ? &consumed : NULL;
    if (PyUnicodeWriter_DecodeUTF8Stateful(self->writer, str, len,
                                           errors, pconsumed) < 0) {
        if (use_consumed) {
            assert(consumed == 0);
        }
        return NULL;
    }

    if (use_consumed) {
        return PyLong_FromSsize_t(consumed);
    }
    Py_RETURN_NONE;
}


static PyObject*
writer_get_pointer(PyObject *self_raw, PyObject *args)
{
    WriterObject *self = (WriterObject *)self_raw;
    if (writer_check(self) < 0) {
        return NULL;
    }

    return PyLong_FromVoidPtr(self->writer);
}


static PyObject*
writer_finish(PyObject *self_raw, PyObject *Py_UNUSED(args))
{
    WriterObject *self = (WriterObject *)self_raw;
    if (writer_check(self) < 0) {
        return NULL;
    }

    PyObject *str = PyUnicodeWriter_Finish(self->writer);
    self->writer = NULL;
    return str;
}


static PyMethodDef writer_methods[] = {
    {"write_char", _PyCFunction_CAST(writer_write_char), METH_VARARGS},
    {"write_utf8", _PyCFunction_CAST(writer_write_utf8), METH_VARARGS},
    {"write_widechar", _PyCFunction_CAST(writer_write_widechar), METH_VARARGS},
    {"write_ucs4", _PyCFunction_CAST(writer_write_ucs4), METH_VARARGS},
    {"write_str", _PyCFunction_CAST(writer_write_str), METH_VARARGS},
    {"write_repr", _PyCFunction_CAST(writer_write_repr), METH_VARARGS},
    {"write_substring", _PyCFunction_CAST(writer_write_substring), METH_VARARGS},
    {"decodeutf8stateful", _PyCFunction_CAST(writer_decodeutf8stateful), METH_VARARGS},
    {"get_pointer", _PyCFunction_CAST(writer_get_pointer), METH_VARARGS},
    {"finish", _PyCFunction_CAST(writer_finish), METH_NOARGS},
    {NULL,              NULL}           /* sentinel */
};

static PyType_Slot Writer_Type_slots[] = {
    {Py_tp_new, writer_new},
    {Py_tp_init, writer_init},
    {Py_tp_dealloc, writer_dealloc},
    {Py_tp_methods, writer_methods},
    {0, 0},  /* sentinel */
};

static PyType_Spec Writer_spec = {
    .name = "_testcapi.PyUnicodeWriter",
    .basicsize = sizeof(WriterObject),
    .flags = Py_TPFLAGS_DEFAULT,
    .slots = Writer_Type_slots,
};


static PyMethodDef TestMethods[] = {
    {"unicode_new",              unicode_new,                    METH_VARARGS},
    {"unicode_fill",             unicode_fill,                   METH_VARARGS},
    {"unicode_fromkindanddata",  unicode_fromkindanddata,        METH_VARARGS},
    {"unicode_asucs4",           unicode_asucs4,                 METH_VARARGS},
    {"unicode_asucs4copy",       unicode_asucs4copy,             METH_VARARGS},
    {"unicode_asutf8",           unicode_asutf8,                 METH_VARARGS},
    {"unicode_copycharacters",   unicode_copycharacters,         METH_VARARGS},
    {NULL},
};

int
_PyTestCapi_Init_Unicode(PyObject *m) {
    if (PyModule_AddFunctions(m, TestMethods) < 0) {
        return -1;
    }

    PyTypeObject *writer_type = (PyTypeObject *)PyType_FromSpec(&Writer_spec);
    if (writer_type == NULL) {
        return -1;
    }
    if (PyModule_AddType(m, writer_type) < 0) {
        Py_DECREF(writer_type);
        return -1;
    }
    Py_DECREF(writer_type);

    return 0;
}


================================================
File: /Modules/_testcapi/util.h
================================================
#define NULLABLE(x) do {                    \
        if (x == Py_None) {                 \
            x = NULL;                       \
        }                                   \
    } while (0);

#define RETURN_INT(value) do {              \
        int _ret = (value);                 \
        if (_ret == -1) {                   \
            assert(PyErr_Occurred());       \
            return NULL;                    \
        }                                   \
        assert(!PyErr_Occurred());          \
        return PyLong_FromLong(_ret);       \
    } while (0)

#define RETURN_SIZE(value) do {             \
        Py_ssize_t _ret = (value);          \
        if (_ret == -1) {                   \
            assert(PyErr_Occurred());       \
            return NULL;                    \
        }                                   \
        assert(!PyErr_Occurred());          \
        return PyLong_FromSsize_t(_ret);    \
    } while (0)

/* Marker to check that pointer value was set. */
static const char uninitialized[] = "uninitialized";
#define UNINITIALIZED_PTR ((void *)uninitialized)
/* Marker to check that Py_ssize_t value was set. */
#define UNINITIALIZED_SIZE ((Py_ssize_t)236892191)
/* Marker to check that integer value was set. */
#define UNINITIALIZED_INT (63256717)
/*
 * Marker to indicate that a NULL parameter would not be allowed
 * at runtime but that the test interface will check that it is
 * indeed the case.
 *
 * Use this macro only if passing NULL to the C API would raise
 * a catchable exception (and not a fatal exception that would
 * crash the interpreter).
 */
 #define NULL_WOULD_RAISE(NAME)    NAME


================================================
File: /Modules/_testcapi/vectorcall.c
================================================
// clinic/vectorcall.c.h uses internal pycore_modsupport.h API
#define PYTESTCAPI_NEED_INTERNAL_API

#include "parts.h"
#include "clinic/vectorcall.c.h"


#include <stddef.h>                 // offsetof

/*[clinic input]
module _testcapi
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=6361033e795369fc]*/

/* Test PEP 590 - Vectorcall */

static int
fastcall_args(PyObject *args, PyObject ***stack, Py_ssize_t *nargs)
{
    if (args == Py_None) {
        *stack = NULL;
        *nargs = 0;
    }
    else if (PyTuple_Check(args)) {
        *stack = ((PyTupleObject *)args)->ob_item;
        *nargs = PyTuple_GET_SIZE(args);
    }
    else {
        PyErr_SetString(PyExc_TypeError, "args must be None or a tuple");
        return -1;
    }
    return 0;
}

/*[clinic input]
_testcapi.pyobject_fastcalldict
    func: object
    func_args: object
    kwargs: object
    /
[clinic start generated code]*/

static PyObject *
_testcapi_pyobject_fastcalldict_impl(PyObject *module, PyObject *func,
                                     PyObject *func_args, PyObject *kwargs)
/*[clinic end generated code: output=35902ece94de4418 input=b9c0196ca7d5f9e4]*/
{
    PyObject **stack;
    Py_ssize_t nargs;

    if (fastcall_args(func_args, &stack, &nargs) < 0) {
        return NULL;
    }

    if (kwargs == Py_None) {
        kwargs = NULL;
    }
    else if (!PyDict_Check(kwargs)) {
        PyErr_SetString(PyExc_TypeError, "kwnames must be None or a dict");
        return NULL;
    }

    return PyObject_VectorcallDict(func, stack, nargs, kwargs);
}

/*[clinic input]
_testcapi.pyobject_vectorcall
    func: object
    func_args: object
    kwnames: object
    /
[clinic start generated code]*/

static PyObject *
_testcapi_pyobject_vectorcall_impl(PyObject *module, PyObject *func,
                                   PyObject *func_args, PyObject *kwnames)
/*[clinic end generated code: output=ff77245bc6afe0d8 input=a0668dfef625764c]*/
{
    PyObject **stack;
    Py_ssize_t nargs, nkw;

    if (fastcall_args(func_args, &stack, &nargs) < 0) {
        return NULL;
    }

    if (kwnames == Py_None) {
        kwnames = NULL;
    }
    else if (PyTuple_Check(kwnames)) {
        nkw = PyTuple_GET_SIZE(kwnames);
        if (nargs < nkw) {
            PyErr_SetString(PyExc_ValueError, "kwnames longer than args");
            return NULL;
        }
        nargs -= nkw;
    }
    else {
        PyErr_SetString(PyExc_TypeError, "kwnames must be None or a tuple");
        return NULL;
    }
    return PyObject_Vectorcall(func, stack, nargs, kwnames);
}

static PyObject *
override_vectorcall(PyObject *callable, PyObject *const *args, size_t nargsf,
                    PyObject *kwnames)
{
    return PyUnicode_FromString("overridden");
}

static PyObject *
function_setvectorcall(PyObject *self, PyObject *func)
{
    if (!PyFunction_Check(func)) {
        PyErr_SetString(PyExc_TypeError, "'func' must be a function");
        return NULL;
    }
    PyFunction_SetVectorcall((PyFunctionObject *)func, (vectorcallfunc)override_vectorcall);
    Py_RETURN_NONE;
}

/*[clinic input]
_testcapi.pyvectorcall_call
    func: object
    argstuple: object
    kwargs: object = NULL
    /
[clinic start generated code]*/

static PyObject *
_testcapi_pyvectorcall_call_impl(PyObject *module, PyObject *func,
                                 PyObject *argstuple, PyObject *kwargs)
/*[clinic end generated code: output=809046fe78511306 input=4376ee7cabd698ce]*/
{
    if (!PyTuple_Check(argstuple)) {
        PyErr_SetString(PyExc_TypeError, "args must be a tuple");
        return NULL;
    }
    if (kwargs != NULL && !PyDict_Check(kwargs)) {
        PyErr_SetString(PyExc_TypeError, "kwargs must be a dict");
        return NULL;
    }

    return PyVectorcall_Call(func, argstuple, kwargs);
}

PyObject *
VectorCallClass_tpcall(PyObject *self, PyObject *args, PyObject *kwargs) {
    return PyUnicode_FromString("tp_call");
}

PyObject *
VectorCallClass_vectorcall(PyObject *callable,
                            PyObject *const *args,
                            size_t nargsf,
                            PyObject *kwnames) {
    return PyUnicode_FromString("vectorcall");
}

/*[clinic input]
class _testcapi.VectorCallClass "PyObject *" "&PyType_Type"
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=95c63c1a47f9a995]*/

/*[clinic input]
_testcapi.VectorCallClass.set_vectorcall

    type: object(subclass_of="&PyType_Type", type="PyTypeObject *")
    /

Set self's vectorcall function for `type` to one that returns "vectorcall"
[clinic start generated code]*/

static PyObject *
_testcapi_VectorCallClass_set_vectorcall_impl(PyObject *self,
                                              PyTypeObject *type)
/*[clinic end generated code: output=b37f0466f15da903 input=840de66182c7d71a]*/
{
    if (!PyObject_TypeCheck(self, type)) {
        return PyErr_Format(
            PyExc_TypeError,
            "expected %s instance",
            PyType_GetName(type));
    }
    if (!type->tp_vectorcall_offset) {
        return PyErr_Format(
            PyExc_TypeError,
            "type %s has no vectorcall offset",
            PyType_GetName(type));
    }
    *(vectorcallfunc*)((char*)self + type->tp_vectorcall_offset) = (
        VectorCallClass_vectorcall);
    Py_RETURN_NONE;
}

PyMethodDef VectorCallClass_methods[] = {
    _TESTCAPI_VECTORCALLCLASS_SET_VECTORCALL_METHODDEF
    {NULL, NULL}
};

PyMemberDef VectorCallClass_members[] = {
    {"__vectorcalloffset__", Py_T_PYSSIZET, 0/* set later */, Py_READONLY},
    {NULL}
};

PyType_Slot VectorCallClass_slots[] = {
    {Py_tp_call, VectorCallClass_tpcall},
    {Py_tp_members, VectorCallClass_members},
    {Py_tp_methods, VectorCallClass_methods},
    {0},
};

/*[clinic input]
_testcapi.make_vectorcall_class

    base: object(subclass_of="&PyType_Type", type="PyTypeObject *") = NULL
    /

Create a class whose instances return "tpcall" when called.

When the "set_vectorcall" method is called on an instance, a vectorcall
function that returns "vectorcall" will be installed.
[clinic start generated code]*/

static PyObject *
_testcapi_make_vectorcall_class_impl(PyObject *module, PyTypeObject *base)
/*[clinic end generated code: output=16dcfc3062ddf968 input=f72e01ccf52de2b4]*/
{
    if (!base) {
        base = (PyTypeObject *)&PyBaseObject_Type;
    }
    VectorCallClass_members[0].offset = base->tp_basicsize;
    PyType_Spec spec = {
        .name = "_testcapi.VectorcallClass",
        .basicsize = (int)(base->tp_basicsize + sizeof(vectorcallfunc)),
        .flags = Py_TPFLAGS_DEFAULT
            | Py_TPFLAGS_HAVE_VECTORCALL
            | Py_TPFLAGS_BASETYPE,
        .slots = VectorCallClass_slots,
    };

    return PyType_FromSpecWithBases(&spec, (PyObject *)base);
}

/*[clinic input]
_testcapi.has_vectorcall_flag -> bool

    type: object(subclass_of="&PyType_Type", type="PyTypeObject *")
    /

Return true iff Py_TPFLAGS_HAVE_VECTORCALL is set on the class.
[clinic start generated code]*/

static int
_testcapi_has_vectorcall_flag_impl(PyObject *module, PyTypeObject *type)
/*[clinic end generated code: output=3ae8d1374388c671 input=8eee492ac548749e]*/
{
    return PyType_HasFeature(type, Py_TPFLAGS_HAVE_VECTORCALL);
}

static PyMethodDef TestMethods[] = {
    _TESTCAPI_PYOBJECT_FASTCALLDICT_METHODDEF
    _TESTCAPI_PYOBJECT_VECTORCALL_METHODDEF
    {"function_setvectorcall", function_setvectorcall, METH_O},
    _TESTCAPI_PYVECTORCALL_CALL_METHODDEF
    _TESTCAPI_MAKE_VECTORCALL_CLASS_METHODDEF
    _TESTCAPI_HAS_VECTORCALL_FLAG_METHODDEF
    {NULL},
};


typedef struct {
    PyObject_HEAD
    vectorcallfunc vectorcall;
} MethodDescriptorObject;

static PyObject *
MethodDescriptor_vectorcall(PyObject *callable, PyObject *const *args,
                            size_t nargsf, PyObject *kwnames)
{
    /* True if using the vectorcall function in MethodDescriptorObject
     * but False for MethodDescriptor2Object */
    MethodDescriptorObject *md = (MethodDescriptorObject *)callable;
    return PyBool_FromLong(md->vectorcall != NULL);
}

static PyObject *
MethodDescriptor_new(PyTypeObject* type, PyObject* args, PyObject *kw)
{
    MethodDescriptorObject *op = (MethodDescriptorObject *)type->tp_alloc(type, 0);
    op->vectorcall = MethodDescriptor_vectorcall;
    return (PyObject *)op;
}

static PyObject *
func_descr_get(PyObject *func, PyObject *obj, PyObject *type)
{
    if (obj == Py_None || obj == NULL) {
        return Py_NewRef(func);
    }
    return PyMethod_New(func, obj);
}

static PyObject *
nop_descr_get(PyObject *func, PyObject *obj, PyObject *type)
{
    return Py_NewRef(func);
}

static PyObject *
call_return_args(PyObject *self, PyObject *args, PyObject *kwargs)
{
    return Py_NewRef(args);
}

static PyTypeObject MethodDescriptorBase_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MethodDescriptorBase",
    sizeof(MethodDescriptorObject),
    .tp_new = MethodDescriptor_new,
    .tp_call = PyVectorcall_Call,
    .tp_vectorcall_offset = offsetof(MethodDescriptorObject, vectorcall),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
                Py_TPFLAGS_METHOD_DESCRIPTOR | Py_TPFLAGS_HAVE_VECTORCALL,
    .tp_descr_get = func_descr_get,
};

static PyTypeObject MethodDescriptorDerived_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MethodDescriptorDerived",
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
};

static PyTypeObject MethodDescriptorNopGet_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MethodDescriptorNopGet",
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .tp_call = call_return_args,
    .tp_descr_get = nop_descr_get,
};

typedef struct {
    MethodDescriptorObject base;
    vectorcallfunc vectorcall;
} MethodDescriptor2Object;

static PyObject *
MethodDescriptor2_new(PyTypeObject* type, PyObject* args, PyObject *kw)
{
    MethodDescriptor2Object *op = PyObject_New(MethodDescriptor2Object, type);
    if (op == NULL) {
        return NULL;
    }
    op->base.vectorcall = NULL;
    op->vectorcall = MethodDescriptor_vectorcall;
    return (PyObject *)op;
}

static PyTypeObject MethodDescriptor2_Type = {
    PyVarObject_HEAD_INIT(NULL, 0)
    "MethodDescriptor2",
    sizeof(MethodDescriptor2Object),
    .tp_new = MethodDescriptor2_new,
    .tp_call = PyVectorcall_Call,
    .tp_vectorcall_offset = offsetof(MethodDescriptor2Object, vectorcall),
    .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_VECTORCALL,
};


int
_PyTestCapi_Init_Vectorcall(PyObject *m) {
    if (PyModule_AddFunctions(m, TestMethods) < 0) {
        return -1;
    }

    if (PyType_Ready(&MethodDescriptorBase_Type) < 0) {
        return -1;
    }
    if (PyModule_AddType(m, &MethodDescriptorBase_Type) < 0) {
        return -1;
    }

    MethodDescriptorDerived_Type.tp_base = &MethodDescriptorBase_Type;
    if (PyType_Ready(&MethodDescriptorDerived_Type) < 0) {
        return -1;
    }
    if (PyModule_AddType(m, &MethodDescriptorDerived_Type) < 0) {
        return -1;
    }

    MethodDescriptorNopGet_Type.tp_base = &MethodDescriptorBase_Type;
    if (PyType_Ready(&MethodDescriptorNopGet_Type) < 0) {
        return -1;
    }
    if (PyModule_AddType(m, &MethodDescriptorNopGet_Type) < 0) {
        return -1;
    }

    MethodDescriptor2_Type.tp_base = &MethodDescriptorBase_Type;
    if (PyType_Ready(&MethodDescriptor2_Type) < 0) {
        return -1;
    }
    if (PyModule_AddType(m, &MethodDescriptor2_Type) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testcapi/watchers.c
================================================
// clinic/watchers.c.h uses internal pycore_modsupport.h API
#define PYTESTCAPI_NEED_INTERNAL_API

#include "parts.h"

#include "clinic/watchers.c.h"

#define Py_BUILD_CORE
#include "pycore_function.h"  // FUNC_MAX_WATCHERS
#include "pycore_code.h"  // CODE_MAX_WATCHERS
#include "pycore_context.h" // CONTEXT_MAX_WATCHERS

/*[clinic input]
module _testcapi
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=6361033e795369fc]*/

// Test dict watching
static PyObject *g_dict_watch_events = NULL;
static int g_dict_watchers_installed = 0;

static int
dict_watch_callback(PyDict_WatchEvent event,
                    PyObject *dict,
                    PyObject *key,
                    PyObject *new_value)
{
    PyObject *msg;
    switch (event) {
        case PyDict_EVENT_CLEARED:
            msg = PyUnicode_FromString("clear");
            break;
        case PyDict_EVENT_DEALLOCATED:
            msg = PyUnicode_FromString("dealloc");
            break;
        case PyDict_EVENT_CLONED:
            msg = PyUnicode_FromString("clone");
            break;
        case PyDict_EVENT_ADDED:
            msg = PyUnicode_FromFormat("new:%S:%S", key, new_value);
            break;
        case PyDict_EVENT_MODIFIED:
            msg = PyUnicode_FromFormat("mod:%S:%S", key, new_value);
            break;
        case PyDict_EVENT_DELETED:
            msg = PyUnicode_FromFormat("del:%S", key);
            break;
        default:
            msg = PyUnicode_FromString("unknown");
    }
    if (msg == NULL) {
        return -1;
    }
    assert(PyList_Check(g_dict_watch_events));
    if (PyList_Append(g_dict_watch_events, msg) < 0) {
        Py_DECREF(msg);
        return -1;
    }
    Py_DECREF(msg);
    return 0;
}

static int
dict_watch_callback_second(PyDict_WatchEvent event,
                           PyObject *dict,
                           PyObject *key,
                           PyObject *new_value)
{
    PyObject *msg = PyUnicode_FromString("second");
    if (msg == NULL) {
        return -1;
    }
    int rc = PyList_Append(g_dict_watch_events, msg);
    Py_DECREF(msg);
    if (rc < 0) {
        return -1;
    }
    return 0;
}

static int
dict_watch_callback_error(PyDict_WatchEvent event,
                          PyObject *dict,
                          PyObject *key,
                          PyObject *new_value)
{
    PyErr_SetString(PyExc_RuntimeError, "boom!");
    return -1;
}

static PyObject *
add_dict_watcher(PyObject *self, PyObject *kind)
{
    int watcher_id;
    assert(PyLong_Check(kind));
    long kind_l = PyLong_AsLong(kind);
    if (kind_l == 2) {
        watcher_id = PyDict_AddWatcher(dict_watch_callback_second);
    }
    else if (kind_l == 1) {
        watcher_id = PyDict_AddWatcher(dict_watch_callback_error);
    }
    else {
        watcher_id = PyDict_AddWatcher(dict_watch_callback);
    }
    if (watcher_id < 0) {
        return NULL;
    }
    if (!g_dict_watchers_installed) {
        assert(!g_dict_watch_events);
        if (!(g_dict_watch_events = PyList_New(0))) {
            return NULL;
        }
    }
    g_dict_watchers_installed++;
    return PyLong_FromLong(watcher_id);
}

static PyObject *
clear_dict_watcher(PyObject *self, PyObject *watcher_id)
{
    if (PyDict_ClearWatcher(PyLong_AsLong(watcher_id))) {
        return NULL;
    }
    g_dict_watchers_installed--;
    if (!g_dict_watchers_installed) {
        assert(g_dict_watch_events);
        Py_CLEAR(g_dict_watch_events);
    }
    Py_RETURN_NONE;
}

/*[clinic input]
_testcapi.watch_dict
    watcher_id: int
    dict: object
    /
[clinic start generated code]*/

static PyObject *
_testcapi_watch_dict_impl(PyObject *module, int watcher_id, PyObject *dict)
/*[clinic end generated code: output=1426e0273cebe2d8 input=269b006d60c358bd]*/
{
    if (PyDict_Watch(watcher_id, dict)) {
        return NULL;
    }
    Py_RETURN_NONE;
}

/*[clinic input]
_testcapi.unwatch_dict = _testcapi.watch_dict
[clinic start generated code]*/

static PyObject *
_testcapi_unwatch_dict_impl(PyObject *module, int watcher_id, PyObject *dict)
/*[clinic end generated code: output=512b1a71ae33c351 input=cae7dc1b6f7713b8]*/
{
    if (PyDict_Unwatch(watcher_id, dict)) {
        return NULL;
    }
    Py_RETURN_NONE;
}

static PyObject *
get_dict_watcher_events(PyObject *self, PyObject *Py_UNUSED(args))
{
    if (!g_dict_watch_events) {
        PyErr_SetString(PyExc_RuntimeError, "no watchers active");
        return NULL;
    }
    return Py_NewRef(g_dict_watch_events);
}

// Test type watchers
static PyObject *g_type_modified_events;
static int g_type_watchers_installed;

static int
type_modified_callback(PyTypeObject *type)
{
    assert(PyList_Check(g_type_modified_events));
    if(PyList_Append(g_type_modified_events, (PyObject *)type) < 0) {
        return -1;
    }
    return 0;
}

static int
type_modified_callback_wrap(PyTypeObject *type)
{
    assert(PyList_Check(g_type_modified_events));
    PyObject *list = PyList_New(0);
    if (list == NULL) {
        return -1;
    }
    if (PyList_Append(list, (PyObject *)type) < 0) {
        Py_DECREF(list);
        return -1;
    }
    if (PyList_Append(g_type_modified_events, list) < 0) {
        Py_DECREF(list);
        return -1;
    }
    Py_DECREF(list);
    return 0;
}

static int
type_modified_callback_error(PyTypeObject *type)
{
    PyErr_SetString(PyExc_RuntimeError, "boom!");
    return -1;
}

static PyObject *
add_type_watcher(PyObject *self, PyObject *kind)
{
    int watcher_id;
    assert(PyLong_Check(kind));
    long kind_l = PyLong_AsLong(kind);
    if (kind_l == 2) {
        watcher_id = PyType_AddWatcher(type_modified_callback_wrap);
    }
    else if (kind_l == 1) {
        watcher_id = PyType_AddWatcher(type_modified_callback_error);
    }
    else {
        watcher_id = PyType_AddWatcher(type_modified_callback);
    }
    if (watcher_id < 0) {
        return NULL;
    }
    if (!g_type_watchers_installed) {
        assert(!g_type_modified_events);
        if (!(g_type_modified_events = PyList_New(0))) {
            return NULL;
        }
    }
    g_type_watchers_installed++;
    return PyLong_FromLong(watcher_id);
}

static PyObject *
clear_type_watcher(PyObject *self, PyObject *watcher_id)
{
    if (PyType_ClearWatcher(PyLong_AsLong(watcher_id))) {
        return NULL;
    }
    g_type_watchers_installed--;
    if (!g_type_watchers_installed) {
        assert(g_type_modified_events);
        Py_CLEAR(g_type_modified_events);
    }
    Py_RETURN_NONE;
}

static PyObject *
get_type_modified_events(PyObject *self, PyObject *Py_UNUSED(args))
{
    if (!g_type_modified_events) {
        PyErr_SetString(PyExc_RuntimeError, "no watchers active");
        return NULL;
    }
    return Py_NewRef(g_type_modified_events);
}

/*[clinic input]
_testcapi.watch_type
    watcher_id: int
    type: object
    /
[clinic start generated code]*/

static PyObject *
_testcapi_watch_type_impl(PyObject *module, int watcher_id, PyObject *type)
/*[clinic end generated code: output=fdf4777126724fc4 input=5a808bf12be7e3ed]*/
{
    if (PyType_Watch(watcher_id, type)) {
        return NULL;
    }
    Py_RETURN_NONE;
}

/*[clinic input]
_testcapi.unwatch_type = _testcapi.watch_type
[clinic start generated code]*/

static PyObject *
_testcapi_unwatch_type_impl(PyObject *module, int watcher_id, PyObject *type)
/*[clinic end generated code: output=0389672d4ad5f68b input=6701911fb45edc9e]*/
{
    if (PyType_Unwatch(watcher_id, type)) {
        return NULL;
    }
    Py_RETURN_NONE;
}


// Test code object watching

#define NUM_CODE_WATCHERS 2
static int code_watcher_ids[NUM_CODE_WATCHERS] = {-1, -1};
static int num_code_object_created_events[NUM_CODE_WATCHERS] = {0, 0};
static int num_code_object_destroyed_events[NUM_CODE_WATCHERS] = {0, 0};

static int
handle_code_object_event(int which_watcher, PyCodeEvent event, PyCodeObject *co) {
    if (event == PY_CODE_EVENT_CREATE) {
        num_code_object_created_events[which_watcher]++;
    }
    else if (event == PY_CODE_EVENT_DESTROY) {
        num_code_object_destroyed_events[which_watcher]++;
    }
    else {
        return -1;
    }
    return 0;
}

static int
first_code_object_callback(PyCodeEvent event, PyCodeObject *co)
{
    return handle_code_object_event(0, event, co);
}

static int
second_code_object_callback(PyCodeEvent event, PyCodeObject *co)
{
    return handle_code_object_event(1, event, co);
}

static int
noop_code_event_handler(PyCodeEvent event, PyCodeObject *co)
{
    return 0;
}

static int
error_code_event_handler(PyCodeEvent event, PyCodeObject *co)
{
    PyErr_SetString(PyExc_RuntimeError, "boom!");
    return -1;
}

static PyObject *
add_code_watcher(PyObject *self, PyObject *which_watcher)
{
    int watcher_id;
    assert(PyLong_Check(which_watcher));
    long which_l = PyLong_AsLong(which_watcher);
    if (which_l == 0) {
        watcher_id = PyCode_AddWatcher(first_code_object_callback);
        code_watcher_ids[0] = watcher_id;
        num_code_object_created_events[0] = 0;
        num_code_object_destroyed_events[0] = 0;
    }
    else if (which_l == 1) {
        watcher_id = PyCode_AddWatcher(second_code_object_callback);
        code_watcher_ids[1] = watcher_id;
        num_code_object_created_events[1] = 0;
        num_code_object_destroyed_events[1] = 0;
    }
    else if (which_l == 2) {
        watcher_id = PyCode_AddWatcher(error_code_event_handler);
    }
    else {
        PyErr_Format(PyExc_ValueError, "invalid watcher %d", which_l);
        return NULL;
    }
    if (watcher_id < 0) {
        return NULL;
    }
    return PyLong_FromLong(watcher_id);
}

static PyObject *
clear_code_watcher(PyObject *self, PyObject *watcher_id)
{
    assert(PyLong_Check(watcher_id));
    long watcher_id_l = PyLong_AsLong(watcher_id);
    if (PyCode_ClearWatcher(watcher_id_l) < 0) {
        return NULL;
    }
    // reset static events counters
    if (watcher_id_l >= 0) {
        for (int i = 0; i < NUM_CODE_WATCHERS; i++) {
            if (watcher_id_l == code_watcher_ids[i]) {
                code_watcher_ids[i] = -1;
                num_code_object_created_events[i] = 0;
                num_code_object_destroyed_events[i] = 0;
            }
        }
    }
    Py_RETURN_NONE;
}

static PyObject *
get_code_watcher_num_created_events(PyObject *self, PyObject *watcher_id)
{
    assert(PyLong_Check(watcher_id));
    long watcher_id_l = PyLong_AsLong(watcher_id);
    assert(watcher_id_l >= 0 && watcher_id_l < NUM_CODE_WATCHERS);
    return PyLong_FromLong(num_code_object_created_events[watcher_id_l]);
}

static PyObject *
get_code_watcher_num_destroyed_events(PyObject *self, PyObject *watcher_id)
{
    assert(PyLong_Check(watcher_id));
    long watcher_id_l = PyLong_AsLong(watcher_id);
    assert(watcher_id_l >= 0 && watcher_id_l < NUM_CODE_WATCHERS);
    return PyLong_FromLong(num_code_object_destroyed_events[watcher_id_l]);
}

static PyObject *
allocate_too_many_code_watchers(PyObject *self, PyObject *args)
{
    int watcher_ids[CODE_MAX_WATCHERS + 1];
    int num_watchers = 0;
    for (unsigned long i = 0; i < sizeof(watcher_ids) / sizeof(int); i++) {
        int watcher_id = PyCode_AddWatcher(noop_code_event_handler);
        if (watcher_id == -1) {
            break;
        }
        watcher_ids[i] = watcher_id;
        num_watchers++;
    }
    PyObject *exc = PyErr_GetRaisedException();
    for (int i = 0; i < num_watchers; i++) {
        if (PyCode_ClearWatcher(watcher_ids[i]) < 0) {
            PyErr_WriteUnraisable(Py_None);
            break;
        }
    }
    if (exc) {
        PyErr_SetRaisedException(exc);
        return NULL;
    }
    else if (PyErr_Occurred()) {
        return NULL;
    }
    Py_RETURN_NONE;
}

// Test function watchers

#define NUM_TEST_FUNC_WATCHERS 2
static PyObject *pyfunc_watchers[NUM_TEST_FUNC_WATCHERS];
static int func_watcher_ids[NUM_TEST_FUNC_WATCHERS] = {-1, -1};

static PyObject *
get_id(PyObject *obj)
{
    PyObject *builtins = PyEval_GetBuiltins();  // borrowed ref.
    if (builtins == NULL) {
        return NULL;
    }
    PyObject *id_str = PyUnicode_FromString("id");
    if (id_str == NULL) {
        return NULL;
    }
    PyObject *id_func = PyObject_GetItem(builtins, id_str);
    Py_DECREF(id_str);
    if (id_func == NULL) {
        return NULL;
    }
    PyObject *stack[] = {obj};
    PyObject *id = PyObject_Vectorcall(id_func, stack, 1, NULL);
    Py_DECREF(id_func);
    return id;
}

static int
call_pyfunc_watcher(PyObject *watcher, PyFunction_WatchEvent event,
                    PyFunctionObject *func, PyObject *new_value)
{
    PyObject *event_obj = PyLong_FromLong(event);
    if (event_obj == NULL) {
        return -1;
    }
    if (new_value == NULL) {
        new_value = Py_None;
    }
    Py_INCREF(new_value);
    PyObject *func_or_id = NULL;
    if (event == PyFunction_EVENT_DESTROY) {
        /* Don't expose a function that's about to be destroyed to managed code */
        func_or_id = get_id((PyObject *) func);
        if (func_or_id == NULL) {
            Py_DECREF(event_obj);
            Py_DECREF(new_value);
            return -1;
        }
    }
    else {
        Py_INCREF(func);
        func_or_id = (PyObject *) func;
    }
    PyObject *stack[] = {event_obj, func_or_id, new_value};
    PyObject *res = PyObject_Vectorcall(watcher, stack, 3, NULL);
    int st = (res == NULL) ? -1 : 0;
    Py_XDECREF(res);
    Py_DECREF(new_value);
    Py_DECREF(event_obj);
    Py_DECREF(func_or_id);
    return st;
}

static int
first_func_watcher_callback(PyFunction_WatchEvent event, PyFunctionObject *func,
                            PyObject *new_value)
{
    return call_pyfunc_watcher(pyfunc_watchers[0], event, func, new_value);
}

static int
second_func_watcher_callback(PyFunction_WatchEvent event,
                             PyFunctionObject *func, PyObject *new_value)
{
    return call_pyfunc_watcher(pyfunc_watchers[1], event, func, new_value);
}

static PyFunction_WatchCallback func_watcher_callbacks[NUM_TEST_FUNC_WATCHERS] = {
    first_func_watcher_callback,
    second_func_watcher_callback
};

static int
add_func_event(PyObject *module, const char *name, PyFunction_WatchEvent event)
{
    return PyModule_Add(module, name, PyLong_FromLong(event));
}

static PyObject *
add_func_watcher(PyObject *self, PyObject *func)
{
    if (!PyFunction_Check(func)) {
        PyErr_SetString(PyExc_TypeError, "'func' must be a function");
        return NULL;
    }
    int idx = -1;
    for (int i = 0; i < NUM_TEST_FUNC_WATCHERS; i++) {
        if (func_watcher_ids[i] == -1) {
            idx = i;
            break;
        }
    }
    if (idx == -1) {
        PyErr_SetString(PyExc_RuntimeError, "no free test watchers");
        return NULL;
    }
    func_watcher_ids[idx] = PyFunction_AddWatcher(func_watcher_callbacks[idx]);
    if (func_watcher_ids[idx] < 0) {
        return NULL;
    }
    pyfunc_watchers[idx] = Py_NewRef(func);
    PyObject *result = PyLong_FromLong(func_watcher_ids[idx]);
    if (result == NULL) {
        return NULL;
    }
    return result;
}

static PyObject *
clear_func_watcher(PyObject *self, PyObject *watcher_id_obj)
{
    long watcher_id = PyLong_AsLong(watcher_id_obj);
    if ((watcher_id < INT_MIN) || (watcher_id > INT_MAX)) {
        PyErr_SetString(PyExc_ValueError, "invalid watcher ID");
        return NULL;
    }
    int wid = (int) watcher_id;
    if (PyFunction_ClearWatcher(wid) < 0) {
        return NULL;
    }
    int idx = -1;
    for (int i = 0; i < NUM_TEST_FUNC_WATCHERS; i++) {
        if (func_watcher_ids[i] == wid) {
            idx = i;
            break;
        }
    }
    assert(idx != -1);
    Py_CLEAR(pyfunc_watchers[idx]);
    func_watcher_ids[idx] = -1;
    Py_RETURN_NONE;
}

static int
noop_func_event_handler(PyFunction_WatchEvent event, PyFunctionObject *func,
             PyObject *new_value)
{
    return 0;
}

static PyObject *
allocate_too_many_func_watchers(PyObject *self, PyObject *args)
{
    int watcher_ids[FUNC_MAX_WATCHERS + 1];
    int num_watchers = 0;
    for (unsigned long i = 0; i < sizeof(watcher_ids) / sizeof(int); i++) {
        int watcher_id = PyFunction_AddWatcher(noop_func_event_handler);
        if (watcher_id == -1) {
            break;
        }
        watcher_ids[i] = watcher_id;
        num_watchers++;
    }
    PyObject *exc = PyErr_GetRaisedException();
    for (int i = 0; i < num_watchers; i++) {
        if (PyFunction_ClearWatcher(watcher_ids[i]) < 0) {
            PyErr_WriteUnraisable(Py_None);
            break;
        }
    }
    if (exc) {
        PyErr_SetRaisedException(exc);
        return NULL;
    }
    else if (PyErr_Occurred()) {
        return NULL;
    }
    Py_RETURN_NONE;
}

// Test contexct object watchers
#define NUM_CONTEXT_WATCHERS 2
static int context_watcher_ids[NUM_CONTEXT_WATCHERS] = {-1, -1};
static PyObject *context_switches[NUM_CONTEXT_WATCHERS];

static int
handle_context_watcher_event(int which_watcher, PyContextEvent event, PyObject *ctx) {
    if (event == Py_CONTEXT_SWITCHED) {
        PyList_Append(context_switches[which_watcher], ctx);
    }
    else {
        return -1;
    }
    return 0;
}

static int
first_context_watcher_callback(PyContextEvent event, PyObject *ctx) {
    return handle_context_watcher_event(0, event, ctx);
}

static int
second_context_watcher_callback(PyContextEvent event, PyObject *ctx) {
    return handle_context_watcher_event(1, event, ctx);
}

static int
noop_context_event_handler(PyContextEvent event, PyObject *ctx) {
    return 0;
}

static int
error_context_event_handler(PyContextEvent event, PyObject *ctx) {
    PyErr_SetString(PyExc_RuntimeError, "boom!");
    return -1;
}

static PyObject *
add_context_watcher(PyObject *self, PyObject *which_watcher)
{
    static const PyContext_WatchCallback callbacks[] = {
        &first_context_watcher_callback,
        &second_context_watcher_callback,
        &error_context_event_handler,
    };
    assert(PyLong_Check(which_watcher));
    long which_l = PyLong_AsLong(which_watcher);
    if (which_l < 0 || which_l >= (long)Py_ARRAY_LENGTH(callbacks)) {
        PyErr_Format(PyExc_ValueError, "invalid watcher %d", which_l);
        return NULL;
    }
    int watcher_id = PyContext_AddWatcher(callbacks[which_l]);
    if (watcher_id < 0) {
        return NULL;
    }
    if (which_l >= 0 && which_l < NUM_CONTEXT_WATCHERS) {
        context_watcher_ids[which_l] = watcher_id;
        Py_XSETREF(context_switches[which_l], PyList_New(0));
        if (context_switches[which_l] == NULL) {
            return NULL;
        }
    }
    return PyLong_FromLong(watcher_id);
}

static PyObject *
clear_context_watcher(PyObject *self, PyObject *watcher_id)
{
    assert(PyLong_Check(watcher_id));
    long watcher_id_l = PyLong_AsLong(watcher_id);
    if (PyContext_ClearWatcher(watcher_id_l) < 0) {
        return NULL;
    }
    // reset static events counters
    if (watcher_id_l >= 0) {
        for (int i = 0; i < NUM_CONTEXT_WATCHERS; i++) {
            if (watcher_id_l == context_watcher_ids[i]) {
                context_watcher_ids[i] = -1;
                Py_CLEAR(context_switches[i]);
            }
        }
    }
    Py_RETURN_NONE;
}

static PyObject *
clear_context_stack(PyObject *Py_UNUSED(self), PyObject *Py_UNUSED(args))
{
    PyThreadState *tstate = PyThreadState_Get();
    if (tstate->context == NULL) {
        Py_RETURN_NONE;
    }
    if (((PyContext *)tstate->context)->ctx_prev != NULL) {
        PyErr_SetString(PyExc_RuntimeError,
                        "must first exit all non-base contexts");
        return NULL;
    }
    Py_CLEAR(tstate->context);
    Py_RETURN_NONE;
}

static PyObject *
get_context_switches(PyObject *Py_UNUSED(self), PyObject *watcher_id)
{
    assert(PyLong_Check(watcher_id));
    long watcher_id_l = PyLong_AsLong(watcher_id);
    if (watcher_id_l < 0 || watcher_id_l >= NUM_CONTEXT_WATCHERS) {
        PyErr_Format(PyExc_ValueError, "invalid watcher %ld", watcher_id_l);
        return NULL;
    }
    if (context_switches[watcher_id_l] == NULL) {
        return PyList_New(0);
    }
    return Py_NewRef(context_switches[watcher_id_l]);
}

static PyObject *
allocate_too_many_context_watchers(PyObject *self, PyObject *args)
{
    int watcher_ids[CONTEXT_MAX_WATCHERS + 1];
    int num_watchers = 0;
    for (unsigned long i = 0; i < sizeof(watcher_ids) / sizeof(int); i++) {
        int watcher_id = PyContext_AddWatcher(noop_context_event_handler);
        if (watcher_id == -1) {
            break;
        }
        watcher_ids[i] = watcher_id;
        num_watchers++;
    }
    PyObject *exc = PyErr_GetRaisedException();
    for (int i = 0; i < num_watchers; i++) {
        if (PyContext_ClearWatcher(watcher_ids[i]) < 0) {
            PyErr_WriteUnraisable(Py_None);
            break;
        }
    }
    if (exc) {
        PyErr_SetRaisedException(exc);
        return NULL;
    }
    else if (PyErr_Occurred()) {
        return NULL;
    }
    Py_RETURN_NONE;
}

/*[clinic input]
_testcapi.set_func_defaults_via_capi
    func: object
    defaults: object
    /
[clinic start generated code]*/

static PyObject *
_testcapi_set_func_defaults_via_capi_impl(PyObject *module, PyObject *func,
                                          PyObject *defaults)
/*[clinic end generated code: output=caf0cb39db31ac24 input=e04a8508ca9d42fc]*/
{
    if (PyFunction_SetDefaults(func, defaults) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}

/*[clinic input]
_testcapi.set_func_kwdefaults_via_capi = _testcapi.set_func_defaults_via_capi
[clinic start generated code]*/

static PyObject *
_testcapi_set_func_kwdefaults_via_capi_impl(PyObject *module, PyObject *func,
                                            PyObject *defaults)
/*[clinic end generated code: output=9ed3b08177025070 input=f3cd1ca3c18de8ce]*/
{
    if (PyFunction_SetKwDefaults(func, defaults) < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}

static PyMethodDef test_methods[] = {
    // Dict watchers.
    {"add_dict_watcher",         add_dict_watcher,        METH_O,       NULL},
    {"clear_dict_watcher",       clear_dict_watcher,      METH_O,       NULL},
    _TESTCAPI_WATCH_DICT_METHODDEF
    _TESTCAPI_UNWATCH_DICT_METHODDEF
    {"get_dict_watcher_events",
     (PyCFunction) get_dict_watcher_events,               METH_NOARGS,  NULL},

    // Type watchers.
    {"add_type_watcher",         add_type_watcher,        METH_O,       NULL},
    {"clear_type_watcher",       clear_type_watcher,      METH_O,       NULL},
    _TESTCAPI_WATCH_TYPE_METHODDEF
    _TESTCAPI_UNWATCH_TYPE_METHODDEF
    {"get_type_modified_events",
     (PyCFunction) get_type_modified_events,              METH_NOARGS, NULL},

    // Code object watchers.
    {"add_code_watcher",         add_code_watcher,        METH_O,       NULL},
    {"clear_code_watcher",       clear_code_watcher,      METH_O,       NULL},
    {"get_code_watcher_num_created_events",
     get_code_watcher_num_created_events,                 METH_O,       NULL},
    {"get_code_watcher_num_destroyed_events",
     get_code_watcher_num_destroyed_events,               METH_O,       NULL},
    {"allocate_too_many_code_watchers",
     (PyCFunction) allocate_too_many_code_watchers,       METH_NOARGS,  NULL},

    // Function watchers.
    {"add_func_watcher",         add_func_watcher,        METH_O,       NULL},
    {"clear_func_watcher",       clear_func_watcher,      METH_O,       NULL},
    _TESTCAPI_SET_FUNC_DEFAULTS_VIA_CAPI_METHODDEF
    _TESTCAPI_SET_FUNC_KWDEFAULTS_VIA_CAPI_METHODDEF
    {"allocate_too_many_func_watchers", allocate_too_many_func_watchers,
     METH_NOARGS, NULL},

    // Code object watchers.
    {"add_context_watcher",         add_context_watcher,        METH_O,       NULL},
    {"clear_context_watcher",       clear_context_watcher,      METH_O,       NULL},
    {"clear_context_stack",      clear_context_stack,     METH_NOARGS,  NULL},
    {"get_context_switches",     get_context_switches,    METH_O,       NULL},
    {"allocate_too_many_context_watchers",
     (PyCFunction) allocate_too_many_context_watchers,       METH_NOARGS,  NULL},
    {NULL},
};

int
_PyTestCapi_Init_Watchers(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }

    /* Expose each event as an attribute on the module */
#define ADD_EVENT(event)  \
    if (add_func_event(mod, "PYFUNC_EVENT_" #event,   \
                       PyFunction_EVENT_##event)) {   \
        return -1;                                    \
    }
    PY_FOREACH_FUNC_EVENT(ADD_EVENT);
#undef ADD_EVENT

    return 0;
}


================================================
File: /Modules/_testcapi/clinic/exceptions.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

#if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)
#  include "pycore_gc.h"          // PyGC_Head
#  include "pycore_runtime.h"     // _Py_ID()
#endif
#include "pycore_modsupport.h"    // _PyArg_CheckPositional()

PyDoc_STRVAR(_testcapi_err_set_raised__doc__,
"err_set_raised($module, exception, /)\n"
"--\n"
"\n");

#define _TESTCAPI_ERR_SET_RAISED_METHODDEF    \
    {"err_set_raised", (PyCFunction)_testcapi_err_set_raised, METH_O, _testcapi_err_set_raised__doc__},

PyDoc_STRVAR(_testcapi_exception_print__doc__,
"exception_print($module, exception, legacy=False, /)\n"
"--\n"
"\n"
"To test the format of exceptions as printed out.");

#define _TESTCAPI_EXCEPTION_PRINT_METHODDEF    \
    {"exception_print", _PyCFunction_CAST(_testcapi_exception_print), METH_FASTCALL, _testcapi_exception_print__doc__},

static PyObject *
_testcapi_exception_print_impl(PyObject *module, PyObject *exc, int legacy);

static PyObject *
_testcapi_exception_print(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *exc;
    int legacy = 0;

    if (!_PyArg_CheckPositional("exception_print", nargs, 1, 2)) {
        goto exit;
    }
    exc = args[0];
    if (nargs < 2) {
        goto skip_optional;
    }
    legacy = PyObject_IsTrue(args[1]);
    if (legacy < 0) {
        goto exit;
    }
skip_optional:
    return_value = _testcapi_exception_print_impl(module, exc, legacy);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_make_exception_with_doc__doc__,
"make_exception_with_doc($module, /, name, doc=<unrepresentable>,\n"
"                        base=<unrepresentable>, dict=<unrepresentable>)\n"
"--\n"
"\n"
"Test PyErr_NewExceptionWithDoc (also exercise PyErr_NewException). Run via Lib/test/test_exceptions.py");

#define _TESTCAPI_MAKE_EXCEPTION_WITH_DOC_METHODDEF    \
    {"make_exception_with_doc", _PyCFunction_CAST(_testcapi_make_exception_with_doc), METH_FASTCALL|METH_KEYWORDS, _testcapi_make_exception_with_doc__doc__},

static PyObject *
_testcapi_make_exception_with_doc_impl(PyObject *module, const char *name,
                                       const char *doc, PyObject *base,
                                       PyObject *dict);

static PyObject *
_testcapi_make_exception_with_doc(PyObject *module, PyObject *const *args, Py_ssize_t nargs, PyObject *kwnames)
{
    PyObject *return_value = NULL;
    #if defined(Py_BUILD_CORE) && !defined(Py_BUILD_CORE_MODULE)

    #define NUM_KEYWORDS 4
    static struct {
        PyGC_Head _this_is_not_used;
        PyObject_VAR_HEAD
        PyObject *ob_item[NUM_KEYWORDS];
    } _kwtuple = {
        .ob_base = PyVarObject_HEAD_INIT(&PyTuple_Type, NUM_KEYWORDS)
        .ob_item = { &_Py_ID(name), &_Py_ID(doc), &_Py_ID(base), &_Py_ID(dict), },
    };
    #undef NUM_KEYWORDS
    #define KWTUPLE (&_kwtuple.ob_base.ob_base)

    #else  // !Py_BUILD_CORE
    #  define KWTUPLE NULL
    #endif  // !Py_BUILD_CORE

    static const char * const _keywords[] = {"name", "doc", "base", "dict", NULL};
    static _PyArg_Parser _parser = {
        .keywords = _keywords,
        .fname = "make_exception_with_doc",
        .kwtuple = KWTUPLE,
    };
    #undef KWTUPLE
    PyObject *argsbuf[4];
    Py_ssize_t noptargs = nargs + (kwnames ? PyTuple_GET_SIZE(kwnames) : 0) - 1;
    const char *name;
    const char *doc = NULL;
    PyObject *base = NULL;
    PyObject *dict = NULL;

    args = _PyArg_UnpackKeywords(args, nargs, NULL, kwnames, &_parser,
            /*minpos*/ 1, /*maxpos*/ 4, /*minkw*/ 0, /*varpos*/ 0, argsbuf);
    if (!args) {
        goto exit;
    }
    if (!PyUnicode_Check(args[0])) {
        _PyArg_BadArgument("make_exception_with_doc", "argument 'name'", "str", args[0]);
        goto exit;
    }
    Py_ssize_t name_length;
    name = PyUnicode_AsUTF8AndSize(args[0], &name_length);
    if (name == NULL) {
        goto exit;
    }
    if (strlen(name) != (size_t)name_length) {
        PyErr_SetString(PyExc_ValueError, "embedded null character");
        goto exit;
    }
    if (!noptargs) {
        goto skip_optional_pos;
    }
    if (args[1]) {
        if (!PyUnicode_Check(args[1])) {
            _PyArg_BadArgument("make_exception_with_doc", "argument 'doc'", "str", args[1]);
            goto exit;
        }
        Py_ssize_t doc_length;
        doc = PyUnicode_AsUTF8AndSize(args[1], &doc_length);
        if (doc == NULL) {
            goto exit;
        }
        if (strlen(doc) != (size_t)doc_length) {
            PyErr_SetString(PyExc_ValueError, "embedded null character");
            goto exit;
        }
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    if (args[2]) {
        base = args[2];
        if (!--noptargs) {
            goto skip_optional_pos;
        }
    }
    dict = args[3];
skip_optional_pos:
    return_value = _testcapi_make_exception_with_doc_impl(module, name, doc, base, dict);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_exc_set_object__doc__,
"exc_set_object($module, exception, obj, /)\n"
"--\n"
"\n");

#define _TESTCAPI_EXC_SET_OBJECT_METHODDEF    \
    {"exc_set_object", _PyCFunction_CAST(_testcapi_exc_set_object), METH_FASTCALL, _testcapi_exc_set_object__doc__},

static PyObject *
_testcapi_exc_set_object_impl(PyObject *module, PyObject *exc, PyObject *obj);

static PyObject *
_testcapi_exc_set_object(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *exc;
    PyObject *obj;

    if (!_PyArg_CheckPositional("exc_set_object", nargs, 2, 2)) {
        goto exit;
    }
    exc = args[0];
    obj = args[1];
    return_value = _testcapi_exc_set_object_impl(module, exc, obj);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_exc_set_object_fetch__doc__,
"exc_set_object_fetch($module, exception, obj, /)\n"
"--\n"
"\n");

#define _TESTCAPI_EXC_SET_OBJECT_FETCH_METHODDEF    \
    {"exc_set_object_fetch", _PyCFunction_CAST(_testcapi_exc_set_object_fetch), METH_FASTCALL, _testcapi_exc_set_object_fetch__doc__},

static PyObject *
_testcapi_exc_set_object_fetch_impl(PyObject *module, PyObject *exc,
                                    PyObject *obj);

static PyObject *
_testcapi_exc_set_object_fetch(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *exc;
    PyObject *obj;

    if (!_PyArg_CheckPositional("exc_set_object_fetch", nargs, 2, 2)) {
        goto exit;
    }
    exc = args[0];
    obj = args[1];
    return_value = _testcapi_exc_set_object_fetch_impl(module, exc, obj);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_err_setstring__doc__,
"err_setstring($module, exc, value, /)\n"
"--\n"
"\n");

#define _TESTCAPI_ERR_SETSTRING_METHODDEF    \
    {"err_setstring", _PyCFunction_CAST(_testcapi_err_setstring), METH_FASTCALL, _testcapi_err_setstring__doc__},

static PyObject *
_testcapi_err_setstring_impl(PyObject *module, PyObject *exc,
                             const char *value, Py_ssize_t value_length);

static PyObject *
_testcapi_err_setstring(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *exc;
    const char *value;
    Py_ssize_t value_length;

    if (!_PyArg_ParseStack(args, nargs, "Oz#:err_setstring",
        &exc, &value, &value_length)) {
        goto exit;
    }
    return_value = _testcapi_err_setstring_impl(module, exc, value, value_length);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_err_setfromerrnowithfilename__doc__,
"err_setfromerrnowithfilename($module, error, exc, value, /)\n"
"--\n"
"\n");

#define _TESTCAPI_ERR_SETFROMERRNOWITHFILENAME_METHODDEF    \
    {"err_setfromerrnowithfilename", _PyCFunction_CAST(_testcapi_err_setfromerrnowithfilename), METH_FASTCALL, _testcapi_err_setfromerrnowithfilename__doc__},

static PyObject *
_testcapi_err_setfromerrnowithfilename_impl(PyObject *module, int error,
                                            PyObject *exc, const char *value,
                                            Py_ssize_t value_length);

static PyObject *
_testcapi_err_setfromerrnowithfilename(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    int error;
    PyObject *exc;
    const char *value;
    Py_ssize_t value_length;

    if (!_PyArg_ParseStack(args, nargs, "iOz#:err_setfromerrnowithfilename",
        &error, &exc, &value, &value_length)) {
        goto exit;
    }
    return_value = _testcapi_err_setfromerrnowithfilename_impl(module, error, exc, value, value_length);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_raise_exception__doc__,
"raise_exception($module, exception, num_args, /)\n"
"--\n"
"\n");

#define _TESTCAPI_RAISE_EXCEPTION_METHODDEF    \
    {"raise_exception", _PyCFunction_CAST(_testcapi_raise_exception), METH_FASTCALL, _testcapi_raise_exception__doc__},

static PyObject *
_testcapi_raise_exception_impl(PyObject *module, PyObject *exc, int num_args);

static PyObject *
_testcapi_raise_exception(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *exc;
    int num_args;

    if (!_PyArg_CheckPositional("raise_exception", nargs, 2, 2)) {
        goto exit;
    }
    exc = args[0];
    num_args = PyLong_AsInt(args[1]);
    if (num_args == -1 && PyErr_Occurred()) {
        goto exit;
    }
    return_value = _testcapi_raise_exception_impl(module, exc, num_args);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_raise_memoryerror__doc__,
"raise_memoryerror($module, /)\n"
"--\n"
"\n");

#define _TESTCAPI_RAISE_MEMORYERROR_METHODDEF    \
    {"raise_memoryerror", (PyCFunction)_testcapi_raise_memoryerror, METH_NOARGS, _testcapi_raise_memoryerror__doc__},

static PyObject *
_testcapi_raise_memoryerror_impl(PyObject *module);

static PyObject *
_testcapi_raise_memoryerror(PyObject *module, PyObject *Py_UNUSED(ignored))
{
    return _testcapi_raise_memoryerror_impl(module);
}

PyDoc_STRVAR(_testcapi_fatal_error__doc__,
"fatal_error($module, message, release_gil=False, /)\n"
"--\n"
"\n");

#define _TESTCAPI_FATAL_ERROR_METHODDEF    \
    {"fatal_error", _PyCFunction_CAST(_testcapi_fatal_error), METH_FASTCALL, _testcapi_fatal_error__doc__},

static PyObject *
_testcapi_fatal_error_impl(PyObject *module, const char *message,
                           int release_gil);

static PyObject *
_testcapi_fatal_error(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    const char *message;
    int release_gil = 0;

    if (!_PyArg_ParseStack(args, nargs, "y|p:fatal_error",
        &message, &release_gil)) {
        goto exit;
    }
    return_value = _testcapi_fatal_error_impl(module, message, release_gil);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_set_exc_info__doc__,
"set_exc_info($module, new_type, new_value, new_tb, /)\n"
"--\n"
"\n");

#define _TESTCAPI_SET_EXC_INFO_METHODDEF    \
    {"set_exc_info", _PyCFunction_CAST(_testcapi_set_exc_info), METH_FASTCALL, _testcapi_set_exc_info__doc__},

static PyObject *
_testcapi_set_exc_info_impl(PyObject *module, PyObject *new_type,
                            PyObject *new_value, PyObject *new_tb);

static PyObject *
_testcapi_set_exc_info(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *new_type;
    PyObject *new_value;
    PyObject *new_tb;

    if (!_PyArg_CheckPositional("set_exc_info", nargs, 3, 3)) {
        goto exit;
    }
    new_type = args[0];
    new_value = args[1];
    new_tb = args[2];
    return_value = _testcapi_set_exc_info_impl(module, new_type, new_value, new_tb);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_set_exception__doc__,
"set_exception($module, new_exc, /)\n"
"--\n"
"\n");

#define _TESTCAPI_SET_EXCEPTION_METHODDEF    \
    {"set_exception", (PyCFunction)_testcapi_set_exception, METH_O, _testcapi_set_exception__doc__},

PyDoc_STRVAR(_testcapi_traceback_print__doc__,
"traceback_print($module, traceback, file, /)\n"
"--\n"
"\n"
"To test the format of tracebacks as printed out.");

#define _TESTCAPI_TRACEBACK_PRINT_METHODDEF    \
    {"traceback_print", _PyCFunction_CAST(_testcapi_traceback_print), METH_FASTCALL, _testcapi_traceback_print__doc__},

static PyObject *
_testcapi_traceback_print_impl(PyObject *module, PyObject *traceback,
                               PyObject *file);

static PyObject *
_testcapi_traceback_print(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *traceback;
    PyObject *file;

    if (!_PyArg_CheckPositional("traceback_print", nargs, 2, 2)) {
        goto exit;
    }
    traceback = args[0];
    file = args[1];
    return_value = _testcapi_traceback_print_impl(module, traceback, file);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_unstable_exc_prep_reraise_star__doc__,
"unstable_exc_prep_reraise_star($module, orig, excs, /)\n"
"--\n"
"\n"
"To test PyUnstable_Exc_PrepReraiseStar.");

#define _TESTCAPI_UNSTABLE_EXC_PREP_RERAISE_STAR_METHODDEF    \
    {"unstable_exc_prep_reraise_star", _PyCFunction_CAST(_testcapi_unstable_exc_prep_reraise_star), METH_FASTCALL, _testcapi_unstable_exc_prep_reraise_star__doc__},

static PyObject *
_testcapi_unstable_exc_prep_reraise_star_impl(PyObject *module,
                                              PyObject *orig, PyObject *excs);

static PyObject *
_testcapi_unstable_exc_prep_reraise_star(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *orig;
    PyObject *excs;

    if (!_PyArg_CheckPositional("unstable_exc_prep_reraise_star", nargs, 2, 2)) {
        goto exit;
    }
    orig = args[0];
    excs = args[1];
    return_value = _testcapi_unstable_exc_prep_reraise_star_impl(module, orig, excs);

exit:
    return return_value;
}
/*[clinic end generated code: output=d917e9ec082e69ee input=a9049054013a1b77]*/


================================================
File: /Modules/_testcapi/clinic/file.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

#include "pycore_modsupport.h"    // _PyArg_CheckPositional()

PyDoc_STRVAR(_testcapi_py_fopen__doc__,
"py_fopen($module, path, mode, /)\n"
"--\n"
"\n"
"Call Py_fopen(), fread(256) and Py_fclose(). Return read bytes.");

#define _TESTCAPI_PY_FOPEN_METHODDEF    \
    {"py_fopen", _PyCFunction_CAST(_testcapi_py_fopen), METH_FASTCALL, _testcapi_py_fopen__doc__},

static PyObject *
_testcapi_py_fopen_impl(PyObject *module, PyObject *path, const char *mode,
                        Py_ssize_t mode_length);

static PyObject *
_testcapi_py_fopen(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *path;
    const char *mode;
    Py_ssize_t mode_length;

    if (!_PyArg_ParseStack(args, nargs, "Oz#:py_fopen",
        &path, &mode, &mode_length)) {
        goto exit;
    }
    return_value = _testcapi_py_fopen_impl(module, path, mode, mode_length);

exit:
    return return_value;
}
/*[clinic end generated code: output=c4dc92400306c3eb input=a9049054013a1b77]*/


================================================
File: /Modules/_testcapi/clinic/float.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

#include "pycore_modsupport.h"    // _PyArg_CheckPositional()

PyDoc_STRVAR(_testcapi_float_pack__doc__,
"float_pack($module, size, d, le, /)\n"
"--\n"
"\n"
"Test PyFloat_Pack2(), PyFloat_Pack4() and PyFloat_Pack8()");

#define _TESTCAPI_FLOAT_PACK_METHODDEF    \
    {"float_pack", _PyCFunction_CAST(_testcapi_float_pack), METH_FASTCALL, _testcapi_float_pack__doc__},

static PyObject *
_testcapi_float_pack_impl(PyObject *module, int size, double d, int le);

static PyObject *
_testcapi_float_pack(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    int size;
    double d;
    int le;

    if (!_PyArg_CheckPositional("float_pack", nargs, 3, 3)) {
        goto exit;
    }
    size = PyLong_AsInt(args[0]);
    if (size == -1 && PyErr_Occurred()) {
        goto exit;
    }
    if (PyFloat_CheckExact(args[1])) {
        d = PyFloat_AS_DOUBLE(args[1]);
    }
    else
    {
        d = PyFloat_AsDouble(args[1]);
        if (d == -1.0 && PyErr_Occurred()) {
            goto exit;
        }
    }
    le = PyLong_AsInt(args[2]);
    if (le == -1 && PyErr_Occurred()) {
        goto exit;
    }
    return_value = _testcapi_float_pack_impl(module, size, d, le);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_float_unpack__doc__,
"float_unpack($module, data, le, /)\n"
"--\n"
"\n"
"Test PyFloat_Unpack2(), PyFloat_Unpack4() and PyFloat_Unpack8()");

#define _TESTCAPI_FLOAT_UNPACK_METHODDEF    \
    {"float_unpack", _PyCFunction_CAST(_testcapi_float_unpack), METH_FASTCALL, _testcapi_float_unpack__doc__},

static PyObject *
_testcapi_float_unpack_impl(PyObject *module, const char *data,
                            Py_ssize_t data_length, int le);

static PyObject *
_testcapi_float_unpack(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    const char *data;
    Py_ssize_t data_length;
    int le;

    if (!_PyArg_ParseStack(args, nargs, "y#i:float_unpack",
        &data, &data_length, &le)) {
        goto exit;
    }
    return_value = _testcapi_float_unpack_impl(module, data, data_length, le);

exit:
    return return_value;
}
/*[clinic end generated code: output=b43dfd3a77fe04ba input=a9049054013a1b77]*/


================================================
File: /Modules/_testcapi/clinic/long.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

PyDoc_STRVAR(_testcapi_call_long_compact_api__doc__,
"call_long_compact_api($module, arg, /)\n"
"--\n"
"\n");

#define _TESTCAPI_CALL_LONG_COMPACT_API_METHODDEF    \
    {"call_long_compact_api", (PyCFunction)_testcapi_call_long_compact_api, METH_O, _testcapi_call_long_compact_api__doc__},
/*[clinic end generated code: output=0ddcbc6ea06e5e21 input=a9049054013a1b77]*/


================================================
File: /Modules/_testcapi/clinic/vectorcall.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

#include "pycore_modsupport.h"    // _PyArg_CheckPositional()

PyDoc_STRVAR(_testcapi_pyobject_fastcalldict__doc__,
"pyobject_fastcalldict($module, func, func_args, kwargs, /)\n"
"--\n"
"\n");

#define _TESTCAPI_PYOBJECT_FASTCALLDICT_METHODDEF    \
    {"pyobject_fastcalldict", _PyCFunction_CAST(_testcapi_pyobject_fastcalldict), METH_FASTCALL, _testcapi_pyobject_fastcalldict__doc__},

static PyObject *
_testcapi_pyobject_fastcalldict_impl(PyObject *module, PyObject *func,
                                     PyObject *func_args, PyObject *kwargs);

static PyObject *
_testcapi_pyobject_fastcalldict(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *func;
    PyObject *func_args;
    PyObject *__clinic_kwargs;

    if (!_PyArg_CheckPositional("pyobject_fastcalldict", nargs, 3, 3)) {
        goto exit;
    }
    func = args[0];
    func_args = args[1];
    __clinic_kwargs = args[2];
    return_value = _testcapi_pyobject_fastcalldict_impl(module, func, func_args, __clinic_kwargs);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_pyobject_vectorcall__doc__,
"pyobject_vectorcall($module, func, func_args, kwnames, /)\n"
"--\n"
"\n");

#define _TESTCAPI_PYOBJECT_VECTORCALL_METHODDEF    \
    {"pyobject_vectorcall", _PyCFunction_CAST(_testcapi_pyobject_vectorcall), METH_FASTCALL, _testcapi_pyobject_vectorcall__doc__},

static PyObject *
_testcapi_pyobject_vectorcall_impl(PyObject *module, PyObject *func,
                                   PyObject *func_args, PyObject *kwnames);

static PyObject *
_testcapi_pyobject_vectorcall(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *func;
    PyObject *func_args;
    PyObject *__clinic_kwnames;

    if (!_PyArg_CheckPositional("pyobject_vectorcall", nargs, 3, 3)) {
        goto exit;
    }
    func = args[0];
    func_args = args[1];
    __clinic_kwnames = args[2];
    return_value = _testcapi_pyobject_vectorcall_impl(module, func, func_args, __clinic_kwnames);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_pyvectorcall_call__doc__,
"pyvectorcall_call($module, func, argstuple, kwargs=<unrepresentable>, /)\n"
"--\n"
"\n");

#define _TESTCAPI_PYVECTORCALL_CALL_METHODDEF    \
    {"pyvectorcall_call", _PyCFunction_CAST(_testcapi_pyvectorcall_call), METH_FASTCALL, _testcapi_pyvectorcall_call__doc__},

static PyObject *
_testcapi_pyvectorcall_call_impl(PyObject *module, PyObject *func,
                                 PyObject *argstuple, PyObject *kwargs);

static PyObject *
_testcapi_pyvectorcall_call(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *func;
    PyObject *argstuple;
    PyObject *__clinic_kwargs = NULL;

    if (!_PyArg_CheckPositional("pyvectorcall_call", nargs, 2, 3)) {
        goto exit;
    }
    func = args[0];
    argstuple = args[1];
    if (nargs < 3) {
        goto skip_optional;
    }
    __clinic_kwargs = args[2];
skip_optional:
    return_value = _testcapi_pyvectorcall_call_impl(module, func, argstuple, __clinic_kwargs);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_VectorCallClass_set_vectorcall__doc__,
"set_vectorcall($self, type, /)\n"
"--\n"
"\n"
"Set self\'s vectorcall function for `type` to one that returns \"vectorcall\"");

#define _TESTCAPI_VECTORCALLCLASS_SET_VECTORCALL_METHODDEF    \
    {"set_vectorcall", (PyCFunction)_testcapi_VectorCallClass_set_vectorcall, METH_O, _testcapi_VectorCallClass_set_vectorcall__doc__},

static PyObject *
_testcapi_VectorCallClass_set_vectorcall_impl(PyObject *self,
                                              PyTypeObject *type);

static PyObject *
_testcapi_VectorCallClass_set_vectorcall(PyObject *self, PyObject *arg)
{
    PyObject *return_value = NULL;
    PyTypeObject *type;

    if (!PyObject_TypeCheck(arg, &PyType_Type)) {
        _PyArg_BadArgument("set_vectorcall", "argument", (&PyType_Type)->tp_name, arg);
        goto exit;
    }
    type = (PyTypeObject *)arg;
    return_value = _testcapi_VectorCallClass_set_vectorcall_impl(self, type);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_make_vectorcall_class__doc__,
"make_vectorcall_class($module, base=<unrepresentable>, /)\n"
"--\n"
"\n"
"Create a class whose instances return \"tpcall\" when called.\n"
"\n"
"When the \"set_vectorcall\" method is called on an instance, a vectorcall\n"
"function that returns \"vectorcall\" will be installed.");

#define _TESTCAPI_MAKE_VECTORCALL_CLASS_METHODDEF    \
    {"make_vectorcall_class", _PyCFunction_CAST(_testcapi_make_vectorcall_class), METH_FASTCALL, _testcapi_make_vectorcall_class__doc__},

static PyObject *
_testcapi_make_vectorcall_class_impl(PyObject *module, PyTypeObject *base);

static PyObject *
_testcapi_make_vectorcall_class(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyTypeObject *base = NULL;

    if (!_PyArg_CheckPositional("make_vectorcall_class", nargs, 0, 1)) {
        goto exit;
    }
    if (nargs < 1) {
        goto skip_optional;
    }
    if (!PyObject_TypeCheck(args[0], &PyType_Type)) {
        _PyArg_BadArgument("make_vectorcall_class", "argument 1", (&PyType_Type)->tp_name, args[0]);
        goto exit;
    }
    base = (PyTypeObject *)args[0];
skip_optional:
    return_value = _testcapi_make_vectorcall_class_impl(module, base);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_has_vectorcall_flag__doc__,
"has_vectorcall_flag($module, type, /)\n"
"--\n"
"\n"
"Return true iff Py_TPFLAGS_HAVE_VECTORCALL is set on the class.");

#define _TESTCAPI_HAS_VECTORCALL_FLAG_METHODDEF    \
    {"has_vectorcall_flag", (PyCFunction)_testcapi_has_vectorcall_flag, METH_O, _testcapi_has_vectorcall_flag__doc__},

static int
_testcapi_has_vectorcall_flag_impl(PyObject *module, PyTypeObject *type);

static PyObject *
_testcapi_has_vectorcall_flag(PyObject *module, PyObject *arg)
{
    PyObject *return_value = NULL;
    PyTypeObject *type;
    int _return_value;

    if (!PyObject_TypeCheck(arg, &PyType_Type)) {
        _PyArg_BadArgument("has_vectorcall_flag", "argument", (&PyType_Type)->tp_name, arg);
        goto exit;
    }
    type = (PyTypeObject *)arg;
    _return_value = _testcapi_has_vectorcall_flag_impl(module, type);
    if ((_return_value == -1) && PyErr_Occurred()) {
        goto exit;
    }
    return_value = PyBool_FromLong((long)_return_value);

exit:
    return return_value;
}
/*[clinic end generated code: output=210ae67caab177ba input=a9049054013a1b77]*/


================================================
File: /Modules/_testcapi/clinic/watchers.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

#include "pycore_modsupport.h"    // _PyArg_CheckPositional()

PyDoc_STRVAR(_testcapi_watch_dict__doc__,
"watch_dict($module, watcher_id, dict, /)\n"
"--\n"
"\n");

#define _TESTCAPI_WATCH_DICT_METHODDEF    \
    {"watch_dict", _PyCFunction_CAST(_testcapi_watch_dict), METH_FASTCALL, _testcapi_watch_dict__doc__},

static PyObject *
_testcapi_watch_dict_impl(PyObject *module, int watcher_id, PyObject *dict);

static PyObject *
_testcapi_watch_dict(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    int watcher_id;
    PyObject *dict;

    if (!_PyArg_CheckPositional("watch_dict", nargs, 2, 2)) {
        goto exit;
    }
    watcher_id = PyLong_AsInt(args[0]);
    if (watcher_id == -1 && PyErr_Occurred()) {
        goto exit;
    }
    dict = args[1];
    return_value = _testcapi_watch_dict_impl(module, watcher_id, dict);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_unwatch_dict__doc__,
"unwatch_dict($module, watcher_id, dict, /)\n"
"--\n"
"\n");

#define _TESTCAPI_UNWATCH_DICT_METHODDEF    \
    {"unwatch_dict", _PyCFunction_CAST(_testcapi_unwatch_dict), METH_FASTCALL, _testcapi_unwatch_dict__doc__},

static PyObject *
_testcapi_unwatch_dict_impl(PyObject *module, int watcher_id, PyObject *dict);

static PyObject *
_testcapi_unwatch_dict(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    int watcher_id;
    PyObject *dict;

    if (!_PyArg_CheckPositional("unwatch_dict", nargs, 2, 2)) {
        goto exit;
    }
    watcher_id = PyLong_AsInt(args[0]);
    if (watcher_id == -1 && PyErr_Occurred()) {
        goto exit;
    }
    dict = args[1];
    return_value = _testcapi_unwatch_dict_impl(module, watcher_id, dict);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_watch_type__doc__,
"watch_type($module, watcher_id, type, /)\n"
"--\n"
"\n");

#define _TESTCAPI_WATCH_TYPE_METHODDEF    \
    {"watch_type", _PyCFunction_CAST(_testcapi_watch_type), METH_FASTCALL, _testcapi_watch_type__doc__},

static PyObject *
_testcapi_watch_type_impl(PyObject *module, int watcher_id, PyObject *type);

static PyObject *
_testcapi_watch_type(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    int watcher_id;
    PyObject *type;

    if (!_PyArg_CheckPositional("watch_type", nargs, 2, 2)) {
        goto exit;
    }
    watcher_id = PyLong_AsInt(args[0]);
    if (watcher_id == -1 && PyErr_Occurred()) {
        goto exit;
    }
    type = args[1];
    return_value = _testcapi_watch_type_impl(module, watcher_id, type);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_unwatch_type__doc__,
"unwatch_type($module, watcher_id, type, /)\n"
"--\n"
"\n");

#define _TESTCAPI_UNWATCH_TYPE_METHODDEF    \
    {"unwatch_type", _PyCFunction_CAST(_testcapi_unwatch_type), METH_FASTCALL, _testcapi_unwatch_type__doc__},

static PyObject *
_testcapi_unwatch_type_impl(PyObject *module, int watcher_id, PyObject *type);

static PyObject *
_testcapi_unwatch_type(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    int watcher_id;
    PyObject *type;

    if (!_PyArg_CheckPositional("unwatch_type", nargs, 2, 2)) {
        goto exit;
    }
    watcher_id = PyLong_AsInt(args[0]);
    if (watcher_id == -1 && PyErr_Occurred()) {
        goto exit;
    }
    type = args[1];
    return_value = _testcapi_unwatch_type_impl(module, watcher_id, type);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_set_func_defaults_via_capi__doc__,
"set_func_defaults_via_capi($module, func, defaults, /)\n"
"--\n"
"\n");

#define _TESTCAPI_SET_FUNC_DEFAULTS_VIA_CAPI_METHODDEF    \
    {"set_func_defaults_via_capi", _PyCFunction_CAST(_testcapi_set_func_defaults_via_capi), METH_FASTCALL, _testcapi_set_func_defaults_via_capi__doc__},

static PyObject *
_testcapi_set_func_defaults_via_capi_impl(PyObject *module, PyObject *func,
                                          PyObject *defaults);

static PyObject *
_testcapi_set_func_defaults_via_capi(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *func;
    PyObject *defaults;

    if (!_PyArg_CheckPositional("set_func_defaults_via_capi", nargs, 2, 2)) {
        goto exit;
    }
    func = args[0];
    defaults = args[1];
    return_value = _testcapi_set_func_defaults_via_capi_impl(module, func, defaults);

exit:
    return return_value;
}

PyDoc_STRVAR(_testcapi_set_func_kwdefaults_via_capi__doc__,
"set_func_kwdefaults_via_capi($module, func, defaults, /)\n"
"--\n"
"\n");

#define _TESTCAPI_SET_FUNC_KWDEFAULTS_VIA_CAPI_METHODDEF    \
    {"set_func_kwdefaults_via_capi", _PyCFunction_CAST(_testcapi_set_func_kwdefaults_via_capi), METH_FASTCALL, _testcapi_set_func_kwdefaults_via_capi__doc__},

static PyObject *
_testcapi_set_func_kwdefaults_via_capi_impl(PyObject *module, PyObject *func,
                                            PyObject *defaults);

static PyObject *
_testcapi_set_func_kwdefaults_via_capi(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    PyObject *func;
    PyObject *defaults;

    if (!_PyArg_CheckPositional("set_func_kwdefaults_via_capi", nargs, 2, 2)) {
        goto exit;
    }
    func = args[0];
    defaults = args[1];
    return_value = _testcapi_set_func_kwdefaults_via_capi_impl(module, func, defaults);

exit:
    return return_value;
}
/*[clinic end generated code: output=0e07ce7f295917a5 input=a9049054013a1b77]*/


================================================
File: /Modules/_testinternalcapi/README.txt
================================================
Tests in this directory are compiled into the _testinternalcapi extension.
The main file for the extension is Modules/_testinternalcapimodule.c, which
calls `_PyTestInternalCapi_Init_*` from these functions.

See Modules/_testcapi/README.txt for guideline when writing C test code.

================================================
File: /Modules/_testinternalcapi/parts.h
================================================
#ifndef Py_TESTINTERNALCAPI_PARTS_H
#define Py_TESTINTERNALCAPI_PARTS_H

// Always enable assertions
#undef NDEBUG

#ifndef Py_BUILD_CORE_BUILTIN
#  define Py_BUILD_CORE_MODULE 1
#endif

#include "Python.h"

int _PyTestInternalCapi_Init_Lock(PyObject *module);
int _PyTestInternalCapi_Init_PyTime(PyObject *module);
int _PyTestInternalCapi_Init_Set(PyObject *module);
int _PyTestInternalCapi_Init_CriticalSection(PyObject *module);

#endif // Py_TESTINTERNALCAPI_PARTS_H


================================================
File: /Modules/_testinternalcapi/pytime.c
================================================
/* Test pycore_time.h */

#include "parts.h"

#include "pycore_time.h"          // _PyTime_FromSeconds()

#ifdef MS_WINDOWS
#  include <winsock2.h>           // struct timeval
#endif


static PyObject *
test_pytime_fromseconds(PyObject *self, PyObject *args)
{
    int seconds;
    if (!PyArg_ParseTuple(args, "i", &seconds)) {
        return NULL;
    }
    PyTime_t ts = _PyTime_FromSeconds(seconds);
    return _PyTime_AsLong(ts);
}

static int
check_time_rounding(int round)
{
    if (round != _PyTime_ROUND_FLOOR
        && round != _PyTime_ROUND_CEILING
        && round != _PyTime_ROUND_HALF_EVEN
        && round != _PyTime_ROUND_UP)
    {
        PyErr_SetString(PyExc_ValueError, "invalid rounding");
        return -1;
    }
    return 0;
}

static PyObject *
test_pytime_fromsecondsobject(PyObject *self, PyObject *args)
{
    PyObject *obj;
    int round;
    if (!PyArg_ParseTuple(args, "Oi", &obj, &round)) {
        return NULL;
    }
    if (check_time_rounding(round) < 0) {
        return NULL;
    }
    PyTime_t ts;
    if (_PyTime_FromSecondsObject(&ts, obj, round) == -1) {
        return NULL;
    }
    return _PyTime_AsLong(ts);
}

static PyObject *
test_PyTime_AsTimeval(PyObject *self, PyObject *args)
{
    PyObject *obj;
    int round;
    if (!PyArg_ParseTuple(args, "Oi", &obj, &round)) {
        return NULL;
    }
    if (check_time_rounding(round) < 0) {
        return NULL;
    }
    PyTime_t t;
    if (_PyTime_FromLong(&t, obj) < 0) {
        return NULL;
    }
    struct timeval tv;
    if (_PyTime_AsTimeval(t, &tv, round) < 0) {
        return NULL;
    }

    PyObject *seconds = PyLong_FromLongLong(tv.tv_sec);
    if (seconds == NULL) {
        return NULL;
    }
    return Py_BuildValue("Nl", seconds, (long)tv.tv_usec);
}

static PyObject *
test_PyTime_AsTimeval_clamp(PyObject *self, PyObject *args)
{
    PyObject *obj;
    int round;
    if (!PyArg_ParseTuple(args, "Oi", &obj, &round)) {
        return NULL;
    }
    if (check_time_rounding(round) < 0) {
        return NULL;
    }
    PyTime_t t;
    if (_PyTime_FromLong(&t, obj) < 0) {
        return NULL;
    }
    struct timeval tv;
    _PyTime_AsTimeval_clamp(t, &tv, round);

    PyObject *seconds = PyLong_FromLongLong(tv.tv_sec);
    if (seconds == NULL) {
        return NULL;
    }
    return Py_BuildValue("Nl", seconds, (long)tv.tv_usec);
}

#ifdef HAVE_CLOCK_GETTIME
static PyObject *
test_PyTime_AsTimespec(PyObject *self, PyObject *args)
{
    PyObject *obj;
    if (!PyArg_ParseTuple(args, "O", &obj)) {
        return NULL;
    }
    PyTime_t t;
    if (_PyTime_FromLong(&t, obj) < 0) {
        return NULL;
    }
    struct timespec ts;
    if (_PyTime_AsTimespec(t, &ts) == -1) {
        return NULL;
    }
    return Py_BuildValue("Nl", _PyLong_FromTime_t(ts.tv_sec), ts.tv_nsec);
}

static PyObject *
test_PyTime_AsTimespec_clamp(PyObject *self, PyObject *args)
{
    PyObject *obj;
    if (!PyArg_ParseTuple(args, "O", &obj)) {
        return NULL;
    }
    PyTime_t t;
    if (_PyTime_FromLong(&t, obj) < 0) {
        return NULL;
    }
    struct timespec ts;
    _PyTime_AsTimespec_clamp(t, &ts);
    return Py_BuildValue("Nl", _PyLong_FromTime_t(ts.tv_sec), ts.tv_nsec);
}
#endif

static PyObject *
test_PyTime_AsMilliseconds(PyObject *self, PyObject *args)
{
    PyObject *obj;
    int round;
    if (!PyArg_ParseTuple(args, "Oi", &obj, &round)) {
        return NULL;
    }
    PyTime_t t;
    if (_PyTime_FromLong(&t, obj) < 0) {
        return NULL;
    }
    if (check_time_rounding(round) < 0) {
        return NULL;
    }
    PyTime_t ms = _PyTime_AsMilliseconds(t, round);
    return _PyTime_AsLong(ms);
}

static PyObject *
test_PyTime_AsMicroseconds(PyObject *self, PyObject *args)
{
    PyObject *obj;
    int round;
    if (!PyArg_ParseTuple(args, "Oi", &obj, &round)) {
        return NULL;
    }
    PyTime_t t;
    if (_PyTime_FromLong(&t, obj) < 0) {
        return NULL;
    }
    if (check_time_rounding(round) < 0) {
        return NULL;
    }
    PyTime_t us = _PyTime_AsMicroseconds(t, round);
    return _PyTime_AsLong(us);
}

static PyObject *
test_pytime_object_to_time_t(PyObject *self, PyObject *args)
{
    PyObject *obj;
    time_t sec;
    int round;
    if (!PyArg_ParseTuple(args, "Oi", &obj, &round)) {
        return NULL;
    }
    if (check_time_rounding(round) < 0) {
        return NULL;
    }
    if (_PyTime_ObjectToTime_t(obj, &sec, round) == -1) {
        return NULL;
    }
    return _PyLong_FromTime_t(sec);
}

static PyObject *
test_pytime_object_to_timeval(PyObject *self, PyObject *args)
{
    PyObject *obj;
    time_t sec;
    long usec;
    int round;
    if (!PyArg_ParseTuple(args, "Oi", &obj, &round)) {
        return NULL;
    }
    if (check_time_rounding(round) < 0) {
        return NULL;
    }
    if (_PyTime_ObjectToTimeval(obj, &sec, &usec, round) == -1) {
        return NULL;
    }
    return Py_BuildValue("Nl", _PyLong_FromTime_t(sec), usec);
}

static PyObject *
test_pytime_object_to_timespec(PyObject *self, PyObject *args)
{
    PyObject *obj;
    time_t sec;
    long nsec;
    int round;
    if (!PyArg_ParseTuple(args, "Oi", &obj, &round)) {
        return NULL;
    }
    if (check_time_rounding(round) < 0) {
        return NULL;
    }
    if (_PyTime_ObjectToTimespec(obj, &sec, &nsec, round) == -1) {
        return NULL;
    }
    return Py_BuildValue("Nl", _PyLong_FromTime_t(sec), nsec);
}

static PyMethodDef TestMethods[] = {
    {"_PyTime_AsMicroseconds",    test_PyTime_AsMicroseconds,     METH_VARARGS},
    {"_PyTime_AsMilliseconds",    test_PyTime_AsMilliseconds,     METH_VARARGS},
#ifdef HAVE_CLOCK_GETTIME
    {"_PyTime_AsTimespec",        test_PyTime_AsTimespec,         METH_VARARGS},
    {"_PyTime_AsTimespec_clamp",  test_PyTime_AsTimespec_clamp,   METH_VARARGS},
#endif
    {"_PyTime_AsTimeval",         test_PyTime_AsTimeval,          METH_VARARGS},
    {"_PyTime_AsTimeval_clamp",   test_PyTime_AsTimeval_clamp,    METH_VARARGS},
    {"_PyTime_FromSeconds",       test_pytime_fromseconds,        METH_VARARGS},
    {"_PyTime_FromSecondsObject", test_pytime_fromsecondsobject,  METH_VARARGS},
    {"_PyTime_ObjectToTime_t",    test_pytime_object_to_time_t,   METH_VARARGS},
    {"_PyTime_ObjectToTimespec",  test_pytime_object_to_timespec, METH_VARARGS},
    {"_PyTime_ObjectToTimeval",   test_pytime_object_to_timeval,  METH_VARARGS},
    {NULL, NULL} /* sentinel */
};

int
_PyTestInternalCapi_Init_PyTime(PyObject *m)
{
    if (PyModule_AddFunctions(m, TestMethods) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testinternalcapi/set.c
================================================
#include "parts.h"
#include "../_testcapi/util.h"  // NULLABLE, RETURN_INT

#include "pycore_critical_section.h"
#include "pycore_setobject.h"


static PyObject *
set_update(PyObject *self, PyObject *args)
{
    PyObject *set, *iterable;
    if (!PyArg_ParseTuple(args, "OO", &set, &iterable)) {
        return NULL;
    }
    NULLABLE(set);
    NULLABLE(iterable);
    RETURN_INT(_PySet_Update(set, iterable));
}

static PyObject *
set_next_entry(PyObject *self, PyObject *args)
{
    int rc;
    Py_ssize_t pos;
    Py_hash_t hash = (Py_hash_t)UNINITIALIZED_SIZE;
    PyObject *set, *item = UNINITIALIZED_PTR;
    if (!PyArg_ParseTuple(args, "On", &set, &pos)) {
        return NULL;
    }
    NULLABLE(set);
    Py_BEGIN_CRITICAL_SECTION(set);
    rc = _PySet_NextEntryRef(set, &pos, &item, &hash);
    Py_END_CRITICAL_SECTION();
    if (rc == 1) {
        PyObject *ret = Py_BuildValue("innO", rc, pos, hash, item);
        Py_DECREF(item);
        return ret;
    }
    assert(item == UNINITIALIZED_PTR);
    assert(hash == (Py_hash_t)UNINITIALIZED_SIZE);
    if (rc == -1) {
        return NULL;
    }
    assert(rc == 0);
    Py_RETURN_NONE;
}


static PyMethodDef TestMethods[] = {
    {"set_update", set_update, METH_VARARGS},
    {"set_next_entry", set_next_entry, METH_VARARGS},

    {NULL},
};

int
_PyTestInternalCapi_Init_Set(PyObject *m)
{
    if (PyModule_AddFunctions(m, TestMethods) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testinternalcapi/test_critical_sections.c
================================================
/*
 * C Extension module to test pycore_critical_section.h API.
 */

#include "parts.h"

#include "pycore_critical_section.h"

#ifdef Py_GIL_DISABLED
#define assert_nogil assert
#define assert_gil(x)
#else
#define assert_gil assert
#define assert_nogil(x)
#endif


static PyObject *
test_critical_sections(PyObject *self, PyObject *Py_UNUSED(args))
{
    PyObject *d1 = PyDict_New();
    assert(d1 != NULL);

    PyObject *d2 = PyDict_New();
    assert(d2 != NULL);

    // Beginning a critical section should lock the associated object and
    // push the critical section onto the thread's stack (in Py_GIL_DISABLED builds).
    Py_BEGIN_CRITICAL_SECTION(d1);
    assert_nogil(PyMutex_IsLocked(&d1->ob_mutex));
    assert_nogil(_PyCriticalSection_IsActive(PyThreadState_GET()->critical_section));
    assert_gil(PyThreadState_GET()->critical_section == 0);
    Py_END_CRITICAL_SECTION();
    assert_nogil(!PyMutex_IsLocked(&d1->ob_mutex));

    assert_nogil(!PyMutex_IsLocked(&d1->ob_mutex));
    assert_nogil(!PyMutex_IsLocked(&d2->ob_mutex));
    Py_BEGIN_CRITICAL_SECTION2(d1, d2);
    assert_nogil(PyMutex_IsLocked(&d1->ob_mutex));
    assert_nogil(PyMutex_IsLocked(&d2->ob_mutex));
    Py_END_CRITICAL_SECTION2();
    assert_nogil(!PyMutex_IsLocked(&d1->ob_mutex));
    assert_nogil(!PyMutex_IsLocked(&d2->ob_mutex));

    // Passing the same object twice should work (and not deadlock).
    assert_nogil(!PyMutex_IsLocked(&d2->ob_mutex));
    Py_BEGIN_CRITICAL_SECTION2(d2, d2);
    assert_nogil(PyMutex_IsLocked(&d2->ob_mutex));
    Py_END_CRITICAL_SECTION2();
    assert_nogil(!PyMutex_IsLocked(&d2->ob_mutex));

    Py_DECREF(d2);
    Py_DECREF(d1);
    Py_RETURN_NONE;
}

static void
lock_unlock_object(PyObject *obj, int recurse_depth)
{
    Py_BEGIN_CRITICAL_SECTION(obj);
    if (recurse_depth > 0) {
        lock_unlock_object(obj, recurse_depth - 1);
    }
    Py_END_CRITICAL_SECTION();
}

static void
lock_unlock_two_objects(PyObject *a, PyObject *b, int recurse_depth)
{
    Py_BEGIN_CRITICAL_SECTION2(a, b);
    if (recurse_depth > 0) {
        lock_unlock_two_objects(a, b, recurse_depth - 1);
    }
    Py_END_CRITICAL_SECTION2();
}


// Test that nested critical sections do not deadlock if they attempt to lock
// the same object.
static PyObject *
test_critical_sections_nest(PyObject *self, PyObject *Py_UNUSED(args))
{
    PyObject *a = PyDict_New();
    assert(a != NULL);
    PyObject *b = PyDict_New();
    assert(b != NULL);

    // Locking an object recursively with this API should not deadlock.
    assert_nogil(!PyMutex_IsLocked(&a->ob_mutex));
    Py_BEGIN_CRITICAL_SECTION(a);
    assert_nogil(PyMutex_IsLocked(&a->ob_mutex));
    lock_unlock_object(a, 10);
    assert_nogil(PyMutex_IsLocked(&a->ob_mutex));
    Py_END_CRITICAL_SECTION();
    assert_nogil(!PyMutex_IsLocked(&a->ob_mutex));

    // Same test but with two objects.
    Py_BEGIN_CRITICAL_SECTION2(b, a);
    lock_unlock_two_objects(a, b, 10);
    assert_nogil(PyMutex_IsLocked(&a->ob_mutex));
    assert_nogil(PyMutex_IsLocked(&b->ob_mutex));
    Py_END_CRITICAL_SECTION2();

    Py_DECREF(b);
    Py_DECREF(a);
    Py_RETURN_NONE;
}

// Test that a critical section is suspended by a Py_BEGIN_ALLOW_THREADS and
// resumed by a Py_END_ALLOW_THREADS.
static PyObject *
test_critical_sections_suspend(PyObject *self, PyObject *Py_UNUSED(args))
{
    PyObject *a = PyDict_New();
    assert(a != NULL);

    Py_BEGIN_CRITICAL_SECTION(a);
    assert_nogil(PyMutex_IsLocked(&a->ob_mutex));

    // Py_BEGIN_ALLOW_THREADS should suspend the active critical section
    Py_BEGIN_ALLOW_THREADS
    assert_nogil(!PyMutex_IsLocked(&a->ob_mutex));
    Py_END_ALLOW_THREADS;

    // After Py_END_ALLOW_THREADS the critical section should be resumed.
    assert_nogil(PyMutex_IsLocked(&a->ob_mutex));
    Py_END_CRITICAL_SECTION();

    Py_DECREF(a);
    Py_RETURN_NONE;
}

#ifdef Py_CAN_START_THREADS
struct test_data {
    PyObject *obj1;
    PyObject *obj2;
    PyObject *obj3;
    Py_ssize_t countdown;
    PyEvent done_event;
};

static void
thread_critical_sections(void *arg)
{
    const Py_ssize_t NUM_ITERS = 200;
    struct test_data *test_data = arg;
    PyGILState_STATE gil = PyGILState_Ensure();

    for (Py_ssize_t i = 0; i < NUM_ITERS; i++) {
        Py_BEGIN_CRITICAL_SECTION(test_data->obj1);
        Py_END_CRITICAL_SECTION();

        Py_BEGIN_CRITICAL_SECTION(test_data->obj2);
        lock_unlock_object(test_data->obj1, 1);
        Py_END_CRITICAL_SECTION();

        Py_BEGIN_CRITICAL_SECTION2(test_data->obj3, test_data->obj1);
        lock_unlock_object(test_data->obj2, 2);
        Py_END_CRITICAL_SECTION2();

        Py_BEGIN_CRITICAL_SECTION(test_data->obj3);
        Py_BEGIN_ALLOW_THREADS
        Py_END_ALLOW_THREADS
        Py_END_CRITICAL_SECTION();
    }

    PyGILState_Release(gil);
    if (_Py_atomic_add_ssize(&test_data->countdown, -1) == 1) {
        // last thread to finish sets done_event
        _PyEvent_Notify(&test_data->done_event);
    }
}

static PyObject *
test_critical_sections_threads(PyObject *self, PyObject *Py_UNUSED(args))
{
    const Py_ssize_t NUM_THREADS = 4;
    struct test_data test_data = {
        .obj1 = PyDict_New(),
        .obj2 = PyDict_New(),
        .obj3 = PyDict_New(),
        .countdown = NUM_THREADS,
    };
    assert(test_data.obj1 != NULL);
    assert(test_data.obj2 != NULL);
    assert(test_data.obj3 != NULL);

    for (Py_ssize_t i = 0; i < NUM_THREADS; i++) {
        PyThread_start_new_thread(&thread_critical_sections, &test_data);
    }
    PyEvent_Wait(&test_data.done_event);

    Py_DECREF(test_data.obj3);
    Py_DECREF(test_data.obj2);
    Py_DECREF(test_data.obj1);
    Py_RETURN_NONE;
}

static void
pysleep(int ms)
{
#ifdef MS_WINDOWS
    Sleep(ms);
#else
    usleep(ms * 1000);
#endif
}

struct test_data_gc {
    PyObject *obj;
    Py_ssize_t num_threads;
    Py_ssize_t id;
    Py_ssize_t countdown;
    PyEvent done_event;
    PyEvent ready;
};

static void
thread_gc(void *arg)
{
    struct test_data_gc *test_data = arg;
    PyGILState_STATE gil = PyGILState_Ensure();

    Py_ssize_t id = _Py_atomic_add_ssize(&test_data->id, 1);
    if (id == test_data->num_threads - 1) {
        _PyEvent_Notify(&test_data->ready);
    }
    else {
        // wait for all test threads to more reliably reproduce the issue.
        PyEvent_Wait(&test_data->ready);
    }

    if (id == 0) {
        Py_BEGIN_CRITICAL_SECTION(test_data->obj);
        // pause long enough that the lock would be handed off directly to
        // a waiting thread.
        pysleep(5);
        PyGC_Collect();
        Py_END_CRITICAL_SECTION();
    }
    else if (id == 1) {
        pysleep(1);
        Py_BEGIN_CRITICAL_SECTION(test_data->obj);
        pysleep(1);
        Py_END_CRITICAL_SECTION();
    }
    else if (id == 2) {
        // sleep long enough so that thread 0 is waiting to stop the world
        pysleep(6);
        Py_BEGIN_CRITICAL_SECTION(test_data->obj);
        pysleep(1);
        Py_END_CRITICAL_SECTION();
    }

    PyGILState_Release(gil);
    if (_Py_atomic_add_ssize(&test_data->countdown, -1) == 1) {
        // last thread to finish sets done_event
        _PyEvent_Notify(&test_data->done_event);
    }
}

static PyObject *
test_critical_sections_gc(PyObject *self, PyObject *Py_UNUSED(args))
{
    // gh-118332: Contended critical sections should not deadlock with GC
    const Py_ssize_t NUM_THREADS = 3;
    struct test_data_gc test_data = {
        .obj = PyDict_New(),
        .countdown = NUM_THREADS,
        .num_threads = NUM_THREADS,
    };
    assert(test_data.obj != NULL);

    for (Py_ssize_t i = 0; i < NUM_THREADS; i++) {
        PyThread_start_new_thread(&thread_gc, &test_data);
    }
    PyEvent_Wait(&test_data.done_event);
    Py_DECREF(test_data.obj);
    Py_RETURN_NONE;
}

#endif

static PyMethodDef test_methods[] = {
    {"test_critical_sections", test_critical_sections, METH_NOARGS},
    {"test_critical_sections_nest", test_critical_sections_nest, METH_NOARGS},
    {"test_critical_sections_suspend", test_critical_sections_suspend, METH_NOARGS},
#ifdef Py_CAN_START_THREADS
    {"test_critical_sections_threads", test_critical_sections_threads, METH_NOARGS},
    {"test_critical_sections_gc", test_critical_sections_gc, METH_NOARGS},
#endif
    {NULL, NULL} /* sentinel */
};

int
_PyTestInternalCapi_Init_CriticalSection(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testinternalcapi/test_lock.c
================================================
// C Extension module to test pycore_lock.h API

#include "parts.h"
#include "pycore_lock.h"
#include "pycore_pythread.h"      // PyThread_get_thread_ident_ex()

#include "clinic/test_lock.c.h"

#ifdef MS_WINDOWS
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#else
#include <unistd.h>         // usleep()
#endif

/*[clinic input]
module _testinternalcapi
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=7bb583d8c9eb9a78]*/


static void
pysleep(int ms)
{
#ifdef MS_WINDOWS
    Sleep(ms);
#else
    usleep(ms * 1000);
#endif
}

static PyObject *
test_lock_basic(PyObject *self, PyObject *obj)
{
    PyMutex m = (PyMutex){0};

    // uncontended lock and unlock
    PyMutex_Lock(&m);
    assert(m._bits == 1);
    PyMutex_Unlock(&m);
    assert(m._bits == 0);

    Py_RETURN_NONE;
}

struct test_lock2_data {
    PyMutex m;
    PyEvent done;
    int started;
};

static void
lock_thread(void *arg)
{
    struct test_lock2_data *test_data = arg;
    PyMutex *m = &test_data->m;
    _Py_atomic_store_int(&test_data->started, 1);

    PyMutex_Lock(m);
    assert(m->_bits == 1);

    PyMutex_Unlock(m);
    assert(m->_bits == 0);

    _PyEvent_Notify(&test_data->done);
}

static PyObject *
test_lock_two_threads(PyObject *self, PyObject *obj)
{
    // lock attempt by two threads
    struct test_lock2_data test_data;
    memset(&test_data, 0, sizeof(test_data));

    PyMutex_Lock(&test_data.m);
    assert(test_data.m._bits == 1);

    PyThread_start_new_thread(lock_thread, &test_data);

    // wait up to two seconds for the lock_thread to attempt to lock "m"
    int iters = 0;
    uint8_t v;
    do {
        pysleep(10);  // allow some time for the other thread to try to lock
        v = _Py_atomic_load_uint8_relaxed(&test_data.m._bits);
        assert(v == 1 || v == 3);
        iters++;
    } while (v != 3 && iters < 200);

    // both the "locked" and the "has parked" bits should be set
    assert(test_data.m._bits == 3);

    PyMutex_Unlock(&test_data.m);
    PyEvent_Wait(&test_data.done);
    assert(test_data.m._bits == 0);

    Py_RETURN_NONE;
}

#define COUNTER_THREADS 5
#define COUNTER_ITERS 10000

struct test_data_counter {
    PyMutex m;
    Py_ssize_t counter;
};

struct thread_data_counter {
    struct test_data_counter *test_data;
    PyEvent done_event;
};

static void
counter_thread(void *arg)
{
    struct thread_data_counter *thread_data = arg;
    struct test_data_counter *test_data = thread_data->test_data;

    for (Py_ssize_t i = 0; i < COUNTER_ITERS; i++) {
        PyMutex_Lock(&test_data->m);
        test_data->counter++;
        PyMutex_Unlock(&test_data->m);
    }
    _PyEvent_Notify(&thread_data->done_event);
}

static PyObject *
test_lock_counter(PyObject *self, PyObject *obj)
{
    // Test with rapidly locking and unlocking mutex
    struct test_data_counter test_data;
    memset(&test_data, 0, sizeof(test_data));

    struct thread_data_counter thread_data[COUNTER_THREADS];
    memset(&thread_data, 0, sizeof(thread_data));

    for (Py_ssize_t i = 0; i < COUNTER_THREADS; i++) {
        thread_data[i].test_data = &test_data;
        PyThread_start_new_thread(counter_thread, &thread_data[i]);
    }

    for (Py_ssize_t i = 0; i < COUNTER_THREADS; i++) {
        PyEvent_Wait(&thread_data[i].done_event);
    }

    assert(test_data.counter == COUNTER_THREADS * COUNTER_ITERS);
    Py_RETURN_NONE;
}

#define SLOW_COUNTER_ITERS 100

static void
slow_counter_thread(void *arg)
{
    struct thread_data_counter *thread_data = arg;
    struct test_data_counter *test_data = thread_data->test_data;

    for (Py_ssize_t i = 0; i < SLOW_COUNTER_ITERS; i++) {
        PyMutex_Lock(&test_data->m);
        if (i % 7 == 0) {
            pysleep(2);
        }
        test_data->counter++;
        PyMutex_Unlock(&test_data->m);
    }
    _PyEvent_Notify(&thread_data->done_event);
}

static PyObject *
test_lock_counter_slow(PyObject *self, PyObject *obj)
{
    // Test lock/unlock with occasional "long" critical section, which will
    // trigger handoff of the lock.
    struct test_data_counter test_data;
    memset(&test_data, 0, sizeof(test_data));

    struct thread_data_counter thread_data[COUNTER_THREADS];
    memset(&thread_data, 0, sizeof(thread_data));

    for (Py_ssize_t i = 0; i < COUNTER_THREADS; i++) {
        thread_data[i].test_data = &test_data;
        PyThread_start_new_thread(slow_counter_thread, &thread_data[i]);
    }

    for (Py_ssize_t i = 0; i < COUNTER_THREADS; i++) {
        PyEvent_Wait(&thread_data[i].done_event);
    }

    assert(test_data.counter == COUNTER_THREADS * SLOW_COUNTER_ITERS);
    Py_RETURN_NONE;
}

struct bench_data_locks {
    int stop;
    int use_pymutex;
    int critical_section_length;
    char padding[200];
    PyThread_type_lock lock;
    PyMutex m;
    double value;
    Py_ssize_t total_iters;
};

struct bench_thread_data {
    struct bench_data_locks *bench_data;
    Py_ssize_t iters;
    PyEvent done;
};

static void
thread_benchmark_locks(void *arg)
{
    struct bench_thread_data *thread_data = arg;
    struct bench_data_locks *bench_data = thread_data->bench_data;
    int use_pymutex = bench_data->use_pymutex;
    int critical_section_length = bench_data->critical_section_length;

    double my_value = 1.0;
    Py_ssize_t iters = 0;
    while (!_Py_atomic_load_int_relaxed(&bench_data->stop)) {
        if (use_pymutex) {
            PyMutex_Lock(&bench_data->m);
            for (int i = 0; i < critical_section_length; i++) {
                bench_data->value += my_value;
                my_value = bench_data->value;
            }
            PyMutex_Unlock(&bench_data->m);
        }
        else {
            PyThread_acquire_lock(bench_data->lock, 1);
            for (int i = 0; i < critical_section_length; i++) {
                bench_data->value += my_value;
                my_value = bench_data->value;
            }
            PyThread_release_lock(bench_data->lock);
        }
        iters++;
    }

    thread_data->iters = iters;
    _Py_atomic_add_ssize(&bench_data->total_iters, iters);
    _PyEvent_Notify(&thread_data->done);
}

/*[clinic input]
_testinternalcapi.benchmark_locks

    num_threads: Py_ssize_t
    use_pymutex: bool = True
    critical_section_length: int = 1
    time_ms: int = 1000
    /

[clinic start generated code]*/

static PyObject *
_testinternalcapi_benchmark_locks_impl(PyObject *module,
                                       Py_ssize_t num_threads,
                                       int use_pymutex,
                                       int critical_section_length,
                                       int time_ms)
/*[clinic end generated code: output=381df8d7e9a74f18 input=f3aeaf688738c121]*/
{
    // Run from Tools/lockbench/lockbench.py
    // Based on the WebKit lock benchmarks:
    // https://github.com/WebKit/WebKit/blob/main/Source/WTF/benchmarks/LockSpeedTest.cpp
    // See also https://webkit.org/blog/6161/locking-in-webkit/
    PyObject *thread_iters = NULL;
    PyObject *res = NULL;

    struct bench_data_locks bench_data;
    memset(&bench_data, 0, sizeof(bench_data));
    bench_data.use_pymutex = use_pymutex;
    bench_data.critical_section_length = critical_section_length;

    bench_data.lock = PyThread_allocate_lock();
    if (bench_data.lock == NULL) {
        return PyErr_NoMemory();
    }

    struct bench_thread_data *thread_data = NULL;
    thread_data = PyMem_Calloc(num_threads, sizeof(*thread_data));
    if (thread_data == NULL) {
        PyErr_NoMemory();
        goto exit;
    }

    thread_iters = PyList_New(num_threads);
    if (thread_iters == NULL) {
        goto exit;
    }

    PyTime_t start, end;
    if (PyTime_PerfCounter(&start) < 0) {
        goto exit;
    }

    for (Py_ssize_t i = 0; i < num_threads; i++) {
        thread_data[i].bench_data = &bench_data;
        PyThread_start_new_thread(thread_benchmark_locks, &thread_data[i]);
    }

    // Let the threads run for `time_ms` milliseconds
    pysleep(time_ms);
    _Py_atomic_store_int(&bench_data.stop, 1);

    // Wait for the threads to finish
    for (Py_ssize_t i = 0; i < num_threads; i++) {
        PyEvent_Wait(&thread_data[i].done);
    }

    Py_ssize_t total_iters = bench_data.total_iters;
    if (PyTime_PerfCounter(&end) < 0) {
        goto exit;
    }

    // Return the total number of acquisitions and the number of acquisitions
    // for each thread.
    for (Py_ssize_t i = 0; i < num_threads; i++) {
        PyObject *iter = PyLong_FromSsize_t(thread_data[i].iters);
        if (iter == NULL) {
            goto exit;
        }
        PyList_SET_ITEM(thread_iters, i, iter);
    }

    assert(end != start);
    double rate = total_iters * 1e9 / (end - start);
    res = Py_BuildValue("(dO)", rate, thread_iters);

exit:
    PyThread_free_lock(bench_data.lock);
    PyMem_Free(thread_data);
    Py_XDECREF(thread_iters);
    return res;
}

static PyObject *
test_lock_benchmark(PyObject *module, PyObject *obj)
{
    // Just make sure the benchmark runs without crashing
    PyObject *res = _testinternalcapi_benchmark_locks_impl(
        module, 1, 1, 1, 100);
    if (res == NULL) {
        return NULL;
    }
    Py_DECREF(res);
    Py_RETURN_NONE;
}

static int
init_maybe_fail(void *arg)
{
    int *counter = (int *)arg;
    (*counter)++;
    if (*counter < 5) {
        // failure
        return -1;
    }
    assert(*counter == 5);
    return 0;
}

static PyObject *
test_lock_once(PyObject *self, PyObject *obj)
{
    _PyOnceFlag once = {0};
    int counter = 0;
    for (int i = 0; i < 10; i++) {
        int res = _PyOnceFlag_CallOnce(&once, init_maybe_fail, &counter);
        if (i < 4) {
            assert(res == -1);
        }
        else {
            assert(res == 0);
            assert(counter == 5);
        }
    }
    Py_RETURN_NONE;
}

struct test_rwlock_data {
    Py_ssize_t nthreads;
    _PyRWMutex rw;
    PyEvent step1;
    PyEvent step2;
    PyEvent step3;
    PyEvent done;
};

static void
rdlock_thread(void *arg)
{
    struct test_rwlock_data *test_data = arg;

    // Acquire the lock in read mode
    _PyRWMutex_RLock(&test_data->rw);
    PyEvent_Wait(&test_data->step1);
    _PyRWMutex_RUnlock(&test_data->rw);

    _PyRWMutex_RLock(&test_data->rw);
    PyEvent_Wait(&test_data->step3);
    _PyRWMutex_RUnlock(&test_data->rw);

    if (_Py_atomic_add_ssize(&test_data->nthreads, -1) == 1) {
        _PyEvent_Notify(&test_data->done);
    }
}
static void
wrlock_thread(void *arg)
{
    struct test_rwlock_data *test_data = arg;

    // First acquire the lock in write mode
    _PyRWMutex_Lock(&test_data->rw);
    PyEvent_Wait(&test_data->step2);
    _PyRWMutex_Unlock(&test_data->rw);

    if (_Py_atomic_add_ssize(&test_data->nthreads, -1) == 1) {
        _PyEvent_Notify(&test_data->done);
    }
}

static void
wait_until(uintptr_t *ptr, uintptr_t value)
{
    // wait up to two seconds for *ptr == value
    int iters = 0;
    uintptr_t bits;
    do {
        pysleep(10);
        bits = _Py_atomic_load_uintptr(ptr);
        iters++;
    } while (bits != value && iters < 200);
}

static PyObject *
test_lock_rwlock(PyObject *self, PyObject *obj)
{
    struct test_rwlock_data test_data = {.nthreads = 3};

    _PyRWMutex_Lock(&test_data.rw);
    assert(test_data.rw.bits == 1);

    _PyRWMutex_Unlock(&test_data.rw);
    assert(test_data.rw.bits == 0);

    // Start two readers
    PyThread_start_new_thread(rdlock_thread, &test_data);
    PyThread_start_new_thread(rdlock_thread, &test_data);

    // wait up to two seconds for the threads to attempt to read-lock "rw"
    wait_until(&test_data.rw.bits, 8);
    assert(test_data.rw.bits == 8);

    // start writer (while readers hold lock)
    PyThread_start_new_thread(wrlock_thread, &test_data);
    wait_until(&test_data.rw.bits, 10);
    assert(test_data.rw.bits == 10);

    // readers release lock, writer should acquire it
    _PyEvent_Notify(&test_data.step1);
    wait_until(&test_data.rw.bits, 3);
    assert(test_data.rw.bits == 3);

    // writer releases lock, readers acquire it
    _PyEvent_Notify(&test_data.step2);
    wait_until(&test_data.rw.bits, 8);
    assert(test_data.rw.bits == 8);

    // readers release lock again
    _PyEvent_Notify(&test_data.step3);
    wait_until(&test_data.rw.bits, 0);
    assert(test_data.rw.bits == 0);

    PyEvent_Wait(&test_data.done);
    Py_RETURN_NONE;
}

static PyObject *
test_lock_recursive(PyObject *self, PyObject *obj)
{
    _PyRecursiveMutex m = (_PyRecursiveMutex){0};
    assert(!_PyRecursiveMutex_IsLockedByCurrentThread(&m));

    _PyRecursiveMutex_Lock(&m);
    assert(m.thread == PyThread_get_thread_ident_ex());
    assert(PyMutex_IsLocked(&m.mutex));
    assert(m.level == 0);

    _PyRecursiveMutex_Lock(&m);
    assert(m.level == 1);
    _PyRecursiveMutex_Unlock(&m);

    _PyRecursiveMutex_Unlock(&m);
    assert(m.thread == 0);
    assert(!PyMutex_IsLocked(&m.mutex));
    assert(m.level == 0);

    Py_RETURN_NONE;
}

static PyMethodDef test_methods[] = {
    {"test_lock_basic", test_lock_basic, METH_NOARGS},
    {"test_lock_two_threads", test_lock_two_threads, METH_NOARGS},
    {"test_lock_counter", test_lock_counter, METH_NOARGS},
    {"test_lock_counter_slow", test_lock_counter_slow, METH_NOARGS},
    _TESTINTERNALCAPI_BENCHMARK_LOCKS_METHODDEF
    {"test_lock_benchmark", test_lock_benchmark, METH_NOARGS},
    {"test_lock_once", test_lock_once, METH_NOARGS},
    {"test_lock_rwlock", test_lock_rwlock, METH_NOARGS},
    {"test_lock_recursive", test_lock_recursive, METH_NOARGS},
    {NULL, NULL} /* sentinel */
};

int
_PyTestInternalCapi_Init_Lock(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testinternalcapi/clinic/test_lock.c.h
================================================
/*[clinic input]
preserve
[clinic start generated code]*/

#include "pycore_abstract.h"      // _PyNumber_Index()
#include "pycore_modsupport.h"    // _PyArg_CheckPositional()

PyDoc_STRVAR(_testinternalcapi_benchmark_locks__doc__,
"benchmark_locks($module, num_threads, use_pymutex=True,\n"
"                critical_section_length=1, time_ms=1000, /)\n"
"--\n"
"\n");

#define _TESTINTERNALCAPI_BENCHMARK_LOCKS_METHODDEF    \
    {"benchmark_locks", _PyCFunction_CAST(_testinternalcapi_benchmark_locks), METH_FASTCALL, _testinternalcapi_benchmark_locks__doc__},

static PyObject *
_testinternalcapi_benchmark_locks_impl(PyObject *module,
                                       Py_ssize_t num_threads,
                                       int use_pymutex,
                                       int critical_section_length,
                                       int time_ms);

static PyObject *
_testinternalcapi_benchmark_locks(PyObject *module, PyObject *const *args, Py_ssize_t nargs)
{
    PyObject *return_value = NULL;
    Py_ssize_t num_threads;
    int use_pymutex = 1;
    int critical_section_length = 1;
    int time_ms = 1000;

    if (!_PyArg_CheckPositional("benchmark_locks", nargs, 1, 4)) {
        goto exit;
    }
    {
        Py_ssize_t ival = -1;
        PyObject *iobj = _PyNumber_Index(args[0]);
        if (iobj != NULL) {
            ival = PyLong_AsSsize_t(iobj);
            Py_DECREF(iobj);
        }
        if (ival == -1 && PyErr_Occurred()) {
            goto exit;
        }
        num_threads = ival;
    }
    if (nargs < 2) {
        goto skip_optional;
    }
    use_pymutex = PyObject_IsTrue(args[1]);
    if (use_pymutex < 0) {
        goto exit;
    }
    if (nargs < 3) {
        goto skip_optional;
    }
    critical_section_length = PyLong_AsInt(args[2]);
    if (critical_section_length == -1 && PyErr_Occurred()) {
        goto exit;
    }
    if (nargs < 4) {
        goto skip_optional;
    }
    time_ms = PyLong_AsInt(args[3]);
    if (time_ms == -1 && PyErr_Occurred()) {
        goto exit;
    }
skip_optional:
    return_value = _testinternalcapi_benchmark_locks_impl(module, num_threads, use_pymutex, critical_section_length, time_ms);

exit:
    return return_value;
}
/*[clinic end generated code: output=105105d759c0c271 input=a9049054013a1b77]*/


================================================
File: /Modules/_testlimitedcapi/abstract.c
================================================
#include "parts.h"
#include "util.h"


static PyObject *
object_repr(PyObject *self, PyObject *arg)
{
    NULLABLE(arg);
    return PyObject_Repr(arg);
}

static PyObject *
object_ascii(PyObject *self, PyObject *arg)
{
    NULLABLE(arg);
    return PyObject_ASCII(arg);
}

static PyObject *
object_str(PyObject *self, PyObject *arg)
{
    NULLABLE(arg);
    return PyObject_Str(arg);
}

static PyObject *
object_bytes(PyObject *self, PyObject *arg)
{
    NULLABLE(arg);
    return PyObject_Bytes(arg);
}

static PyObject *
object_getattr(PyObject *self, PyObject *args)
{
    PyObject *obj, *attr_name;
    if (!PyArg_ParseTuple(args, "OO", &obj, &attr_name)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(attr_name);
    return PyObject_GetAttr(obj, attr_name);
}

static PyObject *
object_getattrstring(PyObject *self, PyObject *args)
{
    PyObject *obj;
    const char *attr_name;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#", &obj, &attr_name, &size)) {
        return NULL;
    }
    NULLABLE(obj);
    return PyObject_GetAttrString(obj, attr_name);
}

static PyObject *
object_hasattr(PyObject *self, PyObject *args)
{
    PyObject *obj, *attr_name;
    if (!PyArg_ParseTuple(args, "OO", &obj, &attr_name)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(attr_name);
    return PyLong_FromLong(PyObject_HasAttr(obj, attr_name));
}

static PyObject *
object_hasattrstring(PyObject *self, PyObject *args)
{
    PyObject *obj;
    const char *attr_name;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#", &obj, &attr_name, &size)) {
        return NULL;
    }
    NULLABLE(obj);
    return PyLong_FromLong(PyObject_HasAttrString(obj, attr_name));
}

static PyObject *
object_setattr(PyObject *self, PyObject *args)
{
    PyObject *obj, *attr_name, *value;
    if (!PyArg_ParseTuple(args, "OOO", &obj, &attr_name, &value)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(attr_name);
    NULLABLE(value);
    RETURN_INT(PyObject_SetAttr(obj, attr_name, value));
}

static PyObject *
object_setattrstring(PyObject *self, PyObject *args)
{
    PyObject *obj, *value;
    const char *attr_name;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#O", &obj, &attr_name, &size, &value)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(value);
    RETURN_INT(PyObject_SetAttrString(obj, attr_name, value));
}

static PyObject *
object_delattr(PyObject *self, PyObject *args)
{
    PyObject *obj, *attr_name;
if (!PyArg_ParseTuple(args, "OO", &obj, &attr_name)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(attr_name);
    RETURN_INT(PyObject_DelAttr(obj, attr_name));
}

static PyObject *
object_delattrstring(PyObject *self, PyObject *args)
{
    PyObject *obj;
    const char *attr_name;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#", &obj, &attr_name, &size)) {
        return NULL;
    }
    NULLABLE(obj);
    RETURN_INT(PyObject_DelAttrString(obj, attr_name));
}

static PyObject *
number_check(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PyBool_FromLong(PyNumber_Check(obj));
}

static PyObject *
mapping_check(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyMapping_Check(obj));
}

static PyObject *
mapping_size(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_SIZE(PyMapping_Size(obj));
}

static PyObject *
mapping_length(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_SIZE(PyMapping_Length(obj));
}

static PyObject *
object_getitem(PyObject *self, PyObject *args)
{
    PyObject *mapping, *key;
    if (!PyArg_ParseTuple(args, "OO", &mapping, &key)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(key);
    return PyObject_GetItem(mapping, key);
}

static PyObject *
mapping_getitemstring(PyObject *self, PyObject *args)
{
    PyObject *mapping;
    const char *key;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#", &mapping, &key, &size)) {
        return NULL;
    }
    NULLABLE(mapping);
    return PyMapping_GetItemString(mapping, key);
}

static PyObject *
mapping_haskey(PyObject *self, PyObject *args)
{
    PyObject *mapping, *key;
    if (!PyArg_ParseTuple(args, "OO", &mapping, &key)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(key);
    return PyLong_FromLong(PyMapping_HasKey(mapping, key));
}

static PyObject *
mapping_haskeystring(PyObject *self, PyObject *args)
{
    PyObject *mapping;
    const char *key;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#", &mapping, &key, &size)) {
        return NULL;
    }
    NULLABLE(mapping);
    return PyLong_FromLong(PyMapping_HasKeyString(mapping, key));
}

static PyObject *
mapping_haskeywitherror(PyObject *self, PyObject *args)
{
    PyObject *mapping, *key;
    if (!PyArg_ParseTuple(args, "OO", &mapping, &key)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(key);
    RETURN_INT(PyMapping_HasKeyWithError(mapping, key));
}

static PyObject *
mapping_haskeystringwitherror(PyObject *self, PyObject *args)
{
    PyObject *mapping;
    const char *key;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#", &mapping, &key, &size)) {
        return NULL;
    }
    NULLABLE(mapping);
    RETURN_INT(PyMapping_HasKeyStringWithError(mapping, key));
}

static PyObject *
object_setitem(PyObject *self, PyObject *args)
{
    PyObject *mapping, *key, *value;
    if (!PyArg_ParseTuple(args, "OOO", &mapping, &key, &value)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(key);
    NULLABLE(value);
    RETURN_INT(PyObject_SetItem(mapping, key, value));
}

static PyObject *
mapping_setitemstring(PyObject *self, PyObject *args)
{
    PyObject *mapping, *value;
    const char *key;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#O", &mapping, &key, &size, &value)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(value);
    RETURN_INT(PyMapping_SetItemString(mapping, key, value));
}

static PyObject *
object_delitem(PyObject *self, PyObject *args)
{
    PyObject *mapping, *key;
    if (!PyArg_ParseTuple(args, "OO", &mapping, &key)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(key);
    RETURN_INT(PyObject_DelItem(mapping, key));
}

static PyObject *
mapping_delitem(PyObject *self, PyObject *args)
{
    PyObject *mapping, *key;
    if (!PyArg_ParseTuple(args, "OO", &mapping, &key)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(key);
    RETURN_INT(PyMapping_DelItem(mapping, key));
}

static PyObject *
mapping_delitemstring(PyObject *self, PyObject *args)
{
    PyObject *mapping;
    const char *key;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#", &mapping, &key, &size)) {
        return NULL;
    }
    NULLABLE(mapping);
    RETURN_INT(PyMapping_DelItemString(mapping, key));
}

static PyObject *
mapping_keys(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PyMapping_Keys(obj);
}

static PyObject *
mapping_values(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PyMapping_Values(obj);
}

static PyObject *
mapping_items(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PyMapping_Items(obj);
}


static PyObject *
sequence_check(PyObject* self, PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PySequence_Check(obj));
}

static PyObject *
sequence_size(PyObject* self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_SIZE(PySequence_Size(obj));
}

static PyObject *
sequence_length(PyObject* self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_SIZE(PySequence_Length(obj));
}

static PyObject *
sequence_concat(PyObject *self, PyObject *args)
{
    PyObject *seq1, *seq2;
    if (!PyArg_ParseTuple(args, "OO", &seq1, &seq2)) {
        return NULL;
    }
    NULLABLE(seq1);
    NULLABLE(seq2);

    return PySequence_Concat(seq1, seq2);
}

static PyObject *
sequence_repeat(PyObject *self, PyObject *args)
{
    PyObject *seq;
    Py_ssize_t count;
    if (!PyArg_ParseTuple(args, "On", &seq, &count)) {
        return NULL;
    }
    NULLABLE(seq);

    return PySequence_Repeat(seq, count);
}

static PyObject *
sequence_inplaceconcat(PyObject *self, PyObject *args)
{
    PyObject *seq1, *seq2;
    if (!PyArg_ParseTuple(args, "OO", &seq1, &seq2)) {
        return NULL;
    }
    NULLABLE(seq1);
    NULLABLE(seq2);

    return PySequence_InPlaceConcat(seq1, seq2);
}

static PyObject *
sequence_inplacerepeat(PyObject *self, PyObject *args)
{
    PyObject *seq;
    Py_ssize_t count;
    if (!PyArg_ParseTuple(args, "On", &seq, &count)) {
        return NULL;
    }
    NULLABLE(seq);

    return PySequence_InPlaceRepeat(seq, count);
}

static PyObject *
sequence_getitem(PyObject *self, PyObject *args)
{
    PyObject *seq;
    Py_ssize_t i;
    if (!PyArg_ParseTuple(args, "On", &seq, &i)) {
        return NULL;
    }
    NULLABLE(seq);

    return PySequence_GetItem(seq, i);
}

static PyObject *
sequence_setitem(PyObject *self, PyObject *args)
{
    Py_ssize_t i;
    PyObject *seq, *val;
    if (!PyArg_ParseTuple(args, "OnO", &seq, &i, &val)) {
        return NULL;
    }
    NULLABLE(seq);
    NULLABLE(val);

    RETURN_INT(PySequence_SetItem(seq, i, val));
}


static PyObject *
sequence_delitem(PyObject *self, PyObject *args)
{
    Py_ssize_t i;
    PyObject *seq;
    if (!PyArg_ParseTuple(args, "On", &seq, &i)) {
        return NULL;
    }
    NULLABLE(seq);

    RETURN_INT(PySequence_DelItem(seq, i));
}

static PyObject *
sequence_setslice(PyObject* self, PyObject *args)
{
    PyObject *sequence, *obj;
    Py_ssize_t i1, i2;
    if (!PyArg_ParseTuple(args, "OnnO", &sequence, &i1, &i2, &obj)) {
        return NULL;
    }
    NULLABLE(sequence);
    NULLABLE(obj);

    RETURN_INT(PySequence_SetSlice(sequence, i1, i2, obj));
}

static PyObject *
sequence_delslice(PyObject *self, PyObject *args)
{
    PyObject *sequence;
    Py_ssize_t i1, i2;
    if (!PyArg_ParseTuple(args, "Onn", &sequence, &i1, &i2)) {
        return NULL;
    }
    NULLABLE(sequence);

    RETURN_INT(PySequence_DelSlice(sequence, i1, i2));
}

static PyObject *
sequence_count(PyObject *self, PyObject *args)
{
    PyObject *seq, *value;
    if (!PyArg_ParseTuple(args, "OO", &seq, &value)) {
        return NULL;
    }
    NULLABLE(seq);
    NULLABLE(value);

    RETURN_SIZE(PySequence_Count(seq, value));
}

static PyObject *
sequence_contains(PyObject *self, PyObject *args)
{
    PyObject *seq, *value;
    if (!PyArg_ParseTuple(args, "OO", &seq, &value)) {
        return NULL;
    }
    NULLABLE(seq);
    NULLABLE(value);

    RETURN_INT(PySequence_Contains(seq, value));
}

static PyObject *
sequence_index(PyObject *self, PyObject *args)
{
    PyObject *seq, *value;
    if (!PyArg_ParseTuple(args, "OO", &seq, &value)) {
        return NULL;
    }
    NULLABLE(seq);
    NULLABLE(value);

    RETURN_SIZE(PySequence_Index(seq, value));
}

static PyObject *
sequence_list(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PySequence_List(obj);
}

static PyObject *
sequence_tuple(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PySequence_Tuple(obj);
}


static PyMethodDef test_methods[] = {
    {"object_repr", object_repr, METH_O},
    {"object_ascii", object_ascii, METH_O},
    {"object_str", object_str, METH_O},
    {"object_bytes", object_bytes, METH_O},

    {"object_getattr", object_getattr, METH_VARARGS},
    {"object_getattrstring", object_getattrstring, METH_VARARGS},
    {"object_hasattr", object_hasattr, METH_VARARGS},
    {"object_hasattrstring", object_hasattrstring, METH_VARARGS},
    {"object_setattr", object_setattr, METH_VARARGS},
    {"object_setattrstring", object_setattrstring, METH_VARARGS},
    {"object_delattr", object_delattr, METH_VARARGS},
    {"object_delattrstring", object_delattrstring, METH_VARARGS},

    {"number_check", number_check, METH_O},
    {"mapping_check", mapping_check, METH_O},
    {"mapping_size", mapping_size, METH_O},
    {"mapping_length", mapping_length, METH_O},
    {"object_getitem", object_getitem, METH_VARARGS},
    {"mapping_getitemstring", mapping_getitemstring, METH_VARARGS},
    {"mapping_haskey", mapping_haskey, METH_VARARGS},
    {"mapping_haskeystring", mapping_haskeystring, METH_VARARGS},
    {"mapping_haskeywitherror", mapping_haskeywitherror, METH_VARARGS},
    {"mapping_haskeystringwitherror", mapping_haskeystringwitherror, METH_VARARGS},
    {"object_setitem", object_setitem, METH_VARARGS},
    {"mapping_setitemstring", mapping_setitemstring, METH_VARARGS},
    {"object_delitem", object_delitem, METH_VARARGS},
    {"mapping_delitem", mapping_delitem, METH_VARARGS},
    {"mapping_delitemstring", mapping_delitemstring, METH_VARARGS},
    {"mapping_keys", mapping_keys, METH_O},
    {"mapping_values", mapping_values, METH_O},
    {"mapping_items", mapping_items, METH_O},

    {"sequence_check", sequence_check, METH_O},
    {"sequence_size", sequence_size, METH_O},
    {"sequence_length", sequence_length, METH_O},
    {"sequence_concat", sequence_concat, METH_VARARGS},
    {"sequence_repeat", sequence_repeat, METH_VARARGS},
    {"sequence_inplaceconcat", sequence_inplaceconcat, METH_VARARGS},
    {"sequence_inplacerepeat", sequence_inplacerepeat, METH_VARARGS},
    {"sequence_getitem", sequence_getitem, METH_VARARGS},
    {"sequence_setitem", sequence_setitem, METH_VARARGS},
    {"sequence_delitem", sequence_delitem, METH_VARARGS},
    {"sequence_setslice", sequence_setslice, METH_VARARGS},
    {"sequence_delslice", sequence_delslice, METH_VARARGS},
    {"sequence_count", sequence_count, METH_VARARGS},
    {"sequence_contains", sequence_contains, METH_VARARGS},
    {"sequence_index", sequence_index, METH_VARARGS},
    {"sequence_list", sequence_list, METH_O},
    {"sequence_tuple", sequence_tuple, METH_O},

    {NULL},
};

int
_PyTestLimitedCAPI_Init_Abstract(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/bytearray.c
================================================
#include "parts.h"
#include "util.h"


/* Test PyByteArray_Check() */
static PyObject *
bytearray_check(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyByteArray_Check(obj));
}

/* Test PyByteArray_CheckExact() */
static PyObject *
bytearray_checkexact(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyByteArray_CheckExact(obj));
}

/* Test PyByteArray_FromStringAndSize() */
static PyObject *
bytearray_fromstringandsize(PyObject *Py_UNUSED(module), PyObject *args)
{
    const char *s;
    Py_ssize_t bsize;
    Py_ssize_t size = -100;

    if (!PyArg_ParseTuple(args, "z#|n", &s, &bsize, &size)) {
        return NULL;
    }

    if (size == -100) {
        size = bsize;
    }
    return PyByteArray_FromStringAndSize(s, size);
}

/* Test PyByteArray_FromObject() */
static PyObject *
bytearray_fromobject(PyObject *Py_UNUSED(module), PyObject *arg)
{
    NULLABLE(arg);
    return PyByteArray_FromObject(arg);
}

/* Test PyByteArray_Size() */
static PyObject *
bytearray_size(PyObject *Py_UNUSED(module), PyObject *arg)
{
    NULLABLE(arg);
    RETURN_SIZE(PyByteArray_Size(arg));
}

/* Test PyUnicode_AsString() */
static PyObject *
bytearray_asstring(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t buflen;
    const char *s;

    if (!PyArg_ParseTuple(args, "On", &obj, &buflen))
        return NULL;

    NULLABLE(obj);
    s = PyByteArray_AsString(obj);
    if (s == NULL)
        return NULL;

    return PyByteArray_FromStringAndSize(s, buflen);
}

/* Test PyByteArray_Concat() */
static PyObject *
bytearray_concat(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *left, *right;

    if (!PyArg_ParseTuple(args, "OO", &left, &right))
        return NULL;

    NULLABLE(left);
    NULLABLE(right);
    return PyByteArray_Concat(left, right);
}

/* Test PyByteArray_Resize() */
static PyObject *
bytearray_resize(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t size;

    if (!PyArg_ParseTuple(args, "On", &obj, &size))
        return NULL;

    NULLABLE(obj);
    RETURN_INT(PyByteArray_Resize(obj, size));
}


static PyMethodDef test_methods[] = {
    {"bytearray_check", bytearray_check, METH_O},
    {"bytearray_checkexact", bytearray_checkexact, METH_O},
    {"bytearray_fromstringandsize", bytearray_fromstringandsize, METH_VARARGS},
    {"bytearray_fromobject", bytearray_fromobject, METH_O},
    {"bytearray_size", bytearray_size, METH_O},
    {"bytearray_asstring", bytearray_asstring, METH_VARARGS},
    {"bytearray_concat", bytearray_concat, METH_VARARGS},
    {"bytearray_resize", bytearray_resize, METH_VARARGS},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_ByteArray(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/bytes.c
================================================
#include "parts.h"
#include "util.h"


/* Test PyBytes_Check() */
static PyObject *
bytes_check(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyBytes_Check(obj));
}

/* Test PyBytes_CheckExact() */
static PyObject *
bytes_checkexact(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyBytes_CheckExact(obj));
}

/* Test PyBytes_FromStringAndSize() */
static PyObject *
bytes_fromstringandsize(PyObject *Py_UNUSED(module), PyObject *args)
{
    const char *s;
    Py_ssize_t bsize;
    Py_ssize_t size = -100;

    if (!PyArg_ParseTuple(args, "z#|n", &s, &bsize, &size)) {
        return NULL;
    }

    if (size == -100) {
        size = bsize;
    }
    return PyBytes_FromStringAndSize(s, size);
}

/* Test PyBytes_FromString() */
static PyObject *
bytes_fromstring(PyObject *Py_UNUSED(module), PyObject *arg)
{
    const char *s;
    Py_ssize_t size;

    if (!PyArg_Parse(arg, "z#", &s, &size)) {
        return NULL;
    }
    return PyBytes_FromString(s);
}

/* Test PyBytes_FromObject() */
static PyObject *
bytes_fromobject(PyObject *Py_UNUSED(module), PyObject *arg)
{
    NULLABLE(arg);
    return PyBytes_FromObject(arg);
}

/* Test PyBytes_Size() */
static PyObject *
bytes_size(PyObject *Py_UNUSED(module), PyObject *arg)
{
    NULLABLE(arg);
    RETURN_SIZE(PyBytes_Size(arg));
}

/* Test PyUnicode_AsString() */
static PyObject *
bytes_asstring(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t buflen;
    const char *s;

    if (!PyArg_ParseTuple(args, "On", &obj, &buflen))
        return NULL;

    NULLABLE(obj);
    s = PyBytes_AsString(obj);
    if (s == NULL)
        return NULL;

    return PyBytes_FromStringAndSize(s, buflen);
}

/* Test PyBytes_AsStringAndSize() */
static PyObject *
bytes_asstringandsize(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t buflen;
    char *s = UNINITIALIZED_PTR;
    Py_ssize_t size = UNINITIALIZED_SIZE;

    if (!PyArg_ParseTuple(args, "On", &obj, &buflen))
        return NULL;

    NULLABLE(obj);
    if (PyBytes_AsStringAndSize(obj, &s, &size) < 0) {
        return NULL;
    }

    if (s == NULL) {
        return Py_BuildValue("(On)", Py_None, size);
    }
    else {
        return Py_BuildValue("(y#n)", s, buflen, size);
    }
}

static PyObject *
bytes_asstringandsize_null(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t buflen;
    char *s = UNINITIALIZED_PTR;

    if (!PyArg_ParseTuple(args, "On", &obj, &buflen))
        return NULL;

    NULLABLE(obj);
    if (PyBytes_AsStringAndSize(obj, &s, NULL) < 0) {
        return NULL;
    }

    if (s == NULL) {
        Py_RETURN_NONE;
    }
    else {
        return PyBytes_FromStringAndSize(s, buflen);
    }
}

/* Test PyBytes_Repr() */
static PyObject *
bytes_repr(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    int smartquotes;
    if (!PyArg_ParseTuple(args, "Oi", &obj, &smartquotes))
        return NULL;

    NULLABLE(obj);
    return PyBytes_Repr(obj, smartquotes);
}

/* Test PyBytes_Concat() */
static PyObject *
bytes_concat(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *left, *right;
    int new = 0;

    if (!PyArg_ParseTuple(args, "OO|p", &left, &right, &new))
        return NULL;

    NULLABLE(left);
    NULLABLE(right);
    if (new) {
        assert(left != NULL);
        assert(PyBytes_CheckExact(left));
        left = PyBytes_FromStringAndSize(PyBytes_AsString(left),
                                         PyBytes_Size(left));
        if (left == NULL) {
            return NULL;
        }
    }
    else {
        Py_XINCREF(left);
    }
    PyBytes_Concat(&left, right);
    if (left == NULL && !PyErr_Occurred()) {
        Py_RETURN_NONE;
    }
    return left;
}

/* Test PyBytes_ConcatAndDel() */
static PyObject *
bytes_concatanddel(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *left, *right;
    int new = 0;

    if (!PyArg_ParseTuple(args, "OO|p", &left, &right, &new))
        return NULL;

    NULLABLE(left);
    NULLABLE(right);
    if (new) {
        assert(left != NULL);
        assert(PyBytes_CheckExact(left));
        left = PyBytes_FromStringAndSize(PyBytes_AsString(left),
                                         PyBytes_Size(left));
        if (left == NULL) {
            return NULL;
        }
    }
    else {
        Py_XINCREF(left);
    }
    Py_XINCREF(right);
    PyBytes_ConcatAndDel(&left, right);
    if (left == NULL && !PyErr_Occurred()) {
        Py_RETURN_NONE;
    }
    return left;
}

/* Test PyBytes_DecodeEscape() */
static PyObject *
bytes_decodeescape(PyObject *Py_UNUSED(module), PyObject *args)
{
    const char *s;
    Py_ssize_t bsize;
    Py_ssize_t size = -100;
    const char *errors = NULL;

    if (!PyArg_ParseTuple(args, "z#|zn", &s, &bsize, &errors, &size))
        return NULL;

    if (size == -100) {
        size = bsize;
    }
    return PyBytes_DecodeEscape(s, size, errors, 0, NULL);
}


static PyMethodDef test_methods[] = {
    {"bytes_check", bytes_check, METH_O},
    {"bytes_checkexact", bytes_checkexact, METH_O},
    {"bytes_fromstringandsize", bytes_fromstringandsize, METH_VARARGS},
    {"bytes_fromstring", bytes_fromstring, METH_O},
    {"bytes_fromobject", bytes_fromobject, METH_O},
    {"bytes_size", bytes_size, METH_O},
    {"bytes_asstring", bytes_asstring, METH_VARARGS},
    {"bytes_asstringandsize", bytes_asstringandsize, METH_VARARGS},
    {"bytes_asstringandsize_null", bytes_asstringandsize_null, METH_VARARGS},
    {"bytes_repr", bytes_repr, METH_VARARGS},
    {"bytes_concat", bytes_concat, METH_VARARGS},
    {"bytes_concatanddel", bytes_concatanddel, METH_VARARGS},
    {"bytes_decodeescape", bytes_decodeescape, METH_VARARGS},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_Bytes(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/codec.c
================================================
#include "pyconfig.h"   // Py_GIL_DISABLED

// Need limited C API version 3.5 for PyCodec_NameReplaceErrors()
#if !defined(Py_GIL_DISABLED) && !defined(Py_LIMITED_API)
#  define Py_LIMITED_API 0x03050000
#endif

#include "parts.h"

static PyObject *
codec_namereplace_errors(PyObject *Py_UNUSED(module), PyObject *exc)
{
    assert(exc != NULL);
    return PyCodec_NameReplaceErrors(exc);
}

static PyMethodDef test_methods[] = {
    {"codec_namereplace_errors", codec_namereplace_errors, METH_O},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_Codec(PyObject *module)
{
    if (PyModule_AddFunctions(module, test_methods) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testlimitedcapi/complex.c
================================================
#include "parts.h"
#include "util.h"


static PyObject *
complex_check(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyComplex_Check(obj));
}

static PyObject *
complex_checkexact(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyComplex_CheckExact(obj));
}

static PyObject *
complex_fromdoubles(PyObject *Py_UNUSED(module), PyObject *args)
{
    double real, imag;

    if (!PyArg_ParseTuple(args, "dd", &real, &imag)) {
        return NULL;
    }

    return PyComplex_FromDoubles(real, imag);
}

static PyObject *
complex_realasdouble(PyObject *Py_UNUSED(module), PyObject *obj)
{
    double real;

    NULLABLE(obj);
    real = PyComplex_RealAsDouble(obj);

    if (real == -1. && PyErr_Occurred()) {
        return NULL;
    }

    return PyFloat_FromDouble(real);
}

static PyObject *
complex_imagasdouble(PyObject *Py_UNUSED(module), PyObject *obj)
{
    double imag;

    NULLABLE(obj);
    imag = PyComplex_ImagAsDouble(obj);

    if (imag == -1. && PyErr_Occurred()) {
        return NULL;
    }

    return PyFloat_FromDouble(imag);
}


static PyMethodDef test_methods[] = {
    {"complex_check", complex_check, METH_O},
    {"complex_checkexact", complex_checkexact, METH_O},
    {"complex_fromdoubles", complex_fromdoubles, METH_VARARGS},
    {"complex_realasdouble", complex_realasdouble, METH_O},
    {"complex_imagasdouble", complex_imagasdouble, METH_O},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_Complex(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/dict.c
================================================
#include "parts.h"
#include "util.h"


static PyObject *
dict_check(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyDict_Check(obj));
}

static PyObject *
dict_checkexact(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyDict_CheckExact(obj));
}

static PyObject *
dict_new(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    return PyDict_New();
}

static PyObject *
dictproxy_new(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PyDictProxy_New(obj);
}

static PyObject *
dict_clear(PyObject *self, PyObject *obj)
{
    PyDict_Clear(obj);
    Py_RETURN_NONE;
}

static PyObject *
dict_copy(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PyDict_Copy(obj);
}

static PyObject *
dict_contains(PyObject *self, PyObject *args)
{
    PyObject *obj, *key;
    if (!PyArg_ParseTuple(args, "OO", &obj, &key)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(key);
    RETURN_INT(PyDict_Contains(obj, key));
}

static PyObject *
dict_size(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_SIZE(PyDict_Size(obj));
}

static PyObject *
dict_getitem(PyObject *self, PyObject *args)
{
    PyObject *mapping, *key;
    if (!PyArg_ParseTuple(args, "OO", &mapping, &key)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(key);
    PyObject *value = PyDict_GetItem(mapping, key);
    if (value == NULL) {
        if (PyErr_Occurred()) {
            return NULL;
        }
        return Py_NewRef(PyExc_KeyError);
    }
    return Py_NewRef(value);
}

static PyObject *
dict_getitemstring(PyObject *self, PyObject *args)
{
    PyObject *mapping;
    const char *key;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#", &mapping, &key, &size)) {
        return NULL;
    }
    NULLABLE(mapping);
    PyObject *value = PyDict_GetItemString(mapping, key);
    if (value == NULL) {
        if (PyErr_Occurred()) {
            return NULL;
        }
        return Py_NewRef(PyExc_KeyError);
    }
    return Py_NewRef(value);
}

static PyObject *
dict_getitemwitherror(PyObject *self, PyObject *args)
{
    PyObject *mapping, *key;
    if (!PyArg_ParseTuple(args, "OO", &mapping, &key)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(key);
    PyObject *value = PyDict_GetItemWithError(mapping, key);
    if (value == NULL) {
        if (PyErr_Occurred()) {
            return NULL;
        }
        return Py_NewRef(PyExc_KeyError);
    }
    return Py_NewRef(value);
}


static PyObject *
dict_setitem(PyObject *self, PyObject *args)
{
    PyObject *mapping, *key, *value;
    if (!PyArg_ParseTuple(args, "OOO", &mapping, &key, &value)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(key);
    NULLABLE(value);
    RETURN_INT(PyDict_SetItem(mapping, key, value));
}

static PyObject *
dict_setitemstring(PyObject *self, PyObject *args)
{
    PyObject *mapping, *value;
    const char *key;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#O", &mapping, &key, &size, &value)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(value);
    RETURN_INT(PyDict_SetItemString(mapping, key, value));
}

static PyObject *
dict_delitem(PyObject *self, PyObject *args)
{
    PyObject *mapping, *key;
    if (!PyArg_ParseTuple(args, "OO", &mapping, &key)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(key);
    RETURN_INT(PyDict_DelItem(mapping, key));
}

static PyObject *
dict_delitemstring(PyObject *self, PyObject *args)
{
    PyObject *mapping;
    const char *key;
    Py_ssize_t size;
    if (!PyArg_ParseTuple(args, "Oz#", &mapping, &key, &size)) {
        return NULL;
    }
    NULLABLE(mapping);
    RETURN_INT(PyDict_DelItemString(mapping, key));
}

static PyObject *
dict_keys(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PyDict_Keys(obj);
}

static PyObject *
dict_values(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PyDict_Values(obj);
}

static PyObject *
dict_items(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PyDict_Items(obj);
}

static PyObject *
dict_next(PyObject *self, PyObject *args)
{
    PyObject *mapping, *key = UNINITIALIZED_PTR, *value = UNINITIALIZED_PTR;
    Py_ssize_t pos;
    if (!PyArg_ParseTuple(args, "On", &mapping, &pos)) {
        return NULL;
    }
    NULLABLE(mapping);
    int rc = PyDict_Next(mapping, &pos, &key, &value);
    if (rc != 0) {
        return Py_BuildValue("inOO", rc, pos, key, value);
    }
    assert(key == UNINITIALIZED_PTR);
    assert(value == UNINITIALIZED_PTR);
    if (PyErr_Occurred()) {
        return NULL;
    }
    Py_RETURN_NONE;
}

static PyObject *
dict_merge(PyObject *self, PyObject *args)
{
    PyObject *mapping, *mapping2;
    int override;
    if (!PyArg_ParseTuple(args, "OOi", &mapping, &mapping2, &override)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(mapping2);
    RETURN_INT(PyDict_Merge(mapping, mapping2, override));
}

static PyObject *
dict_update(PyObject *self, PyObject *args)
{
    PyObject *mapping, *mapping2;
    if (!PyArg_ParseTuple(args, "OO", &mapping, &mapping2)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(mapping2);
    RETURN_INT(PyDict_Update(mapping, mapping2));
}

static PyObject *
dict_mergefromseq2(PyObject *self, PyObject *args)
{
    PyObject *mapping, *seq;
    int override;
    if (!PyArg_ParseTuple(args, "OOi", &mapping, &seq, &override)) {
        return NULL;
    }
    NULLABLE(mapping);
    NULLABLE(seq);
    RETURN_INT(PyDict_MergeFromSeq2(mapping, seq, override));
}


static PyMethodDef test_methods[] = {
    {"dict_check", dict_check, METH_O},
    {"dict_checkexact", dict_checkexact, METH_O},
    {"dict_new", dict_new, METH_NOARGS},
    {"dictproxy_new", dictproxy_new, METH_O},
    {"dict_clear", dict_clear, METH_O},
    {"dict_copy", dict_copy, METH_O},
    {"dict_size", dict_size, METH_O},
    {"dict_getitem", dict_getitem, METH_VARARGS},
    {"dict_getitemwitherror", dict_getitemwitherror, METH_VARARGS},
    {"dict_getitemstring", dict_getitemstring, METH_VARARGS},
    {"dict_contains", dict_contains, METH_VARARGS},
    {"dict_setitem", dict_setitem, METH_VARARGS},
    {"dict_setitemstring", dict_setitemstring, METH_VARARGS},
    {"dict_delitem", dict_delitem, METH_VARARGS},
    {"dict_delitemstring", dict_delitemstring, METH_VARARGS},
    {"dict_keys", dict_keys, METH_O},
    {"dict_values", dict_values, METH_O},
    {"dict_items", dict_items, METH_O},
    {"dict_next", dict_next, METH_VARARGS},
    {"dict_merge", dict_merge, METH_VARARGS},
    {"dict_update", dict_update, METH_VARARGS},
    {"dict_mergefromseq2", dict_mergefromseq2, METH_VARARGS},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_Dict(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/eval.c
================================================
#include "parts.h"
#include "util.h"

static PyObject *
eval_get_func_name(PyObject *self, PyObject *func)
{
    return PyUnicode_FromString(PyEval_GetFuncName(func));
}

static PyObject *
eval_get_func_desc(PyObject *self, PyObject *func)
{
    return PyUnicode_FromString(PyEval_GetFuncDesc(func));
}

static PyObject *
eval_getlocals(PyObject *module, PyObject *Py_UNUSED(args))
{
    return Py_XNewRef(PyEval_GetLocals());
}

static PyObject *
eval_getglobals(PyObject *module, PyObject *Py_UNUSED(args))
{
    return Py_XNewRef(PyEval_GetGlobals());
}

static PyObject *
eval_getbuiltins(PyObject *module, PyObject *Py_UNUSED(args))
{
    return Py_XNewRef(PyEval_GetBuiltins());
}

static PyObject *
eval_getframe(PyObject *module, PyObject *Py_UNUSED(args))
{
    return Py_XNewRef(PyEval_GetFrame());
}

static PyObject *
eval_getframe_builtins(PyObject *module, PyObject *Py_UNUSED(args))
{
    return PyEval_GetFrameBuiltins();
}

static PyObject *
eval_getframe_globals(PyObject *module, PyObject *Py_UNUSED(args))
{
    return PyEval_GetFrameGlobals();
}

static PyObject *
eval_getframe_locals(PyObject *module, PyObject *Py_UNUSED(args))
{
    return PyEval_GetFrameLocals();
}

static PyObject *
eval_get_recursion_limit(PyObject *module, PyObject *Py_UNUSED(args))
{
    int limit = Py_GetRecursionLimit();
    return PyLong_FromLong(limit);
}

static PyObject *
eval_set_recursion_limit(PyObject *module, PyObject *args)
{
    int limit;
    if (!PyArg_ParseTuple(args, "i", &limit)) {
        return NULL;
    }
    Py_SetRecursionLimit(limit);
    Py_RETURN_NONE;
}

static PyMethodDef test_methods[] = {
    {"eval_get_func_name", eval_get_func_name, METH_O, NULL},
    {"eval_get_func_desc", eval_get_func_desc, METH_O, NULL},
    {"eval_getlocals", eval_getlocals, METH_NOARGS},
    {"eval_getglobals", eval_getglobals, METH_NOARGS},
    {"eval_getbuiltins", eval_getbuiltins, METH_NOARGS},
    {"eval_getframe", eval_getframe, METH_NOARGS},
    {"eval_getframe_builtins", eval_getframe_builtins, METH_NOARGS},
    {"eval_getframe_globals", eval_getframe_globals, METH_NOARGS},
    {"eval_getframe_locals", eval_getframe_locals, METH_NOARGS},
    {"eval_get_recursion_limit", eval_get_recursion_limit, METH_NOARGS},
    {"eval_set_recursion_limit", eval_set_recursion_limit, METH_VARARGS},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_Eval(PyObject *m)
{
    return PyModule_AddFunctions(m, test_methods);
}


================================================
File: /Modules/_testlimitedcapi/float.c
================================================
#include "parts.h"
#include "util.h"


static PyObject *
float_check(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyFloat_Check(obj));
}

static PyObject *
float_checkexact(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyFloat_CheckExact(obj));
}

static PyObject *
float_fromstring(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyFloat_FromString(obj);
}

static PyObject *
float_fromdouble(PyObject *Py_UNUSED(module), PyObject *obj)
{
    double d;

    if (!PyArg_Parse(obj, "d", &d)) {
        return NULL;
    }

    return PyFloat_FromDouble(d);
}

static PyObject *
float_asdouble(PyObject *Py_UNUSED(module), PyObject *obj)
{
    double d;

    NULLABLE(obj);
    d = PyFloat_AsDouble(obj);
    if (d == -1. && PyErr_Occurred()) {
        return NULL;
    }

    return PyFloat_FromDouble(d);
}

static PyObject *
float_getinfo(PyObject *Py_UNUSED(module), PyObject *Py_UNUSED(arg))
{
    return PyFloat_GetInfo();
}

static PyObject *
float_getmax(PyObject *Py_UNUSED(module), PyObject *Py_UNUSED(arg))
{
    return PyFloat_FromDouble(PyFloat_GetMax());
}

static PyObject *
float_getmin(PyObject *Py_UNUSED(module), PyObject *Py_UNUSED(arg))
{
    return PyFloat_FromDouble(PyFloat_GetMin());
}


static PyMethodDef test_methods[] = {
    {"float_check", float_check, METH_O},
    {"float_checkexact", float_checkexact, METH_O},
    {"float_fromstring", float_fromstring, METH_O},
    {"float_fromdouble", float_fromdouble, METH_O},
    {"float_asdouble", float_asdouble, METH_O},
    {"float_getinfo", float_getinfo, METH_NOARGS},
    {"float_getmax", float_getmax, METH_NOARGS},
    {"float_getmin", float_getmin, METH_NOARGS},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_Float(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/heaptype_relative.c
================================================
// Need limited C API version 3.12 for PyType_FromMetaclass()
#include "pyconfig.h"   // Py_GIL_DISABLED
#if !defined(Py_GIL_DISABLED) && !defined(Py_LIMITED_API)
#  define Py_LIMITED_API 0x030c0000
#endif

#include "parts.h"
#include <stddef.h>               // max_align_t
#include <string.h>               // memset

#include "clinic/heaptype_relative.c.h"

static PyType_Slot empty_slots[] = {
    {0, NULL},
};

static PyObject *
make_sized_heaptypes(PyObject *module, PyObject *args)
{
    PyObject *base = NULL;
    PyObject *sub = NULL;
    PyObject *instance = NULL;
    PyObject *result = NULL;

    int extra_base_size, basicsize;

    int r = PyArg_ParseTuple(args, "ii", &extra_base_size, &basicsize);
    if (!r) {
        goto finally;
    }

    PyType_Spec base_spec = {
        .name = "_testcapi.Base",
        .basicsize = sizeof(PyObject) + extra_base_size,
        .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        .slots = empty_slots,
    };
    PyType_Spec sub_spec = {
        .name = "_testcapi.Sub",
        .basicsize = basicsize,
        .flags = Py_TPFLAGS_DEFAULT,
        .slots = empty_slots,
    };

    base = PyType_FromMetaclass(NULL, module, &base_spec, NULL);
    if (!base) {
        goto finally;
    }
    sub = PyType_FromMetaclass(NULL, module, &sub_spec, base);
    if (!sub) {
        goto finally;
    }
    instance = PyObject_CallNoArgs(sub);
    if (!instance) {
        goto finally;
    }
    char *data_ptr = PyObject_GetTypeData(instance, (PyTypeObject *)sub);
    if (!data_ptr) {
        goto finally;
    }
    Py_ssize_t data_size = PyType_GetTypeDataSize((PyTypeObject *)sub);
    if (data_size < 0) {
        goto finally;
    }

    result = Py_BuildValue("OOOKnn", base, sub, instance,
                           (unsigned long long)data_ptr,
                           (Py_ssize_t)(data_ptr - (char*)instance),
                           data_size);
  finally:
    Py_XDECREF(base);
    Py_XDECREF(sub);
    Py_XDECREF(instance);
    return result;
}

static PyObject *
var_heaptype_set_data_to_3s(
    PyObject *self, PyTypeObject *defining_class,
    PyObject **args, Py_ssize_t nargs, PyObject *kwnames)
{
    void *data_ptr = PyObject_GetTypeData(self, defining_class);
    if (!data_ptr) {
        return NULL;
    }
    Py_ssize_t data_size = PyType_GetTypeDataSize(defining_class);
    if (data_size < 0) {
        return NULL;
    }
    memset(data_ptr, 3, data_size);
    Py_RETURN_NONE;
}

static PyObject *
var_heaptype_get_data(PyObject *self, PyTypeObject *defining_class,
                      PyObject **args, Py_ssize_t nargs, PyObject *kwnames)
{
    void *data_ptr = PyObject_GetTypeData(self, defining_class);
    if (!data_ptr) {
        return NULL;
    }
    Py_ssize_t data_size = PyType_GetTypeDataSize(defining_class);
    if (data_size < 0) {
        return NULL;
    }
    return PyBytes_FromStringAndSize(data_ptr, data_size);
}

static PyMethodDef var_heaptype_methods[] = {
    {"set_data_to_3s", _PyCFunction_CAST(var_heaptype_set_data_to_3s),
        METH_METHOD | METH_FASTCALL | METH_KEYWORDS},
    {"get_data", _PyCFunction_CAST(var_heaptype_get_data),
        METH_METHOD | METH_FASTCALL | METH_KEYWORDS},
    {NULL},
};

static PyObject *
subclass_var_heaptype(PyObject *module, PyObject *args)
{
    PyObject *result = NULL;

    PyObject *base; // borrowed from args
    int basicsize, itemsize;
    long pfunc;

    int r = PyArg_ParseTuple(args, "Oiil", &base, &basicsize, &itemsize, &pfunc);
    if (!r) {
        goto finally;
    }

    PyType_Slot slots[] = {
        {Py_tp_methods, var_heaptype_methods},
        {0, NULL},
    };

    PyType_Spec sub_spec = {
        .name = "_testcapi.Sub",
        .basicsize = basicsize,
        .itemsize = itemsize,
        .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_ITEMS_AT_END,
        .slots = slots,
    };

    result = PyType_FromMetaclass(NULL, module, &sub_spec, base);
  finally:
    return result;
}

static PyObject *
subclass_heaptype(PyObject *module, PyObject *args)
{
    PyObject *result = NULL;

    PyObject *base; // borrowed from args
    int basicsize, itemsize;

    int r = PyArg_ParseTuple(args, "Oii", &base, &basicsize, &itemsize);
    if (!r) {
        goto finally;
    }

    PyType_Slot slots[] = {
        {Py_tp_methods, var_heaptype_methods},
        {0, NULL},
    };

    PyType_Spec sub_spec = {
        .name = "_testcapi.Sub",
        .basicsize = basicsize,
        .itemsize = itemsize,
        .flags = Py_TPFLAGS_DEFAULT,
        .slots = slots,
    };

    result = PyType_FromMetaclass(NULL, module, &sub_spec, base);
  finally:
    return result;
}

static PyMemberDef *
heaptype_with_member_extract_and_check_memb(PyObject *self)
{
    PyMemberDef *def = PyType_GetSlot(Py_TYPE(self), Py_tp_members);
    if (!def) {
        if (!PyErr_Occurred()) {
            PyErr_SetString(PyExc_ValueError, "tp_members is NULL");
        }
        return NULL;
    }
    if (!def[0].name) {
        PyErr_SetString(PyExc_ValueError, "tp_members[0] is NULL");
        return NULL;
    }
    if (def[1].name) {
        PyErr_SetString(PyExc_ValueError, "tp_members[1] is not NULL");
        return NULL;
    }
    if (strcmp(def[0].name, "memb")) {
        PyErr_SetString(PyExc_ValueError, "tp_members[0] is not for `memb`");
        return NULL;
    }
    if (def[0].flags) {
        PyErr_SetString(PyExc_ValueError, "tp_members[0] has flags set");
        return NULL;
    }
    return def;
}

static PyObject *
heaptype_with_member_get_memb(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    PyMemberDef *def = heaptype_with_member_extract_and_check_memb(self);
    return PyMember_GetOne((const char *)self, def);
}

static PyObject *
heaptype_with_member_set_memb(PyObject *self, PyObject *value)
{
    PyMemberDef *def = heaptype_with_member_extract_and_check_memb(self);
    int r = PyMember_SetOne((char *)self, def, value);
    if (r < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}

static PyObject *
get_memb_offset(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    PyMemberDef *def = heaptype_with_member_extract_and_check_memb(self);
    return PyLong_FromSsize_t(def->offset);
}

static PyObject *
heaptype_with_member_get_memb_relative(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    PyMemberDef def = {"memb", Py_T_BYTE, sizeof(PyObject), Py_RELATIVE_OFFSET};
    return PyMember_GetOne((const char *)self, &def);
}

static PyObject *
heaptype_with_member_set_memb_relative(PyObject *self, PyObject *value)
{
    PyMemberDef def = {"memb", Py_T_BYTE, sizeof(PyObject), Py_RELATIVE_OFFSET};
    int r = PyMember_SetOne((char *)self, &def, value);
    if (r < 0) {
        return NULL;
    }
    Py_RETURN_NONE;
}

typedef struct {
    int padding;  // just so the offset isn't 0
    PyObject *dict;
} HeapCTypeWithDictStruct;

static void
heapctypewithrelativedict_dealloc(PyObject* self)
{
    PyTypeObject *tp = Py_TYPE(self);
    HeapCTypeWithDictStruct *data = PyObject_GetTypeData(self, tp);
    Py_XDECREF(data->dict);
    PyObject_Free(self);
    Py_DECREF(tp);
}

static PyType_Spec HeapCTypeWithRelativeDict_spec = {
    .name = "_testcapi.HeapCTypeWithRelativeDict",
    .basicsize = -(int)sizeof(HeapCTypeWithDictStruct),
    .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .slots = (PyType_Slot[]) {
        {Py_tp_dealloc, heapctypewithrelativedict_dealloc},
        {Py_tp_getset, (PyGetSetDef[]) {
            {"__dict__", PyObject_GenericGetDict, PyObject_GenericSetDict},
            {NULL} /* Sentinel */
        }},
        {Py_tp_members, (PyMemberDef[]) {
            {"dictobj", _Py_T_OBJECT,
             offsetof(HeapCTypeWithDictStruct, dict),
             Py_RELATIVE_OFFSET},
            {"__dictoffset__", Py_T_PYSSIZET,
             offsetof(HeapCTypeWithDictStruct, dict),
             Py_READONLY | Py_RELATIVE_OFFSET},
            {NULL} /* Sentinel */
        }},
        {0, 0},
    }
};

typedef struct {
    char padding;  // just so the offset isn't 0
    PyObject *weakreflist;
} HeapCTypeWithWeakrefStruct;

static void
heapctypewithrelativeweakref_dealloc(PyObject* self)
{
    PyTypeObject *tp = Py_TYPE(self);
    HeapCTypeWithWeakrefStruct *data = PyObject_GetTypeData(self, tp);
    if (data->weakreflist != NULL) {
        PyObject_ClearWeakRefs(self);
    }
    Py_XDECREF(data->weakreflist);
    PyObject_Free(self);
    Py_DECREF(tp);
}

static PyType_Spec HeapCTypeWithRelativeWeakref_spec = {
    .name = "_testcapi.HeapCTypeWithRelativeWeakref",
    .basicsize = -(int)sizeof(HeapCTypeWithWeakrefStruct),
    .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
    .slots = (PyType_Slot[]) {
        {Py_tp_dealloc, heapctypewithrelativeweakref_dealloc},
        {Py_tp_members, (PyMemberDef[]) {
            {"weakreflist", _Py_T_OBJECT,
             offsetof(HeapCTypeWithWeakrefStruct, weakreflist),
             Py_RELATIVE_OFFSET},
            {"__weaklistoffset__", Py_T_PYSSIZET,
             offsetof(HeapCTypeWithWeakrefStruct, weakreflist),
             Py_READONLY | Py_RELATIVE_OFFSET},
            {NULL} /* Sentinel */
        }},
        {0, 0},
    }
};

static PyMethodDef heaptype_with_member_methods[] = {
    {"get_memb", heaptype_with_member_get_memb, METH_NOARGS},
    {"set_memb", heaptype_with_member_set_memb, METH_O},
    {"get_memb_offset", get_memb_offset, METH_NOARGS},
    {"get_memb_relative", heaptype_with_member_get_memb_relative, METH_NOARGS},
    {"set_memb_relative", heaptype_with_member_set_memb_relative, METH_O},
    {NULL},
};

/*[clinic input]
make_heaptype_with_member

    extra_base_size: int = 0
    basicsize: int = 0
    member_offset: int = 0
    add_relative_flag: bool = False
    *
    member_name: str = "memb"
    member_flags: int = 0
    member_type: int(c_default="Py_T_BYTE") = -1

[clinic start generated code]*/

static PyObject *
make_heaptype_with_member_impl(PyObject *module, int extra_base_size,
                               int basicsize, int member_offset,
                               int add_relative_flag,
                               const char *member_name, int member_flags,
                               int member_type)
/*[clinic end generated code: output=7005db9a07396997 input=007e29cdbe1d3390]*/
{
    PyObject *base = NULL;
    PyObject *result = NULL;

    PyType_Spec base_spec = {
        .name = "_testcapi.Base",
        .basicsize = sizeof(PyObject) + extra_base_size,
        .flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,
        .slots = empty_slots,
    };
    base = PyType_FromMetaclass(NULL, module, &base_spec, NULL);
    if (!base) {
        goto finally;
    }

    PyMemberDef members[] = {
        {member_name, member_type, member_offset,
            member_flags | (add_relative_flag ? Py_RELATIVE_OFFSET : 0)},
        {0},
    };
    PyType_Slot slots[] = {
        {Py_tp_members, members},
        {Py_tp_methods, heaptype_with_member_methods},
        {0, NULL},
    };

    PyType_Spec sub_spec = {
        .name = "_testcapi.Sub",
        .basicsize = basicsize,
        .flags = Py_TPFLAGS_DEFAULT,
        .slots = slots,
    };

    result = PyType_FromMetaclass(NULL, module, &sub_spec, base);
  finally:
    Py_XDECREF(base);
    return result;
}


static PyObject *
test_alignof_max_align_t(PyObject *module, PyObject *Py_UNUSED(ignored))
{
    // We define ALIGNOF_MAX_ALIGN_T even if the compiler doesn't support
    // max_align_t. Double-check that it's correct.
    assert(ALIGNOF_MAX_ALIGN_T > 0);
    assert(ALIGNOF_MAX_ALIGN_T >= _Alignof(long long));
    assert(ALIGNOF_MAX_ALIGN_T >= _Alignof(long double));
    assert(ALIGNOF_MAX_ALIGN_T >= _Alignof(void*));
    assert(ALIGNOF_MAX_ALIGN_T >= _Alignof(void (*)(void)));

    // Ensure it's a power of two
    assert((ALIGNOF_MAX_ALIGN_T & (ALIGNOF_MAX_ALIGN_T - 1)) == 0);

    Py_RETURN_NONE;
}

static PyMethodDef TestMethods[] = {
    {"make_sized_heaptypes", make_sized_heaptypes, METH_VARARGS},
    {"subclass_var_heaptype", subclass_var_heaptype, METH_VARARGS},
    {"subclass_heaptype", subclass_heaptype, METH_VARARGS},
    MAKE_HEAPTYPE_WITH_MEMBER_METHODDEF
    {"test_alignof_max_align_t", test_alignof_max_align_t, METH_NOARGS},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_HeaptypeRelative(PyObject *m)
{
    if (PyModule_AddFunctions(m, TestMethods) < 0) {
        return -1;
    }

    if (PyModule_AddIntMacro(m, ALIGNOF_MAX_ALIGN_T) < 0) {
        return -1;
    }

#define ADD_FROM_SPEC(SPEC) do {                                \
        PyObject *tp = PyType_FromSpec(SPEC);                   \
        if (!tp) {                                              \
            return -1;                                          \
        }                                                       \
        if (PyModule_AddType(m, (PyTypeObject *)tp) < 0) {      \
            return -1;                                          \
        }                                                       \
    } while (0)

    PyObject *tp;

    tp = PyType_FromSpec(&HeapCTypeWithRelativeDict_spec);
    if (!tp) {
        return -1;
    }
    if (PyModule_AddType(m, (PyTypeObject *)tp) < 0) {
        return -1;
    }
    Py_DECREF(tp);

    tp = PyType_FromSpec(&HeapCTypeWithRelativeWeakref_spec);
    if (!tp) {
        return -1;
    }
    if (PyModule_AddType(m, (PyTypeObject *)tp) < 0) {
        return -1;
    }
    Py_DECREF(tp);

    if (PyModule_AddIntMacro(m, Py_T_PYSSIZET) < 0) {
        return -1;
    }
    if (PyModule_AddIntMacro(m, Py_READONLY) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/list.c
================================================
// Need limited C API version 3.13 for PyList_GetItemRef()
#include "pyconfig.h"   // Py_GIL_DISABLED
#if !defined(Py_GIL_DISABLED) && !defined(Py_LIMITED_API)
#  define Py_LIMITED_API 0x030d0000
#endif

#include "parts.h"
#include "util.h"

static PyObject *
list_check(PyObject* Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyList_Check(obj));
}

static PyObject *
list_check_exact(PyObject* Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyList_CheckExact(obj));
}

static PyObject *
list_new(PyObject* Py_UNUSED(module), PyObject *obj)
{
    return PyList_New(PyLong_AsSsize_t(obj));
}

static PyObject *
list_size(PyObject *Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    RETURN_SIZE(PyList_Size(obj));
}

static PyObject *
list_getitem(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t i;
    if (!PyArg_ParseTuple(args, "On", &obj, &i)) {
        return NULL;
    }
    NULLABLE(obj);
    return Py_XNewRef(PyList_GetItem(obj, i));
}

static PyObject *
list_get_item_ref(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t i;
    if (!PyArg_ParseTuple(args, "On", &obj, &i)) {
        return NULL;
    }
    NULLABLE(obj);
    return PyList_GetItemRef(obj, i);
}

static PyObject *
list_setitem(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj, *value;
    Py_ssize_t i;
    if (!PyArg_ParseTuple(args, "OnO", &obj, &i, &value)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(value);
    RETURN_INT(PyList_SetItem(obj, i, Py_XNewRef(value)));

}

static PyObject *
list_insert(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj, *value;
    Py_ssize_t where;
    if (!PyArg_ParseTuple(args, "OnO", &obj, &where, &value)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(value);
    RETURN_INT(PyList_Insert(obj, where, Py_XNewRef(value)));

}

static PyObject *
list_append(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj, *value;
    if (!PyArg_ParseTuple(args, "OO", &obj, &value)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(value);
    RETURN_INT(PyList_Append(obj, value));
}

static PyObject *
list_getslice(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj;
    Py_ssize_t ilow, ihigh;
    if (!PyArg_ParseTuple(args, "Onn", &obj, &ilow, &ihigh)) {
        return NULL;
    }
    NULLABLE(obj);
    return PyList_GetSlice(obj, ilow, ihigh);

}

static PyObject *
list_setslice(PyObject *Py_UNUSED(module), PyObject *args)
{
    PyObject *obj, *value;
    Py_ssize_t ilow, ihigh;
    if (!PyArg_ParseTuple(args, "OnnO", &obj, &ilow, &ihigh, &value)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(value);
    RETURN_INT(PyList_SetSlice(obj, ilow, ihigh, value));
}

static PyObject *
list_sort(PyObject* Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    RETURN_INT(PyList_Sort(obj));
}

static PyObject *
list_reverse(PyObject* Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    RETURN_INT(PyList_Reverse(obj));
}

static PyObject *
list_astuple(PyObject* Py_UNUSED(module), PyObject *obj)
{
    NULLABLE(obj);
    return PyList_AsTuple(obj);
}


static PyMethodDef test_methods[] = {
    {"list_check", list_check, METH_O},
    {"list_check_exact", list_check_exact, METH_O},
    {"list_new", list_new, METH_O},
    {"list_size", list_size, METH_O},
    {"list_getitem", list_getitem, METH_VARARGS},
    {"list_get_item_ref", list_get_item_ref, METH_VARARGS},
    {"list_setitem", list_setitem, METH_VARARGS},
    {"list_insert", list_insert, METH_VARARGS},
    {"list_append", list_append, METH_VARARGS},
    {"list_getslice", list_getslice, METH_VARARGS},
    {"list_setslice", list_setslice, METH_VARARGS},
    {"list_sort", list_sort, METH_O},
    {"list_reverse", list_reverse, METH_O},
    {"list_astuple", list_astuple, METH_O},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_List(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/long.c
================================================
#include "pyconfig.h"   // Py_GIL_DISABLED
#ifndef Py_GIL_DISABLED
   // Need limited C API 3.14 to test PyLong_AsInt64()
#  define Py_LIMITED_API 0x030e0000
#endif

#include "parts.h"
#include "util.h"
#include "clinic/long.c.h"

/*[clinic input]
module _testlimitedcapi
[clinic start generated code]*/
/*[clinic end generated code: output=da39a3ee5e6b4b0d input=2700057f9c1135ba]*/


static PyObject *
raiseTestError(const char* test_name, const char* msg)
{
    PyErr_Format(PyExc_AssertionError, "%s: %s", test_name, msg);
    return NULL;
}

/* Tests of PyLong_{As, From}{Unsigned,}Long(), and
   PyLong_{As, From}{Unsigned,}LongLong().

   Note that the meat of the test is contained in testcapi_long.h.
   This is revolting, but delicate code duplication is worse:  "almost
   exactly the same" code is needed to test long long, but the ubiquitous
   dependence on type names makes it impossible to use a parameterized
   function.  A giant macro would be even worse than this.  A C++ template
   would be perfect.

   The "report an error" functions are deliberately not part of the #include
   file:  if the test fails, you can set a breakpoint in the appropriate
   error function directly, and crawl back from there in the debugger.
*/

#define UNBIND(X)  Py_DECREF(X); (X) = NULL

static PyObject *
raise_test_long_error(const char* msg)
{
    return raiseTestError("test_long_api", msg);
}

// Test PyLong_FromLong()/PyLong_AsLong()
// and PyLong_FromUnsignedLong()/PyLong_AsUnsignedLong().

#define TESTNAME        test_long_api_inner
#define TYPENAME        long
#define F_S_TO_PY       PyLong_FromLong
#define F_PY_TO_S       PyLong_AsLong
#define F_U_TO_PY       PyLong_FromUnsignedLong
#define F_PY_TO_U       PyLong_AsUnsignedLong

#include "testcapi_long.h"

/*[clinic input]
_testlimitedcapi.test_long_api
[clinic start generated code]*/

static PyObject *
_testlimitedcapi_test_long_api_impl(PyObject *module)
/*[clinic end generated code: output=06a2c02366d1853a input=9012b3d6a483df63]*/
{
    return TESTNAME(raise_test_long_error);
}

#undef TESTNAME
#undef TYPENAME
#undef F_S_TO_PY
#undef F_PY_TO_S
#undef F_U_TO_PY
#undef F_PY_TO_U

// Test PyLong_FromLongLong()/PyLong_AsLongLong()
// and PyLong_FromUnsignedLongLong()/PyLong_AsUnsignedLongLong().

static PyObject *
raise_test_longlong_error(const char* msg)
{
    return raiseTestError("test_longlong_api", msg);
}

#define TESTNAME        test_longlong_api_inner
#define TYPENAME        long long
#define F_S_TO_PY       PyLong_FromLongLong
#define F_PY_TO_S       PyLong_AsLongLong
#define F_U_TO_PY       PyLong_FromUnsignedLongLong
#define F_PY_TO_U       PyLong_AsUnsignedLongLong

#include "testcapi_long.h"

/*[clinic input]
_testlimitedcapi.test_longlong_api
[clinic start generated code]*/

static PyObject *
_testlimitedcapi_test_longlong_api_impl(PyObject *module)
/*[clinic end generated code: output=8faa10e1c35214bf input=2b582a9d25bd68e7]*/
{
    return TESTNAME(raise_test_longlong_error);
}

#undef TESTNAME
#undef TYPENAME
#undef F_S_TO_PY
#undef F_PY_TO_S
#undef F_U_TO_PY
#undef F_PY_TO_U


/*[clinic input]
_testlimitedcapi.test_long_and_overflow

Test the PyLong_AsLongAndOverflow API.

General conversion to PY_LONG is tested by test_long_api_inner.
This test will concentrate on proper handling of overflow.
[clinic start generated code]*/

static PyObject *
_testlimitedcapi_test_long_and_overflow_impl(PyObject *module)
/*[clinic end generated code: output=fdfd3c1eeabb6d14 input=e3a18791de6519fe]*/
{
    PyObject *num, *one, *temp;
    long value;
    int overflow;

    /* Test that overflow is set properly for a large value. */
    /* num is a number larger than LONG_MAX even on 64-bit platforms */
    num = PyLong_FromString("FFFFFFFFFFFFFFFFFFFFFFFF", NULL, 16);
    if (num == NULL)
        return NULL;
    overflow = 1234;
    value = PyLong_AsLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != -1)
        return raiseTestError("test_long_and_overflow",
            "return value was not set to -1");
    if (overflow != 1)
        return raiseTestError("test_long_and_overflow",
            "overflow was not set to 1");

    /* Same again, with num = LONG_MAX + 1 */
    num = PyLong_FromLong(LONG_MAX);
    if (num == NULL)
        return NULL;
    one = PyLong_FromLong(1L);
    if (one == NULL) {
        Py_DECREF(num);
        return NULL;
    }
    temp = PyNumber_Add(num, one);
    Py_DECREF(one);
    Py_DECREF(num);
    num = temp;
    if (num == NULL)
        return NULL;
    overflow = 0;
    value = PyLong_AsLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != -1)
        return raiseTestError("test_long_and_overflow",
            "return value was not set to -1");
    if (overflow != 1)
        return raiseTestError("test_long_and_overflow",
            "overflow was not set to 1");

    /* Test that overflow is set properly for a large negative value. */
    /* num is a number smaller than LONG_MIN even on 64-bit platforms */
    num = PyLong_FromString("-FFFFFFFFFFFFFFFFFFFFFFFF", NULL, 16);
    if (num == NULL)
        return NULL;
    overflow = 1234;
    value = PyLong_AsLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != -1)
        return raiseTestError("test_long_and_overflow",
            "return value was not set to -1");
    if (overflow != -1)
        return raiseTestError("test_long_and_overflow",
            "overflow was not set to -1");

    /* Same again, with num = LONG_MIN - 1 */
    num = PyLong_FromLong(LONG_MIN);
    if (num == NULL)
        return NULL;
    one = PyLong_FromLong(1L);
    if (one == NULL) {
        Py_DECREF(num);
        return NULL;
    }
    temp = PyNumber_Subtract(num, one);
    Py_DECREF(one);
    Py_DECREF(num); num = temp;
    if (num == NULL)
        return NULL;
    overflow = 0;
    value = PyLong_AsLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != -1)
        return raiseTestError("test_long_and_overflow",
            "return value was not set to -1");
    if (overflow != -1)
        return raiseTestError("test_long_and_overflow",
            "overflow was not set to -1");

    /* Test that overflow is cleared properly for small values. */
    num = PyLong_FromString("FF", NULL, 16);
    if (num == NULL)
        return NULL;
    overflow = 1234;
    value = PyLong_AsLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != 0xFF)
        return raiseTestError("test_long_and_overflow",
            "expected return value 0xFF");
    if (overflow != 0)
        return raiseTestError("test_long_and_overflow",
            "overflow was not cleared");

    num = PyLong_FromString("-FF", NULL, 16);
    if (num == NULL)
        return NULL;
    overflow = 0;
    value = PyLong_AsLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != -0xFF)
        return raiseTestError("test_long_and_overflow",
            "expected return value 0xFF");
    if (overflow != 0)
        return raiseTestError("test_long_and_overflow",
            "overflow was set incorrectly");

    num = PyLong_FromLong(LONG_MAX);
    if (num == NULL)
        return NULL;
    overflow = 1234;
    value = PyLong_AsLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != LONG_MAX)
        return raiseTestError("test_long_and_overflow",
            "expected return value LONG_MAX");
    if (overflow != 0)
        return raiseTestError("test_long_and_overflow",
            "overflow was not cleared");

    num = PyLong_FromLong(LONG_MIN);
    if (num == NULL)
        return NULL;
    overflow = 0;
    value = PyLong_AsLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != LONG_MIN)
        return raiseTestError("test_long_and_overflow",
            "expected return value LONG_MIN");
    if (overflow != 0)
        return raiseTestError("test_long_and_overflow",
            "overflow was not cleared");

    Py_RETURN_NONE;
}

/*[clinic input]
_testlimitedcapi.test_long_long_and_overflow

Test the PyLong_AsLongLongAndOverflow API.

General conversion to long long is tested by test_long_api_inner.
This test will concentrate on proper handling of overflow.
[clinic start generated code]*/

static PyObject *
_testlimitedcapi_test_long_long_and_overflow_impl(PyObject *module)
/*[clinic end generated code: output=3d2721a49c09a307 input=741c593b606cc6b3]*/
{
    PyObject *num, *one, *temp;
    long long value;
    int overflow;

    /* Test that overflow is set properly for a large value. */
    /* num is a number larger than LLONG_MAX on a typical machine. */
    num = PyLong_FromString("FFFFFFFFFFFFFFFFFFFFFFFF", NULL, 16);
    if (num == NULL)
        return NULL;
    overflow = 1234;
    value = PyLong_AsLongLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != -1)
        return raiseTestError("test_long_long_and_overflow",
            "return value was not set to -1");
    if (overflow != 1)
        return raiseTestError("test_long_long_and_overflow",
            "overflow was not set to 1");

    /* Same again, with num = LLONG_MAX + 1 */
    num = PyLong_FromLongLong(LLONG_MAX);
    if (num == NULL)
        return NULL;
    one = PyLong_FromLong(1L);
    if (one == NULL) {
        Py_DECREF(num);
        return NULL;
    }
    temp = PyNumber_Add(num, one);
    Py_DECREF(one);
    Py_DECREF(num); num = temp;
    if (num == NULL)
        return NULL;
    overflow = 0;
    value = PyLong_AsLongLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != -1)
        return raiseTestError("test_long_long_and_overflow",
            "return value was not set to -1");
    if (overflow != 1)
        return raiseTestError("test_long_long_and_overflow",
            "overflow was not set to 1");

    /* Test that overflow is set properly for a large negative value. */
    /* num is a number smaller than LLONG_MIN on a typical platform */
    num = PyLong_FromString("-FFFFFFFFFFFFFFFFFFFFFFFF", NULL, 16);
    if (num == NULL)
        return NULL;
    overflow = 1234;
    value = PyLong_AsLongLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != -1)
        return raiseTestError("test_long_long_and_overflow",
            "return value was not set to -1");
    if (overflow != -1)
        return raiseTestError("test_long_long_and_overflow",
            "overflow was not set to -1");

    /* Same again, with num = LLONG_MIN - 1 */
    num = PyLong_FromLongLong(LLONG_MIN);
    if (num == NULL)
        return NULL;
    one = PyLong_FromLong(1L);
    if (one == NULL) {
        Py_DECREF(num);
        return NULL;
    }
    temp = PyNumber_Subtract(num, one);
    Py_DECREF(one);
    Py_DECREF(num); num = temp;
    if (num == NULL)
        return NULL;
    overflow = 0;
    value = PyLong_AsLongLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != -1)
        return raiseTestError("test_long_long_and_overflow",
            "return value was not set to -1");
    if (overflow != -1)
        return raiseTestError("test_long_long_and_overflow",
            "overflow was not set to -1");

    /* Test that overflow is cleared properly for small values. */
    num = PyLong_FromString("FF", NULL, 16);
    if (num == NULL)
        return NULL;
    overflow = 1234;
    value = PyLong_AsLongLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != 0xFF)
        return raiseTestError("test_long_long_and_overflow",
            "expected return value 0xFF");
    if (overflow != 0)
        return raiseTestError("test_long_long_and_overflow",
            "overflow was not cleared");

    num = PyLong_FromString("-FF", NULL, 16);
    if (num == NULL)
        return NULL;
    overflow = 0;
    value = PyLong_AsLongLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != -0xFF)
        return raiseTestError("test_long_long_and_overflow",
            "expected return value 0xFF");
    if (overflow != 0)
        return raiseTestError("test_long_long_and_overflow",
            "overflow was set incorrectly");

    num = PyLong_FromLongLong(LLONG_MAX);
    if (num == NULL)
        return NULL;
    overflow = 1234;
    value = PyLong_AsLongLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != LLONG_MAX)
        return raiseTestError("test_long_long_and_overflow",
            "expected return value LLONG_MAX");
    if (overflow != 0)
        return raiseTestError("test_long_long_and_overflow",
            "overflow was not cleared");

    num = PyLong_FromLongLong(LLONG_MIN);
    if (num == NULL)
        return NULL;
    overflow = 0;
    value = PyLong_AsLongLongAndOverflow(num, &overflow);
    Py_DECREF(num);
    if (value == -1 && PyErr_Occurred())
        return NULL;
    if (value != LLONG_MIN)
        return raiseTestError("test_long_long_and_overflow",
            "expected return value LLONG_MIN");
    if (overflow != 0)
        return raiseTestError("test_long_long_and_overflow",
            "overflow was not cleared");

    Py_RETURN_NONE;
}

/*[clinic input]
_testlimitedcapi.test_long_as_size_t

Test the PyLong_As{Size,Ssize}_t API.

At present this just tests that non-integer arguments are handled correctly.
It should be extended to test overflow handling.
[clinic start generated code]*/

static PyObject *
_testlimitedcapi_test_long_as_size_t_impl(PyObject *module)
/*[clinic end generated code: output=297a9f14a42f55af input=8923d8f2038c46f4]*/
{
    size_t out_u;
    Py_ssize_t out_s;

    Py_INCREF(Py_None);

    out_u = PyLong_AsSize_t(Py_None);
    if (out_u != (size_t)-1 || !PyErr_Occurred())
        return raiseTestError("test_long_as_size_t",
                              "PyLong_AsSize_t(None) didn't complain");
    if (!PyErr_ExceptionMatches(PyExc_TypeError))
        return raiseTestError("test_long_as_size_t",
                              "PyLong_AsSize_t(None) raised "
                              "something other than TypeError");
    PyErr_Clear();

    out_s = PyLong_AsSsize_t(Py_None);
    if (out_s != (Py_ssize_t)-1 || !PyErr_Occurred())
        return raiseTestError("test_long_as_size_t",
                              "PyLong_AsSsize_t(None) didn't complain");
    if (!PyErr_ExceptionMatches(PyExc_TypeError))
        return raiseTestError("test_long_as_size_t",
                              "PyLong_AsSsize_t(None) raised "
                              "something other than TypeError");
    PyErr_Clear();

    /* Py_INCREF(Py_None) omitted - we already have a reference to it. */
    return Py_None;
}

/*[clinic input]
_testlimitedcapi.test_long_as_unsigned_long_long_mask
[clinic start generated code]*/

static PyObject *
_testlimitedcapi_test_long_as_unsigned_long_long_mask_impl(PyObject *module)
/*[clinic end generated code: output=90be09ffeec8ecab input=17c660bd58becad5]*/
{
    unsigned long long res = PyLong_AsUnsignedLongLongMask(NULL);

    if (res != (unsigned long long)-1 || !PyErr_Occurred()) {
        return raiseTestError("test_long_as_unsigned_long_long_mask",
                              "PyLong_AsUnsignedLongLongMask(NULL) didn't "
                              "complain");
    }
    if (!PyErr_ExceptionMatches(PyExc_SystemError)) {
        return raiseTestError("test_long_as_unsigned_long_long_mask",
                              "PyLong_AsUnsignedLongLongMask(NULL) raised "
                              "something other than SystemError");
    }
    PyErr_Clear();
    Py_RETURN_NONE;
}

/*[clinic input]
_testlimitedcapi.test_long_as_double
[clinic start generated code]*/

static PyObject *
_testlimitedcapi_test_long_as_double_impl(PyObject *module)
/*[clinic end generated code: output=0e688c2acf224f88 input=e7b5712385064a48]*/
{
    double out;

    Py_INCREF(Py_None);

    out = PyLong_AsDouble(Py_None);
    if (out != -1.0 || !PyErr_Occurred())
        return raiseTestError("test_long_as_double",
                              "PyLong_AsDouble(None) didn't complain");
    if (!PyErr_ExceptionMatches(PyExc_TypeError))
        return raiseTestError("test_long_as_double",
                              "PyLong_AsDouble(None) raised "
                              "something other than TypeError");
    PyErr_Clear();

    /* Py_INCREF(Py_None) omitted - we already have a reference to it. */
    return Py_None;
}

static PyObject *
pylong_check(PyObject *module, PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyLong_Check(obj));
}

static PyObject *
pylong_checkexact(PyObject *module, PyObject *obj)
{
    NULLABLE(obj);
    return PyLong_FromLong(PyLong_CheckExact(obj));
}

static PyObject *
pylong_fromdouble(PyObject *module, PyObject *arg)
{
    double value;
    if (!PyArg_Parse(arg, "d", &value)) {
        return NULL;
    }
    return PyLong_FromDouble(value);
}

static PyObject *
pylong_fromstring(PyObject *module, PyObject *args)
{
    const char *str;
    Py_ssize_t len;
    int base;
    char *end = UNINITIALIZED_PTR;
    if (!PyArg_ParseTuple(args, "z#i", &str, &len, &base)) {
        return NULL;
    }

    PyObject *result = PyLong_FromString(str, &end, base);
    if (result == NULL) {
        // XXX 'end' is not always set.
        return NULL;
    }
    return Py_BuildValue("Nn", result, (Py_ssize_t)(end - str));
}

static PyObject *
pylong_fromvoidptr(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    return PyLong_FromVoidPtr((void *)arg);
}

/*[clinic input]
_testlimitedcapi.PyLong_AsInt
    arg: object
    /
[clinic start generated code]*/

static PyObject *
_testlimitedcapi_PyLong_AsInt(PyObject *module, PyObject *arg)
/*[clinic end generated code: output=d91db4c1287f85fa input=32c66be86f3265a1]*/
{
    NULLABLE(arg);
    assert(!PyErr_Occurred());
    int value = PyLong_AsInt(arg);
    if (value == -1 && PyErr_Occurred()) {
        return NULL;
    }
    return PyLong_FromLong(value);
}

static PyObject *
pylong_aslong(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    long value = PyLong_AsLong(arg);
    if (value == -1 && PyErr_Occurred()) {
        return NULL;
    }
    return PyLong_FromLong(value);
}

static PyObject *
pylong_aslongandoverflow(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    int overflow = UNINITIALIZED_INT;
    long value = PyLong_AsLongAndOverflow(arg, &overflow);
    if (value == -1 && PyErr_Occurred()) {
        assert(overflow == -1);
        return NULL;
    }
    return Py_BuildValue("li", value, overflow);
}

static PyObject *
pylong_asunsignedlong(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    unsigned long value = PyLong_AsUnsignedLong(arg);
    if (value == (unsigned long)-1 && PyErr_Occurred()) {
        return NULL;
    }
    return PyLong_FromUnsignedLong(value);
}

static PyObject *
pylong_asunsignedlongmask(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    unsigned long value = PyLong_AsUnsignedLongMask(arg);
    if (value == (unsigned long)-1 && PyErr_Occurred()) {
        return NULL;
    }
    return PyLong_FromUnsignedLong(value);
}

static PyObject *
pylong_aslonglong(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    long long value = PyLong_AsLongLong(arg);
    if (value == -1 && PyErr_Occurred()) {
        return NULL;
    }
    return PyLong_FromLongLong(value);
}

static PyObject *
pylong_aslonglongandoverflow(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    int overflow = UNINITIALIZED_INT;
    long long value = PyLong_AsLongLongAndOverflow(arg, &overflow);
    if (value == -1 && PyErr_Occurred()) {
        assert(overflow == -1);
        return NULL;
    }
    return Py_BuildValue("Li", value, overflow);
}

static PyObject *
pylong_asunsignedlonglong(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    unsigned long long value = PyLong_AsUnsignedLongLong(arg);
    if (value == (unsigned long long)-1 && PyErr_Occurred()) {
        return NULL;
    }
    return PyLong_FromUnsignedLongLong(value);
}

static PyObject *
pylong_asunsignedlonglongmask(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    unsigned long long value = PyLong_AsUnsignedLongLongMask(arg);
    if (value == (unsigned long long)-1 && PyErr_Occurred()) {
        return NULL;
    }
    return PyLong_FromUnsignedLongLong(value);
}

static PyObject *
pylong_as_ssize_t(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    Py_ssize_t value = PyLong_AsSsize_t(arg);
    if (value == -1 && PyErr_Occurred()) {
        return NULL;
    }
    return PyLong_FromSsize_t(value);
}

static PyObject *
pylong_as_size_t(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    size_t value = PyLong_AsSize_t(arg);
    if (value == (size_t)-1 && PyErr_Occurred()) {
        return NULL;
    }
    return PyLong_FromSize_t(value);
}

static PyObject *
pylong_asdouble(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    double value = PyLong_AsDouble(arg);
    if (value == -1.0 && PyErr_Occurred()) {
        return NULL;
    }
    return PyFloat_FromDouble(value);
}

static PyObject *
pylong_asvoidptr(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    void *value = PyLong_AsVoidPtr(arg);
    if (value == NULL) {
        if (PyErr_Occurred()) {
            return NULL;
        }
        Py_RETURN_NONE;
    }
    return Py_NewRef((PyObject *)value);
}

static PyObject *
pylong_aspid(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    pid_t value = PyLong_AsPid(arg);
    if (value == -1 && PyErr_Occurred()) {
        return NULL;
    }
    return PyLong_FromPid(value);
}


static PyObject *
pylong_asint32(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    int32_t value;
    if (PyLong_AsInt32(arg, &value) < 0) {
        return NULL;
    }
    return PyLong_FromInt32(value);
}

static PyObject *
pylong_asuint32(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    uint32_t value;
    if (PyLong_AsUInt32(arg, &value) < 0) {
        return NULL;
    }
    return PyLong_FromUInt32(value);
}


static PyObject *
pylong_asint64(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    int64_t value;
    if (PyLong_AsInt64(arg, &value) < 0) {
        return NULL;
    }
    return PyLong_FromInt64(value);
}

static PyObject *
pylong_asuint64(PyObject *module, PyObject *arg)
{
    NULLABLE(arg);
    uint64_t value;
    if (PyLong_AsUInt64(arg, &value) < 0) {
        return NULL;
    }
    return PyLong_FromUInt64(value);
}


static PyMethodDef test_methods[] = {
    _TESTLIMITEDCAPI_TEST_LONG_AND_OVERFLOW_METHODDEF
    _TESTLIMITEDCAPI_TEST_LONG_API_METHODDEF
    _TESTLIMITEDCAPI_TEST_LONG_AS_DOUBLE_METHODDEF
    _TESTLIMITEDCAPI_TEST_LONG_AS_SIZE_T_METHODDEF
    _TESTLIMITEDCAPI_TEST_LONG_AS_UNSIGNED_LONG_LONG_MASK_METHODDEF
    _TESTLIMITEDCAPI_TEST_LONG_LONG_AND_OVERFLOW_METHODDEF
    _TESTLIMITEDCAPI_TEST_LONGLONG_API_METHODDEF
    {"pylong_check",                pylong_check,               METH_O},
    {"pylong_checkexact",           pylong_checkexact,          METH_O},
    {"pylong_fromdouble",           pylong_fromdouble,          METH_O},
    {"pylong_fromstring",           pylong_fromstring,          METH_VARARGS},
    {"pylong_fromvoidptr",          pylong_fromvoidptr,         METH_O},
    _TESTLIMITEDCAPI_PYLONG_ASINT_METHODDEF
    {"pylong_aslong",               pylong_aslong,              METH_O},
    {"pylong_aslongandoverflow",    pylong_aslongandoverflow,   METH_O},
    {"pylong_asunsignedlong",       pylong_asunsignedlong,      METH_O},
    {"pylong_asunsignedlongmask",   pylong_asunsignedlongmask,  METH_O},
    {"pylong_aslonglong",           pylong_aslonglong,          METH_O},
    {"pylong_aslonglongandoverflow", pylong_aslonglongandoverflow, METH_O},
    {"pylong_asunsignedlonglong",   pylong_asunsignedlonglong,  METH_O},
    {"pylong_asunsignedlonglongmask", pylong_asunsignedlonglongmask, METH_O},
    {"pylong_as_ssize_t",           pylong_as_ssize_t,          METH_O},
    {"pylong_as_size_t",            pylong_as_size_t,           METH_O},
    {"pylong_asdouble",             pylong_asdouble,            METH_O},
    {"pylong_asvoidptr",            pylong_asvoidptr,           METH_O},
    {"pylong_aspid",                pylong_aspid,               METH_O},
    {"pylong_asint32",              pylong_asint32,             METH_O},
    {"pylong_asuint32",             pylong_asuint32,            METH_O},
    {"pylong_asint64",              pylong_asint64,             METH_O},
    {"pylong_asuint64",             pylong_asuint64,            METH_O},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_Long(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }
    return 0;
}


================================================
File: /Modules/_testlimitedcapi/object.c
================================================
// Need limited C API version 3.13 for Py_GetConstant()
#include "pyconfig.h"   // Py_GIL_DISABLED
#if !defined(Py_GIL_DISABLED) && !defined(Py_LIMITED_API)
#  define Py_LIMITED_API 0x030d0000
#endif

#include "parts.h"
#include "util.h"


/* Test Py_GetConstant() */
static PyObject *
get_constant(PyObject *Py_UNUSED(module), PyObject *args)
{
    int constant_id;
    if (!PyArg_ParseTuple(args, "i", &constant_id)) {
        return NULL;
    }

    PyObject *obj = Py_GetConstant(constant_id);
    if (obj == NULL) {
        assert(PyErr_Occurred());
        return NULL;
    }
    return obj;
}


/* Test Py_GetConstantBorrowed() */
static PyObject *
get_constant_borrowed(PyObject *Py_UNUSED(module), PyObject *args)
{
    int constant_id;
    if (!PyArg_ParseTuple(args, "i", &constant_id)) {
        return NULL;
    }

    PyObject *obj = Py_GetConstantBorrowed(constant_id);
    if (obj == NULL) {
        assert(PyErr_Occurred());
        return NULL;
    }
    return Py_NewRef(obj);
}


/* Test constants */
static PyObject *
test_constants(PyObject *Py_UNUSED(module), PyObject *Py_UNUSED(args))
{
    // Test that implementation of constants in the limited C API:
    // check that the C code compiles.
    //
    // Test also that constants and Py_GetConstant() return the same
    // objects.
    assert(Py_None == Py_GetConstant(Py_CONSTANT_NONE));
    assert(Py_False == Py_GetConstant(Py_CONSTANT_FALSE));
    assert(Py_True == Py_GetConstant(Py_CONSTANT_TRUE));
    assert(Py_Ellipsis == Py_GetConstant(Py_CONSTANT_ELLIPSIS));
    assert(Py_NotImplemented == Py_GetConstant(Py_CONSTANT_NOT_IMPLEMENTED));
    // Other constants are tested in test_capi.test_object
    Py_RETURN_NONE;
}

static PyMethodDef test_methods[] = {
    {"get_constant", get_constant, METH_VARARGS},
    {"get_constant_borrowed", get_constant_borrowed, METH_VARARGS},
    {"test_constants", test_constants, METH_NOARGS},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_Object(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/parts.h
================================================
#ifndef Py_TESTLIMITEDCAPI_PARTS_H
#define Py_TESTLIMITEDCAPI_PARTS_H

// Always enable assertions
#undef NDEBUG

#include "pyconfig.h"   // Py_GIL_DISABLED

// Use the limited C API
#if !defined(Py_GIL_DISABLED) && !defined(Py_LIMITED_API)
   // need limited C API version 3.5 for PyModule_AddFunctions()
#  define Py_LIMITED_API 0x03050000
#endif

// Make sure that the internal C API cannot be used.
#undef Py_BUILD_CORE_MODULE
#undef Py_BUILD_CORE_BUILTIN

#include "Python.h"

#ifdef Py_BUILD_CORE
#  error "Py_BUILD_CORE macro must not be defined"
#endif

int _PyTestLimitedCAPI_Init_Abstract(PyObject *module);
int _PyTestLimitedCAPI_Init_ByteArray(PyObject *module);
int _PyTestLimitedCAPI_Init_Bytes(PyObject *module);
int _PyTestLimitedCAPI_Init_Codec(PyObject *module);
int _PyTestLimitedCAPI_Init_Complex(PyObject *module);
int _PyTestLimitedCAPI_Init_Dict(PyObject *module);
int _PyTestLimitedCAPI_Init_Eval(PyObject *module);
int _PyTestLimitedCAPI_Init_Float(PyObject *module);
int _PyTestLimitedCAPI_Init_HeaptypeRelative(PyObject *module);
int _PyTestLimitedCAPI_Init_Object(PyObject *module);
int _PyTestLimitedCAPI_Init_List(PyObject *module);
int _PyTestLimitedCAPI_Init_Long(PyObject *module);
int _PyTestLimitedCAPI_Init_PyOS(PyObject *module);
int _PyTestLimitedCAPI_Init_Set(PyObject *module);
int _PyTestLimitedCAPI_Init_Sys(PyObject *module);
int _PyTestLimitedCAPI_Init_Tuple(PyObject *module);
int _PyTestLimitedCAPI_Init_Unicode(PyObject *module);
int _PyTestLimitedCAPI_Init_VectorcallLimited(PyObject *module);
int _PyTestLimitedCAPI_Init_Version(PyObject *module);

#endif // Py_TESTLIMITEDCAPI_PARTS_H


================================================
File: /Modules/_testlimitedcapi/pyos.c
================================================
#include "parts.h"


static PyObject *
test_PyOS_mystrnicmp(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    assert(PyOS_mystrnicmp("", "", 0) == 0);
    assert(PyOS_mystrnicmp("", "", 1) == 0);

    assert(PyOS_mystrnicmp("insert", "ins", 3) == 0);
    assert(PyOS_mystrnicmp("ins", "insert", 3) == 0);
    assert(PyOS_mystrnicmp("insect", "insert", 3) == 0);

    assert(PyOS_mystrnicmp("insert", "insert", 6) == 0);
    assert(PyOS_mystrnicmp("Insert", "insert", 6) == 0);
    assert(PyOS_mystrnicmp("INSERT", "insert", 6) == 0);
    assert(PyOS_mystrnicmp("insert", "insert", 10) == 0);

    assert(PyOS_mystrnicmp("invert", "insert", 6) == ('v' - 's'));
    assert(PyOS_mystrnicmp("insert", "invert", 6) == ('s' - 'v'));
    assert(PyOS_mystrnicmp("insert", "ins\0rt", 6) == 'e');

    // GH-21845
    assert(PyOS_mystrnicmp("insert\0a", "insert\0b", 8) == 0);

    Py_RETURN_NONE;
}

static PyObject *
test_PyOS_mystricmp(PyObject *self, PyObject *Py_UNUSED(ignored))
{
    assert(PyOS_mystricmp("", "") == 0);
    assert(PyOS_mystricmp("insert", "insert") == 0);
    assert(PyOS_mystricmp("Insert", "insert") == 0);
    assert(PyOS_mystricmp("INSERT", "insert") == 0);
    assert(PyOS_mystricmp("insert", "ins") == 'e');
    assert(PyOS_mystricmp("ins", "insert") == -'e');

    // GH-21845
    assert(PyOS_mystricmp("insert", "ins\0rt") == 'e');
    assert(PyOS_mystricmp("invert", "insert") == ('v' - 's'));

    Py_RETURN_NONE;
}

static PyMethodDef test_methods[] = {
    {"test_PyOS_mystrnicmp", test_PyOS_mystrnicmp, METH_NOARGS, NULL},
    {"test_PyOS_mystricmp", test_PyOS_mystricmp, METH_NOARGS, NULL},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_PyOS(PyObject *mod)
{
    if (PyModule_AddFunctions(mod, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/set.c
================================================
#include "parts.h"
#include "util.h"

static PyObject *
set_check(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_INT(PySet_Check(obj));
}

static PyObject *
set_checkexact(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_INT(PySet_CheckExact(obj));
}

static PyObject *
frozenset_check(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_INT(PyFrozenSet_Check(obj));
}

static PyObject *
frozenset_checkexact(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_INT(PyFrozenSet_CheckExact(obj));
}

static PyObject *
anyset_check(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_INT(PyAnySet_Check(obj));
}

static PyObject *
anyset_checkexact(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_INT(PyAnySet_CheckExact(obj));
}

static PyObject *
set_new(PyObject *self, PyObject *args)
{
    PyObject *iterable = NULL;
    if (!PyArg_ParseTuple(args, "|O", &iterable)) {
        return NULL;
    }
    return PySet_New(iterable);
}

static PyObject *
frozenset_new(PyObject *self, PyObject *args)
{
    PyObject *iterable = NULL;
    if (!PyArg_ParseTuple(args, "|O", &iterable)) {
        return NULL;
    }
    return PyFrozenSet_New(iterable);
}

static PyObject *
set_size(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_SIZE(PySet_Size(obj));
}

static PyObject *
set_contains(PyObject *self, PyObject *args)
{
    PyObject *obj, *item;
    if (!PyArg_ParseTuple(args, "OO", &obj, &item)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(item);
    RETURN_INT(PySet_Contains(obj, item));
}

static PyObject *
set_add(PyObject *self, PyObject *args)
{
    PyObject *obj, *item;
    if (!PyArg_ParseTuple(args, "OO", &obj, &item)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(item);
    RETURN_INT(PySet_Add(obj, item));
}

static PyObject *
set_discard(PyObject *self, PyObject *args)
{
    PyObject *obj, *item;
    if (!PyArg_ParseTuple(args, "OO", &obj, &item)) {
        return NULL;
    }
    NULLABLE(obj);
    NULLABLE(item);
    RETURN_INT(PySet_Discard(obj, item));
}

static PyObject *
set_pop(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    return PySet_Pop(obj);
}

static PyObject *
set_clear(PyObject *self, PyObject *obj)
{
    NULLABLE(obj);
    RETURN_INT(PySet_Clear(obj));
}

static PyObject *
test_frozenset_add_in_capi(PyObject *self, PyObject *Py_UNUSED(obj))
{
    // Test that `frozenset` can be used with `PySet_Add`,
    // when frozenset is just created in CAPI.
    PyObject *fs = PyFrozenSet_New(NULL);
    if (fs == NULL) {
        return NULL;
    }
    PyObject *num = PyLong_FromLong(1);
    if (num == NULL) {
        goto error;
    }
    if (PySet_Add(fs, num) < 0) {
        goto error;
    }
    int contains = PySet_Contains(fs, num);
    if (contains < 0) {
        goto error;
    }
    else if (contains == 0) {
        goto unexpected;
    }
    Py_DECREF(fs);
    Py_DECREF(num);
    Py_RETURN_NONE;

unexpected:
    PyErr_SetString(PyExc_ValueError, "set does not contain expected value");
error:
    Py_DECREF(fs);
    Py_XDECREF(num);
    return NULL;
}

static PyMethodDef test_methods[] = {
    {"set_check", set_check, METH_O},
    {"set_checkexact", set_checkexact, METH_O},
    {"frozenset_check", frozenset_check, METH_O},
    {"frozenset_checkexact", frozenset_checkexact, METH_O},
    {"anyset_check", anyset_check, METH_O},
    {"anyset_checkexact", anyset_checkexact, METH_O},

    {"set_new", set_new, METH_VARARGS},
    {"frozenset_new", frozenset_new, METH_VARARGS},

    {"set_size", set_size, METH_O},
    {"set_contains", set_contains, METH_VARARGS},
    {"set_add", set_add, METH_VARARGS},
    {"set_discard", set_discard, METH_VARARGS},
    {"set_pop", set_pop, METH_O},
    {"set_clear", set_clear, METH_O},

    {"test_frozenset_add_in_capi", test_frozenset_add_in_capi, METH_NOARGS},

    {NULL},
};

int
_PyTestLimitedCAPI_Init_Set(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/sys.c
================================================
#include "parts.h"
#include "util.h"


static PyObject *
sys_getobject(PyObject *Py_UNUSED(module), PyObject *arg)
{
    const char *name;
    Py_ssize_t size;
    if (!PyArg_Parse(arg, "z#", &name, &size)) {
        return NULL;
    }
    PyObject *result = PySys_GetObject(name);
    if (result == NULL) {
        result = PyExc_AttributeError;
    }
    return Py_NewRef(result);
}

static PyObject *
sys_setobject(PyObject *Py_UNUSED(module), PyObject *args)
{
    const char *name;
    Py_ssize_t size;
    PyObject *value;
    if (!PyArg_ParseTuple(args, "z#O", &name, &size, &value)) {
        return NULL;
    }
    NULLABLE(value);
    RETURN_INT(PySys_SetObject(name, value));
}

static PyObject *
sys_getxoptions(PyObject *Py_UNUSED(module), PyObject *Py_UNUSED(ignored))
{
    PyObject *result = PySys_GetXOptions();
    return Py_XNewRef(result);
}


static PyMethodDef test_methods[] = {
    {"sys_getobject", sys_getobject, METH_O},
    {"sys_setobject", sys_setobject, METH_VARARGS},
    {"sys_getxoptions", sys_getxoptions, METH_NOARGS},
    {NULL},
};

int
_PyTestLimitedCAPI_Init_Sys(PyObject *m)
{
    if (PyModule_AddFunctions(m, test_methods) < 0) {
        return -1;
    }

    return 0;
}


================================================
File: /Modules/_testlimitedcapi/testcapi_long.h
================================================
/* Poor-man's template.  Macros used:
   TESTNAME     name of the test (like test_long_api_inner)
   TYPENAME     the signed type (like long)
   F_S_TO_PY    convert signed to pylong; TYPENAME -> PyObject*
   F_PY_TO_S    convert pylong to signed; PyObject* -> TYPENAME
   F_U_TO_PY    convert unsigned to pylong; unsigned TYPENAME -> PyObject*
   F_PY_TO_U    convert pylong to unsigned; PyObject* -> unsigned TYPENAME
*/

static PyObject *
TESTNAME(PyObject *error(const char*))
{
    const int NBITS = sizeof(TYPENAME) * 8;
    unsigned TYPENAME base;
    PyObject *pyresult;
    int i;

    /* Note:  This test lets PyObjects leak if an error is raised.  Since
       an error should never be raised, leaks are impossible <wink>. */

    /* Test native -> PyLong -> native roundtrip identity.
     * Generate all powers of 2, and test them and their negations,
     * plus the numbers +-1 off from them.
     */
    base = 1;
    for (i = 0;
         i < NBITS + 1;  /* on last, base overflows to 0 */
         ++i, base <<= 1)
    {
        int j;
        for (j = 0; j < 6; ++j) {
            TYPENAME in, out;
            unsigned TYPENAME uin, uout;

            /* For 0, 1, 2 use base; for 3, 4, 5 use -base */
            uin = j < 3 ? base : 0U - base;

            /* For 0 & 3, subtract 1.
             * For 1 & 4, leave alone.
             * For 2 & 5, add 1.
             */
            uin += (unsigned TYPENAME)(TYPENAME)(j % 3 - 1);

            pyresult = F_U_TO_PY(uin);
            if (pyresult == NULL)
                return error(
