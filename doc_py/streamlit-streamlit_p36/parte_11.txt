} from "./StreamlitSyntaxHighlighter"

const getStreamlitSyntaxHighlighterProps = (
  props: Partial<StreamlitSyntaxHighlighterProps> = {}
): StreamlitSyntaxHighlighterProps => ({
  children: [
    `import streamlit as st

st.write("Hello")
`,
  ],
  ...props,
})

describe("CustomCodeTag Element", () => {
  it("should render without crashing", () => {
    const props = getStreamlitSyntaxHighlighterProps()
    const { baseElement } = render(<StreamlitSyntaxHighlighter {...props} />)

    expect(baseElement.querySelectorAll("pre code")).toHaveLength(1)
  })

  it("should render as plaintext", () => {
    const props = getStreamlitSyntaxHighlighterProps({ language: "plaintext" })
    const { baseElement } = render(<StreamlitSyntaxHighlighter {...props} />)

    expect(baseElement.querySelector("pre code")?.outerHTML).toBe(
      '<code class="language-plaintext" style="white-space: pre;"><span>import streamlit as st\n' +
        "</span>\n" +
        'st.write("Hello")\n' +
        "</code>"
    )
  })

  it("should render as plaintext if no language specified", () => {
    const props = getStreamlitSyntaxHighlighterProps({ language: "plaintext" })
    const { baseElement } = render(<StreamlitSyntaxHighlighter {...props} />)

    expect(baseElement.querySelector("pre code")?.outerHTML).toBe(
      '<code class="language-plaintext" style="white-space: pre;"><span>import streamlit as st\n' +
        "</span>\n" +
        'st.write("Hello")\n' +
        "</code>"
    )
  })

  it("should render as python", () => {
    const props = getStreamlitSyntaxHighlighterProps({ language: "python" })
    const { baseElement } = render(<StreamlitSyntaxHighlighter {...props} />)
    expect(
      baseElement.querySelector("pre code .token.string")?.innerHTML
    ).toBe('"Hello"')
  })

  it("applies height style when height prop is provided", () => {
    const props = getStreamlitSyntaxHighlighterProps({ height: 200 })
    const { baseElement } = render(<StreamlitSyntaxHighlighter {...props} />)

    expect(baseElement.querySelector("pre")).toHaveStyle({ height: "200px" })
  })
})


================================================
File: /frontend/lib/src/components/elements/CodeBlock/StreamlitSyntaxHighlighter.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, useCallback } from "react"

import {
  createElement,
  Prism as SyntaxHighlighter,
} from "react-syntax-highlighter"

import CopyButton from "./CopyButton"
import {
  StyledCodeBlock,
  StyledCopyButtonContainer,
  StyledPre,
} from "./styled-components"

export interface StreamlitSyntaxHighlighterProps {
  children: string | string[]
  language?: string
  showLineNumbers?: boolean
  wrapLines?: boolean
  height?: number
}

export default function StreamlitSyntaxHighlighter({
  language,
  showLineNumbers,
  wrapLines,
  height,
  children,
}: Readonly<StreamlitSyntaxHighlighterProps>): ReactElement {
  const renderer = useCallback(
    ({ rows, stylesheet, useInlineStyles }: any): any =>
      rows.map((row: any, index: any): any => {
        const children = row.children

        if (children) {
          const lineNumberElement = children.shift()

          if (lineNumberElement) {
            row.children = [
              lineNumberElement,
              {
                children,
                properties: { className: [] },
                tagName: "span",
                type: "element",
              },
            ]
          }
        }

        return createElement({
          node: row,
          stylesheet,
          useInlineStyles,
          key: index,
        })
      }),
    []
  )

  return (
    <StyledCodeBlock className="stCode" data-testid="stCode">
      <StyledPre height={height}>
        <SyntaxHighlighter
          language={language}
          PreTag="div"
          customStyle={{ backgroundColor: "transparent" }}
          // We set an empty style object here because we have our own CSS styling that
          // reacts on our theme.
          style={{}}
          lineNumberStyle={{}}
          showLineNumbers={showLineNumbers}
          wrapLongLines={wrapLines}
          // Fix bug with wrapLongLines+showLineNumbers (see link below) by
          // using a renderer that wraps individual lines of code in their
          // own spans.
          // https://github.com/react-syntax-highlighter/react-syntax-highlighter/issues/376
          renderer={showLineNumbers && wrapLines ? renderer : undefined}
        >
          {children}
        </SyntaxHighlighter>
      </StyledPre>
      {typeof children === "string" && children.trim() !== "" && (
        <StyledCopyButtonContainer>
          <CopyButton text={children} />
        </StyledCopyButtonContainer>
      )}
    </StyledCodeBlock>
  )
}


================================================
File: /frontend/lib/src/components/elements/CodeBlock/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { CSSObject, Theme } from "@emotion/react"
import styled from "@emotion/styled"

const codeLink: CSSObject = {
  // Streamline the style when inside anchors to avoid broken underline and more
  "a > &": {
    color: "inherit",
  },
}

export const StyledInlineCode = styled.code(({ theme }) => ({
  padding: "0.2em 0.4em",
  wordWrap: "break-word",
  margin: 0,
  borderRadius: theme.radii.md,
  background: theme.colors.codeHighlightColor,
  color: theme.colors.codeTextColor,
  fontFamily: theme.genericFonts.codeFont,
  // Use em here so that it works correctly within captions
  fontSize: "0.75em",

  ...codeLink,
}))

const codeBlockStyle = (theme: Theme): CSSObject => ({
  background: "transparent",
  border: 0,
  color: "inherit",
  display: "inline",
  fontFamily: theme.genericFonts.codeFont,
  fontSize: theme.fontSizes.sm,
  lineHeight: "inherit",
  margin: 0,
  overflowX: "auto",
  padding: 0,
  whiteSpace: "pre",
  wordBreak: "normal",
  wordWrap: "normal",
  ...codeLink,
})

export const StyledCode = styled.code(({ theme }) => ({
  ...codeBlockStyle(theme),
}))

interface StyledPreProps {
  height?: number
}

/*
  This is the default prism.js theme for JavaScript, CSS and HTML, but
  stripped of everything except for token styling.

  See https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript
*/
export const StyledPre = styled.pre<StyledPreProps>(({ theme, height }) => ({
  height: height ? `${height}px` : undefined,
  background: theme.colors.codeHighlightColor,
  borderRadius: theme.radii.default,
  color: theme.colors.bodyText,
  fontSize: theme.fontSizes.twoSm,
  fontFamily: theme.genericFonts.codeFont,
  display: "block",
  // Remove browser default top margin
  margin: 0,
  // Disable auto-hiding scrollbar in legacy Edge to avoid overlap,
  // making it impossible to interact with the content
  msOverflowStyle: "scrollbar",

  // Don't allow content to break outside
  overflow: "auto",

  // Add padding around the code
  padding: theme.spacing.lg,
  // Add padding to the right to account for the copy button
  paddingRight: theme.iconSizes.threeXL,

  code: { ...codeBlockStyle(theme) },

  // The token can consist of many lines, e.g. a triple-quote string, so
  // we need to make sure that the color is not overwritten.
  ".comment.linenumber": {
    color: theme.colors.fadedText40,
    fontSize: theme.fontSizes.twoSm,

    // Center-align number vertically, or they'll be positioned differently when
    // wrapLinst=true. Even with this change, though, the position is still ~2px
    // off.
    // NOTE: The alignSelf below only apply applies when wrapLines=true, because
    // that option wraps this element in a flex container.
    alignSelf: "center",

    // Override the default token's min-width, to ensure it fits 3-digit lines
    minWidth: `${theme.spacing.threeXL} !important`,
  },

  ".token.comment, .token.prolog, .token.doctype, .token.cdata": {
    color: theme.colors.gray70,
  },

  ".token.punctuation": {
    color: theme.colors.gray70,
  },

  ".namespace": {
    opacity: 0.7,
  },

  ".token.attr-name, .token.property, .token.variable": {
    color: theme.colors.lightBlue80,
  },

  ".token.boolean, .token.constant, .token.symbol": {
    color: theme.colors.green70,
  },

  ".token.number, .token.regex": {
    color: theme.colors.blueGreen80,
  },

  ".token.string, .token.char, .token.attr-value": {
    color: theme.colors.green80,
  },

  ".token.operator, .token.entity": {
    color: theme.colors.orange90,
  },

  ".token.url": {
    color: theme.colors.purple80,
  },

  ".token.decorator, .token.atrule": {
    color: theme.colors.orange90,
  },

  ".token.keyword, .token.tag": {
    color: theme.colors.blue70,
  },

  ".token.function, .token.class-name, .token.selector": {
    color: theme.colors.blue70,
    fontWeight: theme.fontWeights.extrabold,
  },

  ".token.important": {
    color: theme.colors.red70,
    fontWeight: theme.fontWeights.extrabold,
  },

  ".token.comment": {
    color: theme.colors.gray70,
    fontStyle: "italic",
  },

  ".token.italic": {
    fontStyle: "italic",
  },

  ".token.entity": {
    cursor: "help",
  },

  /**
   * Diff syntax highlighting
   */
  ".token.deleted.line, .token.deleted.prefix": {
    color: theme.colors.red70,
  },
  ".token.inserted.line, .token.inserted.prefix": {
    color: theme.colors.green70,
  },
  ".token.unchanged.line": {
    color: theme.colors.gray70,
  },
}))

export const StyledCopyButtonContainer = styled.div(({ theme }) => ({
  opacity: 0,
  padding: `${theme.spacing.sm} ${theme.spacing.sm} 0 0`,
  top: 0,
  right: 0,
  position: "absolute",
  width: "100%",
  height: "100%",
  backgroundColor: theme.colors.transparent,
  zIndex: theme.zIndices.sidebar + 1,
  display: "flex",
  justifyContent: "flex-end",
  alignItems: "flex-start",
  transition: "opacity 300ms 150ms",
  pointerEvents: "none",
}))

export const StyledCodeBlock = styled.div(({ theme }) => ({
  position: "relative",
  marginLeft: theme.spacing.none,
  marginRight: theme.spacing.none,
  marginTop: theme.spacing.none,
  marginBottom: undefined,

  "&:hover": {
    [`${StyledCopyButtonContainer}`]: {
      opacity: 1,
    },
  },
}))

export const StyledCopyButton = styled.button(({ theme }) => ({
  pointerEvents: "auto",
  height: theme.iconSizes.threeXL,
  width: theme.iconSizes.threeXL,
  padding: theme.spacing.none,
  border: "none",
  backgroundColor: theme.colors.transparent,
  color: theme.colors.fadedText60,
  transform: "scale(0)",

  [`${StyledCodeBlock}:hover &, &:active, &:focus, &:hover`]: {
    opacity: 1,
    transform: "scale(1)",
    outline: "none",
    transition: "none",
    color: theme.colors.bodyText,
  },
}))


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/DeckGlJsonChart.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC } from "react"

import JSON5 from "json5"
import { act, screen } from "@testing-library/react"
import { PickingInfo } from "@deck.gl/core"
import { userEvent } from "@testing-library/user-event"

import {
  render,
  renderHook,
} from "@streamlit/lib/src/components/shared/ElementFullscreen/testUtils"
import { DeckGlJsonChart as DeckGlJsonChartProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import { mockTheme } from "@streamlit/lib/src/mocks/mockTheme"
import { ElementFullscreenContext } from "@streamlit/lib/src/components/shared/ElementFullscreen/ElementFullscreenContext"
import { useRequiredContext } from "@streamlit/lib/src/hooks/useRequiredContext"

import type { DeckGLProps } from "./types"
import { useDeckGl, UseDeckGlProps } from "./useDeckGl"

const mockInitialViewState = {
  bearing: -27.36,
  latitude: 52.2323,
  longitude: -1.415,
  maxZoom: 15,
  minZoom: 5,
  pitch: 40.5,
  height: 500,
  zoom: 6,
}

vi.mock("@streamlit/lib/src/theme", async () => ({
  ...(await vi.importActual("@streamlit/lib/src/theme")),
  hasLightBackgroundColor: vi.fn(() => false),
}))

const getProps = (
  elementProps: Partial<DeckGlJsonChartProto> = {},
  initialViewStateProps: Record<string, unknown> = {}
): DeckGLProps => {
  const json = {
    initialViewState: mockInitialViewState,
    layers: [
      {
        "@@type": "HexagonLayer",
        autoHighlight: true,
        coverage: 1,
        data: "https://raw.githubusercontent.com/uber-common/deck.gl-data/master/examples/3d-heatmap/heatmap-data.csv",
        elevationRange: [0, 3000],
        elevationScale: 50,
        extruded: true,
        getPosition: "@@=[lng, lat]",
        id: "0533490f-fcf9-4dc0-8c94-ae4fbd42eb6f",
        pickable: true,
      },
    ],
    mapStyle: "mapbox://styles/mapbox/light-v9",
    views: [{ "@@type": "MapView", controller: true }],
  }

  json.initialViewState = {
    ...json.initialViewState,
    ...initialViewStateProps,
  }

  return {
    element: DeckGlJsonChartProto.create({
      json: JSON.stringify(json),
      ...elementProps,
    }),
    mapboxToken: "mapboxToken",
    widgetMgr: new WidgetStateManager({
      sendRerunBackMsg: vi.fn(),
      formsDataChanged: vi.fn(),
    }),
    fragmentId: "myFragmentId",
  }
}

const getUseDeckGlProps = (
  elementProps: Partial<DeckGlJsonChartProto> = {},
  initialViewStateProps: Record<string, unknown> = {}
): UseDeckGlProps => {
  return {
    ...getProps(elementProps, initialViewStateProps),
    isLightTheme: false,
    theme: mockTheme.emotion,
  }
}

describe("#useDeckGl", () => {
  it("should merge client and server changes in viewState", () => {
    const initialProps = getUseDeckGlProps()

    const {
      result: { current },
      rerender,
    } = renderHook(props => useDeckGl(props), {
      initialProps,
    })

    expect(current.viewState).toEqual(mockInitialViewState)

    rerender({
      ...initialProps,
      element: getUseDeckGlProps({}, { zoom: 8 }).element,
    })

    // should match original mockInitialViewState
    expect(current.viewState).toEqual({ ...mockInitialViewState, zoom: 6 })
  })

  describe("createTooltip", () => {
    it("should return null if info is null", () => {
      const {
        result: { current },
      } = renderHook(props => useDeckGl(props), {
        initialProps: getUseDeckGlProps(),
      })

      expect(current.createTooltip(null)).toBe(null)
    })

    it("should return null if info.object is undefined", () => {
      const {
        result: { current },
      } = renderHook(props => useDeckGl(props), {
        initialProps: getUseDeckGlProps(),
      })

      expect(current.createTooltip({} as PickingInfo)).toBe(null)
    })

    it("should return null if element.tooltip is undefined", () => {
      const {
        result: { current },
      } = renderHook(props => useDeckGl(props), {
        initialProps: getUseDeckGlProps({ tooltip: undefined }),
      })

      expect(current.createTooltip({ object: {} } as PickingInfo)).toBe(null)
    })

    it("should interpolate the html with the correct object", () => {
      const {
        result: { current },
      } = renderHook(props => useDeckGl(props), {
        initialProps: getUseDeckGlProps({
          tooltip: JSON.stringify({
            html: "<b>Elevation Value:</b> {elevationValue}",
          }),
        }),
      })

      const result = current.createTooltip({
        object: { elevationValue: 10 },
      } as PickingInfo)

      if (result === null || typeof result !== "object") {
        throw new Error("Expected result to be an object")
      }

      expect(result.html).toBe("<b>Elevation Value:</b> 10")
    })

    it("should interpolate the html from object with a properties field", () => {
      const {
        result: { current },
      } = renderHook(props => useDeckGl(props), {
        initialProps: getUseDeckGlProps({
          tooltip: JSON.stringify({
            html: "<b>Elevation Value:</b> {elevationValue}",
          }),
        }),
      })

      const result = current.createTooltip({
        object: { properties: { elevationValue: 10 } },
      } as PickingInfo)

      if (result === null || typeof result !== "object") {
        throw new Error("Expected result to be an object")
      }

      expect(result.html).toBe("<b>Elevation Value:</b> 10")
    })

    it("should return the tooltip unchanged when object does have an expected schema", () => {
      const {
        result: { current },
      } = renderHook(props => useDeckGl(props), {
        initialProps: getUseDeckGlProps({
          tooltip: JSON.stringify({
            html: "<b>Elevation Value:</b> {elevationValue}",
          }),
        }),
      })

      const result = current.createTooltip({
        object: { unexpectedSchema: { elevationValue: 10 } },
      } as PickingInfo)

      if (result === null || typeof result !== "object") {
        throw new Error("Expected result to be an object")
      }

      expect(result.html).toBe("<b>Elevation Value:</b> {elevationValue}")
    })

    it("should interpolate the html with the an empty string", () => {
      const {
        result: { current },
      } = renderHook(props => useDeckGl(props), {
        initialProps: getUseDeckGlProps({ tooltip: "" }),
      })

      const result = current.createTooltip({
        object: { elevationValue: 10 },
      } as PickingInfo)

      expect(result).toBe(null)
    })
  })

  describe("deck", () => {
    const newJson = {
      initialViewState: mockInitialViewState,
      mapStyle: "mapbox://styles/mapbox/light-v9",
    }

    const mockJsonParse = vi.fn().mockReturnValue(newJson)

    beforeEach(() => {
      JSON5.parse = mockJsonParse
    })

    afterEach(() => {
      mockJsonParse.mockClear()
    })

    const testCases: {
      description: string
      newProps: Partial<UseDeckGlProps>
    }[] = [
      {
        description: "should call JSON5.parse when the json is different",
        newProps: getUseDeckGlProps(undefined, { zoom: 19 }),
      },
      {
        description: "should call JSON5.parse when theme state changes",
        newProps: { isLightTheme: true },
      },
    ]

    it.each(testCases)("$description", ({ newProps }) => {
      const initialProps = getUseDeckGlProps()
      const { rerender } = renderHook(props => useDeckGl(props), {
        initialProps,
      })

      expect(JSON5.parse).toHaveBeenCalledTimes(1)

      rerender({ ...initialProps, ...newProps })

      expect(JSON5.parse).toHaveBeenCalledTimes(2)
    })

    it("should call JSON5.parse when isFullScreen changes", async () => {
      const user = userEvent.setup()
      const MyComponent: FC<UseDeckGlProps> = props => {
        useDeckGl(props)
        const { expand } = useRequiredContext(ElementFullscreenContext)

        return <button onClick={expand}>Expand</button>
      }

      render(<MyComponent {...getUseDeckGlProps()} />)

      expect(JSON5.parse).toHaveBeenCalledTimes(1)

      await user.click(screen.getByText("Expand"))

      expect(JSON5.parse).toHaveBeenCalledTimes(2)
    })
  })

  describe("selectionMode", () => {
    it("should be undefined when allSelectionModes is empty", () => {
      const initialProps = getUseDeckGlProps({ selectionMode: [] })
      const { result } = renderHook(props => useDeckGl(props), {
        initialProps,
      })
      expect(result.current.selectionMode).toBeUndefined()
    })

    it("should be defined when allSelectionModes has single object select", () => {
      const initialProps = getUseDeckGlProps({
        selectionMode: [DeckGlJsonChartProto.SelectionMode.SINGLE_OBJECT],
      })
      const { result } = renderHook(props => useDeckGl(props), {
        initialProps,
      })
      expect(result.current.selectionMode).toBe(
        DeckGlJsonChartProto.SelectionMode.SINGLE_OBJECT
      )
    })

    it("should be defined when allSelectionModes has multi object select", () => {
      const initialProps = getUseDeckGlProps({
        selectionMode: [DeckGlJsonChartProto.SelectionMode.MULTI_OBJECT],
      })
      const { result } = renderHook(props => useDeckGl(props), {
        initialProps,
      })
      expect(result.current.selectionMode).toBe(
        DeckGlJsonChartProto.SelectionMode.MULTI_OBJECT
      )
    })

    it("should return the first selection mode given, if multiple are given", () => {
      const initialProps = getUseDeckGlProps({
        selectionMode: [
          DeckGlJsonChartProto.SelectionMode.MULTI_OBJECT,
          DeckGlJsonChartProto.SelectionMode.SINGLE_OBJECT,
        ],
      })
      const { result } = renderHook(props => useDeckGl(props), {
        initialProps,
      })
      expect(result.current.selectionMode).toBe(
        DeckGlJsonChartProto.SelectionMode.MULTI_OBJECT
      )
    })
  })

  describe("isSelectionModeActivated", () => {
    it("should activate selection mode when selectionMode is defined", () => {
      const initialProps = getUseDeckGlProps({
        selectionMode: [DeckGlJsonChartProto.SelectionMode.SINGLE_OBJECT],
      })
      const { result } = renderHook(props => useDeckGl(props), {
        initialProps,
      })
      expect(result.current.isSelectionModeActivated).toBe(true)
    })

    it("should not activate selection mode when selectionMode is undefined", () => {
      const initialProps = getUseDeckGlProps({ selectionMode: [] })
      const { result } = renderHook(props => useDeckGl(props), {
        initialProps,
      })
      expect(result.current.isSelectionModeActivated).toBe(false)
    })
  })

  describe("hasActiveSelection", () => {
    it("should be false when selection is empty", () => {
      const initialProps = getUseDeckGlProps({
        selectionMode: [DeckGlJsonChartProto.SelectionMode.SINGLE_OBJECT],
      })
      const { result } = renderHook(props => useDeckGl(props), {
        initialProps,
      })
      expect(result.current.hasActiveSelection).toBe(false)
    })

    it("should be true when selection is not empty", () => {
      const initialProps = getUseDeckGlProps({
        selectionMode: [DeckGlJsonChartProto.SelectionMode.SINGLE_OBJECT],
      })
      const { result, rerender } = renderHook(props => useDeckGl(props), {
        initialProps,
      })

      act(() => {
        result.current.setSelection({
          fromUi: true,
          value: {
            selection: {
              indices: { "0533490f-fcf9-4dc0-8c94-ae4fbd42eb6f": [0] },
              objects: { "0533490f-fcf9-4dc0-8c94-ae4fbd42eb6f": [{}] },
            },
          },
        })
      })

      rerender()

      expect(result.current.hasActiveSelection).toBe(true)
    })
  })
})


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/DeckGlJsonChart.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, useCallback, useEffect, useState } from "react"

import { DeckGL } from "@deck.gl/react"
import { MapContext, NavigationControl, StaticMap } from "react-map-gl"
import { CSVLoader } from "@loaders.gl/csv"
import { GLTFLoader } from "@loaders.gl/gltf"
import { registerLoaders } from "@loaders.gl/core"
import { LayersList, PickingInfo } from "@deck.gl/core"
import { useTheme } from "@emotion/react"
import { Close } from "@emotion-icons/material-outlined"

import {
  EmotionTheme,
  hasLightBackgroundColor,
} from "@streamlit/lib/src/theme"
import { DeckGlJsonChart as DeckGlJsonChartProto } from "@streamlit/lib/src/proto"
import { assertNever } from "@streamlit/lib/src/util/assertNever"
import Toolbar, {
  ToolbarAction,
} from "@streamlit/lib/src/components/shared/Toolbar"
import { useRequiredContext } from "@streamlit/lib/src/hooks/useRequiredContext"
import { ElementFullscreenContext } from "@streamlit/lib/src/components/shared/ElementFullscreen/ElementFullscreenContext"
import { withFullScreenWrapper } from "@streamlit/lib/src/components/shared/FullScreenWrapper"

import withMapboxToken from "./withMapboxToken"
import {
  StyledDeckGlChart,
  StyledNavigationControlContainer,
} from "./styled-components"
import type { DeckGlElementState, DeckGLProps } from "./types"
import { EMPTY_STATE, useDeckGl } from "./useDeckGl"

import "mapbox-gl/dist/mapbox-gl.css"

registerLoaders([CSVLoader, GLTFLoader])

const EMPTY_SELECTION = EMPTY_STATE.selection

const EMPTY_LAYERS: LayersList = []

export const DeckGlJsonChart: FC<DeckGLProps> = props => {
  const {
    disabled,
    disableFullscreenMode,
    element,
    fragmentId,
    mapboxToken: propsMapboxToken,
    widgetMgr,
  } = props
  const { mapboxToken: elementMapboxToken } = element
  const theme: EmotionTheme = useTheme()
  const {
    expanded: isFullScreen,
    expand,
    collapse,
  } = useRequiredContext(ElementFullscreenContext)

  const {
    createTooltip,
    data: selection,
    deck,
    hasActiveSelection,
    height,
    isSelectionModeActivated,
    onViewStateChange,
    selectionMode,
    setSelection,
    viewState,
    width,
  } = useDeckGl({
    element,
    fragmentId,
    isLightTheme: hasLightBackgroundColor(theme),
    theme,
    widgetMgr,
  })

  const [isInitialized, setIsInitialized] = useState(false)

  useEffect(() => {
    // HACK: Load layers a little after loading the map, to hack around a bug
    // where HexagonLayers were not drawing on first load but did load when the
    // script got re-executed.
    setIsInitialized(true)
  }, [])

  const handleClick = useCallback(
    (info: PickingInfo) => {
      if (selectionMode === undefined) {
        // Safety check
        return
      }

      const { index, object } = info

      const layerId = `${info.layer?.id || null}`
      const currState = selection
      /** true if a user clicked outside of any layer */
      const isResetClick = index === -1

      const getSelection = (): DeckGlElementState["selection"] => {
        if (isResetClick) {
          return EMPTY_SELECTION
        }

        switch (selectionMode) {
          case DeckGlJsonChartProto.SelectionMode.SINGLE_OBJECT: {
            if (currState.selection.indices[layerId]?.[0] === index) {
              // Unselect the index
              return EMPTY_SELECTION
            }

            return {
              indices: { [`${layerId}`]: [index] },
              objects: { [`${layerId}`]: [object] },
            }
          }
          case DeckGlJsonChartProto.SelectionMode.MULTI_OBJECT: {
            const selectionMap: Map<number, unknown> = new Map(
              ((): [number, unknown][] => {
                const indices = currState?.selection?.indices?.[layerId] || []

                return indices.map((index, i) => [
                  index,
                  currState.selection?.objects?.[layerId]?.[i],
                ])
              })()
            )

            if (selectionMap.has(index)) {
              // Unselect an existing index
              selectionMap.delete(index)
            } else {
              // Add the newly selected index
              selectionMap.set(index, object)
            }

            if (selectionMap.size === 0) {
              // If the layer has nothing selected, remove the layer from the returned value
              // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-unused-vars
              const { [layerId]: _, ...restIndices } =
                currState.selection.indices
              // eslint-disable-next-line @typescript-eslint/naming-convention, @typescript-eslint/no-unused-vars
              const { [layerId]: __, ...restObjects } =
                currState.selection.objects

              return {
                indices: restIndices,
                objects: restObjects,
              }
            }

            return {
              indices: {
                ...currState.selection.indices,
                [`${layerId}`]: Array.from(selectionMap.keys()),
              },
              objects: {
                ...currState.selection.objects,
                [`${layerId}`]: Array.from(selectionMap.values()),
              },
            }
          }
          default:
            assertNever(selectionMode)
            throw new Error("Invalid selection mode")
        }
      }

      const newSelection = getSelection()

      if (
        JSON.stringify(newSelection) === JSON.stringify(currState.selection)
      ) {
        // If the new selection is the same as the current selection, do
        // nothing, and do not trigger a re-run
        return
      }

      setSelection({
        fromUi: true,
        value: { selection: newSelection },
      })
    },
    [selectionMode, selection, setSelection]
  )

  const handleClearSelectionClick = useCallback(() => {
    setSelection({
      value: { selection: EMPTY_SELECTION },
      fromUi: true,
    })
  }, [setSelection])

  return (
    <StyledDeckGlChart
      className="stDeckGlJsonChart"
      data-testid="stDeckGlJsonChart"
      width={width}
      height={height}
    >
      <Toolbar
        isFullScreen={isFullScreen}
        disableFullscreenMode={disableFullscreenMode}
        onExpand={expand}
        onCollapse={collapse}
        target={StyledDeckGlChart}
        locked={hasActiveSelection && !disabled ? true : undefined}
      >
        {hasActiveSelection && !disabled && (
          <ToolbarAction
            label="Clear selection"
            onClick={handleClearSelectionClick}
            icon={Close}
          />
        )}
      </Toolbar>
      <DeckGL
        viewState={viewState}
        onViewStateChange={onViewStateChange}
        height={height}
        width={width}
        layers={isInitialized ? deck.layers : EMPTY_LAYERS}
        getTooltip={createTooltip}
        // @ts-expect-error There is a type mismatch due to our versions of the libraries
        ContextProvider={MapContext.Provider}
        controller
        onClick={
          isSelectionModeActivated && !disabled ? handleClick : undefined
        }
      >
        <StaticMap
          height={height}
          width={width}
          mapStyle={
            deck.mapStyle &&
            (typeof deck.mapStyle === "string"
              ? deck.mapStyle
              : deck.mapStyle[0])
          }
          mapboxApiAccessToken={elementMapboxToken || propsMapboxToken}
        />
        <StyledNavigationControlContainer>
          <NavigationControl
            data-testid="stDeckGlJsonChartZoomButton"
            showCompass={false}
          />
        </StyledNavigationControlContainer>
      </DeckGL>
    </StyledDeckGlChart>
  )
}

export default withFullScreenWrapper(
  withMapboxToken("st.pydeck_chart")(DeckGlJsonChart)
)


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./DeckGlJsonChart"


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

import { hasLightBackgroundColor } from "@streamlit/lib/src/theme"

export interface StyledDeckGlChartProps {
  width: number | string
  height: number | string
}

export const StyledDeckGlChart = styled.div<StyledDeckGlChartProps>(
  ({ width, height }) => ({
    position: "relative",
    height,
    width,
  })
)

export const StyledNavigationControlContainer = styled.div(({ theme }) => ({
  position: "absolute",
  right: "2.625rem",
  top: theme.spacing.md,
  zIndex: theme.zIndices.priority,

  ".mapboxgl-ctrl.mapboxgl-ctrl-group": {
    // Ensures that the border-radius of the zoom buttons is visible
    overflow: "hidden",
    background: theme.colors.bgColor,
  },

  // Update zoom buttons based on the active theme
  "button:not(:disabled)": {
    background: theme.colors.bgColor,
    width: theme.iconSizes.twoXL,
    height: theme.iconSizes.twoXL,

    // Add a separator between buttons
    "& + button": {
      borderTopColor: theme.colors.borderColor,
    },

    ".mapboxgl-ctrl-icon": {
      backgroundSize: theme.iconSizes.twoXL,
      "&:hover": {
        backgroundColor: theme.colors.darkenedBgMix25,
      },
    },

    // On dark backgrounds, invert the color for the + and - symbols
    "& span": {
      filter: hasLightBackgroundColor(theme) ? "" : "invert(100%)",
    },
  },
}))


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/types.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import type { DeckProps } from "@deck.gl/core"

import type { DeckGlJsonChart as DeckGlJsonChartProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"

export type StreamlitDeckProps = DeckProps & {
  mapStyle?: string
}

type SerializedLayer = {
  /** @see https://deck.gl/docs/api-reference/json/conversion-reference */
  "@@type": string
  id?: string
  /** @see https://deck.gl/docs/developer-guide/performance#use-updatetriggers */
  updateTriggers?: Record<string, unknown[]>
} & Record<string, unknown>

export type ParsedDeckGlConfig = {
  layers: SerializedLayer[]
  mapStyle?: string
  initialViewState: DeckProps["initialViewState"]
  views: DeckProps["views"]
}

export interface DeckGLProps {
  disabled?: boolean
  disableFullscreenMode?: boolean
  element: DeckGlJsonChartProto
  fragmentId: string | undefined
  mapboxToken: string
  widgetMgr: WidgetStateManager
}

export interface DeckObject {
  initialViewState: {
    height: number
    width: number
  }
  layers: DeckProps["layers"]
  mapStyle?: string | Array<string>
}

/**
 * @see PydeckState in the backend for the corresponding Python type.
 */
export type DeckGlElementState = {
  selection: {
    indices: { [layerId: string]: number[] }
    objects: { [layerId: string]: unknown[] }
  }
}


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/useDeckGl.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { useCallback, useEffect, useMemo, useState } from "react"

import JSON5 from "json5"
import { PickingInfo, ViewStateChangeParameters } from "@deck.gl/core"
import isEqual from "lodash/isEqual"
import { TooltipContent } from "@deck.gl/core/dist/lib/tooltip"
import { parseToRgba } from "color2k"

import { useStWidthHeight } from "@streamlit/lib/src/hooks/useStWidthHeight"
import { EmotionTheme } from "@streamlit/lib/src/theme"
import { DeckGlJsonChart as DeckGlJsonChartProto } from "@streamlit/lib/src/proto"
import {
  useBasicWidgetClientState,
  ValueWithSource,
} from "@streamlit/lib/src/hooks/useBasicWidgetState"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import { useRequiredContext } from "@streamlit/lib/src/hooks/useRequiredContext"
import { ElementFullscreenContext } from "@streamlit/lib/src/components/shared/ElementFullscreen/ElementFullscreenContext"

import type {
  DeckGlElementState,
  DeckGLProps,
  DeckObject,
  ParsedDeckGlConfig,
} from "./types"
import { jsonConverter } from "./utils/jsonConverter"
import {
  FillFunction,
  getContextualFillColor,
  LAYER_TYPE_TO_FILL_FUNCTION,
} from "./utils/colors"

type UseDeckGlShape = {
  createTooltip: (info: PickingInfo | null) => TooltipContent
  data: DeckGlElementState
  deck: DeckObject
  hasActiveSelection: boolean
  height: number | string
  isSelectionModeActivated: boolean
  onViewStateChange: (params: ViewStateChangeParameters) => void
  selectionMode: DeckGlJsonChartProto.SelectionMode | undefined
  setSelection: React.Dispatch<
    React.SetStateAction<ValueWithSource<DeckGlElementState> | null>
  >
  viewState: Record<string, unknown>
  width: number | string
}

export type UseDeckGlProps = Omit<DeckGLProps, "mapboxToken"> & {
  isLightTheme: boolean
  theme: EmotionTheme
}

const DEFAULT_DECK_GL_HEIGHT = 500

export const EMPTY_STATE: DeckGlElementState = {
  selection: {
    indices: {},
    objects: {},
  },
}

/**
 * Interpolates variables within a string using values from a PickingInfo object.
 *
 * This function searches for placeholders in the format `{variable}` within the provided
 * string `body` and replaces them with corresponding values from the `info` object.
 * It first checks if the variable exists directly on `info.object`, and if not, it checks
 * within `info.object.properties`.
 *
 * @param {PickingInfo} info - The object containing the data to interpolate into the string.
 * @param {string} body - The string containing placeholders in the format `{variable}`.
 * @returns {string} - The interpolated string with placeholders replaced by actual values.
 */
const interpolate = (info: PickingInfo, body: string): string => {
  const matchedVariables = body.match(/{(.*?)}/g)
  if (matchedVariables) {
    matchedVariables.forEach((match: string) => {
      const variable = match.substring(1, match.length - 1)

      if (info.object.hasOwnProperty(variable)) {
        body = body.replace(match, info.object[variable])
      } else if (
        info.object.hasOwnProperty("properties") &&
        info.object.properties.hasOwnProperty(variable)
      ) {
        body = body.replace(match, info.object.properties[variable])
      }
    })
  }
  return body
}

function getDefaultState(
  widgetMgr: WidgetStateManager,
  element: DeckGlJsonChartProto
): DeckGlElementState {
  if (!element.id) {
    return EMPTY_STATE
  }

  const initialFigureState = widgetMgr.getElementState(element.id, "selection")

  return initialFigureState ?? EMPTY_STATE
}

function getStateFromWidgetMgr(
  widgetMgr: WidgetStateManager,
  element: DeckGlJsonChartProto
): DeckGlElementState {
  if (!element.id) {
    return EMPTY_STATE
  }

  const stringValue = widgetMgr.getStringValue(element)
  const currState: DeckGlElementState | null = stringValue
    ? JSON5.parse(stringValue)
    : null

  return currState ?? EMPTY_STATE
}

function updateWidgetMgrState(
  element: DeckGlJsonChartProto,
  widgetMgr: WidgetStateManager,
  vws: ValueWithSource<DeckGlElementState>,
  fragmentId?: string
): void {
  if (!element.id) {
    return
  }

  widgetMgr.setStringValue(
    element,
    JSON.stringify(vws.value),
    { fromUi: vws.fromUi },
    fragmentId
  )
}

export const useDeckGl = (props: UseDeckGlProps): UseDeckGlShape => {
  const {
    height: propsHeight,
    width: propsWidth,
    expanded: propsIsFullScreen,
  } = useRequiredContext(ElementFullscreenContext)

  const { element, fragmentId, isLightTheme, theme, widgetMgr } = props
  const {
    selectionMode: allSelectionModes,
    tooltip,
    useContainerWidth: shouldUseContainerWidth,
  } = element
  const isFullScreen = propsIsFullScreen ?? false

  const [data, setSelection] = useBasicWidgetClientState<
    DeckGlElementState,
    DeckGlJsonChartProto
  >({
    element,
    getDefaultState,
    getStateFromWidgetMgr,
    updateWidgetMgrState,
    widgetMgr,
    fragmentId,
  })

  const [viewState, setViewState] = useState<Record<string, unknown>>({
    bearing: 0,
    pitch: 0,
    zoom: 11,
  })

  const { height, width } = useStWidthHeight({
    element,
    isFullScreen,
    shouldUseContainerWidth,
    container: { height: propsHeight, width: propsWidth },
    heightFallback:
      (viewState.initialViewState as { height: number } | undefined)?.height ||
      DEFAULT_DECK_GL_HEIGHT,
  })

  const [initialViewState, setInitialViewState] = useState<
    Record<string, unknown>
  >({})

  /**
   * Our proto for selectionMode is an array in order to support future-looking
   * functionality. Currently, we only support 1 single selection mode, so we'll
   * only use the first one (if it exists) to determine our selection mode.
   *
   * @see deck_gl_json_chart.py #parse_selection_mode
   */
  const selectionMode: DeckGlJsonChartProto.SelectionMode | undefined =
    allSelectionModes[0]
  const isSelectionModeActivated = selectionMode !== undefined

  const hasActiveSelection =
    isSelectionModeActivated && Object.keys(data.selection.indices).length > 0

  const parsedPydeckJson = useMemo(() => {
    return Object.freeze(JSON5.parse<ParsedDeckGlConfig>(element.json))
    // Only parse JSON when transitioning to/from fullscreen, the json changes, or theme changes
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isFullScreen, isLightTheme, element.json])

  const deck = useMemo<DeckObject>(() => {
    const copy = { ...parsedPydeckJson }

    // If unset, use either the Mapbox light or dark style based on Streamlit's theme
    // For Mapbox styles, see https://docs.mapbox.com/api/maps/styles/#mapbox-styles
    if (!copy.mapStyle) {
      copy.mapStyle = `mapbox://styles/mapbox/${
        isLightTheme ? "light" : "dark"
      }-v9`
    }

    if (copy.layers) {
      const anyLayersHaveSelection = Object.values(
        data.selection.indices
      ).some(layer => layer?.length)

      const anyLayersHavePickableDefined = copy.layers.some(layer =>
        Object.hasOwn(layer, "pickable")
      )

      copy.layers = copy.layers.map(layer => {
        if (
          !layer ||
          Array.isArray(layer) ||
          // If selection mode is not activated, do not make any additional changes to each layer
          !isSelectionModeActivated
        ) {
          return layer
        }

        if (!anyLayersHavePickableDefined) {
          // If selection mode is activated and no layers have pickable defined,
          // set pickable to true for every layer. This is something Streamlit
          // does to help make map selection easier to work with out of the box.
          layer.pickable = true
        }

        const layerId = `${layer.id || null}`
        const selectedIndices = data?.selection?.indices?.[layerId] || []

        const fillFunctions = LAYER_TYPE_TO_FILL_FUNCTION[layer["@@type"]]

        if (!fillFunctions) {
          return layer
        }

        const clonedLayer = { ...layer }
        fillFunctions.forEach(fillFunction => {
          clonedLayer.updateTriggers = {
            // Tell Deck.gl to recompute the fill color when the selection changes.
            // Without this, objects in layers will have stale colors when selection changes.
            // @see https://deck.gl/docs/api-reference/core/layer#updatetriggers
            [fillFunction]: [
              ...(clonedLayer.updateTriggers?.[fillFunction] || []),
              selectedIndices,
              anyLayersHaveSelection,
            ],
          }

          const shouldUseOriginalFillFunction = !anyLayersHaveSelection

          const originalFillFunction = layer[fillFunction] as
            | FillFunction
            | undefined

          if (shouldUseOriginalFillFunction || !originalFillFunction) {
            // If we aren't changing the fill color, we don't need to change the fillFunction
            return clonedLayer
          }

          const selectedOpacity = 255
          const unselectedOpacity = Math.floor(255 * 0.4)

          // Fallback colors in case there are issues while parsing the colors for a given object
          const selectedColorParsed = parseToRgba(theme.colors.primary)
          const selectedColor: [number, number, number, number] = [
            selectedColorParsed[0],
            selectedColorParsed[1],
            selectedColorParsed[2],
            selectedOpacity,
          ]
          const unselectedColorParsed = parseToRgba(theme.colors.gray20)
          const unselectedColor: [number, number, number, number] = [
            unselectedColorParsed[0],
            unselectedColorParsed[1],
            unselectedColorParsed[2],
            unselectedOpacity,
          ]

          const newFillFunction: FillFunction = (object, objectInfo) => {
            return getContextualFillColor({
              isSelected: selectedIndices.includes(objectInfo.index),
              object,
              objectInfo,
              originalFillFunction,
              selectedColor,
              unselectedColor,
              selectedOpacity,
              unselectedOpacity,
            })
          }

          clonedLayer[fillFunction] = newFillFunction
        })

        return clonedLayer
      })
    }

    delete copy?.views // We are not using views. This avoids a console warning.

    return jsonConverter.convert(copy)
  }, [
    data.selection.indices,
    isLightTheme,
    isSelectionModeActivated,
    parsedPydeckJson,
    theme.colors.gray20,
    theme.colors.primary,
  ])

  useEffect(() => {
    // If the ViewState on the server has changed, apply the diff to the current state
    if (!isEqual(deck.initialViewState, initialViewState)) {
      const diff = Object.keys(deck.initialViewState).reduce(
        (diff, key): any => {
          // @ts-expect-error
          if (deck.initialViewState[key] === initialViewState[key]) {
            return diff
          }

          return {
            ...diff,
            // @ts-expect-error
            [key]: deck.initialViewState[key],
          }
        },
        {}
      )

      setViewState({ ...viewState, ...diff })
      setInitialViewState(deck.initialViewState)
    }
  }, [deck.initialViewState, initialViewState, viewState])

  const createTooltip = useCallback(
    (info: PickingInfo | null): TooltipContent => {
      if (!info || !info.object || !tooltip) {
        return null
      }

      const parsedTooltip = JSON5.parse(tooltip)

      if (parsedTooltip.html) {
        parsedTooltip.html = interpolate(info, parsedTooltip.html)
      } else {
        parsedTooltip.text = interpolate(info, parsedTooltip.text)
      }

      return parsedTooltip
    },
    [tooltip]
  )

  const onViewStateChange = useCallback(
    ({ viewState }: ViewStateChangeParameters) => {
      setViewState(viewState)
    },
    [setViewState]
  )

  return {
    createTooltip,
    data,
    deck,
    hasActiveSelection,
    height,
    isSelectionModeActivated,
    onViewStateChange,
    selectionMode,
    setSelection,
    viewState,
    width,
  }
}


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/utils/colors.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { getContextualFillColor, SerializedColorArray } from "./colors"

describe("#getContextualFillColor", () => {
  const object = { count: 10 }
  const selectedColor: SerializedColorArray = [255, 75, 75]
  const unselectedColor: SerializedColorArray = [25, 25, 25]

  const testCases: [
    string,
    Parameters<typeof getContextualFillColor>[0],
    ReturnType<typeof getContextualFillColor>
  ][] = [
    [
      "should return the original fill color when not selected",
      {
        isSelected: false,
        object,
        objectInfo: { index: 0 },
        originalFillFunction: () => [0, 0, 0, 255],
        selectedColor,
        unselectedColor,
      },
      [0, 0, 0, 102],
    ],
    [
      "should return the original fill color with lower opacity when not selected",
      {
        isSelected: false,
        object,
        objectInfo: { index: 0 },
        originalFillFunction: () => [0, 0, 0, 255],
        selectedColor,
        unselectedColor,
      },
      [0, 0, 0, 102],
    ],
    [
      "should return the original fill color with its original lower opacity when not selected",
      {
        isSelected: false,
        object,
        objectInfo: { index: 0 },
        originalFillFunction: () => [0, 0, 0, 40],
        selectedColor,
        unselectedColor,
      },
      [0, 0, 0, 40],
    ],
    // @see https://deck.gl/docs/api-reference/json/conversion-reference#functions-and-using-the--prefix
    [
      "should return the evaluated original fill color with lower opacity when not selected",
      {
        isSelected: false,
        object,
        objectInfo: { index: 0 },
        originalFillFunction: () => "@@=[255, 255, count > 50 ? 255 : 0]",
        selectedColor,
        unselectedColor,
      },
      [255, 255, 0, 102],
    ],
    [
      "should return the evaluated original fill color with lower opacity when not selected",
      {
        isSelected: false,
        object: { count: 200 },
        objectInfo: { index: 0 },
        originalFillFunction: () => "@@=[255, 255, count > 50 ? 255 : 0]",
        selectedColor,
        unselectedColor,
      },
      [255, 255, 255, 102],
    ],
    [
      "should return the evaluated original fill color with lower opacity when not selected",
      {
        isSelected: false,
        object,
        objectInfo: { index: 0 },
        originalFillFunction: () =>
          "@@=count > 10 ? [255, 0, 0] : [0, 255, 200]",
        selectedColor,
        unselectedColor,
      },
      [0, 255, 200, 102],
    ],
    [
      "should return the evaluated original fill color with lower opacity when not selected",
      {
        isSelected: false,
        object: { color: [124, 54, 66] },
        objectInfo: { index: 0 },
        originalFillFunction: () => "@@=color",
        selectedColor,
        unselectedColor,
      },
      [124, 54, 66, 102],
    ],
    [
      "should return the evaluated original fill color with its existing lower opacity when not selected",
      {
        isSelected: false,
        object: { color: [124, 54, 66, 40] },
        objectInfo: { index: 0 },
        originalFillFunction: () => "@@=color",
        selectedColor,
        unselectedColor,
      },
      [124, 54, 66, 40],
    ],
    [
      "should return the original shorthand fill color with lower opacity when not selected",
      {
        isSelected: false,
        object,
        objectInfo: { index: 0 },
        originalFillFunction: () => [255],
        selectedColor,
        unselectedColor,
      },
      [255, 0, 0, 102],
    ],
    [
      "should return the original color when selected",
      {
        isSelected: true,
        object,
        objectInfo: { index: 0 },
        originalFillFunction: () => [0, 0, 0, 255],
        selectedColor,
        unselectedColor,
      },
      [0, 0, 0, 255],
    ],
    [
      "should return the original color with higher opacity when selected",
      {
        isSelected: true,
        object,
        objectInfo: { index: 0 },
        originalFillFunction: () => [0, 0, 0, 40],
        selectedColor,
        unselectedColor,
      },
      [0, 0, 0, 255],
    ],
  ]

  it.each(testCases)("%s", (description, args, expected) => {
    expect(getContextualFillColor(args)).toEqual(expected)
  })
})


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/utils/colors.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import * as layers from "@deck.gl/layers"
import * as geoLayers from "@deck.gl/geo-layers"
import * as meshLayers from "@deck.gl/mesh-layers"

import { jsonConverter } from "./jsonConverter"

/**
 * @file Utilities for determining fill colors for layers based on their
 *      selection state and the layer's selection color mode.
 */

/**
 * Maps the "@@type" of a layer to the corresponding fill functions.
 *
 * Note that this mapping is not exhaustive and only includes the layers that we
 * can actually change the color of.
 */
export const LAYER_TYPE_TO_FILL_FUNCTION = {
  [geoLayers.GeohashLayer.layerName]: ["getFillColor"],
  [geoLayers.H3ClusterLayer.layerName]: ["getFillColor"],
  [geoLayers.H3HexagonLayer.layerName]: ["getFillColor"],
  [geoLayers.MVTLayer.layerName]: ["getFillColor"],
  [geoLayers.QuadkeyLayer.layerName]: ["getFillColor"],
  [geoLayers.S2Layer.layerName]: ["getFillColor"],
  [geoLayers.TripsLayer.layerName]: ["getColor"],
  [layers.ArcLayer.layerName]: ["getTargetColor", "getSourceColor"],
  [layers.ColumnLayer.layerName]: ["getFillColor"],
  [layers.GeoJsonLayer.layerName]: ["getFillColor"],
  [layers.IconLayer.layerName]: ["getColor"],
  [layers.LineLayer.layerName]: ["getColor"],
  [layers.PathLayer.layerName]: ["getColor"],
  [layers.PointCloudLayer.layerName]: ["getColor"],
  [layers.PolygonLayer.layerName]: ["getFillColor"],
  [layers.ScatterplotLayer.layerName]: [
    "getFillColor",
    "getColor",
    "getLineColor",
  ],
  [layers.SolidPolygonLayer.layerName]: ["getFillColor"],
  [layers.TextLayer.layerName]: ["getColor"],
  [meshLayers.ScenegraphLayer.layerName]: ["getColor"],
  [meshLayers.SimpleMeshLayer.layerName]: ["getColor"],
}

type SerializedColorValue = string | number
export type SerializedColorArray = [
  SerializedColorValue?,
  SerializedColorValue?,
  SerializedColorValue?,
  SerializedColorValue?
]

type ObjectCallbackShape<T = unknown> = {
  object: T
  objectInfo: { index: number }
}

export type FillFunction<T = unknown> = (
  object: ObjectCallbackShape<T>["object"],
  objectInfo: ObjectCallbackShape<T>["objectInfo"]
) => SerializedColorArray | SerializedColorValue

type FillFunctionArgs<T = unknown> = ObjectCallbackShape<T> & {
  originalFillFunction: FillFunction<T> | undefined
}

/**
 * Retrieves the original color in a standardized format by evaluating functions
 * if necessary.
 */
const getOriginalColor = ({
  object,
  objectInfo,
  originalFillFunction,
}: FillFunctionArgs): SerializedColorArray | null => {
  const originalColor =
    typeof originalFillFunction === "function"
      ? originalFillFunction(object, objectInfo)
      : originalFillFunction

  if (Array.isArray(originalColor)) {
    return [
      originalColor[0] || 0,
      originalColor[1] || 0,
      originalColor[2] || 0,
      originalColor[3] || 255,
    ]
  }

  if (typeof originalColor === "string" && originalColor.startsWith("@@=")) {
    // @see https://deck.gl/docs/api-reference/json/conversion-reference#functions-and-using-the--prefix

    const evaluated = jsonConverter
      .convert({ originalColor })
      .originalColor(object)

    return [
      evaluated[0] || 0,
      evaluated[1] || 0,
      evaluated[2] || 0,
      evaluated[3] || 255,
    ]
  }

  return null
}

/**
 * Calculates the original color with the applied opacity based on the selection
 * mode.
 *
 * @param {boolean} isSelected - Indicates if the object is selected.
 * @param {number} opacity - The opacity to apply.
 * @param {object} object - The object for which the color is being calculated.
 * @param {object} objectInfo - Additional information about the object.
 * @param {Function} originalFillFunction - The function to get the original
 * fill color.
 * @returns {SerializedColorArray | null} The color with the applied opacity or
 * null if the original color is not available.
 */
const getOriginalColorWithAppliedOpacity = ({
  isSelected,
  object,
  objectInfo,
  opacity,
  originalFillFunction,
}: {
  isSelected: boolean
  opacity: number
} & FillFunctionArgs): SerializedColorArray | null => {
  const originalColor = getOriginalColor({
    object,
    objectInfo,
    originalFillFunction,
  })

  if (!originalColor) {
    return null
  }

  let calculatedOpacity = 0

  if (isSelected) {
    // Some layers will have objects where the opacity is lower than the default
    // selected opacity In this case, we want to use the higher opacity so that
    // the differentiation between selected and unselected objects is more
    // pronounced
    calculatedOpacity = Math.max(
      typeof originalColor[3] === "number" ? originalColor[3] : opacity,
      opacity
    )
  } else {
    // Some layers will have objects where the opacity is lower than the default
    // unselected opacity In this case, we want to use the lower opacity so that
    // we aren't raising the visibility of objects unnecessarily
    calculatedOpacity = Math.min(
      typeof originalColor[3] === "number" ? originalColor[3] : opacity,
      opacity
    )
  }

  return [
    originalColor[0] || 0,
    originalColor[1] || 0,
    originalColor[2] || 0,
    calculatedOpacity,
  ]
}

/**
 * Determines the fill color for an object based on its selection state and the
 * layer's selection color mode.
 */
export const getContextualFillColor = ({
  isSelected,
  object,
  objectInfo,
  originalFillFunction,
  selectedColor,
  selectedOpacity = 255,
  unselectedColor,
  unselectedOpacity = Math.floor(255 * 0.4),
}: {
  isSelected: boolean
  /** Fallback color in case there are issues in parsing the color for the current object */
  selectedColor: SerializedColorArray
  /** How much opacity should be applied to the selected item. Defaults to 100% */
  selectedOpacity?: number
  /** Fallback color in case there are issues in parsing the color for the current object */
  unselectedColor: SerializedColorArray
  /** How much opacity should be applied to the not selected items. Defaults to 40% */
  unselectedOpacity?: number
} & FillFunctionArgs): SerializedColorArray | SerializedColorValue => {
  if (isSelected) {
    return (
      getOriginalColorWithAppliedOpacity({
        opacity: selectedOpacity,
        isSelected: true,
        object,
        objectInfo,
        originalFillFunction,
      }) || selectedColor
    )
  }

  return (
    getOriginalColorWithAppliedOpacity({
      opacity: unselectedOpacity,
      isSelected: false,
      object,
      objectInfo,
      originalFillFunction,
    }) || unselectedColor
  )
}


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/utils/jsonConverter.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  CARTO_LAYERS,
  colorBins,
  colorCategories,
  colorContinuous,
} from "@deck.gl/carto"
import * as layers from "@deck.gl/layers"
import { JSONConverter } from "@deck.gl/json"
import * as geoLayers from "@deck.gl/geo-layers"
import * as aggregationLayers from "@deck.gl/aggregation-layers"
import * as meshLayers from "@deck.gl/mesh-layers"

const configuration = {
  classes: {
    ...layers,
    ...aggregationLayers,
    ...geoLayers,
    ...meshLayers,
    ...CARTO_LAYERS,
  },
  functions: {
    colorBins,
    colorCategories,
    colorContinuous,
  },
}

export const jsonConverter = new JSONConverter({ configuration })


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/withMapboxToken/MapboxTokenError.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import ErrorElement from "@streamlit/lib/src/components/shared/ErrorElement"
import { StyledInlineCode } from "@streamlit/lib/src/components/elements/CodeBlock/styled-components"

import {
  MapboxTokenFetchingError,
  MapboxTokenNotProvidedError,
} from "./withMapboxToken"

interface Props {
  error: Error | MapboxTokenFetchingError | MapboxTokenNotProvidedError
  deltaType: string
  width: number
}

const MapboxTokenError = ({
  error,
  width,
  deltaType,
}: Props): ReactElement => {
  if (error instanceof MapboxTokenNotProvidedError) {
    return (
      <ErrorElement
        width={width}
        name="No Mapbox token provided"
        message={
          <>
            <p>
              To use <StyledInlineCode>st.{deltaType}</StyledInlineCode> or{" "}
              <StyledInlineCode>st.map</StyledInlineCode> you need to set up a
              Mapbox access token.
            </p>

            <p>
              To get a token, create an account at{" "}
              <a href="https://mapbox.com">https://mapbox.com</a>. It's free
              for moderate usage levels!
            </p>

            <p>
              Once you have a token, just set it using the Streamlit config
              option <StyledInlineCode>mapbox.token</StyledInlineCode> and
              don't forget to restart your Streamlit server at this point if
              it's still running, then reload this tab.
            </p>

            <p>
              See{" "}
              <a href="https://docs.streamlit.io/develop/api-reference/configuration/config.toml">
                our documentation
              </a>{" "}
              for more info on how to set config options.
            </p>
          </>
        }
      />
    )
  }

  if (error instanceof MapboxTokenFetchingError) {
    return (
      <ErrorElement
        width={width}
        name="Error fetching Streamlit Mapbox token"
        message={
          <>
            <p>This app requires an internet connection.</p>
            <p>Please check your connection and try again.</p>
            <p>
              If you think this is a bug, please file bug report{" "}
              <a href="https://github.com/streamlit/streamlit/issues/new/choose">
                here
              </a>
              .
            </p>
          </>
        }
      />
    )
  }

  return (
    <ErrorElement
      width={width}
      name="Error fetching Streamlit Mapbox token"
      message={error.message}
    />
  )
}

export default MapboxTokenError


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/withMapboxToken/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./withMapboxToken"


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/withMapboxToken/withMapboxToken.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import axios from "axios"
import { screen, waitFor } from "@testing-library/react"

import { customRenderLibContext, render } from "@streamlit/lib/src/test_util"
import { DeckGlJsonChart as DeckGlJsonChartProto } from "@streamlit/lib/src/proto"

import withMapboxToken, {
  MapboxTokenFetchingError,
  TOKENS_URL,
  WrappedMapboxProps,
} from "./withMapboxToken"

interface TestProps {
  label: string
  width: number
  mapboxToken: string
}

describe("withMapboxToken", () => {
  const mockMapboxToken = "mockToken"
  const element = DeckGlJsonChartProto.create({
    // mock .streamlit/config.toml token
    mapboxToken: mockMapboxToken,
  })

  const emptyElement = DeckGlJsonChartProto.create({})

  function getProps(): WrappedMapboxProps<TestProps> {
    return {
      label: "mockLabel",
      width: 123,
      element,
    }
  }

  vi.mock("axios")

  // This component is only used to test whether or not the mapbox is correctly set
  const MockComponent = (props: {
    mapboxToken: string | undefined
  }): ReactElement => (
    <div data-testid="mock-component">{props.mapboxToken}</div>
  )

  describe("withMapboxToken rendering", () => {
    const DeltaType = "testDeltaType"
    const WrappedComponent = withMapboxToken(DeltaType)(MockComponent)
    const LIB_CONFIG_TOKEN = "LIB_TOKEN_CONFIG"

    beforeEach(() => {
      vi.resetAllMocks()
    })

    it("renders without crashing", () => {
      const props = getProps()
      render(<WrappedComponent {...props} />, {})
      const mockComponentText = screen.getByText(mockMapboxToken)
      expect(mockComponentText).toBeInTheDocument()
    })

    it("defines `displayName`", () => {
      expect(WrappedComponent.displayName).toEqual(
        "withMapboxToken(MockComponent)"
      )
    })

    it("should inject mapbox token to the wrapped component when available in the config.toml", () => {
      axios.get = vi.fn().mockImplementation(() => ({
        data: { userMapboxToken: mockMapboxToken },
      }))

      render(<WrappedComponent element={element} width={500} />)

      const mockComponentText = screen.getByText(mockMapboxToken)
      expect(mockComponentText).toBeInTheDocument()
    })

    it("should render loading alert while fetching the token", () => {
      axios.get = vi.fn().mockReturnValue(new Promise(() => {}))
      render(<WrappedComponent element={emptyElement} width={500} />)

      expect(screen.getByTestId("stSkeleton")).toBeInTheDocument()
    })

    it("should fetch the token if userMapboxToken is not present in config.toml and libConfig", async () => {
      axios.get = vi
        .fn()
        .mockResolvedValue({ data: { mapbox: mockMapboxToken } })

      render(<WrappedComponent element={emptyElement} width={500} />)

      await waitFor(() => {
        expect(axios.get).toHaveBeenCalledWith(TOKENS_URL)
      })
    })

    it("should throw an error if fetched token is not present", async () => {
      let wrappedComponentInstance: any
      axios.get = vi
        .fn()
        .mockReturnValueOnce({ data: { mapbox: mockMapboxToken } })

      render(
        <WrappedComponent
          ref={ref => {
            wrappedComponentInstance = ref
          }}
          element={emptyElement}
          width={500}
        />
      )

      axios.get = vi.fn().mockRejectedValueOnce("ERROR")
      await expect(wrappedComponentInstance.initMapboxToken()).rejects.toThrow(
        new MapboxTokenFetchingError(`ERROR (${TOKENS_URL})`)
      )
    })

    it("should inject mapbox token to the wrapped component when available in the libConfig", async () => {
      axios.get = vi.fn().mockImplementation(() => ({
        data: { userMapboxToken: mockMapboxToken },
      }))

      customRenderLibContext(
        <WrappedComponent element={element} width={500} />,
        {
          libConfig: { mapboxToken: LIB_CONFIG_TOKEN },
        }
      )

      await waitFor(() => {
        const element = screen.getByTestId("mock-component")
        expect(element.textContent).toBe(mockMapboxToken)
      })
    })

    it("prioritizes the libConfig token if no config.toml token and don't fetch our token", async () => {
      axios.get = vi
        .fn()
        .mockResolvedValue({ data: { mapbox: mockMapboxToken } })

      customRenderLibContext(
        <WrappedComponent element={emptyElement} width={500} />,
        {
          libConfig: { mapboxToken: LIB_CONFIG_TOKEN },
        }
      )

      await waitFor(() => {
        const element = screen.getByTestId("mock-component")
        expect(element.textContent).toBe(LIB_CONFIG_TOKEN)
      })
    })
  })
})


================================================
File: /frontend/lib/src/components/elements/DeckGlJsonChart/withMapboxToken/withMapboxToken.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ComponentType, PureComponent, ReactNode } from "react"

import hoistNonReactStatics from "hoist-non-react-statics"
import axios from "axios"

import { ensureError } from "@streamlit/lib/src/util/ErrorHandling"
import {
  DeckGlJsonChart,
  Skeleton as SkeletonProto,
} from "@streamlit/lib/src/proto"
import { Skeleton } from "@streamlit/lib/src/components/elements/Skeleton"
import { LibContext } from "@streamlit/lib/src/components/core/LibContext"

import MapboxTokenError from "./MapboxTokenError"

interface InjectedProps {
  mapboxToken: string
}

export interface State {
  mapboxToken?: string
  mapboxTokenError?: Error
  isFetching: boolean
}

// Wraps a Component expecting a "mapboxToken" prop.
// The wrapped Component accepts a DeckGLJsonChart prop, which
// incorporates the config.toml token (if provided) and omits the "mapboxToken" prop.
export type WrappedMapboxProps<P extends InjectedProps> = Omit<
  P,
  "mapboxToken"
> & {
  element: DeckGlJsonChart
  width: number
}

export class MapboxTokenNotProvidedError extends Error {}
export class MapboxTokenFetchingError extends Error {}

/**
 * A remote file that stores user-visible tokens.
 */
export const TOKENS_URL = "https://data.streamlit.io/tokens.json"
const MAPBOX = "mapbox"

/**
 * A higher-order component that fetches our mapbox token and passes
 * it through to the wrapped component.
 * This component uses tokens from config.toml first when available.
 * If the token fetch fails, an error will be rendered in place of the wrapped component.
 * This component is necessary as it's good practice to separate data collection
 * (mapbox token retrieval) and the actual rendering of a component.
 *
 * @param {string} deltaType In case of an exception we show an error with this
 */

const withMapboxToken =
  (deltaType: string) =>
  <P extends InjectedProps>(
    WrappedComponent: ComponentType<React.PropsWithChildren<P>>
  ) => {
    // Return a wrapper that accepts the wrapped component's props, minus
    // "mapboxToken". The wrapper will fetch the mapboxToken and inject it into
    // the wrapped component automatically.
    class WithMapboxToken extends PureComponent<WrappedMapboxProps<P>, State> {
      public static readonly displayName = `withMapboxToken(${
        WrappedComponent.displayName || WrappedComponent.name
      })`

      static contextType = LibContext

      context!: React.ContextType<typeof LibContext>

      public constructor(props: WrappedMapboxProps<P>) {
        super(props)

        this.state = {
          isFetching: true,
          mapboxToken: undefined,
          mapboxTokenError: undefined,
        }
      }

      /**
       * Fetch the remote "tokens.json" set the "mapbox" in state.
       * Throw an error if we can't contact TOKENS_URL or the token is missing.
       */
      public initMapboxToken = async (): Promise<void> => {
        try {
          const response = await axios.get(TOKENS_URL)
          const { [MAPBOX]: token } = response.data

          if (!token) {
            throw new Error(`Missing token ${MAPBOX}`)
          }

          this.setState({
            mapboxToken: token,
            isFetching: false,
          })
        } catch (e) {
          const error = ensureError(e)

          this.setState({
            mapboxTokenError: error,
            isFetching: false,
          })
          throw new MapboxTokenFetchingError(
            `${error.message} (${TOKENS_URL})`
          )
        }
      }

      public componentDidMount(): void {
        const mapboxToken =
          this.props.element.mapboxToken || this.context.libConfig.mapboxToken

        if (mapboxToken) {
          this.setState({
            mapboxToken,
            isFetching: false,
          })
        } else {
          this.initMapboxToken()
        }
      }

      public render = (): ReactNode => {
        const { mapboxToken, mapboxTokenError, isFetching } = this.state
        const { width } = this.props

        // We got an error when fetching our mapbox token: show the error.
        if (mapboxTokenError) {
          return (
            <MapboxTokenError
              width={width}
              error={mapboxTokenError}
              deltaType={deltaType}
            />
          )
        }

        // If our mapboxToken hasn't been retrieved yet, show a loading
        // skeleton.
        if (isFetching) {
          return (
            <Skeleton
              element={SkeletonProto.create({
                style: SkeletonProto.SkeletonStyle.ELEMENT,
              })}
            />
          )
        }

        // We have the mapbox token. Pass it through to our component.
        return (
          // (this.props as unknown as P) is required to work around a TS issue:
          // https://github.com/microsoft/TypeScript/issues/28938#issuecomment-450636046
          <WrappedComponent
            {...(this.props as unknown as P)}
            mapboxToken={mapboxToken}
            width={width}
          />
        )
      }
    }

    return hoistNonReactStatics(WithMapboxToken, WrappedComponent)
  }

export default withMapboxToken


================================================
File: /frontend/lib/src/components/elements/Dialog/Dialog.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { Block as BlockProto } from "@streamlit/lib/src/proto"

import Dialog, { Props as DialogProps } from "./Dialog"

const getProps = (
  elementProps: Partial<BlockProto.Dialog> = {},
  props: Partial<DialogProps> = {}
): DialogProps => ({
  element: BlockProto.Dialog.create({
    title: "StreamlitDialog",
    isOpen: true,
    dismissible: true,
    ...elementProps,
  }),
  ...props,
})

describe("Dialog container", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(
      <Dialog {...props}>
        <div>test</div>
      </Dialog>
    )

    const dialogContainer = screen.getByTestId("stDialog")
    expect(dialogContainer).toBeInTheDocument()
    expect(dialogContainer).toHaveClass("stDialog")
  })

  it("should render the text when open", () => {
    const props = getProps()
    render(
      <Dialog {...props}>
        <div>test</div>
      </Dialog>
    )

    expect(screen.getByText("test")).toBeVisible()
  })

  it("should not render the text when closed", () => {
    const props = getProps({ isOpen: false })
    render(
      <Dialog {...props}>
        <div>test</div>
      </Dialog>
    )

    expect(() => screen.getByText("test")).toThrow()
  })

  it("should close when dismissible", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(
      <Dialog {...props}>
        <div>test</div>
      </Dialog>
    )

    expect(screen.getByText("test")).toBeVisible()
    await user.click(screen.getByLabelText("Close"))
    // dialog should be closed by clicking outside and, thus, the content should be gone
    expect(() => screen.getByText("test")).toThrow()
  })

  it("should not close when not dismissible", () => {
    const props = getProps({ dismissible: false })
    render(
      <Dialog {...props}>
        <div>test</div>
      </Dialog>
    )

    expect(screen.getByText("test")).toBeVisible()
    // close button - and hence dismiss - does not exist
    expect(() => screen.getByLabelText("Close")).toThrow()
  })
})


================================================
File: /frontend/lib/src/components/elements/Dialog/Dialog.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, useEffect, useState } from "react"

import Modal, {
  ModalBody,
  ModalHeader,
} from "@streamlit/lib/src/components/shared/Modal"
import { Block as BlockProto } from "@streamlit/lib/src/proto"
import IsDialogContext from "@streamlit/lib/src/components/core/IsDialogContext"
import { notNullOrUndefined } from "@streamlit/lib/src/util/utils"

export interface Props {
  element: BlockProto.Dialog
  deltaMsgReceivedAt?: number
}

const Dialog: React.FC<React.PropsWithChildren<Props>> = ({
  element,
  deltaMsgReceivedAt,
  children,
}): ReactElement => {
  const { title, dismissible, width, isOpen: initialIsOpen } = element
  const [isOpen, setIsOpen] = useState<boolean>(false)

  useEffect(() => {
    // Only apply the open state if it was actually set in the proto.
    if (notNullOrUndefined(initialIsOpen)) {
      setIsOpen(initialIsOpen)
    }

    // when the deltaMsgReceivedAt changes, we might want to open the dialog again.
    // since dismissing is a UI-only action, the initialIsOpen prop might not have
    // changed which would lead to the dialog not opening again.
  }, [initialIsOpen, deltaMsgReceivedAt])

  // don't use the Modal's isOpen prop as it feels laggy when using it
  if (!isOpen) {
    return <></>
  }

  return (
    <Modal
      isOpen
      closeable={dismissible}
      onClose={() => setIsOpen(false)}
      size={width === BlockProto.Dialog.DialogWidth.LARGE ? "full" : "default"}
    >
      <ModalHeader>{title}</ModalHeader>
      <ModalBody>{children}</ModalBody>
    </Modal>
  )
}

function DialogWithProvider(
  props: React.PropsWithChildren<Props>
): ReactElement {
  return (
    <IsDialogContext.Provider value={true}>
      <Dialog {...props} />
    </IsDialogContext.Provider>
  )
}

export default DialogWithProvider


================================================
File: /frontend/lib/src/components/elements/Dialog/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Dialog"


================================================
File: /frontend/lib/src/components/elements/DocString/DocString.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { DocString as DocStringProto } from "@streamlit/lib/src/proto"
import { render } from "@streamlit/lib/src/test_util"

import DocString, { DocStringProps, Member } from "./DocString"

const getProps = (
  elementProps: Partial<DocStringProto> = {}
): DocStringProps => ({
  element: DocStringProto.create({
    name: "st.balloons",
    value: "streamlit.balloons()",
    docString: "docstring",
    type: "method",
    ...elementProps,
  }),
  width: 0,
})

describe("DocString Element", () => {
  const props = getProps()

  it("renders without crashing", () => {
    render(<DocString {...props} />)
    expect(screen.getByTestId("stHelp")).toBeInTheDocument()
  })

  it("should render a doc-string", () => {
    render(<DocString {...props} />)
    expect(screen.getByTestId("stHelpDoc")).toHaveTextContent(
      props.element.docString
    )
  })

  it("should render 'no docs' text when empty", () => {
    const props = getProps({
      docString: undefined,
    })
    render(<DocString {...props} />)

    expect(screen.getByTestId("stHelpDoc")).toHaveTextContent(
      "No docs available"
    )
  })

  describe("doc-header", () => {
    it("should render a name", () => {
      render(<DocString {...props} />)
      expect(screen.getByTestId("stHelpName")).toHaveTextContent("st.balloons")
    })

    it("should render value", () => {
      render(<DocString {...props} />)
      expect(screen.getByTestId("stHelpValue")).toHaveTextContent(
        "streamlit.balloons()"
      )
    })

    it("should render a type", () => {
      render(<DocString {...props} />)
      expect(screen.getByTestId("stHelpType")).toHaveTextContent("method")
    })

    describe("should render empty when", () => {
      const props = getProps({
        name: undefined,
        value: undefined,
        type: undefined,
      })

      it("there's no name", () => {
        render(<DocString {...props} />)
        expect(screen.queryByTestId("stHelpName")).not.toBeInTheDocument()
      })

      it("there's no value", () => {
        render(<DocString {...props} />)
        expect(screen.queryByTestId("stHelpValue")).not.toBeInTheDocument()
      })

      it("there's no type", () => {
        render(<DocString {...props} />)
        expect(screen.queryByTestId("stHelpType")).not.toBeInTheDocument()
      })
    })

    // Testing cases that we expect to happen (won't test every combination)
    it("should render a type and value when there's no name", () => {
      const props = getProps({
        name: undefined,
      })
      render(<DocString {...props} />)

      expect(screen.queryByTestId("stHelpName")).not.toBeInTheDocument()

      expect(screen.getByTestId("stHelpType")).toHaveTextContent("method")
      expect(screen.getByTestId("stHelpValue")).toHaveTextContent(
        "streamlit.balloons()"
      )
    })

    // Testing cases that we expect to happen (won't test every combination)
    it("should render a name and type when there's no value", () => {
      const props = getProps({
        value: undefined,
      })
      render(<DocString {...props} />)

      expect(screen.queryByTestId("stHelpValue")).not.toBeInTheDocument()

      expect(screen.getByTestId("stHelpName")).toHaveTextContent("st.balloons")
      expect(screen.getByTestId("stHelpType")).toHaveTextContent("method")
    })
  })

  describe("members table", () => {
    it("should render no members when there are none", () => {
      render(<DocString {...props} />)
      expect(
        screen.queryByTestId("stHelpMembersTable")
      ).not.toBeInTheDocument()
    })

    it("should render members", () => {
      const props = getProps({
        members: [
          {
            name: "member1",
            value: "value1",
            type: "type1",
          },
          {
            name: "member2",
            value: "value2",
            type: "type2",
          },
        ],
      })
      render(<DocString {...props} />)

      expect(screen.getByTestId("stHelpMembersTable")).toBeInTheDocument()
      expect(screen.getAllByTestId("stHelpMember")).toHaveLength(2)
    })
  })
})

describe("Member Element", () => {
  it("should render value-oriented members", () => {
    const props = {
      member: {
        name: "member1",
        type: "type1",
        value: "value1",
      },
    }

    render(<Member {...props} />)

    expect(screen.getByTestId("stHelpMemberDocValue")).toHaveTextContent(
      "value1"
    )
    expect(screen.getByTestId("stHelpMemberDocName")).toHaveTextContent(
      "member1"
    )
    expect(screen.getByTestId("stHelpMemberDocType")).toHaveTextContent(
      "type1"
    )
  })

  it("should render doc-oriented members", () => {
    const props = {
      member: {
        name: "member1",
        type: "type1",
        docString: "docstring1",
      },
    }

    render(<Member {...props} />)

    expect(screen.getByTestId("stHelpMemberDocName")).toHaveTextContent(
      "member1"
    )
    expect(screen.getByTestId("stHelpMemberDocType")).toHaveTextContent(
      "type1"
    )
    expect(screen.getByTestId("stHelpMemberDocString")).toHaveTextContent(
      "docstring1"
    )
  })

  it("should prefer value over doc", () => {
    const props = {
      member: {
        name: "member1",
        type: "type1",
        value: "value1",
        docString: "docstring1",
      },
    }

    render(<Member {...props} />)

    expect(screen.getByTestId("stHelpMemberDocValue")).toHaveTextContent(
      "value1"
    )
    expect(screen.getByTestId("stHelpMemberDocName")).toHaveTextContent(
      "member1"
    )
    expect(screen.getByTestId("stHelpMemberDocType")).toHaveTextContent(
      "type1"
    )
    expect(
      screen.queryByTestId("stHelpMemberDocString")
    ).not.toBeInTheDocument()
    expect(screen.queryByText("docstring1")).not.toBeInTheDocument()
  })

  it("should tell you when there are no docs", () => {
    const props = {
      member: {
        name: "member1",
        type: "type1",
      },
    }

    render(<Member {...props} />)

    expect(screen.getByTestId("stHelpMemberDocString")).toHaveTextContent(
      "No docs available"
    )
  })

  it("should only show type if present", () => {
    const props = {
      member: {
        name: "member1",
      },
    }

    render(<Member {...props} />)

    expect(screen.queryByTestId("stHelpMemberDocType")).not.toBeInTheDocument()
  })
})


================================================
File: /frontend/lib/src/components/elements/DocString/DocString.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { DocString as DocStringProto, IMember } from "@streamlit/lib/src/proto"

import {
  StyledDocContainer,
  StyledDocHeader,
  StyledDocName,
  StyledDocString,
  StyledDocSummary,
  StyledDocType,
  StyledDocValue,
  StyledMembersDetailsCell,
  StyledMembersRow,
  StyledMembersSummaryCell,
  StyledMembersTable,
} from "./styled-components"

export interface DocStringProps {
  width: number
  element: DocStringProto
}

/**
 * Functional element representing formatted text.
 */
export default function DocString({
  width,
  element,
}: DocStringProps): ReactElement {
  const { name, type, value, docString, members } = element

  // Put it all together into a nice little html view.
  return (
    <StyledDocContainer className="stHelp" data-testid="stHelp" width={width}>
      <StyledDocHeader>
        <StyledDocSummary>
          {name ? (
            <StyledDocName data-testid="stHelpName">{name}</StyledDocName>
          ) : null}
          {type ? (
            <StyledDocType data-testid="stHelpType">{type}</StyledDocType>
          ) : null}
          {value ? (
            <StyledDocValue data-testid="stHelpValue">{value}</StyledDocValue>
          ) : null}
        </StyledDocSummary>
      </StyledDocHeader>
      <StyledDocString data-testid="stHelpDoc">
        {docString || "No docs available"}
      </StyledDocString>
      {members.length > 0 ? (
        <StyledMembersTable data-testid="stHelpMembersTable">
          {members.map(member => (
            <Member member={member} key={member.name} />
          ))}
        </StyledMembersTable>
      ) : null}
    </StyledDocContainer>
  )
}

interface MemberProps {
  member: IMember
}

// Exported for tests.
export function Member({ member }: MemberProps): ReactElement {
  const { name, type, value, docString } = member

  return (
    <StyledMembersRow data-testid="stHelpMember">
      <StyledMembersSummaryCell>
        {name ? (
          <StyledDocName data-testid="stHelpMemberDocName">
            {name}
          </StyledDocName>
        ) : null}
        {type ? (
          <StyledDocType data-testid="stHelpMemberDocType">
            {type}
          </StyledDocType>
        ) : null}
      </StyledMembersSummaryCell>

      <StyledMembersDetailsCell>
        {value ? (
          <StyledDocValue data-testid="stHelpMemberDocValue">
            {value}
          </StyledDocValue>
        ) : (
          <StyledDocValue data-testid="stHelpMemberDocString">
            {docString || "No docs available"}
          </StyledDocValue>
        )}
      </StyledMembersDetailsCell>
    </StyledMembersRow>
  )
}


================================================
File: /frontend/lib/src/components/elements/DocString/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./DocString"


================================================
File: /frontend/lib/src/components/elements/DocString/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledDocSummary = styled.span(({ theme }) => ({
  "& > *": {
    marginRight: theme.spacing.sm,
  },
}))

export const StyledDocName = styled.span(({ theme }) => ({
  fontWeight: theme.fontWeights.bold,
}))

export const StyledDocType = styled.span(({ theme }) => ({
  color: theme.colors.docStringTypeText,
}))

export const StyledDocValue = styled.span()

export interface StyledDocContainerProps {
  width: number
}

export const StyledDocContainer = styled.span<StyledDocContainerProps>(
  ({ theme }) => ({
    display: "flex",
    flexDirection: "column",
    borderRadius: theme.radii.default,
    border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
    fontFamily: theme.genericFonts.codeFont,
    fontSize: theme.fontSizes.sm,
  })
)

export const StyledDocHeader = styled.div(({ theme }) => ({
  padding: `${theme.spacing.sm} ${theme.spacing.lg}`,
  backgroundColor: theme.colors.docStringContainerBackground,
  borderBottom: `${theme.sizes.borderWidth} solid ${theme.colors.borderColorLight}`,
  // Add rounded corners to the top of the container to prevent the background
  // color from bleeding into the surrounding area.
  borderTopLeftRadius: theme.radii.default,
  borderTopRightRadius: theme.radii.default,
  fontSize: theme.fontSizes.sm,
  overflow: ["auto", "overlay"],
}))

export const StyledDocString = styled.div(({ theme }) => ({
  whiteSpace: "pre",
  overflow: ["auto", "overlay"],
  maxHeight: "30.5rem", // The extra 0.5rem is to show a little of the overflowing line.
  padding: `${theme.spacing.sm} ${theme.spacing.lg}`,
  fontSize: theme.fontSizes.sm,

  "&:not(:last-child)": {
    borderBottom: `${theme.sizes.borderWidth} solid ${theme.colors.borderColorLight}`,
  },
}))

export const StyledMembersTable = styled.table(({ theme }) => ({
  width: "100%",
  fontSize: theme.fontSizes.twoSm,
  backgroundColor: theme.colors.docStringContainerBackground,
  tableLayout: "fixed", // Fix table to container's boundaries.
  borderCollapse: "collapse",
}))

export const StyledMembersRow = styled.tr(({ theme }) => ({
  "&:not(:last-child)": {
    borderBottom: `${theme.sizes.borderWidth} dotted ${theme.colors.borderColorLight}`,
  },
}))

export const StyledMembersSummaryCell = styled.td(({ theme }) => ({
  width: "30%",
  overflow: ["auto", "overlay"],
  padding: `${theme.spacing.sm} ${theme.spacing.lg}`,

  "& > *": {
    marginRight: theme.spacing.sm,
  },
}))

export const StyledMembersDetailsCell = styled.td(({ theme }) => ({
  width: "70%",
  overflow: ["auto", "overlay"],
  padding: `${theme.spacing.sm} ${theme.spacing.lg}`,
}))


================================================
File: /frontend/lib/src/components/elements/ExceptionElement/ExceptionElement.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { Exception as ExceptionProto } from "@streamlit/lib/src/proto"

import ExceptionElement, { ExceptionElementProps } from "./ExceptionElement"

const getProps = (
  elementProps: Partial<ExceptionProto> = {}
): ExceptionElementProps => ({
  element: ExceptionProto.create({
    stackTrace: ["step 1", "step 2", "step 3"],
    type: "RuntimeError",
    message: "This is an exception of type RuntimeError",
    messageIsMarkdown: false,
    ...elementProps,
  }),
  width: 0,
})

describe("ExceptionElement Element", () => {
  it("renders without crashing", () => {
    render(<ExceptionElement {...getProps()} />)

    const exceptionContainer = screen.getByTestId("stException")
    expect(exceptionContainer).toBeInTheDocument()
    expect(exceptionContainer).toHaveClass("stException")
  })

  it("should render the complete stack", () => {
    render(<ExceptionElement {...getProps()} />)

    expect(screen.getByText("Traceback:")).toBeInTheDocument()

    const traceRows = screen.getAllByTestId("stExceptionTraceRow")
    traceRows.forEach((row, index) => {
      expect(row).toHaveTextContent(`step ${index + 1}`)
    })
  })

  it("should render only the message when type and stack are empty", () => {
    render(<ExceptionElement {...getProps({ type: "", stackTrace: [] })} />)

    expect(screen.queryByText("RuntimeError")).not.toBeInTheDocument()
    expect(screen.queryByText("Traceback:")).not.toBeInTheDocument()

    expect(
      screen.getByText("This is an exception of type RuntimeError")
    ).toBeInTheDocument()
  })

  it("should render markdown when it has messageIsMarkdown", () => {
    render(<ExceptionElement {...getProps({ messageIsMarkdown: true })} />)

    expect(screen.getByTestId("stMarkdownContainer")).toBeInTheDocument()
  })

  it("should render if there's no message", () => {
    render(<ExceptionElement {...getProps({ message: "" })} />)

    expect(screen.getByText("RuntimeError")).toBeInTheDocument()
  })
})


================================================
File: /frontend/lib/src/components/elements/ExceptionElement/ExceptionElement.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { notNullOrUndefined } from "@streamlit/lib/src/util/utils"
import AlertContainer, {
  Kind,
} from "@streamlit/lib/src/components/shared/AlertContainer"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"
import { Exception as ExceptionProto } from "@streamlit/lib/src/proto"
import { StyledCode } from "@streamlit/lib/src/components/elements/CodeBlock/styled-components"
import { StyledStackTrace } from "@streamlit/lib/src/components/shared/ErrorElement/styled-components"

import {
  StyledExceptionMessage,
  StyledMessageType,
  StyledStackTraceContent,
  StyledStackTraceRow,
  StyledStackTraceTitle,
} from "./styled-components"

export interface ExceptionElementProps {
  width: number
  element: ExceptionProto
}

interface ExceptionMessageProps {
  type: string
  message: string
  messageIsMarkdown: boolean
}

interface StackTraceProps {
  stackTrace: string[]
}

/**
 * Return true if the string is non-null and non-empty.
 */
function isNonEmptyString(value: string | null | undefined): boolean {
  return notNullOrUndefined(value) && value !== ""
}

function ExceptionMessage({
  type,
  message,
  messageIsMarkdown,
}: Readonly<ExceptionMessageProps>): ReactElement {
  // Build the message display.
  // On the backend, we use the StreamlitException type for errors that
  // originate from inside Streamlit. These errors have Markdown-formatted
  // messages, and so we wrap those messages inside our Markdown renderer.

  if (messageIsMarkdown) {
    let markdown = message ?? ""
    if (type.length !== 0) {
      markdown = `**${type}**: ${markdown}`
    }
    return <StreamlitMarkdown source={markdown} allowHTML={false} />
  }
  return (
    <>
      <StyledMessageType>{type}</StyledMessageType>
      {type.length !== 0 && ": "}
      {isNonEmptyString(message) ? message : null}
    </>
  )
}

function StackTrace({ stackTrace }: Readonly<StackTraceProps>): ReactElement {
  // Build the stack trace display, if we got a stack trace.
  return (
    <>
      <StyledStackTraceTitle>Traceback:</StyledStackTraceTitle>
      <StyledStackTrace>
        <StyledStackTraceContent>
          <StyledCode>
            {stackTrace.map((row: string, index: number) => (
              <StyledStackTraceRow
                key={index}
                data-testid="stExceptionTraceRow"
              >
                {row}
              </StyledStackTraceRow>
            ))}
          </StyledCode>
        </StyledStackTraceContent>
      </StyledStackTrace>
    </>
  )
}

/**
 * Functional element representing formatted text.
 */
export default function ExceptionElement({
  element,
  width,
}: Readonly<ExceptionElementProps>): ReactElement {
  return (
    <div className="stException" data-testid="stException">
      <AlertContainer
        kind={element.isWarning ? Kind.WARNING : Kind.ERROR}
        width={width}
      >
        <StyledExceptionMessage data-testid="stExceptionMessage">
          <ExceptionMessage
            type={element.type}
            message={element.message}
            messageIsMarkdown={element.messageIsMarkdown}
          />
        </StyledExceptionMessage>
        {element.stackTrace && element.stackTrace.length > 0 ? (
          <StackTrace stackTrace={element.stackTrace} />
        ) : null}
      </AlertContainer>
    </div>
  )
}


================================================
File: /frontend/lib/src/components/elements/ExceptionElement/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./ExceptionElement"


================================================
File: /frontend/lib/src/components/elements/ExceptionElement/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledStackTraceRow = styled.div(({ theme }) => ({
  marginTop: theme.spacing.sm,
  "&:first-of-type": {
    marginTop: 0,
  },
}))

export const StyledMessageType = styled.span(({ theme }) => ({
  fontWeight: theme.fontWeights.bold,
}))

export const StyledStackTraceTitle = styled.div(({ theme }) => ({
  // Need to add xl to top margin because markdown has negative xl margin bottom.
  marginTop: `calc(${theme.spacing.sm} + ${theme.spacing.xl})`,
  marginBottom: theme.spacing.sm,
}))

// This extra div makes sure that we also have a padding on the right side of the stack
// trace when scrolled to the right.
export const StyledStackTraceContent = styled.div({
  display: "inline-block",
  minWidth: "100%",
})

export const StyledExceptionMessage = styled.div({
  wordWrap: "break-word",
})


================================================
File: /frontend/lib/src/components/elements/Expander/Expander.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { Block as BlockProto } from "@streamlit/lib/src/proto"

import Expander, { ExpanderProps } from "./Expander"

const getProps = (
  elementProps: Partial<BlockProto.Expandable> = {},
  props: Partial<ExpanderProps> = {}
): ExpanderProps => ({
  element: BlockProto.Expandable.create({
    label: "hi",
    expanded: true,
    ...elementProps,
  }),
  isStale: false,
  empty: false,
  ...props,
})

describe("Expander container", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(
      <Expander {...props}>
        <div>test</div>
      </Expander>
    )
    const expanderContainer = screen.getByTestId("stExpander")
    expect(expanderContainer).toBeInTheDocument()
    expect(expanderContainer).toHaveClass("stExpander")
  })

  it("does not render a list", () => {
    const props = getProps()
    render(
      <Expander {...props}>
        <div>test</div>
      </Expander>
    )
    const list = screen.queryByRole("list")
    expect(list).not.toBeInTheDocument()
  })

  it("renders expander label as expected", () => {
    const props = getProps()
    render(
      <Expander {...props}>
        <div>test</div>
      </Expander>
    )
    expect(screen.getByText(props.element.label)).toBeInTheDocument()
  })

  it("does not render collapse/expand icon if empty", () => {
    const props = getProps({}, { empty: true })
    render(<Expander {...props}></Expander>)
    expect(
      screen.queryByTestId("stExpanderToggleIcon")
    ).not.toBeInTheDocument()
  })

  it("renders expander with a spinner icon", () => {
    const props = getProps({ icon: "spinner" })
    render(
      <Expander {...props}>
        <div>test</div>
      </Expander>
    )
    expect(screen.getByTestId("stExpanderIconSpinner")).toBeInTheDocument()
  })

  it("renders expander with a check icon", () => {
    const props = getProps({ icon: ":material/check:" })
    render(
      <Expander {...props}>
        <div>test</div>
      </Expander>
    )
    expect(screen.getByTestId("stExpanderIconCheck")).toBeInTheDocument()
  })

  it("renders expander with a error icon", () => {
    const props = getProps({ icon: ":material/error:" })
    render(
      <Expander {...props}>
        <div>test</div>
      </Expander>
    )
    expect(screen.getByTestId("stExpanderIconError")).toBeInTheDocument()
  })

  it("renders expander with an emoji icon", () => {
    const props = getProps({ icon: "" })
    render(
      <Expander {...props}>
        <div>test</div>
      </Expander>
    )
    expect(screen.getByTestId("stExpanderIcon")).toBeInTheDocument()
    expect(screen.getByText("")).toBeInTheDocument()
  })

  it("renders expander with a material icon", () => {
    const props = getProps({ icon: ":material/add_circle:" })
    render(
      <Expander {...props}>
        <div>test</div>
      </Expander>
    )
    expect(screen.getByTestId("stExpanderIcon")).toBeInTheDocument()
    expect(screen.getByText("add_circle")).toBeInTheDocument()
  })

  it("should render a expanded component", () => {
    const props = getProps()
    render(
      <Expander {...props}>
        <div>test</div>
      </Expander>
    )
    expect(screen.getByText("test")).toBeVisible()
  })

  it("should render a collapsed component", () => {
    const props = getProps({ expanded: false })
    render(
      <Expander {...props}>
        <div>test</div>
      </Expander>
    )
    expect(screen.getByText("test")).not.toBeVisible()
  })

  it("should render the text when expanded", async () => {
    const user = userEvent.setup()
    const props = getProps({ expanded: false })
    render(
      <Expander {...props}>
        <div>test</div>
      </Expander>
    )

    await user.click(screen.getByText("hi"))
    expect(screen.getByText("test")).toBeVisible()
  })
})


================================================
File: /frontend/lib/src/components/elements/Expander/Expander.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, useEffect, useRef, useState } from "react"

import { ExpandLess, ExpandMore } from "@emotion-icons/material-outlined"

import { Block as BlockProto } from "@streamlit/lib/src/proto"
import {
  DynamicIcon,
  StyledIcon,
  StyledSpinnerIcon,
} from "@streamlit/lib/src/components/shared/Icon"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"
import { notNullOrUndefined } from "@streamlit/lib/src/util/utils"
import { LibContext } from "@streamlit/lib/src/components/core/LibContext"
import { IconSize, isPresetTheme } from "@streamlit/lib/src/theme"

import {
  BORDER_SIZE,
  StyledDetails,
  StyledDetailsPanel,
  StyledExpandableContainer,
  StyledSummary,
  StyledSummaryHeading,
} from "./styled-components"

export interface ExpanderIconProps {
  icon?: string
}

/**
 * Renders an icon for the expander and optionally a user-defined icon.
 *
 * If the icon is "spinner", it will render a spinner icon.
 * If the icon is a valid, user-defined icon, it will render the user-defined icon.
 * Otherwise, it will render nothing.
 *
 * @param {string} icon - The icon to render.
 * @returns {ReactElement}
 */
export const ExpanderIcon = (props: ExpanderIconProps): ReactElement => {
  const { icon } = props
  const { activeTheme } = React.useContext(LibContext)

  const iconProps = {
    size: "lg" as IconSize,
    margin: "0",
    padding: "0",
  }

  const statusIconTestIds: Record<string, string> = {
    ":material/check:": "stExpanderIconCheck",
    ":material/error:": "stExpanderIconError",
  }

  if (icon === "spinner") {
    const usingCustomTheme = !isPresetTheme(activeTheme)
    return (
      <StyledSpinnerIcon
        usingCustomTheme={usingCustomTheme}
        data-testid="stExpanderIconSpinner"
        {...iconProps}
      />
    )
  }

  return icon ? (
    <DynamicIcon
      color="inherit"
      iconValue={icon}
      testid={statusIconTestIds[icon] || "stExpanderIcon"}
      {...iconProps}
    />
  ) : (
    <></>
  )
}

export interface ExpanderProps {
  element: BlockProto.Expandable
  isStale: boolean
  empty: boolean
}

const Expander: React.FC<React.PropsWithChildren<ExpanderProps>> = ({
  element,
  isStale,
  empty,
  children,
}): ReactElement => {
  const { label, expanded: initialExpanded } = element
  const [expanded, setExpanded] = useState<boolean>(initialExpanded || false)
  const detailsRef = useRef<HTMLDetailsElement>(null)
  const summaryRef = useRef<HTMLElement>(null)
  const animationRef = useRef<Animation | null>(null)
  const timeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null)
  const contentRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    // Only apply the expanded state if it was actually set in the proto.
    if (notNullOrUndefined(initialExpanded)) {
      setExpanded(initialExpanded)

      // We manage the open attribute via the detailsRef and not with React state
      if (detailsRef.current) {
        detailsRef.current.open = initialExpanded
      }
    }

    // Having `label` in the dependency array here is necessary because
    // sometimes two distinct expanders look so similar that even the react
    // diffing algorithm decides that they're the same element with updated
    // props (this happens when something in the app removes one expander and
    // replaces it with another in the same position).
    //
    // By adding `label` as a dependency, we ensure that we reset the
    // expander's `expanded` state in this edge case.
  }, [label, initialExpanded])

  const onAnimationFinish = (open: boolean): void => {
    if (!detailsRef.current) {
      return
    }

    detailsRef.current.open = open
    animationRef.current = null
    detailsRef.current.style.height = ""
    detailsRef.current.style.overflow = ""
  }

  const toggleAnimation = (
    detailsEl: HTMLDetailsElement,
    startHeight: number,
    endHeight: number
  ): void => {
    const isOpen = endHeight > startHeight

    if (animationRef.current) {
      animationRef.current.cancel()

      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current)
        timeoutRef.current = null
      }
    }

    const animation = detailsEl.animate(
      {
        height: [`${startHeight}px`, `${endHeight}px`],
      },
      {
        duration: 500,
        easing: "cubic-bezier(0.23, 1, 0.32, 1)",
      }
    )

    animation.addEventListener("finish", () => onAnimationFinish(isOpen))
    animationRef.current = animation
  }

  const toggle = (e: React.MouseEvent<HTMLDetailsElement>): void => {
    e.preventDefault()
    if (empty) {
      return
    }

    setExpanded(!expanded)
    const detailsEl = detailsRef.current
    if (!detailsEl || !summaryRef.current) {
      return
    }

    detailsEl.style.overflow = "hidden"
    const detailsHeight = detailsEl.getBoundingClientRect().height
    const summaryHeight = summaryRef.current.getBoundingClientRect().height

    if (!expanded) {
      detailsEl.style.height = `${detailsHeight}px`
      detailsEl.open = true

      window.requestAnimationFrame(() => {
        // For expansion animations, we rely on the rendered width and height
        // of the children content. However, in Safari, the children are not
        // rendered because Safari doesn't paint elements that are not visible
        // (in this case, the details element is not visible because it's
        // not open). This operation produces inconsistent heights to animate.
        // To work around this, we force a repaint by animating a tiny bit
        // and animate the rest of it later.
        toggleAnimation(
          detailsEl,
          detailsHeight,
          summaryHeight + 2 * BORDER_SIZE + 5 // Arbitrary size of 5px
        )

        timeoutRef.current = setTimeout(() => {
          if (!contentRef.current) {
            return
          }

          const contentHeight =
            contentRef.current.getBoundingClientRect().height
          toggleAnimation(
            detailsEl,
            detailsHeight,
            summaryHeight + contentHeight + 2 * BORDER_SIZE
          )
        }, 100)
      })
    } else {
      toggleAnimation(
        detailsEl,
        detailsHeight,
        summaryHeight + 2 * BORDER_SIZE
      )
    }
  }

  return (
    <StyledExpandableContainer className="stExpander" data-testid="stExpander">
      <StyledDetails isStale={isStale} ref={detailsRef}>
        <StyledSummary
          onClick={toggle}
          empty={empty}
          ref={summaryRef}
          isStale={isStale}
        >
          <StyledSummaryHeading>
            {element.icon && <ExpanderIcon icon={element.icon} />}
            <StreamlitMarkdown source={label} allowHTML={false} isLabel />
          </StyledSummaryHeading>
          {!empty ? (
            <StyledIcon
              as={expanded ? ExpandLess : ExpandMore}
              color={"inherit"}
              aria-hidden="true"
              data-testid="stExpanderToggleIcon"
              size="lg"
              margin=""
              padding=""
            />
          ) : (
            <></>
          )}
        </StyledSummary>
        {!empty ? (
          <StyledDetailsPanel data-testid="stExpanderDetails" ref={contentRef}>
            {children}
          </StyledDetailsPanel>
        ) : (
          <></>
        )}
      </StyledDetails>
    </StyledExpandableContainer>
  )
}

export default Expander


================================================
File: /frontend/lib/src/components/elements/Expander/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Expander"
export type { ExpanderProps } from "./Expander"


================================================
File: /frontend/lib/src/components/elements/Expander/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

import {
  STALE_STYLES,
  STALE_TRANSITION_PARAMS,
} from "@streamlit/lib/src/theme"

export interface StyledExpandableContainerProps {
  empty: boolean
  disabled: boolean
}

export const StyledExpandableContainer = styled.div({})
interface StyledDetailsProps {
  isStale: boolean
}

export const BORDER_SIZE = 1 // px
export const StyledDetails = styled.details<StyledDetailsProps>(
  ({ isStale, theme }) => ({
    marginBottom: 0,
    marginTop: 0,
    width: "100%",
    borderStyle: "solid",
    borderWidth: theme.sizes.borderWidth,
    borderColor: theme.colors.borderColor,
    borderRadius: theme.radii.default,
    ...(isStale
      ? {
          borderColor: theme.colors.borderColorLight,
          transition: `border ${STALE_TRANSITION_PARAMS}`,
        }
      : {}),
  })
)

export const StyledSummaryHeading = styled.span(({ theme }) => ({
  display: "flex",
  gap: theme.spacing.sm,
  alignItems: "center",
  flexGrow: 1,
}))

interface StyledSummaryProps {
  empty: boolean
  isStale: boolean
}

export const StyledSummary = styled.summary<StyledSummaryProps>(
  ({ theme, empty, isStale }) => ({
    position: "relative",
    display: "flex",
    width: "100%",
    "&:focus-visible": {
      outline: `${theme.sizes.borderWidth} solid ${theme.colors.primary}`,
      outlineOffset: `-${theme.sizes.borderWidth}`,
      borderRadius: theme.radii.default,
    },
    fontSize: theme.fontSizes.sm,
    paddingLeft: theme.spacing.lg,
    paddingRight: theme.spacing.lg,
    paddingTop: theme.spacing.md,
    paddingBottom: theme.spacing.md,
    cursor: "pointer",
    listStyleType: "none",
    "&::-webkit-details-marker": {
      display: "none",
    },
    "&:hover": {
      color: empty ? undefined : theme.colors.primary,
    },
    "&:hover svg": {
      fill: empty ? undefined : theme.colors.primary,
    },
    ...(empty && {
      cursor: "default",
    }),
    ...(isStale && STALE_STYLES),
  })
)

export const StyledDetailsPanel = styled.div(({ theme }) => ({
  paddingBottom: theme.spacing.lg,
  paddingLeft: theme.spacing.lg,
  paddingRight: theme.spacing.lg,
}))


================================================
File: /frontend/lib/src/components/elements/Favicon/Favicon.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { mockEndpoints } from "@streamlit/lib/src/mocks/mocks"

import { handleFavicon } from "./Favicon"

function getFaviconHref(): string {
  const faviconElement: HTMLLinkElement | null = document.querySelector(
    "link[rel='shortcut icon']"
  )
  return faviconElement ? faviconElement.href : ""
}

document.head.innerHTML = `<link rel="shortcut icon" href="default.png">`

const PIZZA_TWEMOJI_URL =
  "https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/1f355.png"
const SATELLITE_TWEMOJI_URL =
  "https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/1f6f0.png"
const CRESCENT_MOON_TWEMOJI_URL =
  "https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/1f319.png"

const FLAG_MATERIAL_ICON_URL =
  "https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsrounded/flag/default/24px.svg"

const SMART_DISPLAY_MATERIAL_ICON_URL =
  "https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsrounded/smart_display/default/24px.svg"

const ACCESSIBILITY_NEW_MATERIAL_ICON_URL =
  "https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsrounded/accessibility_new/default/24px.svg"

test("is set up with the default favicon", () => {
  expect(getFaviconHref()).toBe("http://localhost:3000/default.png")
})

describe("Favicon element", () => {
  const buildMediaURL = vi.fn().mockReturnValue("https://mock.media.url")
  const endpoints = mockEndpoints({ buildMediaURL: buildMediaURL })

  it("sets the favicon in the DOM", () => {
    handleFavicon("https://some/random/favicon.png", vi.fn(), endpoints)
    expect(buildMediaURL).toHaveBeenCalledWith(
      "https://some/random/favicon.png"
    )
    expect(getFaviconHref()).toBe("https://mock.media.url/")
  })

  it("accepts emojis directly", () => {
    handleFavicon("", vi.fn(), endpoints)
    expect(getFaviconHref()).toBe(PIZZA_TWEMOJI_URL)
  })

  it("handles emoji variants correctly", () => {
    handleFavicon("", vi.fn(), endpoints)
    expect(getFaviconHref()).toBe(SATELLITE_TWEMOJI_URL)
  })

  it("handles material icon correctly", () => {
    handleFavicon(":material/flag:", vi.fn(), endpoints)
    expect(getFaviconHref()).toBe(FLAG_MATERIAL_ICON_URL)

    handleFavicon(":material/smart_display:", vi.fn(), endpoints)
    expect(getFaviconHref()).toBe(SMART_DISPLAY_MATERIAL_ICON_URL)

    handleFavicon(":material/accessibility_new:", vi.fn(), endpoints)
    expect(getFaviconHref()).toBe(ACCESSIBILITY_NEW_MATERIAL_ICON_URL)
  })

  it("handles emoji shortcodes containing a dash correctly", () => {
    handleFavicon(":crescent-moon:", vi.fn(), endpoints)
    expect(getFaviconHref()).toBe(CRESCENT_MOON_TWEMOJI_URL)
  })

  it("accepts emoji shortcodes", () => {
    handleFavicon(":pizza:", vi.fn(), endpoints)
    expect(getFaviconHref()).toBe(PIZZA_TWEMOJI_URL)
  })

  it("updates the favicon when it changes", () => {
    handleFavicon("/media/1234567890.png", vi.fn(), endpoints)
    handleFavicon(":pizza:", vi.fn(), endpoints)
    expect(getFaviconHref()).toBe(PIZZA_TWEMOJI_URL)
  })

  it("sends SET_PAGE_FAVICON message to host", () => {
    const sendMessageToHost = vi.fn()
    handleFavicon(
      "https://streamlit.io/path/to/favicon.png",
      sendMessageToHost,
      endpoints
    )
    expect(sendMessageToHost).toHaveBeenCalledWith({
      favicon: "https://mock.media.url",
      type: "SET_PAGE_FAVICON",
    })
  })
})


================================================
File: /frontend/lib/src/components/elements/Favicon/Favicon.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import nodeEmoji from "node-emoji"

import { grabTheRightIcon } from "@streamlit/lib/src/vendor/twemoji"
import { IGuestToHostMessage } from "@streamlit/lib/src/hostComm/types"
import { StreamlitEndpoints } from "@streamlit/lib/src/StreamlitEndpoints"

function iconToUrl(icon: string): string {
  const iconRegexp = /^:(.+)\/(.+):$/
  const matchResult = icon.match(iconRegexp)
  if (matchResult === null) {
    // If the icon is invalid, return just an empty string
    return ""
  }

  return `https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsrounded/${matchResult[2]}/default/24px.svg`
}

/**
 * Set the provided url/emoji as the page favicon.
 *
 * @param {string} favicon an image url, or an emoji like  or :pizza:
 * @param sendMessageToHost a function that posts messages to the app's parent iframe
 * @param endpoints
 */
export function handleFavicon(
  favicon: string,
  sendMessageToHost: (message: IGuestToHostMessage) => void,
  endpoints: StreamlitEndpoints
): void {
  const emoji = extractEmoji(favicon)
  let imageUrl

  if (emoji && !favicon.startsWith(":material")) {
    // Find the corresponding Twitter emoji on the CDN.
    const codepoint = grabTheRightIcon(emoji)
    const emojiUrl = `https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/${codepoint}.png`

    imageUrl = emojiUrl
  } else if (favicon.startsWith(":material")) {
    imageUrl = iconToUrl(favicon)
  } else {
    imageUrl = endpoints.buildMediaURL(favicon)
  }

  overwriteFavicon(imageUrl)

  sendMessageToHost({
    type: "SET_PAGE_FAVICON",
    favicon: imageUrl,
  })
}

// Update the favicon in the DOM with the specified image.
function overwriteFavicon(imageUrl: string): void {
  const faviconElement: HTMLLinkElement | null = document.querySelector(
    "link[rel='shortcut icon']"
  )

  if (faviconElement) {
    faviconElement.href = imageUrl
  }
}

// Return the emoji if it exists, or empty string otherwise
function extractEmoji(maybeEmoji: string): string {
  const shortcode = maybeEmoji.replace("-", "_")
  if (nodeEmoji.hasEmoji(nodeEmoji.get(shortcode))) {
    // Format: pizza or :pizza:
    // Since hasEmoji(':pizza:') == true, we must do this check first
    return nodeEmoji.get(shortcode)
  }
  if (nodeEmoji.hasEmoji(maybeEmoji)) {
    // Format: 
    return maybeEmoji
  }
  return ""
}


================================================
File: /frontend/lib/src/components/elements/Favicon/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { handleFavicon } from "./Favicon"


================================================
File: /frontend/lib/src/components/elements/GraphVizChart/GraphVizChart.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { Mock } from "vitest"
import { screen } from "@testing-library/react"
import { graphviz } from "d3-graphviz"

import { logError } from "@streamlit/lib/src/util/log"
import { render } from "@streamlit/lib/src/test_util"
import { GraphVizChart as GraphVizChartProto } from "@streamlit/lib/src/proto"

import GraphVizChart, { GraphVizChartProps } from "./GraphVizChart"

vi.mock("d3-graphviz", () => ({
  graphviz: vi.fn().mockReturnValue({
    zoom: () => ({
      fit: () => ({
        scale: () => ({
          engine: () => ({
            renderDot: () => ({
              on: vi.fn(),
            }),
          }),
        }),
      }),
    }),
  }),
}))
vi.mock("@streamlit/lib/src/util/log", () => ({
  logError: vi.fn(),
  logMessage: vi.fn(),
}))

const getProps = (
  elementProps: Partial<GraphVizChartProto> = {}
): GraphVizChartProps => ({
  element: GraphVizChartProto.create({
    spec: `digraph "Hello World" {Hello -> World}`,
    elementId: "1",
    ...elementProps,
  }),
  width: 700,
})

describe("GraphVizChart Element", () => {
  beforeEach(() => {
    // @ts-expect-error
    logError.mockClear()
  })

  afterEach(() => {
    // @ts-expect-error
    graphviz.mockClear()
  })

  it("renders without crashing", () => {
    const props = getProps()
    render(<GraphVizChart {...props} />)

    const graphvizElement = screen.getByTestId("stGraphVizChart")
    expect(graphvizElement).toBeInTheDocument()
    expect(graphvizElement).toHaveClass("stGraphVizChart")

    expect(logError).not.toHaveBeenCalled()
    expect(graphviz).toHaveBeenCalled()
  })

  it("should update chart and log error when crashes", () => {
    // Mock graphviz().renderDot() to throw an error for the "crash" spec
    const mockRenderDot = vi.fn().mockImplementation(spec => {
      if (spec === "crash") {
        throw new Error("Simulated GraphViz crash")
      }
      return {
        on: vi.fn(),
      }
    })

    // Modify the graphviz mock to use the mockRenderDot
    ;(graphviz as Mock).mockReturnValue({
      zoom: () => ({
        fit: () => ({
          scale: () => ({
            engine: () => ({
              renderDot: mockRenderDot,
            }),
          }),
        }),
      }),
    })

    const props = getProps({
      spec: "crash",
    })

    render(<GraphVizChart {...props} />)

    expect(logError).toHaveBeenCalledTimes(1)
    expect(mockRenderDot).toHaveBeenCalledWith("crash")
    expect(graphviz).toHaveBeenCalledTimes(1)
  })

  it("shoud render with height and width set to auto", () => {
    const props = {
      ...getProps(),
    }
    render(<GraphVizChart {...props} />)

    expect(screen.getByTestId("stGraphVizChart")).toHaveStyle(
      "height: auto; width: auto"
    )
  })
})


================================================
File: /frontend/lib/src/components/elements/GraphVizChart/GraphVizChart.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, useEffect } from "react"

import { select } from "d3"
import { Engine, graphviz } from "d3-graphviz"

import { logError } from "@streamlit/lib/src/util/log"
import { GraphVizChart as GraphVizChartProto } from "@streamlit/lib/src/proto"
import Toolbar, {
  StyledToolbarElementContainer,
} from "@streamlit/lib/src/components/shared/Toolbar"
import { ElementFullscreenContext } from "@streamlit/lib/src/components/shared/ElementFullscreen/ElementFullscreenContext"
import { useRequiredContext } from "@streamlit/lib/src/hooks/useRequiredContext"
import { withFullScreenWrapper } from "@streamlit/lib/src/components/shared/FullScreenWrapper"

import { StyledGraphVizChart } from "./styled-components"

export interface GraphVizChartProps {
  element: GraphVizChartProto
  width: number
  disableFullscreenMode?: boolean
}

function GraphVizChart({
  element,
  disableFullscreenMode,
}: Readonly<GraphVizChartProps>): ReactElement {
  const chartId = `st-graphviz-chart-${element.elementId}`

  const {
    expanded: isFullScreen,
    width,
    height,
    expand,
    collapse,
  } = useRequiredContext(ElementFullscreenContext)

  useEffect(() => {
    try {
      graphviz(`#${chartId}`)
        .zoom(false)
        .fit(true)
        .scale(1)
        .engine(element.engine as Engine)
        .renderDot(element.spec)

      if (isFullScreen || element.useContainerWidth) {
        const node = select(`#${chartId} > svg`).node() as SVGGraphicsElement
        // We explicitly remove width and height to let CSS and the SVG viewBox
        // define its dimensions
        node.removeAttribute("width")
        node.removeAttribute("height")
      }
    } catch (error) {
      logError(error)
    }
  }, [
    chartId,
    element.engine,
    element.spec,
    element.useContainerWidth,
    isFullScreen,
  ])

  return (
    <StyledToolbarElementContainer
      width={width}
      height={height}
      useContainerWidth={isFullScreen || element.useContainerWidth}
    >
      <Toolbar
        target={StyledToolbarElementContainer}
        isFullScreen={isFullScreen}
        onExpand={expand}
        onCollapse={collapse}
        disableFullscreenMode={disableFullscreenMode}
      ></Toolbar>
      <StyledGraphVizChart
        className="stGraphVizChart"
        data-testid="stGraphVizChart"
        id={chartId}
        isFullScreen={isFullScreen}
        useContainerWidth={element.useContainerWidth}
      />
    </StyledToolbarElementContainer>
  )
}

export default withFullScreenWrapper(GraphVizChart)


================================================
File: /frontend/lib/src/components/elements/GraphVizChart/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./GraphVizChart"


================================================
File: /frontend/lib/src/components/elements/GraphVizChart/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

interface StyledGraphVizChartProps {
  isFullScreen: boolean
  useContainerWidth: boolean
}

export const StyledGraphVizChart = styled.div<StyledGraphVizChartProps>(
  ({ theme, isFullScreen, useContainerWidth }) => ({
    "& *": {
      fontFamily: theme.genericFonts.bodyFont,
      // Font sizes inside the SVG element are getting huge for some reason.
      // Hacking together a number by eyeballing it:
      // 12px in the SVG looks like 1rem outside.
      fontSize: `calc(${theme.fontSizes.twoSm} * 0.8)`,
    },

    // Ensure SVG is allowed the full width/height in full screen mode
    "& svg": {
      maxWidth: "100%",
      width: isFullScreen || useContainerWidth ? "100%" : "auto",
      height: isFullScreen ? "100%" : "auto",
    },
    width: isFullScreen ? "100%" : "auto",
    height: isFullScreen ? "100%" : "auto",
  })
)


================================================
File: /frontend/lib/src/components/elements/Html/Html.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { Html as HtmlProto } from "@streamlit/lib/src/proto"

import Html, { HtmlProps } from "./Html"

const getProps = (elementProps: Partial<HtmlProto> = {}): HtmlProps => ({
  element: HtmlProto.create({
    body: "<div>Test Html</div>",
    ...elementProps,
  }),
  width: 100,
})

describe("HTML element", () => {
  it("renders the element as expected", () => {
    const props = getProps()
    render(<Html {...props} />)
    const html = screen.getByTestId("stHtml")
    expect(html).toBeInTheDocument()
    expect(html).toHaveTextContent("Test Html")
    expect(html).toHaveStyle("width: 100px")
    expect(html).toHaveClass("stHtml")
  })

  it("handles <style> tags - applies style", () => {
    const props = getProps({
      body: `
        <style>
            #random { color: rgb(255, 165, 0); }
        </style>
        <div id="random">Test Html</div>
    `,
    })
    render(<Html {...props} />)
    const html = screen.getByTestId("stHtml")
    expect(html).toHaveTextContent("Test Html")
    // Check that the style tag is applied to the div
    expect(screen.getByText("Test Html")).toHaveStyle(
      "color: rgb(255, 165, 0)"
    )
    // Check that the unnecessary spacing handling by hiding parent
    // eslint-disable-next-line testing-library/no-node-access
    expect(html.parentElement).toHaveClass("stHtml-empty")
  })

  it("sanitizes <script> tags", () => {
    const props = getProps({
      body: `<script> alert('BEWARE - the script tag is scripting'); </script>`,
    })
    render(<Html {...props} />)
    expect(screen.queryByTestId("stHtml")).not.toBeInTheDocument()
  })

  it("sanitizes <svg> tags", () => {
    const props = getProps({
      body: `
        <svg width="100" height="100">
            <circle cx="50" cy="50" r="40" stroke="green" stroke-width="4" fill="yellow" />
        </svg>
    `,
    })
    render(<Html {...props} />)
    expect(screen.getByTestId("stHtml")).toHaveTextContent("")
  })

  describe("sanitizes anchor tags", () => {
    it("does not add target when not present", () => {
      const props = getProps({
        body: '<a href="https://streamlit.io">Click Me</a>',
      })
      render(<Html {...props} />)
      const anchorElement = screen.getByRole("link", { name: "Click Me" })
      expect(anchorElement).not.toHaveAttribute("target")
    })

    it("preserves target='_blank' and adds rel attributes", () => {
      const props = getProps({
        body: '<a href="https://streamlit.io" target="_blank">Click Me</a>',
      })
      render(<Html {...props} />)
      const anchorElement = screen.getByRole("link", { name: "Click Me" })
      expect(anchorElement).toHaveAttribute("target", "_blank")
      expect(anchorElement).toHaveAttribute("rel", "noopener noreferrer")
    })

    it("removes non-_blank target attributes", () => {
      const props = getProps({
        body: '<a href="https://streamlit.io" target="_self">Click Me</a>',
      })
      render(<Html {...props} />)
      const anchorElement = screen.getByRole("link", { name: "Click Me" })
      expect(anchorElement).not.toHaveAttribute("target")
      expect(anchorElement).not.toHaveAttribute("rel")
    })
  })
})


================================================
File: /frontend/lib/src/components/elements/Html/Html.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, useEffect, useRef, useState } from "react"

import DOMPurify from "dompurify"

import { Html as HtmlProto } from "@streamlit/lib/src/proto"

export interface HtmlProps {
  width: number
  element: HtmlProto
}

// preserve target=_blank and set security attributes (see https://github.com/cure53/DOMPurify/issues/317)
const TEMPORARY_ATTRIBUTE = "data-temp-href-target"
DOMPurify.addHook("beforeSanitizeAttributes", function (node) {
  if (
    node instanceof HTMLElement &&
    node.hasAttribute("target") &&
    node.getAttribute("target") === "_blank"
  ) {
    node.setAttribute(TEMPORARY_ATTRIBUTE, "_blank")
  }
})
DOMPurify.addHook("afterSanitizeAttributes", function (node) {
  if (node instanceof HTMLElement && node.hasAttribute(TEMPORARY_ATTRIBUTE)) {
    node.setAttribute("target", "_blank")
    // according to https://html.spec.whatwg.org/multipage/links.html#link-type-noopener,
    // noreferrer implies noopener, but we set it just to be sure in case some browsers
    // do not implement the spec accordingly.
    node.setAttribute("rel", "noopener noreferrer")
    node.removeAttribute(TEMPORARY_ATTRIBUTE)
  }
})

const sanitizeString = (html: string): string => {
  const sanitizationOptions = {
    // Default to permit HTML, SVG and MathML, this limits to HTML only
    USE_PROFILES: { html: true },
    // glue elements like style, script or others to document.body and prevent unintuitive browser behavior in several edge-cases
    FORCE_BODY: true,
  }
  return DOMPurify.sanitize(html, sanitizationOptions)
}

/**
 * HTML code to insert into the page.
 */
export default function Html({
  element,
  width,
}: Readonly<HtmlProps>): ReactElement {
  const { body } = element
  const [sanitizedHtml, setSanitizedHtml] = useState(sanitizeString(body))
  const htmlRef = useRef<HTMLDivElement | null>(null)

  useEffect(() => {
    if (sanitizeString(body) !== sanitizedHtml) {
      setSanitizedHtml(sanitizeString(body))
    }
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [body])

  useEffect(() => {
    if (
      htmlRef.current?.clientHeight === 0 &&
      htmlRef.current.parentElement?.childElementCount === 1
    ) {
      // div has no rendered content - hide to avoid unnecessary spacing
      htmlRef.current.parentElement.classList.add("stHtml-empty")
    }
  })

  return (
    <>
      {sanitizedHtml && (
        <div
          className="stHtml"
          data-testid="stHtml"
          ref={htmlRef}
          style={{ width }}
          dangerouslySetInnerHTML={{ __html: sanitizedHtml }}
        />
      )}
    </>
  )
}


================================================
File: /frontend/lib/src/components/elements/Html/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Html"


================================================
File: /frontend/lib/src/components/elements/IFrame/IFrame.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import {
  DEFAULT_IFRAME_FEATURE_POLICY,
  DEFAULT_IFRAME_SANDBOX_POLICY,
} from "@streamlit/lib/src/util/IFrameUtil"
import { IFrame as IFrameProto } from "@streamlit/lib/src/proto"

import IFrame, { IFrameProps } from "./IFrame"

const getProps = (elementProps: Partial<IFrameProto> = {}): IFrameProps => ({
  element: IFrameProto.create({
    ...elementProps,
  }),
  width: 100,
})

describe("st.iframe", () => {
  it("should render an iframe", () => {
    const props = getProps({})
    render(<IFrame {...props} />)
    const iframeElement = screen.getByTestId("stIFrame")
    expect(iframeElement).toBeInTheDocument()
    expect(iframeElement).toHaveClass("stIFrame")
  })

  it("should set iframe height", () => {
    const props = getProps({
      height: 400,
    })
    render(<IFrame {...props} />)
    expect(screen.getByTestId("stIFrame")).toHaveAttribute("height", "400")
  })

  describe("Render iframe with `src` parameter", () => {
    const props = getProps({
      src: "foo",
      srcdoc: "bar",
    })

    it("should set `srcDoc` to undefined if src is defined", () => {
      render(<IFrame {...props} />)
      expect(screen.getByTestId("stIFrame")).not.toHaveAttribute("srcdoc")
    })

    it("should set `src`", () => {
      render(<IFrame {...props} />)
      expect(screen.getByTestId("stIFrame")).toHaveAttribute("src", "foo")
    })

    it("should use our default feature policy", () => {
      render(<IFrame {...props} />)
      expect(screen.getByTestId("stIFrame")).toHaveAttribute(
        "allow",
        DEFAULT_IFRAME_FEATURE_POLICY
      )
    })

    it("should use our default sandbox policy", () => {
      render(<IFrame {...props} />)
      expect(screen.getByTestId("stIFrame")).toHaveAttribute(
        "sandbox",
        DEFAULT_IFRAME_SANDBOX_POLICY
      )
    })
  })

  describe("Render iframe with `srcDoc` parameter", () => {
    const props = getProps({
      srcdoc: "bar",
    })

    it("should set `srcDoc`", () => {
      render(<IFrame {...props} />)
      expect(screen.getByTestId("stIFrame")).toHaveAttribute("srcdoc", "bar")
    })

    it("should use our default feature policy", () => {
      render(<IFrame {...props} />)
      expect(screen.getByTestId("stIFrame")).toHaveAttribute(
        "allow",
        DEFAULT_IFRAME_FEATURE_POLICY
      )
    })

    it("should use our default sandbox policy", () => {
      render(<IFrame {...props} />)
      expect(screen.getByTestId("stIFrame")).toHaveAttribute(
        "sandbox",
        DEFAULT_IFRAME_SANDBOX_POLICY
      )
    })
  })

  describe("Render iframe with specified width", () => {
    const props = getProps({
      hasWidth: true,
      width: 200,
    })
    it("should set element width", () => {
      render(<IFrame {...props} />)
      expect(screen.getByTestId("stIFrame")).toHaveAttribute("width", "200")
    })

    it("should set app width", () => {
      const props = getProps({})
      render(<IFrame {...props} />)
      expect(screen.getByTestId("stIFrame")).toHaveAttribute("width", "100")
    })
  })

  describe("Render iframe with scrolling", () => {
    it("should set scrolling to auto", () => {
      const props = getProps({
        scrolling: true,
      })
      render(<IFrame {...props} />)
      expect(screen.getByTestId("stIFrame")).toHaveAttribute(
        "scrolling",
        "auto"
      )
      expect(screen.getByTestId("stIFrame")).not.toHaveStyle(
        "overflow: hidden"
      )
    })

    it("should set `overflow` to hidden", () => {
      const props = getProps({})
      render(<IFrame {...props} />)
      expect(screen.getByTestId("stIFrame")).toHaveStyle("overflow: hidden")
      expect(screen.getByTestId("stIFrame")).toHaveAttribute("scrolling", "no")
    })
  })
})


================================================
File: /frontend/lib/src/components/elements/IFrame/IFrame.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import React, { ReactElement } from "react"

import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"
import { IFrame as IFrameProto } from "@streamlit/lib/src/proto"
import {
  DEFAULT_IFRAME_FEATURE_POLICY,
  DEFAULT_IFRAME_SANDBOX_POLICY,
} from "@streamlit/lib/src/util/IFrameUtil"

import { StyledIframe } from "./styled-components"

export interface IFrameProps {
  element: IFrameProto
  width: number
}

export default function IFrame({
  element,
  width: propWidth,
}: Readonly<IFrameProps>): ReactElement {
  const width = element.hasWidth ? element.width : propWidth

  // Either 'src' or 'srcDoc' will be set in our element. If 'src'
  // is set, we're loading a remote URL in the iframe.
  const src = getNonEmptyString(element.src)
  const srcDoc = notNullOrUndefined(src)
    ? undefined
    : getNonEmptyString(element.srcdoc)

  return (
    <StyledIframe
      className="stIFrame"
      data-testid="stIFrame"
      allow={DEFAULT_IFRAME_FEATURE_POLICY}
      disableScrolling={!element.scrolling}
      src={src}
      srcDoc={srcDoc}
      width={width}
      height={element.height}
      scrolling={element.scrolling ? "auto" : "no"}
      sandbox={DEFAULT_IFRAME_SANDBOX_POLICY}
      title="st.iframe"
    />
  )
}

/**
 * Return a string property from an element. If the string is
 * null or empty, return undefined instead.
 */
function getNonEmptyString(
  value: string | null | undefined
): string | undefined {
  return isNullOrUndefined(value) || value === "" ? undefined : value
}


================================================
File: /frontend/lib/src/components/elements/IFrame/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./IFrame"


================================================
File: /frontend/lib/src/components/elements/IFrame/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

interface StyledIframeProps {
  disableScrolling: boolean
}

export const StyledIframe = styled.iframe<StyledIframeProps>(
  ({ theme, disableScrolling }) => ({
    colorScheme: "normal",
    border: "none",
    padding: theme.spacing.none,
    margin: theme.spacing.none,
    overflow: disableScrolling ? "hidden" : undefined,
  })
)


================================================
File: /frontend/lib/src/components/elements/ImageList/ImageList.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { ImageList as ImageListProto } from "@streamlit/lib/src/proto"
import { mockEndpoints } from "@streamlit/lib/src/mocks/mocks"

import ImageList, { ImageListProps } from "./ImageList"

describe("ImageList Element", () => {
  const buildMediaURL = vi.fn().mockReturnValue("https://mock.media.url")

  const getProps = (
    elementProps: Partial<ImageListProto> = {}
  ): ImageListProps => ({
    element: ImageListProto.create({
      imgs: [
        { caption: "a", url: "/media/mockImage1.jpeg" },
        { caption: "b", url: "/media/mockImage2.jpeg" },
      ],
      width: -1,
      ...elementProps,
    }),
    endpoints: mockEndpoints({ buildMediaURL: buildMediaURL }),
    width: 0,
  })

  it("renders without crashing", () => {
    const props = getProps()
    render(<ImageList {...props} />)
    expect(screen.getAllByRole("img")).toHaveLength(2)
  })

  it("renders explicit width for each image", () => {
    const props = getProps({ width: 300 })
    render(<ImageList {...props} />)

    const images = screen.getAllByRole("img")
    expect(images).toHaveLength(2)
    images.forEach(image => {
      expect(image).toHaveStyle("width: 300px")
    })
  })

  it("creates its `src` attribute using buildMediaURL", () => {
    const props = getProps()
    render(<ImageList {...props} />)
    const images = screen.getAllByRole("img")
    expect(images).toHaveLength(2)

    expect(buildMediaURL).toHaveBeenNthCalledWith(1, "/media/mockImage1.jpeg")
    expect(buildMediaURL).toHaveBeenNthCalledWith(2, "/media/mockImage2.jpeg")

    images.forEach(image => {
      expect(image).toHaveAttribute("src", "https://mock.media.url")
    })
  })

  it("has a caption", () => {
    const props = getProps()
    render(<ImageList {...props} />)

    const captions = screen.getAllByTestId("stImageCaption")
    expect(captions).toHaveLength(2)
    expect(captions[0]).toHaveTextContent("a")
    expect(captions[1]).toHaveTextContent("b")
  })

  it("renders explicit width for each caption", () => {
    const props = getProps({ width: 300 })
    render(<ImageList {...props} />)

    const captions = screen.getAllByTestId("stImageCaption")
    expect(captions).toHaveLength(2)
    captions.forEach(caption => {
      expect(caption).toHaveStyle("width: 300px")
    })
  })
})


================================================
File: /frontend/lib/src/components/elements/ImageList/ImageList.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { CSSProperties, ReactElement } from "react"

import {
  ImageList as ImageListProto,
  Image as ImageProto,
} from "@streamlit/lib/src/proto"
import { StreamlitEndpoints } from "@streamlit/lib/src/StreamlitEndpoints"
import Toolbar, {
  StyledToolbarElementContainer,
} from "@streamlit/lib/src/components/shared/Toolbar"
import { ElementFullscreenContext } from "@streamlit/lib/src/components/shared/ElementFullscreen/ElementFullscreenContext"
import { useRequiredContext } from "@streamlit/lib/src/hooks/useRequiredContext"
import { withFullScreenWrapper } from "@streamlit/lib/src/components/shared/FullScreenWrapper"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"

import {
  StyledCaption,
  StyledImageContainer,
  StyledImageList,
} from "./styled-components"

export interface ImageListProps {
  endpoints: StreamlitEndpoints
  width: number
  element: ImageListProto
  disableFullscreenMode?: boolean
}

/**
 * @see WidthBehavior on the Backend
 * @see the Image.proto file
 */
enum WidthBehavior {
  OriginalWidth = -1,
  /** @deprecated */
  ColumnWidth = -2,
  /** @deprecated */
  AutoWidth = -3,
  MinImageOrContainer = -4,
  MaxImageOrContainer = -5,
}

/**
 * Functional element for a horizontal list of images.
 */
function ImageList({
  element,
  width,
  endpoints,
  disableFullscreenMode,
}: Readonly<ImageListProps>): ReactElement {
  const {
    expanded: isFullScreen,
    width: fullScreenWidth,
    height,
    expand,
    collapse,
  } = useRequiredContext(ElementFullscreenContext)

  // The width of the element is the width of the container, not necessarily the image.
  const elementWidth: number = isFullScreen ? fullScreenWidth : width
  // The width field in the proto sets the image width, but has special
  // cases the values in the WidthBehavior enum.
  let imageWidth: number | undefined
  const protoWidth = element.width

  if (
    [
      WidthBehavior.OriginalWidth,
      WidthBehavior.AutoWidth,
      WidthBehavior.MinImageOrContainer,
    ].includes(protoWidth)
  ) {
    // Use the original image width.
    imageWidth = undefined
  } else if (
    [WidthBehavior.ColumnWidth, WidthBehavior.MaxImageOrContainer].includes(
      protoWidth
    )
  ) {
    // Use the full element width (which handles the full screen case)
    imageWidth = elementWidth
  } else if (protoWidth > 0) {
    // Set the image width explicitly.
    imageWidth = protoWidth
  } else {
    throw Error(`Invalid image width: ${protoWidth}`)
  }

  const imgStyle: CSSProperties = {}

  if (height && isFullScreen) {
    imgStyle.maxHeight = height
    imgStyle.objectFit = "contain"
  } else {
    imgStyle.width = imageWidth
    // Cap the image width, so it doesn't exceed its parent container width
    imgStyle.maxWidth = "100%"
  }

  return (
    <StyledToolbarElementContainer
      width={elementWidth}
      height={height}
      useContainerWidth={isFullScreen}
      topCentered
    >
      <Toolbar
        target={StyledToolbarElementContainer}
        isFullScreen={isFullScreen}
        onExpand={expand}
        onCollapse={collapse}
        disableFullscreenMode={disableFullscreenMode}
      ></Toolbar>
      <StyledImageList className="stImage" data-testid="stImage">
        {element.imgs.map((iimage, idx): ReactElement => {
          const image = iimage as ImageProto
          return (
            <StyledImageContainer data-testid="stImageContainer" key={idx}>
              <img
                style={imgStyle}
                src={endpoints.buildMediaURL(image.url)}
                alt={idx.toString()}
              />
              {image.caption && (
                <StyledCaption data-testid="stImageCaption" style={imgStyle}>
                  <StreamlitMarkdown
                    source={image.caption}
                    allowHTML={false}
                    isCaption
                    // This is technically not a label but we want the same restrictions
                    // as for labels (e.g. no Markdown tables or horizontal rule).
                    isLabel
                  />
                </StyledCaption>
              )}
            </StyledImageContainer>
          )
        })}
      </StyledImageList>
    </StyledToolbarElementContainer>
  )
}

export default withFullScreenWrapper(ImageList)


================================================
File: /frontend/lib/src/components/elements/ImageList/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./ImageList"


================================================
File: /frontend/lib/src/components/elements/ImageList/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledImageList = styled.div(({ theme }) => ({
  display: "flex",
  flexDirection: "row",
  flexWrap: "wrap",
  // Not supported in Safari, but at least it's not a regression for those users:
  rowGap: theme.spacing.lg,
  maxWidth: "100%",
  width: "fit-content",
}))

export const StyledImageContainer = styled.div(({ theme }) => ({
  display: "flex",
  flexDirection: "column",
  alignItems: "stretch",
  width: "auto",
  flexGrow: 0,

  ">img": {
    borderRadius: theme.radii.default,
  },
}))

export const StyledCaption = styled.div(({ theme }) => ({
  textAlign: "center",
  marginTop: theme.spacing.xs,
  wordWrap: "break-word",
  padding: theme.spacing.threeXS,
}))


================================================
File: /frontend/lib/src/components/elements/Json/Json.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { Json as JsonProto } from "@streamlit/lib/src/proto"
import * as getColors from "@streamlit/lib/src/theme/getColors"

import Json, { JsonProps } from "./Json"

const getProps = (elementProps: Partial<JsonProto> = {}): JsonProps => ({
  element: JsonProto.create({
    body:
      '{ "proper": [1,2,3],' +
      '  "nested": { "thing1": "cat", "thing2": "hat" },' +
      '  "json": "structure" }',
    ...elementProps,
  }),
  width: 100,
})

describe("JSON element", () => {
  afterEach(() => {
    vi.restoreAllMocks()
  })

  it("renders json as expected", () => {
    const props = getProps()
    render(<Json {...props} />)
    const jsonElement = screen.getByTestId("stJson")
    expect(jsonElement).toBeInTheDocument()
    expect(jsonElement).toHaveClass("stJson")
  })

  it("should show an error with invalid JSON", () => {
    const props = getProps({ body: "invalid JSON" })
    render(<Json {...props} />)
    expect(screen.getByTestId("stAlertContainer")).toBeInTheDocument()
  })

  it("renders json with NaN and infinity values", () => {
    const props = getProps({
      body: `{
      "numbers":[ -1e27, NaN, Infinity, -Infinity, 2.2822022,-2.2702775],
    }`,
    })
    render(<Json {...props} />)
    expect(screen.getByTestId("stJson")).toBeInTheDocument()
  })

  describe("getJsonTheme", () => {
    it("picks a reasonable theme when the background is light", () => {
      // <Json> uses `hasLightBackgroundColor` to test whether our theme
      // is "light" or "dark". Mock the return value for the test.
      vi.spyOn(getColors, "hasLightBackgroundColor").mockReturnValue(true)

      render(<Json {...getProps()} />)
      // checks resulting json coloration based on theme passed
      expect(screen.getByText("}")).toHaveStyle("color: rgb(0, 43, 54)")
    })

    it("picks a reasonable theme when the background is dark", () => {
      // <Json> uses `hasLightBackgroundColor` to test whether our theme
      // is "light" or "dark". Mock the return value for the test.
      vi.spyOn(getColors, "hasLightBackgroundColor").mockReturnValue(false)
      render(<Json {...getProps()} />)
      expect(screen.getByText("}")).toHaveStyle("color: rgb(249, 248, 245)")
    })
  })
})


================================================
File: /frontend/lib/src/components/elements/Json/Json.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, useRef } from "react"

import JSON5 from "json5"
import Clipboard from "clipboard"
import ReactJson from "react-json-view"
import { useTheme } from "@emotion/react"

import ErrorElement from "@streamlit/lib/src/components/shared/ErrorElement"
import { Json as JsonProto } from "@streamlit/lib/src/proto"
import {
  EmotionTheme,
  hasLightBackgroundColor,
} from "@streamlit/lib/src/theme"
import { ensureError } from "@streamlit/lib/src/util/ErrorHandling"

import { StyledJsonWrapper } from "./styled-components"
export interface JsonProps {
  width: number
  element: JsonProto
}

/**
 * Functional element representing JSON structured text.
 */
export default function Json({
  width,
  element,
}: Readonly<JsonProps>): ReactElement {
  const theme: EmotionTheme = useTheme()

  const elementRef = useRef<HTMLDivElement>(null)

  let bodyObject
  try {
    bodyObject = JSON.parse(element.body)
  } catch (e) {
    const error = ensureError(e)
    try {
      bodyObject = JSON5.parse(element.body)
    } catch (json5Error) {
      // If content fails to parse as Json, rebuild the error message
      // to show where the problem occurred.
      const pos = parseInt(error.message.replace(/[^0-9]/g, ""), 10)
      error.message += `\n${element.body.substring(0, pos + 1)}  here`
      return <ErrorElement name={"Json Parse Error"} message={error.message} />
    }
  }

  // Try to pick a reasonable ReactJson theme based on whether the streamlit
  // theme's background is light or dark.
  const jsonTheme = hasLightBackgroundColor(theme) ? "rjv-default" : "monokai"

  const handleCopy = (copy: any): void => {
    // we use ClipboardJS to do the copying, because it allows
    // us to specify a container element. This is necessary because
    // otherwise copying doesn't work in dialogs.
    Clipboard.copy(JSON.stringify(copy.src), {
      container: elementRef.current ?? undefined,
    })
  }

  return (
    <StyledJsonWrapper
      className="stJson"
      data-testid="stJson"
      width={width}
      ref={elementRef}
    >
      <ReactJson
        src={bodyObject}
        collapsed={element.maxExpandDepth ?? !element.expanded}
        displayDataTypes={false}
        displayObjectSize={false}
        name={false}
        theme={jsonTheme}
        enableClipboard={handleCopy}
        style={{
          fontFamily: theme.genericFonts.codeFont,
          fontSize: theme.fontSizes.sm,
          backgroundColor: theme.colors.bgColor,
          whiteSpace: "pre-wrap", // preserve whitespace
        }}
      />
    </StyledJsonWrapper>
  )
}


================================================
File: /frontend/lib/src/components/elements/Json/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Json"


================================================
File: /frontend/lib/src/components/elements/Json/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

interface StyledJsonWrapperProps {
  width: number
}

export const StyledJsonWrapper = styled.div<StyledJsonWrapperProps>(
  ({ theme, width }) => ({
    width: width,
    overflowY: "auto",
    ".react-json-view .copy-icon svg": {
      // Make the copy icon responsive to the root font size.
      fontSize: `1em !important`,
      marginRight: `${theme.spacing.threeXS} !important`,
      verticalAlign: "middle !important",
    },
  })
)


================================================
File: /frontend/lib/src/components/elements/LinkButton/BaseLinkButton.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import {
  BaseButtonKind,
  BaseButtonSize,
  BaseLinkButtonProps as BaseLinkButtonPropsT,
  StyledPrimaryLinkButton,
  StyledSecondaryLinkButton,
  StyledTertiaryLinkButton,
} from "./styled-components"

// We define separate BaseLinkButton, and not use BaseButton for st.link_button,
// because link behavior requires tag <a> instead of <button>.
function BaseLinkButton({
  kind,
  size,
  disabled,
  fluidWidth,
  children,
  autoFocus,
  href,
  rel,
  target,
  onClick,
}: Readonly<BaseLinkButtonPropsT>): ReactElement {
  let ComponentType = StyledPrimaryLinkButton

  if (kind === BaseButtonKind.SECONDARY) {
    ComponentType = StyledSecondaryLinkButton
  } else if (kind === BaseButtonKind.TERTIARY) {
    ComponentType = StyledTertiaryLinkButton
  }

  return (
    <ComponentType
      kind={kind}
      size={size || BaseButtonSize.MEDIUM}
      fluidWidth={fluidWidth || false}
      disabled={disabled || false}
      autoFocus={autoFocus || false}
      href={href}
      target={target}
      rel={rel}
      onClick={onClick}
      tabIndex={disabled ? -1 : 0}
      data-testid={`stBaseLinkButton-${kind}`}
    >
      {children}
    </ComponentType>
  )
}
export type BaseButtonProps = BaseLinkButtonPropsT
export { BaseButtonKind, BaseButtonSize }
export default BaseLinkButton


================================================
File: /frontend/lib/src/components/elements/LinkButton/LinkButton.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { LinkButton as LinkButtonProto } from "@streamlit/lib/src/proto"

import LinkButton, { Props } from "./LinkButton"

const getProps = (
  elementProps: Partial<LinkButtonProto> = {},
  widgetProps: Partial<Props> = {}
): Props => ({
  element: LinkButtonProto.create({
    label: "Label",
    url: "https://streamlit.io",
    ...elementProps,
  }),
  width: 250,
  disabled: false,
  ...widgetProps,
})

describe("LinkButton widget", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<LinkButton {...props} />)

    const linkButton = screen.getByRole("link")
    expect(linkButton).toBeInTheDocument()
  })

  it("has correct className and style", () => {
    const props = getProps()
    render(<LinkButton {...props} />)

    const linkButton = screen.getByTestId("stLinkButton")

    expect(linkButton).toHaveClass("stLinkButton")
    expect(linkButton).toHaveStyle(`width: ${props.width}px`)
  })

  it("renders a label within the button", () => {
    const props = getProps()
    render(<LinkButton {...props} />)

    const linkButton = screen.getByRole("link", {
      name: `${props.element.label}`,
    })

    expect(linkButton).toBeInTheDocument()
  })

  describe("wrapped BaseLinkButton", () => {
    const LINK_BUTTON_TYPES = ["primary", "secondary", "tertiary"]

    LINK_BUTTON_TYPES.forEach(type => {
      it(`renders ${type} link button correctly`, () => {
        render(<LinkButton {...getProps({ type })} />)

        const linkButton = screen.getByTestId(`stBaseLinkButton-${type}`)
        expect(linkButton).toBeInTheDocument()
      })

      it(`renders disabled ${type} correctly`, () => {
        render(<LinkButton {...getProps({ type }, { disabled: true })} />)

        const linkButton = screen.getByRole("link")
        expect(linkButton).toHaveAttribute("disabled")
      })
    })

    it("does not use container width by default", () => {
      const props = getProps()
      render(<LinkButton {...props}>Hello</LinkButton>)

      const linkButton = screen.getByRole("link")
      expect(linkButton).toHaveStyle("width: auto")
    })

    it("passes useContainerWidth property with help correctly", () => {
      render(
        <LinkButton
          {...getProps({ useContainerWidth: true, help: "mockHelpText" })}
        >
          Hello
        </LinkButton>
      )

      const linkButton = screen.getByRole("link")
      expect(linkButton).toHaveStyle(`width: ${250}px`)
    })

    it("passes useContainerWidth property without help correctly", () => {
      render(
        <LinkButton {...getProps({ useContainerWidth: true })}>
          Hello
        </LinkButton>
      )

      const linkButton = screen.getByRole("link")
      expect(linkButton).toHaveStyle("width: 100%")
    })
  })
})


================================================
File: /frontend/lib/src/components/elements/LinkButton/LinkButton.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { MouseEvent, ReactElement } from "react"

import { LinkButton as LinkButtonProto } from "@streamlit/lib/src/proto"
import {
  BaseButtonKind,
  BaseButtonSize,
  BaseButtonTooltip,
  DynamicButtonLabel,
} from "@streamlit/lib/src/components/shared/BaseButton"

import BaseLinkButton from "./BaseLinkButton"

export interface Props {
  disabled: boolean
  element: LinkButtonProto
  width: number
}

function LinkButton(props: Readonly<Props>): ReactElement {
  const { disabled, element, width } = props
  const style = { width }

  let kind = BaseButtonKind.SECONDARY
  if (element.type === "primary") {
    kind = BaseButtonKind.PRIMARY
  } else if (element.type === "tertiary") {
    kind = BaseButtonKind.TERTIARY
  }

  // When useContainerWidth true & has help tooltip,
  // we need to pass the container width down to the button
  const fluidWidth = element.help ? width : true

  const handleClick = (e: MouseEvent<HTMLAnchorElement>): void => {
    // Prevent the link from being followed if the button is disabled.
    if (props.disabled) {
      e.preventDefault()
    }
  }

  return (
    <div className="stLinkButton" data-testid="stLinkButton" style={style}>
      <BaseButtonTooltip help={element.help}>
        {/* We use separate BaseLinkButton instead of BaseButton here, because
        link behavior requires tag <a> instead of <button>.*/}
        <BaseLinkButton
          kind={kind}
          size={BaseButtonSize.SMALL}
          disabled={disabled}
          onClick={handleClick}
          fluidWidth={element.useContainerWidth ? fluidWidth : false}
          href={element.url}
          target="_blank"
          rel="noreferrer"
          aria-disabled={disabled}
        >
          <DynamicButtonLabel icon={element.icon} label={element.label} />
        </BaseLinkButton>
      </BaseButtonTooltip>
    </div>
  )
}

export default LinkButton


================================================
File: /frontend/lib/src/components/elements/LinkButton/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./LinkButton"


================================================
File: /frontend/lib/src/components/elements/LinkButton/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { MouseEvent, ReactNode } from "react"

import styled, { CSSObject } from "@emotion/styled"
import { darken, transparentize } from "color2k"

import {
  BaseButtonKind,
  BaseButtonSize,
} from "@streamlit/lib/src/components/shared/BaseButton/styled-components"
import { EmotionTheme } from "@streamlit/lib/src/theme"

export { BaseButtonKind, BaseButtonSize }

export interface BaseLinkButtonProps {
  kind:
    | BaseButtonKind.PRIMARY
    | BaseButtonKind.SECONDARY
    | BaseButtonKind.TERTIARY
  size?: BaseButtonSize
  disabled?: boolean
  // If true or number, the button should take up container's full width
  fluidWidth?: boolean | number
  children: ReactNode
  autoFocus?: boolean
  href: string
  target: string
  rel: string
  onClick: (event: MouseEvent<HTMLAnchorElement>) => any
}

type RequiredBaseLinkButtonProps = Required<BaseLinkButtonProps>

function getSizeStyle(size: BaseButtonSize, theme: EmotionTheme): CSSObject {
  switch (size) {
    case BaseButtonSize.XSMALL:
      return {
        padding: `${theme.spacing.twoXS} ${theme.spacing.sm}`,
        fontSize: theme.fontSizes.sm,
      }
    case BaseButtonSize.SMALL:
      return {
        padding: `${theme.spacing.twoXS} ${theme.spacing.md}`,
      }
    case BaseButtonSize.LARGE:
      return {
        padding: `${theme.spacing.md} ${theme.spacing.md}`,
      }
    default:
      return {
        padding: `${theme.spacing.xs} ${theme.spacing.md}`,
      }
  }
}

export const StyledBaseLinkButton = styled.a<RequiredBaseLinkButtonProps>(
  ({ fluidWidth, size, theme }) => {
    const buttonWidth =
      typeof fluidWidth == "number" ? `${fluidWidth}px` : "100%"

    return {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontWeight: theme.fontWeights.normal,
      padding: `${theme.spacing.xs} ${theme.spacing.md}`,
      borderRadius: theme.radii.default,
      minHeight: theme.sizes.minElementHeight,
      margin: 0,
      lineHeight: theme.lineHeights.base,
      color: theme.colors.primary,
      textDecoration: "none",
      width: fluidWidth ? buttonWidth : "auto",
      userSelect: "none",
      "&:visited": {
        color: theme.colors.primary,
      },
      "&:focus": {
        outline: "none",
      },
      "&:focus-visible": {
        boxShadow: `0 0 0 0.2rem ${transparentize(theme.colors.primary, 0.5)}`,
      },
      "&:hover": {
        textDecoration: "none",
      },
      "&:active": {
        textDecoration: "none",
      },
      ...getSizeStyle(size, theme),
    }
  }
)

export const StyledPrimaryLinkButton = styled(
  StyledBaseLinkButton
)<RequiredBaseLinkButtonProps>(({ theme }) => ({
  backgroundColor: theme.colors.primary,
  color: theme.colors.white,
  border: `${theme.sizes.borderWidth} solid ${theme.colors.primary}`,
  "&:hover": {
    backgroundColor: darken(theme.colors.primary, 0.05),
    color: theme.colors.white,
  },
  "&:active": {
    backgroundColor: "transparent",
    color: theme.colors.primary,
  },
  "&:visited:not(:active)": {
    color: theme.colors.white,
  },
  "&[disabled], &[disabled]:hover, &[disabled]:active, &[disabled]:visited": {
    borderColor: theme.colors.borderColor,
    backgroundColor: theme.colors.transparent,
    color: theme.colors.fadedText40,
    cursor: "not-allowed",
  },
}))

export const StyledSecondaryLinkButton = styled(
  StyledBaseLinkButton
)<RequiredBaseLinkButtonProps>(({ theme }) => ({
  backgroundColor: theme.colors.lightenedBg05,
  color: theme.colors.bodyText,
  border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
  "&:visited": {
    color: theme.colors.bodyText,
  },
  "&:hover": {
    borderColor: theme.colors.primary,
    color: theme.colors.primary,
  },
  "&:active": {
    color: theme.colors.white,
    borderColor: theme.colors.primary,
    backgroundColor: theme.colors.primary,
  },
  "&:focus:not(:active)": {
    borderColor: theme.colors.primary,
    color: theme.colors.primary,
  },
  "&[disabled], &[disabled]:hover, &[disabled]:active": {
    borderColor: theme.colors.borderColor,
    backgroundColor: theme.colors.transparent,
    color: theme.colors.fadedText40,
    cursor: "not-allowed",
  },
}))

export const StyledTertiaryLinkButton = styled(
  StyledBaseLinkButton
)<RequiredBaseLinkButtonProps>(({ theme }) => ({
  padding: theme.spacing.none,
  backgroundColor: theme.colors.transparent,
  color: theme.colors.bodyText,
  border: "none",

  "&:visited": {
    color: theme.colors.bodyText,
  },
  "&:hover": {
    color: theme.colors.primary,
  },
  "&:active": {
    color: theme.colors.primary,
  },
  "&:focus": {
    outline: "none",
  },
  "&:focus-visible": {
    color: theme.colors.primary,
    boxShadow: `0 0 0 0.2rem ${transparentize(theme.colors.primary, 0.5)}`,
  },
  "&[disabled], &[disabled]:hover, &[disabled]:active": {
    backgroundColor: theme.colors.transparent,
    color: theme.colors.fadedText40,
    cursor: "not-allowed",
  },
}))


================================================
File: /frontend/lib/src/components/elements/Markdown/Markdown.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { Markdown as MarkdownProto } from "@streamlit/lib/src/proto"

import Markdown, { MarkdownProps } from "./Markdown"

const getProps = (
  elementProps: Partial<MarkdownProps> = {}
): MarkdownProps => ({
  element: MarkdownProto.create({
    body:
      "Emphasis, aka italics, with *asterisks* or _underscores_." +
      "Combined emphasis with **asterisks and _underscores_**." +
      "[I'm an inline-style link with title](https://www.https://streamlit.io/ Streamlit)",
    allowHtml: false,
    ...elementProps,
  }),
  width: 100,
})

describe("Markdown element", () => {
  it("renders markdown as expected", () => {
    const props = getProps()
    render(<Markdown {...props} />)
    const markdown = screen.getByTestId("stMarkdown")
    expect(markdown).toBeInTheDocument()
    expect(markdown).toHaveClass("stMarkdown")
    expect(markdown).toHaveStyle("width: 100px")
  })
})

describe("Markdown element with help", () => {
  it("renders markdown with help tooltip as expected", async () => {
    const user = userEvent.setup()
    const props = getProps({ help: "help text" })
    render(<Markdown {...props} />)
    const tooltip = screen.getByTestId("stTooltipHoverTarget")
    expect(tooltip).toBeInTheDocument()
    await user.hover(tooltip)

    const helpText = await screen.findByText("help text")
    expect(helpText).toBeInTheDocument()
  })
})


================================================
File: /frontend/lib/src/components/elements/Markdown/Markdown.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"
import { Markdown as MarkdownProto } from "@streamlit/lib/src/proto"
import {
  InlineTooltipIcon,
  StyledLabelHelpWrapper,
} from "@streamlit/lib/src/components/shared/TooltipIcon"

export interface MarkdownProps {
  width: number
  help?: string
  element: MarkdownProto
}

/**
 * Functional element representing Markdown formatted text.
 */
export default function Markdown({
  width,
  element,
}: Readonly<MarkdownProps>): ReactElement {
  const styleProp = { width }

  return (
    <div className="stMarkdown" data-testid="stMarkdown" style={styleProp}>
      {element.help ? (
        <StyledLabelHelpWrapper
          isLatex={element.elementType === MarkdownProto.Type.LATEX}
        >
          <StreamlitMarkdown
            isCaption={element.isCaption}
            source={element.body}
            allowHTML={element.allowHtml}
          />
          <InlineTooltipIcon
            content={element.help}
            isLatex={element.elementType === MarkdownProto.Type.LATEX}
          ></InlineTooltipIcon>
        </StyledLabelHelpWrapper>
      ) : (
        <StreamlitMarkdown
          isCaption={element.isCaption}
          source={element.body}
          allowHTML={element.allowHtml}
        />
      )}
    </div>
  )
}


================================================
File: /frontend/lib/src/components/elements/Markdown/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Markdown"


================================================
File: /frontend/lib/src/components/elements/Metric/Metric.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { mockTheme } from "@streamlit/lib/src/mocks/mockTheme"
import {
  LabelVisibilityMessage as LabelVisibilityMessageProto,
  Metric as MetricProto,
} from "@streamlit/lib/src/proto"

import Metric, { MetricProps } from "./Metric"

const getProps = (elementProps: Partial<MetricProto> = {}): MetricProps => ({
  element: MetricProto.create({
    color: MetricProto.MetricColor.RED,
    direction: MetricProto.MetricDirection.UP,
    delta: "test",
    ...elementProps,
  }),
})

describe("Metric element", () => {
  it("renders metric as expected", () => {
    const props = getProps()
    render(<Metric {...props} />)
    const metricElement = screen.getByTestId("stMetric")
    expect(metricElement).toBeInTheDocument()
    expect(metricElement).toHaveClass("stMetric")
  })

  it("renders metric label as expected", () => {
    const props = getProps()
    render(<Metric {...props} />)

    expect(screen.getByTestId("stMetricLabel")).toHaveTextContent(
      props.element.label
    )
  })

  it("pass labelVisibility prop to StyledMetricLabelText correctly when hidden", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.HIDDEN,
      },
    })
    render(<Metric {...props} />)
    expect(screen.getByTestId("stMetricLabel")).toHaveAttribute(
      "visibility",
      String(LabelVisibilityMessageProto.LabelVisibilityOptions.HIDDEN)
    )
  })

  it("pass labelVisibility prop to StyledMetricLabelText correctly when collapsed", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.COLLAPSED,
      },
    })
    render(<Metric {...props} />)
    expect(screen.getByTestId("stMetricLabel")).toHaveAttribute(
      "visibility",
      String(LabelVisibilityMessageProto.LabelVisibilityOptions.COLLAPSED)
    )
  })

  it("renders direction icon based on props - red/up", () => {
    const props = getProps()
    render(<Metric {...props} />)
    expect(screen.getByTestId("stMetricDeltaIcon-Up")).toBeInTheDocument()
  })

  it("renders direction icon based on props - green/down", () => {
    const props = getProps({
      color: MetricProto.MetricColor.GREEN,
      direction: MetricProto.MetricDirection.DOWN,
    })
    render(<Metric {...props} />)
    expect(screen.getByTestId("stMetricDeltaIcon-Down")).toBeInTheDocument()
  })

  it("renders no text and icon based on props", () => {
    const props = getProps({
      color: MetricProto.MetricColor.GRAY,
      direction: MetricProto.MetricDirection.NONE,
      delta: "",
    })
    render(<Metric {...props} />)
    expect(screen.queryByTestId("stMetricDeltaIcon")).not.toBeInTheDocument()
    expect(screen.queryByTestId("stMetricDelta")).not.toBeInTheDocument()
  })

  it("renders correct gray based on props", () => {
    const props = getProps({
      color: MetricProto.MetricColor.GRAY,
      direction: MetricProto.MetricDirection.NONE,
    })
    render(<Metric {...props} />)
    expect(screen.getByTestId("stMetricDelta")).toHaveStyle(
      "color: rgba(49, 51, 63, 0.6);"
    )
  })

  it("renders correct green based on props", () => {
    const props = getProps({
      color: MetricProto.MetricColor.GREEN,
      direction: MetricProto.MetricDirection.DOWN,
    })
    render(<Metric {...props} />)
    expect(screen.getByTestId("stMetricDelta")).toHaveStyle(
      "color: rgb(9, 171, 59);"
    )
  })

  it("renders correct red based on props", () => {
    const props = getProps()
    render(<Metric {...props} />)
    expect(screen.getByTestId("stMetricDelta")).toHaveStyle(
      "color: rgb(255, 43, 43);"
    )
  })

  it("should render TooltipIcon if help text provided", () => {
    const props = getProps({ help: "help text" })
    render(<Metric {...props} />)
    const tooltip = screen.getByTestId("stTooltipIcon")
    expect(tooltip).toBeInTheDocument()
  })

  it("renders without border by default", () => {
    const props = getProps()
    render(<Metric {...props} />)
    expect(screen.getByTestId("stMetric")).toHaveStyle("border: none;")
  })

  it("renders with border if passed", () => {
    const props = getProps({ showBorder: true })
    render(<Metric {...props} />)

    const expectedBorder = `${mockTheme.emotion.sizes.borderWidth} solid ${mockTheme.emotion.colors.borderColor}`
    expect(screen.getByTestId("stMetric")).toHaveStyle(
      `border: ${expectedBorder}`
    )
  })
})


================================================
File: /frontend/lib/src/components/elements/Metric/Metric.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { EmotionIcon } from "@emotion-icons/emotion-icon"
import { ArrowDownward, ArrowUpward } from "@emotion-icons/material-outlined"

import { Metric as MetricProto } from "@streamlit/lib/src/proto"
import { labelVisibilityProtoValueToEnum } from "@streamlit/lib/src/util/utils"
import Icon from "@streamlit/lib/src/components/shared/Icon"
import { StyledWidgetLabelHelpInline } from "@streamlit/lib/src/components/widgets/BaseWidget"
import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"

import {
  StyledMetricContainer,
  StyledMetricDeltaText,
  StyledMetricLabelText,
  StyledMetricValueText,
  StyledTruncateText,
} from "./styled-components"

export interface MetricProps {
  element: MetricProto
}

export default function Metric({
  element,
}: Readonly<MetricProps>): ReactElement {
  const { MetricDirection } = MetricProto
  const {
    body,
    label,
    delta,
    direction,
    color,
    labelVisibility,
    help,
    showBorder,
  } = element

  let metricDirection: EmotionIcon | null = null

  switch (direction) {
    case MetricDirection.DOWN:
      metricDirection = ArrowDownward
      break
    case MetricDirection.UP:
      metricDirection = ArrowUpward
      break
  }

  const arrowMargin = "0 threeXS 0 0"
  const deltaExists = delta !== ""

  return (
    <StyledMetricContainer
      className="stMetric"
      data-testid="stMetric"
      showBorder={showBorder}
    >
      <StyledMetricLabelText
        data-testid="stMetricLabel"
        visibility={labelVisibilityProtoValueToEnum(labelVisibility?.value)}
      >
        <StyledTruncateText>
          <StreamlitMarkdown source={label} allowHTML={false} isLabel />
        </StyledTruncateText>
        {help && (
          <StyledWidgetLabelHelpInline>
            <TooltipIcon content={help} placement={Placement.TOP_RIGHT} />
          </StyledWidgetLabelHelpInline>
        )}
      </StyledMetricLabelText>
      <StyledMetricValueText data-testid="stMetricValue">
        <StyledTruncateText> {body} </StyledTruncateText>
      </StyledMetricValueText>
      {deltaExists && (
        <StyledMetricDeltaText data-testid="stMetricDelta" metricColor={color}>
          {metricDirection && (
            <Icon
              testid={
                metricDirection === ArrowUpward
                  ? "stMetricDeltaIcon-Up"
                  : "stMetricDeltaIcon-Down"
              }
              content={metricDirection}
              size="lg"
              margin={arrowMargin}
            />
          )}
          <StyledTruncateText> {delta} </StyledTruncateText>
        </StyledMetricDeltaText>
      )}
    </StyledMetricContainer>
  )
}


================================================
File: /frontend/lib/src/components/elements/Metric/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Metric"


================================================
File: /frontend/lib/src/components/elements/Metric/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

import { StyledWidgetLabel } from "@streamlit/lib/src/components/widgets/BaseWidget/styled-components"
import { Metric as MetricProto } from "@streamlit/lib/src/proto"
import { LabelVisibilityOptions } from "@streamlit/lib/src/util/utils"

export interface StyledMetricContainerProps {
  showBorder: boolean
}

export const StyledMetricContainer = styled.div<StyledMetricContainerProps>(
  ({ theme, showBorder }) => ({
    ...(showBorder && {
      border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
      borderRadius: theme.radii.default,
      padding: `calc(${theme.spacing.lg} - ${theme.sizes.borderWidth})`,
    }),
  })
)
export interface StyledMetricLabelTextProps {
  visibility?: LabelVisibilityOptions
}

export const StyledTruncateText = styled.div(({ theme }) => ({
  overflowWrap: "normal",
  textOverflow: "ellipsis",
  width: "100%",
  overflow: "hidden",
  whiteSpace: "nowrap",
  fontFamily: theme.genericFonts.bodyFont,
  lineHeight: "normal",
  verticalAlign: "middle",

  // Styles to truncate the text inside the StyledStreamlitMarkdown div.
  "& > div": {
    overflow: "hidden",

    "& > p": {
      textOverflow: "ellipsis",
      overflow: "hidden",
    },
  },
}))

export const StyledMetricLabelText = styled(
  StyledWidgetLabel
)<StyledMetricLabelTextProps>(({ visibility }) => ({
  marginBottom: 0,
  display: visibility === LabelVisibilityOptions.Collapsed ? "none" : "grid",
  gridTemplateColumns:
    visibility === LabelVisibilityOptions.Collapsed ? "initial" : "auto 1fr",
  visibility:
    visibility === LabelVisibilityOptions.Hidden ? "hidden" : "visible",
}))

export const StyledMetricValueText = styled.div(({ theme }) => ({
  fontSize: theme.fontSizes.threeXL,
  color: theme.colors.bodyText,
  paddingBottom: theme.spacing.twoXS,
}))

export interface StyledMetricDeltaTextProps {
  metricColor: MetricProto.MetricColor
}

const getMetricColor = (
  theme: any,
  color: MetricProto.MetricColor
): string => {
  switch (color) {
    case MetricProto.MetricColor.RED:
      return theme.colors.metricNegativeDeltaColor
    case MetricProto.MetricColor.GREEN:
      return theme.colors.metricPositiveDeltaColor
    // this must be grey
    default:
      return theme.colors.metricNeutralDeltaColor
  }
}

export const StyledMetricDeltaText = styled.div<StyledMetricDeltaTextProps>(
  ({ theme, metricColor }) => ({
    color: getMetricColor(theme, metricColor),
    fontSize: theme.fontSizes.md,
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    fontWeight: theme.fontWeights.normal,
  })
)


================================================
File: /frontend/lib/src/components/elements/PageLink/PageLink.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { customRenderLibContext, render } from "@streamlit/lib/src/test_util"
import IsSidebarContext from "@streamlit/lib/src/components/core/IsSidebarContext"
import { PageLink as PageLinkProto } from "@streamlit/lib/src/proto"

import PageLink, { Props } from "./PageLink"

const getProps = (
  elementProps: Partial<PageLinkProto> = {},
  widgetProps: Partial<Props> = {}
): Props => ({
  element: PageLinkProto.create({
    label: "Label",
    page: "streamlit_app",
    pageScriptHash: "main_page_hash",
    useContainerWidth: null,
    ...elementProps,
  }),
  width: 250,
  disabled: false,
  ...widgetProps,
})

const mockOnPageChange = vi.fn()

describe("PageLink", () => {
  beforeEach(() => {
    mockOnPageChange.mockClear()
  })

  it("renders without crashing", () => {
    const props = getProps()
    render(<PageLink {...props} />)

    const pageLink = screen.getByRole("link")
    expect(pageLink).toBeInTheDocument()
  })

  it("has correct className and style", () => {
    const props = getProps()
    render(<PageLink {...props} />)

    const pageLink = screen.getByTestId("stPageLink")

    expect(pageLink).toHaveClass("stPageLink")
    expect(pageLink).toHaveStyle(`width: ${props.width}px`)
  })

  it("renders a label within the button", () => {
    const props = getProps()
    render(<PageLink {...props} />)

    const pageLink = screen.getByRole("link", {
      name: `${props.element.label}`,
    })

    expect(pageLink).toBeInTheDocument()
  })

  it("handles the disabled prop", () => {
    const props = getProps({}, { disabled: true })
    render(<PageLink {...props} />)

    const pageLink = screen.getByRole("link")
    expect(pageLink).toHaveAttribute("disabled")
  })

  it("follows useContainerWidth property if set to true", () => {
    const props = getProps({ useContainerWidth: true })
    render(<PageLink {...props} />)
    const pageNavLink = screen.getByTestId("stPageLink-NavLink")
    expect(pageNavLink).toHaveStyle("width: 250px")
  })

  it("follows useContainerWidth property if set to false", () => {
    const props = getProps({ useContainerWidth: false })
    render(<PageLink {...props} />)
    const pageNavLink = screen.getByTestId("stPageLink-NavLink")
    expect(pageNavLink).toHaveStyle("width: fit-content")
  })

  it("useContainerWidth true by default in the sidebar", () => {
    const props = getProps()
    render(
      <IsSidebarContext.Provider value={true}>
        <PageLink {...props} />
      </IsSidebarContext.Provider>
    )
    const pageNavLink = screen.getByTestId("stPageLink-NavLink")
    expect(pageNavLink).toHaveStyle("width: 250px")
  })

  it("useContainerWidth false by default in the main page", () => {
    const props = getProps()
    render(
      <IsSidebarContext.Provider value={false}>
        <PageLink {...props} />
      </IsSidebarContext.Provider>
    )
    const pageNavLink = screen.getByTestId("stPageLink-NavLink")
    expect(pageNavLink).toHaveStyle("width: fit-content")
  })

  it("triggers onPageChange with pageScriptHash when clicked", async () => {
    const user = userEvent.setup()
    const props = getProps()

    customRenderLibContext(<PageLink {...props} />, {
      onPageChange: mockOnPageChange,
    })

    const pageNavLink = screen.getByTestId("stPageLink-NavLink")
    await user.click(pageNavLink)
    expect(mockOnPageChange).toHaveBeenCalledWith("main_page_hash")
  })

  it("does not trigger onPageChange when disabled", async () => {
    const user = userEvent.setup()
    const props = getProps({}, { disabled: true })

    customRenderLibContext(<PageLink {...props} />, {
      onPageChange: mockOnPageChange,
    })

    const pageNavLink = screen.getByTestId("stPageLink-NavLink")
    await user.click(pageNavLink)
    expect(mockOnPageChange).not.toHaveBeenCalled()
  })

  it("does not trigger onPageChange for external links", async () => {
    const user = userEvent.setup()
    const props = getProps({ page: "http://example.com", external: true })

    customRenderLibContext(<PageLink {...props} />, {
      onPageChange: mockOnPageChange,
    })

    const pageNavLink = screen.getByTestId("stPageLink-NavLink")
    await user.click(pageNavLink)
    expect(mockOnPageChange).not.toHaveBeenCalled()
  })
})


================================================
File: /frontend/lib/src/components/elements/PageLink/PageLink.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { useTheme } from "@emotion/react"

import { DynamicIcon } from "@streamlit/lib/src/components/shared/Icon"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"
import { PageLink as PageLinkProto } from "@streamlit/lib/src/proto"
import { BaseButtonTooltip } from "@streamlit/lib/src/components/shared/BaseButton"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"
import { EmotionTheme } from "@streamlit/lib/src/theme"
import { LibContext } from "@streamlit/lib/src/components/core/LibContext"
import IsSidebarContext from "@streamlit/lib/src/components/core/IsSidebarContext"

import {
  StyledNavLink,
  StyledNavLinkContainer,
  StyledNavLinkText,
} from "./styled-components"

export interface Props {
  disabled: boolean
  element: PageLinkProto
  width: number
}

function shouldUseContainerWidth(
  useContainerWidth: boolean | null | undefined,
  isInSidebar: boolean
): boolean {
  if (useContainerWidth === null && isInSidebar) {
    return true
  } else if (useContainerWidth === null && !isInSidebar) {
    return false
  }
  return useContainerWidth === true ? true : false
}

function PageLink(props: Readonly<Props>): ReactElement {
  const { onPageChange, currentPageScriptHash } = React.useContext(LibContext)
  const isInSidebar = React.useContext(IsSidebarContext)

  const { colors }: EmotionTheme = useTheme()

  const { disabled, element, width } = props
  const style = { width }

  const useContainerWidth = shouldUseContainerWidth(
    element.useContainerWidth,
    isInSidebar
  )

  const isCurrentPage = currentPageScriptHash === element.pageScriptHash

  const handleClick = (e: React.MouseEvent<HTMLAnchorElement>): void => {
    if (element.external) {
      // External Page Link
      if (disabled) {
        e.preventDefault()
      }
    } else {
      // MPA Page Link
      e.preventDefault()
      if (!disabled) {
        onPageChange(element.pageScriptHash)
      }
    }
  }

  return (
    <div className="stPageLink" data-testid="stPageLink" style={style}>
      <BaseButtonTooltip help={element.help} placement={Placement.TOP_RIGHT}>
        <StyledNavLinkContainer>
          <StyledNavLink
            data-testid="stPageLink-NavLink"
            disabled={disabled}
            isCurrentPage={isCurrentPage}
            fluidWidth={useContainerWidth ? width : false}
            href={element.page}
            target={element.external ? "_blank" : ""}
            rel="noreferrer"
            onClick={handleClick}
          >
            {element.icon && (
              <DynamicIcon
                size="lg"
                color={colors.bodyText}
                iconValue={element.icon}
              />
            )}
            <StyledNavLinkText disabled={disabled}>
              <StreamlitMarkdown
                source={element.label}
                allowHTML={false}
                isLabel
                boldLabel={isCurrentPage}
                largerLabel
                disableLinks
              />
            </StyledNavLinkText>
          </StyledNavLink>
        </StyledNavLinkContainer>
      </BaseButtonTooltip>
    </div>
  )
}

export default PageLink


================================================
File: /frontend/lib/src/components/elements/PageLink/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./PageLink"


================================================
File: /frontend/lib/src/components/elements/PageLink/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledNavLinkContainer = styled.div({
  display: "flex",
  flexDirection: "column",
})

export interface StyledNavLinkProps {
  disabled: boolean
  isCurrentPage: boolean
  // If true or number, the button should take up container's full width
  fluidWidth?: boolean | number
}

export const StyledNavLink = styled.a<StyledNavLinkProps>(
  ({ disabled, isCurrentPage, fluidWidth, theme }) => ({
    textDecoration: "none",
    width: typeof fluidWidth == "number" ? `${fluidWidth}px` : "fit-content",
    display: "flex",
    flexDirection: "row",
    alignItems: "center",
    justifyContent: "flex-start",
    gap: theme.spacing.sm,
    borderRadius: theme.radii.default,

    paddingLeft: theme.spacing.sm,
    paddingRight: theme.spacing.sm,
    marginTop: theme.spacing.threeXS,
    marginBottom: theme.spacing.threeXS,
    lineHeight: theme.lineHeights.menuItem,

    backgroundColor: isCurrentPage
      ? theme.colors.darkenedBgMix15
      : "transparent",

    "&:hover": {
      backgroundColor: isCurrentPage
        ? theme.colors.darkenedBgMix25
        : theme.colors.darkenedBgMix15,
    },

