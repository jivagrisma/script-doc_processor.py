st.data_editor(
    DATETIME_TYPES_DF.set_index("datetime"),
    use_container_width=True,
    num_rows="dynamic",
)

# Categorical index doesn't work since arrow
# does serialize the options:
# st.subheader("Categorical Index (pd.CategoricalIndex)")
# st.data_editor(
#     SPECIAL_TYPES_DF.set_index("categorical"),
#     use_container_width=True,
#     num_rows="dynamic",
# )

# List index isn't editable currently:
# st.subheader("List Index (pd.Index)")
# st.data_editor(
#     LIST_TYPES_DF.set_index("string_list"), use_container_width=True, num_rows="dynamic"
# )

# Interval type isn't editable currently:
# st.subheader("Interval Index (pd.IntervalIndex)")
# st.data_editor(INTERVAL_TYPES_DF.set_index("int64_both"), use_container_width=True)

# Multi index is not yet supported for editing:
# st.subheader("Multi Index (pd.MultiIndex)")
# st.data_editor(
#     BASE_TYPES_DF.set_index(["string", "int64"]),
#     use_container_width=True,
#     num_rows="dynamic",
# )

# Timedelta Index are currently not supported for editing:
# st.subheader("Timedelta Index (pd.TimedeltaIndex)")
# st.data_editor(
#     SPECIAL_TYPES_DF.set_index("timedelta"),
#     use_container_width=True,
#     num_rows="dynamic",
# )


================================================
File: /e2e_playwright/st_data_editor_index_types_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_data_editor_index_types(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.data_editor renders various index types correctly."""
    dataframe_elements = app.get_by_test_id("stDataFrame")
    expect(dataframe_elements).to_have_count(7)

    # The dataframe component might require a bit more time for rendering the canvas
    app.wait_for_timeout(250)

    assert_snapshot(dataframe_elements.nth(0), name="st_data_editor-string_index")
    assert_snapshot(dataframe_elements.nth(1), name="st_data_editor-float64_index")
    assert_snapshot(dataframe_elements.nth(2), name="st_data_editor-int64_index")
    assert_snapshot(dataframe_elements.nth(3), name="st_data_editor-uint64_index")
    assert_snapshot(dataframe_elements.nth(4), name="st_data_editor-date_index")
    assert_snapshot(dataframe_elements.nth(5), name="st_data_editor-time_index")
    assert_snapshot(dataframe_elements.nth(6), name="st_data_editor-datetime_index")


================================================
File: /e2e_playwright/st_data_editor_input_data.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import random

import numpy as np
import pandas as pd

import streamlit as st
from shared.data_mocks import SHARED_TEST_CASES, TestCaseMetadata
from streamlit.dataframe_util import DataFormat

np.random.seed(0)
random.seed(0)

st.set_page_config(layout="wide")

activate_dynamic_editing = st.toggle("Activate dynamic editing")
show_return_data = st.toggle("Show return data")

TEST_CASES = SHARED_TEST_CASES.copy()
TEST_CASES.append(
    (
        pd.DataFrame(
            np.random.randn(3, 3),
            columns=pd.MultiIndex.from_tuples(
                [("A", "foo"), ("A", "bar"), ("B", "foo")]
            ),
        ),  # Explicitly set the range index to have the same behavior across versions
        TestCaseMetadata(0, 2, DataFormat.PANDAS_DATAFRAME),
    ),
)

# # Render all test cases with st.data_editor:
for i, test_case in enumerate(TEST_CASES):
    data = test_case[0]
    data_format = str(test_case[1].expected_data_format)
    st.subheader(data_format)
    return_df_fixed = st.data_editor(
        data,
        key=f"data_editor-{i}",
        num_rows="dynamic" if activate_dynamic_editing else "fixed",
    )
    if show_return_data:
        st.dataframe(return_df_fixed)


================================================
File: /e2e_playwright/st_data_editor_input_data_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_data_editor_input_format_rendering(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.data_editor renders various data formats correctly via snapshot testing."""
    dataframe_elements = app.get_by_test_id("stDataFrame")
    expect(dataframe_elements).to_have_count(33)

    # The data editor might require a bit more time for rendering the canvas
    app.wait_for_timeout(1000)

    for i, element in enumerate(dataframe_elements.all()):
        assert_snapshot(element, name=f"st_data_editor-input_data_{i}")


================================================
File: /e2e_playwright/st_dataframe_column_types.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import random

import numpy as np

import streamlit as st
from shared.data_mocks import (
    BASE_TYPES_DF,
    DATETIME_TYPES_DF,
    INTERVAL_TYPES_DF,
    LIST_TYPES_DF,
    NUMBER_TYPES_DF,
    PERIOD_TYPES_DF,
    SPECIAL_TYPES_DF,
    UNSUPPORTED_TYPES_DF,
)

np.random.seed(0)
random.seed(0)

st.set_page_config(layout="wide")

st.subheader("Base types")
st.dataframe(BASE_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("Number types")
st.dataframe(NUMBER_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("Date, time and datetime types")
st.dataframe(DATETIME_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("List types")
st.dataframe(LIST_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("Interval types")
st.dataframe(INTERVAL_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("Special types")
st.dataframe(SPECIAL_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("Period types")
st.dataframe(PERIOD_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("Unsupported types (string fallback)")
st.dataframe(UNSUPPORTED_TYPES_DF, use_container_width=True, hide_index=True)


================================================
File: /e2e_playwright/st_dataframe_column_types_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_dataframe_column_types_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.dataframe renders various column types correctly via screenshot
    matching."""
    elements = themed_app.get_by_test_id("stDataFrame")
    expect(elements).to_have_count(8)

    # The dataframe component might require a bit more time for rendering the canvas
    themed_app.wait_for_timeout(250)

    assert_snapshot(elements.nth(0), name="st_dataframe-base_types")
    assert_snapshot(elements.nth(1), name="st_dataframe-numerical_types")
    assert_snapshot(elements.nth(2), name="st_dataframe-datetime_types")
    assert_snapshot(elements.nth(3), name="st_dataframe-list_types")
    assert_snapshot(elements.nth(4), name="st_dataframe-interval_types")
    assert_snapshot(elements.nth(5), name="st_dataframe-special_types")
    assert_snapshot(elements.nth(6), name="st_dataframe-period_types")
    assert_snapshot(elements.nth(7), name="st_dataframe-unsupported_types")


================================================
File: /e2e_playwright/st_dataframe_config.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import random

import numpy as np
import pandas as pd

import streamlit as st

np.random.seed(0)
random.seed(0)

st.set_page_config(layout="wide")

# Generate a random dataframe
df = pd.DataFrame(
    np.random.randn(5, 5),
    columns=("col_%d" % i for i in range(5)),
)


st.header("Hide index parameter:")
st.dataframe(df, hide_index=True)
st.dataframe(df, hide_index=False)

st.header("Column order parameter:")
st.dataframe(df, column_order=["col_4", "col_3", "col_0"])

st.header("Set column labels:")
st.dataframe(
    df,
    column_config={
        "_index": "Index column",
        "col_0": "Column 0",
        "col_2": st.column_config.Column("Column 1"),
    },
)

st.header("Hide columns:")
st.dataframe(df, column_config={"col_1": None, "col_3": {"hidden": True}})

st.header("Set column width:")
st.dataframe(
    df,
    column_config={
        "col_0": st.column_config.Column(width="small"),
        "col_1": st.column_config.Column(width="medium"),
        "col_4": {"width": "large"},
    },
)

st.header("Set help tooltips:")
st.caption("Hover over the column headers to see the tooltips.")
st.dataframe(
    pd.DataFrame(
        {
            "col_0": ["a", "b", "c", None],
        }
    ),
    column_config={
        "col_0": st.column_config.Column(help="This :red[is] a **tooltip** ðŸŒŸ"),
        "_index": {"help": "Index tooltip!"},
    },
)


st.header("Ignore editing-only config options:")
st.dataframe(
    pd.DataFrame(
        {
            "col_0": ["a", "b", "c", None],
        }
    ),
    column_config={"col_0": st.column_config.Column(disabled=False, required=True)},
)


st.header("Text column:")

st.dataframe(
    pd.DataFrame(
        {
            "col_0": ["Hello World", "Lorem ipsum", "", None],
            "col_1": [1, 2, 3, None],
        }
    ),
    column_config={
        "col_0": st.column_config.TextColumn(
            "Text column",
            width="medium",
            help="This is a text column",
            required=True,  # Should be ignored
            disabled=False,  # Should be ignored
            default="invalid",  # Should be ignored
            max_chars=5,  # Should be ignored
            validate="^[0-9]+$",  # Should be ignored
        ),
        "col_1": st.column_config.TextColumn(),
    },
)

st.header("Number column:")
st.dataframe(
    pd.DataFrame(
        {
            "col_0": [1, 2, 3, None],
            "col_1": ["1", "2", "invalid", None],
        }
    ),
    column_config={
        "col_0": st.column_config.NumberColumn(
            "Number column",
            width="medium",
            help="This is a number column",
            required=True,  # Should be ignored
            disabled=False,  # Should be ignored
            default=0,  # Should be ignored
            min_value=5,  # Should be ignored
            max_value=10,  # Should be ignored
            step=0.001,
        ),
        "col_1": st.column_config.NumberColumn(
            format="%.2f%%",
        ),
    },
)

st.header("Checkbox column:")
st.dataframe(
    pd.DataFrame(
        {
            "col_0": [True, False, False, None],
            "col_1": ["yes", "no", "invalid", None],
        }
    ),
    column_config={
        "col_0": st.column_config.CheckboxColumn(
            "Checkbox column",
            width="medium",
            help="This is a checkbox column",
            required=True,  # Should be ignored
            disabled=False,  # Should be ignored
            default=True,  # Should be ignored
        ),
        "col_1": st.column_config.CheckboxColumn(),
    },
)

st.header("Selectbox column:")

st.dataframe(
    pd.DataFrame(
        {
            "col_0": [1, 2, 3, None],
            "col_1": ["a", "b", "c", None],
        }
    ),
    column_config={
        "col_0": st.column_config.SelectboxColumn(
            "Selectbox column",
            width="medium",
            help="This is a selectbox column",
            required=True,  # Should be ignored
            disabled=False,  # Should be ignored
            default=True,  # Should be ignored
            options=[1, 2, 3, 4, 5],
        ),
        "col_1": st.column_config.SelectboxColumn(options=["a", "b", "c", "d"]),
    },
)

st.header("Link column:")

st.dataframe(
    pd.DataFrame(
        {
            "col_0": [
                "https://streamlit.io/",
                "https://docs.streamlit.io/",
                "https://streamlit.io/gallery",
                None,
            ],
            "col_1": ["/a", "/b", "", None],
            "col_2": [
                "https://roadmap.streamlit.app",
                "https://extras.streamlit.app",
                "",
                None,
            ],
            "col_3": [
                "https://roadmap.streamlit.app",
                "https://extras.streamlit.app",
                "",
                None,
            ],
        }
    ),
    column_config={
        "col_0": st.column_config.LinkColumn(
            "Link column",
            width="medium",
            help="This is a link column",
            required=True,  # Should be ignored
            disabled=False,  # Should be ignored
            default="https://streamlit.io/",  # Should be ignored
            max_chars=5,  # Should be ignored
            validate="^[0-9]+$",  # Should be ignored
        ),
        "col_1": st.column_config.LinkColumn(),
        "col_2": st.column_config.LinkColumn(
            "Display text via Regex",
            display_text=r"https://(.*?)\.streamlit\.app",
        ),
        "col_3": st.column_config.LinkColumn(
            "Static display text",
            display_text="Open link",
        ),
    },
)

st.header("Datetime column:")

st.dataframe(
    pd.DataFrame(
        {
            "col_0": [
                datetime.datetime(2021, 1, 1, 1, 0, 0, 123000),
                datetime.datetime(2022, 1, 2, 2, 0, 0, 234000),
                datetime.datetime(2023, 1, 3, 3, 0, 0, 345000),
                None,
            ],
            "col_1": [
                "2021-01-01T01:00:00.123",
                "2022-01-02T02:00:00.234",
                "invalid",
                None,
            ],
            "col_2": [
                datetime.date(2021, 1, 1),
                datetime.date(2022, 1, 2),
                datetime.date(2023, 1, 3),
                None,
            ],
        }
    ),
    column_config={
        "col_0": st.column_config.DatetimeColumn(
            "Datetime column",
            width="medium",
            help="This is a datetime column",
            required=True,  # Should be ignored
            disabled=False,  # Should be ignored
            default=datetime.datetime(2021, 1, 1, 1, 0, 0),  # Should be ignored
            min_value=datetime.datetime(2021, 1, 1, 1, 0, 0),  # Should be ignored
            max_value=datetime.datetime(2022, 1, 1, 1, 0, 0),  # Should be ignored
            step=0.01,
            format="YYYY-MM-DD HH:mm:ss.SSS",
        ),
        "col_1": st.column_config.DatetimeColumn(
            step=0.01,
        ),
        "col_2": st.column_config.DatetimeColumn(),
    },
)

st.header("Date column:")

st.dataframe(
    pd.DataFrame(
        {
            "col_0": [
                datetime.date(2021, 1, 1),
                datetime.date(2022, 1, 2),
                datetime.date(2023, 1, 3),
                None,
            ],
            "col_1": [
                "2021-01-01T01:00:00",
                "2022-01-02T02:00:00",
                "invalid",
                None,
            ],
            "col_2": [
                datetime.datetime(2021, 1, 1, 1, 0, 0, 123000),
                datetime.datetime(2022, 1, 2, 2, 0, 0, 234000),
                datetime.datetime(2023, 1, 3, 3, 0, 0, 345000),
                None,
            ],
        }
    ),
    column_config={
        "col_0": st.column_config.DateColumn(
            "Date column",
            width="medium",
            help="This is a date column",
            required=True,  # Should be ignored
            disabled=False,  # Should be ignored
            default=datetime.date(2021, 1, 1),  # Should be ignored
            min_value=datetime.date(2021, 1, 1),  # Should be ignored
            max_value=datetime.date(2022, 1, 1),  # Should be ignored
            step=2,  # Should be ignored
        ),
        "col_1": st.column_config.DateColumn(),
        "col_2": st.column_config.DateColumn(),
    },
)

st.header("Time column:")

st.dataframe(
    pd.DataFrame(
        {
            "col_0": [
                datetime.time(1, 2, 0, 123000),
                datetime.time(2, 3, 0, 234000),
                datetime.time(3, 4, 0, 345000),
                None,
            ],
            "col_1": [
                "2021-01-01T01:02:00",
                "2022-01-02T02:03:00",
                "invalid",
                None,
            ],
            "col_2": [
                datetime.datetime(2021, 1, 1, 1, 0, 0, 123000),
                datetime.datetime(2022, 1, 2, 2, 0, 0, 234000),
                datetime.datetime(2023, 1, 3, 3, 0, 0, 345000),
                None,
            ],
        }
    ),
    column_config={
        "col_0": st.column_config.TimeColumn(
            "Time column",
            width="medium",
            help="This is a time column",
            required=True,  # Should be ignored
            disabled=False,  # Should be ignored
            default=datetime.time(1, 2, 0),  # Should be ignored
            min_value=datetime.time(1, 2, 0),  # Should be ignored
            max_value=datetime.time(1, 3, 0),  # Should be ignored
            step=datetime.timedelta(milliseconds=1),
        ),
        "col_1": st.column_config.TimeColumn(
            format="HH:mm",
        ),
        "col_2": st.column_config.TimeColumn(),
    },
)

st.header("Progress column:")

st.dataframe(
    pd.DataFrame(
        {
            "col_0": [0.1, 0.4, 1.1, None],
            "col_1": ["200", "550", "1000", None],
        }
    ),
    column_config={
        "col_0": st.column_config.ProgressColumn(
            "Progress column",
            width="medium",
            help="This is a progress column",
        ),
        "col_1": st.column_config.ProgressColumn(
            format="$%f", min_value=0, max_value=1000
        ),
    },
)

st.header("List column:")

st.dataframe(
    pd.DataFrame(
        {
            "col_0": [[1, 2], [2, 3, 4], [], None],
            "col_1": ["a,b", "c,d,e", "", None],
        }
    ),
    column_config={
        "col_0": st.column_config.ListColumn(
            "List column",
            width="medium",
            help="This is a list column",
        ),
        "col_1": st.column_config.ListColumn(),
    },
)

st.header("Bar chart column:")

st.dataframe(
    pd.DataFrame(
        {
            "col_0": [[1, 5, 2], [2, 3, 5, -4, -5], [], None],
            "col_1": ["1,2,3,4", "6, 5, 1, 10", "invalid", None],
        }
    ),
    column_config={
        "col_0": st.column_config.BarChartColumn(
            "Bar chart column",
            width="medium",
            help="This is a bar chart column",
            y_min=-5,
            y_max=5,
        ),
        "col_1": st.column_config.BarChartColumn(),
    },
)


st.header("Line chart column:")

st.dataframe(
    pd.DataFrame(
        {
            "col_0": [[1, 5, 2], [2, 3, 5, -4, -5], [], None],
            "col_1": ["1,2,3,4", "6, 5, 1, 10", "invalid", None],
        }
    ),
    column_config={
        "col_0": st.column_config.LineChartColumn(
            "Line chart column",
            width="medium",
            help="This is a line chart column",
            y_min=-5,
            y_max=5,
        ),
        "col_1": st.column_config.LineChartColumn(),
    },
)

st.header("Area chart column:")

st.dataframe(
    pd.DataFrame(
        {
            "col_0": [[1, 5, 2], [2, 3, 5, -4, -5], [], None],
            "col_1": ["1,2,3,4", "6, 5, 1, 10", "invalid", None],
        }
    ),
    column_config={
        "col_0": st.column_config.AreaChartColumn(
            "Area chart column",
            width="medium",
            help="This is an area chart column",
            y_min=-5,
            y_max=5,
        ),
        "col_1": st.column_config.AreaChartColumn(),
    },
)


st.header("Image column:")

st.dataframe(
    pd.DataFrame(
        {
            "col_0": [
                "https://streamlit.io/images/brand/streamlit-mark-color.png",
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAABSCAMAAACBpt1yAAAAwFBMVEVHcEyAhJWAhJUzNT97f4+AhJWAhJVtcH9WWWaAhJWAhJWAhJVCRFGAhJWAhJWAhJVVWGeAhJWAhJWAhJVVWGcmJzCAhJWAhJWAhJUmJzAmJzBVWGcmJzAmJzAmJzAmJzAmJzCAhJUmJzBVWGcmJzAmJzAmJzBVWGeAhJVVWGdVWGdVWGeAhJVVWGdVWGdVWGdvcoJVJ2WAhJVVWGcmJzBTVmVaXWx8f5B1eYlhZHNoa3tDRVI3OUQtLzhucoJMT13kXsyQAAAAMXRSTlMA+SYWE/ExBQvmfME1P7Uc9lhpjSdsTZ7cnETlsyP6xvHNg7XXV+bYq6NjTtR1yJLh8/IzCQAABHhJREFUaN7Nmut2mkAYRZGLIMQbRMFbvMQYkmjS9YFJU23z/m9VwEpgGJgZYLo4/2ratXbdhyNMFIS68jzzXm+EpuVl5nne623DqKRXL8yb2iyst4jKG7w0S+HgguU93jZPYZin5mhU32Iqb/DcPIWN0phQGGnUGqewQRpTChuj8fbVQ1ODRnVsDeUaFVbXuBhtpsJYgZYxLP3fUzMKK2qURlvf3wkWBGn1xiVX8PbRw6WsRmm09MOE71YYxe2qNSmMUkqj9rC8i6hWgmzAJYrdVqtfhRU0ag/zC5TvzwVBh2s6drsehWHuGTVq0xjKXz0IgtiBbzBLZFL45OWHSaM6naz8OEspeMWGRBydAex5UIA1Y7iDvklC+f4ofG3cSnLBXu9XV8ik8WayS0L5u0X4qryGdNYm1b5qT4VU3uBAt56bNJTvTy6Xng5o1jTDX6iQVuNis0Wg/Lvp5UftToaLYvgJCqk0RpOOJix8dBm4kA1p+EkKoxyoJh3J5vrzYQvDRRh+okKSRuk66Uh28b/JlD4e/m4FhZFGmTzp+MLjS08YfiqF+RqTk44W/uH7r2FKXzz8VArzNKrT+crPy7XwuaWPwbLDfzPzaJPRqCKTnlf4/NJ/fyKlh1+79+hzKJ703MKH6e+hMPvU8B8YqNIas5OOZJ6eOgsISXwiMShMa8RMekHhw3QVElc8/EwKExqxk45kKyFF7AEx/4b/wEjlzV4ooZDChzGBIsHwsyqMNEpazqQjWU1RrL4DVGD2vXdk55rTQGUKT1X6a/58MmN9namo7kbZ7SWX/pqPP+/MXL9psLYLzOeUAdT5+MUIdjzRvFkT3OenCcAP7HguU/gwosPCBT9/vTN0/0jWeLfE38zaABzByBpH+Fsz+tLHYJ/Ua3Ekatwt8FiyAcARjKRxkneLbgJwBCNcjfjClyh9PGOfdVyNSyn3acQGKAf2Xl3jKP8hadwCrmAn2tvS6qVnASvQOCl6WNahfGiGP1cjeluKlL5TgYtmX0/shRfQMzgOYHkaN8VnKKVLTztjeI07wplT3nFEfWBYjXPSIbcOwBnszFp4wnFETcOP0biViEfRLgBnsBNr4cnHEbXsK6pxRXHIWkPpSfuKapzTHJXrALzBToyFD8vVVoA72Jn0HMat9IXDn9K4EahSV+mLZuyL5rYUOY7YA/AGS3w2zml/N2QBcAc7/qa4La36ZEa3r0fc1UhX+Og4ogfABwxzNU7of+1oAvABe89opC08wxlcxRn7It+W8i89BuzMUnhepU+AHWONuwULlmYAx8TD/1X8HPbfSo/M2PE0ZaIqeRzBDMb6JQ7BbAF/sBnzt41VXeHN9fGjxJdn1bHBF0xx20KZyF3d7hn7jlKvz5bi7A3X1rsVvqqnarLYHg9N3XIDQqejlGJsKUrHWRs929LNYbctylpt3+VVVVnui+1uwBhAWrbb6xnGer13HKeTSvCCs1+vDaPnurYVgJjDcYDSr5GlEDN4J+V+EFEU23GCP4jBa7IcUKilOf4CgQRuuzC9EJcAAAAASUVORK5CYII=",
                "data:image/svg+xml,%3Csvg width='301' height='165' viewBox='0 0 301 165' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M150.731 101.547L98.1387 73.7471L6.84674 25.4969C6.7634 25.4136 6.59674 25.4136 6.51341 25.4136C3.18007 23.8303 -0.236608 27.1636 1.0134 30.497L47.5302 149.139L47.5385 149.164C47.5885 149.281 47.6302 149.397 47.6802 149.514C49.5885 153.939 53.7552 156.672 58.2886 157.747C58.6719 157.831 58.9461 157.906 59.4064 157.998C59.8645 158.1 60.5052 158.239 61.0552 158.281C61.1469 158.289 61.2302 158.289 61.3219 158.297H61.3886C61.4552 158.306 61.5219 158.306 61.5886 158.314H61.6802C61.7386 158.322 61.8052 158.322 61.8636 158.322H61.9719C62.0386 158.331 62.1052 158.331 62.1719 158.331V158.331C121.084 164.754 180.519 164.754 239.431 158.331V158.331C240.139 158.331 240.831 158.297 241.497 158.231C241.714 158.206 241.922 158.181 242.131 158.156C242.156 158.147 242.189 158.147 242.214 158.139C242.356 158.122 242.497 158.097 242.639 158.072C242.847 158.047 243.056 158.006 243.264 157.964C243.681 157.872 243.87 157.806 244.436 157.611C245.001 157.417 245.94 157.077 246.527 156.794C247.115 156.511 247.522 156.239 248.014 155.931C248.622 155.547 249.201 155.155 249.788 154.715C250.041 154.521 250.214 154.397 250.397 154.222L250.297 154.164L150.731 101.547Z' fill='%23FF4B4B'/%3E%3Cpath d='M294.766 25.4981H294.683L203.357 73.7483L254.124 149.357L300.524 30.4981V30.3315C301.691 26.8314 298.108 23.6648 294.766 25.4981' fill='%237D353B'/%3E%3Cpath d='M155.598 2.55572C153.264 -0.852624 148.181 -0.852624 145.931 2.55572L98.1389 73.7477L150.731 101.548L250.398 154.222C251.024 153.609 251.526 153.012 252.056 152.381C252.806 151.456 253.506 150.465 254.123 149.356L203.356 73.7477L155.598 2.55572Z' fill='%23BD4043'/%3E%3C/svg%3E%0A",
                "",
                None,
            ],
        }
    ),
    column_config={
        "col_0": st.column_config.ImageColumn(
            "Image column",
            width="medium",
            help="This is a image column",
        ),
    },
)

st.subheader("Long colum header")
st.dataframe(
    pd.DataFrame(
        np.random.randn(100, 15),
        columns=[
            "this is a very long column header name",
            "A",
            "Short header",
            "B",
            "this is another very very column long header name",
            "C",
            (
                "this is another very very very very very very very very very very very"
                " very very very very long header name"
            ),
            "D",
            "E",
            "F",
            "G",
            "H",
            "I",
            "J",
            "K",
        ],
    ),
)

st.subheader("Hierarchical headers")

st.dataframe(
    pd.DataFrame(
        np.random.randn(3, 6),
        index=["A", "B", "C"],
        columns=pd.MultiIndex.from_tuples(
            [
                ("a", "b", "c"),
                ("a", "b", "d"),
                ("e", "f", "c"),
                ("g", "h", "d"),
                ("", "h", "i"),
                ("j", "", ""),
            ],
            names=["first", "second", "third"],
        ),
    )
)

df = pd.DataFrame(
    np.random.randn(5, 25),
    columns=("col_%d" % i for i in range(25)),
)
st.header("Pinned columns:")
st.dataframe(
    df,
    column_config={
        "_index": st.column_config.Column(pinned=False),
        "col_2": st.column_config.Column(pinned=True),
        "col_4": st.column_config.Column(pinned=True),
        "col_16": st.column_config.Column(pinned=True),
    },
    # Use reversed column order to test that pinned columns
    # use the column order as well.
    column_order=reversed(df.columns.tolist()),
)


================================================
File: /e2e_playwright/st_dataframe_config_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class


def test_dataframe_supports_various_configurations(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Screenshot test that st.dataframe supports various configuration options."""
    dataframe_elements = themed_app.get_by_test_id("stDataFrame")
    expect(dataframe_elements).to_have_count(25)

    # The dataframe component might require a bit more time for rendering the canvas
    themed_app.wait_for_timeout(250)

    assert_snapshot(dataframe_elements.nth(0), name="st_dataframe-hide_index")
    assert_snapshot(dataframe_elements.nth(1), name="st_dataframe-show_index")
    assert_snapshot(dataframe_elements.nth(2), name="st_dataframe-custom_column_order")
    assert_snapshot(dataframe_elements.nth(3), name="st_dataframe-column_labels")
    assert_snapshot(dataframe_elements.nth(4), name="st_dataframe-hide_columns")
    assert_snapshot(dataframe_elements.nth(5), name="st_dataframe-set_column_width")
    assert_snapshot(dataframe_elements.nth(6), name="st_dataframe-help_tooltips")
    assert_snapshot(dataframe_elements.nth(7), name="st_dataframe-ignore_edit_options")
    assert_snapshot(dataframe_elements.nth(8), name="st_dataframe-text_column")
    assert_snapshot(dataframe_elements.nth(9), name="st_dataframe-number_column")
    assert_snapshot(dataframe_elements.nth(10), name="st_dataframe-checkbox_column")
    assert_snapshot(dataframe_elements.nth(11), name="st_dataframe-selectbox_column")
    assert_snapshot(dataframe_elements.nth(12), name="st_dataframe-link_column")
    assert_snapshot(dataframe_elements.nth(13), name="st_dataframe-datetime_column")
    assert_snapshot(dataframe_elements.nth(14), name="st_dataframe-date_column")
    assert_snapshot(dataframe_elements.nth(15), name="st_dataframe-time_column")
    assert_snapshot(dataframe_elements.nth(16), name="st_dataframe-progress_column")
    assert_snapshot(dataframe_elements.nth(17), name="st_dataframe-list_column")
    assert_snapshot(dataframe_elements.nth(18), name="st_dataframe-bar_chart_column")
    assert_snapshot(dataframe_elements.nth(19), name="st_dataframe-line_chart_column")
    assert_snapshot(dataframe_elements.nth(20), name="st_dataframe-area_chart_column")
    assert_snapshot(dataframe_elements.nth(21), name="st_dataframe-image_column")
    assert_snapshot(dataframe_elements.nth(22), name="st_dataframe-auto_sized_columns")
    assert_snapshot(
        dataframe_elements.nth(23), name="st_dataframe-hierarchical_headers"
    )
    assert_snapshot(dataframe_elements.nth(24), name="st_dataframe-pinned_columns")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stDataFrame")


================================================
File: /e2e_playwright/st_dataframe_dimensions.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import numpy as np
import pandas as pd

import streamlit as st

# Explicitly seed the RNG for deterministic results
np.random.seed(0)

data = np.random.randn(100, 100)

df = pd.DataFrame(data)
st.dataframe(df)
st.dataframe(df, 250, 150)
st.dataframe(df, width=250)
st.dataframe(df, height=150)
st.dataframe(df, 5000, 5000)
st.dataframe(df, use_container_width=True)

small_df = pd.DataFrame(np.random.randn(100, 3))
st.dataframe(small_df, width=500)
st.dataframe(small_df, use_container_width=True)
st.dataframe(small_df, width=200, use_container_width=True)
st.dataframe(small_df, width=200, use_container_width=False)

one_col_df = pd.DataFrame(np.random.randn(100, 1))
st.dataframe(one_col_df, use_container_width=True)

if st.button("Resize dataframe"):
    st.dataframe(small_df, width=400, height=200)
else:
    st.dataframe(small_df, width=200, height=100)


================================================
File: /e2e_playwright/st_dataframe_dimensions_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.shared.app_utils import click_button


def test_data_frame_with_different_sizes(app: Page):
    """Test that st.dataframe should show different sizes as expected."""
    expected = [
        {"width": "704px", "height": "400px"},
        {"width": "250px", "height": "150px"},
        {"width": "250px", "height": "400px"},
        {"width": "704px", "height": "150px"},
        {"width": "704px", "height": "5000px"},
        {"width": "704px", "height": "400px"},
        {"width": "500px", "height": "400px"},
        {"width": "704px", "height": "400px"},
        {"width": "704px", "height": "400px"},
        {"width": "200px", "height": "400px"},
        {"width": "704px", "height": "400px"},
        {"width": "200px", "height": "100px"},
    ]

    dataframe_elements = app.get_by_test_id("stDataFrame")
    expect(dataframe_elements).to_have_count(12)

    for i, element in enumerate(dataframe_elements.all()):
        expect(element).to_have_css("width", expected[i]["width"])
        expect(element).to_have_css("height", expected[i]["height"])


def test_data_frame_resizing(app: Page):
    """Test that st.dataframe should resize as expected."""

    dataframe_element = app.get_by_test_id("stDataFrame").nth(11)
    expect(dataframe_element).to_have_css("width", "200px")
    expect(dataframe_element).to_have_css("height", "100px")

    click_button(app, "Resize dataframe")
    expect(dataframe_element).to_have_css("width", "400px")
    expect(dataframe_element).to_have_css("height", "200px")


================================================
File: /e2e_playwright/st_dataframe_index_types.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import random

import numpy as np

import streamlit as st
from shared.data_mocks import (
    BASE_TYPES_DF,
    DATETIME_TYPES_DF,
    INTERVAL_TYPES_DF,
    LIST_TYPES_DF,
    NUMBER_TYPES_DF,
    PERIOD_TYPES_DF,
    SPECIAL_TYPES_DF,
)

np.random.seed(0)
random.seed(0)

st.set_page_config(layout="wide")

st.header("Index types")

st.subheader("String Index (pd.Index)")
st.dataframe(BASE_TYPES_DF.set_index("string"), use_container_width=True)

st.subheader("Float64 Index (pd.Float64Index)")
st.dataframe(NUMBER_TYPES_DF.set_index("float64"), use_container_width=True)

st.subheader("Int64 Index (pd.Int64Index)")
st.dataframe(NUMBER_TYPES_DF.set_index("int64"), use_container_width=True)

st.subheader("Uint64 Index (pd.UInt64Index)")
st.dataframe(NUMBER_TYPES_DF.set_index("uint64"), use_container_width=True)

st.subheader("Datetime Index (pd.DatetimeIndex)")
st.dataframe(DATETIME_TYPES_DF.set_index("datetime"), use_container_width=True)

st.subheader("Date Index (pd.Index)")
st.dataframe(DATETIME_TYPES_DF.set_index("date"), use_container_width=True)

st.subheader("Time Index (pd.Index)")
st.dataframe(DATETIME_TYPES_DF.set_index("time"), use_container_width=True)

st.subheader("Interval Index (pd.IntervalIndex)")
st.dataframe(INTERVAL_TYPES_DF.set_index("int64_both"), use_container_width=True)

st.subheader("List Index (pd.Index)")
st.dataframe(LIST_TYPES_DF.set_index("string_list"), use_container_width=True)

st.subheader("Multi Index (pd.MultiIndex)")
st.dataframe(BASE_TYPES_DF.set_index(["string", "int64"]), use_container_width=True)

st.subheader("Categorical Index (pd.CategoricalIndex)")
st.dataframe(SPECIAL_TYPES_DF.set_index("categorical"), use_container_width=True)

st.subheader("Period Index (pd.PeriodIndex)")
st.dataframe(PERIOD_TYPES_DF.set_index("D"), use_container_width=True)

st.subheader("Timedelta Index (pd.TimedeltaIndex)")
st.dataframe(SPECIAL_TYPES_DF.set_index("timedelta"), use_container_width=True)


================================================
File: /e2e_playwright/st_dataframe_index_types_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_dataframe_index_types(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.dataframe render various index types correctly."""
    dataframe_elements = app.get_by_test_id("stDataFrame")
    expect(dataframe_elements).to_have_count(13)

    # The dataframe component might require a bit more time for rendering the canvas
    app.wait_for_timeout(250)

    assert_snapshot(dataframe_elements.nth(0), name="st_dataframe-string_index")
    assert_snapshot(dataframe_elements.nth(1), name="st_dataframe-float64_index")
    assert_snapshot(dataframe_elements.nth(2), name="st_dataframe-int64_index")
    assert_snapshot(dataframe_elements.nth(3), name="st_dataframe-uint64_index")
    assert_snapshot(dataframe_elements.nth(4), name="st_dataframe-datetime_index")
    assert_snapshot(dataframe_elements.nth(5), name="st_dataframe-date_index")
    assert_snapshot(dataframe_elements.nth(6), name="st_dataframe-time_index")
    assert_snapshot(dataframe_elements.nth(7), name="st_dataframe-interval_index")
    assert_snapshot(dataframe_elements.nth(8), name="st_dataframe-list_index")
    assert_snapshot(dataframe_elements.nth(9), name="st_dataframe-multi_index")
    assert_snapshot(dataframe_elements.nth(10), name="st_dataframe-categorical")
    assert_snapshot(dataframe_elements.nth(11), name="st_dataframe-period_index")
    assert_snapshot(dataframe_elements.nth(12), name="st_dataframe-timedelta_index")


================================================
File: /e2e_playwright/st_dataframe_input_data.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import random

import numpy as np

import streamlit as st
from shared.data_mocks import SHARED_TEST_CASES

np.random.seed(0)
random.seed(0)

st.set_page_config(layout="wide")

selected_test_case = st.number_input(
    "Select test case", max_value=len(SHARED_TEST_CASES) - 1
)

# Render all test cases with st.dataframe:
test_case = SHARED_TEST_CASES[selected_test_case]
data = test_case[0]
st.subheader(str(test_case[1].expected_data_format))

# Little hack to make st.dataframe re-calculate width since
# it's a new element with a new delta path.
for _ in range(selected_test_case):
    st.empty()

st.dataframe(data)


================================================
File: /e2e_playwright/st_dataframe_input_data_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import wait_for_app_run
from e2e_playwright.shared.data_mocks import SHARED_TEST_CASES


def test_dataframe_input_format_rendering(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.dataframe renders various data formats correctly via snapshot
    testing."""

    for index, _ in enumerate(SHARED_TEST_CASES):
        number_input = app.get_by_test_id("stNumberInput").locator("input")
        number_input.fill(str(index))
        number_input.press("Enter")
        wait_for_app_run(app)

        dataframe_element = app.get_by_test_id("stDataFrame")
        expect(dataframe_element).to_be_visible()
        assert_snapshot(dataframe_element, name=f"st_dataframe-input_data_{index}")


================================================
File: /e2e_playwright/st_dataframe_interactions.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import random
import time

import numpy as np
import pandas as pd

import streamlit as st

np.random.seed(0)
random.seed(0)

DF_SIZE = 30


random_df = pd.DataFrame(
    np.random.randn(5, 5),
    columns=["Column A", "Column B", "Column C", "Column D", "Column E"],
)

fullscreen_df = pd.DataFrame(
    np.random.randn(DF_SIZE, DF_SIZE),
    columns=[f"Column {i}" for i in range(DF_SIZE)],
)

# Configure all columns to be use small width to allow reliable interaction testing:
st.dataframe(
    random_df,
    column_config={
        "_index": st.column_config.Column(width="small"),
        "Column A": st.column_config.Column(width="small"),
        "Column B": st.column_config.Column(width="small"),
        "Column C": st.column_config.Column(width="small"),
        "Column D": st.column_config.Column(width="small"),
        "Column E": st.column_config.Column(width="small"),
    },
)


if st.button("Create some elements to unmount component"):
    for _ in range(3):
        # The sleep here is needed, because it won't unmount the
        # component if this is too fast.
        time.sleep(1)
        st.write("Another element")


st.data_editor(random_df, num_rows="dynamic", key="data_editor")


cell_overlay_test_df = pd.DataFrame(
    {
        "big_numbers": [1231231.41, 12012],
        "text": ["hello\nworld", "foo"],
    }
)

cell_overlay_test_column_config = {
    # the e2e interaction testing logic requires all cells to medium
    # width to calculate the cell positions correctly.
    "big_numbers": st.column_config.NumberColumn(
        width="medium",
    ),
    "text": st.column_config.TextColumn(
        width="medium",
    ),
}


st.header("Test read-only cell overlay")
st.dataframe(
    cell_overlay_test_df, hide_index=True, column_config=cell_overlay_test_column_config
)

st.header("Test cell editor")

result = st.data_editor(
    cell_overlay_test_df, hide_index=True, column_config=cell_overlay_test_column_config
)

st.write("Edited DF:", str(result))

st.dataframe(fullscreen_df)


================================================
File: /e2e_playwright/st_dataframe_interactions_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import pytest
from playwright.sync_api import FrameLocator, Locator, Page, Route, expect

from e2e_playwright.conftest import IframedPage, ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import expect_prefixed_markdown, get_element_by_key
from e2e_playwright.shared.dataframe_utils import (
    calc_middle_cell_position,
    click_on_cell,
    expect_canvas_to_be_visible,
    get_open_cell_overlay,
)
from e2e_playwright.shared.toolbar_utils import (
    assert_fullscreen_toolbar_button_interactions,
)

# This test suite covers all interactions of dataframe & data_editor


def test_dataframe_toolbar_on_hover(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the toolbar is shown when hovering over a dataframe."""
    dataframe_element = themed_app.get_by_test_id("stDataFrame").nth(0)
    dataframe_toolbar = dataframe_element.get_by_test_id("stElementToolbar")

    # Check that it is currently not visible:
    expect(dataframe_toolbar).to_have_css("opacity", "0")

    # Hover over dataframe
    dataframe_element.hover()

    # Check that it is visible
    expect(dataframe_toolbar).to_have_css("opacity", "1")

    # Take a snapshot
    assert_snapshot(dataframe_toolbar, name="st_dataframe-toolbar")


def test_data_editor_toolbar_on_hover(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the toolbar is shown when hovering over a data editor component."""
    data_editor_element = themed_app.get_by_test_id("stDataFrame").nth(1)
    data_editor_toolbar = data_editor_element.get_by_test_id("stElementToolbar")

    # Check that it is currently not visible:
    expect(data_editor_toolbar).to_have_css("opacity", "0")

    # Hover over data editor:
    data_editor_element.hover()

    # Check that it is visible
    expect(data_editor_toolbar).to_have_css("opacity", "1")

    # Take a snapshot
    assert_snapshot(data_editor_toolbar, name="st_data_editor-toolbar")


def test_data_editor_delete_row_via_toolbar(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that a row can be deleted via the toolbar."""
    data_editor_element = themed_app.get_by_test_id("stDataFrame").nth(1)
    data_editor_toolbar = data_editor_element.get_by_test_id("stElementToolbar")

    expect_canvas_to_be_visible(data_editor_element)
    # Select the second row
    data_editor_element.click(position={"x": 10, "y": 100})
    # Take a snapshot to check if row is selected:
    assert_snapshot(
        data_editor_element, name="st_data_editor-selected_row_for_deletion"
    )
    expect(data_editor_element).to_have_css("height", "247px")

    # The toolbar should be locked (visible):
    expect(data_editor_toolbar).to_have_css("opacity", "1")
    # Take snapshot to check if trash icon is in toolbar:
    assert_snapshot(data_editor_toolbar, name="st_data_editor-row_deletion_toolbar")

    # Click row deletion button:
    delete_row_button = data_editor_toolbar.get_by_test_id(
        "stElementToolbarButton"
    ).nth(0)
    delete_row_button.click()
    # The height should reflect that one row is missing (247px-35px=212px):
    expect(data_editor_element).to_have_css("height", "212px")


def test_data_editor_delete_row_via_hotkey(app: Page):
    """Test that a row can be deleted via delete hotkey."""
    data_editor_element = app.get_by_test_id("stDataFrame").nth(1)
    expect(data_editor_element).to_have_css("height", "247px")

    # Select the second row
    data_editor_element.click(position={"x": 10, "y": 100})

    # Press backspace to delete row:
    data_editor_element.press("Delete")

    # The height should reflect that one row is missing (247px-35px=212px):
    expect(data_editor_element).to_have_css("height", "212px")


def test_data_editor_add_row_via_toolbar(app: Page):
    """Test that a row can be added via the toolbar."""
    data_editor_element = app.get_by_test_id("stDataFrame").nth(1)
    data_editor_toolbar = data_editor_element.get_by_test_id("stElementToolbar")
    expect(data_editor_element).to_have_css("height", "247px")

    # Activate toolbar:
    data_editor_element.hover()
    # Check that it is visible
    expect(data_editor_toolbar).to_have_css("opacity", "1")

    # Click add row button:
    add_row_button = data_editor_toolbar.get_by_test_id("stElementToolbarButton").nth(0)
    add_row_button.click()

    # The height should reflect that one row is added (247px+35px=282px):
    expect(data_editor_element).to_have_css("height", "282px")


def test_data_editor_add_row_via_trailing_row(app: Page):
    """Test that a row can be added by clicking on the trailing row."""
    data_editor_element = app.get_by_test_id("stDataFrame").nth(1)
    expect(data_editor_element).to_have_css("height", "247px")

    # Click on the trailing row:
    data_editor_element.click(position={"x": 40, "y": 220})

    # The height should reflect that one row is added (247px+35px=282px):
    expect(data_editor_element).to_have_css("height", "282px")


# Firefox seems to be unable to run this test. But I tested it manually
# to make sure that it works correctly.
@pytest.mark.skip_browser("firefox")
def test_dataframe_toolbar_on_toolbar_hover(app: Page):
    """Test that the toolbar is shown when hovering over the toolbar."""
    dataframe_element = app.get_by_test_id("stDataFrame").nth(0)
    dataframe_toolbar = dataframe_element.get_by_test_id("stElementToolbar")

    # Check that it is currently not visible:
    expect(dataframe_toolbar).to_have_css("opacity", "0")

    # Hover over dataframe toolbar itself (which is position)
    dataframe_toolbar.hover(force=True, position={"x": 0, "y": 0})

    # Check that it is visible
    expect(dataframe_toolbar).to_have_css("opacity", "1")


def test_open_search_via_toolbar(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that clicking on search toolbar button triggers dataframe search."""
    dataframe_element = themed_app.get_by_test_id("stDataFrame").nth(0)
    dataframe_toolbar = dataframe_element.get_by_test_id("stElementToolbar")
    search_toolbar_button = dataframe_toolbar.get_by_test_id(
        "stElementToolbarButton"
    ).nth(1)

    # Activate toolbar:
    dataframe_element.hover()
    # Check that it is visible
    expect(dataframe_toolbar).to_have_css("opacity", "1")

    # Hover search icon:
    search_toolbar_button.hover()
    # Test if tooltip works:
    expect(themed_app.get_by_test_id("stTooltipContent")).to_have_text("Search")
    # Take a screenshot to capture hover effect:
    assert_snapshot(dataframe_toolbar, name="st_dataframe-toolbar_hover_search")

    # Click on search button:
    search_toolbar_button.click()

    expect(themed_app.locator(".gdg-search-bar-inner")).to_be_visible()

    # Check that it is visible
    assert_snapshot(dataframe_element, name="st_dataframe-trigger_search_via_toolbar")


def test_open_search_via_hotkey(app: Page):
    """Test that the search can be opened via a hotkey."""
    dataframe_element = app.get_by_test_id("stDataFrame").nth(0)

    # Select a cell to focus the dataframe:
    click_on_cell(dataframe_element, 2, 3)

    # Press hotkey to open search:
    dataframe_element.press("Control+f")

    expect(app.locator(".gdg-search-bar-inner")).to_be_visible()


def test_clicking_on_fullscreen_toolbar_button(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that clicking on fullscreen toolbar button expands the dataframe into
    fullscreen."""

    assert_fullscreen_toolbar_button_interactions(
        app,
        assert_snapshot=assert_snapshot,
        widget_test_id="stDataFrame",
        filename_prefix="st_dataframe",
        nth=4,
    )


def test_data_editor_keeps_state_after_unmounting(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the data editor keeps state correctly after unmounting."""
    data_editor_element = app.get_by_test_id("stDataFrame").nth(1)
    data_editor_toolbar = data_editor_element.get_by_test_id("stElementToolbar")
    expect(data_editor_element).to_have_css("height", "247px")

    # Activate toolbar:
    data_editor_element.hover()
    # Check that it is visible
    expect(data_editor_toolbar).to_have_css("opacity", "1")

    # Click add row button:
    add_row_button = data_editor_toolbar.get_by_test_id("stElementToolbarButton").nth(0)
    add_row_button.click()

    # The height should reflect that one row is added (247px+35px=282px):
    expect(data_editor_element).to_have_css("height", "282px")
    # The added row will trigger a rerun after a bounce, so we need to wait
    # for the app to finish running before we unmount the component.
    wait_for_app_run(app, 500)

    # Click button to unmount the component:
    app.get_by_test_id("stButton").locator("button").click()
    wait_for_app_run(app, 4000)

    # Check the height again, the row should be still attached:
    expect(data_editor_element).to_have_css("height", "282px")

    # Take a screenshot after unmounting:
    assert_snapshot(
        data_editor_element,
        name="st_data_editor-after_unmounting",
    )


def _test_csv_download(
    page: Page,
    locator: FrameLocator | Locator,
    click_enter_on_file_picker: bool = False,
):
    dataframe_element = locator.get_by_test_id("stDataFrame").nth(0)
    dataframe_toolbar = dataframe_element.get_by_test_id("stElementToolbar")

    download_csv_toolbar_button = dataframe_toolbar.get_by_test_id(
        "stElementToolbarButton"
    ).first

    # Activate toolbar:
    dataframe_element.hover()
    # Check that it is visible
    expect(dataframe_toolbar).to_have_css("opacity", "1")

    with page.expect_download(timeout=10000) as download_info:
        download_csv_toolbar_button.click()

        # playwright does not support all fileaccess APIs yet (see this
        # issue: https://github.com/microsoft/playwright/issues/8850) This means we
        # don't know if the system dialog opened to pick a location (expect_file_chooser
        # does not work). So as a workaround, we wait for now and then press enter.
        if click_enter_on_file_picker:
            page.wait_for_timeout(1000)
            page.keyboard.press("Enter")

    download = download_info.value
    download_path = download.path()
    with open(download_path, encoding="UTF-8") as f:
        content = f.read()
        # the app uses a fixed seed, so the data is always the same. This is the reason
        # why we can check it here.
        some_row = (
            "1,-0.977277879876411,0.9500884175255894,-0.1513572082976979,"
            "-0.10321885179355784,0.41059850193837233"
        )
        # we usually try to avoid assert in playwright tests, but since we don't have to
        # wait for any UI interaction or DOM state, it's ok here
        assert some_row in content


def test_csv_download_button(
    app: Page, browser_name: str, browser_type_launch_args: dict
):
    """Test that the csv download button works.

    Note that the library we are using calls the file picker API to download the file.
    This is not supported in headless mode. Hence, the test triggers different code
    paths in the app depending on the browser and the launch arguments.
    """

    click_enter_on_file_picker = False

    # right now the filechooser will only be opened on Chrome. Maybe this will change in
    # the future and the check has to be updated; or maybe playwright will support the
    # file-access APIs better. In headless mode, the file-access API our csv-download
    # button uses under-the-hood does not work. So we monkey-patch it to throw an error
    # and trigger our alternative download logic.
    if browser_name == "chromium":
        if browser_type_launch_args.get("headless", False):
            click_enter_on_file_picker = True
        else:
            app.evaluate(
                """() => window.showSaveFilePicker = () => {
                    throw new Error('Monkey-patched showOpenFilePicker')
                }""",
            )
    _test_csv_download(app, app.locator("body"), click_enter_on_file_picker)


def test_csv_download_button_in_iframe(iframed_app: IframedPage):
    """Test that the csv download button works in an iframe.

    Based on the test behavior and the fact that we don't have to patch the
    'window.showSaveFilePicker' as in the test above, it seems that the fallback
    download method is used.
    """

    page: Page = iframed_app.page
    frame_locator: FrameLocator = iframed_app.open_app(None)

    _test_csv_download(page, frame_locator)


def test_csv_download_button_in_iframe_with_new_tab_host_config(
    iframed_app: IframedPage,
):
    """Test that the csv download button works in an iframe and the host-config enforced
    download in new tab.

    Based on the test behavior and the fact that we don't have to patch the
    'window.showSaveFilePicker' as in the test above,
    it seems that the fallback download method is used.
    If this ever changes, the host-config[enforceDownloadInNewTab] might not take any
    effect as it is only used in the fallback mechanism.
    """
    page: Page = iframed_app.page

    def fulfill_host_config_request(route: Route):
        response = route.fetch()
        result = response.json()
        result["enforceDownloadInNewTab"] = True
        route.fulfill(json=result)

    page.route("**/_stcore/host-config", fulfill_host_config_request)

    # ensure that the route interception works and we get the correct
    # enforceDownloadInNewTab config
    with page.expect_event(
        "response",
        lambda response: response.url.endswith("_stcore/host-config")
        and response.json()["enforceDownloadInNewTab"] is True,
        timeout=10000,
    ):
        frame_locator: FrameLocator = iframed_app.open_app(None)
        _test_csv_download(page, frame_locator)


def test_number_cell_read_only_overlay_formatting(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the number cell overlay is formatted correctly."""
    overlay_test_df = themed_app.get_by_test_id("stDataFrame").nth(2)
    expect_canvas_to_be_visible(overlay_test_df)
    # Click on the first cell of the table
    click_on_cell(overlay_test_df, 1, 0, double_click=True, column_width="medium")
    cell_overlay = get_open_cell_overlay(themed_app)
    # Get the (number) input element and check the value
    expect(cell_overlay.locator(".gdg-input")).to_have_attribute("value", "1231231.41")
    assert_snapshot(cell_overlay, name="st_dataframe-number_col_overlay")


def _test_number_cell_editing(
    themed_app: Page,
    assert_snapshot: ImageCompareFunction,
    *,
    skip_snapshot: bool = False,
):
    """Test that the number cell can be edited."""
    cell_overlay_test_df = themed_app.get_by_test_id("stDataFrame").nth(3)
    expect_canvas_to_be_visible(cell_overlay_test_df)

    # Click on the first cell of the table
    click_on_cell(cell_overlay_test_df, 1, 0, double_click=True, column_width="medium")
    cell_overlay = get_open_cell_overlay(themed_app)
    # On some browsers the cell content is highlighted, so we enforce it to make the
    # test consistent and stable across all browsers
    cell_overlay.click()
    cell_overlay.press("ControlOrMeta+A")

    # Get the (number) input element and check the value
    expect(cell_overlay.locator(".gdg-input")).to_have_attribute("value", "1231231.41")
    if not skip_snapshot:
        assert_snapshot(cell_overlay, name="st_data_editor-number_col_editor")

    # Change the value
    cell_overlay.locator(".gdg-input").fill("9876.54")
    # Press Enter to apply the change
    themed_app.keyboard.press("Enter")
    wait_for_app_run(themed_app)

    # Check if that the value was submitted
    expect_prefixed_markdown(themed_app, "Edited DF:", "9876.54", exact_match=False)


def test_number_cell_editing(themed_app: Page, assert_snapshot: ImageCompareFunction):
    _test_number_cell_editing(themed_app, assert_snapshot)


@pytest.mark.performance
def test_number_cell_editing_performance(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the number cell can be edited."""
    _test_number_cell_editing(app, assert_snapshot, skip_snapshot=True)


def test_text_cell_read_only_overlay_formatting(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the text cell overlay is formatted correctly."""
    overlay_test_df = themed_app.get_by_test_id("stDataFrame").nth(2)
    expect_canvas_to_be_visible(overlay_test_df)

    # Click on the first cell of the table
    click_on_cell(overlay_test_df, 1, 1, double_click=True, column_width="medium")
    cell_overlay = get_open_cell_overlay(themed_app)

    # Get the (text) input element and check the value
    expect(cell_overlay.locator(".gdg-input")).to_have_text("hello\nworld")
    assert_snapshot(cell_overlay, name="st_dataframe-text_col_overlay")


def test_text_cell_editing(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that the number cell can be edited."""
    cell_overlay_test_df = themed_app.get_by_test_id("stDataFrame").nth(3)
    expect_canvas_to_be_visible(cell_overlay_test_df)

    # Click on the first cell of the table
    click_on_cell(cell_overlay_test_df, 1, 1, double_click=True, column_width="medium")
    cell_overlay = get_open_cell_overlay(themed_app)

    # On some browsers the cell content is highlighted, so we enforce it to make the
    # test consistent and stable across all browsers
    cell_overlay.click()
    cell_overlay.press("ControlOrMeta+A")
    # Get the (number) input element and check the value
    expect(cell_overlay.locator(".gdg-input")).to_have_text("hello\nworld")
    assert_snapshot(cell_overlay, name="st_data_editor-text_col_editor")

    # Change the value
    cell_overlay.locator(".gdg-input").fill("edited value")
    # Press Enter to apply the change
    themed_app.keyboard.press("Enter")
    wait_for_app_run(themed_app)

    # Check if that the value was submitted
    expect_prefixed_markdown(
        themed_app, "Edited DF:", "edited value", exact_match=False
    )


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "data_editor")).to_be_visible()


def test_column_reorder_via_ui(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that columns can be reordered via drag and drop on the UI."""
    dataframe_element = app.get_by_test_id("stDataFrame").nth(0)
    expect_canvas_to_be_visible(dataframe_element)

    # 1. Move Column A behind Column C:

    # Calculate positions for source (Column A) and target (Column C) headers
    source_x, source_y = calc_middle_cell_position(0, 1, "small")  # Column A header
    target_x, target_y = calc_middle_cell_position(0, 3, "small")  # Column C header

    # Perform drag and drop using drag_to
    dataframe_element.drag_to(
        dataframe_element,
        source_position={"x": source_x, "y": source_y},
        target_position={"x": target_x, "y": target_y},
    )

    # 2. Move Column D in front of the index column:
    # This also tests that column D should get pinned since it is moved before a
    # pinned column (index column). This is visible via the grey text color.

    # Calculate positions for source (Column D) and target (Index column) headers
    source_x, source_y = calc_middle_cell_position(0, 4, "small")  # Column D header
    target_x, target_y = calc_middle_cell_position(0, 0, "small")  # Index column header

    # Perform drag and drop using drag_to
    dataframe_element.drag_to(
        dataframe_element,
        source_position={"x": source_x, "y": source_y},
        target_position={"x": target_x, "y": target_y},
    )

    # Verify column order changed by taking a screenshot
    assert_snapshot(
        dataframe_element,
        name="st_dataframe-reorder_columns_via_ui",
    )


def test_row_hover_highlight(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that a row gets highlighted when hovering over a cell in the row."""
    df = themed_app.get_by_test_id("stDataFrame").nth(0)
    expect_canvas_to_be_visible(df)
    column_middle_width_px, row_middle_height_px = calc_middle_cell_position(
        2, 2, "small"
    )
    df.hover(position={"x": column_middle_width_px, "y": row_middle_height_px})

    assert_snapshot(df, name="st_dataframe-row_hover_highlight")


# TODO(lukasmasuch): Add additional interactive tests:
# - Copy data to clipboard
# - Paste in data


================================================
File: /e2e_playwright/st_dataframe_selections.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import random
import time

import numpy as np
import pandas as pd

import streamlit as st

np.random.seed(0)
random.seed(0)

# Generate a random dataframe
df = pd.DataFrame(
    np.random.randn(5, 5),
    columns=("col_%d" % i for i in range(5)),
)

# set fixed column with so our pixel-clicks in the test are stable
column_with_fixed_width = st.column_config.Column(width="small")
column_config = {
    "_index": column_with_fixed_width,
    "col_0": column_with_fixed_width,
    "col_1": column_with_fixed_width,
    "col_2": column_with_fixed_width,
    "col_3": column_with_fixed_width,
    "col_4": column_with_fixed_width,
}

st.header("Row & column selections:")
st.subheader("single-row select")
selection = st.dataframe(
    df,
    hide_index=True,
    on_select="rerun",
    selection_mode="single-row",
    column_config=column_config,
)
st.write("Dataframe single-row selection:", str(selection))

st.subheader("single-column select")
selection = st.dataframe(
    df,
    hide_index=True,
    on_select="rerun",
    selection_mode="single-column",
    column_config=column_config,
)
st.write("Dataframe single-column selection:", str(selection))

st.subheader("multi-row select")
selection = st.dataframe(
    df,
    hide_index=True,
    on_select="rerun",
    selection_mode="multi-row",
    column_config=column_config,
)
st.write("Dataframe multi-row selection:", str(selection))

st.subheader("multi-column select")
selection = st.dataframe(
    df,
    hide_index=True,
    on_select="rerun",
    selection_mode="multi-column",
    column_config=column_config,
)
st.write("Dataframe multi-column selection:", str(selection))

if st.button("Create some elements to unmount component"):
    for _ in range(3):
        # The sleep here is needed, because it won't unmount the
        # component if this is too fast.
        time.sleep(1)
        st.write("Another element")

st.subheader("multi-row & multi-column select")
selection = st.dataframe(
    df,
    hide_index=True,
    on_select="rerun",
    selection_mode=["multi-row", "multi-column"],
    column_config=column_config,
)
st.write("Dataframe multi-row-multi-column selection:", str(selection))

st.header("Selections in form:")

with st.form(key="my_form", clear_on_submit=True):
    selection = st.dataframe(
        df,
        hide_index=True,
        on_select="rerun",
        selection_mode=["multi-row", "multi-column"],
        key="df_selection_in_form",
        column_config=column_config,
    )
    st.form_submit_button("Submit")

st.write("Dataframe-in-form selection:", str(selection))
if "df_selection_in_form" in st.session_state:
    st.write(
        "Dataframe-in-form selection in session state:",
        str(st.session_state.df_selection_in_form),
    )

st.header("Selection callback:")


def on_selection():
    st.write("Dataframe selection callback:", str(st.session_state.df_selection))


st.dataframe(
    df,
    hide_index=True,
    on_select=on_selection,
    selection_mode=["multi-row", "multi-column"],
    key="df_selection",
    column_config=column_config,
)

st.header("Selections in fragment:")


@st.fragment
def test_fragment():
    selection = st.dataframe(
        df,
        hide_index=True,
        on_select="rerun",
        selection_mode=["multi-row", "multi-column"],
        key="inside_fragment",
        column_config=column_config,
    )
    st.write("Dataframe-in-fragment selection:", str(selection))


test_fragment()

if "runs" not in st.session_state:
    st.session_state.runs = 0
st.session_state.runs += 1
st.write("Runs:", st.session_state.runs)

st.header("Dataframe with Index:")


selection = st.dataframe(
    df,
    hide_index=False,
    on_select="rerun",
    selection_mode=["multi-column"],
    key="with_index",
    column_config=column_config,
    column_order=["col_1", "col_3"],
)
st.write("No selection on index column:", str(selection))


================================================
File: /e2e_playwright/st_dataframe_selections_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import pytest
from playwright.sync_api import Locator, Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    COMMAND_KEY,
    click_form_button,
    expect_prefixed_markdown,
    get_element_by_key,
)
from e2e_playwright.shared.dataframe_utils import (
    calc_middle_cell_position,
    expect_canvas_to_be_visible,
    select_column,
    select_row,
    sort_column,
)


def _get_single_row_select_df(app: Page) -> Locator:
    return app.get_by_test_id("stDataFrame").nth(0)


def _get_single_column_select_df(app: Page) -> Locator:
    return app.get_by_test_id("stDataFrame").nth(1)


def _get_multi_row_select_df(app: Page) -> Locator:
    return app.get_by_test_id("stDataFrame").nth(2)


def _get_multi_column_select_df(app: Page) -> Locator:
    return app.get_by_test_id("stDataFrame").nth(3)


def _get_multi_row_and_column_select_df(app: Page) -> Locator:
    return app.get_by_test_id("stDataFrame").nth(4)


def _get_in_form_df(app: Page) -> Locator:
    return app.get_by_test_id("stDataFrame").nth(5)


def _get_callback_df(app: Page) -> Locator:
    return app.get_by_test_id("stDataFrame").nth(6)


def _get_fragment_df(app: Page) -> Locator:
    return app.get_by_test_id("stDataFrame").nth(7)


def _get_df_with_index(app: Page) -> Locator:
    return app.get_by_test_id("stDataFrame").nth(8)


def test_single_row_select(app: Page):
    canvas = _get_single_row_select_df(app)
    expect_canvas_to_be_visible(canvas)

    # select first row
    select_row(canvas, 1)
    wait_for_app_run(app)

    expected = (
        "Dataframe single-row selection: {'selection': {'rows': [0], 'columns': []}}"
    )
    selection_text = app.get_by_test_id("stMarkdownContainer").filter(has_text=expected)
    expect(selection_text).to_have_count(1)

    select_row(canvas, 2)
    wait_for_app_run(app)
    expect_prefixed_markdown(
        app,
        "Dataframe single-row selection:",
        "{'selection': {'rows': [1], 'columns': []}}",
    )


def test_single_row_select_with_sorted_column(app: Page):
    canvas = _get_single_row_select_df(app)
    expect_canvas_to_be_visible(canvas)

    # select first row
    select_row(canvas, 1)
    wait_for_app_run(app)
    # The dataframe is not sorted yet, so the first row is the first row:
    expected = (
        "Dataframe single-row selection: {'selection': {'rows': [0], 'columns': []}}"
    )
    selection_text = app.get_by_test_id("stMarkdownContainer").filter(has_text=expected)
    expect(selection_text).to_have_count(1)

    # Sort the first column
    # this is expected to clear the previous row selection:
    sort_column(canvas, 1, has_row_marker_col=True)
    wait_for_app_run(app)

    # The dataframe selection should be cleared
    expected = (
        "Dataframe single-row selection: {'selection': {'rows': [], 'columns': []}}"
    )
    selection_text = app.get_by_test_id("stMarkdownContainer").filter(has_text=expected)
    expect(selection_text).to_have_count(1)

    # select first row again:
    select_row(canvas, 1)
    wait_for_app_run(app)

    # The first row got selected, but the real numerical row index
    # should be different since the first column is sorted
    expected = (
        "Dataframe single-row selection: {'selection': {'rows': [4], 'columns': []}}"
    )
    selection_text = app.get_by_test_id("stMarkdownContainer").filter(has_text=expected)
    expect(selection_text).to_have_count(1)


def test_single_column_select(app: Page):
    canvas = _get_single_column_select_df(app)
    expect_canvas_to_be_visible(canvas)

    select_column(canvas, 1)
    wait_for_app_run(app)

    expect_prefixed_markdown(
        app,
        "Dataframe single-column selection:",
        "{'selection': {'rows': [], 'columns': ['col_1']}}",
        exact_match=True,
    )

    select_column(canvas, 2)
    wait_for_app_run(app)
    expect_prefixed_markdown(
        app,
        "Dataframe single-column selection:",
        "{'selection': {'rows': [], 'columns': ['col_2']}}",
        exact_match=True,
    )


def test_multi_row_select(app: Page):
    canvas = _get_multi_row_select_df(app)
    expect_canvas_to_be_visible(canvas)
    canvas.scroll_into_view_if_needed()

    select_row(canvas, 1)
    select_row(canvas, 3)
    wait_for_app_run(app)

    expect_prefixed_markdown(
        app,
        "Dataframe multi-row selection:",
        "{'selection': {'rows': [0, 2], 'columns': []}}",
        exact_match=True,
    )


def test_multi_row_select_all_at_once(app: Page):
    """Test that all rows are selected when clicking on the top-row checkbox."""
    canvas = _get_multi_row_select_df(app)
    expect_canvas_to_be_visible(canvas)

    select_row(canvas, 0)
    wait_for_app_run(app)

    expect_prefixed_markdown(
        app,
        "Dataframe multi-row selection:",
        "{'selection': {'rows': [0, 1, 2, 3, 4], 'columns': []}}",
        exact_match=True,
    )


def test_multi_row_by_keeping_mouse_pressed(app: Page):
    canvas = _get_multi_row_select_df(app)
    expect_canvas_to_be_visible(canvas)

    # we have to scroll into view, otherwise the bounding_box is not correct
    canvas.scroll_into_view_if_needed()
    bounding_box = canvas.bounding_box()
    assert bounding_box is not None
    canvas_start_x_px = bounding_box.get("x", 0)
    canvas_start_y_px = bounding_box.get("y", 0)
    x, y = calc_middle_cell_position(2, 0, has_row_marker_col=True)
    app.mouse.move(canvas_start_x_px + x, canvas_start_y_px + y)
    app.mouse.down()
    x, y = calc_middle_cell_position(4, 0, has_row_marker_col=True)
    app.mouse.move(canvas_start_x_px + x, canvas_start_y_px + y)
    app.mouse.up()

    expect_prefixed_markdown(
        app,
        "Dataframe multi-row selection:",
        "{'selection': {'rows': [1, 2, 3], 'columns': []}}",
        exact_match=True,
    )


def test_multi_column_select(app: Page):
    canvas = _get_multi_column_select_df(app)
    expect_canvas_to_be_visible(canvas)

    select_column(canvas, 1)
    app.keyboard.down(COMMAND_KEY)
    select_column(canvas, 3)
    select_column(canvas, 4)
    app.keyboard.up(COMMAND_KEY)
    wait_for_app_run(app)

    expect_prefixed_markdown(
        app,
        "Dataframe multi-column selection:",
        "{'selection': {'rows': [], 'columns': ['col_1', 'col_3', 'col_4']}}",
        exact_match=True,
    )


def _select_some_rows_and_columns(app: Page, canvas: Locator):
    select_row(canvas, 1)
    # Column 0 is the row marker column
    select_column(canvas, 2, has_row_marker_col=True)
    app.keyboard.down(COMMAND_KEY)
    select_column(canvas, 4, has_row_marker_col=True)
    select_column(canvas, 5, has_row_marker_col=True)
    app.keyboard.up(COMMAND_KEY)
    select_row(canvas, 3)
    wait_for_app_run(app)


def _expect_multi_row_multi_column_selection(app: Page):
    expect_prefixed_markdown(
        app,
        "Dataframe multi-row-multi-column selection:",
        "{'selection': {'rows': [0, 2], 'columns': ['col_1', 'col_3', 'col_4']}}",
        exact_match=True,
    )


def test_multi_row_and_multi_column_select(app: Page):
    canvas = _get_multi_row_and_column_select_df(app)
    expect_canvas_to_be_visible(canvas)

    _select_some_rows_and_columns(app, canvas)
    _expect_multi_row_multi_column_selection(app)


def test_clear_selection_via_escape(app: Page):
    canvas = _get_multi_row_and_column_select_df(app)
    expect_canvas_to_be_visible(canvas)

    _select_some_rows_and_columns(app, canvas)

    # make sure we have something selected before clearing it to avoid false-positives
    _expect_multi_row_multi_column_selection(app)

    app.keyboard.press("Escape")
    wait_for_app_run(app)

    expect_prefixed_markdown(
        app,
        "Dataframe multi-row-multi-column selection:",
        "{'selection': {'rows': [], 'columns': []}}",
        exact_match=True,
    )


def test_clear_selection_via_toolbar(app: Page):
    canvas = _get_multi_row_and_column_select_df(app)
    expect_canvas_to_be_visible(canvas)

    # toolbar has three buttons: download, search, fullscreen
    dataframe_toolbar = canvas.get_by_test_id("stElementToolbar")
    toolbar_buttons = dataframe_toolbar.get_by_test_id("stElementToolbarButton")
    expect(toolbar_buttons).to_have_count(3)

    _select_some_rows_and_columns(app, canvas)
    _expect_multi_row_multi_column_selection(app)
    # toolbar has one more button now: clear selection
    toolbar_buttons = dataframe_toolbar.get_by_test_id("stElementToolbarButton")
    expect(toolbar_buttons).to_have_count(4)
    # click on the clear-selection button which is the first in the toolbar
    toolbar_buttons.nth(0).click()
    wait_for_app_run(app)

    expect_prefixed_markdown(
        app,
        "Dataframe multi-row-multi-column selection:",
        "{'selection': {'rows': [], 'columns': []}}",
        exact_match=True,
    )


def test_in_form_selection_and_session_state(app: Page):
    canvas = _get_in_form_df(app)
    expect_canvas_to_be_visible(canvas)
    _select_some_rows_and_columns(app, canvas)

    _markdown_prefix = "Dataframe-in-form selection:"
    # nothing should be shown yet because we did not submit the form
    expect_prefixed_markdown(
        app,
        _markdown_prefix,
        "{'selection': {'rows': [], 'columns': []}}",
        exact_match=True,
    )

    # submit the form. The selection uses a debounce of 200ms; if we click too early,
    # the state is not updated correctly and we submit the old, unselected values
    app.wait_for_timeout(210)
    click_form_button(app, "Submit")

    expect_prefixed_markdown(
        app,
        _markdown_prefix,
        "{'selection': {'rows': [0, 2], 'columns': ['col_1', 'col_3', 'col_4']}}",
        exact_match=True,
    )

    expect_prefixed_markdown(
        app,
        "Dataframe-in-form selection in session state:",
        "{'selection': {'rows': [0, 2], 'columns': ['col_1', 'col_3', 'col_4']}}",
        exact_match=True,
    )


def test_multi_row_and_multi_column_selection_with_callback(app: Page):
    canvas = _get_callback_df(app)
    expect_canvas_to_be_visible(canvas)
    canvas.scroll_into_view_if_needed()
    _select_some_rows_and_columns(app, canvas)

    expect_prefixed_markdown(
        app,
        "Dataframe selection callback:",
        "{'selection': {'rows': [0, 2], 'columns': ['col_1', 'col_3', 'col_4']}}",
        exact_match=True,
    )


def test_multi_row_and_multi_column_select_snapshot(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Take a snapshot of multi-select to ensure visual consistency."""
    canvas = _get_multi_row_and_column_select_df(app)
    expect_canvas_to_be_visible(canvas)

    _select_some_rows_and_columns(app, canvas)
    _expect_multi_row_multi_column_selection(app)

    canvas.scroll_into_view_if_needed()
    assert_snapshot(canvas, name="st_dataframe-multi_row_multi_column_selection")


# Skip firefox since it takes a snapshot with a slightly different size
# compared to the one in the test_multi_row_and_multi_column_select_snapshot test
@pytest.mark.skip_browser("firefox")
def test_selection_state_remains_after_unmounting(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the selection state remains after unmounting the component."""
    canvas = _get_multi_row_and_column_select_df(app)
    expect_canvas_to_be_visible(canvas)

    _select_some_rows_and_columns(app, canvas)
    _expect_multi_row_multi_column_selection(app)

    # Click button to unmount the component
    app.get_by_test_id("stButton").locator("button").click()
    wait_for_app_run(app, 4000)

    expect(canvas).to_be_visible()
    # Check that the selection is still returned correctly
    _expect_multi_row_multi_column_selection(app)

    canvas.scroll_into_view_if_needed()
    # Use the same snapshot name as the previous test to ensure visual consistency
    assert_snapshot(canvas, name="st_dataframe-multi_row_multi_column_selection")


def test_multi_row_and_multi_column_selection_in_fragment(app: Page):
    canvas = _get_fragment_df(app)
    canvas.scroll_into_view_if_needed()
    expect(canvas).to_be_visible()
    _select_some_rows_and_columns(app, canvas)

    expect_prefixed_markdown(
        app,
        "Dataframe-in-fragment selection:",
        "{'selection': {'rows': [0, 2], 'columns': ['col_1', 'col_3', 'col_4']}}",
        exact_match=True,
    )

    # Check that the main script has run once (the initial run), but not after the
    # selection:
    expect(app.get_by_text("Runs: 1")).to_be_visible()


def test_that_index_cannot_be_selected(app: Page):
    canvas = _get_df_with_index(app)
    expect_canvas_to_be_visible(canvas)

    canvas.scroll_into_view_if_needed()
    # Try select a selectable columnÃ–
    select_column(canvas, 2)
    wait_for_app_run(app)

    # Check selection:
    expect_prefixed_markdown(
        app,
        "No selection on index column:",
        "{'selection': {'rows': [], 'columns': ['col_3']}}",
        exact_match=True,
    )

    # Select index column:
    select_column(canvas, 0)
    wait_for_app_run(app)

    # Nothing should be selected:
    expect_prefixed_markdown(
        app,
        "No selection on index column:",
        "{'selection': {'rows': [], 'columns': []}}",
        exact_match=True,
    )

    # Try to click on another column and check that in can be selected:
    select_column(canvas, 1)
    wait_for_app_run(app)

    # Check selection:
    expect_prefixed_markdown(
        app,
        "No selection on index column:",
        "{'selection': {'rows': [], 'columns': ['col_1']}}",
        exact_match=True,
    )


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "df_selection")).to_be_visible()


================================================
File: /e2e_playwright/st_dataframe_stable_rendering.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""This test checks that the dataframe component renders without crashing
when used in different containers.

This mainly addresses this issue: https://github.com/streamlit/streamlit/issues/7949
"""

import numpy as np
import pandas as pd

import streamlit as st

np.random.seed(0)
df = pd.DataFrame(np.random.randn(20, 5), columns=["a", "b", "c", "d", "e"])

use_container_width = st.toggle("use_container_width", True)

with st.popover("popover"):
    st.dataframe(df, use_container_width=use_container_width)

with st.sidebar:
    st.dataframe(df, use_container_width=use_container_width)

tab1, tab2 = st.tabs(["Tab 1", "Tab 2"])

col1, col2, col3 = tab1.columns([1, 2, 3])
col1.dataframe(df, use_container_width=use_container_width, height=100)
col2.dataframe(df, use_container_width=use_container_width, height=100)
col3.dataframe(df, use_container_width=use_container_width, height=100)

tab1.dataframe(df, use_container_width=use_container_width, height=100)
tab2.dataframe(df, use_container_width=use_container_width, height=100)


================================================
File: /e2e_playwright/st_dataframe_stable_rendering_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from playwright.sync_api import Page, expect

from e2e_playwright.conftest import wait_for_app_loaded
from e2e_playwright.shared.app_utils import click_toggle


def test_dataframe_renders_without_crashing(app: Page):
    """Test that st.dataframe renders without crashing."""

    # Reload the page a couple of times to make sure that the dataframe
    # crash doesn't appear.
    # This test is safeguarding against potential regressions that
    # cause crashes as report in: https://github.com/streamlit/streamlit/issues/7949
    # But these crashes are usually more random, thats why we run
    # it for a couple of page reloads.
    # Also, even if there are crashes, its not gurunteed that they will
    # happen in our CI environment.
    for _ in range(5):
        dataframe_elements = app.get_by_test_id("stDataFrame")
        expect(dataframe_elements).to_have_count(7)
        expect(app.get_by_test_id("stAlertContainer")).not_to_be_attached()

        # Set use_container_width to False:
        click_toggle(app, "use_container_width")
        dataframe_elements = app.get_by_test_id("stDataFrame")
        expect(dataframe_elements).to_have_count(7)
        expect(app.get_by_test_id("stAlertContainer")).not_to_be_attached()

        # Reload the page:
        app.reload()
        wait_for_app_loaded(app)


================================================
File: /e2e_playwright/st_dataframe_styler_support.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import random

import numpy as np
import pandas as pd

import streamlit as st

# Explicitly seed the RNG for deterministic results
np.random.seed(0)
random.seed(0)


st.header("Pandas Styler: Value formatting")
df = pd.DataFrame({"test": [3.1423424, 3.1]})
st.dataframe(df.style.format({"test": "{:.2f}"}))

st.header("Pandas Styler: Background color")


def highlight_first(value):
    return "background-color: yellow" if value == 0 else ""


df = pd.DataFrame(np.arange(0, 100, 1).reshape(10, 10))
st.dataframe(df.style.map(highlight_first))

st.header("Pandas Styler: Background and font styling")

df = pd.DataFrame(np.random.randn(20, 4), columns=["A", "B", "C", "D"])


def style_negative(v, props=""):
    return props if v < 0 else None


def highlight_max(s, props=""):
    return np.where(s == np.nanmax(s.values), props, "")


# Passing style values w/ all color formats to test css-style-string parsing robustness.
styled_df = df.style.map(style_negative, props="color:#FF0000;").map(
    lambda v: "opacity: 20%;" if (v < 0.3) and (v > -0.3) else None
)

styled_df.apply(
    highlight_max, props="color:white;background-color:rgb(255, 0, 0)", axis=0
)

styled_df.apply(
    highlight_max, props="color:white;background-color:hsl(273, 98%, 60%);", axis=1
).apply(highlight_max, props="color:white;background-color:purple", axis=None)

st.dataframe(styled_df)

st.header("Pandas Styler: Gradient Styling")

weather_df = pd.DataFrame(
    np.random.rand(10, 2) * 5,
    index=pd.date_range(start="2021-01-01", periods=10),
    columns=["Tokyo", "Beijing"],
)


def rain_condition(v):
    if v < 1.75:
        return "Dry"
    elif v < 2.75:
        return "Rain"
    return "Heavy Rain"


def make_pretty(styler):
    styler.set_caption("Weather Conditions")
    styler.format(rain_condition)
    styler.background_gradient(axis=None, vmin=1, vmax=5, cmap="YlGnBu")
    return styler


styled_df = weather_df.style.pipe(make_pretty)

st.dataframe(styled_df)

st.header("LinkColumn with display value:")
st.dataframe(
    pd.DataFrame(
        {
            "col_0": [
                "https://streamlit.io",
                "https://docs.streamlit.io",
                "https://streamlit.io/gallery",
                None,
            ]
        }
    ).style.format(lambda url: url.replace("https://", "Website: ") if url else ""),
    column_config={"col_0": st.column_config.LinkColumn()},
)

st.header("Column config takes prio over Pandas Styler")
st.dataframe(
    pd.DataFrame(
        {
            "number (formatted)": [1, 2, 3],
            "url (formatted)": [
                "https://streamlit.io",
                "https://docs.streamlit.io",
                "https://docs.streamlit.io",
            ],
            "datetime (formatted)": [
                pd.Timestamp("2024-01-01"),
                pd.Timestamp("2024-01-02"),
                pd.Timestamp("2024-01-03"),
            ],
            "text": ["foo", "bar", "foobar"],
            "number": [1, 2, 3],
            "url": [
                "https://streamlit.io",
                "https://docs.streamlit.io",
                "https://docs.streamlit.io",
            ],
            "datetime": [
                pd.Timestamp("2024-01-01"),
                pd.Timestamp("2024-01-02"),
                pd.Timestamp("2024-01-03"),
            ],
        }
    ).style.format(lambda v: "pd styler"),
    column_config={
        "number (formatted)": st.column_config.NumberColumn(format="$%.2f"),
        "url (formatted)": st.column_config.LinkColumn(display_text="Open"),
        "datetime (formatted)": st.column_config.DatetimeColumn(format="MMM DD, YYYY"),
        "number": st.column_config.NumberColumn(),
        "url": st.column_config.LinkColumn(),
        "datetime": st.column_config.DatetimeColumn(),
    },
    hide_index=True,
)


================================================
File: /e2e_playwright/st_dataframe_styler_support_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_dataframe_pd_styler(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.dataframe supports styling and display values via Pandas Styler."""
    elements = themed_app.get_by_test_id("stDataFrame")
    expect(elements).to_have_count(6)

    # The dataframe component might require a bit more time for rendering the canvas
    themed_app.wait_for_timeout(250)

    assert_snapshot(elements.nth(0), name="st_dataframe-styler_value_formatting")
    assert_snapshot(elements.nth(1), name="st_dataframe-styler_background_color")
    assert_snapshot(elements.nth(2), name="st_dataframe-styler_background_and_font")
    assert_snapshot(elements.nth(3), name="st_dataframe-styler_gradient")
    assert_snapshot(elements.nth(4), name="st_dataframe-styler_link_display_value")
    assert_snapshot(elements.nth(5), name="st_dataframe-column_config_over_styler")


================================================
File: /e2e_playwright/st_date_input.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from datetime import date, datetime

import streamlit as st
from streamlit import runtime

leading_indent_regular_text_tooltip = """
This is a regular text block!
Test1
Test2

"""

v1 = st.date_input(
    "Single date",
    date(1970, 1, 1),
    min_value=date(1970, 1, 1),
    help=leading_indent_regular_text_tooltip,
)
st.write("Value 1:", v1)

v2 = st.date_input("Single datetime", datetime(2019, 7, 6, 21, 15), help="Help text")
st.write("Value 2:", v2)

v3 = st.date_input("Range, no date", [])
st.write("Value 3:", v3)

v4 = st.date_input("Range, one date", [date(2019, 7, 6)])
st.write("Value 4:", v4)

v5 = st.date_input("Range, two dates", [date(2019, 7, 6), date(2019, 7, 8)])
st.write("Value 5:", v5)

v6 = st.date_input("Disabled, no date", [], disabled=True)
st.write("Value 6:", v6)

v7 = st.date_input(
    "Label hidden", datetime(2019, 7, 6, 21, 15), label_visibility="hidden"
)
st.write("Value 7:", v7)

v8 = st.date_input(
    "Label collapsed", datetime(2019, 7, 6, 21, 15), label_visibility="collapsed"
)
st.write("Value 8:", v8)

v9 = st.date_input("Single date with format", date(1970, 1, 1), format="MM-DD-YYYY")
st.write("Value 9:", v9)

v10 = st.date_input(
    "Range, two dates with format",
    [date(2019, 7, 6), date(2019, 7, 8)],
    format="MM/DD/YYYY",
)
st.write("Value 10:", v10)

v11 = st.date_input("Range, no date with format", [], format="DD.MM.YYYY")
st.write("Value 11:", v11)


if runtime.exists():

    def on_change():
        st.session_state.date_input_changed = True
        st.text("Date input changed callback")

    st.date_input(
        "Single date with callback",
        date(1970, 1, 1),
        min_value=date(1970, 1, 1),
        key="date_input_12",
        on_change=on_change,
    )
    st.write("Value 12:", st.session_state.date_input_12)
    st.write("Date Input Changed:", st.session_state.get("date_input_changed") is True)
    # Reset to False:
    st.session_state.date_input_changed = False

v13 = st.date_input("Empty value", value=None)
st.write("Value 13:", v13)

if "date_input_14" not in st.session_state:
    st.session_state["date_input_14"] = date(1970, 2, 3)

v14 = st.date_input(
    "Value from state",
    value=None,
    key="date_input_14",
)
st.write("Value 14:", v14)


================================================
File: /e2e_playwright/st_date_input_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    expect_help_tooltip,
    get_element_by_key,
)


def test_date_input_rendering(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.date_input renders correctly via screenshots matching."""
    date_widgets = themed_app.get_by_test_id("stDateInput")
    expect(date_widgets).to_have_count(14)

    assert_snapshot(date_widgets.nth(0), name="st_date_input-single_date")
    assert_snapshot(date_widgets.nth(1), name="st_date_input-single_datetime")
    assert_snapshot(date_widgets.nth(2), name="st_date_input-range_no_date")
    assert_snapshot(date_widgets.nth(3), name="st_date_input-range_one_date")
    assert_snapshot(date_widgets.nth(4), name="st_date_input-range_two_dates")
    assert_snapshot(date_widgets.nth(5), name="st_date_input-disabled_no_date")
    assert_snapshot(date_widgets.nth(6), name="st_date_input-label_hidden")
    assert_snapshot(date_widgets.nth(7), name="st_date_input-label_collapsed")
    assert_snapshot(date_widgets.nth(8), name="st_date_input-single_date_format")
    assert_snapshot(date_widgets.nth(9), name="st_date_input-range_two_dates_format")
    assert_snapshot(date_widgets.nth(10), name="st_date_input-range_no_date_format")
    assert_snapshot(date_widgets.nth(11), name="st_date_input-single_date_callback")
    assert_snapshot(date_widgets.nth(12), name="st_date_input-empty_value")
    assert_snapshot(date_widgets.nth(13), name="st_date_input-value_from_state")


def test_help_tooltip_works(app: Page):
    leading_indent_regular_text_tooltip = """
    This is a regular text block!
    Test1
    Test2

    """
    element_with_help = app.get_by_test_id("stDateInput").nth(0)
    expect_help_tooltip(app, element_with_help, leading_indent_regular_text_tooltip)


def test_date_input_has_correct_initial_values(app: Page):
    """Test that st.date_input has the correct initial values."""
    markdown_elements = app.get_by_test_id("stMarkdown")
    expect(markdown_elements).to_have_count(15)

    expected = [
        "Value 1: 1970-01-01",
        "Value 2: 2019-07-06",
        "Value 3: ()",
        "Value 4: (datetime.date(2019, 7, 6),)",
        "Value 5: (datetime.date(2019, 7, 6), datetime.date(2019, 7, 8))",
        "Value 6: ()",
        "Value 7: 2019-07-06",
        "Value 8: 2019-07-06",
        "Value 9: 1970-01-01",
        "Value 10: (datetime.date(2019, 7, 6), datetime.date(2019, 7, 8))",
        "Value 11: ()",
        "Value 12: 1970-01-01",
        "Date Input Changed: False",
        "Value 13: None",
        "Value 14: 1970-02-03",
    ]

    for markdown_element, expected_text in zip(markdown_elements.all(), expected):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_handles_date_selection(app: Page):
    """Test that selection of a date on the calendar works as expected."""
    app.get_by_test_id("stDateInput").first.click()

    # Select '1970/01/02':
    app.locator(
        '[data-baseweb="calendar"] [aria-label^="Choose Friday, January 2nd 1970."]'
    ).first.click()

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "Value 1: 1970-01-02", use_inner_text=True
    )


def test_handle_value_changes(app: Page):
    """Test that st.date_input has the correct value after typing in a date."""

    first_date_input_field = app.get_by_test_id("stDateInput").first.locator("input")
    first_date_input_field.fill("1970/01/02")
    first_date_input_field.blur()

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "Value 1: 1970-01-02", use_inner_text=True
    )


def test_empty_date_input_behaves_correctly(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.date_input behaves correctly when empty."""
    # Enter 10 in the first empty input:
    empty_number_input = app.get_by_test_id("stDateInput").nth(12).locator("input")
    empty_number_input.type("1970/01/02", delay=50)
    empty_number_input.press("Enter")
    wait_for_app_run(app)
    expect(app.get_by_test_id("stMarkdown").nth(13)).to_have_text(
        "Value 13: 1970-01-02", use_inner_text=True
    )

    # Click outside to remove focus:
    app.get_by_test_id("stMarkdown").nth(13).click()

    # Screenshot match clearable input:
    assert_snapshot(
        app.get_by_test_id("stDateInput").nth(12),
        name="st_date_input-clearable_input",
        image_threshold=0.035,
    )

    # Press escape to clear value:
    empty_number_input = app.get_by_test_id("stDateInput").nth(12).locator("input")
    empty_number_input.focus()
    empty_number_input.press("Escape")
    # Click outside to enter value:
    app.get_by_test_id("stMarkdown").nth(13).click()

    # Should be empty again:
    expect(app.get_by_test_id("stMarkdown").nth(13)).to_have_text(
        "Value 13: None", use_inner_text=True
    )


def test_handles_range_end_date_changes(app: Page):
    """Test that it correctly handles changes to the end date of a range."""
    app.get_by_test_id("stDateInput").nth(3).click()

    # Select '2019/07/10'
    app.locator(
        '[data-baseweb="calendar"] [aria-label^="Choose Wednesday, July 10th 2019."]'
    ).first.click()

    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text(
        "Value 4: (datetime.date(2019, 7, 6), datetime.date(2019, 7, 10))",
        use_inner_text=True,
    )


def test_handles_range_start_end_date_changes(app: Page):
    """Test that it correctly handles changes to the start and end date of a range."""
    app.get_by_test_id("stDateInput").nth(4).click()

    # Select start date: '2019/07/10'
    app.locator(
        '[data-baseweb="calendar"] [aria-label^="Choose Wednesday, July 10th 2019."]'
    ).first.click()

    expect(app.get_by_test_id("stMarkdown").nth(4)).to_have_text(
        "Value 5: (datetime.date(2019, 7, 10),)",
        use_inner_text=True,
    )

    # Select end date: '2019/07/12'
    app.locator(
        '[data-baseweb="calendar"] [aria-label^="Choose Friday, July 12th 2019."]'
    ).first.click()

    expect(app.get_by_test_id("stMarkdown").nth(4)).to_have_text(
        "Value 5: (datetime.date(2019, 7, 10), datetime.date(2019, 7, 12))",
        use_inner_text=True,
    )


def test_calls_callback_on_change(app: Page):
    """Test that it correctly calls the callback on change."""
    app.get_by_test_id("stDateInput").nth(11).click()

    # Select '1970/01/02'
    calendar = app.locator(
        '[data-baseweb="calendar"] [aria-label^="Choose Friday, January 2nd 1970."]'
    ).first
    expect(calendar).to_be_visible()
    calendar.click()
    wait_for_app_run(app)

    value_12_element = app.get_by_test_id("stMarkdown").nth(11)
    expect(value_12_element).to_have_text(
        "Value 12: 1970-01-02",
        use_inner_text=True,
    )
    expect(app.get_by_test_id("stMarkdown").nth(12)).to_have_text(
        "Date Input Changed: True",
        use_inner_text=True,
    )

    # Change different date input to trigger delta path change
    first_date_input_field = app.get_by_test_id("stDateInput").first.locator("input")
    first_date_input_field.fill("1971/01/03")
    wait_for_app_run(app)

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "Value 1: 1971-01-03", use_inner_text=True
    )

    # Test if value is still correct after delta path change
    expect(value_12_element).to_have_text(
        "Value 12: 1970-01-02",
        use_inner_text=True,
    )
    expect(app.get_by_test_id("stMarkdown").nth(12)).to_have_text(
        "Date Input Changed: False",
        use_inner_text=True,
    )


def test_single_date_calendar_picker_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the single value calendar picker renders correctly via screenshots matching."""
    themed_app.get_by_test_id("stDateInput").first.click()
    assert_snapshot(
        themed_app.locator('[data-baseweb="calendar"]').first,
        name="st_date_input-single_date_calendar",
    )


def test_range_date_calendar_picker_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the range calendar picker renders correctly via screenshots matching."""
    themed_app.get_by_test_id("stDateInput").nth(4).click()
    assert_snapshot(
        themed_app.locator('[data-baseweb="calendar"]').first,
        name="st_date_input-range_two_dates_calendar",
    )


def test_resets_to_default_single_value_if_calendar_closed_empty(app: Page):
    """Test that single value is reset to default if calendar closed empty."""
    app.get_by_test_id("stDateInput").first.click()

    # Select '1970/01/02'
    app.locator(
        '[data-baseweb="calendar"] [aria-label^="Choose Friday, January 2nd 1970."]'
    ).first.click()

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "Value 1: 1970-01-02", use_inner_text=True
    )

    # Close calendar without selecting a date
    date_input_field = app.get_by_test_id("stDateInput").first.locator("input")
    date_input_field.focus()
    date_input_field.clear()

    # Click outside of the calendar to submit value
    app.get_by_test_id("stMarkdown").first.click(delay=100)

    # Value should be reset to default
    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "Value 1: 1970-01-01", use_inner_text=True
    )


def test_range_is_empty_if_calendar_closed_empty(app: Page):
    """Test that range value is empty of calendar closed empty."""
    app.get_by_test_id("stDateInput").nth(4).click()

    # Select start date: '2019/07/10'
    app.locator(
        '[data-baseweb="calendar"] [aria-label^="Choose Wednesday, July 10th 2019."]'
    ).first.click()

    expect(app.get_by_test_id("stMarkdown").nth(4)).to_have_text(
        "Value 5: (datetime.date(2019, 7, 10),)",
        use_inner_text=True,
    )

    # Select end date: '2019/07/12'
    app.locator(
        '[data-baseweb="calendar"] [aria-label^="Choose Friday, July 12th 2019."]'
    ).first.click()

    expect(app.get_by_test_id("stMarkdown").nth(4)).to_have_text(
        "Value 5: (datetime.date(2019, 7, 10), datetime.date(2019, 7, 12))",
        use_inner_text=True,
    )

    # Close calendar without selecting a date
    date_input_field = app.get_by_test_id("stDateInput").nth(4).locator("input")
    date_input_field.focus()
    date_input_field.clear()

    # Click outside of the calendar to submit value
    app.get_by_test_id("stMarkdown").nth(4).click()

    # Range should be empty
    expect(app.get_by_test_id("stMarkdown").nth(4)).to_have_text(
        "Value 5: ()",
        use_inner_text=True,
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stDateInput")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "date_input_12")).to_be_visible()


================================================
File: /e2e_playwright/st_dialog.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time

import numpy as np
import pandas as pd

import streamlit as st
from streamlit.runtime.scriptrunner_utils.script_run_context import get_script_run_ctx

np.random.seed(0)
data = np.random.randint(low=0, high=20, size=(20, 3))


@st.dialog("Test Dialog with Images")
def dialog_with_images():
    st.write("Hello!")
    st.slider("Slide me!", 0, 10)

    # render a dataframe
    st.dataframe(
        pd.DataFrame(np.zeros((1000, 6)), columns=["A", "B", "C", "D", "E", "F"])
    )

    st.subheader("Images", help="Some images are generated")
    # render multiple images. This will make the Close button to go out of
    # screen and allows scrollability of the dialog
    for _ in range(0, 3):
        st.image(np.repeat(0, 1000000).reshape(1000, 1000))

    if st.button("Submit", key="dialog-btn"):
        st.rerun()


if st.button("Open Dialog with Images"):
    dialog_with_images()


@st.dialog("Simple Dialog")
def simple_dialog():
    st.write("Hello again!")
    st.text_input("Enter something!")

    if st.button("Submit", key="dialog2-btn"):
        st.rerun()


if st.button("Open Dialog without Images"):
    simple_dialog()


@st.dialog("Large-width Dialog", width="large")
def large_width_dialog():
    st.write("This dialog has a large width.")

    if st.button("Submit", key="dialog4-btn"):
        st.rerun()


if st.button("Open large-width Dialog"):
    large_width_dialog()


@st.dialog("Dialog with headings")
def headings_dialog():
    st.header("Header", help="Some tooltip!")


if st.button("Open headings Dialog"):
    headings_dialog()

# We use this dialog for a screenshot test as loading images via the browser
# is non-deterministic
with st.sidebar:

    @st.dialog("Simple Dialog in Sidebar")
    def dialog_in_sidebar():
        st.write("Hello sidebar dialog!")

        if st.button("Submit", key="dialog5-btn"):
            st.rerun()

    if st.button("Open Sidebar-Dialog"):
        dialog_in_sidebar()


@st.dialog("Submit-button Dialog")
def submit_button_dialog():
    st.write("This dialog has a submit button.")
    st.write(f"Fragment Id: {get_script_run_ctx().current_fragment_id}")

    if st.button("Submit", key="dialog6-btn"):
        st.rerun()


if st.button("Open submit-button Dialog"):
    submit_button_dialog()


@st.dialog("Level2 Dialog")
def level2_dialog():
    st.write("Second level dialog")


@st.dialog("Level1 Dialog")
def level1_dialog():
    st.write("First level dialog")
    st.write(f"Fragment Id: {get_script_run_ctx().current_fragment_id}")
    level2_dialog()


if st.button("Open Nested Dialogs"):
    level1_dialog()


@st.dialog("Dialog with error")
def dialog_with_error():
    with st.form(key="forecast_form"):
        # key is an invalid argument, so this shows an error
        st.form_submit_button("Submit", key="foo")


if st.button("Open Dialog with Key Error"):
    dialog_with_error()


@st.dialog("Dialog with copy buttons")
def dialog_with_copy_buttons():
    st.json([1, 2, 3])

    copied_text = st.text_input("Enter copied text")
    st.write(copied_text)


if st.button("Open Dialog with Copy Buttons"):
    dialog_with_copy_buttons()


@st.experimental_dialog("Usage of deprecated experimental_dialog")
def dialog_with_deprecation_warning():
    pass  # No need to write anything in the dialog body.


if st.button("Open Dialog with deprecation warning"):
    dialog_with_deprecation_warning()


@st.fragment()
def fragment():
    if st.button("Fragment Button"):
        st.write("Fragment Button clicked")


fragment()


@st.dialog("Dialog with chart")
def dialog_with_chart():
    st.write("This dialog has a chart")
    st.bar_chart(pd.DataFrame(data, columns=["a", "b", "c"]))


if st.button("Open Chart Dialog"):
    dialog_with_chart()


@st.dialog("Dialog with dataframe")
def dialog_with_dataframe():
    st.dataframe(pd.DataFrame(data, columns=["a", "b", "c"]), use_container_width=True)


if st.button("Open Dialog with dataframe"):
    dialog_with_dataframe()


@st.dialog("Dialog with rerun")
def dialog_with_rerun():
    if st.button("Close Dialog"):
        time.sleep(0.15)
        st.rerun()


if st.button("Open Dialog with rerun"):
    dialog_with_rerun()


================================================
File: /e2e_playwright/st_dialog_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

import pytest
from playwright.sync_api import Page, expect
from playwright.sync_api import TimeoutError as PlaywrightTimeoutError

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    COMMAND_KEY,
    check_top_level_class,
    click_button,
    expect_exception,
    expect_markdown,
    expect_no_exception,
    get_button,
    get_markdown,
)

modal_test_id = "stDialog"


def open_dialog_with_images(app: Page):
    click_button(app, "Open Dialog with Images")


def open_dialog_without_images(app: Page, *, delay: int = 0):
    click_button(app, "Open Dialog without Images")


def open_largewidth_dialog(app: Page):
    click_button(app, "Open large-width Dialog")


def open_headings_dialogs(app: Page):
    click_button(app, "Open headings Dialog")


def open_sidebar_dialog(app: Page):
    click_button(app, "Open Sidebar-Dialog")


def open_dialog_with_internal_error(app: Page):
    click_button(app, "Open Dialog with Key Error")


def open_nested_dialogs(app: Page):
    click_button(app, "Open Nested Dialogs")


def open_submit_button_dialog(app: Page):
    click_button(app, "Open submit-button Dialog")


def open_dialog_with_copy_buttons(app: Page):
    click_button(app, "Open Dialog with Copy Buttons")


def open_dialog_with_deprecation_warning(app: Page):
    click_button(app, "Open Dialog with deprecation warning")


def open_dialog_with_chart(app: Page):
    click_button(app, "Open Chart Dialog")


def open_dialog_with_rerun(app: Page):
    click_button(app, "Open Dialog with rerun")


def click_to_dismiss(app: Page):
    # Click somewhere outside the close popover container:
    app.keyboard.press("Escape")


def test_displays_dialog_properly(app: Page):
    """Test that dialog is displayed properly."""
    open_dialog_with_images(app)
    wait_for_app_run(app)
    main_dialog = app.get_by_test_id(modal_test_id)
    expect(main_dialog).to_have_count(1)

    # Verify that we don't print a deprecation warning for usage of @st.dialog. We check
    # that a warning is printed for @st.experimental_dialog in a later test.
    expect(app.get_by_test_id("stAlert")).not_to_be_attached()


def _test_dialog_closes_properly(app: Page):
    """Test that dialog closes after clicking on action button."""
    open_dialog_with_images(app)
    wait_for_app_run(app)
    main_dialog = app.get_by_test_id(modal_test_id)
    expect(main_dialog).to_have_count(1)
    close_button = main_dialog.get_by_test_id("stButton").locator("button").first
    close_button.scroll_into_view_if_needed()
    close_button.click()
    wait_for_app_run(app)
    main_dialog = app.get_by_test_id(modal_test_id)
    expect(main_dialog).to_have_count(0)


def test_dialog_closes_properly(app: Page):
    """Test that dialog closes after clicking on action button."""
    _test_dialog_closes_properly(app)


@pytest.mark.performance
def test_dialog_open_and_close_performance(app: Page):
    _test_dialog_closes_properly(app)


def test_dialog_dismisses_properly(app: Page):
    """Test that dialog is dismissed properly after clicking on close (= dismiss)."""
    open_dialog_with_images(app)
    wait_for_app_run(app)
    main_dialog = app.get_by_test_id(modal_test_id)
    expect(main_dialog).to_have_count(1)

    click_to_dismiss(app)
    expect(main_dialog).not_to_be_visible()
    main_dialog = app.get_by_test_id(modal_test_id)
    expect(main_dialog).to_have_count(0)


def test_dialog_reopens_properly_after_dismiss(app: Page):
    """Test that dialog reopens after dismiss."""

    # open and close the dialog multiple times
    for _ in range(0, 10):
        open_dialog_without_images(app)
        wait_for_app_run(app)

        main_dialog = app.get_by_test_id(modal_test_id)
        expect(main_dialog).to_have_count(1)

        click_to_dismiss(app)
        expect(main_dialog).not_to_be_attached()

        main_dialog = app.get_by_test_id(modal_test_id)
        expect(main_dialog).to_have_count(0)


def test_dialog_reopens_properly_after_close(app: Page):
    """Test that dialog reopens properly after closing by action button click."""
    # open and close the dialog multiple times
    for _ in range(0, 5):
        open_dialog_with_images(app)

        wait_for_app_run(app, wait_delay=250)
        main_dialog = app.get_by_test_id(modal_test_id)

        expect(main_dialog).to_have_count(1)
        close_button = main_dialog.get_by_test_id("stButton").locator("button").first
        close_button.scroll_into_view_if_needed()
        close_button.click()
        wait_for_app_run(app, wait_delay=250)
        main_dialog = app.get_by_test_id(modal_test_id)
        expect(main_dialog).to_have_count(0)


def test_dialog_stays_dismissed_when_interacting_with_different_fragment(app: Page):
    """Dismissing a dialog is a UI-only interaction as of today (the Python backend does
    not know about this). We use a deltaMsgReceivedAt to differentiate React renders
    for dialogs triggered via a new backend message which changes the id vs. other
    interactions. This test ensures that the dialog stays dismissed when interacting
    with a different fragment.
    """

    open_dialog_without_images(app)
    wait_for_app_run(app)

    main_dialog = app.get_by_test_id(modal_test_id)
    expect(main_dialog).to_have_count(1)

    click_to_dismiss(app)
    expect(main_dialog).not_to_be_attached()

    main_dialog = app.get_by_test_id(modal_test_id)
    expect(main_dialog).to_have_count(0)

    # interact with unrelated fragment
    click_button(app, "Fragment Button")
    expect_markdown(app, "Fragment Button clicked")

    # dialog is still closed and did not reopen
    main_dialog = app.get_by_test_id(modal_test_id)
    expect(main_dialog).to_have_count(0)

    # reopen dialog
    open_dialog_without_images(app)
    wait_for_app_run(app)

    main_dialog = app.get_by_test_id(modal_test_id)
    expect(main_dialog).to_have_count(1)


def test_dialog_is_scrollable(app: Page):
    """Test that the dialog is scrollable"""
    open_dialog_with_images(app)
    wait_for_app_run(app)
    main_dialog = app.get_by_test_id(modal_test_id)
    close_button = main_dialog.get_by_test_id("stButton")
    expect(close_button).not_to_be_in_viewport()
    close_button.scroll_into_view_if_needed()
    expect(close_button).to_be_in_viewport()


def test_fullscreen_is_disabled_for_dialog_elements(app: Page):
    """Test that elements within the dialog do not show the fullscreen option."""
    open_dialog_with_images(app)
    wait_for_app_run(app)
    main_dialog = app.get_by_test_id(modal_test_id)
    expect(main_dialog).to_have_count(1)

    # check that the dataframe does not have the fullscreen button
    dataframe_toolbar = app.get_by_test_id("stElementToolbarButton")
    # 2 elements are in the toolbar as of today: download, search
    expect(dataframe_toolbar).to_have_count(2)


def test_actions_for_dialog_headings(app: Page):
    """Test that dialog headings show the tooltip icon but not the link icon."""
    open_headings_dialogs(app)
    wait_for_app_run(app)
    main_dialog = app.get_by_test_id(modal_test_id)
    expect(main_dialog).to_have_count(1)

    # check that the actions-element is there
    action_elements = app.get_by_test_id("stHeaderActionElements")
    expect(action_elements).to_have_count(1)

    # check that the tooltip icon is there and hoverable
    tooltip_element = action_elements.get_by_test_id("stTooltipIcon")
    expect(tooltip_element).to_have_count(1)
    tooltip_element.hover()
    expect(app.get_by_text("Some tooltip!")).to_be_visible()

    # check that the link-icon does not exist
    expect(tooltip_element.locator("a")).not_to_be_attached()


def test_dialog_displays_correctly(app: Page, assert_snapshot: ImageCompareFunction):
    open_dialog_without_images(app)
    wait_for_app_run(app)
    dialog = app.get_by_role("dialog")
    # click on the dialog title to take away focus of all elements and make the
    # screenshot stable. Then hover over the button for visual effect.
    dialog.locator("div", has_text="Simple Dialog").click()
    submit_button = get_button(dialog, "Submit")
    submit_button.hover()
    assert_snapshot(dialog, name="st_dialog-default")


def test_largewidth_dialog_displays_correctly(
    app: Page, assert_snapshot: ImageCompareFunction
):
    open_largewidth_dialog(app)
    wait_for_app_run(app)
    dialog = app.get_by_role("dialog")
    # click on the dialog title to take away focus of all elements and make the
    # screenshot stable. Then hover over the button for visual effect.
    dialog.locator("div", has_text="Large-width Dialog").click()
    submit_button = get_button(dialog, "Submit")
    submit_button.hover()
    assert_snapshot(dialog, name="st_dialog-with_large_width")


# its enough to test this on one browser as showing the error inline is more a backend
# functionality than a frontend one
@pytest.mark.only_browser("chromium")
def test_dialog_shows_error_inline(app: Page, assert_snapshot: ImageCompareFunction):
    """Additional check to the unittests we have to ensure errors thrown during the main
    script execution (not a fragment-only rerun) are rendered within the dialog."""
    open_dialog_with_internal_error(app)
    wait_for_app_run(app)
    dialog = app.get_by_role("dialog")
    # click on the dialog title to take away focus of all elements and make the
    # screenshot stable. Then hover over the button for visual effect.
    dialog.locator("div", has_text="Dialog with error").click()
    expect(dialog.get_by_text("TypeError")).to_be_visible()
    assert_snapshot(dialog, name="st_dialog-with_inline_error")


def test_sidebar_dialog_displays_correctly(
    app: Page, assert_snapshot: ImageCompareFunction
):
    open_sidebar_dialog(app)
    wait_for_app_run(app, wait_delay=200)
    dialog = app.get_by_role("dialog")
    submit_button = get_button(dialog, "Submit")
    submit_button.hover()
    assert_snapshot(dialog, name="st_dialog-in_sidebar")


def test_nested_dialogs(app: Page):
    """Test that st.dialog may not be nested inside other dialogs."""
    open_nested_dialogs(app)
    wait_for_app_run(app)
    expect_exception(
        app, "StreamlitAPIException: Dialogs may not be nested inside other dialogs."
    )


# on webkit this test was flaky and manually reproducing the flaky error did not work,
# so we skip it for now
@pytest.mark.skip_browser("webkit")
def test_dialogs_have_different_fragment_ids(app: Page):
    """Test that st.dialog may not be nested inside other dialogs."""
    open_submit_button_dialog(app)
    wait_for_app_run(app)
    large_width_dialog_fragment_id = get_markdown(app, "Fragment Id:").text_content()
    dialog = app.get_by_role("dialog")
    submit_button = get_button(dialog, "Submit")
    submit_button.click()
    wait_for_app_run(app)

    open_nested_dialogs(app)
    wait_for_app_run(app)
    nested_dialog_fragment_id = get_markdown(app, "Fragment Id:").text_content()
    expect_exception(
        app, "StreamlitAPIException: Dialogs may not be nested inside other dialogs."
    )

    click_to_dismiss(app)
    # wait after dismiss so that we can open the next dialog
    app.wait_for_timeout(1000)
    expect(app.get_by_test_id(modal_test_id)).not_to_be_attached()
    open_submit_button_dialog(app)
    wait_for_app_run(app)
    dialog = app.get_by_role("dialog")

    submit_button = get_button(dialog, "Submit")
    submit_button.click()
    wait_for_app_run(app)

    expect_no_exception(app)

    assert large_width_dialog_fragment_id != nested_dialog_fragment_id


def test_dialog_copy_buttons_work(app: Page):
    """Test that the copy buttons in the dialog work as expected.

    We paste the copied content into an input field. We could use
    playwright's app.evaluate("navigator.clipboard.readText()") to get
    the copied text, but then we have to grant permission to the user
    agent to allow accessing the clipboard.
    """

    open_dialog_with_copy_buttons(app)
    wait_for_app_run(app)

    expect(app.get_by_test_id("stMarkdown")).to_have_text("")

    # click icon button
    json_element = app.get_by_test_id("stJson")
    json_element.hover()
    json_element.locator(".copy-icon").first.click()

    # paste the copied content into the input field
    app.get_by_test_id("stTextInput").locator("input").click()
    app.keyboard.press(f"{COMMAND_KEY}+V")
    app.keyboard.press("Enter")

    # we should see the pasted content written to the dialog
    expect(app.get_by_test_id("stMarkdown")).to_have_text("[1,2,3]")


def test_experimental_dialog_deprecation_warning(app: Page):
    """Test that using @st.experimental_dialog instead of @st.dialog results in a
    deprecation warning being displayed in the dialog.
    """
    expect(app.get_by_test_id("stAlert")).not_to_be_attached()

    open_dialog_with_deprecation_warning(app)

    expect(app.get_by_test_id("stAlert")).to_have_text(
        re.compile("Please replace st.experimental_dialog with st.dialog.\n.*")
    )


def test_dialog_with_chart(app: Page):
    open_dialog_with_chart(app)
    wait_for_app_run(app)
    main_dialog = app.get_by_test_id(modal_test_id)
    expect(main_dialog).to_have_count(1)

    # Check for the chart & tooltip
    chart = main_dialog.get_by_test_id("stVegaLiteChart")
    chart.hover(position={"x": 60, "y": 220})
    tooltip = app.locator("#vg-tooltip-element")
    expect(tooltip).to_be_visible()


def test_dialog_with_dataframe_shows_toolbar(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Check that the dataframe toolbar is fully visible when hovering over
    the dataframe."""
    click_button(app, "Open Dialog with dataframe")
    dialog = app.get_by_role("dialog")
    expect(dialog).to_be_visible()
    df_element = dialog.get_by_test_id("stDataFrame")
    expect(df_element).to_be_visible()
    df_element.hover(force=True)
    df_toolbar = df_element.get_by_test_id("stElementToolbar")
    expect(df_toolbar).to_have_css("opacity", "1")
    expect(df_toolbar).to_be_visible()
    assert_snapshot(df_toolbar, name="st_dialog-shows_full_dataframe_toolbar")


def test_dialog_with_rerun_closes_even_if_button_is_clicked_multiple_times(app: Page):
    """Check that the dialog closes even if the button that calls st.rerun is clicked
    multiple times in fast succession. We want to test this since the button click and
    the st.rerun trigger fragment reruns and full app reruns, respectively. We want
    to ensure that the dialog closes in both cases and fragment-rerun messages do not
    interfere with the full app rerun (finished messages). If they would, we have
    observed the dialog to stay open and never closer again. So this test is more about
    sanity-checking the interplay of fragment runs and full app reruns rather than
    testing something dialog-specific, but with the dialog we have a visual way of
    seeing the issue.

    Important: The behavior is not deterministic as it relies on a race condition.
    This means that the test can succeed even though the underlying issue exists.
    However, the test will not always succeed if the issue exists. So if the test
    sometimes fails, it might point to an underlying issue.
    Performing this test manually triggers the issue much more often.
    """
    import time

    for _ in range(0, 10):
        open_dialog_with_rerun(app)
        dialog = app.get_by_role("dialog")
        expect(dialog).to_be_visible()
        button = (
            app.get_by_test_id("stButton")
            .filter(has_text="Close Dialog")
            .locator("button")
        )
        counter = 0
        # simulate clicking the button multiple times in fast succession
        for _ in range(0, 5):
            counter += 1
            try:
                button.click(timeout=1000, no_wait_after=True)
            except PlaywrightTimeoutError:
                # the dialog closed and the button does not exist anymore, so
                # do not try to click it again
                break

            # sleep to mimic human behavior. If the sleep time is too small or too high,
            # I was not able to trigger the behavior; which makes sense given that the
            # original issue that prompted this test to be written was rooted in timing
            # the outgoing message queue flushing / replace behavior in
            # forward_msg_queue.py.
            time.sleep(0.2)

        # ensure that the button was clicked at least twice, otherwise the whole test
        # does not make sense
        assert counter >= 2
        expect(dialog).not_to_be_attached()


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    open_dialog_with_images(app)
    check_top_level_class(app, "stDialog")


================================================
File: /e2e_playwright/st_divider.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.divider()


================================================
File: /e2e_playwright/st_divider_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class


def test_divider_renders(themed_app: Page, assert_snapshot: ImageCompareFunction):
    expect(themed_app.get_by_test_id("stMarkdown").locator("hr")).to_be_visible()
    assert_snapshot(themed_app.get_by_test_id("stMarkdown"), name="st_divider")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stMarkdown")


================================================
File: /e2e_playwright/st_download_button.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from pathlib import Path
from random import random

import streamlit as st
from streamlit import runtime

# Construct test assets path relative to this script file to
# allow its execution with different working directories.
TEST_ASSETS_DIR = Path(__file__).parent / "test_assets"
CAT_IMAGE = TEST_ASSETS_DIR / "cat.jpg"

st.download_button(
    "Download button label",
    data="Hello world!",
    file_name="hello.txt",
)

st.download_button(
    "Download button label",
    data="Hello world!",
    file_name="hello.txt",
    key="disabled_dl_button",
    disabled=True,
)

st.download_button(
    "Download RAR archive file",
    data=b"bytes",
    file_name="archive.rar",
    mime="application/vnd.rar",
)

with open(CAT_IMAGE, "rb") as f:
    st.download_button(
        "Download image file",
        data=f,
        file_name="cat.jpg",
    )

st.download_button(
    "Download button with use_container_width=True",
    data="Hello world!",
    file_name="hello.txt",
    use_container_width=True,
)

st.download_button(
    "Download button with help text and use_container_width=True",
    data="Hello world!",
    file_name="hello.txt",
    use_container_width=True,
    help="Example help text",
)

st.download_button(
    "Primary download button",
    data="Hello world!",
    file_name="hello.txt",
    type="primary",
)

st.download_button(
    "Button with emoji icon",
    data="Hello world!",
    icon="â¬‡ï¸",
)

st.download_button(
    "Button with material icon",
    data="Hello world!",
    icon=":material/download:",
)

st.download_button(
    "Tertiary download button",
    data="Hello world!",
    type="tertiary",
)

st.download_button(
    "Disabled tertiary download button",
    data="Hello world!",
    type="tertiary",
    disabled=True,
)

random_str = str(random())
clicked = st.download_button(label="Download random text", data=random_str)

st.write(f"value: {clicked}")

# st.session_state can only be used in streamlit
if runtime.exists():

    def on_click(x, y):
        if "click_count" not in st.session_state:
            st.session_state.click_count = 0

        st.session_state.click_count += 1
        st.session_state.x = x
        st.session_state.y = y

    i1 = st.download_button(
        "Download + On Click",
        key="download_button",
        data="Hello world!",
        on_click=on_click,
        args=(1,),
        kwargs={"y": 2},
    )
    st.write("value:", i1)
    st.write("value from state:", st.session_state["download_button"])

    button_was_clicked = "click_count" in st.session_state
    st.write("Download Button was clicked:", button_was_clicked)

    if button_was_clicked:
        st.write("times clicked:", st.session_state.click_count)
        st.write("arg value:", st.session_state.x)
        st.write("kwarg value:", st.session_state.y)

i2 = st.checkbox("reset button return value")


================================================
File: /e2e_playwright/st_download_button_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_checkbox,
    get_element_by_key,
)


def test_download_button_widget_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that download buttons are correctly rendered via screenshot matching."""
    download_buttons = themed_app.get_by_test_id("stDownloadButton")
    expect(download_buttons).to_have_count(13)

    assert_snapshot(download_buttons.nth(0), name="st_download_button-default")
    assert_snapshot(download_buttons.nth(1), name="st_download_button-disabled")

    assert_snapshot(
        download_buttons.nth(4), name="st_download_button-use_container_width"
    )
    assert_snapshot(
        download_buttons.nth(5), name="st_download_button-use_container_width_help"
    )
    assert_snapshot(download_buttons.nth(6), name="st_download_button-primary")
    assert_snapshot(download_buttons.nth(7), name="st_download_button-emoji_icon")
    assert_snapshot(download_buttons.nth(8), name="st_download_button-material_icon")
    assert_snapshot(download_buttons.nth(9), name="st_download_button-tertiary")
    assert_snapshot(
        download_buttons.nth(10), name="st_download_button-disabled_tertiary"
    )


def test_show_tooltip_on_hover(app: Page, assert_snapshot: ImageCompareFunction):
    download_button = app.get_by_test_id("stDownloadButton").nth(5)
    download_button.hover()
    expect(app.get_by_test_id("stTooltipContent")).to_have_text("Example help text")


def test_value_correct_on_click(app: Page):
    download_button = app.get_by_test_id("stDownloadButton").nth(11).locator("button")
    download_button.click()
    expect(app.get_by_test_id("stMarkdown").first).to_have_text("value: True")


def test_value_not_reset_on_reclick(app: Page):
    download_button = app.get_by_test_id("stDownloadButton").nth(11).locator("button")
    download_button.click()
    download_button.click()
    expect(app.get_by_test_id("stMarkdown").first).to_have_text("value: True")


def test_click_calls_callback(app: Page):
    download_button = app.get_by_test_id("stDownloadButton").nth(12).locator("button")
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_contain_text(
        "Download Button was clicked: False"
    )
    download_button.click()
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text(
        "Download Button was clicked: True"
    )
    expect(app.get_by_test_id("stMarkdown").nth(4)).to_have_text("times clicked: 1")
    expect(app.get_by_test_id("stMarkdown").nth(5)).to_have_text("arg value: 1")
    expect(app.get_by_test_id("stMarkdown").nth(6)).to_have_text("kwarg value: 2")


def test_reset_on_other_widget_change(app: Page):
    download_button = app.get_by_test_id("stDownloadButton").nth(12).locator("button")
    download_button.click()
    expect(app.get_by_test_id("stMarkdown").nth(1)).to_have_text("value: True")
    expect(app.get_by_test_id("stMarkdown").nth(2)).to_have_text(
        "value from state: True"
    )

    click_checkbox(app, "reset button return value")
    expect(app.get_by_test_id("stMarkdown").nth(1)).to_have_text("value: False")
    expect(app.get_by_test_id("stMarkdown").nth(2)).to_have_text(
        "value from state: False"
    )


def test_downloads_RAR_file_on_click(app: Page):
    # Start waiting for the download
    with app.expect_download() as download_info:
        # Perform the action that initiates download
        download_button_element = (
            app.get_by_test_id("stDownloadButton").locator("button").nth(2)
        )
        download_button_element.click()

    download = download_info.value
    file_name = download.suggested_filename

    assert file_name == "archive.rar"


def test_downloads_image_file_on_click(app: Page):
    # Start waiting for the download
    with app.expect_download() as download_info:
        # Perform the action that initiates download
        download_button_element = (
            app.get_by_test_id("stDownloadButton").locator("button").nth(3)
        )
        download_button_element.click()

    download = download_info.value
    file_name = download.suggested_filename

    assert file_name == "cat.jpg"


def test_downloads_txt_file_on_click(app: Page):
    # Start waiting for the download
    with app.expect_download() as download_info:
        # Perform the action that initiates download
        download_button_element = (
            app.get_by_test_id("stDownloadButton").locator("button").first
        )
        download_button_element.click()

    download = download_info.value
    file_name = download.suggested_filename
    file_text = download.path().read_text()

    assert file_name == "hello.txt"
    assert file_text == "Hello world!"


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stDownloadButton")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "download_button")).to_be_visible()


================================================
File: /e2e_playwright/st_echo.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

with st.echo():
    st.write("This code is awesome!")

with st.echo(code_location="below"):
    st.write("This code is awesome!")


================================================
File: /e2e_playwright/st_echo_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_echo_msg(app: Page):
    """Test that st.echo shows that the correct message."""
    expect(app.get_by_test_id("stCode").first).to_have_text(
        'st.write("This code is awesome!")', use_inner_text=True
    )


def test_echo_msg_code_location(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.echo shows the correct location above and below"""
    screen = app.get_by_test_id("stVerticalBlockBorderWrapper")

    assert_snapshot(screen, name="st_echo-code_location_above_and_below")


================================================
File: /e2e_playwright/st_empty.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.text("The space between this...")
st.text("..and this should be the same as between this...")
st.empty()
st.text("...and this")

replace_hello_text_button_clicked = st.button(
    "Click here to replace text with a chart!"
)
replace_chart_button_clicked = st.button(
    "Click here to replace chart with st.write with `placeholder.container`!"
)
empty_button_clicked = st.button("Empty the placeholder!")

placeholder = st.empty()

# Replace the placeholder with some text:
placeholder.text("Hello")
st.text("last element")

if replace_hello_text_button_clicked:
    # Replace the text with a chart:
    placeholder.line_chart({"data": [1, 5, 2, 6]})

if replace_chart_button_clicked:
    # # Replace the chart with several elements:
    with placeholder.container():
        st.write("This is one element")
        st.write("This is another")

# # Clear all those elements:
if empty_button_clicked:
    placeholder.empty()


================================================
File: /e2e_playwright/st_empty_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run


def test_st_empty(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.empty doesn't take any space on screen."""
    expect(app.get_by_test_id("stEmpty")).to_have_count(1)

    assert_snapshot(
        app.get_by_test_id("stVerticalBlock"), name="st_empty-no_vertical_space_taken"
    )


def test_st_empty_as_a_container(app: Page, assert_snapshot: ImageCompareFunction):
    expect(app.get_by_text("Hello")).to_be_visible()

    app.get_by_test_id("stButton").nth(0).get_by_role("button").click()
    wait_for_app_run(app)

    expect(app.get_by_text("Hello")).to_have_count(0)
    expect(app.get_by_test_id("stVegaLiteChart")).to_have_count(1)

    app.get_by_test_id("stButton").nth(1).get_by_role("button").click()
    wait_for_app_run(app)

    expect(app.get_by_test_id("stVegaLiteChart")).to_have_count(0)
    expect(app.get_by_text("This is one element")).to_have_count(1)
    expect(app.get_by_text("This is another")).to_have_count(1)

    app.get_by_test_id("stButton").nth(2).get_by_role("button").click()
    wait_for_app_run(app)

    expect(app.get_by_text("This is one element")).to_have_count(0)
    expect(app.get_by_text("This is another")).to_have_count(0)

    assert_snapshot(
        app.get_by_test_id("stVerticalBlock"), name="st_empty-order_after_replacement"
    )


================================================
File: /e2e_playwright/st_exception.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit.errors import StreamlitAPIException

# Test a basic exception
basic_exception = RuntimeError("This exception message is awesome!")
st.exception(basic_exception)

# Test an exception with a long exception message (this sometimes happens in practice,
# e.g. if an exception message contains a URL)
long_exception = RuntimeError(
    "longlonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglonglong"
)
st.exception(long_exception)

# Test an exception with Markdown
markdown_exception = StreamlitAPIException(
    """
This exception contains Markdown, e.g. **bold text** or an emoji :wave: or :blue[colored text] or `code`.
It also has a code block that you can scroll through:

```
@st.cache(hash_funcs={_thread.lock: my_hash_func_that_is_some_riduculously_long_name})
def my_func(...):
    ...
```


    """
)
st.exception(markdown_exception)

# Test an exception that is raised without explicitly calling st.exception. This also
# shows the stack trace (which `st.exception` doesn't show when called explicitly).
# We're hiding this behind a button so the script doesn't raise an exception when run,
# which would cause tests to fail.
if st.button("Raise exception"):
    raise basic_exception


================================================
File: /e2e_playwright/st_exception_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import check_top_level_class


def test_st_exception_displays_correctly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    expect(themed_app.get_by_test_id("stException").nth(0)).to_have_text(
        "RuntimeError: This exception message is awesome!"
    )

    # Click the button that raises the exception
    button = themed_app.get_by_test_id("stButton").nth(0).locator("button")
    button.click()
    wait_for_app_run(themed_app)

    for i in range(4):
        assert_snapshot(
            themed_app.get_by_test_id("stException").nth(i), name=f"st_exception-{i}"
        )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stException")


================================================
File: /e2e_playwright/st_expander.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

sidebar = st.sidebar.expander("Expand me!")
sidebar.write("I am in the sidebar")

expander = st.expander("Collapse me!", expanded=True)
expander.write("I can collapse")
expander.slider("I don't get cut off")
expander.button("I'm also not cut off (while focused)")

collapsed = st.expander("_Expand_ **me**!")
collapsed.write("I am already collapsed")

st.expander("Empty expander")

with st.expander("Expander with number input", expanded=True):
    # We deliberately use a list to implement this for the screenshot
    st.write("* Example list item")
    value = st.number_input("number", value=1.0, key="number")


def update_value():
    st.session_state.number = 0


update_button = st.button("Update Num Input", on_click=update_value)

st.text(st.session_state.get("number"))

if st.button("Print State Value"):
    st.text(st.session_state.get("number"))

expander_long = st.expander(
    "Expand me! "
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum arcu nisl, tincidunt id "
    "orci id, condimentum cursus nunc. Nullam sed sodales ipsum, vel tincidunt dui. Etiam diam "
    "dolor, eleifend sit amet purus id, dictum aliquam quam.",
    expanded=True,
)
expander_long.write(
    "I can collapse. "
    "Integer et justo orci. In euismod posuere nulla ac maximus. Mauris tristique hendrerit "
    "placerat. Integer eu imperdiet ipsum. Praesent maximus pharetra est, ut ultrices ante "
    "molestie id. Nulla sollicitudin arcu orci, eget lobortis lacus ultricies eu. Ut suscipit est "
    "eget tellus laoreet faucibus. Nullam nec blandit felis. Nulla ullamcorper, justo eget "
    "consequat ultricies, nisi dolor lacinia mauris, eu lacinia ante nisi sit amet tortor."
)

collapsed_long = st.expander(
    "Expand me! "
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Vestibulum arcu nisl, tincidunt id "
    "orci id, condimentum cursus nunc. Nullam sed sodales ipsum, vel tincidunt dui. Etiam diam "
    "dolor, eleifend sit amet purus id, dictum aliquam quam."
)
collapsed_long.write("I am already collapsed")

expander_material_icon = st.expander(
    "Expander with material icon!", icon=":material/bolt:"
).write("This is an expander with a material icon.")

expander_emoji_icon = st.expander("Expander with emoji icon!", icon="ðŸŽˆ").write(
    "This is an expander with an emoji icon."
)


================================================
File: /e2e_playwright/st_expander_nested.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

level1 = st.expander("See explanation")
level1.write("First level expander")
level1.image("https://static.streamlit.io/examples/dice.jpg")

level2 = level1.expander("Nested expander")
level2.write("Second level expander")


================================================
File: /e2e_playwright/st_expander_nested_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page

from e2e_playwright.shared.app_utils import expect_exception


def test_nested_expanders(app: Page):
    """Test that st.expander may not be nested inside other expanders."""
    expect_exception(
        app,
        "StreamlitAPIException: Expanders may not be nested inside other expanders.",
    )


================================================
File: /e2e_playwright/st_expander_state.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

b0 = st.button("b0")
b1 = st.button("b1")

if b0:
    with st.expander("b0_expander", expanded=False):
        st.write("b0_write")

if b1:
    with st.expander("b1_expander", expanded=False):
        st.write("b1_write")


================================================
File: /e2e_playwright/st_expander_state_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import wait_for_app_run


def test_expandable_state(app: Page):
    """Test whether expander state is not retained for a distinct expander."""
    app.get_by_test_id("stButton").nth(0).locator("button").click()
    wait_for_app_run(app, wait_delay=500)
    app.get_by_test_id("stExpander").locator("summary").click()
    expect(app.get_by_test_id("stExpanderDetails")).to_contain_text("b0_write")

    # Wait for a short moment for the expander to finish expanding:
    app.wait_for_timeout(500)

    app.get_by_test_id("stButton").nth(1).locator("button").click()
    wait_for_app_run(app, wait_delay=500)

    expect(app.get_by_test_id("stExpanderDetails")).not_to_contain_text("b0_write")
    expect(app.get_by_test_id("stExpanderDetails")).to_be_hidden()


================================================
File: /e2e_playwright/st_expander_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import check_top_level_class, get_expander

EXPANDER_HEADER_IDENTIFIER = "summary"


def test_expander_displays_correctly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that all expanders are displayed correctly via screenshot testing."""
    expander_elements = themed_app.get_by_test_id("stExpander")
    expect(expander_elements).to_have_count(8)

    for expander in expander_elements.all():
        expect(expander.locator(EXPANDER_HEADER_IDENTIFIER)).to_be_visible()

    assert_snapshot(expander_elements.nth(0), name="st_expander-sidebar_collapsed")
    assert_snapshot(expander_elements.nth(1), name="st_expander-normal_expanded")
    assert_snapshot(expander_elements.nth(2), name="st_expander-normal_collapsed")
    assert_snapshot(expander_elements.nth(3), name="st_expander-with_input")
    assert_snapshot(expander_elements.nth(4), name="st_expander-long_expanded")
    assert_snapshot(expander_elements.nth(5), name="st_expander-long_collapsed")
    assert_snapshot(expander_elements.nth(6), name="st_expander-with_material_icon")
    assert_snapshot(expander_elements.nth(7), name="st_expander-with_emoji_icon")


def test_expander_collapses_and_expands(app: Page):
    """Test that an expander collapses and expands."""
    main_container = app.get_by_test_id("stMain")
    main_expanders = main_container.get_by_test_id("stExpander")
    expect(main_expanders).to_have_count(7)

    expanders = main_expanders.all()
    # Starts expanded
    expander_header = expanders[0].locator(EXPANDER_HEADER_IDENTIFIER)
    expect(expander_header).to_be_visible()
    toggle = expander_header.locator("svg").first
    expect(toggle).to_be_visible()
    expander_header.click()
    toggle = expander_header.locator("svg").first
    expect(toggle).to_be_visible()

    # Starts collapsed
    expander_header = expanders[1].locator(EXPANDER_HEADER_IDENTIFIER)
    expect(expander_header).to_be_visible()
    toggle = expander_header.locator("svg").first
    expect(toggle).to_be_visible()
    expander_header.click()
    toggle = expander_header.locator("svg").first
    expect(toggle).to_be_visible()


def test_empty_expander_not_rendered(app: Page):
    """Test that an empty expander is not rendered."""
    expect(app.get_by_text("Empty expander")).not_to_be_attached()


def test_expander_session_state_set(app: Page):
    """Test that session state updates are propagated to expander content"""
    main_container = app.get_by_test_id("stMain")
    main_expanders = main_container.get_by_test_id("stExpander")
    expect(main_expanders).to_have_count(7)

    # Show the Number Input
    num_input = main_expanders.nth(2).get_by_test_id("stNumberInput").locator("input")
    num_input.fill("10")
    num_input.press("Enter")
    wait_for_app_run(app)

    # Hide the Number Input
    main_expanders.nth(2).locator(EXPANDER_HEADER_IDENTIFIER).click()

    app.get_by_text("Update Num Input").click()
    wait_for_app_run(app)

    app.get_by_text("Print State Value").click()
    wait_for_app_run(app)

    text_elements = app.get_by_test_id("stText")
    expect(text_elements).to_have_count(2)

    expect(text_elements.nth(0)).to_have_text("0.0", use_inner_text=True)
    expect(text_elements.nth(1)).to_have_text("0.0", use_inner_text=True)


def test_expander_renders_icon(app: Page):
    """Test that an expander renders a material icon and an emoji icon."""
    material_icon = get_expander(app, "Expander with material icon!").get_by_test_id(
        "stExpanderIcon"
    )
    expect(material_icon).to_be_visible()
    expect(material_icon).to_have_text("bolt")

    emoji_icon = get_expander(app, "Expander with emoji icon!").get_by_test_id(
        "stExpanderIcon"
    )
    expect(emoji_icon).to_be_visible()
    expect(emoji_icon).to_have_text("ðŸŽˆ")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stExpander")


================================================
File: /e2e_playwright/st_experimental_audio_input.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import streamlit as st

audio_input = st.experimental_audio_input(
    label="Audio Input 1", key="the_audio_input", help="This is the help text"
)


================================================
File: /e2e_playwright/st_experimental_audio_input_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from playwright.sync_api import Page, expect


def test_experimental_audio_input_renders_with_deprecation_warning(app: Page):
    """Test that the experimental_audio_input component renders with a deprecation warning."""
    audio_input_warning_elements = app.get_by_test_id("stAlertContainer")
    count = 1  # Expected number of audio input elements

    # Verify that the expected number of elements is rendered
    expect(audio_input_warning_elements).to_have_count(count)

    expect(app.get_by_test_id("stAlertContainer").first).to_have_text(
        """Please replace st.experimental_audio_input with st.audio_input.
        st.experimental_audio_input will be removed after 2025-01-01."""
    )


================================================
File: /e2e_playwright/st_experimental_get_query_params.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

query_params = st.experimental_get_query_params()
st.write(str(query_params))


================================================
File: /e2e_playwright/st_experimental_get_query_params_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
from playwright.sync_api import Page, expect

test_dicts = [
    {"x": ["y"]},
    {"x": ["y"], "a": ["b"]},
    {"x": ["y", "1", "2.34"]},
    {"x": [""]},
]


@pytest.mark.parametrize("app_with_query_params", test_dicts, indirect=True)
def test_app_with_experimental_get_query_params(app_with_query_params: Page):
    page, test_dict = app_with_query_params
    expect(page.get_by_test_id("stMarkdownContainer").nth(0)).to_contain_text(
        "Please replace st.experimental_get_query_params with st.query_params. "
        "st.experimental_get_query_params will be removed after 2024-04-11. "
        "Refer to our docs page for more information."
    )
    expect(page.get_by_test_id("stMarkdownContainer").nth(1)).to_contain_text(
        str(test_dict)
    )


================================================
File: /e2e_playwright/st_experimental_set_query_params.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

set_query_params = st.button("Set current query params")

if set_query_params:
    st.experimental_set_query_params(
        show_map=True,
        number_of_countries=2,
        selected=["asia", "america"],
    )


================================================
File: /e2e_playwright/st_experimental_set_query_params_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from playwright.sync_api import Page, expect


def test_query_params_set(app: Page):
    app.get_by_test_id("stButton").locator("button").first.click()

    expect(app.get_by_test_id("stMarkdownContainer").nth(1)).to_contain_text(
        "Please replace st.experimental_set_query_params with st.query_params. "
        "st.experimental_set_query_params will be removed after 2024-04-11. "
        "Refer to our docs page for more information."
    )
    expect(app).to_have_url(
        re.compile(
            r"\?show_map=True&number_of_countries=2&selected=asia&selected=america"
        )
    )


================================================
File: /e2e_playwright/st_feedback.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time

import streamlit as st

with st.container(key="thumbs_container"):
    st.feedback()
    st.session_state.thumbs_feedback_disabled = 1
    st.feedback(key="thumbs_feedback_disabled", disabled=True)


with st.container(key="faces_container"):
    st.feedback(
        "faces",
        key="faces_feedback",
        on_change=lambda: st.write(
            f"Faces sentiment: {st.session_state.faces_feedback_disabled}"
        ),
    )
    st.session_state.faces_feedback_disabled = 3
    st.feedback(
        "faces",
        key="faces_feedback_disabled",
        disabled=True,
    )

with st.container(key="stars_container"):
    sentiment = st.feedback("stars")
    st.write(f"Star sentiment: {sentiment}")
    st.session_state.star_feedback_disabled = 3
    sentiment = st.feedback("stars", disabled=True, key="star_feedback_disabled")
    st.write("feedback-disabled:", str(sentiment))


with st.form(key="my_form", clear_on_submit=True):
    sentiment = st.feedback()
    st.form_submit_button("Submit")

st.write("feedback-in-form:", str(sentiment))


@st.experimental_fragment()
def test_fragment():
    sentiment = st.feedback(key="fragment_feedback")
    st.write("feedback-in-fragment:", str(sentiment))


test_fragment()


if st.button("Create some elements to unmount component"):
    for _ in range(3):
        # The sleep here is needed, because it won't unmount the
        # component if this is too fast.
        time.sleep(1)
        st.write("Another element")

sentiment = st.feedback(key="after_sleep_feedback")
st.write("feedback-after-sleep:", str(sentiment))


if "runs" not in st.session_state:
    st.session_state.runs = 0
st.session_state.runs += 1
st.write("Runs:", st.session_state.runs)


================================================
File: /e2e_playwright/st_feedback_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import re

from playwright.sync_api import Locator, Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_button,
    click_form_button,
    get_element_by_key,
    get_markdown,
)


def get_button_group(locator: Page | Locator, index: int = 0) -> Locator:
    button_group = locator.get_by_test_id("stButtonGroup").nth(index)
    expect(button_group).to_be_visible()
    return button_group


def get_feedback_icon_buttons(locator: Locator, type: str | None = None) -> Locator:
    return locator.get_by_test_id(
        re.compile("stBaseButton-borderlessIcon(Active)?")
    ).filter(has_text=type)


def get_feedback_icon_button(locator: Locator, type: str, index: int = 0) -> Locator:
    return get_feedback_icon_buttons(locator, type).nth(index)


def test_click_thumbsup_and_take_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Create snapshot of thumbs feedback (enabled & disabled)."""

    container = get_element_by_key(themed_app, "thumbs_container")
    expect(container).to_be_attached()

    thumbs = get_button_group(container)
    expect(thumbs).to_be_attached()
    get_feedback_icon_button(thumbs, "thumb_up").click()
    wait_for_app_run(themed_app)

    assert_snapshot(container, name="st_feedback-thumbs")


def test_clicking_on_faces_shows_sentiment_via_on_change_callback_and_take_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Create snapshot of faces feedback (enabled & disabled)."""

    container = get_element_by_key(themed_app, "faces_container")
    expect(container).to_be_attached()

    faces = get_button_group(container)
    get_feedback_icon_button(faces, "sentiment_satisfied").click()
    wait_for_app_run(themed_app)
    text = get_markdown(themed_app, "Faces sentiment: 3")
    expect(text).to_be_attached()

    assert_snapshot(container, name="st_feedback-faces")


def test_clicking_on_stars_shows_sentiment_and_take_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Create snapshot of stars feedback (enabled & disabled)."""

    container = get_element_by_key(themed_app, "stars_container")
    expect(container).to_be_attached()

    stars = get_button_group(container)
    get_feedback_icon_button(stars, "star", 3).click()
    wait_for_app_run(themed_app)
    text = get_markdown(themed_app, "Star sentiment: 3")
    expect(text).to_be_attached()

    assert_snapshot(container, name="st_feedback-stars")


def test_feedback_buttons_are_disabled(app: Page):
    """Test that feedback buttons are disabled when `disabled=True` and that
    they cannot be interacted with."""

    container = get_element_by_key(app, "stars_container")
    expect(container).to_be_attached()

    stars = get_button_group(container, 1)
    star_buttons = get_feedback_icon_buttons(stars)
    for star_button in star_buttons.all():
        expect(star_button).to_have_js_property("disabled", True)
    selected_button = star_buttons.nth(4)
    selected_button.click(force=True)
    expect(selected_button).not_to_have_css(
        "color", re.compile("rgb\\(\\d+, \\d+, \\d+\\)")
    )
    # the feedback value was set to 3 via session state
    text = get_markdown(app, "feedback-disabled: 3")
    expect(text).to_be_attached()


def test_feedback_works_in_forms(app: Page):
    expect(app.get_by_text("feedback-in-form: None")).to_be_visible()

    container = app.get_by_test_id("stForm")
    expect(container).to_be_attached()

    thumbs = get_button_group(container)
    get_feedback_icon_button(thumbs, "thumb_up").click()
    expect(app.get_by_text("feedback-in-form: None")).to_be_visible()
    click_form_button(app, "Submit")
    wait_for_app_run(app)

    text = get_markdown(app, "feedback-in-form: 1")
    expect(text).to_be_attached()


def test_feedback_works_with_fragments(app: Page):
    expect(app.get_by_text("Runs: 1")).to_be_visible()
    expect(app.get_by_text("feedback-in-fragment: None")).to_be_visible()

    fragment_container = get_element_by_key(app, "fragment_feedback")
    thumbs = get_button_group(fragment_container)
    get_feedback_icon_button(thumbs, "thumb_up").click()
    wait_for_app_run(app)

    expect(app.get_by_text("feedback-in-fragment: 1")).to_be_visible()
    expect(app.get_by_text("Runs: 1")).to_be_visible()


def test_feedback_remount_keep_value(app: Page):
    """Test that `st.feedback` remounts correctly without resetting value."""

    expect(app.get_by_text("feedback-after-sleep: None")).to_be_visible()

    sleep_feedback_container = get_element_by_key(app, "after_sleep_feedback")
    thumbs = get_button_group(sleep_feedback_container)
    selected_button = get_feedback_icon_button(thumbs, "thumb_up")
    selected_button.click()
    wait_for_app_run(app)
    expect(app.get_by_text("feedback-after-sleep: 1")).to_be_visible()
    expect(selected_button).to_have_css(
        "color", re.compile("rgb\\(\\d+, \\d+, \\d+\\)")
    )
    click_button(app, "Create some elements to unmount component")
    expect(selected_button).to_have_css(
        "color", re.compile("rgb\\(\\d+, \\d+, \\d+\\)")
    )
    expect(app.get_by_text("feedback-after-sleep: 1")).to_be_visible()


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""

    check_top_level_class(app, "stButtonGroup")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""

    expect(get_element_by_key(app, "faces_feedback")).to_be_visible()


================================================
File: /e2e_playwright/st_file_uploader.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit import runtime

single_file = st.file_uploader("Drop a file:", type=["txt"], key="single")
if single_file is None:
    st.text("No upload")
else:
    st.text(single_file.read())

# Here and throughout this file, we use `if runtime.is_running():`
# since we also run e2e python files in "bare Python mode" as part of our
# Python tests, and this doesn't work in that circumstance
# st.session_state can only be accessed while running with streamlit
if runtime.exists():
    st.write(repr(st.session_state.single) == repr(single_file))

disabled = st.file_uploader(
    "Can't drop a file:", type=["txt"], key="disabled", disabled=True
)
if disabled is None:
    st.text("No upload")
else:
    st.text(disabled.read())

if runtime.exists():
    st.write(repr(st.session_state.disabled) == repr(disabled))

multiple_files = st.file_uploader(
    "Drop multiple files:",
    type=["txt"],
    accept_multiple_files=True,
    key="multiple",
)
if multiple_files is None:
    st.text("No upload")
else:
    files = [file.read().decode() for file in multiple_files]
    st.text("\n".join(files))

if runtime.exists():
    st.write(repr(st.session_state.multiple) == repr(multiple_files))

with st.form("foo"):
    form_file = st.file_uploader("Inside form:", type=["txt"])
    st.form_submit_button("Submit")
    if form_file is None:
        st.text("No upload")
    else:
        st.text(form_file.read())


hidden_label = st.file_uploader(
    "Hidden label:",
    key="hidden_label",
    label_visibility="hidden",
)

if hidden_label is None:
    st.text("No upload")
else:
    st.text(hidden_label.read())

if runtime.exists():
    st.write(repr(st.session_state.hidden_label) == repr(hidden_label))

collapsed_label = st.file_uploader(
    "Collapsed label:",
    key="collapsed_label",
    label_visibility="collapsed",
)

if collapsed_label is None:
    st.text("No upload")
else:
    st.text(collapsed_label.read())

if runtime.exists():
    st.write(repr(st.session_state.collapsed_label) == repr(collapsed_label))

if not st.session_state.get("counter"):
    st.session_state["counter"] = 0


def file_uploader_on_change():
    st.session_state.counter += 1


st.file_uploader(
    "Drop a file:",
    type=["txt"],
    key="on_change_file_uploader_key",
    on_change=file_uploader_on_change,
)

st.text(st.session_state.counter)


@st.experimental_fragment()
def test_file_fragment():
    file_uploader_in_fragment = st.file_uploader(label="file uploader")
    st.write("File uploader in Fragment:", bool(file_uploader_in_fragment))


test_file_fragment()

if "runs" not in st.session_state:
    st.session_state.runs = 0
st.session_state.runs += 1
st.write("Runs:", st.session_state.runs)


================================================
File: /e2e_playwright/st_file_uploader_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, rerun_app, wait_for_app_run
from e2e_playwright.shared.app_utils import check_top_level_class, get_element_by_key


def test_file_uploader_render_correctly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the file uploader render as expected via screenshot matching."""
    file_uploaders = themed_app.get_by_test_id("stFileUploader")
    expect(file_uploaders).to_have_count(8)

    assert_snapshot(file_uploaders.nth(0), name="st_file_uploader-single_file")
    assert_snapshot(file_uploaders.nth(1), name="st_file_uploader-disabled")
    assert_snapshot(file_uploaders.nth(2), name="st_file_uploader-multiple_files")
    assert_snapshot(file_uploaders.nth(4), name="st_file_uploader-hidden_label")
    assert_snapshot(file_uploaders.nth(5), name="st_file_uploader-collapsed_label")


def test_file_uploader_error_message_disallowed_files(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that shows error message for disallowed files."""
    file_name1 = "example.json"
    file_content1 = b"{}"

    uploader_index = 0

    with app.expect_file_chooser() as fc_info:
        app.get_by_test_id("stFileUploaderDropzone").nth(uploader_index).click()

    file_chooser = fc_info.value
    file_chooser.set_files(
        files=[
            {
                "name": file_name1,
                "mimeType": "application/json",
                "buffer": file_content1,
            }
        ]
    )

    wait_for_app_run(app)

    expect(
        app.get_by_test_id("stFileUploaderFileErrorMessage").nth(uploader_index)
    ).to_have_text("application/json files are not allowed.", use_inner_text=True)

    file_uploader_in_error_state = app.get_by_test_id("stFileUploader").nth(
        uploader_index
    )

    assert_snapshot(file_uploader_in_error_state, name="st_file_uploader-error")


def test_uploads_and_deletes_single_file_only(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that uploading a file for single file uploader works as expected."""
    file_name1 = "file1.txt"
    file_content1 = b"file1content"

    file_name2 = "file2.txt"
    file_content2 = b"file2content"

    uploader_index = 0

    with app.expect_file_chooser() as fc_info:
        app.get_by_test_id("stFileUploaderDropzone").nth(uploader_index).click()

    file_chooser = fc_info.value
    file_chooser.set_files(
        files=[{"name": file_name1, "mimeType": "text/plain", "buffer": file_content1}]
    )
    wait_for_app_run(app)

    expect(app.get_by_test_id("stFileUploaderFileName")).to_have_text(
        file_name1, use_inner_text=True
    )

    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        str(file_content1), use_inner_text=True
    )

    file_uploader_uploaded_state = app.get_by_test_id("stFileUploader").nth(
        uploader_index
    )

    assert_snapshot(
        file_uploader_uploaded_state, name="st_file_uploader-single_file_uploaded"
    )

    expect(
        app.get_by_test_id("stMarkdownContainer").nth(uploader_index + 1)
    ).to_have_text("True", use_inner_text=True)

    # Upload a second file. This one will replace the first.
    with app.expect_file_chooser() as fc_info:
        app.get_by_test_id("stFileUploaderDropzone").nth(uploader_index).click()

    file_chooser = fc_info.value
    file_chooser.set_files(
        files=[{"name": file_name2, "mimeType": "text/plain", "buffer": file_content2}]
    )

    wait_for_app_run(app)

    expect(app.get_by_test_id("stFileUploaderFileName")).to_have_text(
        file_name2, use_inner_text=True
    )

    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        str(file_content2), use_inner_text=True
    )

    expect(
        app.get_by_test_id("stMarkdownContainer").nth(uploader_index + 1)
    ).to_have_text("True", use_inner_text=True)

    rerun_app(app)

    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        str(file_content2), use_inner_text=True
    )

    app.get_by_test_id("stFileUploaderDeleteBtn").nth(uploader_index).click()

    wait_for_app_run(app)

    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        "No upload", use_inner_text=True
    )


def test_uploads_and_deletes_multiple_files(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that uploading multiple files at once works correctly."""
    file_name1 = "file1.txt"
    file_content1 = b"file1content"

    file_name2 = "file2.txt"
    file_content2 = b"file2content"

    files = [
        {"name": file_name1, "mimeType": "text/plain", "buffer": file_content1},
        {"name": file_name2, "mimeType": "text/plain", "buffer": file_content2},
    ]

    uploader_index = 2

    with app.expect_file_chooser() as fc_info:
        app.get_by_test_id("stFileUploaderDropzone").nth(uploader_index).click()

    file_chooser = fc_info.value
    file_chooser.set_files(files=files)

    wait_for_app_run(app, wait_delay=500)

    uploaded_file_names = app.get_by_test_id("stFileUploaderFileName")

    # The widget should show the names of the uploaded files in reverse order
    file_names = [files[1]["name"], files[0]["name"]]

    for i, element in enumerate(uploaded_file_names.all()):
        expect(element).to_have_text(file_names[i], use_inner_text=True)

    # The script should have printed the contents of the two files into a st.text.
    # This tests that the upload actually went through.
    content = "\n".join(
        [
            files[0]["buffer"].decode("utf-8"),
            files[1]["buffer"].decode("utf-8"),
        ]
    )
    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        content, use_inner_text=True
    )

    file_uploader = app.get_by_test_id("stFileUploader").nth(uploader_index)
    assert_snapshot(file_uploader, name="st_file_uploader-multi_file_uploaded")

    #  Delete the second file. The second file is on top because it was
    #  most recently uploaded. The first file should still exist.
    app.get_by_test_id("stFileUploaderDeleteBtn").first.click()

    wait_for_app_run(app)

    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        files[0]["buffer"].decode("utf-8"), use_inner_text=True
    )

    expect(app.get_by_test_id("stMarkdownContainer").nth(5)).to_have_text(
        "True", use_inner_text=True
    )


def test_uploads_multiple_files_one_by_one_quickly(app: Page):
    """Test that uploads and deletes multiple files quickly works correctly."""
    file_name1 = "file1.txt"
    file_content1 = b"file1content"

    file_name2 = "file2.txt"
    file_content2 = b"file2content"

    files = [
        {"name": file_name1, "mimeType": "text/plain", "buffer": file_content1},
        {"name": file_name2, "mimeType": "text/plain", "buffer": file_content2},
    ]

    uploader_index = 2

    with app.expect_file_chooser() as fc_info:
        app.get_by_test_id("stFileUploaderDropzone").nth(uploader_index).click()

    file_chooser = fc_info.value
    file_chooser.set_files(files=files[0])

    # The widget should show the name of the uploaded file
    expect(app.get_by_test_id("stFileUploaderFileName")).to_have_text(
        file_name1, use_inner_text=True
    )

    with app.expect_file_chooser() as fc_info:
        app.get_by_test_id("stFileUploaderDropzone").nth(uploader_index).click()

    file_chooser = fc_info.value

    with app.expect_request("**/upload_file/**"):
        file_chooser.set_files(files=files[1])

    uploaded_file_names = app.get_by_test_id("stFileUploaderFileName")

    # The widget should show the names of the uploaded files in reverse order
    file_names = [files[1]["name"], files[0]["name"]]

    for i, element in enumerate(uploaded_file_names.all()):
        expect(element).to_have_text(file_names[i], use_inner_text=True)

    # The script should have printed the contents of the two files into a st.text.
    # This tests that the upload actually went through.
    content = "\n".join(
        [
            files[0]["buffer"].decode("utf-8"),
            files[1]["buffer"].decode("utf-8"),
        ]
    )
    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        content, use_inner_text=True
    )

    #  Delete the second file. The second file is on top because it was
    #  most recently uploaded. The first file should still exist.
    app.get_by_test_id("stFileUploaderDeleteBtn").first.click()

    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        files[0]["buffer"].decode("utf-8"), use_inner_text=True
    )

    expect(app.get_by_test_id("stMarkdownContainer").nth(5)).to_have_text(
        "True", use_inner_text=True
    )


# NOTE: This test is essentially identical to the one above. The only
# difference is that we add a short delay to uploading the two files to
# ensure that two script runs happen separately (sufficiently rapid widget
# changes will often be batched into a single script run) to test for the
# failure mode in https://github.com/streamlit/streamlit/issues/3531.
def test_uploads_multiple_files_one_by_one_slowly(app: Page):
    """Test that uploads and deletes multiple files slowly works."""
    file_name1 = "file1.txt"
    file_content1 = b"file1content"

    file_name2 = "file2.txt"
    file_content2 = b"file2content"

    files = [
        {"name": file_name1, "mimeType": "text/plain", "buffer": file_content1},
        {"name": file_name2, "mimeType": "text/plain", "buffer": file_content2},
    ]

    uploader_index = 2

    with app.expect_file_chooser() as fc_info:
        app.get_by_test_id("stFileUploaderDropzone").nth(uploader_index).click()

    file_chooser = fc_info.value
    # Here we wait for the first file to be uploaded before uploading the second
    with app.expect_request("**/upload_file/**"):
        file_chooser.set_files(files=files[0])

    # The widget should show the name of the uploaded file
    expect(app.get_by_test_id("stFileUploaderFileName")).to_have_text(
        file_name1, use_inner_text=True
    )

    with app.expect_file_chooser() as fc_info:
        app.get_by_test_id("stFileUploaderDropzone").nth(uploader_index).click()

    file_chooser = fc_info.value

    with app.expect_request("**/upload_file/**"):
        file_chooser.set_files(files=files[1])

    uploaded_file_names = app.get_by_test_id("stFileUploaderFileName")

    # The widget should show the names of the uploaded files in reverse order
    file_names = [files[1]["name"], files[0]["name"]]

    for i, element in enumerate(uploaded_file_names.all()):
        expect(element).to_have_text(file_names[i], use_inner_text=True)

    # The script should have printed the contents of the two files into a st.text.
    # This tests that the upload actually went through.
    content = "\n".join(
        [
            files[0]["buffer"].decode("utf-8"),
            files[1]["buffer"].decode("utf-8"),
        ]
    )
    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        content, use_inner_text=True
    )

    #  Delete the second file. The second file is on top because it was
    #  most recently uploaded. The first file should still exist.
    app.get_by_test_id("stFileUploaderDeleteBtn").first.click()

    wait_for_app_run(app)

    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        files[0]["buffer"].decode("utf-8"), use_inner_text=True
    )

    expect(app.get_by_test_id("stMarkdownContainer").nth(5)).to_have_text(
        "True", use_inner_text=True
    )


def test_does_not_call_callback_when_not_changed(app: Page):
    """Test that the file uploader does not call a callback when not changed."""
    file_name1 = "example5.txt"
    file_content1 = b"Hello world!"

    uploader_index = 6

    # Script contains counter variable stored in session_state with
    # default value 0. We increment counter inside file_uploader callback
    # Since callback did not called at this moment, counter value should
    # be equal 0
    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        "0", use_inner_text=True
    )

    with app.expect_file_chooser() as fc_info:
        app.get_by_test_id("stFileUploaderDropzone").nth(uploader_index).click()

    file_chooser = fc_info.value
    file_chooser.set_files(
        files=[
            {
                "name": file_name1,
                "mimeType": "application/json",
                "buffer": file_content1,
            }
        ]
    )

    wait_for_app_run(app)

    # Make sure callback called
    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        "1", use_inner_text=True
    )
    rerun_app(app)

    # Counter should be still equal 1
    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        "1", use_inner_text=True
    )


def test_works_inside_form(app: Page):
    """Test that uploading a file inside form works as expected."""
    file_name1 = "form_file1.txt"
    file_content1 = b"form_file1content"

    uploader_index = 3

    with app.expect_file_chooser() as fc_info:
        app.get_by_test_id("stFileUploaderDropzone").nth(uploader_index).click()

    file_chooser = fc_info.value
    file_chooser.set_files(
        files=[{"name": file_name1, "mimeType": "text/plain", "buffer": file_content1}]
    )
    wait_for_app_run(app)

    # We should be showing the uploaded file name
    expect(app.get_by_test_id("stFileUploaderFileName")).to_have_text(
        file_name1, use_inner_text=True
    )
    # But our uploaded text should contain nothing yet, as we haven't submitted.
    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        "No upload", use_inner_text=True
    )

    # Submit the form
    app.get_by_test_id("stFormSubmitButton").first.locator("button").click()
    wait_for_app_run(app)

    # Now we should see the file's contents
    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        str(file_content1), use_inner_text=True
    )

    # Press the delete button. Again, nothing should happen - we
    # should still see the file's contents.
    app.get_by_test_id("stFileUploaderDeleteBtn").first.click()
    wait_for_app_run(app)
    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        str(file_content1), use_inner_text=True
    )

    # Submit again. Now the file should be gone.
    app.get_by_test_id("stFormSubmitButton").first.locator("button").click()
    wait_for_app_run(app)

    expect(app.get_by_test_id("stText").nth(uploader_index)).to_have_text(
        "No upload", use_inner_text=True
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stFileUploader")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "single")).to_be_visible()


def test_file_uploader_works_with_fragments(app: Page):
    file_name1 = "form_file1.txt"
    file_content1 = b"form_file1content"

    expect(app.get_by_text("Runs: 1")).to_be_visible()
    expect(app.get_by_text("File uploader in Fragment: False")).to_be_visible()

    uploader_index = 7

    with app.expect_file_chooser() as fc_info:
        app.get_by_test_id("stFileUploaderDropzone").nth(uploader_index).click()

    file_chooser = fc_info.value
    file_chooser.set_files(
        files=[{"name": file_name1, "mimeType": "text/plain", "buffer": file_content1}]
    )
    wait_for_app_run(app)

    expect(app.get_by_text("File uploader in Fragment: True")).to_be_visible()
    expect(app.get_by_text("Runs: 1")).to_be_visible()


================================================
File: /e2e_playwright/st_form.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from datetime import date, time

import streamlit as st

# Tests all widgets, sans file_uploader, color picker, camera input and data editor,
# inside a form. These widgets are a lot more complicated to test, and
# are tested separately within the e2e tests for those components.
with st.form("form_1"):
    checkbox = st.checkbox("Checkbox", False)
    date_input = st.date_input("Date Input", date(2019, 7, 6))
    multiselect = st.multiselect("Multiselect", ["foo", "bar"], default=["foo"])
    number_input = st.number_input("Number Input")
    radio = st.radio("Radio", ["foo", "bar", "baz"])
    selectbox = st.selectbox("Selectbox", ["foo", "bar", "baz"])
    select_slider = st.select_slider("Select Slider", ["foo", "bar", "baz"])
    slider = st.slider("Slider")
    text_area = st.text_area("Text Area", value="foo")
    text_input = st.text_input("Text Input", value="foo")
    time_input = st.time_input("Time Input", time(8, 45))
    toggle_input = st.toggle("Toggle Input", value=False)
    st.form_submit_button("Submit")

st.write("Checkbox:", checkbox)
st.write("Date Input:", date_input)
st.write("Multiselect:", ", ".join(multiselect))
st.write("Number Input:", number_input)
st.write("Radio:", radio)
st.write("Selectbox:", selectbox)
st.write("Select Slider:", select_slider)
st.write("Slider:", slider)
st.write("Text Area:", text_area)
st.write("Text Input:", text_input)
st.write("Time Input:", time_input)
st.write("Toggle Input:", toggle_input)

with st.form("form_2"):
    st.write("Inside form 2")
    text_input = st.text_input("Form 2 - Text Input")
    col1, col2 = st.columns(2)
    col1.form_submit_button(
        "Form 2 - Submit (use_container_width, help)",
        use_container_width=True,
        help="Submit by clicking",
    )
    col2.form_submit_button(
        "Form 2 - Submit 2 (use_container_width)", use_container_width=True
    )


with st.form("form_3", border=False):
    st.write("Inside form 3 (border=False)")
    text_input = st.text_input("Form 3 - Text Input")
    st.form_submit_button(
        "Form 3 - Submit (use_container_width)",
        use_container_width=True,
    )

with st.form("form_4"):
    st.write("Inside form 4 - emoji icon")
    text_input = st.text_input("Form 4 - Text Input")
    st.form_submit_button(
        "Form 4 - Submit with emoji icon",
        use_container_width=True,
        icon="ðŸ”",
    )

with st.form("form_5"):
    st.write("Inside form 5 - material icon")
    text_input = st.text_input("Form 5 - Text Input")
    st.form_submit_button(
        "Form 5 - Submit with material icon",
        use_container_width=True,
        icon=":material/key:",
    )

with st.form("form_6"):
    st.write("Inside form 6 - Submit on Enter")
    text_input = st.text_input("Form 6 - Text Input")
    submitted_6 = st.form_submit_button(
        "Form 6 - First Submit",
        use_container_width=True,
    )
    submitted_6b = st.form_submit_button(
        "Form 6 - Second Submit",
        disabled=True,
        use_container_width=True,
    )
    if submitted_6 or submitted_6b:
        st.write("Form submitted")

with st.form("form_7"):
    st.write("Inside form 7")
    text_input = st.text_input("Form 7 - Text Input")
    submitted_7 = st.form_submit_button(
        "Form 7 - Disables Submit on Enter",
        use_container_width=True,
        disabled=True,
    )
    submitted_7b = st.form_submit_button(
        "Form 7 - Second Submit",
        use_container_width=True,
    )
    if submitted_7 or submitted_7b:
        st.write("Form submitted")

with st.form("form_8", enter_to_submit=False):
    st.write("Inside form 8")
    number_input = st.number_input("Form 8 - Number Input", 0, 100, step=1)
    submitted_8 = st.form_submit_button(
        "Form 8 - Submit",
        use_container_width=True,
    )
    if submitted_8:
        st.write("Form submitted")

with st.form("form_9", enter_to_submit=False):
    st.write("Inside form 9")
    number_input = st.number_input("Form 9 - Number Input", 0, 100, step=1)
    submitted_9 = st.form_submit_button(
        "Form 9 - Submit",
        type="primary",
        use_container_width=True,
    )
    if submitted_9:
        st.write("Form submitted")

with st.form("form_10"):
    st.write("Inside form 10")
    number_input = st.number_input("Form 10 - Number Input", 0, 100, step=1)
    submitted_10 = st.form_submit_button(
        "Form 10 - Submit",
        type="tertiary",
        use_container_width=True,
    )
    if submitted_10:
        st.write("Form submitted")


================================================
File: /e2e_playwright/st_form_container_association.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

# Element created in a form located in the sidebar.
form_0_key = "form_0"
with st.sidebar.form(form_0_key):
    value = st.checkbox(f"in {form_0_key}")
    st.form_submit_button(f"{form_0_key} submit")
st.sidebar.write(f"{form_0_key} value:", value)

# Element created in the sidebar, outside the form.
form_1_key = "form_1"
with st.form(form_1_key):
    "Empty Form 1"
    value = st.sidebar.checkbox(f"NOT in {form_1_key}")
    st.form_submit_button(f"{form_1_key} submit")
st.write(f"{form_1_key} value:", value)

# Parent block created outside a form; element created inside a form.
form_2_key = "form_2"
cols = st.columns(2)
with st.form(form_2_key):
    "Empty Form 2"
    value = cols[0].checkbox(f"NOT in {form_2_key}")
    st.form_submit_button(f"{form_2_key} submit")
st.write(f"{form_2_key} value:", value)

# Parent block and element created inside a form.
form_3_key = "form_3"
with st.form(form_3_key):
    cols = st.columns(2)
    with cols[0]:
        value = st.checkbox(f"in {form_3_key}")
    st.form_submit_button(f"{form_3_key} submit")
st.write(f"{form_3_key} value:", value)

# Parent block created inside a form; element created outside a form.
form_4_key = "form_4"
with st.form(form_4_key):
    cols = st.columns(2)
    st.form_submit_button(f"{form_4_key} submit")
value = cols[0].checkbox(f"in {form_4_key}")
st.write(f"{form_4_key} value:", value)

# DG created outside a form; element created inside a form.
form_5_key = "form_5"
empty = st.empty()
with st.form(form_5_key):
    "Empty Form 5"
    value = empty.checkbox(f"NOT in {form_5_key}")
    st.form_submit_button(f"{form_5_key} submit")
st.write(f"{form_5_key} value:", value)

# DG created inside a form; element created outside a form.
form_6_key = "form_6"
with st.form(form_6_key):
    empty = st.empty()
    st.form_submit_button(f"{form_6_key} submit")
value = empty.checkbox(f"in {form_6_key}")
st.write(f"{form_6_key} value:", value)

# Element created directly on a form block.
form_7_key = "form_7"
form = st.form(form_7_key)
value = form.checkbox(f"in {form_7_key}")
form.form_submit_button(f"{form_7_key} submit")
st.write(f"{form_7_key} value:", value)

# Forms inside columns.
cols = st.columns(2)
with cols[0]:
    form_8_key = "form_8"
    with st.form(form_8_key):
        value = st.checkbox(f"in {form_8_key}")
        st.form_submit_button(f"{form_8_key} submit")
    st.write(f"{form_8_key} value:", value)
with cols[1]:
    form_9_key = "form_9"
    with st.form(form_9_key):
        value = st.checkbox(f"in {form_9_key}")
        st.form_submit_button(f"{form_9_key} submit")
    st.write(f"{form_9_key} value:", value)


================================================
File: /e2e_playwright/st_form_container_association_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from playwright.sync_api import Page

from e2e_playwright.shared.app_utils import (
    click_checkbox,
    click_form_button,
    expect_prefixed_markdown,
)


def test_form_container_association(app: Page):
    """Test association of elements to a form with different cases
    with elements created in the form container and outside.
    """

    # We could also use parameterized tests here, but this would
    # cause some overhead and > 2x the time since it has to execute
    # 30 tests instead of 3 (10 form ids * 3 browsers).

    # Form id mapping whether a checkbox is inside a form
    checkbox_inside_form = {
        "form_0": True,
        "form_1": False,
        "form_2": False,
        "form_3": True,
        "form_4": True,
        "form_5": False,
        "form_6": True,
        "form_7": True,
        "form_8": True,
        "form_9": True,
    }

    for form_id, is_checkbox_inside_form in checkbox_inside_form.items():
        # Check the initial state of the checkbox to be False
        expect_prefixed_markdown(app, f"{form_id} value:", "False", exact_match=True)

        # Click on the checkbox
        click_checkbox(app, re.compile(f"in {form_id}"))

        # Check that only checkbox values have been updated that are outside a form
        expect_prefixed_markdown(
            app, f"{form_id} value:", str(not is_checkbox_inside_form), exact_match=True
        )

        # Submit the form
        click_form_button(app, f"{form_id} submit")

        # Check the checkbox value has been updated to True for all cases
        expect_prefixed_markdown(app, f"{form_id} value:", "True", exact_match=True)


================================================
File: /e2e_playwright/st_form_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_checkbox,
    click_toggle,
)


@pytest.mark.performance
def test_form_input_performance(app: Page):
    """
    Tests the re-render performance when typing in an input that is in a form.
    """
    form_1 = app.get_by_test_id("stForm").nth(0)
    form_1.get_by_test_id("stTextArea").locator("textarea").press_sequentially(
        "this is some text", delay=100
    )
    wait_for_app_run(app)


def change_widget_values(app: Page):
    """Change the checkbox value."""
    # Get the first form:
    form_1 = app.get_by_test_id("stForm").nth(0)
    click_checkbox(app, "Checkbox")

    # Change the date input value.
    form_1.get_by_test_id("stDateInput").locator("input").click()
    app.locator(
        '[data-baseweb="calendar"] [aria-label^="Choose Wednesday, July 17th 2019."]'
    ).first.click()

    # Change the multiselect value.
    form_1.get_by_test_id("stMultiSelect").locator("input").click()
    app.locator("[data-baseweb='popover'] >> li").nth(0).click()

    # Change the number input value.
    form_1.get_by_test_id("stNumberInput").locator("input").fill("42")

    # Change the radio value.
    form_1.get_by_test_id("stRadio").locator('label[data-baseweb="radio"]').nth(
        1
    ).click(force=True)

    # Change the selectbox value.
    form_1.get_by_test_id("stSelectbox").locator("input").click()
    app.locator("[data-baseweb='popover']").locator("li").nth(1).click()

    # Change the select slider value.
    form_1.get_by_test_id("stSlider").nth(0).get_by_role("slider").press("ArrowRight")

    # Change the slider value.
    form_1.get_by_test_id("stSlider").nth(1).get_by_role("slider").press("ArrowRight")

    # Change the text area value.
    form_1.get_by_test_id("stTextArea").locator("textarea").fill("bar")

    # Change the text input value.
    form_1.get_by_test_id("stTextInput").locator("input").fill("bar")

    # Change the time input value.
    form_1.get_by_test_id("stTimeInput").locator("input").click()
    app.locator('[data-baseweb="popover"]').locator("li").nth(0).click()

    # Change the toggle value.
    click_toggle(app, "Toggle Input")


def test_does_not_change_values_before_form_submitted(app: Page):
    """Query for markdown elements after the form."""
    markdown_elements = app.get_by_test_id("stMarkdown")

    # Change widget values without submitting the form.
    change_widget_values(app)

    # Assert that the values did not change.
    expect(markdown_elements.nth(0)).to_have_text("Checkbox: False")
    expect(markdown_elements.nth(1)).to_have_text("Date Input: 2019-07-06")
    expect(markdown_elements.nth(2)).to_have_text("Multiselect: foo")
    expect(markdown_elements.nth(3)).to_have_text("Number Input: 0.0")
    expect(markdown_elements.nth(4)).to_have_text("Radio: foo")
    expect(markdown_elements.nth(5)).to_have_text("Selectbox: foo")
    expect(markdown_elements.nth(6)).to_have_text("Select Slider: foo")
    expect(markdown_elements.nth(7)).to_have_text("Slider: 0")
    expect(markdown_elements.nth(8)).to_have_text("Text Area: foo")
    expect(markdown_elements.nth(9)).to_have_text("Text Input: foo")
    expect(markdown_elements.nth(10)).to_have_text("Time Input: 08:45:00")
    expect(markdown_elements.nth(11)).to_have_text("Toggle Input: False")


def test_changes_widget_values_after_form_submitted(app: Page):
    # Change widget values and submit the form.
    change_widget_values(app)
    app.get_by_test_id("stFormSubmitButton").nth(0).locator("button").click()
    wait_for_app_run(app)

    # Query for markdown elements after the form
    markdown_elements = app.get_by_test_id("stMarkdown")

    # Assert that the values have changed.
    expect(markdown_elements.nth(0)).to_have_text("Checkbox: True")
    expect(markdown_elements.nth(1)).to_have_text("Date Input: 2019-07-17")
    expect(markdown_elements.nth(2)).to_have_text("Multiselect: foo, bar")
    expect(markdown_elements.nth(3)).to_have_text("Number Input: 42.0")
    expect(markdown_elements.nth(4)).to_have_text("Radio: bar")
    expect(markdown_elements.nth(5)).to_have_text("Selectbox: bar")
    expect(markdown_elements.nth(6)).to_have_text("Select Slider: bar")
    expect(markdown_elements.nth(7)).to_have_text("Slider: 1")
    expect(markdown_elements.nth(8)).to_have_text("Text Area: bar")
    expect(markdown_elements.nth(9)).to_have_text("Text Input: bar")
    expect(markdown_elements.nth(10)).to_have_text("Time Input: 00:00:00")
    expect(markdown_elements.nth(11)).to_have_text("Toggle Input: True")


def test_form_with_stretched_button(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Tests if the form with stretched submit button renders correctly."""
    form_2 = themed_app.get_by_test_id("stForm").nth(1)

    assert_snapshot(form_2, name="st_form-with_stretched_submit_button")

    submit_buttons = form_2.get_by_test_id("stFormSubmitButton")
    expect(submit_buttons).to_have_count(2)

    submit_button = submit_buttons.nth(0)
    submit_button.hover()
    expect(themed_app.get_by_test_id("stTooltipContent")).to_have_text(
        "Submit by clicking"
    )


def test_form_submit_with_emoji_icon(app: Page, assert_snapshot: ImageCompareFunction):
    """Tests if the form submit button with emoji icon renders correctly."""
    form_4 = app.get_by_test_id("stForm").nth(3)

    assert_snapshot(form_4, name="st_form_submit-emoji_icon")


def test_form_submit_with_material_icon(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Tests if the form submit button with material icon renders correctly."""
    form_5 = app.get_by_test_id("stForm").nth(4)

    assert_snapshot(form_5, name="st_form_submit-material_icon")


def test_form_submits_on_enter(app: Page):
    """Tests that submit on enter works when 1st submit button enabled."""
    form_6 = app.get_by_test_id("stForm").nth(5)
    text_input = form_6.get_by_test_id("stTextInput").locator("input")
    text_input.type("Test")
    expect(form_6.get_by_test_id("InputInstructions")).to_have_text(
        "Press Enter to submit form"
    )

    # Submit the form by pressing Enter, check if submitted.
    text_input.press("Enter")
    wait_for_app_run(app)
    expect(form_6.get_by_test_id("stMarkdown").last).to_have_text("Form submitted")


def test_form_disabled_submit_on_enter(app: Page):
    """Tests that submit on enter does not work when 1st submit button disabled."""
    form_7 = app.get_by_test_id("stForm").nth(6)
    text_input = form_7.get_by_test_id("stTextInput").locator("input")
    text_input.fill("Test")
    expect(form_7.get_by_test_id("InputInstructions")).to_have_text("")

    # Try to submit the form by pressing Enter, check not submitted.
    text_input.press("Enter")
    wait_for_app_run(app)
    expect(form_7.get_by_test_id("stMarkdown").last).not_to_have_text("Form submitted")


def test_enter_to_submit_false(app: Page):
    """Tests that pressing Enter does not submit form when enter_to_submit=False."""
    form_8 = app.get_by_test_id("stForm").nth(7)
    number_input = form_8.get_by_test_id("stNumberInput").locator("input")
    number_input.fill("42")
    expect(form_8.get_by_test_id("InputInstructions")).to_have_text("")

    # Try to submit the form by pressing Enter, check not submitted.
    number_input.press("Enter")
    wait_for_app_run(app)
    expect(form_8.get_by_test_id("stMarkdown").last).not_to_have_text("Form submitted")


def test_form_submits_on_click(app: Page):
    """Tests that submit via enabled form submit button works."""
    form_6 = app.get_by_test_id("stForm").nth(5)
    text_input = form_6.get_by_test_id("stTextInput").locator("input")
    text_input.fill("Test")
    expect(form_6.get_by_test_id("InputInstructions")).to_have_text(
        "Press Enter to submit form"
    )

    # Submit form with enabled submit button, check submitted
    form_6.get_by_test_id("stFormSubmitButton").first.click()
    wait_for_app_run(app)
    expect(form_6.get_by_test_id("stMarkdown").last).to_have_text("Form submitted")


def test_form_disabled_submit_on_click(app: Page):
    """Tests that submit via disabled form submit button does not work."""
    form_7 = app.get_by_test_id("stForm").nth(6)
    text_input = form_7.get_by_test_id("stTextInput").locator("input")
    text_input.fill("Test")
    expect(form_7.get_by_test_id("InputInstructions")).to_have_text("")

    # Try submit with disabled submit button, check not submitted
    form_7.get_by_test_id("stFormSubmitButton").first.click()
    wait_for_app_run(app)
    expect(form_7.get_by_test_id("stMarkdown").last).not_to_have_text("Form submitted")


def test_secondary_submit_buttons_enabled(app: Page):
    """Tests that secondary submit buttons work when enabled."""
    form_7 = app.get_by_test_id("stForm").nth(6)
    text_input = form_7.get_by_test_id("stTextInput").locator("input")
    text_input.fill("Test")
    expect(form_7.get_by_test_id("InputInstructions")).to_have_text("")

    # Submit form with secondary submit button, check submitted
    form_7.get_by_test_id("stFormSubmitButton").last.click()
    wait_for_app_run(app)
    expect(form_7.get_by_test_id("stMarkdown").last).to_have_text("Form submitted")


def test_borderless_form(app: Page, assert_snapshot: ImageCompareFunction):
    """Tests if the borderless form (border=False) renders correctly."""
    form_3 = app.get_by_test_id("stForm").nth(2)

    assert_snapshot(form_3, name="st_form-borderless")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stForm")


def test_check_form_submit_button_types(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Check that the form submit button types are correctly set."""
    form_9 = app.get_by_test_id("stForm").nth(8)
    assert_snapshot(form_9, name="st_form-primary_submit_button")

    form_10 = app.get_by_test_id("stForm").nth(9)
    assert_snapshot(form_10, name="st_form-tertiary_submit_button")


================================================
File: /e2e_playwright/st_fragment_basics.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from datetime import date
from uuid import uuid4

import streamlit as st


# Write a bunch of widgets so that we can interact with them and verify that only the
# uuid within the fragment changes in the script run.
# NOTE: We intentionally don't verify that values returned by these widgets work as
# expected as doing so in this type of batch test would drastically increase the
# boilerplate code required to write this. Instead, we rely on other tests to fully test
# return values. We also don't test the audio_input, camera_input, data_editor, and
# file_uploader widgets as well as custom components here due to the disproportionate
# amount of work required to do so.
@st.fragment
def my_big_fragment():
    st.button("a button")
    st.download_button("a download button", b"")
    st.chat_input("a chat input")
    st.checkbox("a checkbox")
    st.color_picker("a color picker")
    st.date_input("a date input", date(1970, 1, 1), min_value=date(1970, 1, 1))
    st.multiselect("a multiselect", ["a", "b", "c"])
    st.number_input("a number input")
    st.radio("a radio", ["a", "b", "c"])
    st.selectbox("a selectbox", ["a", "b", "c"])
    st.slider("a slider")
    st.text_area("a text area")
    st.text_input("a text input")
    st.time_input("a time input")

    st.write(f"inside fragment: {uuid4()}")


my_big_fragment()

st.write(f"outside: fragment {uuid4()}")


================================================
File: /e2e_playwright/st_fragment_basics_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import wait_for_app_run
from e2e_playwright.shared.app_utils import click_button, click_checkbox


def get_uuids(app: Page):
    expect(app.get_by_test_id("stMarkdown")).to_have_count(2)

    text_in_fragment = app.get_by_test_id("stMarkdown").first.text_content()
    text_outside_fragment = app.get_by_test_id("stMarkdown").last.text_content()

    return text_in_fragment, text_outside_fragment


def expect_only_fragment_uuid_changed(
    app: Page, old_text_in_fragment: str, old_text_outside_fragment: str
):
    expect(app.get_by_test_id("stMarkdown").first).not_to_have_text(
        old_text_in_fragment
    )
    expect(app.get_by_test_id("stMarkdown").last).to_have_text(
        old_text_outside_fragment
    )


def test_button_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    click_button(app, "a button")

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_download_button_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    app.get_by_test_id("stDownloadButton").locator("button").click()
    wait_for_app_run(app)

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_chat_input_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    chat_input_area = app.get_by_test_id("stChatInputTextArea")
    chat_input_area.type("Corgi")
    chat_input_area.press("Enter")
    wait_for_app_run(app)

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_checkbox_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    click_checkbox(app, "a checkbox")

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_color_picker_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    color_block_element = app.get_by_test_id("stColorPickerBlock")
    color_block_element.click()
    app.locator('[data-baseweb="popover"]').locator("input").fill("0xFFFFFF")
    color_block_element.click()
    wait_for_app_run(app)

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_date_input_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    app.get_by_test_id("stDateInput").click()
    app.locator(
        '[data-baseweb="calendar"] [aria-label^="Choose Friday, January 2nd 1970."]'
    ).first.click()
    wait_for_app_run(app)

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_multiselect_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    app.get_by_test_id("stMultiSelect").locator("input").click()
    app.locator("li").first.click()
    app.keyboard.press("Escape")
    wait_for_app_run(app)

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_number_input_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    first_number_input_field = app.get_by_test_id("stNumberInput").locator("input")
    first_number_input_field.fill("10")
    first_number_input_field.press("Enter")
    wait_for_app_run(app)

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_radio_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    radio = app.get_by_test_id("stRadio").locator('label[data-baseweb="radio"]').nth(1)
    radio.scroll_into_view_if_needed()
    radio.click(force=True)
    wait_for_app_run(app)

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_selectbox_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    app.get_by_test_id("stSelectbox").locator("input").click()
    selection_dropdown = app.locator('[data-baseweb="popover"]').first
    selection_dropdown.locator("li").nth(1).click()
    app.get_by_test_id("stSelectbox").locator("input").click()
    wait_for_app_run(app)

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


# TODO(vdonato): Figure out how to get this test to work. I'm currently having some
# trouble getting Playwright to correctly manipulate st.slider (although manual testing
# verifies that sliders work as expected from within fragments.
@pytest.mark.skip
def test_slider_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    slider_element = app.get_by_test_id("stSliderThumbValue")
    slider_element.click(force=True)
    slider_element.press("ArrowRight")
    wait_for_app_run(app)

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_text_area_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    text_area_field = app.get_by_test_id("stTextArea").locator("textarea")
    text_area_field.fill("hello world")
    text_area_field.press("Control+Enter")
    wait_for_app_run(app)

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_text_input_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    first_text_input_field = app.get_by_test_id("stTextInput").locator("input")
    first_text_input_field.fill("hello world")
    first_text_input_field.press("Enter")
    wait_for_app_run(app)

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_time_input_in_fragment(app: Page):
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    time_input_field = app.get_by_test_id("stTimeInput").locator("input")
    time_input_field.type("00:15")
    time_input_field.press("Enter")
    wait_for_app_run(app)

    expect_only_fragment_uuid_changed(
        app, old_text_in_fragment, old_text_outside_fragment
    )


def test_full_app_rerun(app: Page):
    """On a full rerun, verify that the uuids both inside and outside the fragment changed."""
    old_text_in_fragment, old_text_outside_fragment = get_uuids(app)

    app.keyboard.press("r")
    wait_for_app_run(app)

    expect(app.get_by_test_id("stMarkdown").first).not_to_have_text(
        old_text_in_fragment
    )
    expect(app.get_by_test_id("stMarkdown").last).not_to_have_text(
        old_text_outside_fragment
    )


================================================
File: /e2e_playwright/st_fragment_chat_response.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

import streamlit as st

st.header("Chat response cell")
st.caption('The "LLM-generated" code runs independently of the rest of the page')


line_chart_response = """
Here, have a line chart,
```python
import streamlit as st
import pandas as pd

app_df = pd.DataFrame([[1, 1, 1], [2, 2, 2], [3, 3, 2], [4, 4, 2], [5, 5, 3]], columns=["day", "apps", "external_apps"])
exclude = st.checkbox("Exclude internal apps")
y = "apps" if not exclude else "external_apps"
st.line_chart(app_df, x="day", y=y)
```
"""


@st.fragment
def parse_and_exec(response):
    code_match = re.search(r"```python\n(.*)\n```", response, re.DOTALL)
    if code_match:
        code = code_match.group(1)
        exec(code)


messages = [
    {"role": "user", "content": "how2LineChartPlz"},
    {"role": "assistant", "content": line_chart_response},
]

for msg in messages:
    st.chat_message(msg["role"]).write(msg["content"])
    parse_and_exec(msg["content"])


================================================
File: /e2e_playwright/st_fragment_chat_response_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
from playwright.sync_api import Page

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import click_checkbox


# Only run tests on chromium as this can otherwise create a lot of screenshots, and
# we're only using the screenshots to verify that the app state changed as expected
# rather than using them for precise visual testing anyway.
@pytest.mark.only_browser("chromium")
def test_chat_response(app: Page, assert_snapshot: ImageCompareFunction):
    # Take a screenshot of the original chart
    assert_snapshot(
        app.get_by_test_id("stVegaLiteChart"),
        name="chart_before_fragment_rerun",
    )

    # Click on the checkbox to edit the chart
    click_checkbox(app, "Exclude internal apps")

    # Take a screenshot of the modified chart
    assert_snapshot(
        app.get_by_test_id("stVegaLiteChart"),
        name="chart_after_fragment_rerun",
    )


================================================
File: /e2e_playwright/st_fragment_dynamic_containers.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st


@st.fragment
def show_page():
    checkmark = st.checkbox("Yes or No")

    if checkmark:
        st.tabs(["Tab A", "Tab B", "Tab C"])
    else:
        st.tabs(["Tab 1", "Tab 2"])


show_page()


================================================
File: /e2e_playwright/st_fragment_dynamic_containers_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.shared.app_utils import click_checkbox


def _expect_numeric_tabs(app: Page):
    tabs = app.get_by_test_id("stTabs")
    expect(tabs).to_have_count(1)
    tab_buttons = tabs.locator("button")
    expect(tab_buttons).to_have_count(2)
    expect(tab_buttons.nth(0)).to_have_text("Tab 1")
    expect(tab_buttons.nth(1)).to_have_text("Tab 2")


def _expect_letter_tabs(app: Page):
    tabs = app.get_by_test_id("stTabs")
    expect(tabs).to_have_count(1)
    tab_buttons = tabs.locator("button")
    expect(tab_buttons).to_have_count(3)
    expect(tab_buttons.nth(0)).to_have_text("Tab A")
    expect(tab_buttons.nth(1)).to_have_text("Tab B")
    expect(tab_buttons.nth(2)).to_have_text("Tab C")


def test_correct_tabs_are_shown_and_no_ghost_tabs(app: Page):
    """When we render a different amount of tabs, we want the
    correct tabs to show and no tabs from the previous fragment
    run (see issue https://github.com/streamlit/streamlit/issues/9158).
    """
    _expect_numeric_tabs(app)

    # Ensure that this works for multiple runs
    for _ in range(10):
        click_checkbox(app, "Yes or No")
        _expect_letter_tabs(app)

        click_checkbox(app, "Yes or No")
        _expect_numeric_tabs(app)


================================================
File: /e2e_playwright/st_fragment_dynamic_form.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import streamlit as st

st.header("Dynamic form - full app only runs on submit")

states = {
    "USA": ["", "California", "Washington", "New Jersey"],
    "Canada": ["", "Quebec", "Ontario", "British Columbia"],
    "Germany": ["", "Brandenberg", "Hesse", "Bavaria"],
}


@st.fragment
def get_location():
    with st.container(border=True):
        st.subheader("Enter your location")

        city = None
        state = None

        country = st.selectbox("Country", ["", "USA", "Canada", "Germany"])

        if country:
            state = st.selectbox("State", states[country])
        if state:
            city = st.text_input("City")

        submit_enabled = city and state and country
        if st.button("Submit", type="primary", disabled=not submit_enabled):
            if len(city) < 8:
                st.warning(f"City name {city} must be at least 8 characters")
            else:
                st.session_state.new_location = {
                    "country": country,
                    "state": state,
                    "city": city,
                }
                st.rerun()


get_location()

if "new_location" in st.session_state:
    result = st.session_state.pop("new_location")
    st.success("We have recorded your location, thank you!")
    "Response:"
    st.json(result)


================================================
File: /e2e_playwright/st_fragment_dynamic_form_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import wait_for_app_run


def expect_correct_app_state(
    app: Page, num_selectboxes: int, num_text_inputs: int, num_jsons: int
):
    expect(app.get_by_test_id("stSelectbox")).to_have_count(num_selectboxes)
    expect(app.get_by_test_id("stTextInput")).to_have_count(num_text_inputs)
    expect(app.get_by_test_id("stJson")).to_have_count(num_jsons)


def test_dynamic_form(app: Page):
    expect_correct_app_state(
        app,
        num_selectboxes=1,
        num_text_inputs=0,
        num_jsons=0,
    )

    # Select a country
    app.get_by_test_id("stSelectbox").locator("input").first.click()
    selection_dropdown = app.locator('[data-baseweb="popover"]').first
    selection_dropdown.locator("li").nth(1).click()
    wait_for_app_run(app)

    expect_correct_app_state(
        app,
        num_selectboxes=2,
        num_text_inputs=0,
        num_jsons=0,
    )

    # Select a state
    app.get_by_test_id("stSelectbox").locator("input").last.click()
    selection_dropdown = app.locator('[data-baseweb="popover"]').first
    selection_dropdown.locator("li").nth(1).click()
    wait_for_app_run(app)

    expect_correct_app_state(
        app,
        num_selectboxes=2,
        num_text_inputs=1,
        num_jsons=0,
    )

    # Enter a city name and click submit.
    text_input_field = app.get_by_test_id("stTextInput").locator("input")
    text_input_field.fill("Berkeley")
    text_input_field.press("Enter")

    # Submit and validate output
    app.get_by_test_id("stButton").locator("button").click()
    expect_correct_app_state(
        app,
        num_selectboxes=2,
        num_text_inputs=1,
        num_jsons=1,
    )


================================================
File: /e2e_playwright/st_fragment_mixed_execution_flow.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time
from uuid import uuid4

import streamlit as st

if "sleep_time" not in st.session_state:
    st.session_state["sleep_time"] = 0
sleep_time = st.session_state["sleep_time"]


@st.fragment
def my_fragment(n):
    with st.container(border=True):
        st.button("rerun this fragment", key=n)
        st.write(f"uuid in fragment {n}: {uuid4()}")
    # sleep here so that we have time to react to the flow
    # and trigger buttons etc. before the fragment is finished
    # and the next starts to render
    time.sleep(sleep_time)


my_fragment(1)
my_fragment(2)
my_fragment(3)

st.session_state["sleep_time"] = 3
st.button("Full app rerun")


================================================
File: /e2e_playwright/st_fragment_mixed_execution_flow_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import wait_for_app_run


def get_uuids(app: Page):
    expect(app.get_by_test_id("stMarkdown")).to_have_count(2)

    fragment_1_text = app.get_by_test_id("stMarkdown").first.text_content()
    fragment_2_text = app.get_by_test_id("stMarkdown").last.text_content()

    return fragment_1_text, fragment_2_text


def test_fragments_rerun_correctly_during_full_app_run(app: Page):
    """Test that fragments can send fragment-bound reruns during full app runs.

    Click on the full app rerun button and immediately click on the second
    fragment button. This will send a rerun message bound to the fragment while
    the full app run is still executing. The expectation is that the full app
    run is still continuing and the following fragments are also registered
    and executing correctly.
    """

    app.get_by_test_id("stButton").locator("button").filter(
        has_text="Full app rerun"
    ).click()

    # wait until first fragment is finished
    sleep_time_of_fragment = 3500
    app.wait_for_timeout(sleep_time_of_fragment)

    app.get_by_test_id("stButton").locator("button").nth(1).click()
    wait_for_app_run(app)

    expect(
        app.get_by_test_id("stMarkdown").filter(has_text="uuid in fragment 1").first
    ).to_be_attached()
    expect(
        app.get_by_test_id("stMarkdown").filter(has_text="uuid in fragment 2").first
    ).to_be_attached()
    expect(
        app.get_by_test_id("stMarkdown").filter(has_text="uuid in fragment 3").first
    ).to_be_attached()


================================================
File: /e2e_playwright/st_fragment_multiple_fragments.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from uuid import uuid4

import streamlit as st

raise_exception = st.checkbox("Raise Exception in Fragment", value=False)


@st.fragment
def my_fragment(n):
    with st.container(border=True):
        st.button("rerun this fragment", key=n)
        st.write(f"uuid in fragment {n}: {uuid4()}")


@st.fragment
def exception_raising_fragment():
    if st.checkbox("Raise Exception", value=raise_exception):
        raise RuntimeError("This is an exception raised in a fragment")


my_fragment(1)
# fragment that raises an exception during full app run stops the execution
exception_raising_fragment()
my_fragment(2)


================================================
File: /e2e_playwright/st_fragment_multiple_fragments_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Locator, Page, expect

from e2e_playwright.conftest import wait_for_app_run


def _get_uuids(app: Page, expected_markdown_count: int = 2):
    """Test that fragments run and the uuids are written."""
    expect(app.get_by_test_id("stMarkdown")).to_have_count(expected_markdown_count)

    fragment_1_text = app.get_by_test_id("stMarkdown").first.text_content()
    fragment_2_text = app.get_by_test_id("stMarkdown").last.text_content()

    return fragment_1_text, fragment_2_text


def _get_fragment_checkbox(app: Page) -> Locator:
    return app.get_by_test_id("stCheckbox").nth(1).locator("span").first


def _get_app_raise_exception_checkbox(app: Page) -> Locator:
    return app.get_by_test_id("stCheckbox").nth(0).locator("span").first


def test_fragments_run_independently(app: Page):
    fragment_1_text, fragment_2_text = _get_uuids(app)

    # Click the first button and verify that only the uuid in the first fragment
    # changed.
    app.get_by_test_id("stButton").locator("button").first.click()
    wait_for_app_run(app)
    expect(app.get_by_test_id("stMarkdown").first).not_to_have_text(fragment_1_text)
    expect(app.get_by_test_id("stMarkdown").last).to_have_text(fragment_2_text)

    fragment_1_text, fragment_2_text = _get_uuids(app)

    # Click the second button and verify that only the uuid in the second fragment
    # changed.
    app.get_by_test_id("stButton").locator("button").last.click()
    wait_for_app_run(app)
    expect(app.get_by_test_id("stMarkdown").first).to_have_text(fragment_1_text)
    expect(app.get_by_test_id("stMarkdown").last).not_to_have_text(fragment_2_text)


