    // But we still run all other validations on the corrected value below.
    let corrected = false

    if (parameters.max_chars && cellData.length > parameters.max_chars) {
      cellData = cellData.slice(0, parameters.max_chars)
      corrected = true
    }

    if (
      validateRegex instanceof RegExp &&
      validateRegex.test(cellData) === false
    ) {
      return false
    }

    return corrected ? cellData : true
  }

  return {
    ...props,
    kind: "text",
    sortMode: "default",
    validateInput,
    getCell(data?: any, validate?: boolean): GridCell {
      if (typeof validateRegex === "string") {
        // The regex is invalid, we return an error to indicate this
        // to the developer:
        return getErrorCell(toSafeString(data), validateRegex)
      }

      if (validate) {
        const validationResult = validateInput(data)
        if (validationResult === false) {
          // The input is invalid, we return an error cell which will
          // prevent this cell to be inserted into the table.
          // This cell should never be actually displayed to the user.
          // It's mostly used internally to prevent invalid input to be
          // inserted into the table.
          return getErrorCell(toSafeString(data), "Invalid input.")
        } else if (typeof validationResult === "string") {
          // Apply corrections:
          data = validationResult
        }
      }

      try {
        const cellData = notNullOrUndefined(data) ? toSafeString(data) : null
        const displayData = notNullOrUndefined(cellData)
          ? removeLineBreaks(cellData) // Remove line breaks to show all content in the cell
          : ""
        return {
          ...cellTemplate,
          isMissingValue: isNullOrUndefined(cellData),
          data: cellData,
          displayData,
        } as TextCell
      } catch (error) {
        // This should never happen, but if it does, we want to show an error
        return getErrorCell(
          "Incompatible value",
          `The value cannot be interpreted as string. Error: ${error}`
        )
      }
    },
    getCellValue(cell: TextCell): string | null {
      return cell.data === undefined ? null : cell.data
    },
  }
}

TextColumn.isEditableType = true

export default TextColumn


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/index.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  AreaChartColumn,
  BarChartColumn,
  LineChartColumn,
} from "./ChartColumn"
import CheckboxColumn from "./CheckboxColumn"
import DateTimeColumn, { DateColumn, TimeColumn } from "./DateTimeColumn"
import ImageColumn from "./ImageColumn"
import LinkColumn from "./LinkColumn"
import ListColumn from "./ListColumn"
import NumberColumn from "./NumberColumn"
import ObjectColumn from "./ObjectColumn"
import ProgressColumn from "./ProgressColumn"
import SelectboxColumn from "./SelectboxColumn"
import TextColumn from "./TextColumn"
import { ColumnCreator } from "./utils"

export { ImageCellEditor } from "./cells/ImageCellEditor"
export type { DateTimeColumnParams } from "./DateTimeColumn"
export type { LinkColumnParams } from "./LinkColumn"
export type { NumberColumnParams } from "./NumberColumn"

export * from "./utils"

/**
 * All available column types need to be registered here.
 *
 * These names must match the column names used in the backend.
 */
export const ColumnTypes = new Map<string, ColumnCreator>(
  Object.entries({
    object: ObjectColumn,
    text: TextColumn,
    checkbox: CheckboxColumn,
    selectbox: SelectboxColumn,
    list: ListColumn,
    number: NumberColumn,
    link: LinkColumn,
    datetime: DateTimeColumn,
    date: DateColumn,
    time: TimeColumn,
    line_chart: LineChartColumn,
    bar_chart: BarChartColumn,
    area_chart: AreaChartColumn,
    image: ImageColumn,
    progress: ProgressColumn,
  })
)

export const CustomCells = []

export {
  AreaChartColumn,
  BarChartColumn,
  CheckboxColumn,
  DateColumn,
  DateTimeColumn,
  ImageColumn,
  LineChartColumn,
  LinkColumn,
  ListColumn,
  NumberColumn,
  ObjectColumn,
  ProgressColumn,
  SelectboxColumn,
  TextColumn,
  TimeColumn,
}


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/utils.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { GridCell, GridCellKind } from "@glideapps/glide-data-grid"
import moment, { Moment } from "moment-timezone"

import { withTimezones } from "@streamlit/lib/src/util/withTimezones"

import {
  BaseColumnProps,
  countDecimals,
  formatMoment,
  formatNumber,
  getEmptyCell,
  getErrorCell,
  getLinkDisplayValueFromRegex,
  getTextCell,
  isErrorCell,
  isMissingValueCell,
  mergeColumnParameters,
  removeLineBreaks,
  toGlideColumn,
  toSafeArray,
  toSafeBoolean,
  toSafeDate,
  toSafeNumber,
  toSafeString,
  truncateDecimals,
} from "./utils"

import { TextColumn } from "./index"

const MOCK_TEXT_COLUMN_PROPS = {
  id: "column_1",
  name: "column_1",
  title: "column_1",
  indexNumber: 0,
  arrowType: {
    pandas_type: "unicode",
    numpy_type: "object",
  },
  isEditable: false,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
} as BaseColumnProps

describe("getErrorCell", () => {
  it("creates a valid error cell", () => {
    const errorCell = getErrorCell("Foo Error", "Lorem Ipsum Dolor")
    expect(errorCell.kind).toEqual(GridCellKind.Text)
    expect(errorCell.readonly).toEqual(true)
    expect(errorCell.allowOverlay).toEqual(true)
    expect(errorCell.displayData).toEqual("Foo Error")
    expect(errorCell.data).toEqual("Foo Error")
    expect(errorCell.errorDetails).toEqual("Lorem Ipsum Dolor")
    expect(errorCell.isError).toEqual(true)
    expect(errorCell.style).toEqual("faded")
  })
})

describe("isErrorCell", () => {
  it("detects error cells", () => {
    const errorCell = getErrorCell("Foo Error")
    expect(isErrorCell(errorCell)).toEqual(true)

    const textCell: GridCell = {
      kind: GridCellKind.Text,
      displayData: "foo",
      data: "foo",
      allowOverlay: true,
    }
    expect(isErrorCell(textCell)).toEqual(false)
  })
})

describe("getEmptyCell", () => {
  it("creates a valid empty cell", () => {
    const emptyCell = getEmptyCell()
    expect(emptyCell.kind).toEqual(GridCellKind.Loading)
    expect(emptyCell.allowOverlay).toEqual(false)
    expect(isMissingValueCell(emptyCell)).toEqual(false)
  })

  it("creates a valid empty cell with missing placeholder", () => {
    const emptyCell = getEmptyCell(true)
    expect(emptyCell.kind).toEqual(GridCellKind.Loading)
    expect(emptyCell.allowOverlay).toEqual(false)
    expect(isMissingValueCell(emptyCell)).toEqual(true)
  })
})

describe("getTextCell", () => {
  it("creates a valid read-only text cell", () => {
    const textCell = getTextCell(true, false)
    expect(textCell.kind).toEqual(GridCellKind.Text)
    expect(textCell.readonly).toEqual(true)
    expect(textCell.allowOverlay).toEqual(true)
    expect(textCell.displayData).toEqual("")
    expect(textCell.data).toEqual("")
  })
})

describe("toSafeArray", () => {
  it.each([
    [null, []],
    [undefined, []],
    ["", []],
    ["foo", ["foo"]],
    // Comma separated syntax
    ["foo,bar", ["foo", "bar"]],
    ["foo,bar,", ["foo", "bar", ""]],
    ["foo,bar,,", ["foo", "bar", "", ""]],
    // JSON Array syntax
    [`["foo","bar"]`, ["foo", "bar"]],
    // non-string values
    [0, [0]],
    [1, [1]],
    [
      [0, 1.2],
      [0, 1.2],
    ],
    [true, [true]],
    [false, [false]],
    [
      [true, false],
      [true, false],
    ],
  ])("converts %s to a valid array: %s", (input, expected) => {
    expect(toSafeArray(input)).toEqual(expected)
  })
})

describe("toSafeString", () => {
  it.each([
    [null, ""],
    [undefined, ""],
    [[], ""],
    ["", ""],
    ["foo", "foo"],
    ["abc def 1234 $", "abc def 1234 $"],
    [0, "0"],
    [1, "1"],
    [0.123, "0.123"],
    [true, "true"],
    [false, "false"],
    [["foo", "bar"], "foo,bar"],
    [[1, 2, 0.1231], "1,2,0.1231"],
    [
      {
        foo: "bar",
      },
      "[object Object]",
    ],
  ])("converts %s to a valid string: %s", (input, expected) => {
    expect(toSafeString(input)).toEqual(expected)
  })
})

describe("toSafeBoolean", () => {
  it.each([
    [true, true],
    [false, false],
    ["true", true],
    ["false", false],
    ["yes", true],
    ["no", false],
    ["t", true],
    ["f", false],
    ["y", true],
    ["n", false],
    ["on", true],
    ["off", false],
    ["1", true],
    ["0", false],
    [1, true],
    [0, false],
    [[], null],
    [null, null],
    [undefined, null],
    ["", null],
    ["foo", undefined],
    [12345, undefined],
    [[1, 2], undefined],
    [0.1, undefined],
  ])("converts %s to a boolean: %s", (input, expected) => {
    expect(toSafeBoolean(input)).toEqual(expected)
  })
})

describe("toSafeNumber", () => {
  it.each([
    [null, null],
    [undefined, null],
    ["", null],
    ["foo", NaN],
    [["foo"], NaN],
    [
      {
        foo: "bar",
      },
      NaN,
    ],
    [[], NaN],
    ["123", 123],
    ["123 ", 123],
    [" 123 ", 123],
    [" 123", 123],
    ["123.456", 123.456],
    ["123,456", 123456],
    ["123,456.789", 123456.789],
    ["123,456,789", 123456789],
    ["123,456,789.123", 123456789.123],
    ["4.12", 4.12],
    ["-4.12", -4.12],
    [1.3122, 1.3122],
    [123, 123],
    ["1,212.12", 1212.12],
    [".1312314", 0.1312314],
    [true, 1],
    [false, 0],
  ])("converts %s to a valid number: %s", (input, expected) => {
    expect(toSafeNumber(input)).toEqual(expected)
  })
})

describe("formatNumber", () => {
  it.each([
    [10, "10"],
    [10.1, "10.1"],
    [10.123, "10.123"],
    [10.1234, "10.1234"],
    // Rounds to 4 decimals
    [10.12346, "10.1235"],
    [0.00016, "0.0002"],
    // If number is smaller than 0.0001, shows the next decimal number
    // to avoid showing 0 for small numbers.
    [0.000051, "0.00005"],
    [0.00000123, "0.000001"],
    [0.00000183, "0.000002"],
    [0.0000000061, "0.000000006"],
  ])(
    "formats %s to %s with default options (no trailing zeros)",
    (value, expected) => {
      expect(formatNumber(value)).toEqual(expected)
    }
  )

  it.each([
    [10, 0, "10"],
    [10, 4, "10.0000"],
    [10.123, 0, "10"],
    [10.123, 1, "10.1"],
    [10.123, 2, "10.12"],
    [10.123, 3, "10.123"],
    [10.123, 4, "10.1230"],
    [10.123, 5, "10.12300"],
    [0.123, 0, "0"],
    [0.123, 1, "0.1"],
  ])(
    "formats %s to %s with %s decimals (keeps trailing zeros)",
    (value, decimals, expected) => {
      expect(formatNumber(value, undefined, decimals)).toEqual(expected)
    }
  )

  it.each([
    [0.5, "percent", "50.00%"],
    [0.51236, "percent", "51.24%"],
    [1.1, "percent", "110.00%"],
    [0, "percent", "0.00%"],
    [0.00001, "percent", "0.00%"],
    [1000, "compact", "1K"],
    [1100, "compact", "1.1K"],
    [10, "compact", "10"],
    [10.123, "compact", "10"],
    [123456789, "compact", "123M"],
    [1000, "scientific", "1E3"],
    [123456789, "scientific", "1.235E8"],
    [1000, "engineering", "1E3"],
    [123456789, "engineering", "123.457E6"],
    // sprintf format
    [10.123, "%d", "10"],
    [10.123, "%i", "10"],
    [10.123, "%u", "10"],
    [10.123, "%f", "10.123"],
    [10.123, "%g", "10.123"],
    [10, "$%.2f", "$10.00"],
    [10.126, "$%.2f", "$10.13"],
    [10.123, "%.2f€", "10.12€"],
    [10.126, "($%.2f)", "($10.13)"],
    [65, "%d years", "65 years"],
    [1234567898765432, "%d ⭐", "1234567898765432 ⭐"],
    [72.3, "%.1f%%", "72.3%"],
    [-5.678, "%.1f", "-5.7"],
    [0.123456, "%.4f", "0.1235"],
    [0.123456, "%.4g", "0.1235"],
    // Test boolean formatting:
    [1, "%t", "true"],
    [0, "%t", "false"],
    // Test zero-padding for integers
    [42, "%05d", "00042"],
    // Test scientific notations:
    [1234.5678, "%.2e", "1.23e+3"],
    [0.000123456, "%.2e", "1.23e-4"],
    // Test hexadecimal representation:
    [255, "%x", "ff"],
    [255, "%X", "FF"],
    [4096, "%X", "1000"],
    // Test octal representation:
    [8, "%o", "10"],
    [64, "%o", "100"],
    // Test fixed width formatting:
    [12345, "%8d", "   12345"],
    [12.34, "%8.2f", "   12.34"],
    [12345, "%'_8d", "___12345"],
    // Test left-justified formatting:
    [12345, "%-8d", "12345   "],
    [12.34, "%-8.2f", "12.34   "],
    // Test prefixing with plus sign:
    [42, "%+d", "+42"],
    [-42, "%+d", "-42"],
  ])("formats %s with format %s to '%s'", (value, format, expected) => {
    expect(formatNumber(value, format)).toEqual(expected)
  })

  it.each([
    [10, "%d %d"],
    [1234567.89, "%'_,.2f"],
    [1234.5678, "%+.2E"],
    [0.000123456, "%+.2E"],
    [-0.000123456, "%+.2E"],
    [255, "%#x"],
    [4096, "%#X"],
    [42, "% d"],
    [1000, "%,.0f"],
    [25000.25, "$%,.2f"],
    [9876543210, "%,.0f"],
  ])(
    "cannot format %s using the invalid sprintf format %s",
    (input: number, format: string) => {
      expect(() => {
        formatNumber(input, format)
      }).toThrow()
    }
  )
})

describe("mergeColumnParameters", () => {
  it("should merge the default and user parameters", () => {
    const defaultParams = {
      foo: "bar",
      bar: "baz",
    }
    const userParams = {
      foo: "baz",
      baz: "qux",
    }
    const mergedParams = mergeColumnParameters(defaultParams, userParams)
    expect(mergedParams).toEqual({
      foo: "baz",
      bar: "baz",
      baz: "qux",
    })
  })
})

describe("isMissingValueCell", () => {
  it("detects if a cell has a missing value", () => {
    const textColumn = TextColumn(MOCK_TEXT_COLUMN_PROPS)

    expect(isMissingValueCell(textColumn.getCell(null))).toBe(true)
    expect(isMissingValueCell(textColumn.getCell("foo"))).toBe(false)
  })
})

describe("toGlideColumn", () => {
  it("should convert form our BaseColumn to a glide-data-grid compatible column", () => {
    const textColumn = TextColumn(MOCK_TEXT_COLUMN_PROPS)
    const glideColumn = toGlideColumn(textColumn)

    expect(glideColumn).toEqual({
      id: MOCK_TEXT_COLUMN_PROPS.id,
      title: MOCK_TEXT_COLUMN_PROPS.title,
      hasMenu: false,
      themeOverride: MOCK_TEXT_COLUMN_PROPS.themeOverride,
      grow: undefined,
      width: undefined,
    })
  })

  it("should set the correct grow based on the isStretched config", () => {
    const textColumn = TextColumn({
      ...MOCK_TEXT_COLUMN_PROPS,
      isStretched: true,
    })

    expect(toGlideColumn(textColumn).grow).toEqual(3)

    // Create index column:
    const indexColumn = TextColumn({
      ...MOCK_TEXT_COLUMN_PROPS,
      isStretched: true,
      isIndex: true,
    })

    expect(toGlideColumn(indexColumn).grow).toEqual(1)
  })
})

function getTodayIsoDate(): string {
  return new Date().toISOString().split("T")[0]
}

describe("toSafeDate", () => {
  it.each([
    // valid date object
    [new Date("2023-04-25"), new Date("2023-04-25")],
    // undefined value
    [undefined, null],
    // null value
    [null, null],
    // empty string
    ["", null],
    // invalid number
    [NaN, undefined],
    // invalid string
    ["foo", undefined],
    // valid date string
    ["2023-04-25", new Date("2023-04-25")],
    // valid unix timestamp in seconds
    [1671951600, new Date("2022-12-25T07:00:00.000Z")],
    // valid bigint timestamp in seconds
    [BigInt(1671951600), new Date("2022-12-25T07:00:00.000Z")],
    // valid unix timestamp in milliseconds
    [1671951600000, new Date("2022-12-25T07:00:00.000Z")],
    // valid unix timestamp in microseconds
    [1671951600000000, new Date("2022-12-25T07:00:00.000Z")],
    // valid unix timestamp in nanoseconds
    [1671951600000000000, new Date("2022-12-25T07:00:00.000Z")],
    // other date formats:
    ["04/25/2023", new Date("2023-04-25T00:00:00.000Z")],
    // invalid string
    ["invalid date", undefined],
    // valid ISO date string
    ["2023-04-25T10:30:00.000Z", new Date("2023-04-25T10:30:00.000Z")],
    // valid date string with time
    ["2023-04-25 10:30", new Date("2023-04-25T10:30:00.000Z")],
    // valid date string with timezone
    ["2023-04-25T10:30:00.000+02:00", new Date("2023-04-25T08:30:00.000Z")],
    // valid time string
    ["10:30", new Date(getTodayIsoDate() + "T10:30:00.000Z")],
    // valid time string with milliseconds
    ["10:30:25.123", new Date(getTodayIsoDate() + "T10:30:25.123Z")],
    // valid time string with seconds
    ["10:30:25", new Date(getTodayIsoDate() + "T10:30:25.000Z")],
    // valid month string
    ["Jan 2023", new Date("2023-01-01T00:00:00.000Z")],
    // valid month string with day
    ["Jan 15, 2023", new Date("2023-01-15T00:00:00.000Z")],
    // valid date string with day and month names
    ["25 April 2023", new Date("2023-04-25T00:00:00.000Z")],
    // valid date string with day and short month names
    ["25 Apr 2023", new Date("2023-04-25T00:00:00.000Z")],
    // valid date string with short day and month names
    ["Tue, 25 Apr 2023", new Date("2023-04-25T00:00:00.000Z")],
    // valid date string with time and AM/PM
    ["2023-04-25 10:30 AM", new Date("2023-04-25T10:30:00.000Z")],
    // valid Unix timestamp in seconds as a string
    ["1671951600", new Date("2022-12-25T07:00:00.000Z")],
  ])("converts input %s to the correct date %s", (input, expectedOutput) => {
    expect(toSafeDate(input)).toEqual(expectedOutput)
  })
})

describe("countDecimals", () => {
  it.each([
    [0, 0],
    [1, 0],
    [0.1, 1],
    [0.01, 2],
    [0.123456789, 9],
    [0.000001, 6],
    [0.0000001, 7],
    [1.23456789e-10, 18],
    [0.0000000000000000001, 19],
    [-0.12345, 5],
    [123456789432, 0],
    // eslint-disable-next-line  @typescript-eslint/no-loss-of-precision
    [123456789876543212312313, 0],
    // It is expected that very large and small numbers won't work correctly:
    // eslint-disable-next-line  @typescript-eslint/no-loss-of-precision
    [1234567898765432.1, 0],
    [0.0000000000000000000001, 0],
    [1.234567890123456e-20, 20],
  ])("should return correct decimal count for %d", (value, expected) => {
    const result = countDecimals(value)
    expect(result).toEqual(expected)
  })
})

describe("truncateDecimals", () => {
  it.each([
    [3.14159265, 2, 3.14],
    [123.456, 1, 123.4],
    [-3.14159265, 2, -3.14],
    [-123.456, 1, -123.4],
    [3.14159265, 0, 3],
    [123.456, 0, 123],
    [-3.14159265, 0, -3],
    [-123.456, 0, -123],
    [42, 0, 42],
    [-42, 0, -42],
    [0.1 + 0.2, 2, 0.3],
  ])(
    "truncates value %f to %i decimal places, resulting in %f",
    (value, decimals, expected) => {
      expect(truncateDecimals(value, decimals)).toBe(expected)
    }
  )
})

withTimezones(() => {
  describe("formatMoment", () => {
    beforeAll(() => {
      const d = new Date("2022-04-28T00:00:00Z")
      vi.useFakeTimers()
      vi.setSystemTime(d)
    })

    afterAll(() => {
      vi.useRealTimers()
    })

    it.each([
      [
        "YYYY-MM-DD HH:mm:ss z",
        moment.utc("2023-04-27T10:20:30Z"),
        "2023-04-27 10:20:30 UTC",
      ],
      [
        "YYYY-MM-DD HH:mm:ss z",
        moment.utc("2023-04-27T10:20:30Z").tz("America/Los_Angeles"),
        "2023-04-27 03:20:30 PDT",
      ],
      [
        "YYYY-MM-DD HH:mm:ss Z",
        moment.utc("2023-04-27T10:20:30Z").tz("America/Los_Angeles"),
        "2023-04-27 03:20:30 -07:00",
      ],
      [
        "YYYY-MM-DD HH:mm:ss Z",
        moment.utc("2023-04-27T10:20:30Z").utcOffset("+04:00"),
        "2023-04-27 14:20:30 +04:00",
      ],
      ["YYYY-MM-DD", moment.utc("2023-04-27T10:20:30Z"), "2023-04-27"],
      [
        "MMM Do, YYYY [at] h:mm A",
        moment.utc("2023-04-27T15:45:00Z"),
        "Apr 27th, 2023 at 3:45 PM",
      ],
      [
        "MMMM Do, YYYY Z",
        moment.utc("2023-04-27T10:20:30Z").utcOffset("-02:30"),
        "April 27th, 2023 -02:30",
      ],
      // Distance:
      ["distance", moment.utc("2022-04-10T20:20:30Z"), "17 days ago"],
      ["distance", moment.utc("2020-04-10T20:20:30Z"), "2 years ago"],
      ["distance", moment.utc("2022-04-27T23:59:59Z"), "a few seconds ago"],
      ["distance", moment.utc("2022-04-20T00:00:00Z"), "8 days ago"],
      ["distance", moment.utc("2022-05-27T23:59:59Z"), "in a month"],
      // Relative:
      ["relative", moment.utc("2022-04-30T15:30:00Z"), "Saturday at 3:30 PM"],
      [
        "relative",
        moment.utc("2022-04-24T12:20:30Z"),
        "Last Sunday at 12:20 PM",
      ],
      ["relative", moment.utc("2022-04-28T12:00:00Z"), "Today at 12:00 PM"],
      ["relative", moment.utc("2022-04-29T12:00:00Z"), "Tomorrow at 12:00 PM"],
    ])(
      "uses %s format to format %s to %s",
      (format: string, momentDate: Moment, expected: string) => {
        expect(formatMoment(momentDate, format)).toBe(expected)
      }
    )
  })
})

test("removeLineBreaks should remove line breaks", () => {
  expect(removeLineBreaks("\n")).toBe(" ")
  expect(removeLineBreaks("\nhello\n\nworld")).toBe(" hello  world")
})

describe("getLinkDisplayValueFromRegex", () => {
  it.each([
    [
      new RegExp("https://(.*?).streamlit.app"),
      "https://example.streamlit.app",
      "example",
    ],
    [
      new RegExp("https://(.*?).streamlit.app"),
      "https://my-cool-app.streamlit.app",
      "my-cool-app",
    ],
    [
      new RegExp("https://(.*?).streamlit.app"),
      "https://example.streamlit.app?param=value",
      "example",
    ],
    [
      new RegExp("https://(.*?).streamlit.app"),
      "https://example.streamlit.app?param1=value1&param2=value2",
      "example",
    ],
    [new RegExp("id=(.*?)&"), "https://example.com?id=123&type=user", "123"],
    [
      new RegExp("[?&]user=(.*?)(?:&|$)"),
      "https://example.com?page=1&user=john_doe&sort=desc",
      "john_doe",
    ],
    [
      new RegExp("https://(.*?).streamlit.app"),
      "https://my%20cool%20app.streamlit.app",
      "my cool app",
    ],
    [
      new RegExp("https://(.*?).streamlit.app"),
      "https://special%21chars%40app.streamlit.app",
      "special!chars@app",
    ],
    [
      new RegExp("user=(.*?)(?:&|$)"),
      "https://example.com?user=john%20doe%40email.com",
      "john doe@email.com",
    ],
    [
      new RegExp("name=(.*?)&"),
      "https://example.com?name=%E2%9C%A8special%20user%E2%9C%A8&type=vip",
      "✨special user✨",
    ],
    [
      new RegExp("q=(.*?)&"),
      "https://example.com?q=%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D1%82&lang=ru",
      "привет",
    ],
    [
      new RegExp("path/(.*?)/"),
      "https://example.com/path/user%20name%20%26%20company/settings",
      "user name & company",
    ],
    [
      new RegExp("search/(.*?)\\?"),
      "https://example.com/search/space%20%26%20time?page=1",
      "space & time",
    ],
    [
      new RegExp("https://(.*?).other.app"),
      "https://example.streamlit.app",
      "https://example.streamlit.app",
    ],
    [new RegExp("https://(.*?).streamlit.app"), null, ""],
    [new RegExp("https://(.*?).streamlit.app"), undefined, ""],
    [
      new RegExp(".*meal=(.*)"),
      "https://example.com/feedme?meal=fish+%26+chips%3A+%C2%A39",
      "fish & chips: £9",
    ],
  ])(
    "extracts display value from %s with href %s to be %s",
    (regex: RegExp, href: string | null | undefined, expected: string) => {
      expect(getLinkDisplayValueFromRegex(regex, href)).toBe(expected)
    }
  )
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/utils.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  BaseGridCell,
  Theme as GlideTheme,
  GridCell,
  GridCellKind,
  GridColumn,
  LoadingCell,
  TextCell,
} from "@glideapps/glide-data-grid"
import merge from "lodash/merge"
import toString from "lodash/toString"
import moment, { Moment } from "moment"
import "moment-duration-format"
import "moment-timezone"
import numbro from "numbro"
import { sprintf } from "sprintf-js"

import { PandasColumnType as ArrowType } from "@streamlit/lib/src/dataframes/arrowTypeUtils"
import { EmotionTheme } from "@streamlit/lib/src/theme"
import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

/**
 * Interface used for defining the properties (configuration options) of a column.
 * These options can also be used to overwrite from user-defined column config.
 */
export interface BaseColumnProps {
  // The id of the column:
  readonly id: string
  // The name of the column from the original data:
  readonly name: string
  // The display title of the column:
  readonly title: string
  // The index number of the column:
  readonly indexNumber: number
  // The arrow data type of the column:
  readonly arrowType: ArrowType
  // If `True`, the column can be edited:
  readonly isEditable: boolean
  // If `True`, the column is hidden (will not be shown):
  readonly isHidden: boolean
  // If `True`, the column is a table index:
  readonly isIndex: boolean
  // If `True`, the column is pinned/frozen:
  readonly isPinned: boolean
  // If `True`, the column is a stretched:
  readonly isStretched: boolean
  // If `True`, a value is required before the cell or row can be submitted:
  readonly isRequired?: boolean
  // The initial width of the column:
  readonly width?: number
  // A help text that is displayed on hovering the column header.
  readonly help?: string
  // Configuration options related to the column type:
  readonly columnTypeOptions?: Record<string, any>
  // The content alignment of the column:
  readonly contentAlignment?: "left" | "center" | "right"
  // The default value of the column used when adding a new row:
  readonly defaultValue?: string | number | boolean
  // Theme overrides for this column:
  readonly themeOverride?: Partial<GlideTheme>
  // A custom icon to be displayed in the column header:
  readonly icon?: string
  // The group that this column belongs to.
  readonly group?: string
}

/**
 * The interface that is implemented by any column type.
 */
export interface BaseColumn extends BaseColumnProps {
  readonly kind: string
  // Defines the sort mode that should be used for this column type:
  // default: Sorts by interpreting all values as strings.
  // smart: Detects if value is a number or a string and sorts accordingly.
  // raw: Sorts based on the actual type of the cell data value.
  readonly sortMode: "default" | "raw" | "smart"
  // Validate the input data for compatibility with the column type:
  // Either returns a boolean indicating if the data is valid or not, or
  // returns the corrected value.
  validateInput?(data?: any): boolean | any
  // Get a cell with the provided data for the column type:
  getCell(data?: any, validate?: boolean): GridCell
  // Get the raw value of the given cell:
  getCellValue(cell: GridCell): any | null
}

/**
 * A type that describes the function signature used to create a column based on
 * some column properties.
 */
export type ColumnCreator = {
  (props: BaseColumnProps, theme: EmotionTheme): BaseColumn
  readonly isEditableType: boolean
}

// See pydantic for inspiration: https://pydantic-docs.helpmanual.io/usage/types/#booleans
const BOOLEAN_TRUE_VALUES = ["true", "t", "yes", "y", "on", "1"]
const BOOLEAN_FALSE_VALUES = ["false", "f", "no", "n", "off", "0"]

/**
 * Interface used for indicating if a cell contains an error.
 */
export interface ErrorCell extends TextCell {
  readonly isError: true
  readonly errorDetails: string
}

/**
 * Returns a cell with an error message.
 *
 * @param errorMsg: A short error message or the wrong value to use as display value.
 * @param errorDetails: The full error message to show when the user
 *                     hovers on a cell.
 *
 * @return a read-only GridCell object that can be used by glide-data-grid.
 */
export function getErrorCell(errorMsg: string, errorDetails = ""): ErrorCell {
  return {
    kind: GridCellKind.Text,
    readonly: true,
    allowOverlay: true,
    data: errorMsg,
    displayData: errorMsg,
    errorDetails: errorDetails,
    isError: true,
    style: "faded",
  }
}

/**
 * Returns `true` if the given cell contains an error.
 * This can happen if the value type is not compatible with
 * the given value type.
 */
export function isErrorCell(cell: GridCell): cell is ErrorCell {
  return cell.hasOwnProperty("isError") && (cell as ErrorCell).isError
}

interface CellWithTooltip extends BaseGridCell {
  readonly tooltip: string
}

/**
 * Returns `true` if the given cell has a tooltip
 */
export function hasTooltip(cell: BaseGridCell): cell is CellWithTooltip {
  return (
    cell.hasOwnProperty("tooltip") && (cell as CellWithTooltip).tooltip !== ""
  )
}
/**
 * Interface used for indicating if a cell contains no value.
 */
interface MissingValueCell extends BaseGridCell {
  readonly isMissingValue: true
}

/**
 * Returns `true` if the given cell contains no value (-> missing value).
 * For example, a number cell that contains null is interpreted as a missing value.
 */
export function isMissingValueCell(
  cell: BaseGridCell
): cell is MissingValueCell {
  return (
    cell.hasOwnProperty("isMissingValue") &&
    (cell as MissingValueCell).isMissingValue
  )
}

/**
 * Returns an empty cell.
 */
export function getEmptyCell(missingCell = false): LoadingCell {
  if (missingCell) {
    return {
      kind: GridCellKind.Loading,
      allowOverlay: false,
      isMissingValue: true,
    } as LoadingCell
  }

  return {
    kind: GridCellKind.Loading,
    allowOverlay: false,
  } as LoadingCell
}

/**
 * Returns an empty text cell.
 *
 * @param readonly: If true, returns a read-only version of the cell.
 * @param faded: If true, returns a faded version of the cell.
 *
 * @return a GridCell object that can be used by glide-data-grid.
 */
export function getTextCell(readonly: boolean, faded: boolean): TextCell {
  const style = faded ? "faded" : "normal"
  return {
    kind: GridCellKind.Text,
    data: "",
    displayData: "",
    allowOverlay: true,
    readonly,
    style,
  } as TextCell
}

/**
 * Converts from our BaseColumn format to the glide-data-grid compatible GridColumn.
 */
export function toGlideColumn(column: BaseColumn): GridColumn {
  return {
    id: column.id,
    title: column.title,
    hasMenu: false,
    themeOverride: column.themeOverride,
    icon: column.icon,
    group: column.group,
    ...(column.isStretched && {
      grow: column.isIndex ? 1 : 3,
    }),
    ...(column.width && {
      width: column.width,
    }),
  } as GridColumn
}

/**
 * Merges the default column parameters with the user-defined column parameters.
 *
 * @param defaultParams - The default column parameters.
 * @param userParams - The user-defined column parameters.
 *
 * @returns The merged column parameters.
 */
export function mergeColumnParameters(
  defaultParams: Record<string, any> | undefined | null,
  userParams: Record<string, any> | undefined | null
): Record<string, any> {
  if (isNullOrUndefined(defaultParams)) {
    return userParams || {}
  }

  if (isNullOrUndefined(userParams)) {
    return defaultParams || {}
  }

  return merge(defaultParams, userParams)
}

/**
 * Converts the given value of unknown type to an array without
 * the risks of any exceptions.
 *
 * @param data - The value to convert to an array.
 *
 * @returns The converted array or an empty array if the value cannot be interpreted as an array.
 */
export function toSafeArray(data: any): any[] {
  if (isNullOrUndefined(data)) {
    return []
  }

  if (typeof data === "number" || typeof data === "boolean") {
    // Single number or boolean
    return [data]
  }

  if (typeof data === "string") {
    if (data === "") {
      // Empty string
      return []
    }

    // Try to parse string to an array
    if (data.trim().startsWith("[") && data.trim().endsWith("]")) {
      // Support for JSON arrays: ["foo", 1, null, "test"]
      try {
        return JSON.parse(data)
      } catch (error) {
        return [data]
      }
    } else {
      // Support for comma-separated values: "foo,1,,test"
      return data.split(",")
    }
  }

  try {
    const parsedData = JSON.parse(
      JSON.stringify(data, (_key, value) =>
        typeof value === "bigint" ? Number(value) : value
      )
    )
    if (!Array.isArray(parsedData)) {
      return [toSafeString(parsedData)]
    }

    return parsedData.map((value: any) =>
      ["string", "number", "boolean", "null"].includes(typeof value)
        ? value
        : toSafeString(value)
    )
  } catch (error) {
    return [toSafeString(data)]
  }
}

/**
 * Converts the given value of unknown type to a string without
 * the risks of any exceptions.
 *
 * @param data - The value to convert to a string.
 *
 * @return The converted string or a string showing the type of the object as fallback.
 */
export function toSafeString(data: any): string {
  try {
    try {
      return toString(data)
    } catch (error) {
      return JSON.stringify(data, (_key, value) =>
        typeof value === "bigint" ? Number(value) : value
      )
    }
  } catch (error) {
    // This is most likely an object that cannot be converted to a string
    // console.log converts this to `[object Object]` which we are doing here as well:
    return `[${typeof data}]`
  }
}

/**
 * Converts the given value of unknown type to a boolean without
 * the risks of any exceptions.
 *
 * @param value - The value to convert to a boolean.
 *
 * @return The converted boolean, null if the value is empty or undefined if the
 *         value cannot be interpreted as a boolean.
 */
export function toSafeBoolean(value: any): boolean | null | undefined {
  if (isNullOrUndefined(value)) {
    return null
  }

  if (typeof value === "boolean") {
    return value
  }

  const cleanedValue = toSafeString(value).toLowerCase().trim()
  if (cleanedValue === "") {
    return null
  } else if (BOOLEAN_TRUE_VALUES.includes(cleanedValue)) {
    return true
  } else if (BOOLEAN_FALSE_VALUES.includes(cleanedValue)) {
    return false
  }
  // The value cannot be interpreted as boolean
  return undefined
}

/**
 * Converts the given value of unknown type to a number without
 * the risks of any exceptions.
 *
 * @param value - The value to convert to a number.
 *
 * @returns The converted number or null if the value is empty or undefined or NaN if the
 *          value cannot be interpreted as a number.
 */
export function toSafeNumber(value: any): number | null {
  // TODO(lukasmasuch): Should this return null as replacement for NaN?

  if (isNullOrUndefined(value)) {
    return null
  }

  if (Array.isArray(value)) {
    return NaN
  }

  if (typeof value === "string") {
    if (value.trim().length === 0) {
      // Empty string should return null
      return null
    }

    try {
      // Try to convert string to number via numbro:
      // https://numbrojs.com/old-format.html#unformat
      const unformattedValue = numbro.unformat(value.trim())
      if (notNullOrUndefined(unformattedValue)) {
        return unformattedValue
      }
    } catch (error) {
      // Do nothing here
    }
  } else if (value instanceof Int32Array) {
    // int values need to be extracted this way:
    // eslint-disable-next-line prefer-destructuring
    return Number(value[0])
  }

  return Number(value)
}

/**
 * Determines the default mantissa to use for the given number.
 *
 * @param value - The number to determine the mantissa for.
 *
 * @returns The mantissa to use.
 */
function determineDefaultMantissa(value: number): number {
  if (value === 0 || Math.abs(value) >= 0.0001) {
    return 4
  }

  const expStr = value.toExponential()
  const parts = expStr.split("e")
  return Math.abs(parseInt(parts[1], 10))
}

/**
 * Formats the given number to a string based on a provided format or the default format.
 *
 * @param value - The number to format.
 * @param format - The format to use. If not provided, the default format is used.
 * @param maxPrecision - The maximum number of decimals to show. This is only used by the default format.
 *                     If not provided, the default is 4 decimals and trailing zeros are hidden.
 *
 * @returns The formatted number as a string.
 */
export function formatNumber(
  value: number,
  format?: string | undefined,
  maxPrecision?: number | undefined
): string {
  if (Number.isNaN(value) || !Number.isFinite(value)) {
    return ""
  }

  if (isNullOrUndefined(format) || format === "") {
    // If no format is provided, use the default format
    if (notNullOrUndefined(maxPrecision)) {
      // Use the configured precision to influence how the number is formatted
      if (maxPrecision === 0) {
        // Numbro is unable to format the number with 0 decimals.
        value = Math.round(value)
      }

      return numbro(value).format({
        thousandSeparated: true,
        mantissa: maxPrecision,
        trimMantissa: false,
      })
    }

    // Use a default format if no precision is given
    return numbro(value).format({
      thousandSeparated: true,
      mantissa: determineDefaultMantissa(value),
      trimMantissa: true,
    })
  }

  if (format === "percent") {
    return new Intl.NumberFormat(undefined, {
      style: "percent",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(value)
  } else if (["compact", "scientific", "engineering"].includes(format)) {
    return new Intl.NumberFormat(undefined, {
      notation: format as any,
    }).format(value)
  }

  return sprintf(format, value)
}

/**
 * Formats the given date to a string with the given format.
 *
 * @param momentDate The moment date to format.
 * @param format The format to use.
 *   If the format is `locale` the date will be formatted according to the user's locale.
 *   If the format is `relative` the date will be formatted as a relative time (e.g. "2 hours ago").
 *   Otherwise, it is interpreted as momentJS format string: https://momentjs.com/docs/#/displaying/format/
 * @returns The formatted date as a string.
 */
export function formatMoment(momentDate: Moment, format: string): string {
  if (format === "locale") {
    return new Intl.DateTimeFormat(undefined, {
      dateStyle: "medium",
      timeStyle: "medium",
    }).format(momentDate.toDate())
  } else if (format === "distance") {
    return momentDate.fromNow()
  } else if (format === "relative") {
    return momentDate.calendar()
  }
  return momentDate.format(format)
}

/**
 * Converts the given value of unknown type to a date without
 * the risks of any exceptions.
 *
 * Note: Unix timestamps are only supported in seconds.
 *
 * @param value - The value to convert to a date.
 *
 * @returns The converted date or null if the value cannot be interpreted as a date.
 */
export function toSafeDate(value: any): Date | null | undefined {
  if (isNullOrUndefined(value)) {
    return null
  }

  // Return the value as-is if it is already a date
  if (value instanceof Date) {
    if (!isNaN(value.getTime())) {
      return value
    }
    return undefined
  }

  if (typeof value === "string" && value.trim().length === 0) {
    // Empty string should return null
    return null
  }

  try {
    const parsedTimestamp = Number(value)
    if (!isNaN(parsedTimestamp)) {
      // Unix timestamps can be have different units.
      // As default, we handle the unit as second, but
      // if it larger than a certain threshold, we assume
      // a different unit. This is not 100% accurate, but
      // should be good enough since it is unlikely that
      // users are actually referring to years >= 5138.
      let timestampInSeconds = parsedTimestamp
      if (parsedTimestamp >= 10 ** 18) {
        // Assume that the timestamp is in nanoseconds
        // and adjust to seconds
        timestampInSeconds = parsedTimestamp / 1000 ** 3
      } else if (parsedTimestamp >= 10 ** 15) {
        // Assume that the timestamp is in microseconds
        // and adjust to seconds
        timestampInSeconds = parsedTimestamp / 1000 ** 2
      } else if (parsedTimestamp >= 10 ** 12) {
        // Assume that the timestamp is in milliseconds
        // and adjust to seconds
        timestampInSeconds = parsedTimestamp / 1000
      }

      // Parse it as a unix timestamp in seconds
      const parsedMomentDate = moment.unix(timestampInSeconds).utc()
      if (parsedMomentDate.isValid()) {
        return parsedMomentDate.toDate()
      }
    }

    if (typeof value === "string") {
      // Try to parse string via momentJS:
      const parsedMomentDate = moment.utc(value)
      if (parsedMomentDate.isValid()) {
        return parsedMomentDate.toDate()
      }
      // The pasted value was not a valid date string
      // Try to interpret value as time string instead (HH:mm:ss)
      const parsedMomentTime = moment.utc(value, [
        moment.HTML5_FMT.TIME_MS, // HH:mm:ss.SSS
        moment.HTML5_FMT.TIME_SECONDS, // HH:mm:ss
        moment.HTML5_FMT.TIME, // HH:mm
      ])
      if (parsedMomentTime.isValid()) {
        return parsedMomentTime.toDate()
      }
    }
  } catch (error) {
    return undefined
  }

  // Unable to interpret this value as a date:
  return undefined
}

/**
 * Count the number of decimals in a number.
 *
 * @param {number} value - The number to count the decimals for.
 *
 * @returns {number} The number of decimals.
 */
export function countDecimals(value: number): number {
  if (value % 1 === 0) {
    return 0
  }

  let numberStr = value.toString()

  if (numberStr.indexOf("e") !== -1) {
    // Handle scientific notation
    numberStr = value.toLocaleString("fullwide", {
      useGrouping: false,
      maximumFractionDigits: 20,
    })
  }

  if (numberStr.indexOf(".") === -1) {
    // Fallback to 0 decimals, this can happen with
    // extremely large or small numbers
    return 0
  }

  return numberStr.split(".")[1].length
}

/**
 * Truncates a number to a specified number of decimal places without rounding.
 *
 * @param {number} value - The number to be truncated.
 * @param {number} decimals - The number of decimal places to preserve after truncation.
 *
 * @returns {number} The truncated number.
 *
 * @example
 * truncateDecimals(3.14159265, 2); // returns 3.14
 * truncateDecimals(123.456, 0); // returns 123
 */
export function truncateDecimals(value: number, decimals: number): number {
  return decimals === 0
    ? Math.trunc(value)
    : Math.trunc(value * 10 ** decimals) / 10 ** decimals
}

const LINE_BREAK_REGEX = new RegExp(/(\r\n|\n|\r)/gm)

/**
 * Removes all line breaks from the given text.
 * @param text - The text to remove line breaks from.
 * @returns The text without line breaks.
 */
export function removeLineBreaks(text: string): string {
  if (text.indexOf("\n") !== -1) {
    return text.replace(LINE_BREAK_REGEX, " ")
  }
  return text
}

/**
 * Determines the correct value to display in a link cell based on the `href` and `regexPattern` parameters.
 *
 * @param href - The raw url value.
 * @param displayTextRegex - The regex pattern which will be applied to the `href`. If no match is found, then we return the `href`.
 * @returns - The string value to be displayed in the cell.
 *
 * * @example
 * const regex = new RegExp("https:\/\/(.*?)\.streamlit\.app")
 * const regex2 = new RegExp("https:\/\/roadmap\.(.*?)\.app")
 * getLinkDisplayValueFromRegex(regex, "https://roadmap.streamlit.app"); // returns "roadmap"
 * getLinkDisplayValueFromRegex(regex, "https://roadmap.streamlit.app"); // returns "streamlit"
 */
export function getLinkDisplayValueFromRegex(
  displayTextRegex: RegExp,
  href?: string | null
): string {
  if (isNullOrUndefined(href)) {
    return ""
  }

  try {
    // apply the regex pattern to display the value
    const patternMatch = href.match(displayTextRegex)
    if (patternMatch && patternMatch[1] !== undefined) {
      // return the first matching group
      // Since this might be a URI encoded value, we decode it.
      // Note: we replace + with %20 to correctly convert + to whitespaces.
      return decodeURIComponent(patternMatch[1].replace(/\+/g, "%20"))
    }

    // if the regex doesn't find a match with the url, just use the url as display value
    return href
  } catch (error) {
    // if there was any error return the href
    return href
  }
}


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/cells/ImageCellEditor.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import { ImageCellEditor } from "./ImageCellEditor"

describe("ImageCellEditor", () => {
  test("renders an image with the correct src", () => {
    const urls = ["https://example.com/image.jpg"]
    render(
      <ImageCellEditor
        urls={urls}
        canWrite={false}
        onCancel={() => {}}
        onChange={() => {}}
      />
    )

    const imageElement = screen.getByRole("img")
    expect(imageElement).toHaveAttribute("src", urls[0])
  })

  test("renders a link with the correct href when imageData starts with 'http'", () => {
    const urls = ["https://example.com/image.jpg"]
    render(
      <ImageCellEditor
        urls={urls}
        canWrite={false}
        onCancel={() => {}}
        onChange={() => {}}
      />
    )

    const linkElement = screen.getByRole("link")
    expect(linkElement).toHaveAttribute("href", urls[0])
    expect(linkElement).toHaveAttribute("target", "_blank")
    expect(linkElement).toHaveAttribute("rel", "noreferrer noopener")
  })

  test("renders an image without a link when imageData does not start with 'http'", () => {
    const urls = ["/local/path/to/image.jpg"]
    render(
      <ImageCellEditor
        urls={urls}
        canWrite={false}
        onCancel={() => {}}
        onChange={() => {}}
      />
    )

    const imageElement = screen.getByRole("img")
    expect(imageElement).toHaveAttribute("src", urls[0])
    expect(screen.queryByRole("link")).toBeNull()
  })

  test("renders an empty image when urls prop is empty", () => {
    render(
      <ImageCellEditor
        urls={[]}
        canWrite={false}
        onCancel={() => {}}
        onChange={() => {}}
      />
    )

    const imageElement = screen.getByRole("img")
    expect(imageElement).toHaveAttribute("src", "")
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/cells/ImageCellEditor.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import React from "react"

import { ImageEditorType } from "@glideapps/glide-data-grid"
import styled from "@emotion/styled"

const StyledImage = styled.img({
  maxWidth: "100%",
  maxHeight: "37.5rem",
  objectFit: "scale-down",
})

export const ImageCellEditor: ImageEditorType = ({ urls }) => {
  const imageData = urls && urls.length > 0 ? urls[0] : ""
  // Allow external image links to be opened in a new tab on click
  if (imageData.startsWith("http")) {
    return (
      <a href={imageData} target="_blank" rel="noreferrer noopener">
        <StyledImage src={imageData}></StyledImage>
      </a>
    )
  }

  return <StyledImage src={imageData}></StyledImage>
}


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/index.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default as useColumnLoader } from "./useColumnLoader"
export { default as useColumnPinning } from "./useColumnPinning"
export { default as useColumnReordering } from "./useColumnReordering"
export { default as useColumnSizer } from "./useColumnSizer"
export { default as useColumnSort } from "./useColumnSort"
export { default as useCustomRenderer } from "./useCustomRenderer"
export { default as useCustomTheme } from "./useCustomTheme"
export { default as useDataEditor } from "./useDataEditor"
export { default as useDataExporter } from "./useDataExporter"
export { default as useDataLoader } from "./useDataLoader"
export { default as useRowHover } from "./useRowHover"
export { default as useSelectionHandler } from "./useSelectionHandler"
export { default as useTableSizer } from "./useTableSizer"
export { default as useTooltips } from "./useTooltips"


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useColumnLoader.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { renderHook } from "@testing-library/react-hooks"

import {
  BaseColumn,
  CheckboxColumn,
  ColumnCreator,
  ListColumn,
  NumberColumn,
  ObjectColumn,
  SelectboxColumn,
  TextColumn,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"
import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import { UNICODE } from "@streamlit/lib/src/mocks/arrow"
import { Arrow as ArrowProto } from "@streamlit/lib/src/proto"

import useColumnLoader, {
  applyColumnConfig,
  COLUMN_POSITION_PREFIX,
  COLUMN_WIDTH_MAPPING,
  ColumnConfigProps,
  getColumnConfig,
  getColumnType,
  INDEX_IDENTIFIER,
} from "./useColumnLoader"

const MOCK_COLUMNS: BaseColumn[] = [
  NumberColumn({
    id: "index_col",
    name: "",
    title: "",
    indexNumber: 0,
    arrowType: {
      pandas_type: "int64",
      numpy_type: "int64",
    },
    isEditable: false,
    isHidden: false,
    isIndex: true,
    isPinned: true,
    isStretched: false,
  }),
  NumberColumn({
    id: "column_1",
    name: "column_1",
    title: "column_1",
    indexNumber: 1,
    arrowType: {
      pandas_type: "int64",
      numpy_type: "int64",
    },
    isEditable: false,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
  }),
  TextColumn({
    id: "column_2",
    name: "column_2",
    title: "column_2",
    indexNumber: 2,
    arrowType: {
      pandas_type: "unicode",
      numpy_type: "object",
    },
    isEditable: false,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
  }),
]

describe("applyColumnConfig", () => {
  it("should correctly apply the use-defined column config", () => {
    const columnConfig: Map<string | number, ColumnConfigProps> = new Map([
      [
        "column_1",
        {
          width: "small",
          disabled: false,
          type_config: {
            type: "text",
          },
        } as ColumnConfigProps,
      ],
      [
        "column_2",
        {
          disabled: true,
          hidden: true,
          alignment: "center",
          required: true,
          default: "this is the default",
        } as ColumnConfigProps,
      ],
    ])

    const column1 = applyColumnConfig(MOCK_COLUMNS[1], columnConfig)
    expect(column1.isEditable).toBe(true)
    expect(column1.width).toBe(COLUMN_WIDTH_MAPPING.small)
    expect((column1.columnTypeOptions as any).type).toBe("text")
    expect(column1).toEqual({
      ...MOCK_COLUMNS[1],
      width: COLUMN_WIDTH_MAPPING.small,
      isEditable: true,
      columnTypeOptions: {
        type: "text",
      },
    })

    const column2 = applyColumnConfig(MOCK_COLUMNS[2], columnConfig)
    expect(column2.isEditable).toBe(false)
    expect(column2.width).toBe(undefined)
    expect(column2.contentAlignment).toBe("center")
    expect(column2.isHidden).toBe(true)
    expect(column2.isRequired).toBe(true)
    expect(column2.defaultValue).toBe("this is the default")
    expect(column2).toEqual({
      ...MOCK_COLUMNS[2],
      isHidden: true,
      contentAlignment: "center",
      defaultValue: "this is the default",
      isRequired: true,
    })
  })

  it("allows configuring the index via `index` as ID", () => {
    const columnConfig: Map<string | number, ColumnConfigProps> = new Map([
      [
        INDEX_IDENTIFIER,
        {
          width: "small",
        },
      ],
    ])

    const column1 = applyColumnConfig(MOCK_COLUMNS[0], columnConfig)
    expect(column1.width).toBe(COLUMN_WIDTH_MAPPING.small)
    expect(column1.isIndex).toBe(true)

    const column2 = applyColumnConfig(MOCK_COLUMNS[1], columnConfig)
    expect(column2.width).toBe(undefined)
    expect(column2.isIndex).toBe(false)
  })

  it("allows configuring a column via numeric ID", () => {
    const columnConfig: Map<string | number, ColumnConfigProps> = new Map([
      [
        `${COLUMN_POSITION_PREFIX}0`,
        {
          width: "small",
        },
      ],
    ])

    const column1 = applyColumnConfig(MOCK_COLUMNS[0], columnConfig)
    expect(column1.width).toBe(COLUMN_WIDTH_MAPPING.small)
  })

  it("works with empty column configs", () => {
    const emptyColumnConfig: Map<string | number, ColumnConfigProps> = new Map(
      []
    )

    const column1 = applyColumnConfig(MOCK_COLUMNS[0], emptyColumnConfig)
    expect(column1).toBe(MOCK_COLUMNS[0])
  })

  it("applies column config in the correct priority order", () => {
    const columnConfig: Map<string | number, ColumnConfigProps> = new Map([
      // All these column keys refer to the same column. They are just different
      // ways of specifying the same column (index, position, name, ID).
      // 1. Index config
      [
        INDEX_IDENTIFIER,
        {
          width: "small",
          label: "Index Label",
          alignment: "left",
        },
      ],
      // 2. Position-based config
      [
        `${COLUMN_POSITION_PREFIX}0`,
        {
          width: "medium",
          label: "Position Label",
          alignment: "center",
        },
      ],
      // 3. Name-based config
      [
        "",
        {
          width: "large",
          label: "Name Label",
          alignment: "right",
        },
      ],
      // 4. ID-based config
      [
        "index_col",
        {
          width: 100,
          label: "ID Label",
          alignment: "left",
        },
      ],
    ])

    // Test with the index column from MOCK_COLUMNS
    const result = applyColumnConfig(MOCK_COLUMNS[0], columnConfig)

    // Config should be merged in order, with later configs overwriting earlier ones
    expect(result).toEqual({
      ...MOCK_COLUMNS[0],
      // Should have the width from ID config (last)
      width: 100,
      // Should have the label from ID config (last)
      title: "ID Label",
      // Should have the alignment from ID config (last)
      contentAlignment: "left",
    })
  })

  it("allows partial config overrides in priority order", () => {
    const columnConfig: Map<string | number, ColumnConfigProps> = new Map([
      // All these column keys refer to the same column. They are just different
      // ways of specifying the same column (_index, position, ID).
      [
        INDEX_IDENTIFIER,
        {
          width: "small",
          label: "Index Label",
        },
      ],
      [
        `${COLUMN_POSITION_PREFIX}0`,
        {
          // Only override the label
          label: "Position Label",
        },
      ],
      [
        "index_col",
        {
          // Only override the width
          width: 100,
        },
      ],
    ])

    const result = applyColumnConfig(MOCK_COLUMNS[0], columnConfig)

    expect(result).toEqual({
      ...MOCK_COLUMNS[0],
      // Width should come from ID config
      width: 100,
      // Label should come from position config
      title: "Position Label",
    })
  })

  it("correctly merges nested type_config options", () => {
    const columnConfig: Map<string | number, ColumnConfigProps> = new Map([
      // All these column keys refer to the same column. They are just different
      // ways of specifying the same column (_index, position, ID).
      // 1. Index config
      [
        INDEX_IDENTIFIER,
        {
          type_config: {
            options: ["a", "b"],
            min_value: 0,
          },
        },
      ],
      // 2. Position-based config
      [
        `${COLUMN_POSITION_PREFIX}0`,
        {
          type_config: {
            options: ["c", "d", "x"],
            max_value: 100,
          },
        },
      ],
      // 3. ID-based config
      [
        "index_col",
        {
          type_config: {
            options: ["e", "f"],
            step: 1,
          },
        },
      ],
    ])

    const result = applyColumnConfig(MOCK_COLUMNS[0], columnConfig)

    // Should merge all type_config options from different config sources
    expect(result.columnTypeOptions).toEqual({
      options: ["e", "f"], // From ID config (last)
      min_value: 0, // From index config (first)
      max_value: 100, // From position config
      step: 1, // From ID config (last)
    })
  })
})

describe("getColumnConfig", () => {
  it("extract the column config from the proto element", () => {
    const element = ArrowProto.create({
      data: UNICODE,
      columns: JSON.stringify({
        c1: {
          width: "small",
          hidden: true,
        },
        c2: {
          width: "medium",
          alignment: "center",
        },
      }),
    })

    const columnConfig = getColumnConfig(element.columns)
    expect(columnConfig.size).toBe(2)
    expect(columnConfig.get("c1")).toEqual({
      width: "small",
      hidden: true,
    })
    expect(columnConfig.get("c2")).toEqual({
      width: "medium",
      alignment: "center",
    })
  })
})

describe("getColumnType", () => {
  it("determines the correct column type creator", () => {
    const column1 = getColumnType(MOCK_COLUMNS[1])
    expect(column1).toBe(NumberColumn)

    const column2 = getColumnType(MOCK_COLUMNS[2])
    expect(column2).toBe(TextColumn)
  })

  it.each([
    ["object", ObjectColumn],
    ["text", TextColumn],
    ["checkbox", CheckboxColumn],
    ["selectbox", SelectboxColumn],
    ["list", ListColumn],
    ["number", NumberColumn],
  ])(
    "maps user-specified type to column type (%p parsed as %p)",
    (typeName: string, columnCreator: ColumnCreator) => {
      const columnType = getColumnType({
        id: "column_1",
        name: "column_1",
        title: "column_1",
        indexNumber: 1,
        arrowType: {
          pandas_type: "int64",
          numpy_type: "int64",
        },
        isEditable: false,
        isHidden: false,
        isIndex: false,
        isPinned: false,
        isStretched: false,
        columnTypeOptions: {
          type: typeName,
        },
      })
      expect(columnType).toEqual(columnCreator)
    }
  )
})

describe("useColumnLoader hook", () => {
  it("creates columns from the Arrow data", () => {
    const element = ArrowProto.create({
      data: UNICODE,
    })
    const data = new Quiver(element)

    const { result } = renderHook(() => {
      return useColumnLoader(element, data, false, element.columnOrder)
    })

    const { columns } = result.current

    expect(columns.length).toBe(3)

    expect(columns[0].title).toBe("")
    expect(columns[0].isIndex).toBe(true)

    expect(columns[1].title).toBe("c1")
    expect(columns[1].isIndex).toBe(false)

    expect(columns[2].title).toBe("c2")
    expect(columns[2].isIndex).toBe(false)
  })

  it("reorders columns when specified via column order", () => {
    const element = ArrowProto.create({
      data: UNICODE,
      columnOrder: ["c2", "c1"],
    })
    const data = new Quiver(element)

    const { result } = renderHook(() => {
      return useColumnLoader(element, data, false, element.columnOrder)
    })

    const { columns } = result.current

    expect(columns.length).toBe(3)

    expect(columns[0].title).toBe("")
    expect(columns[0].isIndex).toBe(true)

    expect(columns[1].title).toBe("c2")
    expect(columns[1].isIndex).toBe(false)

    expect(columns[2].title).toBe("c1")
    expect(columns[2].isIndex).toBe(false)
  })

  it("hides columns not specified in column order", () => {
    const element = ArrowProto.create({
      data: UNICODE,
      columnOrder: ["c2"],
    })
    const data = new Quiver(element)

    const { result } = renderHook(() => {
      return useColumnLoader(element, data, false, element.columnOrder)
    })

    const { columns } = result.current

    expect(columns.length).toBe(2)

    expect(columns[0].title).toBe("")
    expect(columns[0].isIndex).toBe(true)

    expect(columns[1].title).toBe("c2")
    expect(columns[1].isIndex).toBe(false)
  })

  it("activates colum stretch if configured by user", () => {
    const element = ArrowProto.create({
      data: UNICODE,
      useContainerWidth: true,
    })

    const data = new Quiver(element)

    const { result } = renderHook(() => {
      return useColumnLoader(element, data, false, element.columnOrder)
    })

    for (const column of result.current.columns) {
      expect(column.isStretched).toBe(true)
    }
  })

  it("configures the editable icon for editable columns", () => {
    const element = ArrowProto.create({
      data: UNICODE,
      useContainerWidth: true,
      editingMode: ArrowProto.EditingMode.FIXED,
    })

    const data = new Quiver(element)

    const { result } = renderHook(() => {
      return useColumnLoader(element, data, false, element.columnOrder)
    })

    for (const column of result.current.columns) {
      expect(column.icon).toBe("editable")
    }
  })

  it("disallows hidden for editable columns that are required for dynamic editing", () => {
    const element = ArrowProto.create({
      data: UNICODE,
      editingMode: ArrowProto.EditingMode.DYNAMIC,
      columns: JSON.stringify({
        c1: {
          required: true,
          hidden: true,
        },
      }),
    })

    const data = new Quiver(element)

    const { result } = renderHook(() => {
      return useColumnLoader(element, data, false, element.columnOrder)
    })

    expect(result.current.columns[1].isRequired).toBe(true)
    expect(result.current.columns[1].isHidden).toBe(false)
  })

  it("respects hiding required columns for fixed editing", () => {
    const element = ArrowProto.create({
      data: UNICODE,
      editingMode: ArrowProto.EditingMode.FIXED,
      columns: JSON.stringify({
        c1: {
          required: true,
          hidden: true,
        },
      }),
    })

    const data = new Quiver(element)

    const { result } = renderHook(() => {
      return useColumnLoader(element, data, false, element.columnOrder)
    })

    // Test that the column is hidden (not part of columns).
    // Column with index 1 should be c2:
    expect(result.current.columns[1].name).toBe("c2")
  })

  it("doesn't configure any icon for non-editable columns", () => {
    const element = ArrowProto.create({
      data: UNICODE,
      useContainerWidth: true,
      editingMode: ArrowProto.EditingMode.READ_ONLY,
    })

    const data = new Quiver(element)

    const { result } = renderHook(() => {
      return useColumnLoader(element, data, false, element.columnOrder)
    })

    for (const column of result.current.columns) {
      expect(column.icon).toBe(undefined)
    }
  })

  it("uses column order to order pinned columns", () => {
    const element = ArrowProto.create({
      data: UNICODE,
      columnOrder: ["c2", "c1"],
      columns: JSON.stringify({
        c1: {
          pinned: true,
        },
        c2: {
          pinned: true,
        },
      }),
    })

    const data = new Quiver(element)

    const { result } = renderHook(() => {
      return useColumnLoader(element, data, false, element.columnOrder)
    })

    // Range index:
    expect(result.current.columns[0].name).toBe("")
    expect(result.current.columns[0].isIndex).toBe(true)

    // Pinned columns:
    expect(result.current.columns[1].name).toBe("c2")
    expect(result.current.columns[1].isPinned).toBe(true)
    expect(result.current.columns[2].name).toBe("c1")
    expect(result.current.columns[2].isPinned).toBe(true)
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useColumnLoader.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import React from "react"

import { useTheme } from "@emotion/react"
import isArray from "lodash/isArray"
import isEmpty from "lodash/isEmpty"
import merge from "lodash/merge"
import mergeWith from "lodash/mergeWith"

import {
  getAllColumnsFromArrow,
  getColumnTypeFromArrow,
  getEmptyIndexColumn,
} from "@streamlit/lib/src/components/widgets/DataFrame/arrowUtils"
import {
  BaseColumn,
  BaseColumnProps,
  ColumnCreator,
  ColumnTypes,
  ObjectColumn,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"
import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import { Arrow as ArrowProto } from "@streamlit/lib/src/proto"
import { EmotionTheme } from "@streamlit/lib/src/theme"
import { logError, logWarning } from "@streamlit/lib/src/util/log"
import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

// Using this ID for column config will apply the config to all index columns
export const INDEX_IDENTIFIER = "_index"
// Prefix used in the config column mapping when referring to a column via the numeric position
export const COLUMN_POSITION_PREFIX = "_pos:"

// Predefined column widths configurable by the user
export const COLUMN_WIDTH_MAPPING = {
  small: 75,
  medium: 200,
  large: 400,
}

/**
 * Options to configure columns.
 *
 * This needs to be kept in sync with the ColumnConfig TypeDict in the backend.
 * This will be eventually replaced with a proto message.
 */
export interface ColumnConfigProps {
  label?: string
  width?: "small" | "medium" | "large" | number
  help?: string
  hidden?: boolean
  disabled?: boolean
  required?: boolean
  default?: number | string | boolean
  alignment?: "left" | "center" | "right"
  pinned?: boolean
  // uses snake_case to match the property names in the backend:
  type_config?: Record<string, unknown>
}

/**
 * Parse the user-defined width configuration and return the width in pixels.
 */
function parseWidthConfig(
  width?: "small" | "medium" | "large" | number
): number | undefined {
  if (isNullOrUndefined(width)) {
    return undefined
  }

  if (typeof width === "number") {
    return width
  }

  if (width in COLUMN_WIDTH_MAPPING) {
    return COLUMN_WIDTH_MAPPING[width]
  }

  return undefined
}

/**
 * Custom merge function to merge column config objects.
 */
const mergeColumnConfig = (
  target: ColumnConfigProps,
  source: ColumnConfigProps
): ColumnConfigProps => {
  // Don't merge arrays, just overwrite the old value with the new value
  const customMergeArrays = (objValue: object, srcValue: object): any => {
    // If the new value is an array, just return it as is (overwriting the old)
    if (isArray(srcValue)) {
      return srcValue
    }
  }

  return mergeWith(target, source, customMergeArrays)
}

/**
 * Apply the user-defined column configuration if supplied.
 *
 * @param columnProps - The column properties to apply the config to.
 * @param columnConfigMapping - The user-defined column configuration mapping.
 *
 * @return the column properties with the config applied.
 */
export function applyColumnConfig(
  columnProps: BaseColumnProps,
  columnConfigMapping: Map<string | number, ColumnConfigProps>
): BaseColumnProps {
  if (!columnConfigMapping) {
    // No column config configured
    return columnProps
  }

  let columnConfig: ColumnConfigProps = {}

  // Merge all possible ways to provide column config for a specific column:
  // The order / priority of how this is merged is important!

  // 1. Config is configured for the index column (or all index columns for multi-index)
  if (columnProps.isIndex && columnConfigMapping.has(INDEX_IDENTIFIER)) {
    columnConfig = mergeColumnConfig(
      columnConfig,
      columnConfigMapping.get(INDEX_IDENTIFIER) ?? {}
    )
  }

  // 2. Config is configured based on the column position, e.g. _pos:0 -> first column
  if (
    columnConfigMapping.has(
      `${COLUMN_POSITION_PREFIX}${columnProps.indexNumber}`
    )
  ) {
    columnConfig = mergeColumnConfig(
      columnConfig,
      columnConfigMapping.get(
        `${COLUMN_POSITION_PREFIX}${columnProps.indexNumber}`
      ) ?? {}
    )
  }

  // 3. Config is configured based on the column name
  if (
    columnConfigMapping.has(columnProps.name) &&
    columnProps.name !== INDEX_IDENTIFIER // "_index" is not supported as name for normal columns
  ) {
    columnConfig = mergeColumnConfig(
      columnConfig,
      columnConfigMapping.get(columnProps.name) ?? {}
    )
  }

  // 4. Config is configured based on the column id
  // This is mainly used by the frontend component to apply changes to columns
  // based on user configuration on the UI.
  if (columnConfigMapping.has(columnProps.id)) {
    columnConfig = mergeColumnConfig(
      columnConfig,
      columnConfigMapping.get(columnProps.id) ?? {}
    )
  }

  // No column config found for this column
  if (isEmpty(columnConfig)) {
    return columnProps
  }

  // This will update all column props with the user-defined config for all
  // configuration options that are not undefined:
  return merge({ ...columnProps }, {
    title: columnConfig.label,
    width: parseWidthConfig(columnConfig.width),
    isEditable: notNullOrUndefined(columnConfig.disabled)
      ? !columnConfig.disabled
      : undefined,
    isHidden: columnConfig.hidden,
    isPinned: columnConfig.pinned,
    isRequired: columnConfig.required,
    columnTypeOptions: columnConfig.type_config,
    contentAlignment: columnConfig.alignment,
    defaultValue: columnConfig.default,
    help: columnConfig.help,
  } as BaseColumnProps) as BaseColumnProps
}

/**
 * Extracts the user-defined column configuration from the JSON config.
 *
 * @param configJson - the column config JSON from the proto.
 *
 * @returns the user-defined column configuration.
 */
export function getColumnConfig(configJson: string): Map<string, any> {
  if (!configJson) {
    return new Map()
  }
  try {
    return new Map(Object.entries(JSON.parse(configJson)))
  } catch (error) {
    // This is not expected to happen, but if it does, we'll return an empty map
    // and log the error to the console.
    logError(error)
    return new Map()
  }
}

type ColumnLoaderReturn = {
  columns: BaseColumn[]
  setColumnConfigMapping: React.Dispatch<
    React.SetStateAction<Map<string, any>>
  >
}

/**
 * Get the column type (creator class of column type) for the given column properties.
 *
 * @param column - The column properties.
 *
 * @returns the column creator of the corresponding column type.
 */
export function getColumnType(column: BaseColumnProps): ColumnCreator {
  const customType = column.columnTypeOptions?.type as string
  // Create a column instance based on the column properties
  let ColumnType: ColumnCreator | undefined
  if (notNullOrUndefined(customType)) {
    if (ColumnTypes.has(customType)) {
      ColumnType = ColumnTypes.get(customType)
    } else {
      logWarning(
        `Unknown column type configured in column configuration: ${customType}`
      )
    }
  }
  if (isNullOrUndefined(ColumnType)) {
    // Load based on arrow type
    ColumnType = getColumnTypeFromArrow(column.arrowType)
  }
  return ColumnType
}

/**
 * Custom hook that handles loads and configures all table columns from the Arrow table.
 *
 * @param element - The proto message of the dataframe element
 * @param data - The Arrow data extracted from the proto message
 * @param disabled - Whether the widget is disabled
 * @param columnOrder - The custom column order state. This is a list of column names or column ids.
 *        If this is empty, the columns will be ordered by their position in the Arrow table.
 *
 * @returns the columns and the cell content getter compatible with glide-data-grid
 * and the parsed column config mapping.
 */
function useColumnLoader(
  element: ArrowProto,
  data: Quiver,
  disabled: boolean,
  columnOrder: string[]
): ColumnLoaderReturn {
  const theme: EmotionTheme = useTheme()

  // Memoize the column config parsing to avoid unnecessary re-renders & re-parsing:
  const parsedColumnConfig = React.useMemo(
    () => getColumnConfig(element.columns),
    [element.columns]
  )

  // Initialize state with the parsed column config:
  // We need that to allow changing the column config state
  // (e.g. via changes by the user in the UI)
  const [columnConfigMapping, setColumnConfigMapping] =
    React.useState<Map<string, any>>(parsedColumnConfig)

  // Resync state whenever the parsed column config from the proto changes:
  React.useEffect(() => {
    setColumnConfigMapping(parsedColumnConfig)
  }, [parsedColumnConfig])

  const stretchColumns: boolean =
    element.useContainerWidth ||
    (notNullOrUndefined(element.width) && element.width > 0)

  // Converts the columns from Arrow into columns compatible with glide-data-grid
  const columns: BaseColumn[] = React.useMemo(() => {
    const visibleColumns = getAllColumnsFromArrow(data)
      .map(column => {
        // Apply column configurations
        let updatedColumn = {
          ...column,
          ...applyColumnConfig(column, columnConfigMapping),
          isStretched: stretchColumns,
        } as BaseColumnProps
        const ColumnType = getColumnType(updatedColumn)

        // Make sure editing is deactivated if the column is read-only, disabled,
        // or a not editable type.
        if (
          element.editingMode === ArrowProto.EditingMode.READ_ONLY ||
          disabled ||
          ColumnType.isEditableType === false
        ) {
          updatedColumn = {
            ...updatedColumn,
            isEditable: false,
          }
        }

        if (
          element.editingMode !== ArrowProto.EditingMode.READ_ONLY &&
          updatedColumn.isEditable == true
        ) {
          // Set editable icon for all editable columns:
          updatedColumn = {
            ...updatedColumn,
            icon: "editable",
          }

          // Make sure that required columns are not hidden when editing mode is dynamic:
          if (
            updatedColumn.isRequired &&
            element.editingMode === ArrowProto.EditingMode.DYNAMIC
          ) {
            updatedColumn = {
              ...updatedColumn,
              isHidden: false,
            }
          }
        }

        return ColumnType(updatedColumn, theme)
      })
      .filter(column => {
        // Filter out all columns that are hidden
        return !column.isHidden
      })

    const pinnedColumns: BaseColumn[] = []
    const unpinnedColumns: BaseColumn[] = []

    if (columnOrder?.length) {
      // The column order list can contain either column names - if configured by the user -
      // or column ids - if configured by the frontend component.

      // Special case: index columns not part of the column order
      // are shown as the first columns in the table
      visibleColumns.forEach(column => {
        if (
          column.isIndex &&
          !columnOrder.includes(column.name) &&
          !columnOrder.includes(column.id) &&
          // Don't add the index column if it is explicitly not pinned
          column.isPinned !== false
        ) {
          pinnedColumns.push(column)
        }
      })

      // Reorder columns based on the configured column order:
      columnOrder.forEach(columnName => {
        const column = visibleColumns.find(
          column => column.name === columnName || column.id === columnName
        )
        if (column) {
          if (column.isPinned) {
            pinnedColumns.push(column)
          } else {
            unpinnedColumns.push(column)
          }
        }
      })
    } else {
      // If no column order is configured, we just need to split
      // the columns into pinned and unpinned:
      visibleColumns.forEach(column => {
        if (column.isPinned) {
          pinnedColumns.push(column)
        } else {
          unpinnedColumns.push(column)
        }
      })
    }

    const orderedColumns = [...pinnedColumns, ...unpinnedColumns]

    // If all columns got filtered out, we add an empty index column
    // to prevent errors from glide-data-grid.
    return orderedColumns.length > 0
      ? orderedColumns
      : [ObjectColumn(getEmptyIndexColumn())]
  }, [
    data,
    columnConfigMapping,
    stretchColumns,
    disabled,
    element.editingMode,
    columnOrder,
    theme,
  ])

  return {
    columns,
    setColumnConfigMapping,
  }
}

export default useColumnLoader


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useColumnPinning.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { act, renderHook } from "@testing-library/react-hooks"

import {
  BaseColumn,
  NumberColumn,
  TextColumn,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"

import useColumnPinning from "./useColumnPinning"

const MOCK_COLUMNS: BaseColumn[] = [
  NumberColumn({
    id: "_column-1",
    name: "column_1",
    title: "Column 1",
    indexNumber: 0,
    arrowType: {
      pandas_type: "int64",
      numpy_type: "int64",
    },
    isEditable: false,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
  }),
  TextColumn({
    id: "_column-2",
    name: "column_2",
    title: "Column 2",
    indexNumber: 1,
    arrowType: {
      pandas_type: "unicode",
      numpy_type: "object",
    },
    isEditable: false,
    isHidden: false,
    isIndex: false,
    isPinned: true,
    isStretched: false,
  }),
]

const clearSelectionMock = vi.fn()
const setColumnConfigMappingMock = vi.fn()

describe("useColumnPinning hook", () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it("returns correct initial state", () => {
    const { result } = renderHook(() =>
      useColumnPinning(
        MOCK_COLUMNS,
        false,
        800,
        50,
        clearSelectionMock,
        setColumnConfigMappingMock
      )
    )

    expect(result.current.freezeColumns).toBe(1)
    expect(typeof result.current.pinColumn).toBe("function")
    expect(typeof result.current.unpinColumn).toBe("function")
  })

  it("sets freezeColumns to 0 for empty table", () => {
    const { result } = renderHook(() =>
      useColumnPinning(
        MOCK_COLUMNS,
        true,
        800,
        50,
        clearSelectionMock,
        setColumnConfigMappingMock
      )
    )

    expect(result.current.freezeColumns).toBe(0)
  })

  it("sets freezeColumns to 0 when pinned columns width exceeds limit", () => {
    const { result } = renderHook(() =>
      useColumnPinning(
        MOCK_COLUMNS,
        false,
        100, // Small container width to trigger the width limit
        50,
        clearSelectionMock,
        setColumnConfigMappingMock
      )
    )

    expect(result.current.freezeColumns).toBe(0)
  })

  it("pins column correctly", () => {
    const { result } = renderHook(() =>
      useColumnPinning(
        MOCK_COLUMNS,
        false,
        800,
        50,
        clearSelectionMock,
        setColumnConfigMappingMock
      )
    )

    act(() => {
      result.current.pinColumn("_column-1")
    })

    expect(setColumnConfigMappingMock).toHaveBeenCalled()
    expect(clearSelectionMock).toHaveBeenCalledWith(true, false)

    // Verify the mapping was called with correct parameters
    const setStateCallback = setColumnConfigMappingMock.mock.calls[0][0]
    const prevMap = new Map()
    const newMap = setStateCallback(prevMap)

    expect(newMap.get("_column-1")).toEqual({ pinned: true })
  })

  it("unpins column correctly", () => {
    const { result } = renderHook(() =>
      useColumnPinning(
        MOCK_COLUMNS,
        false,
        800,
        50,
        clearSelectionMock,
        setColumnConfigMappingMock
      )
    )

    act(() => {
      result.current.unpinColumn("_column-2")
    })

    expect(setColumnConfigMappingMock).toHaveBeenCalled()
    expect(clearSelectionMock).toHaveBeenCalledWith(true, false)

    // Verify the mapping was called with correct parameters
    const setStateCallback = setColumnConfigMappingMock.mock.calls[0][0]
    const prevMap = new Map()
    const newMap = setStateCallback(prevMap)

    expect(newMap.get("_column-2")).toEqual({ pinned: false })
  })

  it("preserves existing column config when pinning", () => {
    const { result } = renderHook(() =>
      useColumnPinning(
        MOCK_COLUMNS,
        false,
        800,
        50,
        clearSelectionMock,
        setColumnConfigMappingMock
      )
    )

    act(() => {
      result.current.pinColumn("_column-1")
    })

    // Verify the mapping preserves existing config
    const setStateCallback = setColumnConfigMappingMock.mock.calls[0][0]
    const prevMap = new Map([["_column-1", { width: 100 }]])
    const newMap = setStateCallback(prevMap)

    expect(newMap.get("_column-1")).toEqual({ width: 100, pinned: true })
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useColumnPinning.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { BaseColumn } from "@streamlit/lib/src/components/widgets/DataFrame/columns"

type ColumnPinningReturn = {
  // The number of columns to freeze.
  freezeColumns: number
  // Pin a column to the left side of the table.
  pinColumn: (columnId: string) => void
  // Unpin a column from the left side of the table.
  unpinColumn: (columnId: string) => void
}

/**
 * A React hook that adds the ability to pin/freeze columns to the left side of the table.
 *
 * @param columns - The columns of the table
 * @param isEmptyTable - Whether the table is empty (no rows)
 * @param containerWidth - The width of the parent container
 * @param minColumnWidth - The minimum width allowed for a column
 * @param clearSelection - A callback to clear current selections in the table
 * @param setColumnConfigMapping - A callback to set the column config mapping state
 *
 * @returns An object containing the following properties:
 * - `pinColumn`: A callback to pin a column
 * - `unpinColumn`: A callback to unpin a column
 * - `freezeColumns`: The number of columns to freeze
 */
function useColumnPinning(
  columns: BaseColumn[],
  isEmptyTable: boolean,
  containerWidth: number,
  minColumnWidth: number,
  clearSelection: (keepRows?: boolean, keepColumns?: boolean) => void,
  setColumnConfigMapping: React.Dispatch<
    React.SetStateAction<Map<string, any>>
  >
): ColumnPinningReturn {
  // This is a simple heuristic to prevent the pinned columns
  // from taking up too much space and prevent horizontal scrolling.
  // Since its not easy to determine the current width of auto-sized columns,
  // we just use 2x of the min column width as a fallback.
  // The combined width of all pinned columns should not exceed 60%
  // of the container width.
  const isPinnedColumnsWidthTooLarge = React.useMemo(() => {
    return (
      columns
        .filter((col: BaseColumn) => col.isPinned)
        .reduce((acc, col) => acc + (col.width ?? minColumnWidth * 2), 0) >
      containerWidth * 0.6
    )
  }, [columns, containerWidth, minColumnWidth])

  // All pinned columns are expected to be moved to the beginning
  // in useColumnLoader. So we can just count all pinned columns here.
  const freezeColumns =
    isEmptyTable || isPinnedColumnsWidthTooLarge
      ? 0
      : columns.filter((col: BaseColumn) => col.isPinned).length

  const unpinColumn = React.useCallback(
    (columnId: string) => {
      setColumnConfigMapping(prevColumnConfigMapping => {
        const newColumnConfigMapping = new Map(prevColumnConfigMapping)
        const existingConfig = newColumnConfigMapping.get(columnId)
        newColumnConfigMapping.set(columnId, {
          ...(existingConfig || {}),
          pinned: false,
        })
        return newColumnConfigMapping
      })
      clearSelection(true, false)
    },
    [clearSelection, setColumnConfigMapping]
  )

  const pinColumn = React.useCallback(
    (columnId: string) => {
      setColumnConfigMapping(prevColumnConfigMapping => {
        const newColumnConfigMapping = new Map(prevColumnConfigMapping)
        const existingConfig = newColumnConfigMapping.get(columnId)
        newColumnConfigMapping.set(columnId, {
          ...(existingConfig || {}),
          pinned: true,
        })
        return newColumnConfigMapping
      })
      clearSelection(true, false)
    },
    [clearSelection, setColumnConfigMapping]
  )

  return {
    pinColumn,
    unpinColumn,
    freezeColumns,
  }
}

export default useColumnPinning


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useColumnReordering.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { act, renderHook } from "@testing-library/react-hooks"

import {
  BaseColumn,
  NumberColumn,
  TextColumn,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"

import useColumnReordering from "./useColumnReordering"

const MOCK_COLUMNS: BaseColumn[] = [
  NumberColumn({
    id: "column_1",
    name: "column_1",
    title: "column_1",
    indexNumber: 0,
    arrowType: {
      pandas_type: "int64",
      numpy_type: "int64",
    },
    isEditable: false,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
  }),
  TextColumn({
    id: "column_2",
    name: "column_2",
    title: "column_2",
    indexNumber: 1,
    arrowType: {
      pandas_type: "unicode",
      numpy_type: "object",
    },
    isEditable: false,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
  }),
]

const pinColumnMock = vi.fn()
const unpinColumnMock = vi.fn()
const setColumnOrderMock = vi.fn()

describe("useColumnReordering hook", () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it("returns onColumnMoved callback", () => {
    const { result } = renderHook(() =>
      useColumnReordering(
        MOCK_COLUMNS,
        0,
        pinColumnMock,
        unpinColumnMock,
        setColumnOrderMock
      )
    )

    expect(typeof result.current.onColumnMoved).toBe("function")
  })

  it("correctly handles moving a column to a new position", () => {
    const { result } = renderHook(() =>
      useColumnReordering(
        MOCK_COLUMNS,
        0,
        pinColumnMock,
        unpinColumnMock,
        setColumnOrderMock
      )
    )

    act(() => {
      result.current.onColumnMoved?.(0, 1)
    })

    expect(setColumnOrderMock).toHaveBeenCalledWith(["column_2", "column_1"])
  })

  it("pins column when moved to frozen section", () => {
    const { result } = renderHook(() =>
      useColumnReordering(
        MOCK_COLUMNS,
        1,
        pinColumnMock,
        unpinColumnMock,
        setColumnOrderMock
      )
    )

    act(() => {
      result.current.onColumnMoved?.(1, 0)
    })

    expect(pinColumnMock).toHaveBeenCalledWith("column_2")
    expect(setColumnOrderMock).toHaveBeenCalledWith(["column_2", "column_1"])
  })

  it("unpins column when moved out of frozen section", () => {
    const pinnedColumns = [
      {
        ...MOCK_COLUMNS[0],
        isPinned: true,
      },
      MOCK_COLUMNS[1],
    ]

    const { result } = renderHook(() =>
      useColumnReordering(
        pinnedColumns,
        1,
        pinColumnMock,
        unpinColumnMock,
        setColumnOrderMock
      )
    )

    act(() => {
      result.current.onColumnMoved?.(0, 1)
    })

    expect(unpinColumnMock).toHaveBeenCalledWith("column_1")
    expect(setColumnOrderMock).toHaveBeenCalledWith(["column_2", "column_1"])
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useColumnReordering.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { DataEditorProps } from "@glideapps/glide-data-grid"

import { BaseColumn } from "@streamlit/lib/src/components/widgets/DataFrame/columns"

type ColumnReorderingReturn = Pick<DataEditorProps, "onColumnMoved">

/**
 * A React hook that adds the ability to reorder columns via drag and drop in the UI.
 *
 * @param columns - The columns of the table.
 * @param freezeColumns - The number of columns to freeze
 * @param pinColumn - A callback to pin a column
 * @param unpinColumn - A callback to unpin a column
 * @param setColumnOrder - A callback to set the column order state
 *
 * @returns An object containing the following properties:
 * - `onColumnMoved`: A glide-data-grid compatible callback to handle column movement.
 */
function useColumnReordering(
  columns: BaseColumn[],
  freezeColumns: number,
  pinColumn: (columnId: string) => void,
  unpinColumn: (columnId: string) => void,
  setColumnOrder: React.Dispatch<React.SetStateAction<string[]>>
): ColumnReorderingReturn {
  const onColumnMoved = React.useCallback(
    (startIndex: number, endIndex: number): void => {
      // Create a shallow copy of the original columns
      const newColumns = [...columns]

      // Remove the column from its original position
      const [movedColumn] = newColumns.splice(startIndex, 1)

      // Insert the column into its new position
      newColumns.splice(endIndex, 0, movedColumn)

      // Pin or unpin the column if necessary:
      if (endIndex < freezeColumns && !movedColumn.isPinned) {
        pinColumn(movedColumn.id)
      } else if (endIndex >= freezeColumns && movedColumn.isPinned) {
        unpinColumn(movedColumn.id)
      }

      // Update the column order with the new sequence of column IDs
      setColumnOrder(newColumns.map(column => column.id))
    },
    [columns, freezeColumns, pinColumn, unpinColumn, setColumnOrder]
  )

  return {
    onColumnMoved,
  }
}

export default useColumnReordering


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useColumnSizer.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridColumn, SizedGridColumn } from "@glideapps/glide-data-grid"
import { act, renderHook } from "@testing-library/react-hooks"

import useColumnSizer from "./useColumnSizer"

const MOCK_COLUMNS: GridColumn[] = [
  {
    id: "column_1",
    title: "column_1",
  },
  {
    id: "column_2",
    title: "column_2",
    width: 100,
  },
  {
    id: "column_3",
    title: "column_3",
    grow: 1,
  },
]

describe("useColumnSizer hook", () => {
  it("should correctly apply column resizing.", () => {
    const { result } = renderHook(() => useColumnSizer(MOCK_COLUMNS))
    // Check initial state
    expect((result.current.columns[0] as SizedGridColumn).width).toBe(
      undefined
    )
    expect((result.current.columns[1] as SizedGridColumn).width).toBe(100)

    // Resize first column to size of 123:
    act(() => {
      const { onColumnResize } = result.current
      onColumnResize?.(MOCK_COLUMNS[0], 123, 0, 123)
    })
    expect((result.current.columns[0] as SizedGridColumn).width).toBe(123)

    // Resize first column to size of 321:
    act(() => {
      const { onColumnResize } = result.current
      onColumnResize?.(MOCK_COLUMNS[0], 321, 0, 321)
    })
    expect((result.current.columns[0] as SizedGridColumn).width).toBe(321)

    // First column should stay at previous value if other column is resized
    act(() => {
      const { onColumnResize } = result.current
      onColumnResize?.(MOCK_COLUMNS[1], 88, 1, 88)
    })
    expect((result.current.columns[0] as SizedGridColumn).width).toBe(321)
  })

  it("should deactivate grow on resize.", () => {
    const { result } = renderHook(() => useColumnSizer(MOCK_COLUMNS))

    // Check initial state
    expect((result.current.columns[2] as SizedGridColumn).width).toBe(
      undefined
    )
    expect((result.current.columns[2] as SizedGridColumn).grow).toBe(1)

    // Resize column with grow
    act(() => {
      const { onColumnResize } = result.current
      onColumnResize?.(MOCK_COLUMNS[2], 123, 0, 123)
    })
    expect((result.current.columns[2] as SizedGridColumn).width).toBe(123)
    // Grow should be deactivated (by setting it to 0)
    expect((result.current.columns[2] as SizedGridColumn).grow).toBe(0)
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useColumnSizer.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { useState } from "react"

import { DataEditorProps, GridColumn } from "@glideapps/glide-data-grid"

type ColumnSizerReturn = Pick<DataEditorProps, "columns" | "onColumnResize">

/**
 * Hook to manage the interactive column resizing capabilities.
 *
 * @param columns - The columns of the table.
 *
 * @returns An object containing the following properties:
 * - columns: The updated list of columns.
 * - onColumnResize: The callback function to be called when a column is resized.
 */
function useColumnSizer(columns: GridColumn[]): ColumnSizerReturn {
  // The columns with the corresponding empty template for every type:
  const [columnSizes, setColumnSizes] = useState<Map<string, number>>(
    () => new Map()
  )

  const onColumnResize = React.useCallback(
    (
      column: GridColumn,
      _newSize: number,
      _colIndex: number,
      newSizeWithGrow: number
    ) => {
      if (column.id) {
        setColumnSizes(new Map(columnSizes).set(column.id, newSizeWithGrow))
      }
    },
    [columnSizes]
  )

  const sizedColumns = React.useMemo(() => {
    return columns.map(column => {
      if (
        column.id &&
        columnSizes.has(column.id) &&
        columnSizes.get(column.id) !== undefined
      ) {
        return {
          ...column,
          width: columnSizes.get(column.id),
          // Deactivate grow whenever a column gets manually resized
          grow: 0,
        } as GridColumn
      }
      return column
    })
  }, [columns, columnSizes])

  return {
    columns: sizedColumns,
    onColumnResize,
  }
}

export default useColumnSizer


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useColumnSort.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCell, NumberCell } from "@glideapps/glide-data-grid"
import { act, renderHook } from "@testing-library/react-hooks"

import {
  BaseColumn,
  NumberColumn,
  TextColumn,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"

import useColumnSort from "./useColumnSort"

const MOCK_COLUMNS: BaseColumn[] = [
  NumberColumn({
    id: "column_1",
    name: "column_1",
    title: "column_1",
    indexNumber: 0,
    arrowType: {
      pandas_type: "int64",
      numpy_type: "int64",
    },
    isEditable: false,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
  }),
  TextColumn({
    id: "column_2",
    name: "column_2",
    title: "column_2",
    indexNumber: 1,
    arrowType: {
      pandas_type: "unicode",
      numpy_type: "object",
    },
    isEditable: false,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
  }),
]

const MOCK_PROPS = {
  numRows: 3,
  columns: MOCK_COLUMNS,
  getCellContent: ([col, row]: readonly [number, number]): GridCell => {
    if (row === 0) {
      return MOCK_COLUMNS[col].getCell(90)
    }
    if (row === 1) {
      return MOCK_COLUMNS[col].getCell(100)
    }
    if (row === 2) {
      return MOCK_COLUMNS[col].getCell(5)
    }
    return MOCK_COLUMNS[col].getCell(0)
  },
}

describe("useColumnSort hook", () => {
  it("should correctly sort numbers ascending and descending order", () => {
    const { result } = renderHook(() =>
      useColumnSort(
        MOCK_PROPS.numRows,
        MOCK_PROPS.columns,
        MOCK_PROPS.getCellContent
      )
    )
    // Select number column
    const SELECTED_COLUMN = 0

    // Sort the first time for ascending order
    act(() => {
      const { sortColumn } = result.current
      sortColumn?.(MOCK_COLUMNS[SELECTED_COLUMN].indexNumber)
    })

    // Column header should contain ascending sort icon
    expect(result.current.columns[SELECTED_COLUMN].title).toContain("↑")

    const sortedDataAsc = []

    for (let i = 0; i < MOCK_PROPS.numRows; i++) {
      sortedDataAsc.push(
        (result.current.getCellContent([SELECTED_COLUMN, i]) as NumberCell)
          .data
      )
    }

    const sortOperator = (
      a: number | undefined,
      b: number | undefined
    ): number => {
      if (a === undefined) {
        return -1
      }

      if (b === undefined) {
        return 1
      }

      return a - b
    }

    expect(Array.from(sortedDataAsc)).toEqual(
      // Sort as number array
      Array.from(sortedDataAsc).sort(sortOperator)
    )

    // Sort again for descending order
    act(() => {
      const { sortColumn } = result.current
      sortColumn?.(MOCK_COLUMNS[SELECTED_COLUMN].indexNumber)
    })

    // Column header should contain descending sort icon
    expect(result.current.columns[SELECTED_COLUMN].title).toContain("↓")

    const sortedDataDesc = []

    for (let i = 0; i < MOCK_PROPS.numRows; i++) {
      sortedDataDesc.push(
        (result.current.getCellContent([SELECTED_COLUMN, i]) as NumberCell)
          .data
      )
    }

    expect(Array.from(sortedDataDesc)).toEqual(
      // Sort as number array
      Array.from(sortedDataDesc).sort(sortOperator).reverse()
    )
  })

  it("should correctly sort text ascending and descending order", () => {
    const { result } = renderHook(() =>
      useColumnSort(
        MOCK_PROPS.numRows,
        MOCK_PROPS.columns,
        MOCK_PROPS.getCellContent
      )
    )
    // Select number column
    const SELECTED_COLUMN = 1

    // Sort the first time for ascending order
    act(() => {
      const { sortColumn } = result.current
      sortColumn?.(MOCK_COLUMNS[SELECTED_COLUMN].indexNumber)
    })

    // Column header should contain ascending sort icon
    expect(result.current.columns[SELECTED_COLUMN].title).toContain("↑")

    const sortedDataAsc = []

    for (let i = 0; i < MOCK_PROPS.numRows; i++) {
      sortedDataAsc.push(
        (result.current.getCellContent([SELECTED_COLUMN, i]) as NumberCell)
          .data
      )
    }

    expect(Array.from(sortedDataAsc)).toEqual(
      // Sort as text array
      Array.from(sortedDataAsc).sort()
    )

    // Sort again for descending order
    act(() => {
      const { sortColumn } = result.current
      sortColumn?.(MOCK_COLUMNS[SELECTED_COLUMN].indexNumber)
    })

    // Column header should contain descending sort icon
    expect(result.current.columns[SELECTED_COLUMN].title).toContain("↓")

    const sortedDataDesc = []

    for (let i = 0; i < MOCK_PROPS.numRows; i++) {
      sortedDataDesc.push(
        (result.current.getCellContent([SELECTED_COLUMN, i]) as NumberCell)
          .data
      )
    }

    expect(Array.from(sortedDataDesc)).toEqual(
      /// Sort as text array
      Array.from(sortedDataDesc).sort().reverse()
    )
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useColumnSort.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import {
  DataEditorProps,
  GridCell,
  GridColumn,
} from "@glideapps/glide-data-grid"
import { useColumnSort as useGlideColumnSort } from "@glideapps/glide-data-grid-source"

import {
  BaseColumn,
  toGlideColumn,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"

/**
 * Configuration type for column sorting hook.
 */
type ColumnSortConfig = {
  column: GridColumn
  mode?: "default" | "raw" | "smart"
  direction?: "asc" | "desc"
}

/**
 * Updates the column headers based on the sorting configuration.
 *
 * @param columns - The columns of the table.
 * @param sort - The current sorting configuration.
 *
 * @returns The updated list of columns.
 */
function updateSortingHeader(
  columns: BaseColumn[],
  sort: ColumnSortConfig | undefined
): BaseColumn[] {
  if (sort === undefined) {
    return columns
  }
  return columns.map(column => {
    if (column.id === sort.column.id) {
      return {
        ...column,
        title:
          sort.direction === "asc" ? `↑ ${column.title}` : `↓ ${column.title}`,
      }
    }
    return column
  })
}

type ColumnSortReturn = {
  columns: BaseColumn[]
  sortColumn: (index: number) => void
  getOriginalIndex: (index: number) => number
} & Pick<DataEditorProps, "getCellContent">

/**
 * A React hook that provides column sorting functionality.
 *
 * @param numRows - The number of rows in the table.
 * @param columns - The columns of the table.
 *
 * @returns An object containing the following properties:
 * - `columns`: The updated list of columns.
 * - `sortColumn`: A function that sorts the column at the given index.
 * - `getOriginalIndex`: A function that returns the original index of the row at the given index.
 * - `getCellContent`: An updated function that returns the content of the cell at the given column and row indices.
 */
function useColumnSort(
  numRows: number,
  columns: BaseColumn[],
  getCellContent: ([col, row]: readonly [number, number]) => GridCell
): ColumnSortReturn {
  const [sort, setSort] = React.useState<ColumnSortConfig>()

  const { getCellContent: getCellContentSorted, getOriginalIndex } =
    useGlideColumnSort({
      columns: columns.map(column => toGlideColumn(column)),
      getCellContent,
      rows: numRows,
      sort,
    })

  const updatedColumns = React.useMemo(() => {
    return updateSortingHeader(columns, sort)
  }, [columns, sort])

  const sortColumn = React.useCallback(
    (index: number) => {
      let sortDirection = "asc"
      const clickedColumn = updatedColumns[index]

      if (sort && sort.column.id === clickedColumn.id) {
        // The clicked column is already sorted
        if (sort.direction === "asc") {
          // Sort column descending
          sortDirection = "desc"
        } else {
          // Remove sorting of column
          setSort(undefined)
          return
        }
      }

      setSort({
        column: toGlideColumn(clickedColumn),
        direction: sortDirection,
        mode: clickedColumn.sortMode,
      } as ColumnSortConfig)
    },
    [sort, updatedColumns]
  )

  return {
    columns: updatedColumns,
    sortColumn,
    getOriginalIndex,
    getCellContent: getCellContentSorted,
  }
}

export default useColumnSort


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useCustomRenderer.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { renderHook } from "@testing-library/react-hooks"

import {
  BaseColumn,
  NumberColumn,
  TextColumn,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"

import useCustomRenderer from "./useCustomRenderer"

const MOCK_COLUMNS: BaseColumn[] = [
  NumberColumn({
    id: "column_1",
    name: "column_1",
    title: "column_1",
    indexNumber: 0,
    arrowType: {
      pandas_type: "int64",
      numpy_type: "int64",
    },
    isEditable: true,
    isRequired: true,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
  }),
  TextColumn({
    id: "column_2",
    name: "column_2",
    title: "column_2",
    indexNumber: 1,
    arrowType: {
      pandas_type: "unicode",
      numpy_type: "object",
    },
    isEditable: true,
    isRequired: false,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
  }),
]

describe("useCustomRenderer hook", () => {
  it("returns correct initial state", () => {
    const { result } = renderHook(() => {
      return useCustomRenderer(MOCK_COLUMNS)
    })

    // Initial state assertions
    expect(typeof result.current.drawCell).toBe("function")
    expect(Array.isArray(result.current.customRenderers)).toBeTruthy()
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useCustomRenderer.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import {
  BaseDrawArgs,
  DataEditorProps,
  DrawCellCallback,
  drawTextCell,
  Theme as GlideTheme,
  Rectangle,
} from "@glideapps/glide-data-grid"
import {
  DatePickerCell,
  DropdownCell,
  RangeCell,
  SparklineCell,
} from "@glideapps/glide-data-grid-cells"

import {
  BaseColumn,
  CustomCells,
  isErrorCell,
  isMissingValueCell,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"

// Token used for missing values (null, NaN, etc.)
const NULL_VALUE_TOKEN = "None"

/**
 * Draw a red indicator in the top right corner of the cell
 * to indicate an issue with the cell (e.g. required or error).
 */
export function drawAttentionIndicator(
  ctx: CanvasRenderingContext2D,
  rect: Rectangle,
  theme: GlideTheme
): void {
  ctx.save()
  ctx.beginPath()
  // We are first moving the drawing position under the top right corner
  // 8 pixels from left side (this is the size triangle)
  // and 1 pixel from top side (to be under the cell border).
  ctx.moveTo(rect.x + rect.width - 8, rect.y + 1)
  // We draw the first line to the top right corner.
  ctx.lineTo(rect.x + rect.width, rect.y + 1)
  // We draw the second line 8 pixel down on the right cell border
  ctx.lineTo(rect.x + rect.width, rect.y + 1 + 8)
  // And now its enough to just fill it with a color to get a triangle.
  ctx.fillStyle = theme.accentColor
  ctx.fill()
  ctx.restore()
}

/**
 * If a cell is marked as missing, we draw a placeholder symbol with a faded text color.
 */
export const drawMissingPlaceholder = (args: BaseDrawArgs): void => {
  const { cell, theme, ctx } = args
  drawTextCell(
    {
      ...args,
      theme: {
        ...theme,
        textDark: theme.textLight,
        headerFontFull: `${theme.headerFontStyle} ${theme.fontFamily}`,
        baseFontFull: `${theme.baseFontStyle} ${theme.fontFamily}`,
        markerFontFull: `${theme.markerFontStyle} ${theme.fontFamily}`,
      },
      // The following props are just added for technical reasons:
      // @ts-expect-error
      spriteManager: {},
      hyperWrapping: false,
    },
    NULL_VALUE_TOKEN,
    cell.contentAlign
  )
  // Reset fill style to the original one
  ctx.fillStyle = theme.textDark
}

/**
 * Create return type for useCustomRenderer hook based on the DataEditorProps.
 */
type CustomRendererReturn = Pick<
  DataEditorProps,
  "drawCell" | "customRenderers"
>

/**
 * Custom hook that creates some custom cell renderers compatible with glide-data-grid.
 *
 * This includes capabilities like showing a faded placeholder for missing values or
 * a red indicator for required cells.
 *
 * @param columns - The columns of the table.
 *
 * @returns An object containing the following properties:
 * - `drawCell`: A function that overwrites some rendering that can be
 *    passed to the `DataEditor` component.
 * - `customRenderers`: A map of custom cell renderers used by custom cells
 *    that can be passed to the `DataEditor` component.
 */
function useCustomRenderer(columns: BaseColumn[]): CustomRendererReturn {
  const drawCell: DrawCellCallback = React.useCallback(
    (args, draw) => {
      const { cell, theme, ctx, rect } = args
      const colPos = args.col
      if (isErrorCell(cell)) {
        // If the cell is an error cell, we draw a red indicator in the top right corner of the cell.
        drawAttentionIndicator(ctx, rect, theme)
      } else if (isMissingValueCell(cell) && colPos < columns.length) {
        const column = columns[colPos]

        // We explicitly ignore some cell types here (e.g. checkbox, progress...) since
        // they are taking care of rendering their missing value state themselves (usually as empty cell).
        // All other cell types are rendered with a placeholder symbol and a faded text color via drawMissingPlaceholder.
        if (
          ["checkbox", "line_chart", "bar_chart", "progress"].includes(
            column.kind
          )
        ) {
          draw()
        } else {
          drawMissingPlaceholder(args as BaseDrawArgs)
        }

        if (column.isRequired && column.isEditable) {
          // If the column is configured as required & editable,
          // we draw a red indicator in the top right corner of the cell.
          drawAttentionIndicator(ctx, rect, theme)
        }
        return
      }
      draw()
    },
    [columns]
  )

  // Load extra cell renderers from the glide-data-grid-cells package:
  const customRenderers = React.useMemo(
    () =>
      [
        SparklineCell,
        DropdownCell,
        RangeCell,
        DatePickerCell,
        ...CustomCells,
      ] as DataEditorProps["customRenderers"],
    // This doesn't change during the lifetime of the component,
    // so we can just run it once at creation time.
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    /* eslint-disable react-hooks/exhaustive-deps */
    []
  )

  return {
    drawCell,
    customRenderers,
  }
}

export default useCustomRenderer


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useCustomTheme.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import React from "react"

import { useTheme } from "@emotion/react"
import { Theme as GlideTheme, SpriteMap } from "@glideapps/glide-data-grid"
import { mix, transparentize } from "color2k"

import { convertRemToPx, EmotionTheme } from "@streamlit/lib/src/theme"

export type CustomGridTheme = {
  // The theme configuration for the glide-data-grid
  glideTheme: Partial<GlideTheme>
  // The table border radius in pixels
  tableBorderRadius: string
  // The table border size in pixels
  tableBorderWidth: number
  // The default table height in pixels
  defaultTableHeight: number
  // Configure custom SVG icons used in the column header:
  headerIcons: SpriteMap
  // The background color of the row when it is hovered:
  bgRowHovered: string
  // Min column width in pixels used for manual and automatic resizing
  minColumnWidth: number
  // Max column width in pixels used for manual resizing
  maxColumnWidth: number
  // Max column width in pixels used for automatic column sizing
  maxColumnAutoWidth: number
  // The default row height in pixels
  defaultRowHeight: number
  // The default header height in pixels
  defaultHeaderHeight: number
}

/**
 * Creates a glide-data-grid compatible theme based on our theme configuration.
 *
 * @return a glide-data-grid compatible theme.
 */
function useCustomTheme(): Readonly<CustomGridTheme> {
  const theme: EmotionTheme = useTheme()

  const gridTheme: CustomGridTheme = React.useMemo<CustomGridTheme>(() => {
    const headerIcons = {
      // Material design icon `edit_note`:
      // https://fonts.google.com/icons?selected=Material%20Symbols%20Outlined%3Aedit_note%3AFILL%400%3Bwght%40400%3BGRAD%400%3Bopsz%4048
      // We need to provide this as string as explained explained here: https://github.com/glideapps/glide-data-grid/blob/main/packages/core/API.md#headericons
      editable: (p: { bgColor: string }) =>
        `<svg xmlns="http://www.w3.org/2000/svg" height="40" viewBox="0 96 960 960" width="40" fill="${p.bgColor}"><path d="m800.641 679.743-64.384-64.384 29-29q7.156-6.948 17.642-6.948 10.485 0 17.742 6.948l29 29q6.948 7.464 6.948 17.95 0 10.486-6.948 17.434l-29 29Zm-310.64 246.256v-64.383l210.82-210.821 64.384 64.384-210.821 210.82h-64.383Zm-360-204.872v-50.254h289.743v50.254H130.001Zm0-162.564v-50.255h454.615v50.255H130.001Zm0-162.307v-50.255h454.615v50.255H130.001Z"/></svg>`,
    }

    const glideTheme = {
      // Explanations: https://github.com/glideapps/glide-data-grid/blob/main/packages/core/API.md#theme
      accentColor: theme.colors.primary,
      accentFg: theme.colors.white,
      accentLight: transparentize(theme.colors.primary, 0.9),
      borderColor: theme.colors.borderColorLight,
      horizontalBorderColor: theme.colors.borderColorLight,
      fontFamily: theme.genericFonts.bodyFont,
      bgSearchResult: transparentize(theme.colors.primary, 0.9),
      resizeIndicatorColor: theme.colors.primary,
      // Header styling:
      bgIconHeader: theme.colors.fadedText60,
      fgIconHeader: theme.colors.white,
      bgHeader: theme.colors.bgMix,
      bgHeaderHasFocus: theme.colors.secondaryBg,
      bgHeaderHovered: theme.colors.secondaryBg,
      textHeader: theme.colors.fadedText60,
      textHeaderSelected: theme.colors.white,
      textGroupHeader: theme.colors.fadedText60,
      headerFontStyle: `${theme.fontSizes.sm}`,
      // Cell styling:
      baseFontStyle: theme.fontSizes.sm,
      editorFontSize: theme.fontSizes.sm,
      textDark: theme.colors.bodyText,
      textMedium: transparentize(theme.colors.bodyText, 0.2),
      textLight: theme.colors.fadedText40,
      textBubble: theme.colors.fadedText60,
      bgCell: theme.colors.bgColor,
      // uses same as bgCell to always have the same background color:
      bgCellMedium: theme.colors.bgColor,
      cellHorizontalPadding: Math.round(convertRemToPx(theme.spacing.sm)),
      cellVerticalPadding: Math.round(convertRemToPx("0.1875rem")),
      // Special cells:
      bgBubble: theme.colors.secondaryBg,
      bgBubbleSelected: theme.colors.secondaryBg,
      linkColor: theme.colors.linkText,
      drilldownBorder: theme.colors.darkenedBgMix25,
      // Unused settings:
      // lineHeight
      // headerIconSize: number;
      // markerFontStyle: string;
      // resizeIndicatorColor?: string;
      // headerBottomBorderColor?: string;
    }

    return {
      glideTheme,
      tableBorderRadius: theme.radii.default,
      tableBorderWidth: 1,
      // glide-data-grid can only handle integer pixel values:
      defaultTableHeight: Math.round(convertRemToPx("25rem")),
      minColumnWidth: Math.round(convertRemToPx("3.125rem")),
      maxColumnWidth: Math.round(convertRemToPx("62.5rem")),
      maxColumnAutoWidth: Math.round(convertRemToPx("31.25rem")),
      defaultRowHeight: Math.round(convertRemToPx("2.1875rem")),
      defaultHeaderHeight: Math.round(convertRemToPx("2.1875rem")),
      bgRowHovered: mix(theme.colors.bgColor, theme.colors.secondaryBg, 0.3),
      headerIcons,
    }
  }, [theme])

  return gridTheme
}

export default useCustomTheme


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useDataEditor.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  CompactSelection,
  GridSelection,
  TextCell,
} from "@glideapps/glide-data-grid"
import { renderHook } from "@testing-library/react-hooks"

import {
  BaseColumn,
  NumberColumn,
  TextColumn,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"
import EditingState from "@streamlit/lib/src/components/widgets/DataFrame/EditingState"
import { notNullOrUndefined } from "@streamlit/lib/src/util/utils"

import useDataEditor from "./useDataEditor"

const MOCK_COLUMNS: BaseColumn[] = [
  NumberColumn({
    id: "column_1",
    name: "column_1",
    title: "column_1",
    indexNumber: 0,
    arrowType: {
      pandas_type: "int64",
      numpy_type: "int64",
    },
    isEditable: true,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
  }),
  TextColumn({
    id: "column_2",
    name: "column_2",
    title: "column_2",
    indexNumber: 1,
    arrowType: {
      pandas_type: "unicode",
      numpy_type: "object",
    },
    isEditable: true,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
    defaultValue: "foo",
    columnTypeOptions: {
      max_chars: 10,
      validate: "^[a-zA-Z]+$",
    },
  }),
]

const INITIAL_NUM_ROWS = 3
const refreshCellsMock = vi.fn()
const syncEditsMock = vi.fn()
const updateNumRows = vi.fn()
const clearSelectionMock = vi.fn()
const getOriginalIndexMock = vi.fn().mockImplementation((index: number) => {
  return index
})
const getCellContentMock = vi
  .fn()
  .mockImplementation(([col]: readonly [number]) => {
    const column = MOCK_COLUMNS[col]
    if (column.kind === "number") {
      return column.getCell(123)
    }
    return column.getCell("foo")
  })

describe("useDataEditor hook", () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })
  it("allows to edit cells with onCellEdited", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }

    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        false,
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.onCellEdited !== "function") {
      throw new Error("onCellEdited is expected to be a function")
    }

    const columnToEdit = MOCK_COLUMNS[1]
    result.current.onCellEdited(
      [1, 0],
      columnToEdit.getCell("bar") as TextCell
    )
    expect(syncEditsMock).toHaveBeenCalled()
    expect(getCellContentMock).toHaveBeenCalled()
    const editedCell = editingState.current.getCell(1, 0)

    expect(notNullOrUndefined(editedCell)).toBe(true)

    // @ts-expect-error
    expect(columnToEdit.getCellValue(editedCell)).toEqual("bar")

    // Check with full editing state
    expect(editingState.current.toJson(MOCK_COLUMNS)).toEqual(
      '{"edited_rows":{"0":{"column_2":"bar"}},"added_rows":[],"deleted_rows":[]}'
    )
  })

  it("correctly handles indices on editing", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }

    const { result } = renderHook(() => {
      return useDataEditor(
        [{ ...MOCK_COLUMNS[0], isIndex: true }, MOCK_COLUMNS[1]],
        false,
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.onCellEdited !== "function") {
      throw new Error("onCellEdited is expected to be a function")
    }

    const columnToEdit = MOCK_COLUMNS[1]
    result.current.onCellEdited(
      [1, 0],
      columnToEdit.getCell("bar") as TextCell
    )
    expect(syncEditsMock).toHaveBeenCalled()
    expect(getCellContentMock).toHaveBeenCalled()
    const editedCell = editingState.current.getCell(1, 0)

    expect(notNullOrUndefined(editedCell)).toBe(true)

    // @ts-expect-error
    expect(columnToEdit.getCellValue(editedCell)).toEqual("bar")

    // Check with full editing state
    expect(editingState.current.toJson(MOCK_COLUMNS)).toEqual(
      '{"edited_rows":{"0":{"column_2":"bar"}},"added_rows":[],"deleted_rows":[]}'
    )
  })

  it("applies cell edits from pasted data via onPaste", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }
    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        false,
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.onPaste !== "function") {
      throw new Error("onPaste is expected to be a function")
    }

    // Paste in some data into the second row:
    result.current.onPaste([0, 1], [["321", "bar", "baz"]])

    expect(syncEditsMock).toHaveBeenCalled()
    expect(getCellContentMock).toHaveBeenCalled()

    // Check edited data from first column
    const cell1 = editingState.current.getCell(0, 1)
    expect(notNullOrUndefined(cell1)).toBe(true)

    // @ts-expect-error
    expect(MOCK_COLUMNS[0].getCellValue(cell1)).toEqual(321)

    // Check data from second column
    const cell2 = editingState.current.getCell(1, 1)
    expect(cell2).not.toBeNull()

    // @ts-expect-error
    expect(MOCK_COLUMNS[1].getCellValue(cell2)).toEqual("bar")

    // Check with full editing state
    expect(editingState.current.toJson(MOCK_COLUMNS)).toEqual(
      '{"edited_rows":{"1":{"column_1":321,"column_2":"bar"}},"added_rows":[],"deleted_rows":[]}'
    )
  })

  it("adds new rows from pasted data via onPaste", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }
    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        false, // activates addition & deletion of rows
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.onPaste !== "function") {
      throw new Error("onPaste is expected to be a function")
    }

    // Paste in two rows into the last row
    result.current.onPaste(
      [0, INITIAL_NUM_ROWS - 1],
      [
        ["321", "bar", "baz"],
        ["432", "lorem", "ipsum"],
      ]
    )

    // This should have added one row:
    expect(editingState.current.getNumRows()).toEqual(INITIAL_NUM_ROWS + 1)

    expect(syncEditsMock).toHaveBeenCalled()
    expect(getCellContentMock).toHaveBeenCalled()

    // Check with full editing state:
    expect(editingState.current.toJson(MOCK_COLUMNS)).toEqual(
      '{"edited_rows":{"2":{"column_1":321,"column_2":"bar"}},"added_rows":[{"column_1":432,"column_2":"lorem"}],"deleted_rows":[]}'
    )
  })

  it("doesn't add new rows from pasted data via onPaste if fixed num rows", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }
    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        true, // deactivate the addition of new rows
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.onPaste !== "function") {
      throw new Error("onPaste is expected to be a function")
    }

    // Paste in two rows into the last row
    result.current.onPaste(
      [0, INITIAL_NUM_ROWS - 1],
      [
        ["321", "bar", "baz"],
        ["432", "lorem", "ipsum"],
      ]
    )

    // This should not have added any rows since fixedNumRows is true
    expect(editingState.current.getNumRows()).toEqual(INITIAL_NUM_ROWS)

    expect(syncEditsMock).toHaveBeenCalled()
    expect(getCellContentMock).toHaveBeenCalled()

    // Check with full editing state:
    expect(editingState.current.toJson(MOCK_COLUMNS)).toEqual(
      '{"edited_rows":{"2":{"column_1":321,"column_2":"bar"}},"added_rows":[],"deleted_rows":[]}'
    )
  })

  it("allows to add new rows via onRowAppended", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }
    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        false, // activates addition & deletion of rows
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.onRowAppended !== "function") {
      throw new Error("onRowAppended is expected to be a function")
    }

    result.current.onRowAppended()

    // This should have added one row
    expect(editingState.current.getNumRows()).toEqual(INITIAL_NUM_ROWS + 1)

    expect(syncEditsMock).toHaveBeenCalled()
  })

  it("uses default values for new rows in onRowAppended", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }
    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        false, // activates addition & deletion of rows
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.onRowAppended !== "function") {
      throw new Error("onRowAppended is expected to be a function")
    }

    result.current.onRowAppended()

    // Check with full editing state:
    expect(editingState.current.toJson(MOCK_COLUMNS)).toEqual(
      '{"edited_rows":{},"added_rows":[{"column_2":"foo"}],"deleted_rows":[]}'
    )
  })

  it("doesn't allow to add new rows via onRowAppended if fix num rows", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }
    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        true, // deactivates addition & deletion of rows
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.onRowAppended !== "function") {
      throw new Error("onRowAppended is expected to be a function")
    }

    result.current.onRowAppended()

    // Row addition is deactivated, this should not add any rows
    expect(editingState.current.getNumRows()).toEqual(INITIAL_NUM_ROWS)

    expect(syncEditsMock).toHaveBeenCalledTimes(0)
  })

  it("allows to delete cell content via onDelete", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }
    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        false,
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.onDelete !== "function") {
      throw new Error("onDelete is expected to be a function")
    }

    // Mock selection to delete cell 0,0
    const deleteCellSelection = {
      current: {
        range: { x: 0, y: 0, width: 1, height: 1 },
      },
      rows: CompactSelection.empty(),
      columns: CompactSelection.empty(),
    } as GridSelection

    // Delete the cell content for 0,0 -> changes the value to null
    result.current.onDelete(deleteCellSelection)

    expect(syncEditsMock).toHaveBeenCalled()
    expect(refreshCellsMock).toHaveBeenCalledWith([{ cell: [0, 0] }])

    // The value of cell 0,0 should be null
    const cell1 = editingState.current.getCell(0, 0)

    expect(notNullOrUndefined(cell1)).toBe(true)

    // @ts-expect-error
    expect(MOCK_COLUMNS[0].getCellValue(cell1)).toEqual(null)

    // Check with full editing state
    expect(editingState.current.toJson(MOCK_COLUMNS)).toEqual(
      '{"edited_rows":{"0":{"column_1":null}},"added_rows":[],"deleted_rows":[]}'
    )
  })

  it("allows to delete rows via onDelete", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }
    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        false, // activates addition & deletion of rows
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.onDelete !== "function") {
      throw new Error("onDelete is expected to be a function")
    }

    // Mock selection to delete row 1
    const deleteRowSelection = {
      current: undefined,
      rows: CompactSelection.fromSingleSelection(1),
      columns: CompactSelection.empty(),
    } as GridSelection

    // Delete the row
    result.current.onDelete(deleteRowSelection)

    // The number of rows should be one less
    expect(editingState.current.getNumRows()).toEqual(INITIAL_NUM_ROWS - 1)

    expect(syncEditsMock).toHaveBeenCalled()

    // Check with full editing state
    expect(editingState.current.toJson(MOCK_COLUMNS)).toEqual(
      `{"edited_rows":{},"added_rows":[],"deleted_rows":[1]}`
    )
  })

  it("doesn't allow to delete rows via onDelete if fix num rows", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }
    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        true, // deactivates addition & deletion of rows
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.onDelete !== "function") {
      throw new Error("onDelete is expected to be a function")
    }

    // Mock selection to delete row 1
    const deleteRowSelection = {
      current: undefined,
      rows: CompactSelection.fromSingleSelection(1),
      columns: CompactSelection.empty(),
    } as GridSelection

    // Delete the row
    result.current.onDelete(deleteRowSelection)

    // The number of rows should be same since row deletion is not allowed:
    expect(editingState.current.getNumRows()).toEqual(INITIAL_NUM_ROWS)

    expect(syncEditsMock).toHaveBeenCalledTimes(0)

    // Check with full editing state
    expect(editingState.current.toJson(MOCK_COLUMNS)).toEqual(
      `{"edited_rows":{},"added_rows":[],"deleted_rows":[]}`
    )
  })

  it("calls validateInput and returns false on invalid data.", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }

    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        false,
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.validateCell !== "function") {
      throw new Error("validateCell is expected to be a function")
    }

    const columnToValidate = MOCK_COLUMNS[1]
    const invalidValue = columnToValidate.getCell("12345") as TextCell
    const validationResult = result.current.validateCell(
      [1, 0],
      invalidValue,
      columnToValidate.getCell(undefined)
    )

    expect(validationResult).toEqual(false)
  })

  it("calls validateInput and corrects invalid input.", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }

    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        false,
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.validateCell !== "function") {
      throw new Error("validateCell is expected to be a function")
    }

    const columnToValidate = MOCK_COLUMNS[1]
    const invalidValue = columnToValidate.getCell("abcdefghijk") as TextCell
    const validationResult = result.current.validateCell(
      [1, 0],
      invalidValue,
      columnToValidate.getCell(undefined)
    )
    expect((validationResult as TextCell).data).toEqual("abcdefghij")
  })

  it("calls validateInput and returns true on valid data.", () => {
    const editingState = {
      current: new EditingState(INITIAL_NUM_ROWS),
    }

    const { result } = renderHook(() => {
      return useDataEditor(
        MOCK_COLUMNS,
        false,
        editingState,
        getCellContentMock,
        getOriginalIndexMock,
        refreshCellsMock,
        updateNumRows,
        syncEditsMock,
        clearSelectionMock
      )
    })

    if (typeof result.current.validateCell !== "function") {
      throw new Error("validateCell is expected to be a function")
    }

    const columnToValidate = MOCK_COLUMNS[1]

    const validValue = columnToValidate.getCell("abcde") as TextCell
    const validResult = result.current.validateCell(
      [1, 0],
      validValue,
      columnToValidate.getCell(undefined)
    )

    expect(validResult).toEqual(true)
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useDataEditor.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import {
  DataEditorProps,
  EditableGridCell,
  GridCell,
  GridSelection,
  Item,
  ValidatedGridCell,
} from "@glideapps/glide-data-grid"

import { logWarning } from "@streamlit/lib/src/util/log"
import { notNullOrUndefined } from "@streamlit/lib/src/util/utils"
import {
  BaseColumn,
  isErrorCell,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"
import EditingState from "@streamlit/lib/src/components/widgets/DataFrame/EditingState"

/**
 * Create return type for useDataLoader hook based on the DataEditorProps.
 */
type DataEditorReturn = Pick<
  DataEditorProps,
  "onCellEdited" | "onPaste" | "onRowAppended" | "onDelete" | "validateCell"
>

/**
 * Custom hook to handle all aspects related to data editing. This includes editing cells,
 * pasting from clipboard, and appending & deleting rows.
 *
 * @param columns - The columns of the table.
 * @param fixedNumRows - Whether the number of rows is fixed. This means that rows cannot be added or deleted.
 * @param editingState - The editing state of the data editor.
 * @param getCellContent - Function to get a specific cell.
 * @param getOriginalIndex - Function to map a row ID of the current state to the original row ID.
 *                           This mainly changed by sorting of columns.
 * @param updateNumRows - Callback to sync the number of rows from editing state with the component state.
 * @param refreshCells - Callback that allows to trigger a UI refresh of a selection of cells.
 * @param syncEditState - Callback that needs to be called on all edits. This will also trigger a rerun
 *                     and send widget state to the backend.
 *
 * @returns Glide-data-grid compatible functions for editing capabilities.
 */
function useDataEditor(
  columns: BaseColumn[],
  fixedNumRows: boolean,
  editingState: React.MutableRefObject<EditingState>,
  getCellContent: ([col, row]: readonly [number, number]) => GridCell,
  getOriginalIndex: (index: number) => number,
  refreshCells: (
    cells: {
      cell: [number, number]
    }[]
  ) => void,
  updateNumRows: () => void,
  syncEditState: () => void,
  clearSelection: () => void
): DataEditorReturn {
  const onCellEdited = React.useCallback(
    (
      [col, row]: readonly [number, number],
      updatedCell: EditableGridCell
    ): void => {
      const column = columns[col]

      if (!column.isEditable) {
        return
      }

      const originalCol = column.indexNumber

      // We need to apply two different mappings here. One for the case that
      // the user has sorted a column, and another one from the editing state
      // to get the correct row ID when the user has deleted rows.
      const originalRow = editingState.current.getOriginalRowIndex(
        getOriginalIndex(row)
      )
      const currentCell = getCellContent([col, row])
      const currentValue = column.getCellValue(currentCell)
      const newValue = column.getCellValue(updatedCell)
      if (!isErrorCell(currentCell) && newValue === currentValue) {
        // No editing is required since the values did not change
        return
      }

      const newCell = column.getCell(newValue, true)
      // Only update the cell if the new cell is not causing any errors:
      if (!isErrorCell(newCell)) {
        editingState.current.setCell(originalCol, originalRow, {
          ...newCell,
          lastUpdated: performance.now(),
        })

        syncEditState()
      } else {
        logWarning(
          `Not applying the cell edit since it causes this error:\n ${newCell.data}`
        )
      }
    },
    [columns, editingState, getOriginalIndex, getCellContent, syncEditState]
  )

  /**
   * Appends a new empty row to the end of the table.
   */
  const appendEmptyRow = React.useCallback(() => {
    if (fixedNumRows) {
      // Appending rows is not supported
      return
    }

    const newRow: Map<number, GridCell> = new Map()
    columns.forEach(column => {
      // For the default value, we trust the developer to make a valid choice,
      // so we do not validate the value here.
      newRow.set(column.indexNumber, column.getCell(column.defaultValue))
    })
    editingState.current.addRow(newRow)
    updateNumRows()
  }, [columns, editingState, fixedNumRows, updateNumRows])

  /**
   * Callback used by glide-data-grid when the user adds a new row in the table UI.
   */
  const onRowAppended = React.useCallback(() => {
    if (fixedNumRows) {
      // Appending rows is not supported
      return
    }

    appendEmptyRow()
    syncEditState()
  }, [appendEmptyRow, syncEditState, fixedNumRows])

  /**
   * Callback used by glide-data-grid when the user deletes a row or cell value in the table UI.
   */
  const onDelete = React.useCallback(
    (selection: GridSelection): GridSelection | boolean => {
      if (selection.rows.length > 0) {
        // User has selected one or more rows
        if (fixedNumRows) {
          // Deleting rows is not supported
          return true
        }

        const rowsToDelete = selection.rows.toArray().map(row => {
          return editingState.current.getOriginalRowIndex(
            getOriginalIndex(row)
          )
        })
        // We need to delete all rows at once, so that the indexes work correct
        editingState.current.deleteRows(rowsToDelete)
        updateNumRows()
        clearSelection()
        syncEditState()
        return false
      }
      if (selection.current?.range) {
        // User has selected one or more cells
        const updatedCells: { cell: [number, number] }[] = []
        const selectedArea = selection.current.range
        for (
          let row = selectedArea.y;
          row < selectedArea.y + selectedArea.height;
          row++
        ) {
          for (
            let col = selectedArea.x;
            col < selectedArea.x + selectedArea.width;
            col++
          ) {
            const column = columns[col]
            // Only allow deletion if the column is editable and not configured as required
            if (column.isEditable && !column.isRequired) {
              updatedCells.push({
                cell: [col, row],
              })
              onCellEdited(
                [col, row],
                column.getCell(null) as EditableGridCell
              )
            }
          }
        }

        if (updatedCells.length > 0) {
          syncEditState()
          refreshCells(updatedCells)
        }
        return false
      }
      return true
    },
    [
      columns,
      editingState,
      fixedNumRows,
      refreshCells,
      getOriginalIndex,
      syncEditState,
      onCellEdited,
      clearSelection,
      updateNumRows,
    ]
  )

  /**
   * Callback used by glide-data-grid when the user pastes data into the table.
   */
  const onPaste = React.useCallback(
    (target: Item, values: readonly (readonly string[])[]): boolean => {
      const [targetCol, targetRow] = target

      const updatedCells: { cell: [number, number] }[] = []

      for (let row = 0; row < values.length; row++) {
        const rowData = values[row]
        if (row + targetRow >= editingState.current.getNumRows()) {
          if (fixedNumRows) {
            // Only add new rows if editing mode is dynamic, otherwise break here
            break
          }
          // Adding rows during paste would not work currently. However, we already disallow
          // sorting in dynamic mode, so we don't have to do anything here.
          appendEmptyRow()
        }
        for (let col = 0; col < rowData.length; col++) {
          const pasteDataValue = rowData[col]

          const rowIndex = row + targetRow
          const colIndex = col + targetCol

          if (colIndex >= columns.length) {
            // We could potentially add new columns here in the future.
            break
          }

          const column = columns[colIndex]
          // Only add to columns that are editable:
          if (column.isEditable) {
            const newCell = column.getCell(pasteDataValue, true)

            // We are not editing cells if the pasted value leads to an error:
            if (notNullOrUndefined(newCell) && !isErrorCell(newCell)) {
              const originalCol = column.indexNumber
              const originalRow = editingState.current.getOriginalRowIndex(
                getOriginalIndex(rowIndex)
              )
              const currentValue = column.getCellValue(
                getCellContent([colIndex, rowIndex])
              )
              const newValue = column.getCellValue(newCell)
              // Edit the cell only if the value actually changed:
              if (newValue !== currentValue) {
                editingState.current.setCell(originalCol, originalRow, {
                  ...newCell,
                  lastUpdated: performance.now(),
                })

                updatedCells.push({
                  cell: [colIndex, rowIndex],
                })
              }
            }
          }
        }

        if (updatedCells.length > 0) {
          syncEditState()
          refreshCells(updatedCells)
        }
      }

      return false
    },
    [
      columns,
      editingState,
      fixedNumRows,
      getOriginalIndex,
      getCellContent,
      appendEmptyRow,
      syncEditState,
      refreshCells,
    ]
  )

  /**
   * Callback used by glide-data-grid to validate the data inputted into a cell by the user.
   */
  const validateCell = React.useCallback(
    (cell: Item, newValue: EditableGridCell) => {
      const col = cell[0]
      if (col >= columns.length) {
        // This should never happen.
        // But we return true (default) to avoid any unknown issues.
        return true
      }

      const column = columns[col]
      if (column.validateInput) {
        // We get the actual raw value of the new cell and
        // validate it based on the column validateInput implementation:
        const validationResult = column.validateInput(
          column.getCellValue(newValue)
        )
        if (validationResult === true || validationResult === false) {
          // Only return if the validation result is a valid boolean value (true or false)
          // validationResult can also be other values, so we need to check this specifically.
          return validationResult
        }
        // If it is any other value, we return it as a corrected cell:
        return column.getCell(validationResult) as ValidatedGridCell
      }
      // If no validation is implemented, we accept the value:
      return true
    },
    [columns]
  )

  return {
    onCellEdited,
    onPaste,
    onRowAppended,
    onDelete,
    validateCell,
  }
}

export default useDataEditor


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useDataExporter.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { renderHook } from "@testing-library/react-hooks"
import { showSaveFilePicker } from "native-file-system-adapter"

import {
  BaseColumn,
  NumberColumn,
  TextColumn,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"

import useDataExporter, { toCsvRow } from "./useDataExporter"

const mockWrite = vi.fn()
const mockClose = vi.fn()

// The native-file-system-adapter is not available in tests, so we need to mock it.
vi.mock("native-file-system-adapter", () => ({
  showSaveFilePicker: vi.fn().mockImplementation((_object: any) => {
    return {
      createWritable: vi.fn().mockImplementation(() => {
        return {
          write: mockWrite,
          close: mockClose,
        }
      }),
    }
  }),
}))

const MOCK_COLUMNS: BaseColumn[] = [
  NumberColumn({
    id: "column_1",
    name: "column_1",
    title: "column_1",
    indexNumber: 0,
    arrowType: {
      pandas_type: "int64",
      numpy_type: "int64",
    },
    isEditable: false,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
  }),
  TextColumn({
    id: "column_2",
    name: "column_2",
    title: "column_2",
    indexNumber: 1,
    arrowType: {
      pandas_type: "unicode",
      numpy_type: "object",
    },
    isEditable: false,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
    columnTypeOptions: {},
  }),
]

const NUM_ROWS = 5

const getCellContentMock = vi
  .fn()
  .mockImplementation(([col]: readonly [number]) => {
    const column = MOCK_COLUMNS[col]
    if (column.kind === "number") {
      return column.getCell(123)
    }
    return column.getCell("foo")
  })

describe("toCsvRow", () => {
  it.each([
    [["foo", "bar"], "foo,bar\n"],
    [[1, 2], "1,2\n"],
    // Correctly escapes if value has comma:
    [["foo,bar", "baz"], '"foo,bar",baz\n'],
    // Correctly escapes if value has quote:
    [['foo"bar', "baz"], '"foo""bar",baz\n'],
    [["foo,,,bar", "baz,"], '"foo,,,bar","baz,"\n'],
    [[true, 10.123141], "true,10.123141\n"],
  ])("converts %p to a valid CSV row: %p", (input, expected) => {
    expect(toCsvRow(input)).toEqual(expected)
  })
})

describe("useDataExporter hook", () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it("correctly writes data row-by-row to writable", async () => {
    const { result } = renderHook(() => {
      return useDataExporter(getCellContentMock, MOCK_COLUMNS, NUM_ROWS, false)
    })

    if (typeof result.current.exportToCsv !== "function") {
      throw new Error("exportToCsv is expected to be a function")
    }
    await result.current.exportToCsv()

    const textEncoder = new TextEncoder()

    expect(getCellContentMock).toHaveBeenCalled()
    // Number of writes: 1 for BOM + 1 for header + num rows
    expect(mockWrite).toBeCalledTimes(NUM_ROWS + 2)
    expect(mockWrite).toBeCalledWith(textEncoder.encode("\ufeff"))
    // Write the header row:
    expect(mockWrite).toBeCalledWith(textEncoder.encode("column_1,column_2\n"))
    expect(mockWrite).toBeCalledWith(textEncoder.encode("123,foo\n"))
    expect(mockClose).toBeCalledTimes(1)
  })

  it("correctly creates a file picker", async () => {
    const { result } = renderHook(() => {
      return useDataExporter(getCellContentMock, MOCK_COLUMNS, NUM_ROWS, false)
    })

    if (typeof result.current.exportToCsv !== "function") {
      throw new Error("exportToCsv is expected to be a function")
    }

    const timestamp = new Date().toISOString().slice(0, 16).replace(":", "-")
    await result.current.exportToCsv()

    expect(showSaveFilePicker).toBeCalledTimes(1)
    expect(showSaveFilePicker).toBeCalledWith({
      excludeAcceptAllOption: false,
      suggestedName: `${timestamp}_export.csv`,
      types: [{ accept: { "text/csv": [".csv"] } }],
    })
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useDataExporter.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { DataEditorProps } from "@glideapps/glide-data-grid"

import createDownloadLinkElement from "@streamlit/lib/src/util/createDownloadLinkElement"
import {
  BaseColumn,
  toSafeString,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"
import { isNullOrUndefined } from "@streamlit/lib/src/util/utils"
import { logError, logWarning } from "@streamlit/lib/src/util/log"

// Delimiter between cells
const CSV_DELIMITER = ","
// Quote character for cell values containing special characters
const CSV_QUOTE_CHAR = '"'
// The character used to escape the quote character within a cell
const CSV_ESCAPE_CHAR = '"'
// Delimiter between rows (newline)
const CSV_ROW_DELIMITER = "\n"
// Used to indicate Unicode encoding of a text file (for excel compatibility)
const CSV_UTF8_BOM = "\ufeff"
// Regex to check if a value contains special characters that need to be escaped
const CSV_SPECIAL_CHARS_REGEX = new RegExp(
  `[${[CSV_DELIMITER, CSV_QUOTE_CHAR, CSV_ROW_DELIMITER].join("")}]`
)

export function toCsvRow(rowValues: any[]): string {
  return (
    rowValues.map(cell => escapeValue(cell)).join(CSV_DELIMITER) +
    CSV_ROW_DELIMITER
  )
}

/**
 * Escapes a cell value for CSV export.
 *
 * Makes sure that the value is a string, and special characters are escaped correctly.
 */
function escapeValue(value: any): string {
  if (isNullOrUndefined(value)) {
    return ""
  }
  const strValue = toSafeString(value)

  // Special chars need to be escaped:
  if (CSV_SPECIAL_CHARS_REGEX.test(strValue)) {
    // Add quotes around the value:
    return `${CSV_QUOTE_CHAR}${strValue.replace(
      // Escape all quote chars if inside a quoted string:
      new RegExp(CSV_QUOTE_CHAR, "g"),
      CSV_ESCAPE_CHAR + CSV_QUOTE_CHAR
    )}${CSV_QUOTE_CHAR}`
  }

  return strValue
}

type DataExporterReturn = {
  // A callback to trigger the data download as CSV
  exportToCsv: () => void
}

/**
 * Writes CSV data to a specified writable stream using provided data table parameters.
 * Initiates by writing a UTF-8 Byte Order Mark (BOM) for Excel compatibility, followed by
 * column headers and rows constructed from the cell values obtained through `getCellContent`.
 * The function handles encoding and CSV formatting, concluding by closing the writable stream.
 *
 * @param {WritableStreamDefaultWriter} writable - Target stream for CSV data.
 * @param {DataEditorProps["getCellContent"]} getCellContent - The cell content getter compatible with glide-data-grid.
 * @param {BaseColumn[]} columns - The columns of the table.
 * @param {number} numRows - The number of rows of the current state.
 *
 * @returns {Promise<void>} Promise that resolves when the CSV has been fully written.
 */
async function writeCsv(
  writable: WritableStreamDefaultWriter,
  getCellContent: DataEditorProps["getCellContent"],
  columns: BaseColumn[],
  numRows: number
): Promise<void> {
  const textEncoder = new TextEncoder()

  // Write UTF-8 BOM for excel compatibility:
  await writable.write(textEncoder.encode(CSV_UTF8_BOM))

  // Write headers:
  const headers: string[] = columns.map(column => column.name)
  await writable.write(textEncoder.encode(toCsvRow(headers)))

  for (let row = 0; row < numRows; row++) {
    const rowData: any[] = []
    columns.forEach((column: BaseColumn, col: number, _map) => {
      rowData.push(column.getCellValue(getCellContent([col, row])))
    })
    // Write row to CSV:
    await writable.write(textEncoder.encode(toCsvRow(rowData)))
  }

  await writable.close()
}
/**
 * Custom hook that handles all the data export/download logic.
 *
 * @param getCellContent - The cell content getter compatible with glide-data-grid.
 * @param columns - The columns of the table.
 * @param numRows - The number of rows of the current state.
 *
 * @returns a callback to trigger the data download as CSV.
 */
function useDataExporter(
  getCellContent: DataEditorProps["getCellContent"],
  columns: BaseColumn[],
  numRows: number,
  enforceDownloadInNewTab: boolean
): DataExporterReturn {
  const exportToCsv = React.useCallback(async () => {
    const timestamp = new Date().toISOString().slice(0, 16).replace(":", "-")
    const suggestedName = `${timestamp}_export.csv`
    try {
      // Lazy import to prevent weird breakage in some niche cases
      // (e.g. usage within the replay.io browser). The package works well
      // in all of the common browser, but might cause some trouble in
      // less common browsers. To not crash the whole app, we just lazy import
      // this here.
      const nativeFileSystemAdapter = await import(
        "native-file-system-adapter"
      )
      const fileHandle = await nativeFileSystemAdapter.showSaveFilePicker({
        suggestedName,
        types: [{ accept: { "text/csv": [".csv"] } }],
        excludeAcceptAllOption: false,
      })

      const writer = await fileHandle.createWritable()

      await writeCsv(writer, getCellContent, columns, numRows)
    } catch (error) {
      if (error instanceof Error && error.name === "AbortError") {
        // The user has canceled the save dialog. Do nothing.
        return
      }

      try {
        logWarning(
          "Failed to export data as CSV with FileSystem API, trying fallback method",
          error
        )
        // Simulated WritableStream that builds CSV content in-memory for the Blob fallback method
        let csvContent = ""

        const inMemoryWriter = new WritableStream({
          write: async chunk => {
            csvContent += new TextDecoder("utf-8").decode(chunk)
          },
          close: async () => {},
        })

        await writeCsv(
          inMemoryWriter.getWriter(),
          getCellContent,
          columns,
          numRows
        )

        // Fallback to the old browser download method:
        const blob = new Blob([csvContent], {
          type: "text/csv;charset=utf-8;",
        })
        const url = URL.createObjectURL(blob)

        const link = createDownloadLinkElement({
          enforceDownloadInNewTab,
          url,
          filename: suggestedName,
        })

        link.style.display = "none"

        document.body.appendChild(link) // Required for FF
        link.click()
        document.body.removeChild(link) // Clean up
        URL.revokeObjectURL(url) // Free up memory
      } catch (error) {
        logError("Failed to export data as CSV", error)
      }
    }
  }, [columns, numRows, getCellContent, enforceDownloadInNewTab])

  return {
    exportToCsv,
  }
}

export default useDataExporter


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useDataLoader.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { GridCellKind } from "@glideapps/glide-data-grid"
import { renderHook } from "@testing-library/react-hooks"

import {
  BaseColumn,
  isErrorCell,
  TextColumn,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"
import EditingState from "@streamlit/lib/src/components/widgets/DataFrame/EditingState"
import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import { MULTI, UNICODE } from "@streamlit/lib/src/mocks/arrow"
import { Arrow as ArrowProto } from "@streamlit/lib/src/proto"

import useDataLoader from "./useDataLoader"

// These columns are based on the UNICODE mock arrow table:
const MOCK_COLUMNS: BaseColumn[] = [
  TextColumn({
    arrowType: { meta: null, numpy_type: "object", pandas_type: "unicode" },
    id: "index-0",
    name: "",
    indexNumber: 0,
    isEditable: true,
    isHidden: false,
    isIndex: true,
    isPinned: true,
    isStretched: false,
    title: "",
  }),
  TextColumn({
    arrowType: { meta: null, numpy_type: "object", pandas_type: "unicode" },
    id: "column-c1-0",
    name: "c1",
    indexNumber: 1,
    isEditable: true,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
    title: "c1",
  }),
  TextColumn({
    arrowType: { meta: null, numpy_type: "object", pandas_type: "unicode" },
    columnTypeOptions: undefined,
    id: "column-c2-1",
    name: "c2",
    indexNumber: 2,
    isEditable: true,
    isHidden: false,
    isIndex: false,
    isPinned: false,
    isStretched: false,
    title: "c2",
  }),
]

describe("useDataLoader hook", () => {
  it("creates a glide-data-grid compatible callback to access cells", () => {
    const element = ArrowProto.create({
      data: UNICODE,
    })
    const data = new Quiver(element)
    const numRows = data.dimensions.numRows

    const { result } = renderHook(() => {
      const editingState = React.useRef<EditingState>(
        new EditingState(numRows)
      )
      return useDataLoader(data, MOCK_COLUMNS, numRows, editingState)
    })

    // Row 1
    expect(
      MOCK_COLUMNS[0].getCellValue(result.current.getCellContent([0, 0]))
    ).toBe("i1")
    expect(
      MOCK_COLUMNS[1].getCellValue(result.current.getCellContent([1, 0]))
    ).toBe("foo")
    expect(
      MOCK_COLUMNS[2].getCellValue(result.current.getCellContent([2, 0]))
    ).toBe("1")

    // Row 2
    expect(
      MOCK_COLUMNS[0].getCellValue(result.current.getCellContent([0, 1]))
    ).toBe("i2")
    expect(
      MOCK_COLUMNS[1].getCellValue(result.current.getCellContent([1, 1]))
    ).toBe("bar")
    expect(
      MOCK_COLUMNS[2].getCellValue(result.current.getCellContent([2, 1]))
    ).toBe("2")

    // if row out of bounds. return error cell
    expect(isErrorCell(result.current.getCellContent([0, 2]))).toBe(true)

    // if column out of bounds. return error cell
    expect(isErrorCell(result.current.getCellContent([3, 0]))).toBe(true)
  })

  it("correctly handles multi-index headers", () => {
    const element = ArrowProto.create({
      data: MULTI,
    })
    const data = new Quiver(element)
    const numRows = data.dimensions.numRows

    const { result } = renderHook(() => {
      const editingState = React.useRef<EditingState>(
        new EditingState(numRows)
      )
      return useDataLoader(data, MOCK_COLUMNS, numRows, editingState)
    })

    // Check that row 0 is returning the correct cell value:
    expect(
      MOCK_COLUMNS[0].getCellValue(result.current.getCellContent([2, 0]))
    ).toBe("foo")
  })

  it("uses editing state if a cell got edited", () => {
    const element = ArrowProto.create({
      data: UNICODE,
      editingMode: ArrowProto.EditingMode.FIXED,
    })

    const data = new Quiver(element)
    const numRows = data.dimensions.numRows

    const { result } = renderHook(() => {
      const editingState = React.useRef<EditingState>(
        new EditingState(numRows)
      )
      editingState.current.setCell(1, 0, {
        kind: GridCellKind.Text,
        displayData: "edited",
        data: "edited",
        allowOverlay: true,
      })
      return useDataLoader(data, MOCK_COLUMNS, numRows, editingState)
    })

    // Check if value got edited
    expect(
      MOCK_COLUMNS[1].getCellValue(result.current.getCellContent([1, 0]))
    ).toEqual("edited")
  })

  it("uses editing state if a row got deleted", () => {
    const element = ArrowProto.create({
      data: UNICODE,
      editingMode: ArrowProto.EditingMode.DYNAMIC,
    })

    const data = new Quiver(element)
    const numRows = data.dimensions.numRows

    const { result } = renderHook(() => {
      const editingState = React.useRef<EditingState>(
        new EditingState(numRows)
      )
      editingState.current.deleteRow(0)
      return useDataLoader(data, MOCK_COLUMNS, numRows, editingState)
    })

    // Should return value of second row
    expect(
      MOCK_COLUMNS[1].getCellValue(result.current.getCellContent([1, 0]))
    ).toEqual("bar")
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useDataLoader.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { DataEditorProps, GridCell } from "@glideapps/glide-data-grid"

import { getCellFromArrow } from "@streamlit/lib/src/components/widgets/DataFrame/arrowUtils"
import {
  BaseColumn,
  getErrorCell,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"
import EditingState from "@streamlit/lib/src/components/widgets/DataFrame/EditingState"
import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import { notNullOrUndefined } from "@streamlit/lib/src/util/utils"

type DataLoaderReturn = Pick<DataEditorProps, "getCellContent">

/**
 * Custom hook that handles all data loading capabilities for the interactive data table.
 * This also includes the logic to load and configure columns.
 *
 * @param data - The Arrow data extracted from the proto message
 * @param numRows - The number of rows of the current state (includes row additions/deletions)
 * @param editingState - The editing state of the data editor
 *
 * @returns the columns and the cell content getter compatible with glide-data-grid.
 */
function useDataLoader(
  data: Quiver,
  columns: BaseColumn[],
  numRows: number,
  editingState: React.MutableRefObject<EditingState>
): DataLoaderReturn {
  // numHeaderRows > 1 for multi-level headers
  const numHeaderRows = data.dimensions.numHeaderRows
  const getCellContent = React.useCallback(
    ([col, row]: readonly [number, number]): GridCell => {
      if (col > columns.length - 1) {
        return getErrorCell(
          "Column index out of bounds",
          "This error should never happen. Please report this bug."
        )
      }

      if (row > numRows - 1) {
        return getErrorCell(
          "Row index out of bounds",
          "This error should never happen. Please report this bug."
        )
      }
      const column = columns[col]

      const originalCol = column.indexNumber
      const originalRow = editingState.current.getOriginalRowIndex(row)
      const isAddedRow = editingState.current.isAddedRow(originalRow)
      // Use editing state if editable or if it is an appended row
      if (column.isEditable || isAddedRow) {
        const editedCell = editingState.current.getCell(
          originalCol,
          originalRow
        )
        if (notNullOrUndefined(editedCell)) {
          return editedCell
        } else if (isAddedRow) {
          // This is not expected to happen. All cells to added rows should
          // be defined. If not, we return a specific error cell.
          return getErrorCell(
            "Error during cell creation",
            "This error should never happen. Please report this bug. " +
              `No cell found for an added row: col=${originalCol}; row=${originalRow}`
          )
        }
      }

      try {
        // We skip all header rows to get to to the actual data rows.
        // in th Arrow data.
        const arrowCell = data.getCell(
          originalRow + numHeaderRows,
          originalCol
        )
        return getCellFromArrow(column, arrowCell, data.styler?.cssStyles)
      } catch (error) {
        return getErrorCell(
          "Error during cell creation",
          `This error should never happen. Please report this bug. \nError: ${error}`
        )
      }
    },
    [columns, numRows, data, editingState, numHeaderRows]
  )

  return {
    getCellContent,
  }
}

export default useDataLoader


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useRowHover.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { act, renderHook } from "@testing-library/react-hooks"

import { CustomGridTheme } from "./useCustomTheme"
import useRowHover from "./useRowHover"

const mockTheme = {
  bgRowHovered: "rgba(0, 0, 0, 0.1)",
} as CustomGridTheme

describe("useRowHover hook", () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it("should initialize with no row hover", () => {
    const { result } = renderHook(() => useRowHover(mockTheme))

    expect(result.current.getRowThemeOverride).toBeDefined()
    expect(result.current.onItemHovered).toBeDefined()

    // Initially, no row should have a hover theme
    const themeOverride = result.current.getRowThemeOverride?.(0, 0, 0)
    expect(themeOverride).toBeUndefined()
  })

  it("should apply hover theme to hovered row", () => {
    const { result } = renderHook(() => useRowHover(mockTheme))

    // Simulate hovering over row 1
    act(() => {
      result.current.onItemHovered?.({
        location: [0, 1], // [col, row]
        kind: "cell",
      } as any)
    })

    // Check that row 1 has hover theme
    const themeOverride = result.current.getRowThemeOverride?.(1, 1, 1)
    expect(themeOverride).toEqual({
      bgCell: mockTheme.bgRowHovered,
      bgCellMedium: mockTheme.bgRowHovered,
    })

    // Check that other rows don't have hover theme
    const otherRowTheme = result.current.getRowThemeOverride?.(0, 0, 0)
    expect(otherRowTheme).toBeUndefined()
  })

  it("should clear hover theme when mouse leaves", () => {
    const { result } = renderHook(() => useRowHover(mockTheme))

    // Simulate hovering over row 1
    act(() => {
      result.current.onItemHovered?.({
        location: [0, 1],
        kind: "cell",
      } as any)
    })

    // Simulate mouse leaving (undefined location)
    act(() => {
      result.current.onItemHovered?.({
        location: undefined,
        kind: "out-of-bounds",
      } as any)
    })

    // Check that hover theme is cleared
    const themeOverride = result.current.getRowThemeOverride?.(1, 1, 1)
    expect(themeOverride).toBeUndefined()
  })

  it("should update hover theme when moving between rows", () => {
    const { result } = renderHook(() => useRowHover(mockTheme))

    // Hover over row 1
    act(() => {
      result.current.onItemHovered?.({
        location: [0, 1],
        kind: "cell",
      } as any)
    })

    // Move to row 2
    act(() => {
      result.current.onItemHovered?.({
        location: [0, 2],
        kind: "cell",
      } as any)
    })

    // Check that row 1 no longer has hover theme
    const row1Theme = result.current.getRowThemeOverride?.(1, 1, 1)
    expect(row1Theme).toBeUndefined()

    // Check that row 2 has hover theme
    const row2Theme = result.current.getRowThemeOverride?.(2, 2, 2)
    expect(row2Theme).toEqual({
      bgCell: mockTheme.bgRowHovered,
      bgCellMedium: mockTheme.bgRowHovered,
    })
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useRowHover.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import {
  DataEditorProps,
  GetRowThemeCallback,
  GridMouseEventArgs,
} from "@glideapps/glide-data-grid"

import { CustomGridTheme } from "./useCustomTheme"

type RowHoverReturn = Pick<
  DataEditorProps,
  "onItemHovered" | "getRowThemeOverride"
>

/**
 * Hook to enable highlighting (via different background color) the row when hovering
 * over a cell in the row.
 *
 * @param gridTheme - The custom theme configuration.
 *
 * @returns An object containing the following properties:
 * - onItemHovered: The glide-data-grid compatible callback function to be called when a cell is hovered.
 * - getRowThemeOverride: The glide-data-grid compatible callback function to be called to
 *   get the theme override for a row.
 */
function useRowHover(gridTheme: CustomGridTheme): RowHoverReturn {
  const [hoverRow, setHoverRow] = React.useState<number | undefined>(undefined)

  const onItemHovered = React.useCallback(
    (args: GridMouseEventArgs) => {
      if (args.kind !== "cell") {
        // Clear row hovering state if the event indicates that
        // the mouse is not anymore hovering a cell
        setHoverRow(undefined)
      } else {
        const [, row] = args.location
        setHoverRow(row)
      }
    },
    [setHoverRow]
  )

  const getRowThemeOverride = React.useCallback<GetRowThemeCallback>(
    row => {
      if (row !== hoverRow) {
        return undefined
      }
      return {
        bgCell: gridTheme.bgRowHovered,
        bgCellMedium: gridTheme.bgRowHovered,
      }
    },
    [gridTheme.bgRowHovered, hoverRow]
  )

  return { getRowThemeOverride, onItemHovered }
}

export default useRowHover


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useSelectionHandler.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { CompactSelection } from "@glideapps/glide-data-grid"
import { act, renderHook } from "@testing-library/react-hooks"

import { TextColumn } from "@streamlit/lib/src/components/widgets/DataFrame/columns"
import { Arrow as ArrowProto } from "@streamlit/lib/src/proto"

import useSelectionHandler from "./useSelectionHandler"

const syncSelectionStateMock = vi.fn()

describe("useSelectionHandler hook", () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it("detects single row selection", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [ArrowProto.SelectionMode.SINGLE_ROW],
        }),
        false,
        false,
        [],
        syncSelectionStateMock
      )
    )

    expect(result.current.isRowSelectionActivated).toEqual(true)
    expect(result.current.isMultiRowSelectionActivated).toEqual(false)

    expect(result.current.isColumnSelectionActivated).toEqual(false)
    expect(result.current.isMultiColumnSelectionActivated).toEqual(false)
  })

  it("detects multi row selection", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [ArrowProto.SelectionMode.MULTI_ROW],
        }),
        false,
        false,
        [],
        syncSelectionStateMock
      )
    )

    expect(result.current.isRowSelectionActivated).toEqual(true)
    expect(result.current.isMultiRowSelectionActivated).toEqual(true)

    expect(result.current.isColumnSelectionActivated).toEqual(false)
    expect(result.current.isMultiColumnSelectionActivated).toEqual(false)
  })

  it("detects single column selection", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [ArrowProto.SelectionMode.SINGLE_COLUMN],
        }),
        false,
        false,
        [],
        syncSelectionStateMock
      )
    )

    expect(result.current.isRowSelectionActivated).toEqual(false)
    expect(result.current.isMultiRowSelectionActivated).toEqual(false)

    expect(result.current.isColumnSelectionActivated).toEqual(true)
    expect(result.current.isMultiColumnSelectionActivated).toEqual(false)
  })
  it("detects multi column selection", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [ArrowProto.SelectionMode.MULTI_COLUMN],
        }),
        false,
        false,
        [],
        syncSelectionStateMock
      )
    )

    expect(result.current.isRowSelectionActivated).toEqual(false)
    expect(result.current.isMultiRowSelectionActivated).toEqual(false)

    expect(result.current.isColumnSelectionActivated).toEqual(true)
    expect(result.current.isMultiColumnSelectionActivated).toEqual(true)
  })
  it("detects mixed multi selection", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [
            ArrowProto.SelectionMode.MULTI_ROW,
            ArrowProto.SelectionMode.MULTI_COLUMN,
          ],
        }),
        false,
        false,
        [],
        syncSelectionStateMock
      )
    )

    expect(result.current.isRowSelectionActivated).toEqual(true)
    expect(result.current.isMultiRowSelectionActivated).toEqual(true)

    expect(result.current.isColumnSelectionActivated).toEqual(true)
    expect(result.current.isMultiColumnSelectionActivated).toEqual(true)
  })
  it("disables all selections if empty table", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [
            ArrowProto.SelectionMode.MULTI_ROW,
            ArrowProto.SelectionMode.MULTI_COLUMN,
          ],
        }),
        true,
        false,
        [],
        syncSelectionStateMock
      )
    )

    expect(result.current.isRowSelectionActivated).toEqual(false)
    expect(result.current.isMultiRowSelectionActivated).toEqual(false)

    expect(result.current.isColumnSelectionActivated).toEqual(false)
    expect(result.current.isMultiColumnSelectionActivated).toEqual(false)
  })
  it("correctly processes and clears column selection", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [
            ArrowProto.SelectionMode.MULTI_ROW,
            ArrowProto.SelectionMode.MULTI_COLUMN,
          ],
        }),
        false,
        false,
        [],
        syncSelectionStateMock
      )
    )

    expect(result.current.isRowSelectionActivated).toEqual(true)
    expect(result.current.isMultiRowSelectionActivated).toEqual(true)
    expect(result.current.isColumnSelectionActivated).toEqual(true)
    expect(result.current.isMultiColumnSelectionActivated).toEqual(true)

    // Process a new selection with a single column selected:
    const newGridSelection = {
      columns: CompactSelection.fromSingleSelection(0),
      rows: CompactSelection.empty(),
      current: undefined,
    }

    act(() => {
      const { processSelectionChange } = result.current
      processSelectionChange?.(newGridSelection)
    })

    // Check that it detects a column to be selected:
    expect(result.current.isColumnSelected).toEqual(true)

    expect(result.current.isRowSelected).toEqual(false)
    expect(result.current.isCellSelected).toEqual(false)

    expect(result.current.gridSelection).toEqual(newGridSelection)

    expect(syncSelectionStateMock).toBeCalledTimes(1)

    // Check that the selection can also be cleared again:
    act(() => {
      const { clearSelection } = result.current
      clearSelection?.()
    })

    // Check that it clears the selection:
    expect(result.current.isRowSelected).toEqual(false)
    expect(result.current.isColumnSelected).toEqual(false)
    expect(result.current.isCellSelected).toEqual(false)

    expect(syncSelectionStateMock).toBeCalledTimes(2)
  })
  it("correctly processes and clears row selection", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [
            ArrowProto.SelectionMode.MULTI_ROW,
            ArrowProto.SelectionMode.MULTI_COLUMN,
          ],
        }),
        false,
        false,
        [],
        syncSelectionStateMock
      )
    )

    expect(result.current.isRowSelectionActivated).toEqual(true)
    expect(result.current.isMultiRowSelectionActivated).toEqual(true)
    expect(result.current.isColumnSelectionActivated).toEqual(true)
    expect(result.current.isMultiColumnSelectionActivated).toEqual(true)

    // Process a new selection with a single row selected:
    const newGridSelection = {
      columns: CompactSelection.empty(),
      rows: CompactSelection.fromSingleSelection(0),
      current: undefined,
    }
    act(() => {
      const { processSelectionChange } = result.current
      processSelectionChange?.(newGridSelection)
    })

    // Check that it detects a row to be selected:
    expect(result.current.isRowSelected).toEqual(true)

    expect(result.current.isColumnSelected).toEqual(false)
    expect(result.current.isCellSelected).toEqual(false)

    expect(result.current.gridSelection).toEqual(newGridSelection)

    expect(syncSelectionStateMock).toBeCalledTimes(1)

    // Check that the selection can also be cleared again:
    act(() => {
      const { clearSelection } = result.current
      clearSelection?.()
    })

    // Check that it clears the selection:
    expect(result.current.isRowSelected).toEqual(false)
    expect(result.current.isColumnSelected).toEqual(false)
    expect(result.current.isCellSelected).toEqual(false)

    expect(syncSelectionStateMock).toBeCalledTimes(2)
  })
  it("correctly processes and clears row+column selection", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [
            ArrowProto.SelectionMode.MULTI_ROW,
            ArrowProto.SelectionMode.MULTI_COLUMN,
          ],
        }),
        false,
        false,
        [],
        syncSelectionStateMock
      )
    )

    expect(result.current.isRowSelectionActivated).toEqual(true)
    expect(result.current.isMultiRowSelectionActivated).toEqual(true)
    expect(result.current.isColumnSelectionActivated).toEqual(true)
    expect(result.current.isMultiColumnSelectionActivated).toEqual(true)

    const newGridSelection = {
      columns: CompactSelection.fromSingleSelection(0),
      rows: CompactSelection.fromSingleSelection(0),
      current: undefined,
    }

    // Process a new selection with a row and column:
    act(() => {
      const { processSelectionChange } = result.current
      processSelectionChange?.(newGridSelection)
    })

    // Check that it detects a row+column to be selected:
    expect(result.current.isRowSelected).toEqual(true)
    expect(result.current.isColumnSelected).toEqual(true)

    expect(result.current.isCellSelected).toEqual(false)

    expect(result.current.gridSelection).toEqual(newGridSelection)

    expect(syncSelectionStateMock).toBeCalledTimes(1)

    // Check that the clear cell selections doesn't clear the row+column selection:
    act(() => {
      const { clearSelection } = result.current
      // Keep column & row selections:
      clearSelection?.(true, true)
    })
    expect(result.current.isRowSelected).toEqual(true)
    expect(result.current.isColumnSelected).toEqual(true)
    expect(result.current.isCellSelected).toEqual(false)
    // This should not call syncSelectionState callback:
    expect(syncSelectionStateMock).toBeCalledTimes(1)

    // Check that the selection can also be cleared again:
    act(() => {
      const { clearSelection } = result.current
      clearSelection?.()
    })

    // Check that it clears the selection:
    expect(result.current.isRowSelected).toEqual(false)
    expect(result.current.isColumnSelected).toEqual(false)
    expect(result.current.isCellSelected).toEqual(false)

    expect(syncSelectionStateMock).toBeCalledTimes(2)
  })

  it("correctly processes and clears cell selection", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [
            ArrowProto.SelectionMode.MULTI_ROW,
            ArrowProto.SelectionMode.MULTI_COLUMN,
          ],
        }),
        false,
        false,
        [],
        syncSelectionStateMock
      )
    )

    const newGridSelection = {
      columns: CompactSelection.empty(),
      rows: CompactSelection.empty(),
      current: {
        cell: [0, 0],
      },
    }
    // Process a new cell selection:
    act(() => {
      const { processSelectionChange } = result.current
      // @ts-expect-error
      processSelectionChange?.(newGridSelection)
    })

    // Check that it detects a row+column to be selected:
    expect(result.current.isCellSelected).toEqual(true)

    expect(result.current.isRowSelected).toEqual(false)
    expect(result.current.isColumnSelected).toEqual(false)

    expect(result.current.gridSelection).toEqual(newGridSelection)

    expect(syncSelectionStateMock).not.toBeCalled()

    // Check that the clear cell selections doesn't clear the row+column selection:
    act(() => {
      const { clearSelection } = result.current
      clearSelection?.(true, true)
    })
    expect(result.current.isRowSelected).toEqual(false)
    expect(result.current.isColumnSelected).toEqual(false)
    expect(result.current.isCellSelected).toEqual(false)
    // This should not call syncSelectionState callback:
    expect(syncSelectionStateMock).not.toBeCalled()
  })
  it("keeps row & column selection on cell selection changes", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [
            ArrowProto.SelectionMode.MULTI_ROW,
            ArrowProto.SelectionMode.MULTI_COLUMN,
          ],
        }),
        false,
        false,
        [],
        syncSelectionStateMock
      )
    )

    // Select a row+column:
    const firstGridSelection = {
      columns: CompactSelection.fromSingleSelection(0),
      rows: CompactSelection.fromSingleSelection(0),
      cell: undefined,
    }
    act(() => {
      const { processSelectionChange } = result.current
      processSelectionChange?.(firstGridSelection)
    })

    // Check that it detects a row+column to be selected:
    expect(result.current.isCellSelected).toEqual(false)
    expect(result.current.isRowSelected).toEqual(true)
    expect(result.current.isColumnSelected).toEqual(true)

    expect(syncSelectionStateMock).toBeCalledTimes(1)

    const secondGridSelection = {
      columns: CompactSelection.empty(),
      rows: CompactSelection.empty(),
      current: {
        cell: [0, 0],
      },
    }
    // Select a cell:
    act(() => {
      const { processSelectionChange } = result.current
      // @ts-expect-error
      processSelectionChange?.(secondGridSelection)
    })

    // Row+column selection should be kept:
    expect(result.current.isCellSelected).toEqual(true)
    expect(result.current.isRowSelected).toEqual(true)
    expect(result.current.isColumnSelected).toEqual(true)

    // This should not call syncSelectionState callback:
    expect(syncSelectionStateMock).toBeCalledTimes(1)
  })
  it("keeps row selection on column selection changes", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [
            ArrowProto.SelectionMode.MULTI_ROW,
            ArrowProto.SelectionMode.MULTI_COLUMN,
          ],
        }),
        false,
        false,
        [],
        syncSelectionStateMock
      )
    )

    // Select only a row:
    const firstGridSelection = {
      columns: CompactSelection.empty(),
      rows: CompactSelection.fromSingleSelection(0),
      cell: undefined,
    }
    act(() => {
      const { processSelectionChange } = result.current
      processSelectionChange?.(firstGridSelection)
    })

    // Only a row should be selected:
    expect(result.current.isCellSelected).toEqual(false)
    expect(result.current.isRowSelected).toEqual(true)
    expect(result.current.isColumnSelected).toEqual(false)

    expect(syncSelectionStateMock).toBeCalledTimes(1)

    const secondGridSelection = {
      columns: CompactSelection.fromSingleSelection(0),
      rows: CompactSelection.empty(),
      cell: undefined,
    }
    // Select a column
    act(() => {
      const { processSelectionChange } = result.current
      processSelectionChange?.(secondGridSelection)
    })

    // Row selection is kept in addition to the new column selection:
    expect(result.current.isRowSelected).toEqual(true)
    expect(result.current.isColumnSelected).toEqual(true)
    expect(result.current.isCellSelected).toEqual(false)

    expect(syncSelectionStateMock).toBeCalledTimes(2)
  })
  it("keeps column selection on row selection changes", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [
            ArrowProto.SelectionMode.MULTI_ROW,
            ArrowProto.SelectionMode.MULTI_COLUMN,
          ],
        }),
        false,
        false,
        [],
        syncSelectionStateMock
      )
    )

    // Select only a column:
    const firstGridSelection = {
      columns: CompactSelection.fromSingleSelection(0),
      rows: CompactSelection.empty(),
      cell: undefined,
    }
    act(() => {
      const { processSelectionChange } = result.current
      processSelectionChange?.(firstGridSelection)
    })

    // Only a column should be selected:
    expect(result.current.isCellSelected).toEqual(false)
    expect(result.current.isRowSelected).toEqual(false)
    expect(result.current.isColumnSelected).toEqual(true)
    expect(syncSelectionStateMock).toBeCalledTimes(1)

    // Select a row:
    const secondGridSelection = {
      columns: CompactSelection.empty(),
      rows: CompactSelection.fromSingleSelection(0),
      cell: undefined,
    }
    act(() => {
      const { processSelectionChange } = result.current
      processSelectionChange?.(secondGridSelection)
    })

    // Column selection is kept in addition to the new row selection:
    expect(result.current.isRowSelected).toEqual(true)
    expect(result.current.isColumnSelected).toEqual(true)
    expect(result.current.isCellSelected).toEqual(false)
    expect(syncSelectionStateMock).toBeCalledTimes(2)
  })

  it("ignores index column selection", () => {
    const { result } = renderHook(() =>
      useSelectionHandler(
        ArrowProto.create({
          selectionMode: [
            ArrowProto.SelectionMode.MULTI_ROW,
            ArrowProto.SelectionMode.MULTI_COLUMN,
          ],
        }),
        false,
        false,
        [
          // Configure 1 index column
          TextColumn({
            arrowType: {
              meta: null,
              numpy_type: "object",
              pandas_type: "unicode",
            },
            id: "index-0",
            name: "",
            indexNumber: 0,
            isEditable: true,
            isHidden: false,
            isIndex: true,
            isPinned: false,
            isStretched: false,
            title: "",
          }),
        ],
        syncSelectionStateMock
      )
    )

    // Select the index column:
    const firstGridSelection = {
      columns: CompactSelection.fromSingleSelection(0),
      rows: CompactSelection.empty(),
      cell: undefined,
    }
    act(() => {
      const { processSelectionChange } = result.current
      processSelectionChange?.(firstGridSelection)
    })

    // Nothing should have been selected since the index column is ignored:
    expect(result.current.isCellSelected).toEqual(false)
    expect(result.current.isRowSelected).toEqual(false)
    expect(result.current.isColumnSelected).toEqual(false)
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useSelectionHandler.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { CompactSelection, GridSelection } from "@glideapps/glide-data-grid"
import isEqual from "lodash/isEqual"

import { BaseColumn } from "@streamlit/lib/src/components/widgets/DataFrame/columns"
import { Arrow as ArrowProto } from "@streamlit/lib/src/proto"

export type SelectionHandlerReturn = {
  // The current selection state
  gridSelection: GridSelection
  // True, if row selection is activated
  isRowSelectionActivated: boolean
  // True, if multi row selection is activated
  isMultiRowSelectionActivated: boolean
  // True, if column selection is activated
  isColumnSelectionActivated: boolean
  // True, if multi column selections is activated
  isMultiColumnSelectionActivated: boolean
  // True, if at least one row is selected
  isRowSelected: boolean
  // True, if at least one column is selected
  isColumnSelected: boolean
  // True, if at least one cell is selected
  isCellSelected: boolean
  // Callback to clear selections
  clearSelection: (keepRows?: boolean, keepColumns?: boolean) => void
  // Callback to process selection changes from the grid
  processSelectionChange: (newSelection: GridSelection) => void
}

/**
 * Custom hook that handles all selection capabilities for the interactive data table.
 *
 * @param element - The Arrow proto message
 * @param isEmptyTable - Whether the table is empty
 * @param isDisabled - Whether the table is disabled
 * @param columns - The columns of the table.
 * @param syncSelectionState - The callback to sync the selection state
 *
 * @returns the selection handler return object
 */
function useSelectionHandler(
  element: ArrowProto,
  isEmptyTable: boolean,
  isDisabled: boolean,
  columns: BaseColumn[],
  syncSelectionState: (newSelection: GridSelection) => void
): SelectionHandlerReturn {
  const [gridSelection, setGridSelection] = React.useState<GridSelection>({
    columns: CompactSelection.empty(),
    rows: CompactSelection.empty(),
    current: undefined,
  })

  const isRowSelectionActivated =
    !isEmptyTable &&
    !isDisabled &&
    (element.selectionMode.includes(ArrowProto.SelectionMode.MULTI_ROW) ||
      element.selectionMode.includes(ArrowProto.SelectionMode.SINGLE_ROW))
  const isMultiRowSelectionActivated =
    isRowSelectionActivated &&
    element.selectionMode.includes(ArrowProto.SelectionMode.MULTI_ROW)

  const isColumnSelectionActivated =
    !isEmptyTable &&
    !isDisabled &&
    (element.selectionMode.includes(ArrowProto.SelectionMode.SINGLE_COLUMN) ||
      element.selectionMode.includes(ArrowProto.SelectionMode.MULTI_COLUMN))
  const isMultiColumnSelectionActivated =
    isColumnSelectionActivated &&
    element.selectionMode.includes(ArrowProto.SelectionMode.MULTI_COLUMN)

  const isRowSelected = gridSelection.rows.length > 0
  const isColumnSelected = gridSelection.columns.length > 0
  const isCellSelected = gridSelection.current !== undefined

  /**
   * This callback is used to process selection changes and - if activated -
   * trigger a sync of the state with the widget state
   */
  const processSelectionChange = React.useCallback(
    (newSelection: GridSelection) => {
      const rowSelectionChanged = !isEqual(
        newSelection.rows.toArray(),
        gridSelection.rows.toArray()
      )

      const columnSelectionChanged = !isEqual(
        newSelection.columns.toArray(),
        gridSelection.columns.toArray()
      )

      const cellSelectionChanged = !isEqual(
        newSelection.current,
        gridSelection.current
      )

      // A flag to determine if the selection should be synced with the widget state
      let syncSelection =
        (isRowSelectionActivated && rowSelectionChanged) ||
        (isColumnSelectionActivated && columnSelectionChanged)

      let updatedSelection = newSelection
      if (
        (isRowSelectionActivated || isColumnSelectionActivated) &&
        newSelection.current !== undefined &&
        cellSelectionChanged
      ) {
        // The default behavior is that row selections are cleared when a cell is selected.
        // This is not desired when row selection is activated. Instead, we want to keep the
        // row selection and only update the cell selection.
        updatedSelection = {
          ...newSelection,
          rows: gridSelection.rows,
          columns: gridSelection.columns,
        }
        // It should not sync the selection
        // when only the cell selection changes
        syncSelection = false
      }

      if (
        rowSelectionChanged &&
        newSelection.rows.length > 0 &&
        columnSelectionChanged &&
        newSelection.columns.length === 0
      ) {
        // Keep the column selection if row selection was changed
        updatedSelection = {
          ...updatedSelection,
          columns: gridSelection.columns,
        }
        syncSelection = true
      }
      if (
        columnSelectionChanged &&
        newSelection.columns.length > 0 &&
        rowSelectionChanged &&
        newSelection.rows.length === 0
      ) {
        // Keep the row selection if column selection was changed
        updatedSelection = {
          ...updatedSelection,
          rows: gridSelection.rows,
        }

        syncSelection = true
      }

      if (columnSelectionChanged && updatedSelection.columns.length >= 0) {
        // Remove all index columns from the column selection
        // We don't want to allow selection of index columns.
        let cleanedColumns = updatedSelection.columns
        columns.forEach((column, idx) => {
          if (column.isIndex) {
            cleanedColumns = cleanedColumns.remove(idx)
          }
        })
        if (cleanedColumns.length < updatedSelection.columns.length) {
          updatedSelection = {
            ...updatedSelection,
            columns: cleanedColumns,
          }
        }
      }

      setGridSelection(updatedSelection)

      if (syncSelection) {
        syncSelectionState(updatedSelection)
      }
    },
    [
      gridSelection,
      isRowSelectionActivated,
      isColumnSelectionActivated,
      syncSelectionState,
      columns,
    ]
  )

  /**
   * This callback is used to selections (row/column/cell)
   * and sync the state with the widget state if column or row selections
   * are activated and the selection has changed.
   *
   * @param keepRows - Whether to keep the row selection (default: false)
   * @param keepColumns - Whether to keep the column selection (default: false)
   */
  const clearSelection = React.useCallback(
    (keepRows = false, keepColumns = false) => {
      const emptySelection: GridSelection = {
        columns: keepColumns
          ? gridSelection.columns
          : CompactSelection.empty(),
        rows: keepRows ? gridSelection.rows : CompactSelection.empty(),
        current: undefined,
      }
      setGridSelection(emptySelection)
      if (
        (!keepRows && isRowSelectionActivated) ||
        (!keepColumns && isColumnSelectionActivated)
      ) {
        syncSelectionState(emptySelection)
      }
    },
    [
      gridSelection,
      isRowSelectionActivated,
      isColumnSelectionActivated,
      syncSelectionState,
    ]
  )

  return {
    gridSelection,
    isRowSelectionActivated,
    isMultiRowSelectionActivated,
    isColumnSelectionActivated,
    isMultiColumnSelectionActivated,
    isRowSelected,
    isColumnSelected,
    isCellSelected,
    clearSelection,
    processSelectionChange,
  }
}

export default useSelectionHandler


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useTableSizer.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { act, renderHook } from "@testing-library/react-hooks"

import { TEN_BY_TEN, UNICODE, VERY_TALL } from "@streamlit/lib/src/mocks/arrow"
import { Arrow as ArrowProto } from "@streamlit/lib/src/proto"

import { CustomGridTheme } from "./useCustomTheme"
import useTableSizer from "./useTableSizer"

const mockTheme = {
  tableBorderWidth: 1,
  defaultTableHeight: 400,
  minColumnWidth: 50,
  maxColumnWidth: 1000,
  maxColumnAutoWidth: 500,
  defaultRowHeight: 35,
  defaultHeaderHeight: 35,
} as CustomGridTheme

describe("useTableSizer hook", () => {
  it("applies the configured width", () => {
    // The width of the surrounding containers
    const CONTAINER_WIDTH = 700
    const TABLE_WIDTH = 350
    const { result } = renderHook(() =>
      useTableSizer(
        ArrowProto.create({
          data: TEN_BY_TEN,
          useContainerWidth: false,
          width: TABLE_WIDTH,
        }),
        mockTheme,
        10,
        false,
        CONTAINER_WIDTH
      )
    )

    expect(result.current.resizableSize.width).toEqual(TABLE_WIDTH)
    expect(result.current.maxWidth).toEqual(CONTAINER_WIDTH)
  })

  it("Uses the minimum table width if container width is -1", () => {
    // The width of the surrounding containers can be -1 in some edge cases
    // caused by the resize observer in the Block component.
    // We test that the dataframe component correctly handles this case
    // by falling back to the minimum table width instead.
    // Related to: https://github.com/streamlit/streamlit/issues/7949
    const CONTAINER_WIDTH = -1
    const { result } = renderHook(() =>
      useTableSizer(
        ArrowProto.create({
          data: TEN_BY_TEN,
          useContainerWidth: true,
        }),
        mockTheme,
        10,
        false,
        CONTAINER_WIDTH
      )
    )

    const minTableWidth =
      mockTheme.minColumnWidth + 2 * mockTheme.tableBorderWidth

    expect(result.current.resizableSize.width).toEqual(minTableWidth)
    expect(result.current.maxWidth).toEqual(minTableWidth)
    expect(result.current.minWidth).toEqual(minTableWidth)
  })

  it("adapts to the surrounding container width", () => {
    // The width of the surrounding containers
    const CONTAINER_WIDTH = 200
    const TABLE_WIDTH = 350
    const { result } = renderHook(() =>
      useTableSizer(
        ArrowProto.create({
          data: TEN_BY_TEN,
          useContainerWidth: false,
          width: TABLE_WIDTH,
        }),
        mockTheme,
        10,
        false,
        CONTAINER_WIDTH
      )
    )

    expect(result.current.resizableSize.width).toEqual(CONTAINER_WIDTH)
    expect(result.current.maxWidth).toEqual(CONTAINER_WIDTH)
  })

  it("applies the configured height", () => {
    const NUMBER_OF_ROWS = 10
    const TABLE_HEIGHT = 100
    const { result } = renderHook(() =>
      useTableSizer(
        ArrowProto.create({
          data: TEN_BY_TEN,
          useContainerWidth: false,
          height: TABLE_HEIGHT,
        }),
        mockTheme,
        NUMBER_OF_ROWS,
        false,
        700
      )
    )

    expect(result.current.resizableSize.height).toEqual(TABLE_HEIGHT)
    // +1 rows for header row
    expect(result.current.maxHeight).toEqual(
      NUMBER_OF_ROWS * mockTheme.defaultRowHeight +
        mockTheme.defaultHeaderHeight +
        2 * mockTheme.tableBorderWidth
    )
  })

  it("correctly includes group row in height calculation", () => {
    const NUMBER_OF_ROWS = 10
    const TABLE_HEIGHT = 100
    const { result } = renderHook(() =>
      useTableSizer(
        ArrowProto.create({
          data: TEN_BY_TEN,
          useContainerWidth: false,
          height: TABLE_HEIGHT,
        }),
        mockTheme,
        NUMBER_OF_ROWS,
        true,
        700
      )
    )

    expect(result.current.resizableSize.height).toEqual(TABLE_HEIGHT)
    expect(result.current.maxHeight).toEqual(
      NUMBER_OF_ROWS * mockTheme.defaultRowHeight +
        // + header row & group row
        2 * mockTheme.defaultHeaderHeight +
        2 * mockTheme.tableBorderWidth
    )
  })

  it("applies useContainerWidth configuration", () => {
    // The width of the surrounding containers
    const CONTAINER_WIDTH = 700
    const TABLE_WIDTH = 350
    const { result } = renderHook(() =>
      useTableSizer(
        ArrowProto.create({
          data: TEN_BY_TEN,
          useContainerWidth: true,
          width: TABLE_WIDTH,
        }),
        mockTheme,
        10,
        false,
        CONTAINER_WIDTH
      )
    )

    expect(result.current.resizableSize.width).toEqual(CONTAINER_WIDTH)
    expect(result.current.maxWidth).toEqual(CONTAINER_WIDTH)
  })

  it("calculates correct container dimensions for a table", () => {
    // The width of the surrounding containers
    const CONTAINER_WIDTH = 700
    const { result } = renderHook(() =>
      useTableSizer(
        ArrowProto.create({
          data: UNICODE,
          useContainerWidth: false,
        }),
        mockTheme,
        2, // Unicode table has 2 rows
        false,
        CONTAINER_WIDTH
      )
    )

    // This is expected to be 100% to adapt to whatever width the glide data grid calculates
    expect(result.current.resizableSize.width).toEqual("100%")
    expect(result.current.maxWidth).toEqual(CONTAINER_WIDTH)
  })

  it("calculates correct container dimensions for fullscreen mode", () => {
    // The width of the surrounding containers
    const CONTAINER_WIDTH = 1920
    const CONTAINER_HEIGHT = 1080

    const TABLE_WIDTH = 350
    const { result } = renderHook(() =>
      useTableSizer(
        ArrowProto.create({
          data: VERY_TALL,
          useContainerWidth: true,
          width: TABLE_WIDTH,
        }),
        mockTheme,
        100, // VERY_TALL table has 100 rows
        false,
        CONTAINER_WIDTH,
        CONTAINER_HEIGHT,
        true
      )
    )

    expect(result.current.maxWidth).toEqual(CONTAINER_WIDTH)
    expect(result.current.maxHeight).toEqual(CONTAINER_HEIGHT)
    expect(result.current.resizableSize.width).toEqual(CONTAINER_WIDTH)
    expect(result.current.resizableSize.height).toEqual(CONTAINER_HEIGHT)
  })

  it("adapts size on resizing", () => {
    // The width of the surrounding containers
    const CONTAINER_WIDTH = 700
    const TABLE_WIDTH = 350
    const NUMBER_OF_ROWS = 10 // TEN_BY_TEN has 10 rows
    const { result } = renderHook(() =>
      useTableSizer(
        ArrowProto.create({
          data: TEN_BY_TEN,
          useContainerWidth: false,
          width: TABLE_WIDTH,
        }),
        mockTheme,
        NUMBER_OF_ROWS,
        false,
        CONTAINER_WIDTH
      )
    )

    const NEW_WIDTH = 100
    const NEW_HEIGHT = 100

    act(() => {
      const { setResizableSize } = result.current
      setResizableSize?.({
        width: NEW_WIDTH,
        height: NEW_HEIGHT,
      })
    })

    expect(result.current.resizableSize.width).toEqual(NEW_WIDTH)
    expect(result.current.resizableSize.height).toEqual(NEW_HEIGHT)
    expect(result.current.maxWidth).toEqual(CONTAINER_WIDTH)
    expect(result.current.maxHeight).toEqual(
      NUMBER_OF_ROWS * mockTheme.defaultRowHeight +
        mockTheme.defaultHeaderHeight +
        2 * mockTheme.tableBorderWidth
    )
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/hooks/useTableSizer.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// TODO: fix incorrect hook usage and delete this lint suppression
// TODO: Update to match React best practices
// eslint-disable-next-line react-compiler/react-compiler
/* eslint-disable react-hooks/exhaustive-deps */

import React from "react"

import { Size as ResizableSize } from "re-resizable"

import { Arrow as ArrowProto } from "@streamlit/lib/src/proto"
import { notNullOrUndefined } from "@streamlit/lib/src/util/utils"

import { CustomGridTheme } from "./useCustomTheme"

export type AutoSizerReturn = {
  // The minimum height that the data grid can be resized to
  minHeight: number
  // The maximum height of the data grid can be resized to
  maxHeight: number
  // The minimum width of the data grid can be resized to
  minWidth: number
  // The maximum width of the data grid can be resized to
  maxWidth: number
  // The row height of the data grid
  rowHeight: number
  // The current (or initial) size of the data grid
  resizableSize: ResizableSize
  // A callback function to change the size of the data grid.
  setResizableSize: React.Dispatch<React.SetStateAction<ResizableSize>>
}

/**
 * A custom React hook that manages all aspects related to the size of the table.
 *
 * @param element - The ArrowProto element
 * @param numRows - The number of rows in the table
 * @param usesGroupRow - Whether the table uses a group row to display multiple column headers.
 * @param containerWidth - The width of the surrounding container
 * @param containerHeight - The height of the surrounding container
 * @param isFullScreen - Whether the table is in fullscreen mode
 *
 * @returns The row height, min/max height & width, and the current size of the resizable container.
 */
function useTableSizer(
  element: ArrowProto,
  gridTheme: CustomGridTheme,
  numRows: number,
  usesGroupRow: boolean,
  containerWidth: number,
  containerHeight?: number,
  isFullScreen?: boolean
): AutoSizerReturn {
  const rowHeight = gridTheme.defaultRowHeight
  // Min height for the resizable table container:
  // Based on header + one column, and border threshold
  const minHeight =
    gridTheme.defaultHeaderHeight + rowHeight + 2 * gridTheme.tableBorderWidth

  // Group row + column header row
  const numHeaderRows = usesGroupRow ? 2 : 1
  const numTrailingRows =
    element.editingMode === ArrowProto.EditingMode.DYNAMIC ? 1 : 0
  // Calculate the maximum height of the table based on the number of rows:
  const totalDataRows = numRows + numTrailingRows
  let maxHeight = Math.max(
    totalDataRows * rowHeight +
      numHeaderRows * gridTheme.defaultHeaderHeight +
      2 * gridTheme.tableBorderWidth,
    minHeight
  )

  // The initial height is either the default table height or the maximum
  // (full) height based if its smaller than the default table height.
  // The reason why we have initial height is that the table itself is
  // resizable by the user. So, it starts with initial height but can be
  // resized between min and max height.
  let initialHeight = Math.min(maxHeight, gridTheme.defaultTableHeight)

  if (element.height) {
    // User has explicitly configured a height
    initialHeight = Math.max(element.height, minHeight)
    maxHeight = Math.max(element.height, maxHeight)
  }

  if (containerHeight) {
    // If container height is set (e.g. when used in fullscreen)
    // The maxHeight and height should not be larger than container height
    initialHeight = Math.min(initialHeight, containerHeight)
    maxHeight = Math.min(maxHeight, containerHeight)

    if (!element.height) {
      // If no explicit height is set, set height to max height (fullscreen mode)
      initialHeight = maxHeight
    }
  }

  // Min width for the resizable table container:
  // Based on one column at minimum width + borders
  const minWidth = gridTheme.minColumnWidth + 2 * gridTheme.tableBorderWidth
  // The available width should be at least the minimum table width
  // to prevent "maximum update depth exceeded" error. The reason
  // is that the container width can be -1 in some edge cases
  // caused by the resize observer in the Block component.
  // This can trigger the "maximum update depth exceeded" error
  // within the grid component.
  const availableWidth = Math.max(containerWidth, minWidth)

  // The initial width of the data grid.
  // If not set, the data grid will be auto adapted to its content.
  // The reason why we have initial width is that the data grid itself
  // is resizable by the user. It starts with initial width but can be
  // resized between min and max width.
  let initialWidth: number | undefined
  // The maximum width of the data grid can be resized to.
  let maxWidth = availableWidth

  if (element.useContainerWidth) {
    // If user has set use_container_width,
    // use the full container (available) width.
    initialWidth = availableWidth
  } else if (element.width) {
    // The user has explicitly configured a width
    // use it but keep between the MIN_TABLE_WIDTH
    // and the available width.
    initialWidth = Math.min(Math.max(element.width, minWidth), availableWidth)
    // Make sure that the max width we configure is between the user
    // configured width and the available (container) width.
    maxWidth = Math.min(Math.max(element.width, maxWidth), availableWidth)
  }
