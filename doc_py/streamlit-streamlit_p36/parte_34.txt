        self.ctx = ScriptRunContext(
            session_id="test session id",
            _enqueue=ForwardMsgQueue().enqueue,
            query_string="",
            session_state=SafeSessionState(SessionState(), lambda: None),
            uploaded_file_mgr=MemoryUploadedFileManager(""),
            main_script_path="",
            user_info={"email": "something@else.com"},
            fragment_storage=MemoryFragmentStorage(),
            pages_manager=PagesManager(""),
        )
        return super().setUp()

    def test_func_succeeds(self):
        def test_func():
            """Test function that does nothing and, thus, succeeds."""
            return 42

        (
            result,
            run_without_errors,
            rerun_exception_data,
            premature_stop,
            uncaught_exception,
        ) = exec_func_with_error_handling(test_func, self.ctx)

        assert result == 42
        assert run_without_errors is True
        assert rerun_exception_data is None
        assert premature_stop is False
        assert uncaught_exception is None

    def test_func_throws_rerun_exception(self):
        rerun_data = RerunData(query_string="foo")

        def test_func():
            """Test function that raises a RerunException."""
            raise RerunException(rerun_data)

        (
            _,
            run_without_errors,
            rerun_exception_data,
            premature_stop,
            uncaught_exception,
        ) = exec_func_with_error_handling(test_func, self.ctx)

        assert run_without_errors is True
        assert rerun_exception_data == rerun_data
        assert premature_stop is False
        assert uncaught_exception is None

    def test_func_throws_stop_exception(self):
        def test_func():
            """Test function that raises a StopException."""
            raise StopException()

        (
            _,
            run_without_errors,
            rerun_exception_data,
            premature_stop,
            uncaught_exception,
        ) = exec_func_with_error_handling(test_func, self.ctx)

        assert run_without_errors is True
        assert rerun_exception_data is None
        assert premature_stop is True
        assert uncaught_exception is None

    @parameterized.expand([(ValueError), (TypeError), (RuntimeError), (Exception)])
    def test_func_throws_generic_exception(self, exception_type: type):
        def test_func():
            """Test function that raises a generic Exception."""
            raise exception_type()

        (
            _,
            run_without_errors,
            rerun_exception_data,
            premature_stop,
            uncaught_exception,
        ) = exec_func_with_error_handling(test_func, self.ctx)

        assert run_without_errors is False
        assert rerun_exception_data is None
        assert premature_stop is True
        assert isinstance(uncaught_exception, exception_type)


================================================
File: /lib/tests/streamlit/runtime/scriptrunner/magic_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Magic unit test."""

import ast
import sys
import unittest

import streamlit.runtime.scriptrunner.magic as magic
from tests.testutil import patch_config_options


class MagicTest(unittest.TestCase):
    """Test for Magic
    The test counts the number of substitutions that magic.add_code do for
    a few code snippets. The test passes if the expected number of
    substitutions have been made.
    """

    def _testCode(self, code: str, expected_count: int) -> None:
        tree = magic.add_magic(code, "./")
        count = 0
        for node in ast.walk(tree):
            # count the nodes where a substitution has been made, i.e.
            # look for 'calls' to a '__streamlitmagic__' function
            if type(node) is ast.Call and magic.MAGIC_MODULE_NAME in ast.dump(
                node.func
            ):
                count += 1
        self.assertEqual(
            expected_count,
            count,
            f"There must be exactly {expected_count} {magic.MAGIC_MODULE_NAME} nodes, but found {count}",
        )

    def test_simple_statement(self):
        """Test simple statements"""
        CODE_SIMPLE_STATEMENTS = """
a = 1
b = 10
a
b
"""
        self._testCode(CODE_SIMPLE_STATEMENTS, 2)

    def test_empty_ast(self):
        """Test empty AST"""
        CODE_EMPTY_AST = ""
        self._testCode(CODE_EMPTY_AST, 0)

    def test_if_statement(self):
        """Test if statements"""
        CODE_IF_STATEMENT = """
a = 1
if True:
    a
    if False:
        a
    elif False:
        a
    else:
        a
else:
    a
"""
        self._testCode(CODE_IF_STATEMENT, 5)

    def test_for_statement(self):
        """Test for statements"""
        CODE_FOR_STATEMENT = """
a = 1
for i in range(10):
    for j in range(2):
        a
    else:
        a
else:
    a

"""
        self._testCode(CODE_FOR_STATEMENT, 3)

    def test_try_statement(self):
        """Test try statements"""
        CODE_TRY_STATEMENT = """
try:
    a = 10
    a
except RuntimeError:
    a
except Exception:
    try:
        a
    except RuntimeError:
        a
    except Exception:
        a
    else:
        a
    finally:
        a
else:
    a
finally:
    a
"""
        self._testCode(CODE_TRY_STATEMENT, 9)

    @unittest.skipIf(
        not sys.version_info >= (3, 11), "Not supported in this Python version"
    )
    def test_try_star_statement(self):
        """Test try statements with except* clauses"""
        CODE_TRY_STAR_STATEMENT = """
try:
    a = 10
    a
except* RuntimeError:
    a
except* Exception:
    try:
        a
    except* RuntimeError:
        a
    except* Exception:
        a
    else:
        a
    finally:
        a
else:
    a
finally:
    a
"""
        self._testCode(CODE_TRY_STAR_STATEMENT, 9)

    @unittest.skipIf(
        not sys.version_info >= (3, 10), "Not supported in this Python version"
    )
    def test_match_statement(self):
        """Test match statements"""
        CODE_MATCH_STATEMENT = """
a = 1
match a:
    case 1:
        a
    case 2:
        a
    case _:
        a
"""
        self._testCode(CODE_MATCH_STATEMENT, 3)

    def test_function_call_statement(self):
        """Test with function calls"""
        CODE_FUNCTION_CALL = """
def myfunc(a):
    a
a =10
myfunc(a)
"""
        self._testCode(CODE_FUNCTION_CALL, 1)

    def test_with_statement(self):
        """Test 'with' statements"""
        CODE_WITH_STATEMENT = """
a = 10
with None:
    a
"""
        self._testCode(CODE_WITH_STATEMENT, 1)

    def test_while_statement(self):
        """Test 'while' statements"""
        CODE_WHILE_STATEMENT = """
a = 10
while True:
    a
    while True:
        a
    else:
        a
else:
    a
"""
        self._testCode(CODE_WHILE_STATEMENT, 4)

    def test_yield_statement(self):
        """Test that 'yield' expressions do not get magicked"""
        CODE_YIELD_STATEMENT = """
def yield_func():
    yield
"""
        self._testCode(CODE_YIELD_STATEMENT, 0)

    def test_yield_from_statement(self):
        """Test that 'yield from' expressions do not get magicked"""
        CODE_YIELD_FROM_STATEMENT = """
def yield_func():
    yield from None
"""
        self._testCode(CODE_YIELD_FROM_STATEMENT, 0)

    def test_await_expression(self):
        """Test that 'await' expressions do not get magicked"""
        CODE_AWAIT_EXPRESSION = """
async def await_func(a):
    await coro()
"""
        self._testCode(CODE_AWAIT_EXPRESSION, 0)

    def test_async_function_statement(self):
        """Test async function definitions"""
        CODE_ASYNC_FUNCTION = """
async def myfunc(a):
    a
"""
        self._testCode(CODE_ASYNC_FUNCTION, 1)

    def test_async_with_statement(self):
        """Test 'async with' statements"""
        CODE_ASYNC_WITH = """
async def myfunc(a):
    async with None:
        a
"""
        self._testCode(CODE_ASYNC_WITH, 1)

    def test_async_for_statement(self):
        """Test 'async for' statements"""
        CODE_ASYNC_FOR = """
async def myfunc(a):
    async for _ in None:
        a
"""
        self._testCode(CODE_ASYNC_FOR, 1)

    def test_docstring_is_ignored_func(self):
        """Test that docstrings don't print in the app"""
        CODE = """
def myfunc(a):
    '''This is the docstring'''
    return 42
"""
        self._testCode(CODE, 0)

    def test_docstring_is_ignored_async_func(self):
        """Test that async function docstrings don't print in the app by default"""
        CODE = """
async def myfunc(a):
    '''This is the docstring for async func'''
    return 43
"""
        self._testCode(CODE, 0)

    def test_display_root_docstring_config_option(self):
        """Test that magic.displayRootDocString skips/includes docstrings when True/False."""

        CODE = """
'''This is a top-level docstring'''

'this is a string that should always be magicked'

def my_func():
    '''This is a function docstring'''

    'this is a string that should always be magicked'

class MyClass:
    '''This is a class docstring'''

    'this is a string that should never be magicked'

    def __init__(self):
        '''This is a method docstring'''

        'this is a string that should always be magicked'
"""

        self._testCode(CODE, 3)

        with patch_config_options({"magic.displayRootDocString": True}):
            self._testCode(CODE, 4)

        with patch_config_options({"magic.displayRootDocString": False}):
            self._testCode(CODE, 3)

    def test_display_last_expr_config_option(self):
        """Test that magic.displayLastExprIfNoSemicolon causes the last function ast.Expr
        node in a file to be wrapped in st.write()."""

        CODE_WITHOUT_SEMICOLON = """
this_should_not_be_magicked()

def my_func():
    this_should_not_be_magicked()

class MyClass:
    this_should_not_be_magicked()

    def __init__(self):
        this_should_not_be_magicked()

this_is_the_last_expr()

# Some newlines for good measure


"""

        self._testCode(CODE_WITHOUT_SEMICOLON, 0)

        with patch_config_options({"magic.displayLastExprIfNoSemicolon": True}):
            self._testCode(CODE_WITHOUT_SEMICOLON, 1)

        with patch_config_options({"magic.displayLastExprIfNoSemicolon": False}):
            self._testCode(CODE_WITHOUT_SEMICOLON, 0)

        CODE_WITH_SEMICOLON = """
this_should_not_be_magicked()

def my_func():
    this_should_not_be_magicked()

class MyClass:
    this_should_not_be_magicked()

    def __init__(self):
        this_should_not_be_magicked()

this_is_the_last_expr();

# Some newlines for good measure


"""

        self._testCode(CODE_WITH_SEMICOLON, 0)

        with patch_config_options({"magic.displayLastExprIfNoSemicolon": True}):
            self._testCode(CODE_WITH_SEMICOLON, 0)

        with patch_config_options({"magic.displayLastExprIfNoSemicolon": False}):
            self._testCode(CODE_WITH_SEMICOLON, 0)


================================================
File: /lib/tests/streamlit/runtime/scriptrunner/script_cache_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os.path
import unittest
from unittest import mock
from unittest.mock import Mock

from streamlit import source_util
from streamlit.runtime.scriptrunner.script_cache import ScriptCache


def _get_script_path(name: str) -> str:
    return os.path.join(os.path.dirname(__file__), "test_data", name)


class ScriptCacheTest(unittest.TestCase):
    def test_load_valid_script(self):
        """`get_bytecode` works as expected."""
        cache = ScriptCache()
        result = cache.get_bytecode(_get_script_path("good_script.py"))
        self.assertIsNotNone(result)
        # Execing the code shouldn't raise an error
        exec(result)

    @mock.patch("streamlit.runtime.scriptrunner.script_cache.open_python_file")
    def test_returns_cached_data(self, mock_open_python_file: Mock):
        """`get_bytecode` caches its results."""
        mock_open_python_file.side_effect = source_util.open_python_file
        cache = ScriptCache()

        # The first time we get a script's bytecode, the script is loaded from disk.
        result = cache.get_bytecode(_get_script_path("good_script.py"))
        self.assertIsNotNone(result)
        mock_open_python_file.assert_called_once()

        # Subsequent calls don't reload the script from disk and return the same object.
        mock_open_python_file.reset_mock()
        self.assertIs(cache.get_bytecode(_get_script_path("good_script.py")), result)
        mock_open_python_file.assert_not_called()

    def test_clear(self):
        """`clear` removes cached entries."""
        cache = ScriptCache()
        cache.get_bytecode(_get_script_path("good_script.py"))
        self.assertEqual(1, len(cache._cache))

        cache.clear()
        self.assertEqual(0, len(cache._cache))

    def test_file_not_found_error(self):
        """An exception is thrown when a script file doesn't exist."""
        cache = ScriptCache()
        with self.assertRaises(FileNotFoundError):
            cache.get_bytecode(_get_script_path("not_a_valid_path.py"))

    def test_syntax_error(self):
        """An exception is thrown when a script has a compile error."""
        cache = ScriptCache()
        with self.assertRaises(SyntaxError):
            cache.get_bytecode(_get_script_path("compile_error.py.txt"))


================================================
File: /lib/tests/streamlit/runtime/scriptrunner/script_runner_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests ScriptRunner functionality"""

from __future__ import annotations

import os
import sys
import time
from typing import TYPE_CHECKING, Any
from unittest.mock import MagicMock, call, patch

import pytest
from parameterized import parameterized
from tornado.testing import AsyncTestCase

from streamlit.delta_generator import DeltaGenerator
from streamlit.delta_generator_singletons import context_dg_stack
from streamlit.elements.exception import _GENERIC_UNCAUGHT_EXCEPTION_TEXT
from streamlit.proto.WidgetStates_pb2 import WidgetState, WidgetStates
from streamlit.runtime import Runtime
from streamlit.runtime.forward_msg_queue import ForwardMsgQueue
from streamlit.runtime.fragment import MemoryFragmentStorage, _fragment
from streamlit.runtime.media_file_manager import MediaFileManager
from streamlit.runtime.memory_media_file_storage import MemoryMediaFileStorage
from streamlit.runtime.memory_uploaded_file_manager import MemoryUploadedFileManager
from streamlit.runtime.pages_manager import PagesManager
from streamlit.runtime.scriptrunner import (
    RerunData,
    RerunException,
    ScriptRunner,
    ScriptRunnerEvent,
    StopException,
)
from streamlit.runtime.scriptrunner.script_cache import ScriptCache
from streamlit.runtime.scriptrunner_utils.script_requests import (
    ScriptRequest,
    ScriptRequests,
    ScriptRequestType,
)
from streamlit.runtime.state.session_state import SessionState
from tests import testutil

if TYPE_CHECKING:
    from streamlit.proto.Delta_pb2 import Delta
    from streamlit.proto.Element_pb2 import Element
    from streamlit.proto.ForwardMsg_pb2 import ForwardMsg

text_utf = "complete! 👨‍🎤"
text_utf2 = "complete2! 👨‍🎤"
text_no_encoding = text_utf
text_latin = "complete! ð\x9f\x91¨â\x80\x8dð\x9f\x8e¤"


def _create_widget(id: str, states: WidgetStates) -> WidgetState:
    """
    Returns
    -------
    streamlit.proto.WidgetStates_pb2.WidgetState

    """
    states.widgets.add().id = id
    return states.widgets[-1]


def _is_control_event(event: ScriptRunnerEvent) -> bool:
    """True if the given ScriptRunnerEvent is a 'control' event, as opposed
    to a 'data' event.
    """
    # There's only one data event type.
    return event != ScriptRunnerEvent.ENQUEUE_FORWARD_MSG


@patch("streamlit.source_util._cached_pages", new=None)
class ScriptRunnerTest(AsyncTestCase):
    def setUp(self) -> None:
        super().setUp()
        mock_runtime = MagicMock(spec=Runtime)
        mock_runtime.media_file_mgr = MediaFileManager(
            MemoryMediaFileStorage("/mock/media")
        )
        mock_runtime.media_file_mgr.clear_session_refs = MagicMock()
        Runtime._instance = mock_runtime

    def tearDown(self) -> None:
        super().tearDown()
        Runtime._instance = None

    def test_startup_shutdown(self):
        """Test that we can create and shut down a ScriptRunner."""
        scriptrunner = TestScriptRunner("good_script.py")

        # Request that the ScriptRunner stop before it even starts, so that
        # it doesn't start the script at all.
        scriptrunner.request_stop()

        scriptrunner.start()
        scriptrunner.join()

        self._assert_no_exceptions(scriptrunner)
        self._assert_control_events(scriptrunner, [ScriptRunnerEvent.SHUTDOWN])
        self._assert_text_deltas(scriptrunner, [])

    def test_yield_on_enqueue(self):
        """Make sure we try to handle execution control requests whenever
        our _enqueue_forward_msg function is called.
        """
        # Create a TestScriptRunner. We won't actually be starting its
        # script thread - instead, we'll manually call _enqueue_forward_msg on it, and
        # pretend we're in the script thread.
        runner = TestScriptRunner("not_a_script.py")
        runner._is_in_script_thread = MagicMock(return_value=True)

        # Mock the call to _maybe_handle_execution_control_request.
        # This is what we're testing gets called or not.
        maybe_handle_execution_control_request_mock = MagicMock()
        runner._maybe_handle_execution_control_request = (
            maybe_handle_execution_control_request_mock
        )

        # Enqueue a ForwardMsg on the runner
        mock_msg = MagicMock()
        runner._enqueue_forward_msg(mock_msg)

        # Ensure the ForwardMsg was delivered to event listeners.
        self._assert_forward_msgs(runner, [mock_msg])

        # maybe_handle_execution_control_request should be called by the
        # enqueue function.
        self.assertEqual(
            1,
            maybe_handle_execution_control_request_mock.call_count,
        )

    def test_dont_enqueue_with_pending_script_request(self):
        """No ForwardMsgs are enqueued when the ScriptRunner has
        a STOP or RERUN request.
        """
        # Create a ScriptRunner and pretend that we've already started
        # executing.
        runner = TestScriptRunner("not_a_script.py")
        runner._is_in_script_thread = MagicMock(return_value=True)
        runner._execing = True
        runner._requests._state = ScriptRequestType.CONTINUE

        # Enqueue a ForwardMsg on the runner, and ensure it's delivered
        # to event listeners. (We're not stopped yet.)
        mock_msg = MagicMock()
        runner._enqueue_forward_msg(mock_msg)
        self._assert_forward_msgs(runner, [mock_msg])

        runner.clear_forward_msgs()

        # Now, "stop" our ScriptRunner. Enqueuing should result in
        # a StopException being raised, and no message enqueued.
        runner._requests.request_stop()
        with self.assertRaises(StopException):
            runner._enqueue_forward_msg(MagicMock())
        self._assert_forward_msgs(runner, [])

        # And finally, request a rerun. Enqueuing should result in
        # a RerunException being raised and no message enqueued.
        runner._requests = ScriptRequests()
        runner.request_rerun(RerunData())
        with self.assertRaises(RerunException):
            runner._enqueue_forward_msg(MagicMock())
        self._assert_forward_msgs(runner, [])

    def test_maybe_handle_execution_control_request(self):
        """maybe_handle_execution_control_request should no-op if called
        from another thread.
        """
        runner = TestScriptRunner("not_a_script.py")
        runner._execing = True

        # Mock ScriptRequests.on_scriptrunner_yield(). It will return a fake
        # rerun request.
        requests_mock = MagicMock()
        requests_mock.on_scriptrunner_yield = MagicMock(
            return_value=ScriptRequest(ScriptRequestType.RERUN, RerunData())
        )
        runner._requests = requests_mock

        # If _is_in_script_thread is False, our request shouldn't get popped
        runner._is_in_script_thread = MagicMock(return_value=False)
        runner._maybe_handle_execution_control_request()
        requests_mock.on_scriptrunner_yield.assert_not_called()

        # If _is_in_script_thread is True, our rerun request should get
        # popped (and this will result in a RerunException being raised).
        runner._is_in_script_thread = MagicMock(return_value=True)
        with self.assertRaises(RerunException):
            runner._maybe_handle_execution_control_request()
        requests_mock.on_scriptrunner_yield.assert_called_once()

    def test_run_script_in_loop(self):
        """_run_script_thread should continue re-running its script
        while it has pending rerun requests."""
        scriptrunner = TestScriptRunner("not_a_script.py")

        # ScriptRequests.on_scriptrunner_ready will return 3 rerun requests,
        # and then stop.
        on_scriptrunner_ready_mock = MagicMock()
        on_scriptrunner_ready_mock.side_effect = [
            ScriptRequest(ScriptRequestType.RERUN, RerunData()),
            ScriptRequest(ScriptRequestType.RERUN, RerunData()),
            ScriptRequest(ScriptRequestType.RERUN, RerunData()),
            ScriptRequest(ScriptRequestType.STOP),
        ]

        scriptrunner._requests.on_scriptrunner_ready = on_scriptrunner_ready_mock

        run_script_mock = MagicMock()
        scriptrunner._run_script = run_script_mock

        scriptrunner.start()
        scriptrunner.join()

        # _run_script should have been called 3 times, once for each
        # RERUN request.
        self._assert_no_exceptions(scriptrunner)
        self.assertEqual(3, run_script_mock.call_count)

    @parameterized.expand(
        [
            ("good_script.py", text_utf),
            # These files are .txt to avoid being broken by "make headers".
            ("good_script_no_encoding.py.txt", text_no_encoding),
            ("good_script_latin_encoding.py.txt", text_latin),
        ]
    )
    def test_run_script(self, filename, text):
        """Tests that we can run a script to completion."""
        scriptrunner = TestScriptRunner(filename)
        scriptrunner._fragment_storage = MagicMock()

        scriptrunner.request_rerun(RerunData())
        scriptrunner.start()
        scriptrunner.join()

        self._assert_no_exceptions(scriptrunner)
        self._assert_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.ENQUEUE_FORWARD_MSG,
                ScriptRunnerEvent.SCRIPT_STOPPED_WITH_SUCCESS,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )
        self._assert_text_deltas(scriptrunner, [text])
        scriptrunner._fragment_storage.clear.assert_called_once()
        # The following check is a requirement for the CodeHasher to
        # work correctly. The CodeHasher is scoped to
        # files contained in the directory of __main__.__file__, which we
        # assume is the main script directory.
        self.assertEqual(
            os.path.realpath(scriptrunner._main_script_path),
            os.path.realpath(sys.modules["__main__"].__file__),
            (" ScriptRunner should set the __main__.__file__" "attribute correctly"),
        )

        Runtime._instance.media_file_mgr.clear_session_refs.assert_called_once()

    def test_run_one_fragment(self):
        """Tests that we can run one fragment."""
        fragment = MagicMock()

        scriptrunner = TestScriptRunner("good_script.py")
        scriptrunner._fragment_storage.set("my_fragment", fragment)

        scriptrunner.request_rerun(RerunData(fragment_id_queue=["my_fragment"]))
        scriptrunner.start()
        scriptrunner.join()

        self._assert_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.FRAGMENT_STOPPED_WITH_SUCCESS,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )
        script_started_event_data = scriptrunner.event_data[0]
        script_started_event_data["fragment_ids_this_run"] = ["my_fragment"]

        fragment.assert_called_once()

    def test_run_multiple_fragments(self):
        """Tests that we can run fragments."""
        fragment = MagicMock()

        scriptrunner = TestScriptRunner("good_script.py")
        scriptrunner._fragment_storage.set("my_fragment1", fragment)
        scriptrunner._fragment_storage.set("my_fragment2", fragment)
        scriptrunner._fragment_storage.set("my_fragment3", fragment)

        scriptrunner.request_rerun(
            RerunData(
                fragment_id_queue=[
                    "my_fragment1",
                    "my_fragment2",
                    "my_fragment3",
                ]
            )
        )
        scriptrunner.start()
        scriptrunner.join()

        self._assert_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.FRAGMENT_STOPPED_WITH_SUCCESS,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )
        script_started_event_data = scriptrunner.event_data[0]
        script_started_event_data["fragment_ids_this_run"] = [
            "my_fragment1",
            "my_fragment2",
            "my_fragment3",
        ]

        fragment.assert_has_calls([call(), call(), call()])
        Runtime._instance.media_file_mgr.clear_session_refs.assert_not_called()

    def test_run_multiple_fragments_even_if_one_raised_an_exception(self):
        """Tests that fragments continue to run when previous fragment raised an error."""
        fragment = MagicMock()
        scriptrunner = TestScriptRunner("good_script.py")

        raised_exception = {"called": False}

        def raise_exception():
            raised_exception["called"] = True
            raise RuntimeError("this fragment errored out")

        scriptrunner._fragment_storage.set("my_fragment1", raise_exception)
        scriptrunner._fragment_storage.set("my_fragment2", fragment)
        scriptrunner._fragment_storage.set("my_fragment3", fragment)

        scriptrunner.request_rerun(
            RerunData(
                fragment_id_queue=[
                    "my_fragment1",
                    "my_fragment2",
                    "my_fragment3",
                ]
            )
        )
        scriptrunner.start()
        scriptrunner.join()
        self._assert_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.FRAGMENT_STOPPED_WITH_SUCCESS,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )

        self.assertTrue(raised_exception["called"])
        fragment.assert_has_calls([call(), call()])
        Runtime._instance.media_file_mgr.clear_session_refs.assert_not_called()

    @patch("streamlit.runtime.scriptrunner.script_runner.get_script_run_ctx")
    @patch("streamlit.runtime.fragment.handle_uncaught_app_exception")
    def test_regular_KeyError_is_rethrown(
        self, patched_handle_exception, patched_get_script_run_ctx
    ):
        """Test that regular key-errors within a fragment are surfaced
        as such and not caught by the FragmentStorageKeyError.
        """

        ctx = MagicMock()
        patched_get_script_run_ctx.return_value = ctx
        ctx.current_fragment_id = "my_fragment_id"

        def non_optional_func():
            raise KeyError("kaboom")

        def fragment():
            _fragment(non_optional_func)()

        scriptrunner = TestScriptRunner("good_script.py")
        scriptrunner._fragment_storage.set("my_fragment", fragment)

        scriptrunner.request_rerun(RerunData(fragment_id_queue=["my_fragment"]))
        scriptrunner.start()
        scriptrunner.join()

        ex = patched_handle_exception.call_args[0][0]
        assert isinstance(ex, KeyError)

    def test_compile_error(self):
        """Tests that we get an exception event when a script can't compile."""
        scriptrunner = TestScriptRunner("compile_error.py.txt")
        scriptrunner.request_rerun(RerunData())
        scriptrunner.start()
        scriptrunner.join()

        self._assert_no_exceptions(scriptrunner)
        self._assert_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.SCRIPT_STOPPED_WITH_COMPILE_ERROR,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )
        self._assert_text_deltas(scriptrunner, [])

    @patch("streamlit.runtime.state.session_state.SessionState._call_callbacks")
    def test_calls_widget_callbacks(self, patched_call_callbacks):
        """Before a script is rerun, we call callbacks for any widgets
        whose value has changed.
        """
        scriptrunner = TestScriptRunner("widgets_script.py")
        scriptrunner.request_rerun(RerunData())
        scriptrunner.start()

        # Default widget values
        require_widgets_deltas([scriptrunner])
        self._assert_text_deltas(
            scriptrunner, ["False", "ahoy!", "0", "False", "loop_forever"]
        )

        patched_call_callbacks.assert_not_called()

        # Update widgets
        states = WidgetStates()
        w1_id = scriptrunner.get_widget_id("checkbox", "checkbox")
        _create_widget(w1_id, states).bool_value = True
        w2_id = scriptrunner.get_widget_id("text_area", "text_area")
        _create_widget(w2_id, states).string_value = "matey!"
        w3_id = scriptrunner.get_widget_id("radio", "radio")
        _create_widget(w3_id, states).int_value = 2
        w4_id = scriptrunner.get_widget_id("button", "button")
        _create_widget(w4_id, states).trigger_value = True

        # Explicitly clear deltas before re-running, to prevent a race
        # condition. (The ScriptRunner will clear the deltas when it
        # starts the re-run, but if that doesn't happen before
        # require_widgets_deltas() starts polling the ScriptRunner's deltas,
        # it will see stale deltas from the last run.)
        scriptrunner.clear_forward_msgs()
        scriptrunner.request_rerun(RerunData(widget_states=states))
        require_widgets_deltas([scriptrunner])

        patched_call_callbacks.assert_called_once()
        self._assert_text_deltas(
            scriptrunner, ["True", "matey!", "2", "True", "loop_forever"]
        )

        scriptrunner.request_stop()
        scriptrunner.join()

    @patch("streamlit.runtime.state.session_state.SessionState._call_callbacks")
    def test_calls_widget_callbacks_on_new_scriptrunner_instance(
        self, patched_call_callbacks
    ):
        """A new ScriptRunner instance will call widget callbacks
        if widget values have changed. (This differs slightly from
        `test_calls_widget_callbacks`, which tests that an *already-running*
        ScriptRunner calls its callbacks on rerun).
        """
        # Create a ScriptRunner and run it once so we can grab its widgets.
        scriptrunner = TestScriptRunner("widgets_script.py")
        scriptrunner.request_rerun(RerunData())
        scriptrunner.start()
        require_widgets_deltas([scriptrunner])
        scriptrunner.request_stop()
        scriptrunner.join()

        patched_call_callbacks.assert_not_called()

        # Set our checkbox's value to True
        states = WidgetStates()
        checkbox_id = scriptrunner.get_widget_id("checkbox", "checkbox")
        _create_widget(checkbox_id, states).bool_value = True

        # Create a *new* ScriptRunner with our new RerunData. Our callbacks
        # should be called this time.
        scriptrunner = TestScriptRunner("widgets_script.py")
        scriptrunner.request_rerun(RerunData(widget_states=states))
        scriptrunner.start()
        require_widgets_deltas([scriptrunner])
        scriptrunner.request_stop()
        scriptrunner.join()

        patched_call_callbacks.assert_called_once()

    @patch("streamlit.elements.exception._exception")
    @patch("streamlit.runtime.state.session_state.SessionState._call_callbacks")
    def test_calls_widget_callbacks_error(
        self, patched_call_callbacks, patched_st_exception
    ):
        """If an exception is raised from a callback function,
        it should result in a call to `streamlit.exception`.
        """
        patched_call_callbacks.side_effect = RuntimeError("Random Error")

        scriptrunner = TestScriptRunner("widgets_script.py")
        scriptrunner.request_rerun(RerunData())
        scriptrunner.start()

        # Default widget values
        require_widgets_deltas([scriptrunner])
        self._assert_text_deltas(
            scriptrunner, ["False", "ahoy!", "0", "False", "loop_forever"]
        )

        patched_call_callbacks.assert_not_called()

        # Update widgets
        states = WidgetStates()
        w1_id = scriptrunner.get_widget_id("checkbox", "checkbox")
        _create_widget(w1_id, states).bool_value = True
        w2_id = scriptrunner.get_widget_id("text_area", "text_area")
        _create_widget(w2_id, states).string_value = "matey!"
        w3_id = scriptrunner.get_widget_id("radio", "radio")
        _create_widget(w3_id, states).int_value = 2
        w4_id = scriptrunner.get_widget_id("button", "button")
        _create_widget(w4_id, states).trigger_value = True

        # Explicitly clear deltas before re-running, to prevent a race
        # condition. (The ScriptRunner will clear the deltas when it
        # starts the re-run, but if that doesn't happen before
        # require_widgets_deltas() starts polling the ScriptRunner's deltas,
        # it will see stale deltas from the last run.)
        scriptrunner.clear_forward_msgs()
        scriptrunner.request_rerun(RerunData(widget_states=states))

        scriptrunner.join()

        patched_call_callbacks.assert_called_once()

        self._assert_control_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.SCRIPT_STOPPED_FOR_RERUN,
                ScriptRunnerEvent.SCRIPT_STARTED,
                # We use the SCRIPT_STOPPED_WITH_SUCCESS event even if the
                # script runs into an error during execution. The user is
                # informed of the error by an `st.exception` box that we check
                # for below.
                ScriptRunnerEvent.SCRIPT_STOPPED_WITH_SUCCESS,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )

        patched_st_exception.assert_called_once()

    def test_missing_script(self):
        """Tests that we get an exception event when a script doesn't exist."""
        scriptrunner = TestScriptRunner("i_do_not_exist.py")
        scriptrunner.request_rerun(RerunData())
        scriptrunner.start()
        scriptrunner.join()

        self._assert_no_exceptions(scriptrunner)
        self._assert_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.SCRIPT_STOPPED_WITH_COMPILE_ERROR,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )
        self._assert_text_deltas(scriptrunner, [])

    @patch("streamlit.runtime.scriptrunner.script_runner.create_page_profile_message")
    def test_uncaught_exception_gets_tracked(self, patched_create_page_profile_message):
        """Tests that we track uncaught exceptions."""
        with testutil.patch_config_options({"browser.gatherUsageStats": True}):
            scriptrunner = TestScriptRunner("runtime_error.py")
            scriptrunner.request_rerun(RerunData())
            scriptrunner.start()
            scriptrunner.join()

            patched_create_page_profile_message.assert_called_once()
            call_kwargs = patched_create_page_profile_message.call_args_list[0].kwargs

            # Check the
            assert len(call_kwargs["commands"]) == 2  # text & exception command
            assert call_kwargs["exec_time"] > 0
            assert call_kwargs["prep_time"] > 0
            assert call_kwargs["uncaught_exception"] == "AttributeError"

    @parameterized.expand([(True,), (False,)])
    def test_runtime_error(self, show_error_details: bool):
        """Tests that we correctly handle scripts with runtime errors."""
        with testutil.patch_config_options(
            {"client.showErrorDetails": show_error_details}
        ):
            scriptrunner = TestScriptRunner("runtime_error.py")
            scriptrunner.request_rerun(RerunData())
            scriptrunner.start()
            scriptrunner.join()

            self._assert_no_exceptions(scriptrunner)
            self._assert_events(
                scriptrunner,
                [
                    ScriptRunnerEvent.SCRIPT_STARTED,
                    ScriptRunnerEvent.ENQUEUE_FORWARD_MSG,  # text delta
                    ScriptRunnerEvent.ENQUEUE_FORWARD_MSG,  # exception delta
                    ScriptRunnerEvent.SCRIPT_STOPPED_WITH_SUCCESS,
                    ScriptRunnerEvent.SHUTDOWN,
                ],
            )

            # We'll get two deltas: one for st.text(), and one for the
            # exception that gets thrown afterwards.
            elts = scriptrunner.elements()
            self.assertEqual(elts[0].WhichOneof("type"), "text")

            if show_error_details:
                self._assert_num_deltas(scriptrunner, 2)
                self.assertEqual(elts[1].WhichOneof("type"), "exception")
            else:
                self._assert_num_deltas(scriptrunner, 2)
                self.assertEqual(elts[1].WhichOneof("type"), "exception")
                exc_msg = elts[1].exception.message
                self.assertTrue(_GENERIC_UNCAUGHT_EXCEPTION_TEXT == exc_msg)

    @pytest.mark.slow
    def test_stop_script(self):
        """Tests that we can stop a script while it's running."""
        scriptrunner = TestScriptRunner("infinite_loop.py")
        scriptrunner.request_rerun(RerunData())
        scriptrunner.start()

        time.sleep(0.1)
        scriptrunner.request_rerun(RerunData())

        # This test will fail if the script runner does not execute the infinite
        # script's write call at least once during the final script run.
        # The script runs forever, and when we enqueue a rerun it forcibly
        # stops execution and runs some cleanup. If we do not wait for the
        # forced GC to finish, the script won't start running before we stop
        # the script runner, so the expected delta is never created.
        time.sleep(1)
        scriptrunner.request_stop()
        scriptrunner.join()

        self._assert_no_exceptions(scriptrunner)

        # We use _assert_control_events, and not _assert_events,
        # because the infinite loop will fire an indeterminate number of
        # ForwardMsg enqueue requests. Those ForwardMsgs will all be ultimately
        # coalesced down to a single message by the ForwardMsgQueue, which is
        # why the "_assert_text_deltas" call, below, just asserts the existence
        # of a single ForwardMsg.
        self._assert_control_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.SCRIPT_STOPPED_FOR_RERUN,
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.SCRIPT_STOPPED_WITH_SUCCESS,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )
        self._assert_text_deltas(scriptrunner, ["loop_forever"])

    def test_shutdown(self):
        """Test that we can shutdown while a script is running."""
        scriptrunner = TestScriptRunner("infinite_loop.py")
        scriptrunner.request_rerun(RerunData())
        scriptrunner.start()

        time.sleep(0.1)
        scriptrunner.request_stop()
        scriptrunner.join()

        self._assert_no_exceptions(scriptrunner)
        self._assert_control_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.SCRIPT_STOPPED_WITH_SUCCESS,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )
        self._assert_text_deltas(scriptrunner, ["loop_forever"])

    def test_widgets(self):
        """Tests that widget values behave as expected."""
        scriptrunner = TestScriptRunner("widgets_script.py")
        try:
            scriptrunner.request_rerun(RerunData())
            scriptrunner.start()

            # Default widget values
            require_widgets_deltas([scriptrunner])
            self._assert_text_deltas(
                scriptrunner, ["False", "ahoy!", "0", "False", "loop_forever"]
            )

            # Update widgets
            states = WidgetStates()
            w1_id = scriptrunner.get_widget_id("checkbox", "checkbox")
            _create_widget(w1_id, states).bool_value = True
            w2_id = scriptrunner.get_widget_id("text_area", "text_area")
            _create_widget(w2_id, states).string_value = "matey!"
            w3_id = scriptrunner.get_widget_id("radio", "radio")
            _create_widget(w3_id, states).int_value = 2
            w4_id = scriptrunner.get_widget_id("button", "button")
            _create_widget(w4_id, states).trigger_value = True

            # Explicitly clear deltas before re-running, to prevent a race
            # condition. (The ScriptRunner will clear the deltas when it
            # starts the re-run, but if that doesn't happen before
            # require_widgets_deltas() starts polling the ScriptRunner's deltas,
            # it will see stale deltas from the last run.)
            scriptrunner.clear_forward_msgs()
            scriptrunner.request_rerun(RerunData(widget_states=states))

            require_widgets_deltas([scriptrunner])
            self._assert_text_deltas(
                scriptrunner, ["True", "matey!", "2", "True", "loop_forever"]
            )

            # Rerun with previous values. The button should be reset;
            # everything else should be the same.
            scriptrunner.clear_forward_msgs()
            scriptrunner.request_rerun(RerunData())

            require_widgets_deltas([scriptrunner])
            self._assert_text_deltas(
                scriptrunner, ["True", "matey!", "2", "False", "loop_forever"]
            )

        finally:
            scriptrunner.request_stop()
            scriptrunner.join()

            self._assert_no_exceptions(scriptrunner)

    @patch(
        "streamlit.source_util.get_pages",
        MagicMock(
            return_value={
                "hash1": {
                    "page_script_hash": "hash1",
                    "script_path": os.path.join(
                        os.path.dirname(__file__), "test_data", "good_script.py"
                    ),
                },
            },
        ),
    )
    def test_query_string_and_page_script_hash_saved(self):
        scriptrunner = TestScriptRunner("good_script.py")
        scriptrunner.request_rerun(
            RerunData(query_string="foo=bar", page_script_hash="hash1")
        )
        scriptrunner.start()
        scriptrunner.join()

        self._assert_no_exceptions(scriptrunner)
        self._assert_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.ENQUEUE_FORWARD_MSG,
                ScriptRunnerEvent.SCRIPT_STOPPED_WITH_SUCCESS,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )

        shutdown_data = scriptrunner.event_data[-1]
        self.assertEqual(shutdown_data["client_state"].query_string, "foo=bar")
        self.assertEqual(shutdown_data["client_state"].page_script_hash, "hash1")

    def test_coalesce_rerun(self):
        """Tests that multiple pending rerun requests get coalesced."""
        scriptrunner = TestScriptRunner("good_script.py")
        scriptrunner.request_rerun(RerunData())
        scriptrunner.request_rerun(RerunData())
        scriptrunner.request_rerun(RerunData())
        scriptrunner.start()
        scriptrunner.join()

        self._assert_no_exceptions(scriptrunner)
        self._assert_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.ENQUEUE_FORWARD_MSG,
                ScriptRunnerEvent.SCRIPT_STOPPED_WITH_SUCCESS,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )
        self._assert_text_deltas(scriptrunner, [text_utf])

    def test_remove_nonexistent_elements(self):
        """Tests that nonexistent elements are removed from widget cache after script run."""

        widget_id = "nonexistent_widget_id"

        # Run script, sending in a WidgetStates containing our fake widget ID.
        scriptrunner = TestScriptRunner("good_script.py")
        states = WidgetStates()
        _create_widget(widget_id, states).string_value = "streamlit"
        scriptrunner.request_rerun(RerunData(widget_states=states))
        scriptrunner.start()

        # At this point, scriptrunner should have finished running, detected
        # that our widget_id wasn't in the list of widgets found this run, and
        # culled it. Ensure widget cache no longer holds our widget ID.
        self.assertRaises(KeyError, lambda: scriptrunner._session_state[widget_id])

    def test_dg_stack_preserved_for_fragment_rerun(self):
        """Tests that the dg_stack and cursor are preserved for a fragment rerun.

        Having a fragment rerun that is interrupted by a RerunException triggered by another fragment run
        simulates what we have seen in the issue where the main app was rendered inside of a dialog when
        two fragment-related reruns were handled in the same ScriptRunner thread.
        """
        scriptrunner = TestScriptRunner("good_script.py")

        # set the dg_stack from the fragment to simulate a populated dg_stack of a real app
        dg_stack_set_by_fragment = (
            DeltaGenerator(),
            DeltaGenerator(),
            DeltaGenerator(),
            DeltaGenerator(),
        )
        scriptrunner._fragment_storage.set(
            "my_fragment1",
            lambda: context_dg_stack.set(dg_stack_set_by_fragment),
        )

        # trigger a run with fragment_id to avoid clearing the fragment_storage in the script runner
        scriptrunner.request_rerun(RerunData(fragment_id_queue=["my_fragment1"]))

        # yielding a rerun request will raise a RerunException in the script runner with the provided RerunData
        on_scriptrunner_yield_mock = MagicMock()
        on_scriptrunner_yield_mock.side_effect = [
            # the original_dg_stack will be set to the dg_stack populated by the first requested_rerun of the fragment
            ScriptRequest(
                ScriptRequestType.RERUN, RerunData(fragment_id_queue=["my_fragment1"])
            ),
            ScriptRequest(ScriptRequestType.STOP),
        ]
        scriptrunner._requests.on_scriptrunner_yield = on_scriptrunner_yield_mock

        scriptrunner.start()
        scriptrunner.join()

        assert len(scriptrunner.get_runner_thread_dg_stack()) == len(
            dg_stack_set_by_fragment
        )
        assert scriptrunner.get_runner_thread_dg_stack() == dg_stack_set_by_fragment

    def test_dg_stack_reset_for_full_app_rerun(self):
        """Tests that the dg_stack and cursor are reset for a full app rerun."""

        scriptrunner = TestScriptRunner("good_script.py")
        # simulate a dg_stack populated by the fragment
        dg_stack_set_by_fragment = (
            DeltaGenerator(),
            DeltaGenerator(),
            DeltaGenerator(),
            DeltaGenerator(),
        )
        scriptrunner._fragment_storage.set(
            "my_fragment1",
            lambda: context_dg_stack.set(dg_stack_set_by_fragment),
        )

        # trigger a run with fragment_id to avoid clearing the fragment_storage in the script runner
        scriptrunner.request_rerun(RerunData(fragment_id_queue=["my_fragment1"]))

        # yielding a rerun request will raise a RerunException in the script runner with the provided RerunData
        on_scriptrunner_yield_mock = MagicMock()
        on_scriptrunner_yield_mock.side_effect = [
            # raise RerunException for full app run
            ScriptRequest(ScriptRequestType.RERUN, RerunData()),
            ScriptRequest(ScriptRequestType.STOP),
        ]
        scriptrunner._requests.on_scriptrunner_yield = on_scriptrunner_yield_mock

        scriptrunner.start()
        scriptrunner.join()

        # for full app run, the dg_stack should have been reset
        assert len(scriptrunner.get_runner_thread_dg_stack()) == 1

    # TODO re-enable after flakiness is fixed
    def off_test_multiple_scriptrunners(self):
        """Tests that multiple scriptrunners can run simultaneously."""
        # This scriptrunner will run before the other 3. It's used to retrieve
        # the widget id before initializing deltas on other runners.
        scriptrunner = TestScriptRunner("widgets_script.py")
        scriptrunner.request_rerun(RerunData())
        scriptrunner.start()

        # Get the widget ID of a radio button and shut down the first runner.
        require_widgets_deltas([scriptrunner])
        radio_widget_id = scriptrunner.get_widget_id("radio", "radio")
        scriptrunner.request_stop()
        scriptrunner.join()
        self._assert_no_exceptions(scriptrunner)

        # Build several runners. Each will set a different int value for
        # its radio button.
        runners = []
        for ii in range(3):
            runner = TestScriptRunner("widgets_script.py")
            runners.append(runner)

            states = WidgetStates()
            _create_widget(radio_widget_id, states).int_value = ii
            runner.request_rerun(RerunData(widget_states=states))

        # Start the runners and wait a beat.
        for runner in runners:
            runner.start()

        require_widgets_deltas(runners)

        # Ensure that each runner's radio value is as expected.
        for ii, runner in enumerate(runners):
            self._assert_text_deltas(
                runner, ["False", "ahoy!", "%s" % ii, "False", "loop_forever"]
            )
            runner.request_stop()

        time.sleep(0.1)

        # Shut 'em all down!
        for runner in runners:
            runner.join()

        for runner in runners:
            self._assert_no_exceptions(runner)
            self._assert_control_events(
                runner,
                [
                    ScriptRunnerEvent.SCRIPT_STARTED,
                    ScriptRunnerEvent.SCRIPT_STOPPED_WITH_SUCCESS,
                    ScriptRunnerEvent.SHUTDOWN,
                ],
            )

    @patch(
        "streamlit.source_util.get_pages",
        MagicMock(
            return_value={
                "hash2": {
                    "page_script_hash": "hash2",
                    "page_name": "good_script2",
                    "script_path": os.path.join(
                        os.path.dirname(__file__), "test_data", "good_script2.py"
                    ),
                },
            },
        ),
    )
    def test_page_script_hash_to_script_path(self):
        scriptrunner = TestScriptRunner("good_script.py")
        scriptrunner.request_rerun(RerunData(page_name="good_script2"))
        scriptrunner.start()
        scriptrunner.join()

        self._assert_no_exceptions(scriptrunner)
        self._assert_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.ENQUEUE_FORWARD_MSG,
                ScriptRunnerEvent.SCRIPT_STOPPED_WITH_SUCCESS,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )
        self._assert_text_deltas(scriptrunner, [text_utf2])
        self.assertEqual(
            os.path.join(os.path.dirname(__file__), "test_data", "good_script2.py"),
            sys.modules["__main__"].__file__,
            (" ScriptRunner should set the __main__.__file__" "attribute correctly"),
        )

        shutdown_data = scriptrunner.event_data[-1]
        self.assertEqual(shutdown_data["client_state"].page_script_hash, "hash2")

    @patch(
        "streamlit.source_util.get_pages",
        MagicMock(
            return_value={
                "hash2": {"page_script_hash": "hash2", "script_path": "script2"},
            }
        ),
    )
    def test_404_hash_not_found(self):
        scriptrunner = TestScriptRunner("good_script.py")
        scriptrunner.request_rerun(RerunData(page_script_hash="hash3"))
        scriptrunner.start()
        scriptrunner.join()

        self._assert_no_exceptions(scriptrunner)
        self._assert_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.ENQUEUE_FORWARD_MSG,  # page not found message
                ScriptRunnerEvent.ENQUEUE_FORWARD_MSG,  # deltas
                ScriptRunnerEvent.SCRIPT_STOPPED_WITH_SUCCESS,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )
        self._assert_text_deltas(scriptrunner, [text_utf])

        page_not_found_msg = scriptrunner.forward_msg_queue._queue[0].page_not_found
        self.assertEqual(page_not_found_msg.page_name, "")

        self.assertEqual(
            scriptrunner._main_script_path,
            sys.modules["__main__"].__file__,
            (" ScriptRunner should set the __main__.__file__" "attribute correctly"),
        )

    @patch(
        "streamlit.source_util.get_pages",
        MagicMock(
            return_value={
                "hash2": {
                    "page_script_hash": "hash2",
                    "script_path": "script2",
                    "page_name": "page2",
                },
            }
        ),
    )
    def test_404_page_name_not_found(self):
        scriptrunner = TestScriptRunner("good_script.py")
        scriptrunner.request_rerun(RerunData(page_name="nonexistent"))
        scriptrunner.start()
        scriptrunner.join()

        self._assert_no_exceptions(scriptrunner)
        self._assert_events(
            scriptrunner,
            [
                ScriptRunnerEvent.SCRIPT_STARTED,
                ScriptRunnerEvent.ENQUEUE_FORWARD_MSG,  # page not found message
                ScriptRunnerEvent.ENQUEUE_FORWARD_MSG,  # deltas
                ScriptRunnerEvent.SCRIPT_STOPPED_WITH_SUCCESS,
                ScriptRunnerEvent.SHUTDOWN,
            ],
        )
        self._assert_text_deltas(scriptrunner, [text_utf])

        page_not_found_msg = scriptrunner.forward_msg_queue._queue[0].page_not_found
        self.assertEqual(page_not_found_msg.page_name, "nonexistent")

        self.assertEqual(
            scriptrunner._main_script_path,
            sys.modules["__main__"].__file__,
            (" ScriptRunner should set the __main__.__file__" "attribute correctly"),
        )

    def _assert_no_exceptions(self, scriptrunner: TestScriptRunner) -> None:
        """Assert that no uncaught exceptions were thrown in the
        scriptrunner's run thread.
        """
        self.assertEqual([], scriptrunner.script_thread_exceptions)

    def _assert_events(
        self, scriptrunner: TestScriptRunner, expected_events: list[ScriptRunnerEvent]
    ) -> None:
        """Assert that the ScriptRunnerEvents emitted by a TestScriptRunner
        are what we expect."""
        self.assertEqual(expected_events, scriptrunner.events)

    def _assert_control_events(
        self, scriptrunner: TestScriptRunner, expected_events: list[ScriptRunnerEvent]
    ) -> None:
        """Assert the non-data ScriptRunnerEvents emitted by a TestScriptRunner
        are what we expect. ("Non-data" refers to all events except
        ENQUEUE_FORWARD_MSG.)
        """
        control_events = [
            event for event in scriptrunner.events if _is_control_event(event)
        ]
        self.assertEqual(expected_events, control_events)

    def _assert_forward_msgs(
        self, scriptrunner: TestScriptRunner, messages: list[ForwardMsg]
    ) -> None:
        """Assert that the ScriptRunner's ForwardMsgQueue contains the
        given list of ForwardMsgs.
        """
        self.assertEqual(messages, scriptrunner.forward_msgs())

    def _assert_num_deltas(
        self, scriptrunner: TestScriptRunner, num_deltas: int
    ) -> None:
        """Assert that the given number of delta ForwardMsgs were enqueued
        during script execution.

        Parameters
        ----------
        scriptrunner : TestScriptRunner
        num_deltas : int

        """
        self.assertEqual(num_deltas, len(scriptrunner.deltas()))

    def _assert_text_deltas(
        self, scriptrunner: TestScriptRunner, text_deltas: list[str]
    ) -> None:
        """Assert that the scriptrunner's ForwardMsgQueue contains text deltas
        with the given contents.
        """
        self.assertEqual(text_deltas, scriptrunner.text_deltas())


class TestScriptRunner(ScriptRunner):
    """Subclasses ScriptRunner to provide some testing features."""

    # PyTest is unable to collect Test classes with __init__,
    # and issues PytestCollectionWarning: cannot collect test class
    # Since class TestScriptRunner is a helper class,
    # there is no need for class TestScriptRunner to be collected by PyTest
    # To prevent PytestCollectionWarning we set __test__ property to False
    __test__ = False

    def __init__(self, script_name: str):
        """Initializes the ScriptRunner for the given script_name"""
        # DeltaGenerator deltas will be enqueued into self.forward_msg_queue.
        self.forward_msg_queue = ForwardMsgQueue()

        main_script_path = os.path.join(
            os.path.dirname(__file__), "test_data", script_name
        )

        super().__init__(
            session_id="test session id",
            main_script_path=main_script_path,
            session_state=SessionState(),
            uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
            script_cache=ScriptCache(),
            initial_rerun_data=RerunData(),
            user_info={"email": "test@example.com"},
            fragment_storage=MemoryFragmentStorage(),
            pages_manager=PagesManager(main_script_path),
        )

        # Accumulates uncaught exceptions thrown by our run thread.
        self.script_thread_exceptions: list[BaseException] = []

        # Accumulates all ScriptRunnerEvents emitted by us.
        self.events: list[ScriptRunnerEvent] = []
        self.event_data: list[Any] = []

        def record_event(
            sender: ScriptRunner | None, event: ScriptRunnerEvent, **kwargs
        ) -> None:
            # Assert that we're not getting unexpected `sender` params
            # from ScriptRunner.on_event
            assert (
                sender is None or sender == self
            ), "Unexpected ScriptRunnerEvent sender!"

            self.events.append(event)
            self.event_data.append(kwargs)

            # Send ENQUEUE_FORWARD_MSGs to our queue
            if event == ScriptRunnerEvent.ENQUEUE_FORWARD_MSG:
                forward_msg = kwargs["forward_msg"]
                self.forward_msg_queue.enqueue(forward_msg)

        self.on_event.connect(record_event, weak=False)

    def _run_script_thread(self) -> None:
        try:
            super()._run_script_thread()
        except BaseException as e:
            self.script_thread_exceptions.append(e)

    def _run_script(self, rerun_data: RerunData) -> None:
        self.clear_forward_msgs()
        super()._run_script(rerun_data)

        # Set the _dg_stack here to the one belonging to the thread context
        self._dg_stack = context_dg_stack.get()

    def join(self) -> None:
        """Join the script_thread if it's running."""
        if self._script_thread is not None:
            self._script_thread.join()

    def clear_forward_msgs(self) -> None:
        """Clear all messages from our ForwardMsgQueue."""
        self.forward_msg_queue.clear()

    def forward_msgs(self) -> list[ForwardMsg]:
        """Return all messages in our ForwardMsgQueue."""
        return self.forward_msg_queue._queue

    def deltas(self) -> list[Delta]:
        """Return the delta messages in our ForwardMsgQueue."""
        return [
            msg.delta for msg in self.forward_msg_queue._queue if msg.HasField("delta")
        ]

    def elements(self) -> list[Element]:
        """Return the delta.new_element messages in our ForwardMsgQueue."""
        return [delta.new_element for delta in self.deltas()]

    def text_deltas(self) -> list[str]:
        """Return the string contents of text deltas in our ForwardMsgQueue"""
        return [
            element.text.body
            for element in self.elements()
            if element.WhichOneof("type") == "text"
        ]

    def get_widget_id(self, widget_type: str, label: str) -> str | None:
        """Returns the id of the widget with the specified type and label"""
        for delta in self.deltas():
            new_element = getattr(delta, "new_element", None)
            widget = getattr(new_element, widget_type, None)
            widget_label = getattr(widget, "label", None)
            if widget_label == label:
                return widget.id
        return None

    def get_runner_thread_dg_stack(self) -> tuple[DeltaGenerator, ...]:
        """The returned stack was set by the ScriptRunner thread and, thus, has its context."""
        return self._dg_stack


def require_widgets_deltas(
    runners: list[TestScriptRunner], timeout: float = 15
) -> None:
    """Wait for the given ScriptRunners to each produce the appropriate
    number of deltas for widgets_script.py before a timeout. If the timeout
    is reached, the runners will all be shutdown and an error will be thrown.
    """
    # widgets_script.py has 8 deltas, then a 1-delta loop. If 9
    # have been emitted, we can proceed with the test..
    NUM_DELTAS = 9

    t0 = time.time()
    num_complete = 0
    while time.time() - t0 < timeout:
        time.sleep(0.1)
        num_complete = sum(
            1 for runner in runners if len(runner.deltas()) >= NUM_DELTAS
        )
        if num_complete == len(runners):
            return

    # If we get here, at least 1 runner hasn't yet completed before our
    # timeout. Create an error string for debugging.
    err_string = f"require_widgets_deltas() timed out after {timeout}s ({num_complete}/{len(runners)} runners complete)"
    for runner in runners:
        if len(runner.deltas()) < NUM_DELTAS:
            err_string += f"\n- incomplete deltas: {runner.text_deltas()}"

    # Shutdown all runners before throwing an error, so that the script
    # doesn't hang forever.
    for runner in runners:
        runner.request_stop()
    for runner in runners:
        runner.join()

    raise RuntimeError(err_string)


================================================
File: /lib/tests/streamlit/runtime/scriptrunner/test_data/compile_error.py.txt
================================================
"""A script that won't compile, for ScriptRunnerTest."""

import streamlit as st

placeholder = st.text('this will never run!')

because i am a compile error! # noqa: E999 pylint:disable=syntax-error


================================================
File: /lib/tests/streamlit/runtime/scriptrunner/test_data/good_script.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A test script for ScriptRunnerTest that enqueues a delta."""

import streamlit as st

st.text("complete! 👨‍🎤")


================================================
File: /lib/tests/streamlit/runtime/scriptrunner/test_data/good_script2.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A test script for ScriptRunnerTest that enqueues a delta."""

import streamlit as st

st.text("complete2! 👨‍🎤")


================================================
File: /lib/tests/streamlit/runtime/scriptrunner/test_data/good_script_latin_encoding.py.txt
================================================
# -*- coding: latin-1 -*-


"""A test script for ScriptRunnerTest that enqueues a delta."""

import streamlit as st

st.text("complete! 👨‍🎤")


================================================
File: /lib/tests/streamlit/runtime/scriptrunner/test_data/good_script_no_encoding.py.txt
================================================
# -*- coding: utf-8 -*-


"""A test script for ScriptRunnerTest that enqueues a delta."""

import streamlit as st

st.text("complete! 👨‍🎤")


================================================
File: /lib/tests/streamlit/runtime/scriptrunner/test_data/infinite_loop.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A script for ScriptRunnerTest that never ends"""

import time

import streamlit as st

element = st.empty()
while True:
    element.text("loop_forever")
    time.sleep(0.01)


================================================
File: /lib/tests/streamlit/runtime/scriptrunner/test_data/runtime_error.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A script that will throw an exception at runtime."""

import streamlit as st

# Create a delta
st.text("first")

# Cause an exception
bad = None
bad.do_a_thing()

# Create another delta (we'll never get here)
st.text("second")


================================================
File: /lib/tests/streamlit/runtime/scriptrunner/test_data/widgets_script.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""A script for ScriptRunnerTest that uses widgets"""

import time

import streamlit as st

# IMPORTANT: ScriptRunner_test.py expects this file to produce 8 deltas + a
# 1-delta loop. If you change this, please change that file too.

checkbox = st.checkbox("checkbox", False)
st.text("%s" % checkbox)

text_area = st.text_area("text_area", "ahoy!")
st.text("%s" % text_area)

radio = st.radio("radio", ("0", "1", "2"), 0)
st.text("%s" % radio)

button = st.button("button")
st.text("%s" % button)

# Loop forever so that our test can check widget states
# without the scriptrunner shutting down.
placeholder = st.text("loop_forever")
while True:
    time.sleep(0.1)
    placeholder.text("loop_forever")


================================================
File: /lib/tests/streamlit/runtime/scriptrunner_utils/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.



================================================
File: /lib/tests/streamlit/runtime/scriptrunner_utils/script_requests_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import unittest

from streamlit.proto.WidgetStates_pb2 import WidgetState, WidgetStates
from streamlit.runtime.scriptrunner_utils.script_requests import (
    RerunData,
    ScriptRequest,
    ScriptRequests,
    ScriptRequestType,
)


def _create_widget(id: str, states: WidgetStates) -> WidgetState:
    """Create a widget with the given ID."""
    states.widgets.add().id = id
    return states.widgets[-1]


def _get_widget(id: str, states: WidgetStates) -> WidgetState | None:
    """Return the widget with the given ID."""
    for state in states.widgets:
        if state.id == id:
            return state
    return None


class ScriptRequestsTest(unittest.TestCase):
    def test_starts_running(self):
        """ScriptRequests starts in the CONTINUE state."""
        reqs = ScriptRequests()
        self.assertEqual(ScriptRequestType.CONTINUE, reqs._state)

    def test_stop(self):
        """A stop request will unconditionally succeed regardless of the
        ScriptRequests' current state.
        """

        for state in ScriptRequestType:
            reqs = ScriptRequests()
            reqs._state = state
            reqs.request_stop()
            self.assertEqual(ScriptRequestType.STOP, reqs._state)

    def test_rerun_while_stopped(self):
        """Requesting a rerun while STOPPED will return False."""
        reqs = ScriptRequests()
        reqs.request_stop()
        success = reqs.request_rerun(RerunData())
        self.assertFalse(success)
        self.assertEqual(ScriptRequestType.STOP, reqs._state)

    def test_rerun_while_running(self):
        """Requesting a rerun while in CONTINUE state will always succeed."""
        reqs = ScriptRequests()
        rerun_data = RerunData(query_string="test_query_string")
        success = reqs.request_rerun(rerun_data)
        self.assertTrue(success)
        self.assertEqual(ScriptRequestType.RERUN, reqs._state)
        self.assertEqual(rerun_data, reqs._rerun_data)

    def test_rerun_coalesce_none_and_none(self):
        """Coalesce two null-WidgetStates rerun requests."""
        reqs = ScriptRequests()

        # Request a rerun with null WidgetStates
        success = reqs.request_rerun(RerunData(widget_states=None))
        self.assertTrue(success)
        self.assertEqual(ScriptRequestType.RERUN, reqs._state)

        # Request another
        reqs.request_rerun(RerunData(widget_states=None))
        self.assertTrue(success)
        self.assertEqual(ScriptRequestType.RERUN, reqs._state)

        # The resulting RerunData should have null widget_states
        self.assertEqual(RerunData(widget_states=None), reqs._rerun_data)

    def test_rerun_coalesce_widgets_and_widgets(self):
        """Coalesce two non-null-WidgetStates rerun requests."""
        reqs = ScriptRequests()

        # Request a rerun with non-null WidgetStates.
        states = WidgetStates()
        _create_widget("trigger", states).trigger_value = True
        _create_widget("int", states).int_value = 123
        success = reqs.request_rerun(RerunData(widget_states=states))
        self.assertTrue(success)

        # Request another rerun. It should get coalesced with the first one.
        states = WidgetStates()
        _create_widget("trigger", states).trigger_value = False
        _create_widget("int", states).int_value = 456

        success = reqs.request_rerun(RerunData(widget_states=states))
        self.assertTrue(success)
        self.assertEqual(ScriptRequestType.RERUN, reqs._state)

        result_states = reqs._rerun_data.widget_states

        # Coalesced triggers should be True if either the old *or*
        # new value was True
        self.assertEqual(True, _get_widget("trigger", result_states).trigger_value)

        # Other widgets should have their newest value
        self.assertEqual(456, _get_widget("int", result_states).int_value)

    def test_rerun_coalesce_widgets_and_none(self):
        """Coalesce a non-null-WidgetStates rerun request with a
        null-WidgetStates request.
        """
        reqs = ScriptRequests()

        # Request a rerun with non-null WidgetStates.
        states = WidgetStates()
        _create_widget("trigger", states).trigger_value = True
        _create_widget("int", states).int_value = 123
        success = reqs.request_rerun(RerunData(widget_states=states))
        self.assertTrue(success)

        # Request a rerun with null WidgetStates.
        success = reqs.request_rerun(RerunData(widget_states=None))
        self.assertTrue(success)

        # The null WidgetStates request will be dropped; our existing
        # request should have the original values.
        result_states = reqs._rerun_data.widget_states
        self.assertEqual(True, _get_widget("trigger", result_states).trigger_value)
        self.assertEqual(123, _get_widget("int", result_states).int_value)

    def test_rerun_coalesce_none_and_widgets(self):
        """Coalesce a null-WidgetStates rerun request with a
        non-null-WidgetStates request.
        """
        reqs = ScriptRequests()

        # Request a rerun with null WidgetStates.
        success = reqs.request_rerun(RerunData(widget_states=None))
        self.assertTrue(success)

        # Request a rerun with non-null WidgetStates.
        states = WidgetStates()
        _create_widget("trigger", states).trigger_value = True
        _create_widget("int", states).int_value = 123
        success = reqs.request_rerun(RerunData(widget_states=states))
        self.assertTrue(success)

        # The null WidgetStates request will be overwritten.
        result_states = reqs._rerun_data.widget_states
        self.assertEqual(True, _get_widget("trigger", result_states).trigger_value)
        self.assertEqual(123, _get_widget("int", result_states).int_value)

    def test_request_rerun_appends_new_fragment_ids_to_queue(self):
        reqs = ScriptRequests()

        reqs.request_rerun(RerunData(fragment_id="my_fragment1"))

        # Sanity check
        self.assertEqual(reqs._rerun_data.fragment_id_queue, ["my_fragment1"])

        reqs.request_rerun(RerunData(fragment_id="my_fragment2"))
        reqs.request_rerun(RerunData(fragment_id="my_fragment3"))
        # Test that duplicate fragment_id isn't appended to queue.
        reqs.request_rerun(RerunData(fragment_id="my_fragment1"))

        self.assertEqual(
            reqs._rerun_data.fragment_id_queue,
            [
                "my_fragment1",
                "my_fragment2",
                "my_fragment3",
            ],
        )

    def test_request_rerun_appends_clears_fragment_queue_on_full_rerun(self):
        reqs = ScriptRequests()
        reqs.request_rerun(
            RerunData(
                fragment_id_queue=[
                    "my_fragment1",
                    "my_fragment2",
                    "my_fragment3",
                ]
            )
        )

        # Sanity check
        self.assertEqual(
            reqs._rerun_data.fragment_id_queue,
            [
                "my_fragment1",
                "my_fragment2",
                "my_fragment3",
            ],
        )

        reqs.request_rerun(RerunData(fragment_id_queue=[]))
        self.assertEqual(reqs._rerun_data.fragment_id_queue, [])

    def test_on_script_yield_with_no_request(self):
        """Return None; remain in the CONTINUE state."""
        reqs = ScriptRequests()
        result = reqs.on_scriptrunner_yield()
        self.assertEqual(None, result)
        self.assertEqual(ScriptRequestType.CONTINUE, reqs._state)

    def test_on_script_yield_with_fragment_rerun_request(self):
        """Return None; remain in the RERUN state."""
        reqs = ScriptRequests()
        reqs.request_rerun(RerunData(fragment_id_queue=["my_fragment_id"]))

        result = reqs.on_scriptrunner_yield()
        self.assertEqual(None, result)
        self.assertEqual(ScriptRequestType.RERUN, reqs._state)
        self.assertEqual(
            reqs._rerun_data, RerunData(fragment_id_queue=["my_fragment_id"])
        )

    def test_on_script_yield_with_is_fragment_scoped_rerun(self):
        """Return RERUN; transition to the CONTINUE state."""
        rerun_data = RerunData(
            fragment_id_queue=["my_fragment_id"], is_fragment_scoped_rerun=True
        )
        reqs = ScriptRequests()
        reqs.request_rerun(rerun_data)

        result = reqs.on_scriptrunner_yield()
        self.assertEqual(ScriptRequest(ScriptRequestType.RERUN, rerun_data), result)
        self.assertEqual(ScriptRequestType.CONTINUE, reqs._state)
        self.assertEqual(
            reqs._rerun_data,
            RerunData(
                fragment_id_queue=["my_fragment_id"], is_fragment_scoped_rerun=True
            ),
        )

    def test_on_script_yield_with_stop_request(self):
        """Return STOP; remain in the STOP state."""
        reqs = ScriptRequests()
        reqs.request_stop()

        result = reqs.on_scriptrunner_yield()
        self.assertEqual(ScriptRequest(ScriptRequestType.STOP), result)
        self.assertEqual(ScriptRequestType.STOP, reqs._state)

    def test_on_script_yield_with_rerun_request(self):
        """Return RERUN; transition to the CONTINUE state."""
        reqs = ScriptRequests()
        reqs.request_rerun(RerunData())

        result = reqs.on_scriptrunner_yield()
        self.assertEqual(ScriptRequest(ScriptRequestType.RERUN, RerunData()), result)
        self.assertEqual(ScriptRequestType.CONTINUE, reqs._state)

    def test_on_script_complete_with_no_request(self):
        """Return STOP; transition to the STOP state."""
        reqs = ScriptRequests()
        result = reqs.on_scriptrunner_ready()
        self.assertEqual(ScriptRequest(ScriptRequestType.STOP), result)
        self.assertEqual(ScriptRequestType.STOP, reqs._state)

    def test_on_script_complete_with_pending_request(self):
        """Return RERUN; transition to the CONTINUE state."""
        reqs = ScriptRequests()
        reqs.request_rerun(RerunData())

        result = reqs.on_scriptrunner_ready()
        self.assertEqual(ScriptRequest(ScriptRequestType.RERUN, RerunData()), result)
        self.assertEqual(ScriptRequestType.CONTINUE, reqs._state)


================================================
File: /lib/tests/streamlit/runtime/scriptrunner_utils/script_run_context_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import threading
import unittest

from parameterized import parameterized

from streamlit.errors import NoSessionContext, StreamlitAPIException
from streamlit.proto.ForwardMsg_pb2 import ForwardMsg
from streamlit.runtime.fragment import MemoryFragmentStorage
from streamlit.runtime.memory_uploaded_file_manager import MemoryUploadedFileManager
from streamlit.runtime.pages_manager import PagesManager
from streamlit.runtime.scriptrunner_utils.script_run_context import (
    SCRIPT_RUN_CONTEXT_ATTR_NAME,
    ScriptRunContext,
    add_script_run_ctx,
    enqueue_message,
)
from streamlit.runtime.state import SafeSessionState, SessionState


class ScriptRunContextTest(unittest.TestCase):
    def setUp(self):
        try:
            # clear context variable as it otherwise would be carried over between tests
            delattr(threading.current_thread(), SCRIPT_RUN_CONTEXT_ATTR_NAME)
        except AttributeError:
            pass

    def test_set_page_config_immutable(self):
        """st.set_page_config must be called at most once"""

        def fake_enqueue(msg):
            return None

        ctx = ScriptRunContext(
            session_id="TestSessionID",
            _enqueue=fake_enqueue,
            query_string="",
            session_state=SafeSessionState(SessionState(), lambda: None),
            uploaded_file_mgr=MemoryUploadedFileManager("mock/upload"),
            main_script_path="",
            user_info={"email": "test@example.com"},
            fragment_storage=MemoryFragmentStorage(),
            pages_manager=PagesManager(""),
        )

        msg = ForwardMsg()
        msg.page_config_changed.title = "foo"

        ctx.enqueue(msg)
        with self.assertRaises(StreamlitAPIException):
            ctx.enqueue(msg)

    def test_set_page_config_first(self):
        """st.set_page_config must be called before other st commands
        when the script has been marked as started"""

        def fake_enqueue(msg):
            return None

        ctx = ScriptRunContext(
            session_id="TestSessionID",
            _enqueue=fake_enqueue,
            query_string="",
            session_state=SafeSessionState(SessionState(), lambda: None),
            uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
            main_script_path="",
            user_info={"email": "test@example.com"},
            fragment_storage=MemoryFragmentStorage(),
            pages_manager=PagesManager(""),
        )

        ctx.on_script_start()

        markdown_msg = ForwardMsg()
        markdown_msg.delta.new_element.markdown.body = "foo"

        msg = ForwardMsg()
        msg.page_config_changed.title = "foo"

        ctx.enqueue(markdown_msg)
        with self.assertRaises(StreamlitAPIException):
            ctx.enqueue(msg)

    def test_disallow_set_page_config_twice(self):
        """st.set_page_config cannot be called twice"""

        def fake_enqueue(msg):
            return None

        ctx = ScriptRunContext(
            session_id="TestSessionID",
            _enqueue=fake_enqueue,
            query_string="",
            session_state=SafeSessionState(SessionState(), lambda: None),
            uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
            main_script_path="",
            user_info={"email": "test@example.com"},
            fragment_storage=MemoryFragmentStorage(),
            pages_manager=PagesManager(""),
        )

        ctx.on_script_start()

        msg = ForwardMsg()
        msg.page_config_changed.title = "foo"
        ctx.enqueue(msg)

        with self.assertRaises(StreamlitAPIException):
            same_msg = ForwardMsg()
            same_msg.page_config_changed.title = "bar"
            ctx.enqueue(same_msg)

    def test_set_page_config_reset(self):
        """st.set_page_config should be allowed after a rerun"""

        def fake_enqueue(msg):
            return None

        ctx = ScriptRunContext(
            session_id="TestSessionID",
            _enqueue=fake_enqueue,
            query_string="",
            session_state=SafeSessionState(SessionState(), lambda: None),
            uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
            main_script_path="",
            user_info={"email": "test@example.com"},
            fragment_storage=MemoryFragmentStorage(),
            pages_manager=PagesManager(""),
        )

        ctx.on_script_start()

        msg = ForwardMsg()
        msg.page_config_changed.title = "foo"

        ctx.enqueue(msg)
        ctx.reset()
        try:
            ctx.on_script_start()
            ctx.enqueue(msg)
        except StreamlitAPIException:
            self.fail("set_page_config should have succeeded after reset!")

    def test_active_script_hash(self):
        """ensures active script hash is set correctly when enqueueing messages"""

        fake_path = "my/custom/script/path"
        pg_mgr = PagesManager(fake_path)

        def fake_enqueue(msg):
            return None

        ctx = ScriptRunContext(
            session_id="TestSessionID",
            _enqueue=fake_enqueue,
            query_string="",
            session_state=SafeSessionState(SessionState(), lambda: None),
            uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
            main_script_path="",
            user_info={"email": "test@example.com"},
            fragment_storage=MemoryFragmentStorage(),
            pages_manager=pg_mgr,
        )
        ctx.reset(page_script_hash="main_script_hash")

        ctx.on_script_start()

        msg = ForwardMsg()
        msg.delta.new_element.markdown.body = "foo"

        ctx.enqueue(msg)
        self.assertEqual(msg.metadata.active_script_hash, ctx.active_script_hash)

        ctx.set_mpa_v2_page("new_hash")

        with ctx.run_with_active_hash("new_hash"):
            new_msg = ForwardMsg()
            new_msg.delta.new_element.markdown.body = "bar"

            ctx.enqueue(new_msg)
            assert new_msg.metadata.active_script_hash == "new_hash"

    @parameterized.expand(
        [
            (True, True, True),  # Both APIs used
            (True, False, False),  # Only experimental API used
            (False, True, False),  # Only final API used
            (False, False, False),  # Neither API used
        ]
    )
    def test_both_query_params_used(
        self, experimental_used, production_used, should_raise
    ):
        def fake_enqueue(msg):
            return None

        ctx = ScriptRunContext(
            session_id="TestSessionID",
            _enqueue=fake_enqueue,
            query_string="",
            session_state=SafeSessionState(SessionState(), lambda: None),
            uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
            main_script_path="",
            user_info={"email": "test@example.com"},
            fragment_storage=MemoryFragmentStorage(),
            pages_manager=PagesManager(""),
        )
        ctx._experimental_query_params_used = experimental_used
        ctx._production_query_params_used = production_used

        if should_raise:
            with self.assertRaises(StreamlitAPIException):
                ctx.ensure_single_query_api_used()
        else:
            ctx.ensure_single_query_api_used()

    def test_mark_experimental_query_params_used_sets_true(self):
        def fake_enqueue(msg):
            return None

        ctx = ScriptRunContext(
            session_id="TestSessionID",
            _enqueue=fake_enqueue,
            query_string="",
            session_state=SafeSessionState(SessionState(), lambda: None),
            uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
            main_script_path="",
            user_info={"email": "test@example.com"},
            fragment_storage=MemoryFragmentStorage(),
            pages_manager=PagesManager(""),
        )
        ctx.mark_experimental_query_params_used()
        assert ctx._experimental_query_params_used is True

    def test_mark_production_query_params_used_sets_true(self):
        def fake_enqueue(msg):
            return None

        ctx = ScriptRunContext(
            session_id="TestSessionID",
            _enqueue=fake_enqueue,
            query_string="",
            session_state=SafeSessionState(SessionState(), lambda: None),
            uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
            main_script_path="",
            user_info={"email": "test@example.com"},
            fragment_storage=MemoryFragmentStorage(),
            pages_manager=PagesManager(""),
        )
        ctx.mark_production_query_params_used()
        assert ctx._production_query_params_used is True

    def test_enqueue_message_raise_if_ctx_is_none(self):
        msg = ForwardMsg()
        msg.delta.new_element.markdown.body = "foo"

        with self.assertRaises(NoSessionContext):
            enqueue_message(msg)

    def test_enqueue_message(self):
        fake_enqueue_result = {}

        def fake_enqueue(msg: ForwardMsg):
            fake_enqueue_result["msg"] = msg

        ctx = ScriptRunContext(
            session_id="TestSessionID",
            _enqueue=fake_enqueue,
            query_string="",
            session_state=SafeSessionState(SessionState(), lambda: None),
            uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
            main_script_path="",
            user_info={"email": "test@example.com"},
            fragment_storage=MemoryFragmentStorage(),
            pages_manager=PagesManager(""),
        )
        add_script_run_ctx(ctx=ctx)
        msg = ForwardMsg()
        msg.delta.new_element.markdown.body = "foo"
        enqueue_message(msg)
        self.assertIsNotNone(fake_enqueue_result)
        self.assertEqual(
            fake_enqueue_result["msg"].delta.new_element.markdown.body,
            msg.delta.new_element.markdown.body,
        )

    def test_enqueue_message_with_fragment_id(self):
        fake_enqueue_result = {}

        def fake_enqueue(msg: ForwardMsg):
            fake_enqueue_result["msg"] = msg

            ctx = ScriptRunContext(
                session_id="TestSessionID",
                _enqueue=fake_enqueue,
                query_string="",
                session_state=SafeSessionState(SessionState(), lambda: None),
                uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
                main_script_path="",
                user_info={"email": "test@example.com"},
                fragment_storage=MemoryFragmentStorage(),
                pages_manager=PagesManager(""),
                current_fragment_id="my_fragment_id",
            )
            add_script_run_ctx(ctx=ctx)
            msg = ForwardMsg()
            msg.delta.new_element.markdown.body = "foo"
            enqueue_message(msg)
            self.assertIsNotNone(fake_enqueue_result)
            self.assertEqual(
                fake_enqueue_result["msg"].delta.new_element.markdown.body,
                msg.delta.new_element.markdown.body,
            )
            self.assertEqual(
                fake_enqueue_result["msg"].delta.fragment_id, "my_fragment_id"
            )

    def test_run_with_active_hash(self):
        """Ensure the active script is set correctly"""
        pages_manager = PagesManager("")
        ctx = ScriptRunContext(
            session_id="TestSessionID",
            _enqueue=lambda msg: None,
            query_string="",
            session_state=SafeSessionState(SessionState(), lambda: None),
            uploaded_file_mgr=MemoryUploadedFileManager("/mock/upload"),
            main_script_path="",
            user_info={"email": "test@test.com"},
            fragment_storage=MemoryFragmentStorage(),
            pages_manager=pages_manager,
            current_fragment_id="my_fragment_id",
        )
        ctx.reset(page_script_hash=pages_manager.main_script_hash)
        assert ctx.active_script_hash == pages_manager.main_script_hash

        pages_manager.set_pages({})
        ctx.set_mpa_v2_page("new_hash")
        assert ctx.active_script_hash == pages_manager.main_script_hash

        with ctx.run_with_active_hash("new_hash"):
            assert ctx.active_script_hash == "new_hash"

        assert ctx.active_script_hash == pages_manager.main_script_hash


================================================
File: /lib/tests/streamlit/runtime/state/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/runtime/state/query_params_proxy_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import unittest
from unittest.mock import MagicMock, patch

import pytest

from streamlit.runtime.state.query_params import QueryParams
from streamlit.runtime.state.query_params_proxy import QueryParamsProxy
from streamlit.runtime.state.safe_session_state import SafeSessionState
from streamlit.runtime.state.session_state import SessionState


def _create_mock_session_state(
    initial_query_params_values: dict[str, list[str] | str],
) -> SafeSessionState:
    """Return a new SafeSessionState instance populated with the
    given query param values.
    """
    session_state = SessionState()
    query_params = QueryParams()
    for key, value in initial_query_params_values.items():
        query_params[key] = value
    session_state.query_params = query_params
    return SafeSessionState(session_state, lambda: None)


class TestQueryParamsProxy(unittest.TestCase):
    def setUp(self):
        self.patcher = patch(
            "streamlit.runtime.state.query_params_proxy.get_session_state",
            MagicMock(
                return_value=_create_mock_session_state(
                    initial_query_params_values={"test": "value"}
                )
            ),
        )
        self.mock_get_session_state = self.patcher.start()
        self.query_params_proxy = QueryParamsProxy()

    def tearDown(self):
        self.patcher.stop()

    def test__getitem__returns_correct_value(self):
        assert self.query_params_proxy["test"] == "value"

    def test__setitem__sets_entry(self):
        self.query_params_proxy["key"] = "value"
        assert self.query_params_proxy["key"] == "value"

    def test__delitem__deletes_entry(self):
        del self.query_params_proxy["test"]
        assert "test" not in self.query_params_proxy

    def test__len__returns_correct_len(self):
        assert len(self.query_params_proxy) == 1

    def test__str__returns_correct_str(self):
        assert str(self.query_params_proxy) == "{'test': 'value'}"

    def test__iter__returns_correct_iter(self):
        keys = list(iter(self.query_params_proxy))
        assert keys == ["test"]

    def test_clear_removes_all_entries(self):
        self.query_params_proxy.clear()
        assert len(self.query_params_proxy) == 0

    def test_get_all_returns_correct_list(self):
        self.query_params_proxy["test"] = ["value1", "value2"]
        assert self.query_params_proxy.get_all("test") == ["value1", "value2"]

    def test__getattr__returns_correct_value(self):
        assert self.query_params_proxy.test == "value"

    def test__setattr__sets_entry(self):
        self.query_params_proxy.key = "value"
        assert self.query_params_proxy["key"] == "value"

    def test_update_sets_entries(self):
        self.query_params_proxy.update({"key1": "value1", "key2": "value2"})
        assert self.query_params_proxy["key1"] == "value1"
        assert self.query_params_proxy["key2"] == "value2"

    def test__delattr__deletes_entry(self):
        del self.query_params_proxy.test
        assert "test" not in self.query_params_proxy

    def test__getattr__raises_Attribute_exception(self):
        with pytest.raises(AttributeError):
            self.query_params_proxy.nonexistent  # noqa: B018

    def test__delattr__raises_Attribute_exception(self):
        with pytest.raises(AttributeError):
            del self.query_params_proxy.nonexistent

    def test_to_dict(self):
        self.query_params_proxy["test_multi"] = ["value1", "value2"]
        assert self.query_params_proxy.to_dict() == {
            "test": "value",
            "test_multi": "value2",
        }

    def test_from_dict(self):
        new_dict = {"test_new": "value_new", "test_multi": ["value1", "value2"]}
        self.query_params_proxy.from_dict(new_dict)
        assert self.query_params_proxy.test_new == "value_new"
        assert self.query_params_proxy["test_multi"] == "value2"
        assert self.query_params_proxy.get_all("test_multi") == ["value1", "value2"]
        assert len(self.query_params_proxy) == 2


================================================
File: /lib/tests/streamlit/runtime/state/query_params_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest

from streamlit.errors import StreamlitAPIException
from streamlit.runtime.state.query_params import QueryParams
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class QueryParamsMethodTests(DeltaGeneratorTestCase):
    query_params_dict_with_embed_key = {
        "foo": "bar",
        "two": ["x", "y"],
        "embed": "true",
        "embed_options": "disable_scrolling",
    }

    def setUp(self):
        super().setUp()
        self.query_params = QueryParams()
        self.query_params._query_params = {"foo": "bar", "two": ["x", "y"]}

    def test__iter__doesnt_include_embed_keys(self):
        self.query_params._query_params = self.query_params_dict_with_embed_key
        for key in self.query_params.__iter__():
            if key == "embed" or key == "embed_options":
                raise KeyError("Cannot iterate through embed or embed_options key")

    def test__getitem__raises_KeyError_for_nonexistent_key_for_embed(self):
        self.query_params._query_params = self.query_params_dict_with_embed_key
        with pytest.raises(KeyError):
            self.query_params["embed"]

    def test__getitem__raises_KeyError_for_nonexistent_key_for_embed_options(self):
        self.query_params._query_params = self.query_params_dict_with_embed_key
        with pytest.raises(KeyError):
            self.query_params["embed_options"]

    def test__getitem__raises_KeyError_for_nonexistent_key(self):
        with pytest.raises(KeyError):
            self.query_params["nonexistent"]

    def test__getitem__returns_last_element_of_list(self):
        assert self.query_params["two"] == "y"

    def test__getitem__retrieves_existing_key(self):
        assert self.query_params["foo"] == "bar"

    def test__setitem__converts_int_value_to_string(self):
        self.query_params["baz"] = 1
        assert self.query_params["baz"] == "1"
        message = self.get_message_from_queue(0)
        assert "baz=1" in message.page_info_changed.query_string

    def test__setitem__converts_float_value_to_string(self):
        self.query_params["corge"] = 1.23
        assert self.query_params["corge"] == "1.23"
        message = self.get_message_from_queue(0)
        assert "corge=1.23" in message.page_info_changed.query_string

    def test__setitem__adds_new_str_query_param(self):
        assert "test" not in self.query_params
        self.query_params["test"] = "test"
        assert self.query_params.get("test") == "test"
        message = self.get_message_from_queue(0)
        assert "test=test" in message.page_info_changed.query_string

    def test__setitem__adds_empty_string_value(self):
        assert "test" not in self.query_params
        self.query_params["test"] = ""
        assert self.query_params["test"] == ""
        message = self.get_message_from_queue(0)
        assert "foo=bar&two=x&two=y&test=" == message.page_info_changed.query_string

    def test__setitem__adds_list_value(self):
        self.query_params["test"] = ["test", "test2"]
        assert self.query_params["test"] == "test2"
        message = self.get_message_from_queue(0)
        assert "test=test&test=test2" in message.page_info_changed.query_string

    def test__setitem__adds_tuple_value(self):
        self.query_params["test"] = (1, 2, 3)
        assert self.query_params["test"] == "3"
        message = self.get_message_from_queue(0)
        assert "test=1&test=2&test=3" in message.page_info_changed.query_string

    def test__setitem__adds_set_value(self):
        self.query_params["test"] = set({1, 2, 3})
        assert self.query_params["test"] == "3"
        message = self.get_message_from_queue(0)
        assert "test=1&test=2&test=3" in message.page_info_changed.query_string

    def test__setitem__sets_old_query_param_key(self):
        self.query_params["foo"] = "test"
        assert self.query_params.get("foo") == "test"
        message = self.get_message_from_queue(0)
        assert "foo=test" in message.page_info_changed.query_string

    def test__setitem__raises_StreamlitException_with_dictionary_value(self):
        with pytest.raises(StreamlitAPIException):
            self.query_params["foo"] = {"test": "test"}

    def test__setitem__raises_exception_for_embed_key(self):
        with pytest.raises(StreamlitAPIException):
            self.query_params["embed"] = True

    def test__setitem__raises_exception_for_embed_options_key(self):
        with pytest.raises(StreamlitAPIException):
            self.query_params["embed_options"] = "show_toolbar"

    def test__setitem__raises_error_with_embed_key(self):
        with pytest.raises(StreamlitAPIException):
            self.query_params["embed"] = "true"

    def test_update_adds_values(self):
        self.query_params.update({"foo": "bar"})
        assert self.query_params.get("foo") == "bar"
        message = self.get_message_from_queue(0)
        assert "foo=bar" in message.page_info_changed.query_string

    def test_update_adds_list_values(self):
        self.query_params.update({"foo": ["bar", "baz"]})
        assert self.query_params.get_all("foo") == ["bar", "baz"]
        message = self.get_message_from_queue(0)
        assert "foo=bar&foo=baz" in message.page_info_changed.query_string

    def test_update_with_iterable(self):
        self.query_params.update([("foo", "bar"), ("stream", ["lit", "rocks"])])
        assert self.query_params.get("foo") == "bar"
        assert self.query_params.get("stream") == "rocks"
        message = self.get_message_from_queue(0)
        assert "foo=bar" in message.page_info_changed.query_string
        assert "stream=lit&stream=rocks" in message.page_info_changed.query_string

    def test_update_with_keywords(self):
        self.query_params.update(foo="bar", stream=["lit", "rocks"])
        assert self.query_params.get("foo") == "bar"
        assert self.query_params.get("stream") == "rocks"
        message = self.get_message_from_queue(0)
        assert "foo=bar" in message.page_info_changed.query_string
        assert "stream=lit&stream=rocks" in message.page_info_changed.query_string

    def test_update_raises_error_with_embed_key(self):
        with pytest.raises(StreamlitAPIException):
            self.query_params.update({"foo": "bar", "embed": "true"})

    def test_update_raises_error_with_embed_options_key(self):
        with pytest.raises(StreamlitAPIException):
            self.query_params.update({"foo": "bar", "embed_options": "show_toolbar"})

    def test_update_raises_exception_with_dictionary_value(self):
        with pytest.raises(StreamlitAPIException):
            self.query_params.update({"a_dict": {"test": "test"}})

    def test_update_changes_values_in_single_message(self):
        self.query_params.set_with_no_forward_msg("foo", "test")
        self.query_params.update({"foo": "bar", "baz": "test"})
        assert self.query_params.get("foo") == "bar"
        assert self.query_params.get("baz") == "test"
        assert len(self.forward_msg_queue) == 1
        message = self.get_message_from_queue(0)
        assert "foo=bar" in message.page_info_changed.query_string
        assert "baz=test" in message.page_info_changed.query_string

    def test__delitem__removes_existing_key(self):
        del self.query_params["foo"]
        assert "foo" not in self.query_params
        message = self.get_message_from_queue(0)
        assert "two=x&two=y" in message.page_info_changed.query_string
        assert "foo" not in message.page_info_changed.query_string

    def test__delitem__raises_error_for_nonexistent_key(self):
        with pytest.raises(KeyError):
            del self.query_params["nonexistent"]

    def test__delitem__throws_KeyErrorException_for_embed_key(self):
        self.query_params._query_params = self.query_params_dict_with_embed_key
        with pytest.raises(KeyError):
            del self.query_params["embed"]
        assert "embed" in self.query_params._query_params

    def test__delitem__throws_KeyErrorException_for_embed_options_key(self):
        self.query_params._query_params = self.query_params_dict_with_embed_key
        with pytest.raises(KeyError):
            del self.query_params["embed_options"]
        assert "embed_options" in self.query_params._query_params

    def test_get_all_returns_empty_list_for_nonexistent_key(self):
        assert self.query_params.get_all("nonexistent") == []

    def test_get_all_retrieves_single_element_list(self):
        assert self.query_params.get_all("foo") == ["bar"]

    def test_get_all_retrieves_multiple_values_as_list(self):
        assert self.query_params.get_all("two") == ["x", "y"]

    def test_get_all_handles_mixed_type_values(self):
        self.query_params["test"] = ["", "a", 1, 1.23]
        assert self.query_params.get_all("test") == ["", "a", "1", "1.23"]

    def test_get_all_returns_empty_array_for_embed_key(self):
        self.query_params._query_params = self.query_params_dict_with_embed_key
        assert self.query_params.get_all("embed") == []

    def test_get_all_returns_empty_array_for_embed_options_key(self):
        self.query_params._query_params = self.query_params_dict_with_embed_key
        assert self.query_params.get_all("embed_options") == []

    def test__len__doesnt_include_embed_and_embed_options_key(self):
        self.query_params._query_params = self.query_params_dict_with_embed_key
        assert len(self.query_params) == 2

    def test_clear_removes_all_query_params(self):
        self.query_params.clear()
        assert len(self.query_params) == 0
        message = self.get_message_from_queue(0)
        assert "" == message.page_info_changed.query_string

    def test_clear_doesnt_remove_embed_query_params(self):
        self.query_params._query_params = {
            "foo": "bar",
            "embed": "true",
            "embed_options": ["show_colored_line", "disable_scrolling"],
        }
        result_dict = {
            "embed": "true",
            "embed_options": ["show_colored_line", "disable_scrolling"],
        }
        self.query_params.clear()
        assert self.query_params._query_params == result_dict

    def test_to_dict(self):
        self.query_params["baz"] = ""
        result_dict = {"foo": "bar", "two": "y", "baz": ""}
        assert self.query_params.to_dict() == result_dict

    def test_to_dict_doesnt_include_embed_params(self):
        self.query_params._query_params = {
            "foo": "bar",
            "embed": "true",
            "embed_options": ["show_colored_line", "disable_scrolling"],
        }
        result_dict = {"foo": "bar"}
        assert self.query_params.to_dict() == result_dict

    def test_from_dict(self):
        result_dict = {"hello": "world"}
        self.query_params.from_dict(result_dict)
        assert self.query_params.to_dict() == result_dict

    def test_from_dict_iterable(self):
        self.query_params.from_dict((("key1", 5), ("key2", 6)))
        assert self.query_params._query_params == {"key1": "5", "key2": "6"}

    def test_from_dict_mixed_values(self):
        result_dict = {"hello": ["world", "janice", "amy"], "snow": "flake"}
        self.query_params.from_dict(result_dict)

        # self.query_params.to_dict() has behavior consistent with fetching values using
        # self.query_params["some_key"]. That is, if the value is an array, the last
        # element of the array is returned rather than the array in its entirety.
        assert self.query_params.to_dict() == {"hello": "amy", "snow": "flake"}

        result_as_list = {"hello": ["world", "janice", "amy"], "snow": ["flake"]}
        qp_as_list = {key: self.query_params.get_all(key) for key in self.query_params}
        assert result_as_list == qp_as_list

    def test_from_dict_preserves_embed_keys(self):
        self.query_params._query_params.update(
            {"embed_options": ["disable_scrolling", "show_colored_line"]}
        )
        self.query_params.from_dict({"a": "b", "c": "d"})
        assert self.query_params._query_params == {
            "a": "b",
            "c": "d",
            "embed_options": ["disable_scrolling", "show_colored_line"],
        }

    def test_from_dict_preserves_last_value_on_error(self):
        old_value = self.query_params._query_params
        with pytest.raises(StreamlitAPIException):
            self.query_params.from_dict({"a": "b", "embed": False})
        assert self.query_params._query_params == old_value

    def test_from_dict_changes_values_in_single_message(self):
        self.query_params.set_with_no_forward_msg("hello", "world")
        self.query_params.from_dict({"foo": "bar", "baz": "test"})
        assert self.query_params.get("foo") == "bar"
        assert self.query_params.get("baz") == "test"
        assert len(self.forward_msg_queue) == 1
        message = self.get_message_from_queue(0)
        assert message.page_info_changed.query_string == "foo=bar&baz=test"

    def test_from_dict_raises_error_with_embed_key(self):
        with pytest.raises(StreamlitAPIException):
            self.query_params.from_dict({"foo": "bar", "embed": "true"})

    def test_from_dict_raises_error_with_embed_options_key(self):
        with pytest.raises(StreamlitAPIException):
            self.query_params.from_dict({"foo": "bar", "embed_options": "show_toolbar"})

    def test_from_dict_raises_exception_with_dictionary_value(self):
        with pytest.raises(StreamlitAPIException):
            self.query_params.from_dict({"a_dict": {"test": "test"}})

    def test_from_dict_inverse(self):
        self.query_params.from_dict({"a": "b", "c": "d"})
        assert self.query_params._query_params == {"a": "b", "c": "d"}
        message = self.get_message_from_queue(0)
        assert message.page_info_changed.query_string == "a=b&c=d"
        from_dict_inverse = {
            key: self.query_params.get_all(key) for key in self.query_params
        }
        self.query_params.from_dict(from_dict_inverse)
        assert self.query_params._query_params == {"a": ["b"], "c": ["d"]}
        message = self.get_message_from_queue(0)
        assert message.page_info_changed.query_string == "a=b&c=d"

    def test_set_with_no_forward_msg_sends_no_msg_and_sets_query_params(self):
        self.query_params.set_with_no_forward_msg("test", "test")
        assert self.query_params["test"] == "test"
        with pytest.raises(IndexError):
            # no forward message should be sent
            self.get_message_from_queue(0)

    def test_set_with_no_forward_msg_accepts_embed(self):
        self.query_params.set_with_no_forward_msg("embed", "true")
        assert self.query_params._query_params["embed"] == "true"
        with pytest.raises(IndexError):
            # no forward message should be sent
            self.get_message_from_queue(0)

    def test_set_with_no_forward_msg_accepts_embed_options(self):
        self.query_params.set_with_no_forward_msg("embed_options", "disable_scrolling")
        assert self.query_params._query_params["embed_options"] == "disable_scrolling"
        with pytest.raises(IndexError):
            # no forward message should be sent
            self.get_message_from_queue(0)

    def test_set_with_no_forward_msg_accepts_multiple_embed_options(self):
        self.query_params.set_with_no_forward_msg(
            "embed_options", ["disable_scrolling", "show_colored_line"]
        )
        assert self.query_params._query_params["embed_options"] == [
            "disable_scrolling",
            "show_colored_line",
        ]
        with pytest.raises(IndexError):
            # no forward message should be sent
            self.get_message_from_queue(0)

    def test_clear_with_no_forward_msg_sends_no_msg_and_clears_query_params(self):
        self.query_params._query_params.update(
            {"embed_options": ["disable_scrolling", "show_colored_line"]}
        )
        self.query_params.clear_with_no_forward_msg()
        assert len(self.query_params) == 0
        assert len(self.query_params._query_params) == 0
        with pytest.raises(IndexError):
            # no forward message should be sent
            self.get_message_from_queue(0)

    def test_clear_with_no_forward_msg_preserve_embed_keys(self):
        self.query_params._query_params.update(
            {"embed_options": ["disable_scrolling", "show_colored_line"]}
        )
        self.query_params.clear_with_no_forward_msg(preserve_embed=True)
        assert len(self.query_params) == 0
        assert len(self.query_params._query_params) == 1
        assert self.query_params._query_params["embed_options"] == (
            ["disable_scrolling", "show_colored_line"]
        )


================================================
File: /lib/tests/streamlit/runtime/state/session_state_proxy_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""SessionStateProxy unit tests."""

from __future__ import annotations

import unittest
from typing import Any
from unittest.mock import MagicMock, patch

import pytest

from streamlit.errors import StreamlitAPIException
from streamlit.runtime.state import SafeSessionState, SessionState, SessionStateProxy
from streamlit.runtime.state.common import (
    GENERATED_ELEMENT_ID_PREFIX,
    require_valid_user_key,
)


def _create_mock_session_state(
    initial_state_values: dict[str, Any],
) -> SafeSessionState:
    """Return a new SafeSessionState instance populated with the
    given state values.
    """
    session_state = SessionState()
    for key, value in initial_state_values.items():
        session_state[key] = value
    return SafeSessionState(session_state, lambda: None)


@patch(
    "streamlit.runtime.state.session_state_proxy.get_session_state",
    MagicMock(return_value=_create_mock_session_state({"foo": "bar"})),
)
class SessionStateProxyTests(unittest.TestCase):
    reserved_key = f"{GENERATED_ELEMENT_ID_PREFIX}-some_key"

    def setUp(self):
        self.session_state_proxy = SessionStateProxy()

    def test_iter(self):
        state_iter = iter(self.session_state_proxy)
        assert next(state_iter) == "foo"
        with pytest.raises(StopIteration):
            next(state_iter)

    def test_len(self):
        assert len(self.session_state_proxy) == 1

    def test_validate_key(self):
        with pytest.raises(StreamlitAPIException) as e:
            require_valid_user_key(self.reserved_key)
        assert "are reserved" in str(e.value)

    def test_to_dict(self):
        assert self.session_state_proxy.to_dict() == {"foo": "bar"}

    # NOTE: We only test the error cases of {get, set, del}{item, attr} below
    # since the others are tested in another test class.
    def test_getitem_reserved_key(self):
        with pytest.raises(StreamlitAPIException):
            _ = self.session_state_proxy[self.reserved_key]

    def test_setitem_reserved_key(self):
        with pytest.raises(StreamlitAPIException):
            self.session_state_proxy[self.reserved_key] = "foo"

    def test_delitem_reserved_key(self):
        with pytest.raises(StreamlitAPIException):
            del self.session_state_proxy[self.reserved_key]

    def test_getattr_reserved_key(self):
        with pytest.raises(StreamlitAPIException):
            getattr(self.session_state_proxy, self.reserved_key)

    def test_setattr_reserved_key(self):
        with pytest.raises(StreamlitAPIException):
            setattr(self.session_state_proxy, self.reserved_key, "foo")

    def test_delattr_reserved_key(self):
        with pytest.raises(StreamlitAPIException):
            delattr(self.session_state_proxy, self.reserved_key)


class SessionStateProxyAttributeTests(unittest.TestCase):
    """Tests of SessionStateProxy attribute methods.

    Separate from the others to change patching. Test methods are individually
    patched to avoid issues with mutability.
    """

    def setUp(self):
        self.session_state_proxy = SessionStateProxy()

    @patch(
        "streamlit.runtime.state.session_state_proxy.get_session_state",
        MagicMock(return_value=SessionState(_new_session_state={"foo": "bar"})),
    )
    def test_delattr(self):
        del self.session_state_proxy.foo
        assert "foo" not in self.session_state_proxy

    @patch(
        "streamlit.runtime.state.session_state_proxy.get_session_state",
        MagicMock(return_value=SessionState(_new_session_state={"foo": "bar"})),
    )
    def test_getattr(self):
        assert self.session_state_proxy.foo == "bar"

    @patch(
        "streamlit.runtime.state.session_state_proxy.get_session_state",
        MagicMock(return_value=SessionState(_new_session_state={"foo": "bar"})),
    )
    def test_getattr_error(self):
        with pytest.raises(AttributeError):
            del self.session_state_proxy.nonexistent

    @patch(
        "streamlit.runtime.state.session_state_proxy.get_session_state",
        MagicMock(return_value=SessionState(_new_session_state={"foo": "bar"})),
    )
    def test_setattr(self):
        self.session_state_proxy.corge = "grault2"
        assert self.session_state_proxy.corge == "grault2"


================================================
File: /lib/tests/streamlit/runtime/state/session_state_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Session state unit tests."""

from __future__ import annotations

import unittest
from copy import deepcopy
from datetime import date, datetime, timedelta
from typing import Any
from unittest.mock import MagicMock, patch

import pytest
from hypothesis import given, settings
from hypothesis import strategies as hst

import streamlit as st
import tests.streamlit.runtime.state.strategies as stst
from streamlit.errors import (
    StreamlitAPIException,
    UnserializableSessionStateError,
)
from streamlit.proto.Common_pb2 import FileURLs as FileURLsProto
from streamlit.proto.WidgetStates_pb2 import WidgetState as WidgetStateProto
from streamlit.runtime.scriptrunner import get_script_run_ctx
from streamlit.runtime.state import SessionState, get_session_state
from streamlit.runtime.state.common import GENERATED_ELEMENT_ID_PREFIX
from streamlit.runtime.state.session_state import (
    KeyIdMapper,
    Serialized,
    Value,
    WidgetMetadata,
    WStates,
    _is_stale_widget,
)
from streamlit.runtime.uploaded_file_manager import UploadedFile, UploadedFileRec
from streamlit.testing.v1.app_test import AppTest
from tests.delta_generator_test_case import DeltaGeneratorTestCase
from tests.testutil import patch_config_options


def identity(x):
    return x


def _raw_session_state() -> SessionState:
    """Return the SessionState instance within the current ScriptRunContext's
    SafeSessionState wrapper.
    """
    return get_session_state()._state


class WStateTests(unittest.TestCase):
    def setUp(self):
        wstates = WStates()
        self.wstates = wstates

        widget_state = WidgetStateProto()
        widget_state.id = "widget_id_1"
        widget_state.int_value = 5
        wstates.set_widget_from_proto(widget_state)
        wstates.set_widget_metadata(
            WidgetMetadata(
                id="widget_id_1",
                deserializer=lambda x, s: str(x),
                serializer=lambda x: int(x),
                value_type="int_value",
            )
        )

        wstates.set_from_value("widget_id_2", 5)
        wstates.set_widget_metadata(
            WidgetMetadata(
                id="widget_id_2",
                deserializer=lambda x, s: x,
                serializer=identity,
                value_type="int_value",
            )
        )

    def test_get_from_json_value(self):
        widget_state = WidgetStateProto()
        widget_state.id = "widget_id_3"
        widget_state.json_value = '{"foo":5}'

        self.wstates.set_widget_from_proto(widget_state)
        self.wstates.set_widget_metadata(
            WidgetMetadata(
                id="widget_id_3",
                deserializer=lambda x, s: x,
                serializer=identity,
                value_type="json_value",
            )
        )

        assert self.wstates["widget_id_3"] == {"foo": 5}

    def test_getitem_nonexistent(self):
        with pytest.raises(KeyError):
            self.wstates["nonexistent_widget_id"]

    def test_getitem_no_metadata(self):
        del self.wstates.widget_metadata["widget_id_1"]
        with pytest.raises(KeyError):
            self.wstates["widget_id_1"]

    def test_getitem_serialized(self):
        assert isinstance(self.wstates.states["widget_id_1"], Serialized)
        assert self.wstates["widget_id_1"] == "5"
        assert self.wstates.states["widget_id_1"] == Value("5")

    def test_getitem_value(self):
        assert self.wstates["widget_id_2"] == 5

    def test_len(self):
        assert len(self.wstates) == 2

    def test_iter(self):
        wstate_iter = iter(self.wstates)
        assert next(wstate_iter) == "widget_id_1"
        assert next(wstate_iter) == "widget_id_2"
        with pytest.raises(StopIteration):
            next(wstate_iter)

    def test_keys(self):
        assert self.wstates.keys() == {"widget_id_1", "widget_id_2"}

    def test_items(self):
        assert self.wstates.items() == {("widget_id_1", "5"), ("widget_id_2", 5)}

    def test_values(self):
        assert self.wstates.values() == {"5", 5}

    def test_remove_stale_widgets(self):
        self.wstates.remove_stale_widgets({"widget_id_1"}, None)
        assert "widget_id_1" in self.wstates
        assert "widget_id_2" not in self.wstates

    def test_remove_stale_widgets_fragment_run(self):
        widget_data = [
            ("widget_id_1", "my_fragment_id"),
            ("widget_id_2", "my_fragment_id"),
            ("widget_id_3", "some_other_fragment_id"),
        ]
        for widget_id, fragment_id in widget_data:
            widget_state1 = WidgetStateProto()
            widget_state1.id = widget_id
            widget_state1.int_value = 7
            self.wstates.set_widget_from_proto(widget_state1)
            self.wstates.set_widget_metadata(
                WidgetMetadata(
                    id=widget_id,
                    deserializer=lambda x, s: x,
                    serializer=identity,
                    value_type="int_value",
                    fragment_id=fragment_id,
                )
            )

        self.wstates.remove_stale_widgets({"widget_id_1"}, {"my_fragment_id"})
        assert "widget_id_1" in self.wstates  # Active widget in fragment, not removed
        assert "widget_id_2" not in self.wstates  # Stale widget in fragment, removed
        assert "widget_id_3" in self.wstates  # Unrelated widget, not removed

    def test_get_serialized_nonexistent_id(self):
        assert self.wstates.get_serialized("nonexistent_id") is None

    def test_get_serialized_no_metadata(self):
        del self.wstates.widget_metadata["widget_id_2"]
        assert self.wstates.get_serialized("widget_id_2") is None

    def test_get_serialized_already_serialized(self):
        serialized = self.wstates.get_serialized("widget_id_2")
        assert serialized.id == "widget_id_2"
        assert serialized.int_value == 5

    def test_get_serialized(self):
        serialized = self.wstates.get_serialized("widget_id_1")
        assert serialized.id == "widget_id_1"
        assert serialized.int_value == 5

    def test_get_serialized_array_value(self):
        widget_state = WidgetStateProto()
        widget_state.id = "widget_id_1"
        widget_state.int_array_value.data.extend([1, 2, 3, 4])
        self.wstates.set_widget_from_proto(widget_state)
        self.wstates.set_widget_metadata(
            WidgetMetadata(
                id="widget_id_1",
                deserializer=lambda x, s: x,
                serializer=identity,
                value_type="int_array_value",
            )
        )

        serialized = self.wstates.get_serialized("widget_id_1")
        assert serialized.id == "widget_id_1"
        assert list(serialized.int_array_value.data) == [1, 2, 3, 4]

    def test_get_serialized_json_value(self):
        self.wstates.set_from_value("widget_id_3", {"foo": 5})
        self.wstates.set_widget_metadata(
            WidgetMetadata(
                id="widget_id_3",
                deserializer=lambda x, s: x,
                serializer=identity,
                value_type="json_value",
            )
        )

        serialized = self.wstates.get_serialized("widget_id_3")
        assert serialized.id == "widget_id_3"
        assert serialized.json_value == '{"foo": 5}'

    def test_as_widget_states(self):
        widget_states = self.wstates.as_widget_states()
        assert len(widget_states) == 2
        assert widget_states[0].id == "widget_id_1"
        assert widget_states[0].int_value == 5
        assert widget_states[1].id == "widget_id_2"
        assert widget_states[1].int_value == 5

    def test_call_callback(self):
        metadata = WidgetMetadata(
            id="widget_id_1",
            deserializer=lambda x, s: str(x),
            serializer=lambda x: int(x),
            value_type="int_value",
            callback=MagicMock(),
            callback_args=(1,),
            callback_kwargs={"y": 2},
        )
        self.wstates.widget_metadata["widget_id_1"] = metadata
        self.wstates.call_callback("widget_id_1")

        metadata.callback.assert_called_once_with(1, y=2)


@patch("streamlit.runtime.Runtime.exists", MagicMock(return_value=True))
class SessionStateUpdateTest(DeltaGeneratorTestCase):
    def test_widget_creation_updates_state(self):
        state = st.session_state
        assert "c" not in state

        st.checkbox("checkbox", value=True, key="c")

        assert state.c is True

    def test_setting_before_widget_creation(self):
        state = st.session_state
        state.c = True
        assert state.c is True

        c = st.checkbox("checkbox", key="c")
        assert c is True


@patch("streamlit.runtime.Runtime.exists", MagicMock(return_value=True))
class SessionStateTest(DeltaGeneratorTestCase):
    def test_widget_presence(self):
        state = st.session_state

        assert "foo" not in state

        state.foo = "foo"

        assert "foo" in state
        assert state.foo == "foo"

    def test_widget_outputs_dont_alias(self):
        color = st.select_slider(
            "Select a color of the rainbow",
            options=[
                ["red", "orange"],
                ["yellow", "green"],
                ["blue", "indigo"],
                ["violet"],
            ],
            key="color",
        )

        ctx = get_script_run_ctx()
        assert ctx.session_state["color"] is not color


def test_callbacks_with_rerun():
    """Calling 'rerun' from within a widget callback
    is disallowed and results in a warning.
    """

    def script():
        import streamlit as st

        def callback():
            st.session_state["message"] = "ran callback"
            st.rerun()

        st.checkbox("cb", on_change=callback)

    at = AppTest.from_function(script).run()
    at.checkbox[0].check().run()
    assert at.session_state["message"] == "ran callback"
    warning = at.warning[0]
    assert "no-op" in warning.value


def test_updates():
    at = AppTest.from_file("test_data/linked_sliders.py").run()
    assert at.slider.values == [-100.0, -148.0]
    assert at.markdown.values == ["Celsius `-100.0`", "Fahrenheit `-148.0`"]

    # Both sliders update when first is changed
    at.slider[0].set_value(0.0).run()
    assert at.slider.values == [0.0, 32.0]
    assert at.markdown.values == ["Celsius `0.0`", "Fahrenheit `32.0`"]

    # Both sliders update when second is changed
    at.slider[1].set_value(212.0).run()
    assert at.slider.values == [100.0, 212.0]
    assert at.markdown.values == ["Celsius `100.0`", "Fahrenheit `212.0`"]

    # Sliders update when one is changed repeatedly
    at.slider[0].set_value(0.0).run()
    assert at.slider.values == [0.0, 32.0]
    at.slider[0].set_value(100.0).run()
    assert at.slider.values == [100.0, 212.0]


def test_serializable_check():
    """When the config option is on, adding unserializable data to session
    state should result in an exception.
    """
    with patch_config_options({"runner.enforceSerializableSessionState": True}):

        def script():
            import streamlit as st

            def unserializable_data():
                return lambda x: x

            st.session_state.unserializable = unserializable_data()

        at = AppTest.from_function(script).run()
        assert at.exception
        assert "pickle" in at.exception[0].value


def test_serializable_check_off():
    """When the config option is off, adding unserializable data to session
    state should work without errors.
    """
    with patch_config_options({"runner.enforceSerializableSessionState": False}):

        def script():
            import streamlit as st

            def unserializable_data():
                return lambda x: x

            st.session_state.unserializable = unserializable_data()

        at = AppTest.from_function(script).run()
        assert not at.exception


def check_roundtrip(widget_id: str, value: Any) -> None:
    session_state = _raw_session_state()
    wid = session_state._get_widget_id(widget_id)
    metadata = session_state._new_widget_state.widget_metadata[wid]
    serializer = metadata.serializer
    deserializer = metadata.deserializer

    assert deserializer(serializer(value), "") == value


@patch("streamlit.runtime.Runtime.exists", MagicMock(return_value=True))
class SessionStateSerdeTest(DeltaGeneratorTestCase):
    def test_checkbox_serde(self):
        cb = st.checkbox("cb", key="cb")
        check_roundtrip("cb", cb)

    def test_color_picker_serde(self):
        cp = st.color_picker("cp", key="cp")
        check_roundtrip("cp", cp)

    def test_date_input_serde(self):
        date = st.date_input("date", key="date")
        check_roundtrip("date", date)

        date_interval = st.date_input(
            "date_interval",
            value=[datetime.now().date(), datetime.now().date() + timedelta(days=1)],
            key="date_interval",
        )
        check_roundtrip("date_interval", date_interval)

    def test_feedback_serde(self):
        feedback = st.feedback("stars", key="feedback")
        check_roundtrip("feedback", feedback)

    @patch("streamlit.elements.widgets.file_uploader._get_upload_files")
    def test_file_uploader_serde(self, get_upload_files_patch):
        file_rec = UploadedFileRec("file1", "file1", "type", b"123")
        uploaded_files = [
            UploadedFile(
                file_rec, FileURLsProto(file_id="1", delete_url="d1", upload_url="u1")
            )
        ]

        get_upload_files_patch.return_value = uploaded_files

        uploaded_file = st.file_uploader("file_uploader", key="file_uploader")
        check_roundtrip("file_uploader", uploaded_file)

    def test_multiselect_serde(self):
        multiselect = st.multiselect(
            "multiselect", options=["a", "b", "c"], key="multiselect"
        )
        check_roundtrip("multiselect", multiselect)

        multiselect_multiple = st.multiselect(
            "multiselect_multiple",
            options=["a", "b", "c"],
            default=["b", "c"],
            key="multiselect_multiple",
        )
        check_roundtrip("multiselect_multiple", multiselect_multiple)

    def test_number_input_serde(self):
        number = st.number_input("number", key="number")
        check_roundtrip("number", number)

        number_int = st.number_input("number_int", value=16777217, key="number_int")
        check_roundtrip("number_int", number_int)

    def test_radio_input_serde(self):
        radio = st.radio("radio", options=["a", "b", "c"], key="radio")
        check_roundtrip("radio", radio)

        radio_nondefault = st.radio(
            "radio_nondefault",
            options=["a", "b", "c"],
            index=1,
            key="radio_nondefault",
        )
        check_roundtrip("radio_nondefault", radio_nondefault)

    def test_selectbox_serde(self):
        selectbox = st.selectbox("selectbox", options=["a", "b", "c"], key="selectbox")
        check_roundtrip("selectbox", selectbox)

    def test_select_slider_serde(self):
        select_slider = st.select_slider(
            "select_slider", options=["a", "b", "c"], key="select_slider"
        )
        check_roundtrip("select_slider", select_slider)

        select_slider_range = st.select_slider(
            "select_slider_range",
            options=["a", "b", "c"],
            value=["a", "b"],
            key="select_slider_range",
        )
        check_roundtrip("select_slider_range", select_slider_range)

    def test_slider_serde(self):
        slider = st.slider("slider", key="slider")
        check_roundtrip("slider", slider)

        slider_float = st.slider("slider_float", value=0.5, key="slider_float")
        check_roundtrip("slider_float", slider_float)

        slider_date = st.slider(
            "slider_date",
            value=date.today(),
            key="slider_date",
        )
        check_roundtrip("slider_date", slider_date)

        slider_time = st.slider(
            "slider_time",
            value=datetime.now().time(),
            key="slider_time",
        )
        check_roundtrip("slider_time", slider_time)

        slider_datetime = st.slider(
            "slider_datetime",
            value=datetime.now(),
            key="slider_datetime",
        )
        check_roundtrip("slider_datetime", slider_datetime)

        slider_interval = st.slider(
            "slider_interval",
            value=[-1.0, 1.0],
            key="slider_interval",
        )
        check_roundtrip("slider_interval", slider_interval)

    def test_text_area_serde(self):
        text_area = st.text_area("text_area", key="text_area")
        check_roundtrip("text_area", text_area)

        text_area_default = st.text_area(
            "text_area_default",
            value="default",
            key="text_area_default",
        )
        check_roundtrip("text_area_default", text_area_default)

    def test_text_input_serde(self):
        text_input = st.text_input("text_input", key="text_input")
        check_roundtrip("text_input", text_input)

        text_input_default = st.text_input(
            "text_input_default",
            value="default",
            key="text_input_default",
        )
        check_roundtrip("text_input_default", text_input_default)

    def test_time_input_serde(self):
        time = st.time_input("time", key="time")
        check_roundtrip("time", time)

        time_datetime = st.time_input(
            "datetime",
            value=datetime.now(),
            key="time_datetime",
        )
        check_roundtrip("time_datetime", time_datetime)


def _compact_copy(state: SessionState) -> SessionState:
    """Return a compacted copy of the given SessionState."""
    state_copy = deepcopy(state)
    state_copy._compact_state()
    return state_copy


def _sorted_items(state: SessionState) -> list[tuple[str, Any]]:
    """Return all key-value pairs in the SessionState.
    The returned list is sorted by key for easier comparison.
    """
    return [(key, state[key]) for key in sorted(state._keys())]


class SessionStateMethodTests(unittest.TestCase):
    def setUp(self):
        self.old_state = {"foo": "bar", "baz": "qux", "corge": "grault"}
        self.new_session_state = {"foo": "bar2"}
        new_widget_state = WStates(
            {
                "baz": Value("qux2"),
                f"{GENERATED_ELEMENT_ID_PREFIX}-foo-None": Value("bar"),
            },
        )
        self.session_state = SessionState(
            self.old_state, self.new_session_state, new_widget_state
        )

    def test_compact(self):
        self.session_state._compact_state()
        assert self.session_state._old_state == {
            "foo": "bar2",
            "baz": "qux2",
            "corge": "grault",
            f"{GENERATED_ELEMENT_ID_PREFIX}-foo-None": "bar",
        }
        assert self.session_state._new_session_state == {}
        assert self.session_state._new_widget_state == WStates()

    # https://github.com/streamlit/streamlit/issues/7206
    def test_ignore_key_error_within_compact_state(self):
        wstates = WStates()

        widget_state = WidgetStateProto()
        widget_state.id = "widget_id_1"
        widget_state.int_value = 5
        wstates.set_widget_from_proto(widget_state)
        session_state = SessionState(self.old_state, self.new_session_state, wstates)
        # KeyError should be thrown from grabbing a key with no metadata
        # but _compact_state catches it so no KeyError should be thrown
        session_state._compact_state()
        with pytest.raises(KeyError):
            wstates["baz"]

    def test_clear_state(self):
        # Sanity test
        keys = {"foo", "baz", "corge", f"{GENERATED_ELEMENT_ID_PREFIX}-foo-None"}
        self.assertEqual(keys, self.session_state._keys())

        # Clear state
        self.session_state.clear()

        # Keys should be empty
        self.assertEqual(set(), self.session_state._keys())

    def test_filtered_state(self):
        assert self.session_state.filtered_state == {
            "foo": "bar2",
            "baz": "qux2",
            "corge": "grault",
        }

    def test_filtered_state_resilient_to_missing_metadata(self):
        old_state = {"foo": "bar", "corge": "grault"}
        new_session_state = {}
        new_widget_state = WStates(
            {f"{GENERATED_ELEMENT_ID_PREFIX}-baz": Serialized(WidgetStateProto())},
        )
        self.session_state = SessionState(
            old_state, new_session_state, new_widget_state
        )

        assert self.session_state.filtered_state == {
            "foo": "bar",
            "corge": "grault",
        }

    def is_new_state_value(self):
        assert self.session_state.is_new_state_value("foo")
        assert not self.session_state.is_new_state_value("corge")

    def test_getitem(self):
        assert self.session_state["foo"] == "bar2"

    def test_getitem_error(self):
        with pytest.raises(KeyError):
            self.session_state["nonexistent"]

    def test_setitem(self):
        assert not self.session_state.is_new_state_value("corge")
        self.session_state["corge"] = "grault2"
        assert self.session_state["corge"] == "grault2"
        assert self.session_state.is_new_state_value("corge")

    def test_setitem_disallows_setting_created_widget(self):
        mock_ctx = MagicMock()
        mock_ctx.widget_ids_this_run = {"widget_id"}

        with patch(
            "streamlit.runtime.state.session_state.get_script_run_ctx",
            return_value=mock_ctx,
        ):
            with pytest.raises(StreamlitAPIException) as e:
                self.session_state._key_id_mapper.set_key_id_mapping(
                    {"widget_id": "widget_id"}
                )
                self.session_state["widget_id"] = "blah"
            assert "`st.session_state.widget_id` cannot be modified" in str(e.value)

    def test_setitem_disallows_setting_created_form(self):
        mock_ctx = MagicMock()
        mock_ctx.form_ids_this_run = {"form_id"}

        with patch(
            "streamlit.runtime.state.session_state.get_script_run_ctx",
            return_value=mock_ctx,
        ):
            with pytest.raises(StreamlitAPIException) as e:
                self.session_state["form_id"] = "blah"
            assert "`st.session_state.form_id` cannot be modified" in str(e.value)

    def test_delitem(self):
        del self.session_state["foo"]
        assert "foo" not in self.session_state

    def test_delitem_errors(self):
        for key in ["_new_session_state", "_new_widget_state", "_old_state"]:
            with pytest.raises(KeyError):
                del self.session_state[key]

        with pytest.raises(KeyError):
            del self.session_state["nonexistent"]

    def test_widget_changed(self):
        assert self.session_state._widget_changed("foo")
        self.session_state._new_widget_state.set_from_value("foo", "bar")
        assert not self.session_state._widget_changed("foo")

    def test_remove_stale_widgets(self):
        existing_widget_key = f"{GENERATED_ELEMENT_ID_PREFIX}-existing_widget"
        generated_widget_key = f"{GENERATED_ELEMENT_ID_PREFIX}-removed_widget"

        self.session_state._old_state = {
            existing_widget_key: True,
            generated_widget_key: True,
            "val_set_via_state": 5,
        }

        wstates = WStates()
        wstates.set_widget_metadata(
            WidgetMetadata(
                id=existing_widget_key,
                deserializer=lambda x, s: str(x),
                serializer=lambda x: bool(x),
                value_type="bool_value",
            )
        )
        wstates.set_widget_metadata(
            WidgetMetadata(
                id=generated_widget_key,
                deserializer=lambda x, s: str(x),
                serializer=lambda x: bool(x),
                value_type="bool_value",
            )
        )
        self.session_state._new_widget_state = wstates

        self.session_state._remove_stale_widgets({existing_widget_key})

        assert self.session_state[existing_widget_key] is True
        assert generated_widget_key not in self.session_state
        assert self.session_state["val_set_via_state"] == 5

    def test_should_set_frontend_state_value_new_widget(self):
        # The widget is being registered for the first time, so there's no need
        # to have the frontend update with a new value.
        wstates = WStates()
        self.session_state._new_widget_state = wstates

        WIDGET_VALUE = 123

        metadata = WidgetMetadata(
            id=f"{GENERATED_ELEMENT_ID_PREFIX}-0-widget_id_1",
            deserializer=lambda _, __: WIDGET_VALUE,
            serializer=identity,
            value_type="int_value",
        )
        wsr = self.session_state.register_widget(
            metadata=metadata,
            user_key="widget_id_1",
        )
        assert not wsr.value_changed
        assert self.session_state["widget_id_1"] == WIDGET_VALUE

    def test_detect_unserializable(self):
        # Doesn't error when only serializable data is present
        self.session_state._check_serializable()

        def nested():
            return lambda x: x

        lam_func = nested()
        self.session_state["unserializable"] = lam_func
        with pytest.raises(UnserializableSessionStateError):
            self.session_state._check_serializable()


@given(state=stst.session_state())
@settings(deadline=400)
def test_compact_idempotent(state):
    assert _compact_copy(state) == _compact_copy(_compact_copy(state))


@given(state=stst.session_state())
@settings(deadline=400)
def test_compact_len(state):
    assert len(state) >= len(_compact_copy(state))


@given(state=stst.session_state())
@settings(deadline=400)
def test_compact_presence(state):
    assert _sorted_items(state) == _sorted_items(_compact_copy(state))


@given(
    m=stst.session_state(),
    key=stst.USER_KEY,
    value1=hst.integers(),
    value2=hst.integers(),
)
def test_map_set_set(m, key, value1, value2):
    m[key] = value1
    l1 = len(m)
    m[key] = value2
    assert m[key] == value2
    assert len(m) == l1


@given(m=stst.session_state(), key=stst.USER_KEY, value1=hst.integers())
def test_map_set_del(m, key, value1):
    m[key] = value1
    l1 = len(m)
    del m[key]
    assert key not in m
    assert len(m) == l1 - 1


@given(state=stst.session_state())
def test_key_wid_lookup_equiv(state: SessionState):
    k_wid_map = state._key_id_mapper._key_id_mapping
    for k, wid in k_wid_map.items():
        assert state[k] == state[wid]


def test_map_set_del_3837_regression():
    """A regression test for `test_map_set_del` that involves too much setup
    to conveniently use the hypothesis `example` decorator."""

    meta1 = stst.mock_metadata(
        "   $$GENERATED_WIDGET_ID-e3e70682-c209-4cac-629f-6fbed82c07cd-None", 0
    )
    meta2 = stst.mock_metadata(
        "$$GENERATED_WIDGET_ID-f728b4fa-4248-5e3a-0a5d-2f346baa9455-0", 0
    )
    m = SessionState()
    m["0"] = 0
    m.register_widget(metadata=meta1, user_key=None)
    m._compact_state()

    m.register_widget(metadata=meta2, user_key="0")
    key = "0"
    value1 = 0

    m[key] = value1
    l1 = len(m)
    del m[key]
    assert key not in m
    assert len(m) == l1 - 1


class IsStaleWidgetTests(unittest.TestCase):
    def test_is_stale_widget_metadata_is_None(self):
        assert _is_stale_widget(None, {}, {})

    def test_is_stale_widget_active_id(self):
        metadata = WidgetMetadata(
            id="widget_id_1",
            deserializer=lambda x, s: str(x),
            serializer=lambda x: int(x),
            value_type="int_value",
        )
        assert not _is_stale_widget(metadata, {"widget_id_1"}, {})

    def test_is_stale_widget_unrelated_fragment(self):
        metadata = WidgetMetadata(
            id="widget_id_1",
            deserializer=lambda x, s: str(x),
            serializer=lambda x: int(x),
            value_type="int_value",
            fragment_id="my_fragment",
        )
        assert not _is_stale_widget(metadata, {"widget_id_2"}, {"some_other_fragment"})

    def test_is_stale_widget_actually_stale_fragment(self):
        metadata = WidgetMetadata(
            id="widget_id_1",
            deserializer=lambda x, s: str(x),
            serializer=lambda x: int(x),
            value_type="int_value",
            fragment_id="my_fragment",
        )
        assert _is_stale_widget(metadata, {"widget_id_2"}, {"my_fragment"})

    def test_is_stale_widget_actually_stale_no_fragment(self):
        metadata = WidgetMetadata(
            id="widget_id_1",
            deserializer=lambda x, s: str(x),
            serializer=lambda x: int(x),
            value_type="int_value",
            fragment_id="my_fragment",
        )
        assert _is_stale_widget(metadata, {"widget_id_2"}, {})


class SessionStateStatProviderTests(DeltaGeneratorTestCase):
    def test_session_state_stats(self):
        # TODO: document the values used here. They're somewhat arbitrary -
        #  we don't care about actual byte values, but rather that our
        #  SessionState isn't getting unexpectedly massive.
        state = _raw_session_state()
        stat = state.get_stats()[0]
        assert stat.category_name == "st_session_state"

        # The expected size of the session state in bytes.
        # It composes of the session_state's fields.
        expected_session_state_size_bytes = 3000

        init_size = stat.byte_length
        assert init_size < expected_session_state_size_bytes

        state["foo"] = 2
        new_size = state.get_stats()[0].byte_length
        assert new_size > init_size
        assert new_size < expected_session_state_size_bytes

        state["foo"] = 1
        new_size_2 = state.get_stats()[0].byte_length
        assert new_size_2 == new_size

        st.checkbox("checkbox", key="checkbox")
        new_size_3 = state.get_stats()[0].byte_length
        assert new_size_3 > new_size_2
        assert new_size_3 - new_size_2 < expected_session_state_size_bytes

        state._compact_state()
        new_size_4 = state.get_stats()[0].byte_length
        assert new_size_4 <= new_size_3


class KeyIdMapperTest(unittest.TestCase):
    def test_key_id_mapping(self):
        key_id_mapper = KeyIdMapper()
        key_id_mapper.set_key_id_mapping({"key": "wid"})
        assert key_id_mapper.get_id_from_key("key") == "wid"
        assert key_id_mapper.get_key_from_id("wid") == "key"

    def test_key_id_mapping_errors(self):
        key_id_mapper = KeyIdMapper()
        key_id_mapper.set_key_id_mapping({"key": "wid"})
        assert key_id_mapper.get_id_from_key("nonexistent") is None
        with pytest.raises(KeyError):
            key_id_mapper.get_key_from_id("nonexistent")

    def test_key_id_mapping_clear(self):
        key_id_mapper = KeyIdMapper()
        key_id_mapper.set_key_id_mapping({"key": "wid"})
        assert key_id_mapper.get_id_from_key("key") == "wid"
        assert key_id_mapper.get_key_from_id("wid") == "key"
        key_id_mapper.clear()
        assert key_id_mapper.get_id_from_key("key") is None
        with pytest.raises(KeyError):
            key_id_mapper.get_key_from_id("wid")

    def test_key_id_mapping_delete(self):
        key_id_mapper = KeyIdMapper()
        key_id_mapper.set_key_id_mapping({"key": "wid"})
        assert key_id_mapper.get_id_from_key("key") == "wid"
        assert key_id_mapper.get_key_from_id("wid") == "key"
        del key_id_mapper["key"]
        assert key_id_mapper.get_id_from_key("key") is None
        with pytest.raises(KeyError):
            key_id_mapper.get_key_from_id("wid")

    def test_key_id_mapping_set_key_id_mapping(self):
        key_id_mapper = KeyIdMapper()
        key_id_mapper.set_key_id_mapping({"key": "wid"})
        key_id_mapper["key2"] = "wid2"
        assert key_id_mapper.get_id_from_key("key") == "wid"
        assert key_id_mapper.get_key_from_id("wid") == "key"
        assert key_id_mapper.get_id_from_key("key2") == "wid2"
        assert key_id_mapper.get_key_from_id("wid2") == "key2"

    def test_key_id_mapping_update(self):
        key_id_mapper = KeyIdMapper()
        key_id_mapper.set_key_id_mapping({"key": "wid"})
        assert key_id_mapper.get_id_from_key("key") == "wid"
        assert key_id_mapper.get_key_from_id("wid") == "key"

        key_id_mapper2 = KeyIdMapper()
        key_id_mapper2.set_key_id_mapping({"key2": "wid2"})
        key_id_mapper.update(key_id_mapper2)
        assert key_id_mapper.get_id_from_key("key2") == "wid2"
        assert key_id_mapper.get_key_from_id("wid2") == "key2"

        key_id_mapper3 = KeyIdMapper()
        key_id_mapper3.set_key_id_mapping({"key": "wid3"})
        key_id_mapper.update(key_id_mapper3)
        assert key_id_mapper.get_id_from_key("key") == "wid3"
        assert key_id_mapper.get_key_from_id("wid3") == "key"
        assert key_id_mapper.get_id_from_key("key2") == "wid2"
        assert key_id_mapper.get_key_from_id("wid2") == "key2"
        assert key_id_mapper.get_id_from_key("key") == "wid3"
        assert key_id_mapper.get_key_from_id("wid") == "key"


================================================
File: /lib/tests/streamlit/runtime/state/strategies.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from hypothesis import strategies as hst

from streamlit.runtime.state.common import GENERATED_ELEMENT_ID_PREFIX
from streamlit.runtime.state.session_state import SessionState, WidgetMetadata

ASCII = list("abcdefghijklmnopqrstuvwxyz0123456789_-")

USER_KEY = hst.one_of(hst.text(alphabet=ASCII, min_size=1), hst.integers().map(str))

NEW_SESSION_STATE = hst.dictionaries(keys=USER_KEY, values=hst.integers())

UNKEYED_WIDGET_IDS = hst.uuids().map(
    lambda s: f"{GENERATED_ELEMENT_ID_PREFIX}-{s}-None"
)


def as_keyed_widget_id(raw_wid, key):
    return f"{GENERATED_ELEMENT_ID_PREFIX}-{raw_wid}-{key}"


def mock_metadata(widget_id: str, default_value: int) -> WidgetMetadata:
    return WidgetMetadata(
        id=widget_id,
        deserializer=lambda x, s: default_value if x is None else x,
        serializer=lambda x: x,
        value_type="int_value",
    )


@hst.composite
def _session_state(draw) -> SessionState:
    state = SessionState()
    new_state = draw(NEW_SESSION_STATE)
    for k, v in new_state.items():
        state[k] = v

    unkeyed_widgets = draw(
        hst.dictionaries(keys=UNKEYED_WIDGET_IDS, values=hst.integers())
    )
    for wid, v in unkeyed_widgets.items():
        state.register_widget(mock_metadata(wid, v), user_key=None)

    widget_key_val_triple = draw(
        hst.lists(hst.tuples(hst.uuids(), USER_KEY, hst.integers()))
    )
    k_wids = {
        key: (as_keyed_widget_id(wid, key), val)
        for wid, key, val in widget_key_val_triple
    }
    for key, (wid, val) in k_wids.items():
        state.register_widget(mock_metadata(wid, val), user_key=key)

    if k_wids:
        session_state_widget_entries = draw(
            hst.dictionaries(
                keys=hst.sampled_from(list(k_wids.keys())),
                values=hst.integers(),
            )
        )
        for k, v in session_state_widget_entries.items():
            state[k] = v

    return state


def _merge_states(a: SessionState, b: SessionState) -> None:
    """Merge 'b' into 'a'."""
    a._new_session_state.update(b._new_session_state)
    a._new_widget_state.update(b._new_widget_state)
    a._old_state.update(b._old_state)
    a._key_id_mapper.update(b._key_id_mapper)


# TODO: don't generate states where there is a k-wid mapping where the key exists but the widget doesn't
@hst.composite
def session_state(draw) -> SessionState:
    state = draw(_session_state())

    state._compact_state()
    # round 2

    state2 = draw(_session_state())

    _merge_states(state, state2)

    return state


================================================
File: /lib/tests/streamlit/runtime/state/widgets_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests widget-related functionality"""

import inspect
import unittest
from dataclasses import dataclass
from typing import get_args
from unittest.mock import ANY, MagicMock, call, patch

from parameterized import parameterized

import streamlit as st
from streamlit import errors
from streamlit.elements.lib.utils import (
    _compute_element_id,
    compute_and_register_element_id,
)
from streamlit.proto.Common_pb2 import StringTriggerValue as StringTriggerValueProto
from streamlit.proto.WidgetStates_pb2 import WidgetState, WidgetStates
from streamlit.runtime.scriptrunner_utils.script_requests import _coalesce_widget_states
from streamlit.runtime.scriptrunner_utils.script_run_context import get_script_run_ctx
from streamlit.runtime.state.common import (
    GENERATED_ELEMENT_ID_PREFIX,
    ValueFieldName,
)
from streamlit.runtime.state.session_state import SessionState, WidgetMetadata
from streamlit.runtime.state.widgets import (
    register_widget_from_metadata,
    user_key_from_element_id,
)
from tests.delta_generator_test_case import DeltaGeneratorTestCase
from tests.streamlit.element_mocks import ELEMENT_PRODUCER, WIDGET_ELEMENTS


def _create_widget(id, states):
    states.widgets.add().id = id
    return states.widgets[-1]


def create_metadata(id, value_type):
    return WidgetMetadata(id, lambda x, s: x, identity, value_type)


def identity(x):
    return x


class WidgetManagerTests(unittest.TestCase):
    def test_get(self):
        states = WidgetStates()

        _create_widget("trigger", states).trigger_value = True
        _create_widget("bool", states).bool_value = True
        _create_widget("float", states).double_value = 0.5
        _create_widget("int", states).int_value = 123
        _create_widget("string", states).string_value = "howdy!"

        session_state = SessionState()
        session_state.set_widgets_from_proto(states)

        session_state._set_widget_metadata(create_metadata("trigger", "trigger_value"))
        session_state._set_widget_metadata(create_metadata("bool", "bool_value"))
        session_state._set_widget_metadata(create_metadata("float", "double_value"))
        session_state._set_widget_metadata(create_metadata("int", "int_value"))
        session_state._set_widget_metadata(create_metadata("string", "string_value"))

        self.assertEqual(True, session_state["trigger"])
        self.assertEqual(True, session_state["bool"])
        self.assertAlmostEqual(0.5, session_state["float"])
        self.assertEqual(123, session_state["int"])
        self.assertEqual("howdy!", session_state["string"])

    def test_get_nonexistent(self):
        session_state = SessionState()
        self.assertRaises(KeyError, lambda: session_state["fake_widget_id"])

    def test_get_prev_widget_value_nonexistent(self):
        session_state = SessionState()
        self.assertRaises(KeyError, lambda: session_state["fake_widget_id"])

    def test_set_widget_attrs_nonexistent(self):
        session_state = SessionState()
        session_state._set_widget_metadata(create_metadata("fake_widget_id", ""))

        self.assertIsInstance(
            session_state._new_widget_state.widget_metadata["fake_widget_id"],
            WidgetMetadata,
        )

    def test_call_callbacks(self):
        """Test the call_callbacks method in 6 possible cases:

        1. A widget does not have a callback
        2. A widget's old and new values are equal, so the callback is not
           called.
        3. A widget's callback has no args provided.
        4. A widget's callback has just args provided.
        5. A widget's callback has just kwargs provided.
        6. A widget's callback has both args and kwargs provided.
        """
        prev_states = WidgetStates()
        _create_widget("trigger", prev_states).trigger_value = True
        _create_widget("bool", prev_states).bool_value = True
        _create_widget("bool2", prev_states).bool_value = True
        _create_widget("float", prev_states).double_value = 0.5
        _create_widget("int", prev_states).int_value = 123
        _create_widget("string", prev_states).string_value = "howdy!"

        session_state = SessionState()
        session_state.set_widgets_from_proto(prev_states)

        mock_callback = MagicMock()

        def deserializer(x, s):
            return x

        callback_cases = [
            ("trigger", "trigger_value", None, None, None),
            ("bool", "bool_value", mock_callback, None, None),
            ("bool2", "bool_value", mock_callback, None, None),
            ("float", "double_value", mock_callback, (1,), None),
            ("int", "int_value", mock_callback, None, {"x": 2}),
            ("string", "string_value", mock_callback, (1,), {"x": 2}),
        ]
        for widget_id, value_type, callback, args, kwargs in callback_cases:
            session_state._set_widget_metadata(
                WidgetMetadata(
                    widget_id,
                    deserializer,
                    lambda x: x,
                    value_type=value_type,
                    callback=callback,
                    callback_args=args,
                    callback_kwargs=kwargs,
                )
            )

        states = WidgetStates()
        _create_widget("trigger", states).trigger_value = True
        _create_widget("bool", states).bool_value = True
        _create_widget("bool2", states).bool_value = False
        _create_widget("float", states).double_value = 1.5
        _create_widget("int", states).int_value = 321
        _create_widget("string", states).string_value = "!ydwoh"

        session_state.on_script_will_rerun(states)

        mock_callback.assert_has_calls([call(), call(1), call(x=2), call(1, x=2)])

    def test_marshall_excludes_widgets_without_state(self):
        widget_states = WidgetStates()
        _create_widget("trigger", widget_states).trigger_value = True

        session_state = SessionState()
        session_state.set_widgets_from_proto(widget_states)
        session_state._set_widget_metadata(
            WidgetMetadata("other_widget", lambda x, s: x, None, "trigger_value", True)
        )

        widgets = session_state.get_widget_states()

        self.assertEqual(len(widgets), 1)
        self.assertEqual(widgets[0].id, "trigger")

    def test_reset_triggers(self):
        states = WidgetStates()
        session_state = SessionState()

        _create_widget("trigger", states).trigger_value = True
        _create_widget("int", states).int_value = 123
        session_state.set_widgets_from_proto(states)
        session_state._set_widget_metadata(
            WidgetMetadata("trigger", lambda x, s: x, None, "trigger_value")
        )
        session_state._set_widget_metadata(
            WidgetMetadata("int", lambda x, s: x, None, "int_value")
        )

        self.assertTrue(session_state["trigger"])
        self.assertEqual(123, session_state["int"])

        session_state._reset_triggers()

        self.assertFalse(session_state["trigger"])
        self.assertEqual(123, session_state["int"])

    def test_reset_string_triggers(self):
        states = WidgetStates()
        session_state = SessionState()

        _create_widget("string_trigger", states).string_trigger_value.CopyFrom(
            StringTriggerValueProto(data="Some Value")
        )
        _create_widget("int", states).int_value = 123
        session_state.set_widgets_from_proto(states)
        session_state._set_widget_metadata(
            WidgetMetadata(
                "string_trigger", lambda x, s: x, None, "string_trigger_value"
            )
        )
        session_state._set_widget_metadata(
            WidgetMetadata("int", lambda x, s: x, None, "int_value")
        )

        self.assertEqual("Some Value", session_state["string_trigger"].data)
        self.assertEqual(123, session_state["int"])

        session_state._reset_triggers()

        self.assertIsNone(session_state["string_trigger"])
        self.assertEqual(123, session_state["int"])

    def test_coalesce_widget_states(self):
        session_state = SessionState()

        old_states = WidgetStates()

        _create_widget("old_set_trigger", old_states).trigger_value = True
        _create_widget("old_unset_trigger", old_states).trigger_value = False
        _create_widget(
            "old_set_string_trigger", old_states
        ).string_trigger_value.CopyFrom(StringTriggerValueProto(data="Some String"))
        _create_widget(
            "old_set_empty_string_trigger", old_states
        ).string_trigger_value.CopyFrom(StringTriggerValueProto(data=""))
        _create_widget(
            "old_unset_string_trigger", old_states
        ).string_trigger_value.CopyFrom(StringTriggerValueProto(data=None))
        _create_widget("missing_in_new", old_states).int_value = 123
        _create_widget("shape_changing_trigger", old_states).trigger_value = True
        _create_widget(
            "overwritten_string_trigger", old_states
        ).string_trigger_value.CopyFrom(StringTriggerValueProto(data="old string"))

        session_state._set_widget_metadata(
            create_metadata("old_set_trigger", "trigger_value")
        )
        session_state._set_widget_metadata(
            create_metadata("old_unset_trigger", "trigger_value")
        )
        session_state._set_widget_metadata(
            create_metadata("old_set_string_trigger", "string_trigger_value")
        )
        session_state._set_widget_metadata(
            create_metadata("old_set_empty_string_trigger", "string_trigger_value")
        )
        session_state._set_widget_metadata(
            create_metadata("old_unset_string_trigger", "string_trigger_value")
        )
        session_state._set_widget_metadata(
            create_metadata("missing_in_new", "int_value")
        )
        session_state._set_widget_metadata(
            create_metadata("shape changing trigger", "trigger_value")
        )
        session_state._set_widget_metadata(
            create_metadata("overwritten_string_trigger", "string_trigger_value")
        )

        new_states = WidgetStates()

        _create_widget("old_set_trigger", new_states).trigger_value = False
        _create_widget("new_set_trigger", new_states).trigger_value = True
        _create_widget(
            "old_set_string_trigger", new_states
        ).string_trigger_value.CopyFrom(StringTriggerValueProto(data=None))
        _create_widget(
            "old_set_empty_string_trigger", new_states
        ).string_trigger_value.CopyFrom(StringTriggerValueProto(data=None))
        _create_widget(
            "new_set_string_trigger", new_states
        ).string_trigger_value.CopyFrom(
            StringTriggerValueProto(data="Some other string")
        )
        _create_widget("added_in_new", new_states).int_value = 456
        _create_widget("shape_changing_trigger", new_states).int_value = 3
        _create_widget(
            "overwritten_string_trigger", new_states
        ).string_trigger_value.CopyFrom(
            StringTriggerValueProto(data="Overwritten string")
        )

        session_state._set_widget_metadata(
            create_metadata("new_set_trigger", "trigger_value")
        )
        session_state._set_widget_metadata(
            create_metadata("new_set_string_trigger", "string_trigger_value")
        )
        session_state._set_widget_metadata(create_metadata("added_in_new", "int_value"))
        session_state._set_widget_metadata(
            create_metadata("shape_changing_trigger", "int_value")
        )

        session_state.set_widgets_from_proto(
            _coalesce_widget_states(old_states, new_states)
        )

        self.assertRaises(KeyError, lambda: session_state["old_unset_trigger"])
        self.assertRaises(KeyError, lambda: session_state["missing_in_new"])
        self.assertRaises(KeyError, lambda: session_state["old_unset_string_trigger"])

        self.assertEqual(True, session_state["old_set_trigger"])
        self.assertEqual(True, session_state["new_set_trigger"])
        self.assertEqual(456, session_state["added_in_new"])
        self.assertEqual("Some String", session_state["old_set_string_trigger"].data)
        self.assertEqual("", session_state["old_set_empty_string_trigger"].data)
        self.assertEqual(
            "Some other string", session_state["new_set_string_trigger"].data
        )
        self.assertEqual(
            "Overwritten string", session_state["overwritten_string_trigger"].data
        )

        # Widgets that were triggers before, but no longer are, will *not*
        # be coalesced
        self.assertEqual(3, session_state["shape_changing_trigger"])

    def coalesce_widget_states_returns_None_if_both_inputs_None(self):
        assert _coalesce_widget_states(None, None) is None

    def coalesce_widget_states_returns_old_states_if_new_states_None(self):
        old_states = WidgetStates()
        assert _coalesce_widget_states(old_states, None) is old_states

    def coalesce_widget_states_returns_new_states_if_old_states_None(self):
        new_states = WidgetStates()
        assert _coalesce_widget_states(None, new_states) is new_states


class WidgetHelperTests(unittest.TestCase):
    def test_get_widget_with_generated_key(self):
        element_id = compute_and_register_element_id(
            "button", label="the label", user_key="my_key", form_id=None
        )
        assert element_id.startswith(GENERATED_ELEMENT_ID_PREFIX)


# These kwargs are not supposed to be used for element ID calculation:
EXCLUDED_KWARGS_FOR_ELEMENT_ID_COMPUTATION = {
    # Internal stuff
    "ctx",
    # Formatting/display stuff: can be changed without resetting an element.
    "disabled",
    "format_func",
    "label_visibility",
    # on_change callbacks and similar/related parameters.
    "args",
    "kwargs",
    "on_change",
    "on_click",
    "on_submit",
    # Key should be provided via `user_key` instead.
    "key",
}


class ComputeElementIdTests(DeltaGeneratorTestCase):
    """Enforce that new arguments added to the signature of a widget function are taken
    into account when computing element IDs unless explicitly excluded.
    """

    def signature_to_expected_kwargs(self, sig):
        kwargs = {
            kwarg: ANY
            for kwarg in sig.parameters.keys()
            if kwarg not in EXCLUDED_KWARGS_FOR_ELEMENT_ID_COMPUTATION
        }

        # Add some kwargs that are passed to compute element ID
        # but don't appear in widget signatures.
        for kwarg in ["form_id", "user_key"]:
            kwargs[kwarg] = ANY

        return kwargs

    @parameterized.expand(WIDGET_ELEMENTS)
    def test_no_usage_of_excluded_kwargs(
        self, _element_name: str, widget_func: ELEMENT_PRODUCER
    ):
        with patch(
            "streamlit.elements.lib.utils._compute_element_id",
            wraps=_compute_element_id,
        ) as patched_compute_element_id:
            widget_func()

        # Get call kwargs from patched_compute_element_id
        call_kwargs = patched_compute_element_id.call_args[1]

        kwargs_intersection = set(call_kwargs.keys()) & set(
            EXCLUDED_KWARGS_FOR_ELEMENT_ID_COMPUTATION
        )
        assert not kwargs_intersection, (
            "These kwargs are not supposed to be used for element ID calculation: "
            + str(kwargs_intersection)
        )

    @parameterized.expand(WIDGET_ELEMENTS)
    def test_includes_essential_kwargs(self, element_name: str, widget_func):
        """Test that active_script_hash and form ID are always included in
        element ID calculation."""

        expected_form_id: str | None = "form_id"

        @dataclass
        class MockForm:
            form_id = expected_form_id

        with patch(
            "streamlit.elements.lib.utils._compute_element_id",
            wraps=_compute_element_id,
        ) as patched_compute_element_id:
            # Some elements cannot be used in a form:
            if element_name not in ["button", "chat_input", "download_button"]:
                with patch(
                    "streamlit.elements.lib.form_utils._current_form",
                    return_value=MockForm(),
                ):
                    widget_func()
            else:
                widget_func()
                expected_form_id = None

        # Get call kwargs from patched_compute_element_id
        call_kwargs = patched_compute_element_id.call_args[1]
        assert (
            "active_script_hash" in call_kwargs
        ), "active_script_hash is expected to always be included "
        "in element ID calculation."

        # Elements that don't set a form ID
        assert (
            call_kwargs.get("form_id") == expected_form_id
        ), "form_id is expected to be included in element ID calculation."

    @parameterized.expand(WIDGET_ELEMENTS)
    def test_triggers_duplicate_id_error(self, _element_name: str, widget_func):
        """
        Test that duplicate ID error is raised if the same widget is called twice.
        """
        widget_func()
        with self.assertRaises(errors.DuplicateWidgetID):
            widget_func()

    @parameterized.expand(
        [
            (st.camera_input, "camera_input"),
            (st.checkbox, "checkbox"),
            (st.color_picker, "color_picker"),
            (st.date_input, "time_widgets"),
            (st.file_uploader, "file_uploader"),
            (st.number_input, "number_input"),
            (st.slider, "slider"),
            (st.text_area, "text_widgets"),
            (st.text_input, "text_widgets"),
            (st.time_input, "time_widgets"),
        ]
    )
    def test_widget_id_computation(self, widget_func, module_name):
        with patch(
            f"streamlit.elements.widgets.{module_name}.compute_and_register_element_id",
            wraps=compute_and_register_element_id,
        ) as patched_compute_and_register_element_id:
            widget_func("my_widget")

        sig = inspect.signature(widget_func)
        expected_sig = self.signature_to_expected_kwargs(sig)

        patched_compute_and_register_element_id.assert_called_with(ANY, **expected_sig)

        # Double check that we get a DuplicateWidgetID error since the `disabled`
        # argument shouldn't affect a widget's ID.
        with self.assertRaises(errors.DuplicateWidgetID):
            widget_func("my_widget", disabled=True)

    @parameterized.expand(
        [
            (st.button, "button"),
            (st.chat_input, "chat"),
            (st.download_button, "button"),
        ]
    )
    def test_widget_id_computation_no_form_widgets(self, widget_func, module_name):
        with patch(
            f"streamlit.elements.widgets.{module_name}.compute_and_register_element_id",
            wraps=compute_and_register_element_id,
        ) as patched_compute_and_register_element_id:
            if widget_func == st.download_button:
                widget_func("my_widget", data="")
            else:
                widget_func("my_widget")

        sig = inspect.signature(widget_func)
        expected_sig = self.signature_to_expected_kwargs(sig)

        if widget_func == st.button:
            expected_sig["is_form_submitter"] = ANY
        # we exclude `data` for `st.download_button` here and not
        # in `signature_to_expected_kwargs`, because `data` param is also used for
        # `st.data_editor`.
        if widget_func == st.download_button:
            del expected_sig["data"]

        patched_compute_and_register_element_id.assert_called_with(ANY, **expected_sig)

    @parameterized.expand(
        [
            (
                # define a lambda that matches the signature of what button_group is
                # passing to compute_and_register_element_id, because st.feedback does
                # not take a label and its arguments are different.
                lambda key,
                options,
                disabled=False,
                default=[],
                click_mode=0,
                style="": st.feedback("stars", disabled=disabled),
                "button_group",
            ),
            (
                # define a lambda that matches the signature of what button_group is
                # passing to compute_and_register_element_id, because st.pills does
                # not take a label and its arguments are different.
                lambda key,
                options,
                disabled=False,
                default=[],
                click_mode=0,
                style="": st.pills("some_label", options, disabled=disabled),
                "button_group",
            ),
            (
                # define a lambda that matches the signature of what button_group is
                # passing to compute_and_register_element_id, because st.feedback does
                # not take a label and its arguments are different.
                lambda key,
                options,
                disabled=False,
                default=[],
                click_mode=0,
                style="": st.segmented_control(
                    "some_label", options, disabled=disabled
                ),
                "button_group",
            ),
            (st.multiselect, "multiselect"),
            (st.radio, "radio"),
            (st.select_slider, "select_slider"),
            (st.selectbox, "selectbox"),
        ]
    )
    def test_widget_id_computation_options_widgets(self, widget_func, module_name):
        options = ["a", "b", "c"]

        with patch(
            f"streamlit.elements.widgets.{module_name}.compute_and_register_element_id",
            wraps=compute_and_register_element_id,
        ) as patched_compute_and_register_element_id:
            widget_func("my_widget", options)

        sig = inspect.signature(widget_func)
        patched_compute_and_register_element_id.assert_called_with(
            ANY, **self.signature_to_expected_kwargs(sig)
        )

        # Double check that we get a DuplicateWidgetID error since the `disabled`
        # argument shouldn't affect a widget's ID.
        with self.assertRaises(errors.DuplicateWidgetID):
            widget_func("my_widget", options, disabled=True)

    def test_widget_id_computation_data_editor(self):
        with patch(
            "streamlit.elements.widgets.data_editor.compute_and_register_element_id",
            wraps=compute_and_register_element_id,
        ) as patched_compute_and_register_element_id:
            st.data_editor(data=[])

        sig = inspect.signature(st.data_editor)
        expected_sig = self.signature_to_expected_kwargs(sig)

        # Make some changes to expected_sig unique to st.data_editor.
        expected_sig["column_config_mapping"] = ANY
        del expected_sig["hide_index"]
        del expected_sig["column_config"]

        patched_compute_and_register_element_id.assert_called_with(ANY, **expected_sig)

        # Double check that we get a DuplicateWidgetID error since the `disabled`
        # argument shouldn't affect a widget's ID.
        with self.assertRaises(errors.DuplicateWidgetID):
            st.data_editor(data=[], disabled=True)


class RegisterWidgetsTest(DeltaGeneratorTestCase):
    @parameterized.expand(WIDGET_ELEMENTS)
    def test_register_widget_called_with_valid_value_type(
        self, _element_name: str, widget_func: ELEMENT_PRODUCER
    ):
        with patch(
            "streamlit.runtime.state.widgets.register_widget_from_metadata",
            wraps=register_widget_from_metadata,
        ) as patched_register_widget_from_metadata:
            widget_func()
        assert patched_register_widget_from_metadata.call_count == 1
        widget_metadata_arg: WidgetMetadata = (
            patched_register_widget_from_metadata.call_args[0][0]
        )
        assert widget_metadata_arg.value_type in get_args(ValueFieldName)
        # test that the value_type also maps to a protobuf field
        assert (
            widget_metadata_arg.value_type
            in WidgetState.DESCRIPTOR.fields_by_name.keys()
        )


@patch("streamlit.runtime.Runtime.exists", new=MagicMock(return_value=True))
class WidgetUserKeyTests(DeltaGeneratorTestCase):
    def test_get_widget_user_key(self):
        state = get_script_run_ctx().session_state._state
        st.checkbox("checkbox", key="c")

        k = list(state._keys())[0]
        assert user_key_from_element_id(k) == "c"

    def test_get_widget_user_key_none(self):
        state = get_script_run_ctx().session_state._state
        st.selectbox("selectbox", options=["foo", "bar"])

        k = list(state._keys())[0]
        # Absence of a user key is represented as None throughout our code
        assert user_key_from_element_id(k) is None

    def test_get_widget_user_key_hyphens(self):
        state = get_script_run_ctx().session_state._state
        st.slider("slider", key="my-slider")

        k = list(state._keys())[0]
        assert user_key_from_element_id(k) == "my-slider"

    def test_get_widget_user_key_incorrect_none(self):
        state = get_script_run_ctx().session_state._state
        st.checkbox("checkbox", key="None")

        k = list(state._keys())[0]
        # Incorrectly inidcates no user key
        assert user_key_from_element_id(k) is None


================================================
File: /lib/tests/streamlit/runtime/state/test_data/linked_sliders.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st


def to_celsius(fahrenheit):
    return (fahrenheit - 32) * 5.0 / 9.0


def to_fahrenheit(celsius):
    return 9.0 / 5.0 * celsius + 32


MIN_CELSIUS, MAX_CELSIUS = -100.0, 100.0

state = st.session_state

if "celsius" not in st.session_state:
    state.celsius = MIN_CELSIUS
    state.fahrenheit = to_fahrenheit(MIN_CELSIUS)


# Callbacks if something changes
def celsius_changed():
    state.fahrenheit = to_fahrenheit(state.celsius)


def fahrenheit_changed():
    state.celsius = to_celsius(state.fahrenheit)


# Display the sliders.
st.slider(
    "Celsius",
    min_value=MIN_CELSIUS,
    max_value=MAX_CELSIUS,
    on_change=celsius_changed,
    key="celsius",
)

st.slider(
    "Fahrenheit",
    min_value=to_fahrenheit(MIN_CELSIUS),
    max_value=to_fahrenheit(MAX_CELSIUS),
    on_change=fahrenheit_changed,
    key="fahrenheit",
)

st.write("Celsius", state.celsius)
st.write("Fahrenheit", state.fahrenheit)


================================================
File: /lib/tests/streamlit/test_data/cached_widget_replay.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import streamlit as st

st.button("click to rerun")


@st.cache_data(experimental_allow_widgets=True, show_spinner=False)
def foo(i):
    options = ["foo", "bar", "baz", "qux"]
    r = st.radio("radio", options, index=i)
    return r


r = foo(1)
st.text(r)


================================================
File: /lib/tests/streamlit/test_data/widgets_script.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from __future__ import annotations

import streamlit as st

c1, c2 = st.columns(2)

with c1:
    checkbox = st.checkbox("checkbox", False)
    st.text("%s" % checkbox)

    text_area = st.text_area("text_area", "ahoy!")
    st.text("%s" % text_area)

with c2:
    radio = st.radio("radio", ("0", "1", "2"), 1)
    st.text("%s" % radio)

button = st.button("button")
st.text("%s" % button)

st.sidebar.radio("sidebar radio", ["a", "b"])


================================================
File: /lib/tests/streamlit/testing/app_test_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from pathlib import Path

import pytest

from streamlit.testing.v1 import AppTest


def test_smoke():
    def script():
        import streamlit as st

        st.radio("radio", options=["a", "b", "c"], key="r")
        st.radio("default index", options=["a", "b", "c"], index=2)

    at = AppTest.from_function(script).run()
    assert at.radio
    assert at.radio[0].value == "a"
    assert at.radio(key="r").value == "a"
    assert at.radio.values == ["a", "c"]

    r = at.radio[0].set_value("b")
    assert r.index == 1
    assert r.value == "b"
    at = r.run()
    assert at.radio[0].value == "b"
    assert at.radio.values == ["b", "c"]


def test_from_file_str():
    script = AppTest.from_file("../test_data/widgets_script.py")
    script.run()


def test_from_file_path():
    script = AppTest.from_file(Path("../test_data/widgets_script.py"))
    script.run()


def test_get_query_params():
    def script():
        import streamlit as st

        st.write(st.experimental_get_query_params())

    at = AppTest.from_function(script).run()
    assert at.json[0].value == "{}"
    at.query_params["foo"] = 5
    at.query_params["bar"] = "baz"
    at.run()
    assert at.json[0].value == '{"foo": ["5"], "bar": ["baz"]}'


def test_set_query_params():
    def script():
        import streamlit as st

        st.experimental_set_query_params(foo="bar")

    at = AppTest.from_function(script).run()
    # parse.parse_qs puts everything in lists
    assert at.query_params["foo"] == ["bar"]


def test_secrets():
    def script():
        import streamlit as st

        st.write(st.secrets["foo"])

    at = AppTest.from_function(script)
    at.secrets["foo"] = "bar"
    at.run()
    assert at.markdown[0].value == "bar"
    assert at.secrets["foo"] == "bar"


def test_7636_regression():
    def repro():
        import streamlit as st

        st.container()

    at = AppTest.from_function(repro).run()

    repr(at)


def test_widget_added_removed():
    """
    Test that the value of a widget persists, disappears, and resets
    appropriately, as the widget is added and removed from the script execution.
    """

    def script():
        import streamlit as st

        cb = st.radio("radio emulating a checkbox", options=["off", "on"], key="cb")
        if cb == "on":
            st.radio("radio", options=["a", "b", "c"], key="conditional")

    at = AppTest.from_function(script).run()
    assert len(at.radio) == 1
    with pytest.raises(KeyError):
        at.radio(key="conditional")

    at.radio(key="cb").set_value("on").run()
    assert len(at.radio) == 2
    assert at.radio(key="conditional").value == "a"

    at.radio(key="conditional").set_value("c").run()
    assert len(at.radio) == 2
    assert at.radio(key="conditional").value == "c"

    at.radio(key="cb").set_value("off").run()
    assert len(at.radio) == 1
    with pytest.raises(KeyError):
        at.radio(key="conditional")

    at.radio(key="cb").set_value("on").run()
    assert len(at.radio) == 2
    assert at.radio(key="conditional").value == "a"


def test_query_narrowing():
    def script():
        import streamlit as st

        st.text("1")
        with st.expander("open"):
            st.text("2")
            st.text("3")
        st.text("4")

    at = AppTest.from_function(script).run()
    assert at.text.len == 4
    # querying elements via a block only returns the elements in that block
    assert at.expander[0].text.len == 2


def test_out_of_order_blocks() -> None:
    # Regression test for #7711
    def script():
        import streamlit as st

        container = st.container()
        with container:
            st.markdown("BarFoo")

            def button_one_clicked(cont):
                cont.info("Hi!")
                cont.markdown("FooBar")

            st.button("one", on_click=button_one_clicked, args=[container])

    at = AppTest.from_function(script).run()

    at.button[0].click().run()

    assert at.markdown.len == 2
    assert at.info[0].value == "Hi!"
    assert at.markdown.values == ["FooBar", "BarFoo"]


def test_from_function_kwargs():
    def script(foo, baz):
        import streamlit as st

        st.text(foo)
        st.text(baz)
        return foo

    at = AppTest.from_function(script, args=("bar",), kwargs={"baz": "baz"}).run()
    assert at.text.values == ["bar", "baz"]


def test_trigger_recursion():
    # Regression test for #7768
    def code():
        import time

        import streamlit as st

        if st.button(label="Submit"):
            time.sleep(1)
            st.rerun()

    at = AppTest.from_function(code).run()
    # The script run should finish instead of recurring and timing out
    at.button[0].click().run()


def test_switch_page():
    at = AppTest.from_file("test_data/main.py").run()
    assert at.text[0].value == "main page"

    at.switch_page("pages/page1.py").run()
    assert at.text[0].value == "page 1"

    with pytest.raises(ValueError) as e:
        # Pages must be relative to main script path
        at.switch_page("test_data/pages/page1.py")
        assert "relative to the main script path" in str(e.value)


def test_switch_page_widgets():
    at = AppTest.from_file("test_data/main.py").run()
    at.slider[0].set_value(5).run()
    assert at.slider[0].value == 5

    at.switch_page("pages/page1.py").run()
    assert not at.slider
    at.switch_page("main.py").run()
    assert at.slider[0].value == 0


================================================
File: /lib/tests/streamlit/testing/element_tree_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from datetime import date, datetime, time

import numpy as np
import pandas as pd
import pytest

from streamlit.elements.markdown import MARKDOWN_HORIZONTAL_RULE_EXPRESSION
from streamlit.testing.v1.app_test import AppTest


def test_alert():
    def script():
        import streamlit as st

        st.success("yay we did it", icon="🚨")
        st.info("something happened")
        st.warning("danger danger")
        st.error("something went terribly wrong", icon="💥")

    at = AppTest.from_function(script).run()
    assert at.error[0].value == "something went terribly wrong"
    assert at.error[0].icon == "💥"
    assert at.info[0].value == "something happened"
    assert at.success[0].value == "yay we did it"
    assert at.success[0].icon == "🚨"
    assert at.warning[0].value == "danger danger"

    # Verify that creating the reprs does not throw
    repr(at.error[0])
    repr(at.info[0])
    repr(at.success[0])
    repr(at.warning[0])


def test_button():
    def script():
        import streamlit as st

        st.button("button")
        st.button("second button")

    sr = AppTest.from_function(script).run()
    assert sr.button[0].value is False
    assert sr.button[1].value is False

    sr2 = sr.button[0].click().run()
    assert sr2.button[0].value is True
    assert sr2.button[1].value is False

    sr3 = sr2.run()
    assert sr3.button[0].value is False
    assert sr3.button[1].value is False

    repr(sr.button[0])


def test_chat():
    def script():
        import streamlit as st

        input = st.chat_input(placeholder="Type a thing")
        with st.chat_message("user"):
            st.write(input)

    at = AppTest.from_function(script).run()
    assert at.chat_input[0].value is None
    msg = at.chat_message[0]
    assert msg.name == "user"
    assert msg.markdown[0].value == "`None`"

    at.chat_input[0].set_value("hi").run()
    assert at.chat_input[0].value == "hi"
    assert at.chat_message[0].markdown[0].value == "hi"

    # verify value resets after use
    at.run()
    assert at.chat_input[0].value is None

    # verify reprs
    repr(at.chat_input[0])
    repr(at.chat_message[0])


def test_checkbox():
    def script():
        import streamlit as st

        st.checkbox("defaults")
        st.checkbox("defaulted on", True)

    at = AppTest.from_function(script).run()
    assert at.checkbox[0].label == "defaults"
    assert at.checkbox.values == [False, True]

    at.checkbox[0].check().run()
    assert at.checkbox.values == [True, True]

    at.checkbox[1].uncheck().run()
    assert at.checkbox.values == [True, False]

    repr(at.checkbox[0])


def test_color_picker():
    def script():
        import streamlit as st

        st.color_picker("what is your favorite color?")
        st.color_picker("short hex", value="#ABC")
        st.color_picker("invalid", value="blue")

    at = AppTest.from_function(script).run()
    assert at.color_picker.len == 2
    assert at.color_picker.values == ["#000000", "#ABC"]
    assert "blue" in at.exception[0].value

    at.color_picker[0].pick("#123456").run()
    assert at.color_picker[0].value == "#123456"

    repr(at.color_picker[0])


def test_columns():
    def script():
        import streamlit as st

        c1, c2 = st.columns(2)
        with c1:
            st.text("c1")
        c2.radio("c2", ["a", "b", "c"])

    at = AppTest.from_function(script).run()
    assert len(at.columns) == 2
    assert at.columns[0].weight == at.columns[1].weight
    assert at.columns[0].text[0].value == "c1"
    assert at.columns[1].radio[0].value == "a"

    repr(at.columns[0])


def test_dataframe():
    def script():
        import numpy as np
        import pandas as pd

        import streamlit as st

        df = pd.DataFrame(
            index=[[0, 1], ["i1", "i2"]],
            columns=[[2, 3, 4], ["c1", "c2", "c3"]],
            data=np.arange(0, 6, 1).reshape(2, 3),
        )
        st.dataframe(df)

    at = AppTest.from_function(script).run()
    d = at.dataframe[0]
    assert d.value.equals(
        pd.DataFrame(
            index=[[0, 1], ["i1", "i2"]],
            columns=[[2, 3, 4], ["c1", "c2", "c3"]],
            data=np.arange(0, 6, 1).reshape(2, 3),
        )
    )

    repr(at.dataframe[0])


def test_date_input():
    def script():
        import datetime

        import streamlit as st

        st.date_input("date", value=datetime.date(2023, 4, 17))
        st.date_input("datetime", value=datetime.datetime(2023, 4, 17, 11))
        st.date_input(
            "range", value=(datetime.date(2020, 1, 1), datetime.date(2030, 1, 1))
        )

    at = AppTest.from_function(script).run()
    assert not at.exception
    assert at.date_input.values == [
        date(2023, 4, 17),
        datetime(2023, 4, 17).date(),
        (date(2020, 1, 1), date(2030, 1, 1)),
    ]
    ds = at.date_input
    ds[0].set_value(date(2023, 5, 1))
    ds[1].set_value(datetime(2023, 1, 1))
    ds[2].set_value((date(2023, 1, 1), date(2024, 1, 1)))

    at.run()
    assert at.date_input.values == [
        date(2023, 5, 1),
        date(2023, 1, 1),
        (date(2023, 1, 1), date(2024, 1, 1)),
    ]

    # Verify that creating the reprs does not throw
    repr(at.date_input[0])


def test_exception():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.exception(RuntimeError("foo"))
        """,
    )
    sr = script.run()

    assert sr.exception[0].value == "foo"

    repr(sr.exception[0])


def test_expander():
    def script():
        import streamlit as st

        with st.expander("expander"):
            st.write("some text")

    at = AppTest.from_function(script).run()
    assert at.markdown[0].value == "some text"


def test_markdown_exception():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.exception(st.errors.MarkdownFormattedException("# Oh no"))
        """,
    )
    sr = script.run()

    assert sr.exception[0].is_markdown

    repr(sr.exception[0])


def test_title():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.title("This is a title")
        st.title("This is a title with anchor", anchor="anchor text")
        st.title("This is a title with hidden anchor", anchor=False)
        """,
    )
    sr = script.run()

    assert len(sr.title) == 3
    assert sr.title[1].tag == "h1"
    assert sr.title[1].anchor == "anchor text"
    assert sr.title[1].value == "This is a title with anchor"
    assert sr.title[2].hide_anchor

    repr(sr.title[0])


def test_header():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.header("This is a header")
        st.header("This is a header with anchor", anchor="header anchor text")
        st.header("This is a header with hidden anchor", anchor=False)
        """,
    )
    sr = script.run()

    assert len(sr.header) == 3
    assert sr.header[1].tag == "h2"
    assert sr.header[1].anchor == "header anchor text"
    assert sr.header[1].value == "This is a header with anchor"
    assert sr.header[2].hide_anchor

    repr(sr.header[0])


def test_subheader():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.subheader("This is a subheader")
        st.subheader(
            "This is a subheader with anchor",
            anchor="subheader anchor text"
        )
        st.subheader("This is a subheader with hidden anchor", anchor=False)
        """,
    )
    sr = script.run()

    assert len(sr.subheader) == 3
    assert sr.subheader[1].tag == "h3"
    assert sr.subheader[1].anchor == "subheader anchor text"
    assert sr.subheader[1].value == "This is a subheader with anchor"
    assert sr.subheader[2].hide_anchor

    repr(sr.subheader[0])


def test_heading_elements_by_type():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.title("title1")
        st.header("header1")
        st.subheader("subheader1")

        st.title("title2")
        st.header("header2")
        st.subheader("subheader2")
        """,
    )
    sr = script.run()

    assert len(sr.title) == 2
    assert len(sr.header) == 2
    assert len(sr.subheader) == 2


def test_json():
    def script():
        import streamlit as st

        st.json(["hi", {"foo": "bar"}])

    at = AppTest.from_function(script).run()
    j = at.json[0]
    assert j.value == '["hi", {"foo": "bar"}]'
    assert j.expanded

    repr(j)


def test_markdown():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.markdown("**This is a markdown**")
        """,
    )
    sr = script.run()

    assert sr.markdown
    assert sr.markdown[0].type == "markdown"
    assert sr.markdown[0].value == "**This is a markdown**"

    repr(sr.markdown[0])


def test_caption():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.caption("This is a caption")
        """,
    )
    sr = script.run()

    assert sr.caption
    assert sr.caption[0].type == "caption"
    assert sr.caption[0].value == "This is a caption"
    assert sr.caption[0].is_caption

    repr(sr.caption[0])


def test_code():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.code("import streamlit as st")
        """,
    )
    sr = script.run()

    assert sr.code
    assert sr.code[0].type == "code"
    assert sr.code[0].value == "import streamlit as st"

    repr(sr.code[0])


def test_echo():
    script = AppTest.from_string(
        """
        import streamlit as st

        with st.echo():
            st.write("Hello")
        """
    )

    sr = script.run()

    assert sr.code
    assert sr.code[0].type == "code"
    assert sr.code[0].language == "python"
    assert sr.code[0].value == """st.write("Hello")"""


def test_latex():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.latex("E=mc^2")
        """,
    )
    sr = script.run()

    assert sr.latex
    assert sr.latex[0].type == "latex"
    assert sr.latex[0].value == "$$\nE=mc^2\n$$"

    repr(sr.latex[0])


def test_divider():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.divider()
        """,
    )
    sr = script.run()

    assert sr.divider
    assert sr.divider[0].type == "divider"
    assert sr.divider[0].value == MARKDOWN_HORIZONTAL_RULE_EXPRESSION

    repr(sr.divider[0])


def test_markdown_elements_by_type():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.markdown("**This is a markdown1**")
        st.caption("This is a caption1")
        st.code("print('hello world1')")
        st.latex("sin(2x)=2sin(x)cos(x)")

        st.markdown("**This is a markdown2**")
        st.caption("This is a caption2")
        st.code("print('hello world2')")
        st.latex("cos(2x)=cos^2(x)-sin^2(x)")
        """,
    )
    sr = script.run()

    assert len(sr.markdown) == 2
    assert len(sr.caption) == 2
    assert len(sr.code) == 2
    assert len(sr.latex) == 2


def test_metric():
    def script():
        import streamlit as st

        st.metric("stonks", value=9500, delta=1000)

    at = AppTest.from_function(script).run()
    m = at.metric[0]
    assert m.value == "9500"
    assert m.delta == "1000"

    repr(m)


def test_multiselect():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.multiselect("one", options=["a", "b", "c"])
        st.multiselect("two", options=["zero", "one", "two"], default=["two"])
        """,
    )
    sr = script.run()
    assert sr.multiselect[0].value == []
    assert sr.multiselect[1].value == ["two"]

    sr2 = sr.multiselect[0].select("b").run()
    assert sr2.multiselect[0].value == ["b"]
    assert sr2.multiselect[1].value == ["two"]

    sr3 = sr2.multiselect[1].select("zero").select("one").run()
    assert sr3.multiselect[0].value == ["b"]
    assert set(sr3.multiselect[1].value) == {"zero", "one", "two"}

    sr4 = sr3.multiselect[0].unselect("b").run()
    assert sr4.multiselect[0].value == []
    assert set(sr3.multiselect[1].value) == {"zero", "one", "two"}

    # Verify that creating the reprs does not throw
    repr(sr.multiselect[0])


def test_number_input():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.number_input("int", min_value=-10, max_value=10)
        st.number_input("float", min_value=-1.0, max_value=100.0)
        """,
    )
    sr = script.run()
    assert sr.number_input[0].value == -10
    assert sr.number_input[1].value == -1.0

    sr2 = sr.number_input[0].increment().run().number_input[1].increment().run()
    assert sr2.number_input[0].value == -9
    assert sr2.number_input[1].value == -0.99

    sr3 = sr2.number_input[0].decrement().run().number_input[1].decrement().run()
    assert sr3.number_input[0].value == -10
    assert sr3.number_input[1].value == -1.0

    sr4 = sr3.number_input[0].decrement().run().number_input[1].decrement().run()
    assert sr4.number_input[0].value == -10
    assert sr4.number_input[1].value == -1.0

    repr(sr.number_input[0])


def test_selectbox():
    script = AppTest.from_string(
        """
        import pandas as pd
        import streamlit as st

        options = ("male", "female")
        st.selectbox("selectbox 1", options, 1)
        st.selectbox("selectbox 2", options, 0)
        st.selectbox("selectbox 3", [])

        lst = ['Python', 'C', 'C++', 'Java', 'Scala', 'Lisp', 'JavaScript', 'Go']
        df = pd.DataFrame(lst)
        st.selectbox("selectbox 4", df)
        """,
    )
    sr = script.run()
    assert sr.selectbox[0].value == "female"
    assert sr.selectbox[1].value == "male"
    assert sr.selectbox[2].value is None
    assert sr.selectbox[3].value == "Python"

    sr2 = sr.selectbox[0].select("female").run()
    sr3 = sr2.selectbox[1].select("female").run()
    sr4 = sr3.selectbox[3].select("JavaScript").run()

    assert sr4.selectbox[0].value == "female"
    assert sr4.selectbox[1].value == "female"
    assert sr4.selectbox[2].value is None
    assert sr4.selectbox[3].value == "JavaScript"

    sr5 = sr4.selectbox[0].select_index(0).run()
    sr6 = sr5.selectbox[3].select_index(5).run()
    assert sr6.selectbox[0].value == "male"
    assert sr6.selectbox[3].value == "Lisp"

    with pytest.raises(ValueError):
        sr6.selectbox[0].select("invalid").run()

    with pytest.raises(IndexError):
        sr6.selectbox[0].select_index(42).run()

    repr(sr.selectbox[0])


def test_format_func():
    # Regression test for #8019
    def script():
        import streamlit as st

        key_to_value = {"key1": "value1", "key2": "value2"}
        st.selectbox(
            "selectbox",
            key_to_value.keys(),
            format_func=lambda key: key_to_value[key],
            key="sb",
        )
        st.radio(
            "radio",
            options=["FOO", "BAR", "BAZ"],
            format_func=lambda x: x.lower(),
            key="r",
        )
        st.multiselect(
            "multi",
            options=[1, 2, 3],
            format_func=lambda x: f"Num: {x}",
            key="m",
        )
        st.select_slider(
            "slider",
            options=[1, 2, 3, 5, 8],
            value=[1, 2],
            format_func=lambda x: str(float(x)),
            key="s",
        )

    at = AppTest.from_function(script).run()

    at.selectbox("sb").select("key1").run()
    assert at.selectbox("sb").value == "key1"

    at.radio("r").set_value("FOO").run()
    assert at.radio("r").value == "FOO"

    at.multiselect("m").select(1).select(2).run()
    assert at.multiselect("m").value == [1, 2]

    at.select_slider("s").set_range(2, 5).run()
    assert at.select_slider("s").value == (2, 5)

    assert not at.exception


def test_select_slider():
    script = AppTest.from_string(
        """
        import streamlit as st

        options=['red', 'orange', 'yellow', 'green', 'blue', 'indigo', 'violet']
        st.select_slider("single", options=options, value='green')
        st.select_slider("range", options=options, value=['red', 'blue'])
        """,
    )
    sr = script.run()
    assert sr.select_slider[0].value == "green"
    assert sr.select_slider[1].value == ("red", "blue")

    sr2 = sr.select_slider[0].set_value("violet").run()
    sr3 = sr2.select_slider[1].set_range("yellow", "orange").run()
    assert sr3.select_slider[0].value == "violet"
    assert sr3.select_slider[1].value == ("orange", "yellow")

    repr(sr.select_slider[0])


def test_select_slider_ints():
    def script():
        import streamlit as st

        st.select_slider("What is your favorite small prime?", options=[2, 3, 5, 7])
        st.select_slider(
            "Best number range?", options=list(range(10)), value=[0, 1], key="range"
        )

    at = AppTest.from_function(script).run()
    assert at.select_slider[0].value == 2
    assert at.select_slider[1].value == (0, 1)

    at.select_slider[0].set_value(5)
    at.select_slider[1].set_value([7, 9]).run()
    assert at.select_slider[0].value == 5
    assert at.select_slider[1].value == (7, 9)


def test_access_methods():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.sidebar.radio("foo", options=["a", "b", "c"])
        st.radio("bar", options=[1, 2, 3])
        """,
    )
    sr = script.run()
    assert len(sr.radio) == 2
    assert sr.sidebar.radio[0].value == "a"
    assert sr.main.radio[0].value == 1

    repr(sr.radio[0])


def test_slider():
    script = AppTest.from_string(
        """
        import streamlit as st
        from datetime import datetime, time

        st.slider("defaults")
        st.slider("int", min_value=-100, max_value=100, step=5, value=10)
        st.slider("time", value=(time(11, 30), time(12, 45)))
        st.slider("datetime", value=datetime(2020, 1, 1, 9, 30))
        st.slider("float", min_value=0.0, max_value=1.0, step=0.01)
        """,
    )
    sr = script.run()
    s = sr.slider
    assert s[0].value == 0
    assert s[1].value == 10
    assert s[2].value == (time(11, 30), time(12, 45))
    assert s[3].value == datetime(2020, 1, 1, 9, 30)
    assert s[4].value == 0.0

    sr2 = sr.slider[1].set_value(50).run()
    sr3 = sr2.slider[2].set_range(time(12, 0), time(12, 15)).run()
    sr4 = sr3.slider[3].set_value(datetime(2020, 1, 10, 8, 0)).run()
    sr5 = sr4.slider[4].set_value(0.1).run()
    s = sr5.slider
    assert s[0].value == 0
    assert s[1].value == 50
    assert s[2].value == (time(12, 0), time(12, 15))
    assert s[3].value == datetime(2020, 1, 10, 8, 0)
    assert s[4].value == 0.1

    # Verify that creating the reprs does not throw
    repr(sr.slider[0])


def test_status():
    def script():
        import streamlit as st

        # Not using `with` because exiting that changes status to "complete"
        running = st.status("running status", state="running")
        running.text("waiting")

        with st.status("complete status", state="complete"):
            st.text("yay")

        with st.status("error status", state="error"):
            st.text("oh no")

    at = AppTest.from_function(script).run()
    assert len(at.status) == 3
    assert at.status[0].state == "running"
    assert at.status[1].state == "complete"
    assert at.status[2].state == "error"


def test_table():
    def script():
        import numpy as np
        import pandas as pd

        import streamlit as st

        df = pd.DataFrame(
            index=[[0, 1], ["i1", "i2"]],
            columns=[[2, 3, 4], ["c1", "c2", "c3"]],
            data=np.arange(0, 6, 1).reshape(2, 3),
        )
        st.table(df)

    at = AppTest.from_function(script).run()
    df = pd.DataFrame(
        index=[[0, 1], ["i1", "i2"]],
        columns=[[2, 3, 4], ["c1", "c2", "c3"]],
        data=np.arange(0, 6, 1).reshape(2, 3),
    )
    assert at.table[0].value.equals(df)

    repr(at.table[0])


def test_tabs():
    def script():
        import streamlit as st

        t1, t2 = st.tabs(["cat", "dog"])
        with t1:
            st.text("meow")
        t2.text("woof")

    at = AppTest.from_function(script).run()
    assert len(at.tabs) == 2
    assert at.tabs[0].label == "cat"
    assert at.tabs[0].text[0].value == "meow"
    assert at.tabs[1].label == "dog"
    assert at.tabs[1].text[0].value == "woof"

    repr(at.tabs[0])


def test_text_area():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.text_area("label")
        st.text_area("with default", value="default", max_chars=20)
        """,
    )
    sr = script.run()

    assert sr.text_area[0].value == ""
    assert sr.text_area[1].value == "default"

    long_string = "".join(["this is a long string fragment."] * 10)
    sr.text_area[0].input(long_string)
    sr2 = sr.text_area[1].input(long_string).run()

    assert sr2.text_area[0].value == long_string
    assert sr2.text_area[1].value == "default"

    repr(sr.text_area[0])


def test_text_input():
    script = AppTest.from_string(
        """
        import streamlit as st

        st.text_input("label")
        st.text_input("with default", value="default", max_chars=20)
        """,
    )
    sr = script.run()

    assert sr.text_input[0].value == ""
    assert sr.text_input[1].value == "default"

    long_string = "".join(["this is a long string fragment."] * 10)
    sr.text_input[0].input(long_string)
    sr2 = sr.text_input[1].input(long_string).run()

    assert sr2.text_input[0].value == long_string
    assert sr2.text_input[1].value == "default"

    repr(sr.text_input[0])


def test_time_input():
    script = AppTest.from_string(
        """
        import streamlit as st
        import datetime

        st.time_input("time", value=datetime.time(8, 30))
        st.time_input("datetime", value=datetime.datetime(2000,1,1, hour=17), step=3600)
        st.time_input("timedelta step", value=datetime.time(2), step=datetime.timedelta(minutes=1))
        """,
    )
    sr = script.run()
    assert not sr.exception
    assert [t.value for t in sr.time_input] == [
        time(8, 30),
        time(17),
        time(2),
    ]
    tis = sr.time_input
    tis[0].increment()
    tis[1].decrement()
    tis[2].increment()
    sr2 = sr.run()
    assert [t.value for t in sr2.time_input] == [
        time(8, 45),
        time(16),
        time(2, 1),
    ]

    repr(sr.time_input[0])


def test_toast():
    def script():
        import streamlit as st

        st.toast("first")
        st.write("something in the main area")
        st.toast("second")

    at = AppTest.from_function(script).run()
    assert at.toast.len == 2
    assert at.toast.values == ["first", "second"]


def test_toggle():
    def script():
        import streamlit as st

        on = st.toggle("Activate feature")
        if on:
            st.write("Feature activated!")

    at = AppTest.from_function(script).run()
    assert at.toggle[0].value is False

    at.toggle[0].set_value(True).run()
    assert at.toggle[0].value is True

    repr(at.toggle[0])


def test_short_timeout():
    script = AppTest.from_string(
        """
        import time
        import streamlit as st

        st.write("start")
        time.sleep(0.5)
        st.write("end")
        """
    )
    with pytest.raises(RuntimeError):
        script.run(timeout=0.2)


def test_state_access():
    def script():
        import streamlit as st

        if "foo" not in st.session_state:
            st.session_state.foo = "bar"
        st.write(st.session_state.foo)

    at = AppTest.from_function(script).run()
    assert at.markdown[0].value == "bar"

    at.session_state["foo"] = "baz"
    at.run()
    assert at.markdown[0].value == "baz"

    at.session_state.foo = "quux"
    at.run()
    assert at.markdown[0].value == "quux"


================================================
File: /lib/tests/streamlit/testing/test_data/main.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.text("main page")

st.slider("slider", min_value=0, max_value=10)


================================================
File: /lib/tests/streamlit/testing/test_data/pages/page1.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.text("page 1")


================================================
File: /lib/tests/streamlit/typing/readme.md
================================================
Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

---

Files in the typing/ directory are used for catching typing errors as they are checked by our mypy script. Their purpose is to, essentially, assert that the typechecker derives the types of certain cases correctly.

This is useful because in some cases, such as those involving TypeVars and overloads, the logic necessary to determine what the types are is somewhat non-trivial, so it's nice to affirmatively check that certain typing results are correctly achieved. Furthermore, the rest of the testing code, which is naturally focused more on ensuring correct behavior, might not have sufficient coverage of the static typing possibilities; thus, this directory of code.


================================================
File: /lib/tests/streamlit/typing/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/typing/dataframe_types.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING

from typing_extensions import assert_type

# Perform some "type checking testing"; mypy should flag any assignments that are
# incorrect.
if TYPE_CHECKING:
    import numpy as np
    import pandas as pd

    from streamlit.delta_generator import DeltaGenerator
    from streamlit.elements.arrow import ArrowMixin, DataframeState

    dataframe = ArrowMixin().dataframe

    # Create some test data
    df = pd.DataFrame({"A": [1, 2, 3], "B": ["a", "b", "c"]})
    arr = np.array([[1, 2, 3], [4, 5, 6]])

    # Test return types with on_select="ignore" (default)
    assert_type(dataframe(df), DeltaGenerator)
    assert_type(dataframe(arr), DeltaGenerator)
    assert_type(dataframe(None), DeltaGenerator)
    assert_type(dataframe([[1, 2], [3, 4]]), DeltaGenerator)
    assert_type(dataframe({"col1": [1, 2], "col2": [3, 4]}), DeltaGenerator)

    # Test return types with on_select="rerun"
    assert_type(dataframe(df, on_select="rerun"), DataframeState)
    assert_type(dataframe(arr, on_select="rerun"), DataframeState)
    assert_type(dataframe(None, on_select="rerun"), DataframeState)

    # Test return types with different selection modes
    assert_type(
        dataframe(df, on_select="rerun", selection_mode="single-row"), DataframeState
    )
    assert_type(
        dataframe(df, on_select="rerun", selection_mode="multi-row"), DataframeState
    )
    assert_type(
        dataframe(df, on_select="rerun", selection_mode="single-column"), DataframeState
    )
    assert_type(
        dataframe(df, on_select="rerun", selection_mode="multi-column"), DataframeState
    )
    assert_type(
        dataframe(df, on_select="rerun", selection_mode=["multi-row", "multi-column"]),
        DataframeState,
    )

    # Test return types with callback function
    assert_type(dataframe(df, on_select=lambda: None), DataframeState)

    # Test with various optional parameters
    assert_type(
        dataframe(
            df,
            width=500,
            height=300,
            use_container_width=True,
            hide_index=True,
            column_order=["B", "A"],
            column_config={"A": "Integer values"},
            key="my_table",
            on_select="rerun",
        ),
        DataframeState,
    )


================================================
File: /lib/tests/streamlit/typing/date_input_types.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, Union

from typing_extensions import assert_type

# Perform some "type checking testing"; mypy should flag any assignments that are
# incorrect.
if TYPE_CHECKING:
    from datetime import date, datetime

    from streamlit.elements.widgets.time_widgets import (
        DateWidgetRangeReturn,
        TimeWidgetsMixin,
    )

    date_input = TimeWidgetsMixin().date_input

    # Single date input
    assert_type(date_input("foo", date(2024, 1, 1)), date)
    assert_type(date_input("foo", datetime(2024, 1, 1)), date)
    assert_type(date_input("foo", value="today"), date)
    assert_type(date_input("foo", value="2024-01-01"), date)

    # Should return date or None if value is None:
    assert_type(date_input("foo", value=None), Union[date, None])
    assert_type(
        date_input(
            "foo", value=None, min_value=date(2024, 1, 1), max_value=date(2024, 1, 31)
        ),
        Union[date, None],
    )

    # Date range input with different sequence types
    assert_type(
        date_input("foo", (date(2024, 1, 1), date(2024, 1, 31))), DateWidgetRangeReturn
    )
    assert_type(
        date_input("foo", (datetime(2024, 1, 1), datetime(2024, 1, 31))),
        DateWidgetRangeReturn,
    )
    assert_type(
        date_input("foo", [datetime(2024, 1, 1), datetime(2024, 1, 31)]),
        DateWidgetRangeReturn,
    )
    assert_type(
        date_input("foo", (datetime(2024, 1, 1),)),
        DateWidgetRangeReturn,
    )
    assert_type(
        date_input("foo", [datetime(2024, 1, 1)]),
        DateWidgetRangeReturn,
    )

    # Test with min_value and max_value
    assert_type(
        date_input(
            "foo",
            date(2024, 1, 1),
            min_value=date(2022, 1, 1),
            max_value=date(2024, 12, 31),
        ),
        date,
    )
    assert_type(
        date_input(
            "foo",
            (date(2024, 1, 1), date(2024, 12, 31)),
            min_value=date(2022, 1, 1),
            max_value=date(2024, 12, 31),
        ),
        DateWidgetRangeReturn,
    )

    # Test with different formats
    assert_type(date_input("foo", date(2024, 1, 1), format="MM/DD/YYYY"), date)
    assert_type(
        date_input("foo", (date(2024, 1, 1), date(2024, 12, 31)), format="DD.MM.YYYY"),
        DateWidgetRangeReturn,
    )

    # Test with disabled and label_visibility
    assert_type(date_input("foo", date(2024, 1, 1), disabled=True), date)
    assert_type(
        date_input("foo", date(2024, 1, 1), label_visibility="hidden"),
        date,
    )

    # Test with on_change, args, and kwargs
    def on_change_callback(d: date | None):
        pass

    assert_type(date_input("foo", date(2024, 1, 1), on_change=on_change_callback), date)
    assert_type(
        date_input(
            "foo",
            date(2024, 1, 1),
            on_change=on_change_callback,
            args=(1,),
            kwargs={"key": "value"},
        ),
        date,
    )

    # Test with key
    assert_type(date_input("foo", date(2024, 1, 1), key="unique_key"), date)

    # Test with help
    assert_type(
        date_input("foo", date(2024, 1, 1), help="This is a helpful tooltip"), date
    )

    # Edge cases
    assert_type(date_input("foo", (None, date(2024, 12, 31))), DateWidgetRangeReturn)
    assert_type(date_input("foo", (date(2024, 1, 1), None)), DateWidgetRangeReturn)

    # Mixed input types
    assert_type(
        date_input("foo", (date(2024, 1, 1), datetime(2024, 12, 31))),
        DateWidgetRangeReturn,
    )
    assert_type(
        date_input("foo", (datetime(2024, 1, 1), date(2024, 12, 31))),
        DateWidgetRangeReturn,
    )


================================================
File: /lib/tests/streamlit/typing/feedback.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, Literal, Union

from typing_extensions import assert_type

# Perform some "type checking testing"; mypy should flag any assignments that are incorrect.
if TYPE_CHECKING:
    from streamlit.elements.widgets.button_group import ButtonGroupMixin

    feedback = ButtonGroupMixin().feedback

    assert_type(feedback(), Union[None, Literal[0, 1]])
    assert_type(feedback("thumbs"), Union[None, Literal[0, 1]])
    assert_type(feedback("faces"), Union[None, Literal[0, 1, 2, 3, 4]])
    assert_type(feedback("stars"), Union[None, Literal[0, 1, 2, 3, 4]])


================================================
File: /lib/tests/streamlit/typing/number_input_types.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, Union

from typing_extensions import assert_type

# Perform some "type checking testing"; mypy should flag any assignments that are incorrect.
# Note: Due to https://mypy.readthedocs.io/en/latest/duck_type_compatibility.html, mypy will not detect
# an <int> value being assigned to a <float> variable. There's nothing we can do about this, apparently.
if TYPE_CHECKING:
    from streamlit.elements.widgets.number_input import NumberInputMixin

    number_input = NumberInputMixin().number_input

    # Check positional argument types
    assert_type(number_input("foo", 5), int)
    assert_type(number_input("foo", 5, 5), int)
    assert_type(number_input("foo", 5, 5, 5), int)
    assert_type(number_input("foo", 5, 5, 5, 1), int)
    assert_type(number_input("foo"), float)
    assert_type(number_input("foo", 5.0), float)
    assert_type(number_input("foo", 5.0, 6.0), float)
    assert_type(number_input("foo", 5.0, 6.0, 5.5), float)
    assert_type(number_input("foo", 5.0, 6.0, 5.5, 0.01), float)
    # The next tests would indicate we will return a float instead of raising an error, because mypy considers
    # int to be a subclass of float. This is unavoidable, and not a real issue because we don't expect people
    # who care about type checking their code to use more than one positional numerical argument anyways.
    # number_input("foo", 5, 5.0)
    # number_input("foo", 5.0, 5.0, 5)
    # number_input("foo", 5.0, 5.0, 5.0, 1)

    # Check keyword argument types
    assert_type(number_input("foo", min_value=1), int)
    assert_type(number_input("foo", max_value=1), int)
    assert_type(number_input("foo", value=1), int)
    assert_type(number_input("foo", step=1), int)
    assert_type(number_input("foo", step=1, value=5), int)
    assert_type(number_input("foo", step=1, value="min"), int)
    assert_type(number_input("foo", max_value=1, value=0), int)
    assert_type(number_input("foo", max_value=1, value="min"), int)
    assert_type(number_input("foo", min_value=1, value=2), int)
    assert_type(number_input("foo", min_value=1, value="min"), int)
    assert_type(number_input("foo", min_value=1.0), float)
    assert_type(number_input("foo", max_value=1.0), float)
    assert_type(number_input("foo", value=1.0), float)
    assert_type(number_input("foo", step=1.0), float)
    assert_type(number_input("foo", step=1.0, value=5.0), float)
    assert_type(number_input("foo", step=1.0, value="min"), float)
    assert_type(number_input("foo", max_value=1.0, value=0.0), float)
    assert_type(number_input("foo", max_value=1.0, value="min"), float)
    assert_type(number_input("foo", min_value=1.0, value=2.0), float)
    assert_type(number_input("foo", min_value=1.0, value="min"), float)
    # The next tests would indicate we will return a float instead of raising an error,
    # because mypy considers int to be a subclass of float. This is unavoidable.
    # number_input("foo", min_value=1, max_value=5.0)
    # number_input("foo", step=1, min_value=5.0)
    # number_input("foo", value="min", step=1, max_value=5.0)

    # Check value=none
    assert_type(number_input("foo", step=5, value=None), Union[int, None])
    assert_type(number_input("foo", min_value=5, value=None), Union[int, None])
    assert_type(number_input("foo", max_value=5, value=None), Union[int, None])
    assert_type(number_input("foo", value=None), Union[float, None])
    # Same deal about mixing and matching ints and floats applies here too.
    # number_input("foo", max_value=5, value=None, step=5.0)

    # Check "min" value
    assert_type(number_input("foo", value="min"), float)


================================================
File: /lib/tests/streamlit/typing/pills.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, Union

from typing_extensions import assert_type

# Perform some "type checking testing"; mypy should flag any assignments that are incorrect.
if TYPE_CHECKING:
    from streamlit.elements.widgets.button_group import ButtonGroupMixin

    pills = ButtonGroupMixin().pills

    options: list[int] = [1, 2, 3]
    assert_type(
        pills("foo", options),
        Union[int, None],
    )
    assert_type(
        pills("foo", options, default=1),
        Union[int, None],
    )
    assert_type(
        pills("foo", options, selection_mode="single"),
        Union[int, None],
    )
    assert_type(
        pills("foo", options, selection_mode="single", default=1),
        Union[int, None],
    )
    assert_type(
        pills("foo", options, selection_mode="multi"),
        list[int],
    )
    assert_type(
        pills("foo", options, selection_mode="multi", default=1),
        list[int],
    )
    assert_type(
        pills("foo", options, selection_mode="multi", default=[1]),
        list[int],
    )


================================================
File: /lib/tests/streamlit/typing/radio_types.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, Union

from typing_extensions import assert_type

# Perform some "type checking testing"; mypy should flag any assignments that are incorrect.
if TYPE_CHECKING:
    from enum import Enum

    from streamlit.elements.widgets.radio import RadioMixin

    radio = RadioMixin().radio

    class Alfred(Enum):
        HITCHCOCK = 1
        WALLACE = 2
        GREENE = 3

    assert_type(radio("foo", [1, 2, 3]), int)
    assert_type(radio("foo", [1, 2, 3], index=None), Union[int, None])
    assert_type(radio("foo", [1.0, 2.0, 3.0]), float)
    assert_type(radio("foo", [1.0, 2.0, 3.0], index=None), Union[float, None])
    assert_type(radio("foo", [1.0, 2, 3.0]), float)
    assert_type(radio("foo", [1.0, 2, 3.0], index=None), Union[float, None])
    assert_type(radio("foo", ["foo", "bar"]), str)
    assert_type(radio("foo", ["foo", "bar"], index=None), Union[str, None])
    assert_type(radio("foo", Alfred), Alfred)
    assert_type(radio("foo", [Alfred.HITCHCOCK, Alfred.GREENE]), Alfred)
    assert_type(radio("foo", Alfred, index=None), Union[Alfred, None])
    assert_type(radio("foo", [1, Alfred.HITCHCOCK, "five"], index=None), object)


================================================
File: /lib/tests/streamlit/typing/segmented_control.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, Union

from typing_extensions import assert_type

# Perform some "type checking testing"; mypy should flag any assignments that are incorrect.
if TYPE_CHECKING:
    from streamlit.elements.widgets.button_group import ButtonGroupMixin

    segmented_control = ButtonGroupMixin().segmented_control

    options: list[int] = [1, 2, 3]
    assert_type(
        segmented_control("foo", options),
        Union[int, None],
    )
    assert_type(
        segmented_control("foo", options, default=1),
        Union[int, None],
    )
    assert_type(
        segmented_control("foo", options, selection_mode="single"),
        Union[int, None],
    )
    assert_type(
        segmented_control("foo", options, selection_mode="single", default=1),
        Union[int, None],
    )
    assert_type(
        segmented_control("foo", options, selection_mode="multi"),
        list[int],
    )
    assert_type(
        segmented_control("foo", options, selection_mode="multi", default=1),
        list[int],
    )
    assert_type(
        segmented_control("foo", options, selection_mode="multi", default=[1]),
        list[int],
    )


================================================
File: /lib/tests/streamlit/typing/select_slider_types.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING

from typing_extensions import assert_type

# Perform some "type checking testing"; mypy should flag any assignments that are incorrect.
if TYPE_CHECKING:
    from enum import Enum

    from streamlit.elements.widgets.select_slider import SelectSliderMixin

    select_slider = SelectSliderMixin().select_slider

    class Alfred(Enum):
        HITCHCOCK = 1
        WALLACE = 2
        GREENE = 3

    assert_type(select_slider("foo", [1, 2, 3]), int)
    assert_type(select_slider("foo", [1, 2, 3], value=2), int)
    assert_type(select_slider("foo", [1, 2, 3], value=(1, 3)), tuple[int, int])
    assert_type(select_slider("foo", [1.0, 2.0, 3.0]), float)
    assert_type(select_slider("foo", [1.0, 2.0, 3.0], value=3.0), float)
    assert_type(
        select_slider("foo", [1.0, 2.0, 3.0], value=(2.0, 3.0)), tuple[float, float]
    )
    assert_type(select_slider("foo", ["foo", "bar"]), str)
    assert_type(select_slider("foo", Alfred), Alfred)
    assert_type(select_slider("foo", [Alfred.HITCHCOCK, Alfred.GREENE]), Alfred)
    assert_type(
        select_slider("foo", [1, Alfred.HITCHCOCK, "five"], value="five"), object
    )
    assert_type(
        select_slider("foo", [1, Alfred.HITCHCOCK, "five"], value=[1, "five"]),
        tuple[object, object],
    )
    assert_type(
        select_slider("foo", ([1], [2], [3]), value=[[1], [2]]),
        tuple[list[int], list[int]],
    )
    opt: list[object] = [1, 2, "4"]
    assert_type(select_slider("foo", options=opt, value=[1, 2]), object)
    # See note in select_slider.py; we can't really tell mypy that this will return a
    # tuple[object, object] since value: Sequence[int] is a subtype of object.
    # Technically this return type isn't wrong (tuple[object, object] is a subtype
    # of object), it's just not as specific as we'd like.


================================================
File: /lib/tests/streamlit/typing/selectbox_types.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, Union

from typing_extensions import assert_type

# Perform some "type checking testing"; mypy should flag any assignments that are incorrect.
if TYPE_CHECKING:
    from enum import Enum

    from streamlit.elements.widgets.selectbox import SelectboxMixin

    selectbox = SelectboxMixin().selectbox

    class Alfred(Enum):
        HITCHCOCK = 1
        WALLACE = 2
        GREENE = 3

    assert_type(selectbox("foo", [1, 2, 3]), int)
    assert_type(selectbox("foo", [1, 2, 3], index=None), Union[int, None])
    assert_type(selectbox("foo", [1.0, 2.0, 3.0]), float)
    assert_type(selectbox("foo", [1.0, 2.0, 3.0], index=None), Union[float, None])
    assert_type(selectbox("foo", [1.0, 2, 3.0]), float)
    assert_type(selectbox("foo", [1.0, 2, 3.0], index=None), Union[float, None])
    assert_type(selectbox("foo", ["foo", "bar"]), str)
    assert_type(selectbox("foo", ["foo", "bar"], index=None), Union[str, None])
    assert_type(selectbox("foo", Alfred), Alfred)
    assert_type(selectbox("foo", [Alfred.HITCHCOCK, Alfred.GREENE]), Alfred)
    assert_type(selectbox("foo", Alfred, index=None), Union[Alfred, None])
    assert_type(selectbox("foo", [1, Alfred.HITCHCOCK, "five"], index=None), object)


================================================
File: /lib/tests/streamlit/typing/slider_types.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING

from typing_extensions import assert_type

# Perform some "type checking testing"; mypy should flag any assignments that are incorrect.
# Note: Due to https://mypy.readthedocs.io/en/latest/duck_type_compatibility.html, mypy will not detect
# an <int> value being assigned to a <float> variable. There's nothing we can do about this, apparently.
if TYPE_CHECKING:
    from datetime import date, time, timedelta

    from streamlit.elements.widgets.slider import SliderMixin

    slider = SliderMixin().slider

    assert_type(slider("foo"), int)
    assert_type(slider("foo", 5), int)
    assert_type(slider("foo", 5, 10), int)
    assert_type(slider("foo", 5, 10, 8), int)
    assert_type(slider("foo", 5, 10, 8, 1), int)
    assert_type(slider("foo", 5.0), float)
    assert_type(slider("foo", 5.0, 10.0), float)
    assert_type(slider("foo", 5.0, 10.0, 6.0), float)
    assert_type(slider("foo", 5.0, 10.0, 6.0, 1.0), float)

    assert_type(slider("foo", 5, 10, [5, 8]), tuple[int, int])
    assert_type(slider("foo", 5, 10, [5, 8], 1), tuple[int, int])

    assert_type(slider("foo", min_value=5, value=5), int)
    assert_type(slider("foo", min_value=5, step=1), int)
    assert_type(slider("foo", min_value=5, value=5, step=1), int)
    assert_type(slider("foo", min_value=5, max_value=10, value=5, step=1), int)
    assert_type(slider("foo", max_value=10, value=5, step=1), int)
    assert_type(slider("foo", max_value=10, step=1), int)
    assert_type(slider("foo", step=1), int)
    assert_type(slider("foo", min_value=5, max_value=10), int)
    assert_type(slider("foo", min_value=5, max_value=10, step=1), int)

    assert_type(slider("foo", min_value=5.0, value=5.0), float)
    assert_type(slider("foo", min_value=5.0, step=1.0), float)
    assert_type(slider("foo", min_value=5.0, value=5.0, step=1.0), float)
    assert_type(
        slider("foo", min_value=5.0, max_value=10.0, value=5.0, step=1.0), float
    )
    assert_type(slider("foo", max_value=10.0, value=5.0, step=1.0), float)
    assert_type(slider("foo", max_value=10.0, step=1.0), float)
    # kwsingularfloat7 = slider("foo", step=1.0)
    # ^ This actually raises an exception and is an invalid signature
    assert_type(slider("foo", min_value=5.0, max_value=10.0), float)
    assert_type(slider("foo", min_value=5.0, max_value=10.0, step=1.0), float)

    assert_type(slider("foo", min_value=5, value=[5, 9]), tuple[int, int])
    assert_type(
        slider("foo", min_value=5, max_value=10, value=[8, 9], step=1), tuple[int, int]
    )
    assert_type(slider("foo", max_value=10, value=[8, 9], step=1), tuple[int, int])

    assert_type(slider("foo", min_value=5.0, value=[5.0, 9.0]), tuple[float, float])
    assert_type(
        slider("foo", min_value=5.0, max_value=10.0, value=[8.0, 9.0], step=1.0),
        tuple[float, float],
    )
    assert_type(
        slider("foo", max_value=10.0, value=[8.0, 9.0], step=1.0), tuple[float, float]
    )

    _2024_5_1 = date(2024, 5, 1)
    _2024_5_8 = date(2024, 5, 8)
    _2024_5_15 = date(2024, 5, 15)
    _2024_5_20 = date(2024, 5, 20)
    _1DAYSPAN = timedelta(1)

    assert_type(slider("foo", _2024_5_1), date)
    assert_type(slider("foo", _2024_5_1, _2024_5_20), date)
    assert_type(slider("foo", _2024_5_1, _2024_5_20, _2024_5_8), date)
    assert_type(slider("foo", _2024_5_1, _2024_5_20, _2024_5_8, _1DAYSPAN), date)

    assert_type(
        slider("foo", _2024_5_1, _2024_5_20, [_2024_5_8, _2024_5_15]), tuple[date, date]
    )
    assert_type(
        slider("foo", _2024_5_1, _2024_5_20, [_2024_5_8, _2024_5_15], _1DAYSPAN),
        tuple[date, date],
    )

    assert_type(slider("foo", min_value=_2024_5_1, value=_2024_5_8), date)
    assert_type(slider("foo", min_value=_2024_5_1, step=_1DAYSPAN), date)
    assert_type(
        slider("foo", min_value=_2024_5_1, value=_2024_5_8, step=_1DAYSPAN), date
    )
    assert_type(
        slider(
            "foo",
            min_value=_2024_5_1,
            max_value=_2024_5_20,
            value=_2024_5_8,
            step=_1DAYSPAN,
        ),
        date,
    )
    assert_type(
        slider("foo", max_value=_2024_5_20, value=_2024_5_8, step=_1DAYSPAN), date
    )
    assert_type(slider("foo", max_value=_2024_5_20, step=_1DAYSPAN), date)
    # kwsingulardate7 = slider("foo", step=_1DAYSPAN)
    # ^ This actually raises an exception and is an invalid signature
    assert_type(slider("foo", min_value=_2024_5_1, max_value=_2024_5_20), date)
    assert_type(
        slider("foo", min_value=_2024_5_1, max_value=_2024_5_20, step=_1DAYSPAN), date
    )

    assert_type(
        slider("foo", min_value=_2024_5_1, value=[_2024_5_8, _2024_5_15]),
        tuple[date, date],
    )
    assert_type(
        slider(
            "foo",
            min_value=_2024_5_1,
            max_value=_2024_5_20,
            value=[_2024_5_8, _2024_5_15],
            step=_1DAYSPAN,
        ),
        tuple[date, date],
    )
    assert_type(
        slider(
            "foo", max_value=_2024_5_20, value=[_2024_5_8, _2024_5_15], step=_1DAYSPAN
        ),
        tuple[date, date],
    )

    _0800 = time(8)
    _1400 = time(14)
    _1800 = time(18)
    _2000 = time(20)
    _5MINUTESPAN = timedelta(minutes=5)

    assert_type(slider("foo", _0800), time)
    assert_type(slider("foo", _0800, _2000), time)
    assert_type(slider("foo", _0800, _2000, _1400), time)
    assert_type(slider("foo", _0800, _2000, _1400, _5MINUTESPAN), time)
    assert_type(slider("foo", _0800, _2000, [_1400, _1800]), tuple[time, time])
    assert_type(
        slider("foo", _0800, _2000, [_1400, _1800], _5MINUTESPAN), tuple[time, time]
    )

    assert_type(slider("foo", min_value=_0800, value=_1400), time)
    assert_type(slider("foo", min_value=_0800, step=_5MINUTESPAN), time)
    assert_type(slider("foo", min_value=_0800, value=_1400, step=_5MINUTESPAN), time)
    assert_type(
        slider("foo", min_value=_0800, max_value=_2000, value=_1400, step=_5MINUTESPAN),
        time,
    )
    assert_type(slider("foo", max_value=_2000, value=_1400, step=_5MINUTESPAN), time)
    assert_type(slider("foo", max_value=_2000, step=_5MINUTESPAN), time)
    # kwsingulartime7 = slider("foo", step=_5MINUTESPAN)
    # ^ This actually raises an exception and is an invalid signature
    assert_type(slider("foo", min_value=_0800, max_value=_2000), time)
    assert_type(
        slider("foo", min_value=_0800, max_value=_2000, step=_5MINUTESPAN), time
    )

    assert_type(slider("foo", min_value=_0800, value=[_1400, _1800]), tuple[time, time])
    assert_type(
        slider(
            "foo",
            min_value=_0800,
            max_value=_2000,
            value=[_1400, _1800],
            step=_5MINUTESPAN,
        ),
        tuple[time, time],
    )
    assert_type(
        slider("foo", max_value=_2000, value=[_1400, _1800], step=_5MINUTESPAN),
        tuple[time, time],
    )


================================================
File: /lib/tests/streamlit/watcher/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""watcher unittest."""


================================================
File: /lib/tests/streamlit/watcher/event_based_path_watcher_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations
