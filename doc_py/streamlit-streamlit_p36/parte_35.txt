
import unittest
from unittest import mock

from watchdog import events

from streamlit.watcher import event_based_path_watcher


class EventBasedPathWatcherTest(unittest.TestCase):
    """Test EventBasedPathWatcher."""

    def setUp(self):
        # This test suite patches MultiPathWatcher. A MultiPathWatcher may
        # already exist (another test may have directly or indirectly created
        # one), so we first close any existing watcher instance here.
        if event_based_path_watcher._MultiPathWatcher._singleton is not None:
            event_based_path_watcher._MultiPathWatcher.get_singleton().close()
            event_based_path_watcher._MultiPathWatcher._singleton = None

        self.observer_class_patcher = mock.patch(
            "streamlit.watcher.event_based_path_watcher.Observer"
        )
        self.util_patcher = mock.patch(
            "streamlit.watcher.event_based_path_watcher.util"
        )
        self.MockObserverClass = self.observer_class_patcher.start()
        self.mock_util = self.util_patcher.start()

    def tearDown(self):
        fo = event_based_path_watcher._MultiPathWatcher.get_singleton()
        fo._observer.start.reset_mock()
        fo._observer.schedule.reset_mock()

        self.observer_class_patcher.stop()
        self.util_patcher.stop()

    def test_file_watch_and_callback(self):
        """Test that when a file is modified, the callback is called."""
        cb = mock.Mock()

        self.mock_util.path_modification_time = lambda *args: 101.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "1"

        ro = event_based_path_watcher.EventBasedPathWatcher("/this/is/my/file.py", cb)

        fo = event_based_path_watcher._MultiPathWatcher.get_singleton()
        fo._observer.schedule.assert_called_once()

        folder_handler = fo._observer.schedule.call_args[0][0]

        cb.assert_not_called()

        self.mock_util.path_modification_time = lambda *args: 102.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "2"

        ev = events.FileSystemEvent("/this/is/my/file.py")
        ev.event_type = events.EVENT_TYPE_MODIFIED
        folder_handler.on_modified(ev)

        cb.assert_called_once()

        ro.close()

    def test_works_with_bytes_path(self):
        """Test that when a file path in bytes, the callback is called."""
        cb = mock.Mock()

        self.mock_util.path_modification_time = lambda *args: 101.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "1"

        ro = event_based_path_watcher.EventBasedPathWatcher("/this/is/my/file.py", cb)

        fo = event_based_path_watcher._MultiPathWatcher.get_singleton()
        fo._observer.schedule.assert_called_once()

        folder_handler = fo._observer.schedule.call_args[0][0]

        cb.assert_not_called()

        self.mock_util.path_modification_time = lambda *args: 102.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "2"

        ev = events.FileSystemEvent(b"/this/is/my/file.py")
        ev.event_type = events.EVENT_TYPE_MODIFIED
        folder_handler.on_modified(ev)

        cb.assert_called_once()

        ro.close()

    def test_works_with_directories(self):
        """Test that when a directory is modified, the callback is called."""
        cb = mock.Mock()

        self.mock_util.path_modification_time = lambda *args: 101.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "1"

        ro = event_based_path_watcher.EventBasedPathWatcher("/this/is/my/dir", cb)

        fo = event_based_path_watcher._MultiPathWatcher.get_singleton()
        fo._observer.schedule.assert_called_once()

        folder_handler = fo._observer.schedule.call_args[0][0]

        cb.assert_not_called()

        self.mock_util.path_modification_time = lambda *args: 102.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "2"

        ev = events.FileSystemEvent("/this/is/my/dir")
        ev.event_type = events.EVENT_TYPE_MODIFIED
        ev.is_directory = True
        folder_handler.on_modified(ev)

        cb.assert_called_once()

        ro.close()

    @mock.patch("os.path.isdir")
    def test_correctly_resolves_watched_folder_path(self, mock_is_dir):
        mock_is_dir.return_value = True
        cb = mock.Mock()

        self.mock_util.path_modification_time = lambda *args: 101.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "1"

        ro = event_based_path_watcher.EventBasedPathWatcher("/this/is/my/dir", cb)

        fo = event_based_path_watcher._MultiPathWatcher.get_singleton()
        fo._observer.schedule.assert_called_once()

        folder_path = fo._observer.schedule.call_args[0][1]
        assert folder_path == "/this/is/my/dir"

        ro.close()

    @mock.patch("os.path.isdir")
    def test_correctly_resolves_watched_file_path(self, mock_is_dir):
        mock_is_dir.return_value = False
        cb = mock.Mock()

        self.mock_util.path_modification_time = lambda *args: 101.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "1"

        ro = event_based_path_watcher.EventBasedPathWatcher(
            "/this/is/my/dir/file.txt", cb
        )

        fo = event_based_path_watcher._MultiPathWatcher.get_singleton()
        fo._observer.schedule.assert_called_once()

        folder_path = fo._observer.schedule.call_args[0][1]
        assert folder_path == "/this/is/my/dir"

        ro.close()

    def test_changed_modification_time_0_0(self):
        """Test that when a directory is modified, but modification time is 0.0,
        the callback is called anyway."""
        cb = mock.Mock()

        self.mock_util.path_modification_time = lambda *args: 0.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "42"

        ro = event_based_path_watcher.EventBasedPathWatcher("/this/is/my/dir", cb)

        fo = event_based_path_watcher._MultiPathWatcher.get_singleton()
        fo._observer.schedule.assert_called_once()

        folder_handler = fo._observer.schedule.call_args[0][0]

        cb.assert_not_called()

        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "64"

        ev = events.FileSystemEvent("/this/is/my/dir")
        ev.event_type = events.EVENT_TYPE_MODIFIED
        ev.is_directory = True
        folder_handler.on_modified(ev)

        cb.assert_called_once()

        ro.close()

    def test_kwargs_plumbed_to_calc_md5(self):
        """Test that we pass the glob_pattern and allow_nonexistent kwargs to
        calc_md5_with_blocking_retries.

        `EventBasedPathWatcher`s can be created with optional kwargs allowing
        the caller to specify what types of files to watch (when watching a
        directory) and whether to allow watchers on paths with no files/dirs.
        This test ensures that these optional parameters make it to our hash
        calculation helpers across different on_changed events.
        """
        cb = mock.Mock()

        self.mock_util.path_modification_time = lambda *args: 101.0
        self.mock_util.calc_md5_with_blocking_retries = mock.Mock(return_value="1")

        ro = event_based_path_watcher.EventBasedPathWatcher(
            "/this/is/my/dir",
            cb,
            glob_pattern="*.py",
            allow_nonexistent=True,
        )

        fo = event_based_path_watcher._MultiPathWatcher.get_singleton()
        fo._observer.schedule.assert_called_once()

        folder_handler = fo._observer.schedule.call_args[0][0]

        _, kwargs = self.mock_util.calc_md5_with_blocking_retries.call_args
        assert kwargs == {"glob_pattern": "*.py", "allow_nonexistent": True}
        cb.assert_not_called()

        self.mock_util.path_modification_time = lambda *args: 102.0
        self.mock_util.calc_md5_with_blocking_retries = mock.Mock(return_value="3")

        ev = events.FileSystemEvent("/this/is/my/dir")
        ev.event_type = events.EVENT_TYPE_MODIFIED
        ev.is_directory = True
        folder_handler.on_modified(ev)

        _, kwargs = self.mock_util.calc_md5_with_blocking_retries.call_args
        assert kwargs == {"glob_pattern": "*.py", "allow_nonexistent": True}
        cb.assert_called_once()

        ro.close()

    def test_callback_not_called_if_same_mtime(self):
        """Test that we ignore files with same mtime."""
        cb = mock.Mock()

        self.mock_util.path_modification_time = lambda *args: 101.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "1"

        ro = event_based_path_watcher.EventBasedPathWatcher("/this/is/my/file.py", cb)

        fo = event_based_path_watcher._MultiPathWatcher.get_singleton()
        fo._observer.schedule.assert_called_once()

        folder_handler = fo._observer.schedule.call_args[0][0]

        cb.assert_not_called()

        # Same mtime!
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "2"

        ev = events.FileSystemEvent("/this/is/my/file.py")
        ev.event_type = events.EVENT_TYPE_MODIFIED
        folder_handler.on_modified(ev)

        # This is the test:
        cb.assert_not_called()

        ro.close()

    def test_callback_not_called_if_same_md5(self):
        """Test that we ignore files with same md5."""
        cb = mock.Mock()

        self.mock_util.path_modification_time = lambda *args: 101.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "1"

        ro = event_based_path_watcher.EventBasedPathWatcher("/this/is/my/file.py", cb)

        fo = event_based_path_watcher._MultiPathWatcher.get_singleton()
        fo._observer.schedule.assert_called_once()

        folder_handler = fo._observer.schedule.call_args[0][0]

        cb.assert_not_called()

        self.mock_util.path_modification_time = lambda *args: 102.0
        # Same MD5!

        ev = events.FileSystemEvent("/this/is/my/file.py")
        ev.event_type = events.EVENT_TYPE_MODIFIED
        folder_handler.on_modified(ev)

        # This is the test:
        cb.assert_not_called()

        ro.close()

    def test_callback_not_called_if_wrong_event_type(self):
        """Test that we ignore created files."""
        cb = mock.Mock()

        self.mock_util.path_modification_time = lambda *args: 101.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "1"

        ro = event_based_path_watcher.EventBasedPathWatcher("/this/is/my/file.py", cb)

        fo = event_based_path_watcher._MultiPathWatcher.get_singleton()
        fo._observer.schedule.assert_called_once()

        folder_handler = fo._observer.schedule.call_args[0][0]

        cb.assert_not_called()

        self.mock_util.path_modification_time = lambda *args: 102.0
        self.mock_util.calc_md5_with_blocking_retries = lambda _, **kwargs: "2"

        ev = events.FileSystemEvent("/this/is/my/file.py")
        ev.event_type = events.EVENT_TYPE_DELETED  # Wrong type
        folder_handler.on_modified(ev)

        # This is the test:
        cb.assert_not_called()

        ro.close()

    def test_multiple_watchers_same_file(self):
        """Test that we can have multiple watchers of the same file."""

        filename = "/this/is/my/file.py"

        mod_count = [0.0]

        def modify_mock_file():
            self.mock_util.path_modification_time = lambda *args: mod_count[0]
            self.mock_util.calc_md5_with_blocking_retries = (
                lambda _, **kwargs: "%d" % mod_count[0]
            )

            ev = events.FileSystemEvent(filename)
            ev.event_type = events.EVENT_TYPE_MODIFIED
            folder_handler.on_modified(ev)

            mod_count[0] += 1.0

        cb1 = mock.Mock()
        cb2 = mock.Mock()

        watcher1 = event_based_path_watcher.EventBasedPathWatcher(filename, cb1)
        watcher2 = event_based_path_watcher.EventBasedPathWatcher(filename, cb2)

        fo = event_based_path_watcher._MultiPathWatcher.get_singleton()
        fo._observer.schedule.assert_called_once()

        folder_handler = fo._observer.schedule.call_args[0][0]

        cb1.assert_not_called()
        cb2.assert_not_called()

        # "Modify" our file
        modify_mock_file()

        assert 1 == cb1.call_count
        assert 1 == cb2.call_count

        # Close watcher1. Only watcher2's callback should be called after this.
        watcher1.close()

        # Modify our file again
        modify_mock_file()

        assert 1 == cb1.call_count
        assert 2 == cb2.call_count

        watcher2.close()

        # Modify our file a final time
        modify_mock_file()

        # Both watchers are now closed, so their callback counts
        # should not have increased.
        assert 1 == cb1.call_count
        assert 2 == cb2.call_count


================================================
File: /lib/tests/streamlit/watcher/folder_black_list_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""streamlit.black_list unit test."""

from __future__ import annotations

import unittest

from streamlit.watcher.folder_black_list import FolderBlackList


class FileIsInFolderTest(unittest.TestCase):
    def test_do_blacklist(self):
        """
        miniconda, anaconda, and .*/ folders should be blacklisted.
        """
        folder_black_list = FolderBlackList([])
        is_blacklisted = folder_black_list.is_blacklisted

        self.assertTrue(is_blacklisted("/foo/miniconda2/script.py"))
        self.assertTrue(is_blacklisted("/foo/miniconda3/script.py"))
        self.assertTrue(is_blacklisted("/foo/anaconda2/script.py"))
        self.assertTrue(is_blacklisted("/foo/anaconda3/script.py"))
        self.assertTrue(is_blacklisted("/foo/.virtualenv/script.py"))
        self.assertTrue(is_blacklisted("/foo/.venv/script.py"))
        self.assertTrue(is_blacklisted("/foo/.random_hidden_folder/script.py"))

    def test_do_blacklist_user_configured_folders(self):
        """
        Files inside user configured folders should be blacklisted.
        """
        folder_black_list = FolderBlackList(["/bar/some_folder"])
        is_blacklisted = folder_black_list.is_blacklisted
        self.assertTrue(is_blacklisted("/bar/some_folder/script.py"))

    def test_do_not_blacklist(self):
        """
        Ensure we're not accidentally blacklisting things we shouldn't be.
        """
        folder_black_list = FolderBlackList([])
        is_blacklisted = folder_black_list.is_blacklisted

        self.assertFalse(is_blacklisted("/foo/not_blacklisted/script.py"))
        self.assertFalse(is_blacklisted("/foo/not_blacklisted/.hidden_script.py"))


================================================
File: /lib/tests/streamlit/watcher/local_sources_watcher_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""streamlit.LocalSourcesWatcher unit test."""

from __future__ import annotations

import os
import sys
import unittest
from unittest.mock import MagicMock, patch

import tests.streamlit.watcher.test_data.dummy_module1 as DUMMY_MODULE_1
import tests.streamlit.watcher.test_data.dummy_module2 as DUMMY_MODULE_2
import tests.streamlit.watcher.test_data.misbehaved_module as MISBEHAVED_MODULE
import tests.streamlit.watcher.test_data.nested_module_child as NESTED_MODULE_CHILD
import tests.streamlit.watcher.test_data.nested_module_parent as NESTED_MODULE_PARENT
from streamlit import config
from streamlit.runtime.pages_manager import PagesManager
from streamlit.watcher import local_sources_watcher
from streamlit.watcher.path_watcher import NoOpPathWatcher, _is_watchdog_available

SCRIPT_PATH = os.path.join(
    os.path.dirname(__file__), "test_data", "not_a_real_script.py"
)

DUMMY_MODULE_1_FILE = os.path.abspath(DUMMY_MODULE_1.__file__)
DUMMY_MODULE_2_FILE = os.path.abspath(DUMMY_MODULE_2.__file__)

NESTED_MODULE_CHILD_FILE = os.path.abspath(NESTED_MODULE_CHILD.__file__)


def NOOP_CALLBACK(_filepath):
    pass


@patch("streamlit.source_util._cached_pages", new=None)
@patch("streamlit.file_util.file_in_pythonpath", MagicMock(return_value=False))
class LocalSourcesWatcherTest(unittest.TestCase):
    def setUp(self):
        modules = [
            "DUMMY_MODULE_1",
            "DUMMY_MODULE_2",
            "MISBEHAVED_MODULE",
            "NESTED_MODULE_PARENT",
            "NESTED_MODULE_CHILD",
        ]

        the_globals = globals()

        for name in modules:
            try:
                del sys.modules[the_globals[name].__name__]
            except Exception:
                pass

            try:
                del sys.modules[name]
            except Exception:
                pass

    @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
    def test_just_script(self, fob):
        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(NOOP_CALLBACK)

        fob.assert_called_once()
        args, _ = fob.call_args
        self.assertEqual(os.path.realpath(args[0]), os.path.realpath(SCRIPT_PATH))
        method_type = type(self.setUp)
        self.assertEqual(type(args[1]), method_type)

        fob.reset_mock()
        lsw.update_watched_modules()
        lsw.update_watched_modules()
        lsw.update_watched_modules()
        lsw.update_watched_modules()

        self.assertEqual(fob.call_count, 1)  # __init__.py

    @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
    def test_permission_error(self, fob):
        fob.side_effect = PermissionError("This error should be caught!")
        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(NOOP_CALLBACK)

    @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
    def test_script_and_2_modules_at_once(self, fob):
        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(NOOP_CALLBACK)

        fob.assert_called_once()

        sys.modules["DUMMY_MODULE_1"] = DUMMY_MODULE_1
        sys.modules["DUMMY_MODULE_2"] = DUMMY_MODULE_2

        fob.reset_mock()
        lsw.update_watched_modules()

        self.assertEqual(fob.call_count, 3)  # dummy modules and __init__.py

        method_type = type(self.setUp)

        call_args_list = sort_args_list(fob.call_args_list)

        args, _ = call_args_list[0]
        self.assertIn("__init__.py", args[0])
        args, _ = call_args_list[1]
        self.assertEqual(args[0], DUMMY_MODULE_1_FILE)
        self.assertEqual(type(args[1]), method_type)
        args, _ = call_args_list[2]
        self.assertEqual(args[0], DUMMY_MODULE_2_FILE)
        self.assertEqual(type(args[1]), method_type)

        fob.reset_mock()
        lsw.update_watched_modules()

        self.assertEqual(fob.call_count, 0)

    @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
    def test_script_and_2_modules_in_series(self, fob):
        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(NOOP_CALLBACK)

        fob.assert_called_once()

        sys.modules["DUMMY_MODULE_1"] = DUMMY_MODULE_1
        fob.reset_mock()

        lsw.update_watched_modules()

        self.assertEqual(fob.call_count, 2)  # dummy module and __init__.py

        method_type = type(self.setUp)

        call_args_list = sort_args_list(fob.call_args_list)

        args, _ = call_args_list[0]
        self.assertIn("__init__.py", args[0])

        args, _ = call_args_list[1]
        self.assertEqual(args[0], DUMMY_MODULE_1_FILE)
        self.assertEqual(type(args[1]), method_type)

        sys.modules["DUMMY_MODULE_2"] = DUMMY_MODULE_2
        fob.reset_mock()
        lsw.update_watched_modules()

        args, _ = fob.call_args
        self.assertEqual(args[0], DUMMY_MODULE_2_FILE)
        self.assertEqual(type(args[1]), method_type)

        fob.assert_called_once()

    @patch("streamlit.watcher.local_sources_watcher._LOGGER")
    @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
    def test_misbehaved_module(self, fob, patched_logger):
        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(NOOP_CALLBACK)

        fob.assert_called_once()

        sys.modules["MISBEHAVED_MODULE"] = MISBEHAVED_MODULE.MisbehavedModule
        fob.reset_mock()
        lsw.update_watched_modules()

        fob.assert_called_once()  # Just __init__.py

        patched_logger.warning.assert_called_once_with(
            "Examining the path of MisbehavedModule raised:",
            exc_info=True,
        )

    @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
    def test_nested_module_parent_unloaded(self, fob):
        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(NOOP_CALLBACK)

        fob.assert_called_once()

        with patch(
            "sys.modules",
            {
                "DUMMY_MODULE_1": DUMMY_MODULE_1,
                "NESTED_MODULE_PARENT": NESTED_MODULE_PARENT,
                "NESTED_MODULE_CHILD": NESTED_MODULE_CHILD,
            },
        ):
            lsw.update_watched_modules()

            # Simulate a change to the child module
            lsw.on_file_changed(NESTED_MODULE_CHILD_FILE)

            # Assert that both the parent and child are unloaded, ready for reload
            self.assertNotIn("NESTED_MODULE_CHILD", sys.modules)
            self.assertNotIn("NESTED_MODULE_PARENT", sys.modules)

    @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
    def test_config_blacklist(self, fob):
        """Test server.folderWatchBlacklist"""
        prev_blacklist = config.get_option("server.folderWatchBlacklist")

        config.set_option(
            "server.folderWatchBlacklist", [os.path.dirname(DUMMY_MODULE_1.__file__)]
        )

        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(NOOP_CALLBACK)

        fob.assert_called_once()

        sys.modules["DUMMY_MODULE_1"] = DUMMY_MODULE_1
        fob.reset_mock()

        lsw.update_watched_modules()

        fob.assert_not_called()

        # Reset the config object.
        config.set_option("server.folderWatchBlacklist", prev_blacklist)

    def test_config_watcherType(self):
        """Test server.fileWatcherType"""

        config.set_option("server.fileWatcherType", "none")
        self.assertEqual(
            local_sources_watcher.get_default_path_watcher_class().__name__,
            "NoOpPathWatcher",
        )

        config.set_option("server.fileWatcherType", "poll")
        self.assertEqual(
            local_sources_watcher.get_default_path_watcher_class().__name__,
            "PollingPathWatcher",
        )

        config.set_option("server.fileWatcherType", "watchdog")
        self.assertEqual(
            local_sources_watcher.get_default_path_watcher_class().__name__,
            "EventBasedPathWatcher" if _is_watchdog_available() else "NoOpPathWatcher",
        )

        config.set_option("server.fileWatcherType", "auto")
        self.assertIsNotNone(local_sources_watcher.get_default_path_watcher_class())

        if sys.modules["streamlit.watcher.event_based_path_watcher"] is not None:
            self.assertEqual(
                local_sources_watcher.get_default_path_watcher_class().__name__,
                "EventBasedPathWatcher",
            )
        else:
            self.assertEqual(
                local_sources_watcher.get_default_path_watcher_class().__name__,
                "PollingPathWatcher",
            )

    @patch("streamlit.watcher.local_sources_watcher.PathWatcher", new=NoOpPathWatcher)
    def test_does_nothing_if_NoOpPathWatcher(self):
        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(NOOP_CALLBACK)
        lsw.update_watched_modules()
        self.assertEqual(len(lsw._watched_modules), 0)

    @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
    def test_namespace_package_unloaded(self, fob):
        import tests.streamlit.watcher.test_data.namespace_package as pkg

        pkg_path = os.path.abspath(pkg.__path__._path[0])

        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(NOOP_CALLBACK)

        fob.assert_called_once()

        with patch("sys.modules", {"pkg": pkg}):
            lsw.update_watched_modules()

            # Simulate a change to the child module
            lsw.on_file_changed(pkg_path)

            # Assert that both the parent and child are unloaded, ready for reload
            self.assertNotIn("pkg", sys.modules)

        del sys.modules["tests.streamlit.watcher.test_data.namespace_package"]

    @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
    def test_module_caching(self, _fob):
        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(NOOP_CALLBACK)

        register = MagicMock()
        lsw._register_necessary_watchers = register

        # Updates modules on first run
        lsw.update_watched_modules()
        register.assert_called_once()

        # Skips update when module list hasn't changed
        register.reset_mock()
        lsw.update_watched_modules()
        register.assert_not_called()

        # Invalidates cache when a new module is imported
        register.reset_mock()
        sys.modules["DUMMY_MODULE_2"] = DUMMY_MODULE_2
        lsw.update_watched_modules()
        register.assert_called_once()

        # Skips update when new module is part of cache
        register.reset_mock()
        lsw.update_watched_modules()
        register.assert_not_called()

    @patch(
        "streamlit.runtime.pages_manager.PagesManager.get_pages",
        MagicMock(
            return_value={
                "someHash1": {
                    "page_name": "streamlit_app",
                    "script_path": "streamlit_app.py",
                },
                "someHash2": {
                    "page_name": "streamlit_app2",
                    "script_path": "streamlit_app2.py",
                },
            }
        ),
    )
    @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
    def test_watches_all_page_scripts(self, fob):
        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(NOOP_CALLBACK)

        args1, _ = fob.call_args_list[0]
        args2, _ = fob.call_args_list[1]

        assert args1[0] == "streamlit_app.py"
        assert args2[0] == "streamlit_app2.py"

    @patch(
        "streamlit.runtime.pages_manager.PagesManager.get_pages",
        MagicMock(
            side_effect=[
                {
                    "someHash1": {
                        "page_name": "streamlit_app",
                        "script_path": "streamlit_app.py",
                    },
                    "someHash2": {
                        "page_name": "streamlit_app2",
                        "script_path": "streamlit_app2.py",
                    },
                },
                {
                    "someHash1": {
                        "page_name": "streamlit_app",
                        "script_path": "streamlit_app.py",
                    },
                    "someHash3": {
                        "page_name": "streamlit_app3",
                        "script_path": "streamlit_app3.py",
                    },
                },
            ]
        ),
    )
    @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
    def test_watches_new_page_scripts(self, fob):
        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(NOOP_CALLBACK)

        args1, _ = fob.call_args_list[0]
        args2, _ = fob.call_args_list[1]

        assert args1[0] == "streamlit_app.py"
        assert args2[0] == "streamlit_app2.py"

        lsw.update_watched_pages()
        args3, _ = fob.call_args_list[2]
        assert args3[0] == "streamlit_app3.py"

    @patch(
        "streamlit.runtime.pages_manager.PagesManager.get_pages",
        MagicMock(
            side_effect=[
                {
                    "someHash1": {
                        "page_name": "page1",
                        "script_path": "page1.py",
                    },
                    "someHash2": {
                        "page_name": "page2",
                        "script_path": "page2.py",
                    },
                },
                {
                    "someHash1": {
                        "page_name": "page1",
                        "script_path": "page1.py",
                    },
                    "someHash3": {
                        "page_name": "page3",
                        "script_path": "page3.py",
                    },
                },
            ]
        ),
    )
    @patch("streamlit.watcher.local_sources_watcher.PathWatcher", MagicMock())
    def test_watches_union_of_page_scripts(self):
        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        assert lsw._watched_pages == {"page1.py", "page2.py"}

        def isfile_mock(x):
            return True

        with patch("os.path.isfile", wraps=isfile_mock):
            lsw.update_watched_pages()
            assert lsw._watched_pages == {"page1.py", "page2.py", "page3.py"}

    @patch(
        "streamlit.runtime.pages_manager.PagesManager.get_pages",
        MagicMock(
            side_effect=[
                {
                    "someHash1": {
                        "page_name": "page1",
                        "script_path": "page1.py",
                    },
                    "someHash2": {
                        "page_name": "page2",
                        "script_path": "page2.py",
                    },
                },
                {
                    "someHash1": {
                        "page_name": "page1",
                        "script_path": "page1.py",
                    },
                    "someHash3": {
                        "page_name": "page3",
                        "script_path": "page3.py",
                    },
                },
            ]
        ),
    )
    @patch("streamlit.watcher.local_sources_watcher.PathWatcher", MagicMock())
    def test_unwatches_invalid_page_script_paths(self):
        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        assert lsw._watched_pages == {"page1.py", "page2.py"}

        def isfile_mock(x):
            return x != "page2.py"

        with patch("os.path.isfile", wraps=isfile_mock):
            lsw.update_watched_pages()
            assert lsw._watched_pages == {"page1.py", "page3.py"}

    @patch("streamlit.watcher.local_sources_watcher.PathWatcher")
    def test_passes_filepath_to_callback(self, fob):
        saved_filepath = None

        def callback(filepath):
            nonlocal saved_filepath

            saved_filepath = filepath

        lsw = local_sources_watcher.LocalSourcesWatcher(PagesManager(SCRIPT_PATH))
        lsw.register_file_change_callback(callback)

        # Simulate a change to the report script
        lsw.on_file_changed(SCRIPT_PATH)

        self.assertEqual(saved_filepath, SCRIPT_PATH)


def test_get_module_paths_outputs_abs_paths():
    mock_module = MagicMock()
    mock_module.__file__ = os.path.relpath(DUMMY_MODULE_1_FILE)

    module_paths = local_sources_watcher.get_module_paths(mock_module)
    assert module_paths == {DUMMY_MODULE_1_FILE}


def sort_args_list(args_list):
    return sorted(args_list, key=lambda args: args[0])


================================================
File: /lib/tests/streamlit/watcher/path_watcher_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Tests the public utility functions in path_watcher.py"""

from __future__ import annotations

import unittest
from unittest.mock import Mock, call, patch

import streamlit.watcher.path_watcher
from streamlit.watcher.path_watcher import (
    NoOpPathWatcher,
    get_default_path_watcher_class,
    watch_dir,
    watch_file,
)
from tests.testutil import patch_config_options


class FileWatcherTest(unittest.TestCase):
    @patch_config_options({"server.fileWatcherType": "watchdog"})
    def test_report_watchdog_availability_mac(self):
        with patch(
            "streamlit.watcher.path_watcher._is_watchdog_available",
            return_value=False,
        ), patch("streamlit.env_util.IS_DARWIN", new=True), patch(
            "click.secho"
        ) as mock_echo:
            streamlit.watcher.path_watcher.report_watchdog_availability()

        msg = "\n  $ xcode-select --install"
        calls = [
            call(
                "  %s" % "For better performance, install the Watchdog module:",
                fg="blue",
                bold=True,
            ),
            call(
                """%s
  $ pip install watchdog
            """
                % msg
            ),
        ]
        mock_echo.assert_has_calls(calls)

    @patch_config_options({"server.fileWatcherType": "poll"})
    def test_no_watchdog_suggestion_for_poll_type(self):
        with patch(
            "streamlit.watcher.path_watcher._is_watchdog_available", return_value=False
        ), patch("streamlit.env_util.IS_DARWIN", new=False), patch(
            "click.secho"
        ) as mock_echo:
            streamlit.watcher.path_watcher.report_watchdog_availability()
        mock_echo.assert_not_called()

    @patch_config_options({"server.fileWatcherType": "none"})
    def test_no_watchdog_suggestion_for_none_type(self):
        with patch(
            "streamlit.watcher.path_watcher._is_watchdog_available", return_value=False
        ), patch("streamlit.env_util.IS_DARWIN", new=False), patch(
            "click.secho"
        ) as mock_echo:
            streamlit.watcher.path_watcher.report_watchdog_availability()
        mock_echo.assert_not_called()

    def test_report_watchdog_availability_nonmac(self):
        with patch(
            "streamlit.watcher.path_watcher._is_watchdog_available", return_value=False
        ), patch("streamlit.env_util.IS_DARWIN", new=False), patch(
            "click.secho"
        ) as mock_echo:
            streamlit.watcher.path_watcher.report_watchdog_availability()

        msg = ""
        calls = [
            call(
                "  %s" % "For better performance, install the Watchdog module:",
                fg="blue",
                bold=True,
            ),
            call(
                """%s
  $ pip install watchdog
            """
                % msg
            ),
        ]
        mock_echo.assert_has_calls(calls)

    @patch("streamlit.watcher.path_watcher.PollingPathWatcher")
    @patch("streamlit.watcher.event_based_path_watcher.EventBasedPathWatcher")
    def test_watch_file(self, mock_event_watcher, mock_polling_watcher):
        """Test all possible outcomes of both `get_default_path_watcher_class` and
        `watch_file`, based on config.fileWatcherType and whether
        `watchdog_available` is true.
        """
        subtest_params = [
            (None, False, NoOpPathWatcher),
            (None, True, NoOpPathWatcher),
            ("poll", False, mock_polling_watcher),
            ("poll", True, mock_polling_watcher),
            ("watchdog", False, NoOpPathWatcher),
            ("watchdog", True, mock_event_watcher),
            ("auto", False, mock_polling_watcher),
            ("auto", True, mock_event_watcher),
        ]
        for watcher_config, watchdog_available, path_watcher_class in subtest_params:
            test_name = f"config.fileWatcherType={watcher_config}, watcher_available={watchdog_available}"
            with self.subTest(test_name):
                with patch_config_options(
                    {"server.fileWatcherType": watcher_config}
                ), patch(
                    "streamlit.watcher.path_watcher._is_watchdog_available",
                    return_value=watchdog_available,
                ):
                    # Test get_default_path_watcher_class() result
                    self.assertEqual(
                        path_watcher_class, get_default_path_watcher_class()
                    )

                    # Test watch_file(). If path_watcher_class is
                    # NoOpPathWatcher, nothing should happen. Otherwise,
                    # path_watcher_class should be called with the watch_file
                    # params.
                    on_file_changed = Mock()
                    watching_file = watch_file("some/file/path", on_file_changed)
                    if path_watcher_class is not NoOpPathWatcher:
                        path_watcher_class.assert_called_with(
                            "some/file/path",
                            on_file_changed,
                            glob_pattern=None,
                            allow_nonexistent=False,
                        )
                        self.assertTrue(watching_file)
                    else:
                        self.assertFalse(watching_file)

    @patch(
        "streamlit.watcher.path_watcher._is_watchdog_available", Mock(return_value=True)
    )
    @patch("streamlit.watcher.event_based_path_watcher.EventBasedPathWatcher")
    def test_watch_dir_kwarg_plumbing(self, mock_event_watcher):
        # NOTE: We only test kwarg plumbing for watch_dir since watcher_class
        # selection is tested extensively in test_watch_file, and the two
        # functions are otherwise identical.
        on_file_changed = Mock()

        watching_dir = watch_dir(
            "some/dir/path",
            on_file_changed,
            watcher_type="watchdog",
            glob_pattern="*.py",
            allow_nonexistent=True,
        )

        self.assertTrue(watching_dir)
        mock_event_watcher.assert_called_with(
            "some/dir/path/",
            on_file_changed,
            glob_pattern="*.py",
            allow_nonexistent=True,
        )


================================================
File: /lib/tests/streamlit/watcher/polling_path_watcher_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import unittest
from unittest import mock

from streamlit.watcher import polling_path_watcher


class PollingPathWatcherTest(unittest.TestCase):
    """Test PollingPathWatcher."""

    def setUp(self):
        super().setUp()
        self.util_patch = mock.patch("streamlit.watcher.polling_path_watcher.util")
        self.util_mock = self.util_patch.start()

        # Patch PollingPathWatcher's thread pool executor. We want to do
        # all of our test polling on the test thread, so we accumulate
        # tasks here and run them manually via `_run_executor_tasks`.
        self._executor_tasks = []
        self.executor_patch = mock.patch(
            "streamlit.watcher.polling_path_watcher.PollingPathWatcher._executor",
        )
        executor_mock = self.executor_patch.start()
        executor_mock.submit = self._submit_executor_task

        # Patch PollingPathWatcher's `time.sleep` to no-op, so that the tasks
        # submitted to our mock executor don't block.
        self.sleep_patch = mock.patch(
            "streamlit.watcher.polling_path_watcher.time.sleep"
        )
        self.sleep_patch.start()

    def tearDown(self):
        super().tearDown()
        self.util_patch.stop()
        self.executor_patch.stop()
        self.sleep_patch.stop()

    def _submit_executor_task(self, task):
        """Submit a new task to our mock executor."""
        self._executor_tasks.append(task)

    def _run_executor_tasks(self):
        """Run all tasks that have been submitted to our mock executor."""
        tasks = self._executor_tasks
        self._executor_tasks = []
        for task in tasks:
            task()

    def test_file_watch_and_callback(self):
        """Test that when a file is modified, the callback is called."""
        callback = mock.Mock()

        self.util_mock.path_modification_time = lambda *args: 101.0
        self.util_mock.calc_md5_with_blocking_retries = lambda _, **kwargs: "1"

        watcher = polling_path_watcher.PollingPathWatcher(
            "/this/is/my/file.py", callback
        )

        self._run_executor_tasks()
        callback.assert_not_called()

        self.util_mock.path_modification_time = lambda *args: 102.0
        self.util_mock.calc_md5_with_blocking_retries = lambda _, **kwargs: "2"

        self._run_executor_tasks()
        callback.assert_called_once()

        watcher.close()

    def test_callback_not_called_if_same_mtime(self):
        """Test that we ignore files with same mtime."""
        callback = mock.Mock()

        self.util_mock.path_modification_time = lambda *args: 101.0
        self.util_mock.calc_md5_with_blocking_retries = lambda _, **kwargs: "1"

        watcher = polling_path_watcher.PollingPathWatcher(
            "/this/is/my/file.py", callback
        )

        self._run_executor_tasks()
        callback.assert_not_called()

        # Same mtime!
        self.util_mock.calc_md5_with_blocking_retries = lambda _, **kwargs: "2"

        # This is the test:
        self._run_executor_tasks()
        callback.assert_not_called()

        watcher.close()

    def test_callback_called_if_modification_time_0(self):
        """Test that callback are executed anyway even if modification time is 0.0"""
        callback = mock.Mock()

        self.util_mock.path_modification_time = lambda *args: 0.0
        self.util_mock.calc_md5_with_blocking_retries = lambda _, **kwargs: "11"

        watcher = polling_path_watcher.PollingPathWatcher(
            "/this/is/my/folder/", callback
        )

        self._run_executor_tasks()
        callback.assert_not_called()

        # Same mtime!
        self.util_mock.calc_md5_with_blocking_retries = lambda _, **kwargs: "22"

        # This is the test:
        self._run_executor_tasks()
        callback.assert_called()

        watcher.close()

    def test_callback_not_called_if_same_md5(self):
        """Test that we ignore files with same md5."""
        callback = mock.Mock()

        self.util_mock.path_modification_time = lambda *args: 101.0
        self.util_mock.calc_md5_with_blocking_retries = lambda _, **kwargs: "1"

        watcher = polling_path_watcher.PollingPathWatcher(
            "/this/is/my/file.py", callback
        )

        self._run_executor_tasks()
        callback.assert_not_called()

        self.util_mock.path_modification_time = lambda *args: 102.0
        # Same MD5

        # This is the test:
        self._run_executor_tasks()
        callback.assert_not_called()

        watcher.close()

    def test_kwargs_plumbed_to_calc_md5(self):
        """Test that we pass the glob_pattern and allow_nonexistent kwargs to
        calc_md5_with_blocking_retries.

        `PollingPathWatcher`s can be created with optional kwargs allowing
        the caller to specify what types of files to watch (when watching a
        directory) and whether to allow watchers on paths with no files/dirs.
        This test ensures that these optional parameters make it to our hash
        calculation helpers across different on_changed events.
        """
        callback = mock.Mock()

        self.util_mock.path_modification_time = lambda *args: 101.0
        self.util_mock.calc_md5_with_blocking_retries = mock.Mock(return_value="1")

        watcher = polling_path_watcher.PollingPathWatcher(
            "/this/is/my/dir",
            callback,
            glob_pattern="*.py",
            allow_nonexistent=True,
        )

        self._run_executor_tasks()
        callback.assert_not_called()
        _, kwargs = self.util_mock.calc_md5_with_blocking_retries.call_args
        assert kwargs == {"glob_pattern": "*.py", "allow_nonexistent": True}

        self.util_mock.path_modification_time = lambda *args: 102.0
        self.util_mock.calc_md5_with_blocking_retries = mock.Mock(return_value="2")

        self._run_executor_tasks()
        callback.assert_called_once()
        _, kwargs = self.util_mock.calc_md5_with_blocking_retries.call_args
        assert kwargs == {"glob_pattern": "*.py", "allow_nonexistent": True}

        watcher.close()

    def test_multiple_watchers_same_file(self):
        """Test that we can have multiple watchers of the same file."""
        filename = "/this/is/my/file.py"

        mod_count = [0.0]

        def modify_mock_file():
            self.util_mock.path_modification_time = lambda *args: mod_count[0]
            self.util_mock.calc_md5_with_blocking_retries = (
                lambda _, **kwargs: "%d" % mod_count[0]
            )

            mod_count[0] += 1.0

        modify_mock_file()

        callback1 = mock.Mock()
        callback2 = mock.Mock()

        watcher1 = polling_path_watcher.PollingPathWatcher(filename, callback1)
        watcher2 = polling_path_watcher.PollingPathWatcher(filename, callback2)

        self._run_executor_tasks()

        callback1.assert_not_called()
        callback2.assert_not_called()

        # "Modify" our file
        modify_mock_file()
        self._run_executor_tasks()

        self.assertEqual(callback1.call_count, 1)
        self.assertEqual(callback2.call_count, 1)

        # Close watcher1. Only watcher2's callback should be called after this.
        watcher1.close()

        # Modify our file again
        modify_mock_file()
        self._run_executor_tasks()

        self.assertEqual(callback1.call_count, 1)
        self.assertEqual(callback2.call_count, 2)

        watcher2.close()

        # Modify our file a final time
        modify_mock_file()

        # Both watchers are now closed, so their callback counts
        # should not have increased.
        self.assertEqual(callback1.call_count, 1)
        self.assertEqual(callback2.call_count, 2)


================================================
File: /lib/tests/streamlit/watcher/util_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import tempfile
import unittest
from unittest.mock import MagicMock, mock_open, patch

from streamlit.watcher import util


class UtilTest(unittest.TestCase):
    def test_md5_calculation_succeeds_with_bytes_input(self):
        with patch("streamlit.watcher.util.open", mock_open(read_data=b"hello")):
            md5 = util.calc_md5_with_blocking_retries("foo")
            self.assertEqual(md5, "5d41402abc4b2a76b9719d911017c592")

    @patch("os.path.isdir", MagicMock(return_value=True))
    @patch("streamlit.watcher.util._stable_dir_identifier")
    def test_md5_calculation_succeeds_with_dir_input(self, mock_stable_dir_identifier):
        mock_stable_dir_identifier.return_value = "hello"

        md5 = util.calc_md5_with_blocking_retries("foo")
        self.assertEqual(md5, "5d41402abc4b2a76b9719d911017c592")
        mock_stable_dir_identifier.assert_called_once_with("foo", "*")

    @patch("os.path.isdir", MagicMock(return_value=True))
    @patch("streamlit.watcher.util._stable_dir_identifier")
    def test_md5_calculation_can_pass_glob(self, mock_stable_dir_identifier):
        mock_stable_dir_identifier.return_value = "hello"

        util.calc_md5_with_blocking_retries("foo", glob_pattern="*.py")
        mock_stable_dir_identifier.assert_called_once_with("foo", "*.py")

    @patch("os.path.exists", MagicMock(return_value=False))
    def test_md5_calculation_allow_nonexistent(self):
        md5 = util.calc_md5_with_blocking_retries("hello", allow_nonexistent=True)
        self.assertEqual(md5, "5d41402abc4b2a76b9719d911017c592")

    def test_md5_calculation_opens_file_with_rb(self):
        # This tests implementation :( . But since the issue this is addressing
        # could easily come back to bite us if a distracted coder tweaks the
        # implementation, I'm putting this here anyway.
        with patch("streamlit.watcher.util.open", mock_open(read_data=b"hello")) as m:
            util.calc_md5_with_blocking_retries("foo")
            m.assert_called_once_with("foo", "rb")


class FakeStat:
    """Emulates the output of os.stat()."""

    def __init__(self, mtime):
        self.st_mtime = mtime


class PathModificationTimeTests(unittest.TestCase):
    @patch("streamlit.watcher.util.os.stat", MagicMock(return_value=FakeStat(101.0)))
    @patch("streamlit.watcher.util.os.path.exists", MagicMock(return_value=True))
    def test_st_mtime_if_file_exists(self):
        assert util.path_modification_time("foo") == 101.0

    @patch("streamlit.watcher.util.os.stat", MagicMock(return_value=FakeStat(101.0)))
    @patch("streamlit.watcher.util.os.path.exists", MagicMock(return_value=True))
    def test_st_mtime_if_file_exists_and_allow_nonexistent(self):
        assert util.path_modification_time("foo", allow_nonexistent=True) == 101.0

    @patch("streamlit.watcher.util.os.path.exists", MagicMock(return_value=False))
    def test_zero_if_file_nonexistent_and_allow_nonexistent(self):
        assert util.path_modification_time("foo", allow_nonexistent=True) == 0.0


class DirHelperTests(unittest.TestCase):
    def setUp(self) -> None:
        self._test_dir = tempfile.TemporaryDirectory()

        def create_file(prefix, suffix):
            return tempfile.NamedTemporaryFile(
                dir=self._test_dir.name, prefix=prefix, suffix=suffix, delete=False
            )

        create_file("01", ".py")
        create_file("02", ".py")
        create_file("03", ".py")
        create_file("04", ".rs")
        create_file(".05", ".py")

    def tearDown(self) -> None:
        self._test_dir.cleanup()

    def test_dirfiles_sorts_files_and_ignores_hidden(self):
        dirfiles = util._dirfiles(self._test_dir.name, "*")
        filename_prefixes = [f[:2] for f in dirfiles.split("+")]
        assert filename_prefixes == ["01", "02", "03", "04"]

    def test_dirfiles_glob_pattern(self):
        dirfiles = util._dirfiles(self._test_dir.name, "*.py")
        filename_prefixes = [f[:2] for f in dirfiles.split("+")]
        assert filename_prefixes == ["01", "02", "03"]

    @patch("streamlit.watcher.util._dirfiles", MagicMock(side_effect=["foo", "foo"]))
    def test_stable_dir(self):
        assert util._stable_dir_identifier("my_dir", "*") == "my_dir+foo"

    @patch(
        "streamlit.watcher.util._dirfiles", MagicMock(side_effect=["foo", "bar", "bar"])
    )
    def test_stable_dir_files_change(self):
        assert util._stable_dir_identifier("my_dir", "*") == "my_dir+bar"


================================================
File: /lib/tests/streamlit/watcher/test_data/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/watcher/test_data/dummy_module1.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/watcher/test_data/dummy_module2.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/watcher/test_data/misbehaved_module.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import types


class _MisbehavedModule(types.ModuleType):
    @property
    def __spec__(self):
        raise Exception("Oh noes!")


MisbehavedModule = _MisbehavedModule("MisbehavedModule")


================================================
File: /lib/tests/streamlit/watcher/test_data/nested_module_child.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/watcher/test_data/nested_module_parent.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import tests.streamlit.watcher.test_data.nested_module_child as NESTED_MODULE_CHILD  # noqa: F401


================================================
File: /lib/tests/streamlit/watcher/test_data/namespace_package/empty_file.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/web/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/web/bootstrap_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import os.path
import sys
from io import StringIO
from unittest import IsolatedAsyncioTestCase
from unittest.mock import Mock, patch

from streamlit import config
from streamlit.web import bootstrap
from tests import testutil
from tests.testutil import patch_config_options


class BootstrapPrintTest(IsolatedAsyncioTestCase):
    """Test bootstrap.py's printing functions.

    (We use `IsolatedAsyncioTestCase` to ensure that an asyncio event loop
    exists in tests that implicitly rely on one.)
    """

    def setUp(self):
        self.orig_stdout = sys.stdout
        sys.stdout = StringIO()

    def tearDown(self):
        sys.stdout.close()  # sys.stdout is a StringIO at this point.
        sys.stdout = self.orig_stdout

    def test_print_hello_message(self):
        mock_is_manually_set = testutil.build_mock_config_is_manually_set(
            {"browser.serverAddress": True}
        )
        mock_get_option = testutil.build_mock_config_get_option(
            {"browser.serverAddress": "the-address"}
        )

        with patch.object(config, "get_option", new=mock_get_option), patch.object(
            config, "is_manually_set", new=mock_is_manually_set
        ):
            bootstrap._print_url(True)

        out = sys.stdout.getvalue()
        self.assertIn("Welcome to Streamlit. Check out our demo in your browser.", out)
        self.assertIn("URL: http://the-address", out)

    def test_print_urls_configured(self):
        mock_is_manually_set = testutil.build_mock_config_is_manually_set(
            {"browser.serverAddress": True}
        )
        mock_get_option = testutil.build_mock_config_get_option(
            {"browser.serverAddress": "the-address"}
        )

        with patch.object(config, "get_option", new=mock_get_option), patch.object(
            config, "is_manually_set", new=mock_is_manually_set
        ):
            bootstrap._print_url(False)

        out = sys.stdout.getvalue()
        self.assertIn("You can now view your Streamlit app in your browser.", out)
        self.assertIn("URL: http://the-address", out)

    @patch("streamlit.net_util.get_external_ip")
    @patch("streamlit.net_util.get_internal_ip")
    def test_print_urls_remote(self, mock_get_internal_ip, mock_get_external_ip):
        mock_is_manually_set = testutil.build_mock_config_is_manually_set(
            {"browser.serverAddress": False}
        )
        mock_get_option = testutil.build_mock_config_get_option(
            {"server.headless": True}
        )

        mock_get_internal_ip.return_value = "internal-ip"
        mock_get_external_ip.return_value = "external-ip"

        with patch.object(config, "get_option", new=mock_get_option), patch.object(
            config, "is_manually_set", new=mock_is_manually_set
        ):
            bootstrap._print_url(False)

        out = sys.stdout.getvalue()
        self.assertIn("Local URL: http://localhost", out)
        self.assertIn("Network URL: http://internal-ip", out)
        self.assertIn("External URL: http://external-ip", out)

    @patch("streamlit.net_util.get_external_ip")
    @patch("streamlit.net_util.get_internal_ip")
    def test_print_urls_remote_no_external(
        self, mock_get_internal_ip, mock_get_external_ip
    ):
        mock_is_manually_set = testutil.build_mock_config_is_manually_set(
            {"browser.serverAddress": False}
        )
        mock_get_option = testutil.build_mock_config_get_option(
            {"server.headless": True}
        )

        mock_get_internal_ip.return_value = "internal-ip"
        mock_get_external_ip.return_value = None

        with patch.object(config, "get_option", new=mock_get_option), patch.object(
            config, "is_manually_set", new=mock_is_manually_set
        ):
            bootstrap._print_url(False)

        out = sys.stdout.getvalue()
        self.assertIn("Local URL: http://localhost", out)
        self.assertIn("Network URL: http://internal-ip", out)
        self.assertNotIn("External URL: http://external-ip", out)

    @patch("streamlit.net_util.get_external_ip")
    @patch("streamlit.net_util.get_internal_ip")
    def test_print_urls_remote_no_internal(
        self, mock_get_internal_ip, mock_get_external_ip
    ):
        mock_is_manually_set = testutil.build_mock_config_is_manually_set(
            {"browser.serverAddress": False}
        )
        mock_get_option = testutil.build_mock_config_get_option(
            {"server.headless": True}
        )

        mock_get_internal_ip.return_value = None
        mock_get_external_ip.return_value = "external-ip"

        with patch.object(config, "get_option", new=mock_get_option), patch.object(
            config, "is_manually_set", new=mock_is_manually_set
        ):
            bootstrap._print_url(False)

        out = sys.stdout.getvalue()
        self.assertIn("Local URL: http://localhost", out)
        self.assertNotIn("Network URL: http://internal-ip", out)
        self.assertIn("External URL: http://external-ip", out)

    @patch("streamlit.net_util.get_internal_ip")
    def test_print_urls_local(self, mock_get_internal_ip):
        mock_is_manually_set = testutil.build_mock_config_is_manually_set(
            {"browser.serverAddress": False}
        )
        mock_get_option = testutil.build_mock_config_get_option(
            {"server.headless": False}
        )

        mock_get_internal_ip.return_value = "internal-ip"

        with patch.object(config, "get_option", new=mock_get_option), patch.object(
            config, "is_manually_set", new=mock_is_manually_set
        ):
            bootstrap._print_url(False)

        out = sys.stdout.getvalue()
        self.assertIn("Local URL: http://localhost", out)
        self.assertIn("Network URL: http://internal-ip", out)

    @patch("streamlit.net_util.get_internal_ip")
    def test_print_urls_port(self, mock_get_internal_ip):
        mock_is_manually_set = testutil.build_mock_config_is_manually_set(
            {"browser.serverAddress": False}
        )
        mock_get_option = testutil.build_mock_config_get_option(
            {
                "server.headless": False,
                "server.port": 9988,
                "global.developmentMode": False,
            }
        )

        mock_get_internal_ip.return_value = "internal-ip"

        with patch.object(config, "get_option", new=mock_get_option), patch.object(
            config, "is_manually_set", new=mock_is_manually_set
        ):
            bootstrap._print_url(False)

        out = sys.stdout.getvalue()
        self.assertIn("Local URL: http://localhost:9988", out)
        self.assertIn("Network URL: http://internal-ip:9988", out)

    @patch("streamlit.net_util.get_internal_ip")
    def test_print_urls_base(self, mock_get_internal_ip):
        mock_is_manually_set = testutil.build_mock_config_is_manually_set(
            {"browser.serverAddress": False}
        )
        mock_get_option = testutil.build_mock_config_get_option(
            {
                "server.headless": False,
                "server.baseUrlPath": "foo",
                "server.port": 8501,
                "global.developmentMode": False,
            }
        )

        mock_get_internal_ip.return_value = "internal-ip"

        with patch.object(config, "get_option", new=mock_get_option), patch.object(
            config, "is_manually_set", new=mock_is_manually_set
        ):
            bootstrap._print_url(False)

        out = sys.stdout.getvalue()
        self.assertIn("Local URL: http://localhost:8501/foo", out)
        self.assertIn("Network URL: http://internal-ip:8501/foo", out)

    @patch("streamlit.net_util.get_internal_ip")
    def test_print_urls_base_no_internal(self, mock_get_internal_ip):
        mock_is_manually_set = testutil.build_mock_config_is_manually_set(
            {"browser.serverAddress": False}
        )
        mock_get_option = testutil.build_mock_config_get_option(
            {
                "server.headless": False,
                "server.baseUrlPath": "foo",
                "server.port": 8501,
                "global.developmentMode": False,
            }
        )

        mock_get_internal_ip.return_value = None

        with patch.object(config, "get_option", new=mock_get_option), patch.object(
            config, "is_manually_set", new=mock_is_manually_set
        ):
            bootstrap._print_url(False)

        out = sys.stdout.getvalue()
        self.assertIn("Local URL: http://localhost:8501/foo", out)
        self.assertNotIn("Network URL: http://internal-ip:8501/foo", out)

    @patch("streamlit.net_util.get_internal_ip", return_value="internal-ip")
    def test_print_urls_ssl(self, mock_get_internal_ip):
        with patch_config_options(
            {
                "server.headless": False,
                "server.port": 9988,
                "global.developmentMode": False,
                "server.sslCertFile": "/tmp/aa",
                "server.sslKeyFile": "/tmp/aa",
            }
        ):
            bootstrap._print_url(False)

        out = sys.stdout.getvalue()
        self.assertIn("Local URL: https://localhost:9988", out)
        self.assertIn("Network URL: https://internal-ip:9988", out)

    def test_print_socket(self):
        mock_is_manually_set = testutil.build_mock_config_is_manually_set(
            {"browser.serverAddress": False}
        )

        mock_get_option = testutil.build_mock_config_get_option(
            {
                "server.address": "unix://mysocket.sock",
                "global.developmentMode": False,
            }
        )

        with patch.object(config, "get_option", new=mock_get_option), patch.object(
            config, "is_manually_set", new=mock_is_manually_set
        ):
            bootstrap._print_url(False)

        out = sys.stdout.getvalue()
        self.assertIn("Unix Socket: unix://mysocket.sock", out)

    @patch("streamlit.web.bootstrap.GitRepo")
    def test_print_old_git_warning(self, mock_git_repo):
        mock_git_repo.return_value.is_valid.return_value = False
        mock_git_repo.return_value.git_version = (1, 2, 3)

        bootstrap._maybe_print_old_git_warning("main_script_path")
        out = sys.stdout.getvalue()
        self.assertIn("Streamlit requires Git 2.7.0 or later, but you have 1.2.3.", out)

    @patch("streamlit.web.bootstrap.asyncio.get_running_loop", Mock())
    @patch("streamlit.web.bootstrap.secrets.load_if_toml_exists", Mock())
    @patch("streamlit.web.bootstrap._maybe_print_static_folder_warning")
    def test_maybe_print_static_folder_warning_called_once_on_server_start(
        self, mock_maybe_print_static_folder_warning
    ):
        """We should trigger _maybe_print_static_folder_warning on server start."""
        bootstrap._on_server_start(Mock())
        mock_maybe_print_static_folder_warning.assert_called_once()

    @patch("os.path.isdir", Mock(return_value=False))
    @patch("click.secho")
    def test_maybe_print_static_folder_warning_if_folder_doesnt_exist(self, mock_echo):
        """We should print a warning when static folder does not exist."""

        with testutil.patch_config_options({"server.enableStaticServing": True}):
            bootstrap._maybe_print_static_folder_warning("app_root/main_script_path")
            mock_echo.assert_called_once_with(
                "WARNING: Static file serving is enabled, but no static folder found "
                f"at {os.path.abspath('app_root/static')}. To disable static file "
                f"serving, set server.enableStaticServing to false.",
                fg="yellow",
            )

    @patch("os.path.isdir", Mock(return_value=True))
    @patch(
        "streamlit.file_util.get_directory_size",
        Mock(return_value=(2 * bootstrap.MAX_APP_STATIC_FOLDER_SIZE)),
    )
    @patch("click.secho")
    def test_maybe_print_static_folder_warning_if_folder_is_too_large(self, mock_echo):
        """
        We should print a warning and disable static files serving when static
        folder total size is too large.
        """

        with testutil.patch_config_options(
            {"server.enableStaticServing": True}
        ), patch.object(config, "set_option") as mock_set_option:
            bootstrap._maybe_print_static_folder_warning("app_root/main_script_path")
            mock_echo.assert_called_once_with(
                "WARNING: Static folder size is larger than 1GB. "
                "Static file serving has been disabled.",
                fg="yellow",
            )
            mock_set_option.assert_called_once_with("server.enableStaticServing", False)

    @patch("streamlit.config.get_config_options")
    def test_load_config_options(self, patched_get_config_options):
        """Test that bootstrap.load_config_options parses the keys properly and
        passes down the parameters.
        """

        flag_options = {
            "server_port": 3005,
            "server_headless": True,
            "browser_serverAddress": "localhost",
            "logger_level": "error",
            # global_minCachedMessageSize shouldn't be set below since it's None.
            "global_minCachedMessageSize": None,
        }

        bootstrap.load_config_options(flag_options)

        patched_get_config_options.assert_called_once_with(
            force_reparse=True,
            options_from_flags={
                "server.port": 3005,
                "server.headless": True,
                "browser.serverAddress": "localhost",
                "logger.level": "error",
            },
        )

    @patch("streamlit.web.bootstrap.asyncio.get_running_loop", Mock())
    @patch("streamlit.web.bootstrap._maybe_print_static_folder_warning", Mock())
    @patch("streamlit.web.bootstrap.secrets.load_if_toml_exists")
    def test_load_secrets(self, mock_load_secrets):
        """We should load secrets.toml on startup."""
        bootstrap._on_server_start(Mock())
        mock_load_secrets.assert_called_once()

    @patch("streamlit.web.bootstrap.asyncio.get_running_loop", Mock())
    @patch("streamlit.web.bootstrap._maybe_print_static_folder_warning", Mock())
    @patch("streamlit.web.bootstrap._LOGGER.error")
    @patch("streamlit.web.bootstrap.secrets.load_if_toml_exists")
    def test_log_secret_load_error(self, mock_load_secrets, mock_log_error):
        """If secrets throws an error on startup, we catch and log it."""
        mock_exception = Exception("Secrets exploded!")
        mock_load_secrets.side_effect = mock_exception

        bootstrap._on_server_start(Mock())
        mock_log_error.assert_called_once_with(
            "Failed to load secrets.toml file",
            exc_info=mock_exception,
        )

    @patch("streamlit.config.get_config_options")
    @patch("streamlit.web.bootstrap.watch_file")
    def test_install_config_watcher(
        self, patched_watch_file, patched_get_config_options
    ):
        with patch("os.path.exists", return_value=True):
            bootstrap._install_config_watchers(flag_options={"server_port": 8502})
        self.assertEqual(patched_watch_file.call_count, 2)

        args, _kwargs = patched_watch_file.call_args_list[0]
        on_config_changed = args[1]

        # Simulate a config file change being detected.
        on_config_changed("/unused/nonexistent/file/path")

        patched_get_config_options.assert_called_once_with(
            force_reparse=True,
            options_from_flags={
                "server.port": 8502,
            },
        )


================================================
File: /lib/tests/streamlit/web/cli_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Unit tests for the Streamlit CLI."""

from __future__ import annotations

import contextlib
import os
import subprocess
import sys
import tempfile
import unittest
from pathlib import Path
from unittest import mock
from unittest.mock import MagicMock, patch

import pytest
import requests
import requests_mock
from click.testing import CliRunner
from parameterized import parameterized
from requests.adapters import HTTPAdapter, Retry
from testfixtures import tempdir

import streamlit
import streamlit.web.bootstrap
from streamlit import config
from streamlit.config_option import ConfigOption
from streamlit.runtime.credentials import Credentials
from streamlit.web import cli
from streamlit.web.cli import _convert_config_option_to_click_option
from tests import testutil


class CliTest(unittest.TestCase):
    """Unit tests for the cli."""

    def setUp(self):
        # Credentials._singleton should be None here, but a mis-behaving
        # test may have left it intact.
        Credentials._singleton = None

        cli.name = "streamlit"
        self.runner = CliRunner()

        self.patches = [
            patch.object(config._on_config_parsed, "send"),
            # Make sure the calls to `streamlit run` in this file don't unset
            # the config options loaded in conftest.py.
            patch.object(streamlit.web.bootstrap, "load_config_options"),
        ]

        for p in self.patches:
            p.start()

    def tearDown(self):
        Credentials._singleton = None

        for p in self.patches:
            p.stop()

    def test_run_no_arguments(self):
        """streamlit run should fail if run with no arguments."""
        result = self.runner.invoke(cli, ["run"])
        self.assertNotEqual(0, result.exit_code)

    def test_run_existing_file_argument(self):
        """streamlit run succeeds if an existing file is passed."""
        with patch("streamlit.url_util.is_url", return_value=False), patch(
            "streamlit.web.cli._main_run"
        ), patch("os.path.exists", return_value=True):
            result = self.runner.invoke(cli, ["run", "file_name.py"])
        self.assertEqual(0, result.exit_code)

    def test_run_non_existing_file_argument(self):
        """streamlit run should fail if a non existing file is passed."""

        with patch("streamlit.url_util.is_url", return_value=False), patch(
            "streamlit.web.cli._main_run"
        ), patch("os.path.exists", return_value=False):
            result = self.runner.invoke(cli, ["run", "file_name.py"])
        self.assertNotEqual(0, result.exit_code)
        self.assertIn("File does not exist", result.output)

    def test_run_not_allowed_file_extension(self):
        """streamlit run should fail if a not allowed file extension is passed."""

        result = self.runner.invoke(cli, ["run", "file_name.doc"])

        self.assertNotEqual(0, result.exit_code)
        self.assertIn(
            "Streamlit requires raw Python (.py) files, not .doc.", result.output
        )

    @tempdir()
    def test_run_valid_url(self, temp_dir):
        """streamlit run succeeds if an existing url is passed."""

        with patch("streamlit.url_util.is_url", return_value=True), patch(
            "streamlit.web.cli._main_run"
        ), requests_mock.mock() as m:
            file_content = b"content"
            m.get("http://url/app.py", content=file_content)
            with patch("streamlit.temporary_directory.TemporaryDirectory") as mock_tmp:
                mock_tmp.return_value.__enter__.return_value = temp_dir.path
                result = self.runner.invoke(cli, ["run", "http://url/app.py"])
                with open(os.path.join(temp_dir.path, "app.py"), "rb") as f:
                    self.assertEqual(file_content, f.read())

        self.assertEqual(0, result.exit_code)

    @tempdir()
    def test_run_non_existing_url(self, temp_dir):
        """streamlit run should fail if a non existing but valid
        url is passed.
        """

        with patch("streamlit.url_util.is_url", return_value=True), patch(
            "streamlit.web.cli._main_run"
        ), requests_mock.mock() as m:
            m.get("http://url/app.py", exc=requests.exceptions.RequestException)
            with patch("streamlit.temporary_directory.TemporaryDirectory") as mock_tmp:
                mock_tmp.return_value.__enter__.return_value = temp_dir.path
                result = self.runner.invoke(cli, ["run", "http://url/app.py"])

        self.assertNotEqual(0, result.exit_code)
        self.assertIn("Unable to fetch", result.output)

    def test_run_arguments(self):
        """The correct command line should be passed downstream."""
        with patch("streamlit.url_util.is_url", return_value=False), patch(
            "os.path.exists", return_value=True
        ):
            with patch("streamlit.web.cli._main_run") as mock_main_run:
                result = self.runner.invoke(
                    cli,
                    [
                        "run",
                        "some script.py",
                        "argument with space",
                        "argument with another space",
                    ],
                )
        mock_main_run.assert_called_once()
        positional_args = mock_main_run.call_args[0]
        self.assertEqual(positional_args[0], "some script.py")
        self.assertEqual(
            positional_args[1],
            ("argument with space", "argument with another space"),
        )
        self.assertEqual(0, result.exit_code)

    def test_run_command_with_flag_config_options(self):
        with patch("streamlit.url_util.is_url", return_value=False), patch(
            "streamlit.web.cli._main_run"
        ), patch("os.path.exists", return_value=True):
            result = self.runner.invoke(
                cli, ["run", "file_name.py", "--server.port=8502"]
            )

        streamlit.web.bootstrap.load_config_options.assert_called_once()
        _args, kwargs = streamlit.web.bootstrap.load_config_options.call_args
        self.assertEqual(kwargs["flag_options"]["server_port"], 8502)
        self.assertEqual(0, result.exit_code)

    def test_run_command_with_multiple_secrets_path_single_value(self):
        with patch("streamlit.url_util.is_url", return_value=False), patch(
            "streamlit.web.cli._main_run"
        ), patch("os.path.exists", return_value=True):
            result = self.runner.invoke(
                cli, ["run", "file_name.py", "--secrets.files=secrets1.toml"]
            )

        streamlit.web.bootstrap.load_config_options.assert_called_once()
        _args, kwargs = streamlit.web.bootstrap.load_config_options.call_args
        assert kwargs["flag_options"]["secrets_files"] == ("secrets1.toml",)
        assert result.exit_code == 0

    def test_run_command_with_multiple_secrets_path_multiple_value(self):
        with patch("streamlit.url_util.is_url", return_value=False), patch(
            "streamlit.web.cli._main_run"
        ), patch("os.path.exists", return_value=True):
            result = self.runner.invoke(
                cli,
                [
                    "run",
                    "file_name.py",
                    "--secrets.files=secrets1.toml",
                    "--secrets.files=secrets2.toml",
                ],
            )

        streamlit.web.bootstrap.load_config_options.assert_called_once()
        _args, kwargs = streamlit.web.bootstrap.load_config_options.call_args
        assert kwargs["flag_options"]["secrets_files"] == (
            "secrets1.toml",
            "secrets2.toml",
        )
        assert result.exit_code == 0

    @parameterized.expand(["mapbox.token", "server.cookieSecret"])
    def test_run_command_with_sensitive_options_as_flag(self, sensitive_option):
        with patch("streamlit.url_util.is_url", return_value=False), patch(
            "streamlit.web.cli._main_run"
        ), patch("os.path.exists", return_value=True):
            result = self.runner.invoke(
                cli, ["run", "file_name.py", f"--{sensitive_option}=TESTSECRET"]
            )

        self.assertIn("option using the CLI flag is not allowed", result.output)
        self.assertEqual(1, result.exit_code)

    def test_get_command_line(self):
        """Test that _get_command_line_as_string correctly concatenates values
        from click.
        """
        mock_context = MagicMock()
        mock_context.parent.command_path = "streamlit"
        with patch("click.get_current_context", return_value=mock_context):
            with patch.object(sys, "argv", ["", "os_arg1", "os_arg2"]):
                result = cli._get_command_line_as_string()
                self.assertEqual("streamlit os_arg1 os_arg2", result)

    def test_get_command_line_without_parent_context(self):
        """Test that _get_command_line_as_string correctly returns None when
        there is no context parent
        """
        mock_context = MagicMock()
        mock_context.parent = None
        with patch("click.get_current_context", return_value=mock_context):
            result = cli._get_command_line_as_string()
            self.assertIsNone(result)

    def test_convert_config_option_to_click_option(self):
        """Test that configurator_options adds dynamic commands based on a
        config lists.
        """
        config_option = ConfigOption(
            "server.customKey",
            description="Custom description.\n\nLine one.",
            deprecated=False,
            type_=int,
        )

        result = _convert_config_option_to_click_option(config_option)

        self.assertEqual(result["option"], "--server.customKey")
        self.assertEqual(result["param"], "server_customKey")
        self.assertEqual(result["type"], config_option.type)
        self.assertEqual(result["description"], config_option.description)
        self.assertEqual(result["envvar"], "STREAMLIT_SERVER_CUSTOM_KEY")

    def test_convert_depecated_config_option_to_click_option(self):
        """Test that configurator_options adds extra deprecation information
        to config option's description
        """
        config_option = ConfigOption(
            "deprecated.customKey",
            description="Custom description.\n\nLine one.",
            deprecated=True,
            deprecation_text="Foo",
            expiration_date="Bar",
            type_=int,
        )

        result = _convert_config_option_to_click_option(config_option)

        self.assertEqual(
            "Custom description.\n\nLine one.\n Foo - Bar", result["description"]
        )

    def test_credentials_headless_no_config(self):
        """If headless mode and no config is present,
        activation should be None."""
        with testutil.patch_config_options({"server.headless": True}):
            with patch("streamlit.url_util.is_url", return_value=False), patch(
                "streamlit.web.bootstrap.run"
            ), patch("os.path.exists", return_value=True), patch(
                "streamlit.runtime.credentials._check_credential_file_exists",
                return_value=False,
            ):
                result = self.runner.invoke(cli, ["run", "some script.py"])
            from streamlit.runtime.credentials import Credentials

            credentials = Credentials.get_current()
            self.assertIsNone(credentials.activation)
            self.assertEqual(0, result.exit_code)

    @parameterized.expand([(True,), (False,)])
    def test_credentials_headless_with_config(self, headless_mode):
        """If headless, but a config file is present, activation should be
        defined.
        So we call `_check_activated`.
        """
        with testutil.patch_config_options({"server.headless": headless_mode}):
            with patch("streamlit.url_util.is_url", return_value=False), patch(
                "streamlit.web.bootstrap.run"
            ), patch("os.path.exists", return_value=True), mock.patch(
                "streamlit.runtime.credentials.Credentials._check_activated"
            ) as mock_check, patch(
                "streamlit.runtime.credentials._check_credential_file_exists",
                return_value=True,
            ):
                result = self.runner.invoke(cli, ["run", "some script.py"])
            self.assertTrue(mock_check.called)
            self.assertEqual(0, result.exit_code)

    @parameterized.expand([(True,), (False,)])
    def test_headless_telemetry_message(self, headless_mode):
        """If headless mode, show a message about usage metrics gathering."""

        with testutil.patch_config_options({"server.headless": headless_mode}):
            with patch("streamlit.url_util.is_url", return_value=False), patch(
                "os.path.exists", return_value=True
            ), patch("streamlit.config.is_manually_set", return_value=False), patch(
                "streamlit.runtime.credentials._check_credential_file_exists",
                return_value=False,
            ):
                result = self.runner.invoke(cli, ["run", "file_name.py"])

            self.assertNotEqual(0, result.exit_code)
            self.assertEqual(
                "Collecting usage statistics" in result.output,
                headless_mode,  # Should only be shown if n headless mode
            )

    def test_help_command(self):
        """Tests the help command redirects to using the --help flag"""
        with patch.object(sys, "argv", ["streamlit", "help"]) as args:
            self.runner.invoke(cli, ["help"])
            self.assertEqual("--help", args[1])

    def test_version_command(self):
        """Tests the version command redirects to using the --version flag"""
        with patch.object(sys, "argv", ["streamlit", "version"]) as args:
            self.runner.invoke(cli, ["version"])
            self.assertEqual("--version", args[1])

    def test_docs_command(self):
        """Tests the docs command opens the browser"""
        with patch("streamlit.cli_util.open_browser") as mock_open_browser:
            self.runner.invoke(cli, ["docs"])
            mock_open_browser.assert_called_once_with("https://docs.streamlit.io")

    def test_hello_command(self):
        """Tests the hello command runs the hello script in streamlit"""
        from streamlit.hello import streamlit_app

        with patch("streamlit.web.cli._main_run") as mock_main_run:
            self.runner.invoke(cli, ["hello"])

            mock_main_run.assert_called_once()
            positional_args = mock_main_run.call_args[0]
            self.assertEqual(positional_args[0], streamlit_app.__file__)

    @patch("streamlit.logger.get_logger")
    def test_hello_command_with_logs(self, get_logger):
        """Tests setting log level using --log_level prints a warning."""

        with patch("streamlit.web.cli._main_run"):
            self.runner.invoke(cli, ["--log_level", "error", "hello"])

            mock_logger = get_logger()
            mock_logger.warning.assert_called_once()

    def test_hello_command_with_flag_config_options(self):
        with patch("streamlit.url_util.is_url", return_value=False), patch(
            "streamlit.web.cli._main_run"
        ), patch("os.path.exists", return_value=True):
            result = self.runner.invoke(cli, ["hello", "--server.port=8502"])

        streamlit.web.bootstrap.load_config_options.assert_called_once()
        _args, kwargs = streamlit.web.bootstrap.load_config_options.call_args
        self.assertEqual(kwargs["flag_options"]["server_port"], 8502)
        self.assertEqual(0, result.exit_code)

    def test_config_show_command(self):
        """Tests the config show command calls the corresponding method in
        config
        """
        with patch("streamlit.config.show_config") as mock_config:
            self.runner.invoke(cli, ["config", "show"])
            mock_config.assert_called()

    def test_config_show_command_with_flag_config_options(self):
        with patch("streamlit.url_util.is_url", return_value=False), patch(
            "streamlit.web.cli._main_run"
        ), patch("os.path.exists", return_value=True):
            result = self.runner.invoke(cli, ["config", "show", "--server.port=8502"])

        streamlit.web.bootstrap.load_config_options.assert_called_once()
        _args, kwargs = streamlit.web.bootstrap.load_config_options.call_args
        self.assertEqual(kwargs["flag_options"]["server_port"], 8502)
        self.assertEqual(0, result.exit_code)

    @patch(
        "streamlit.runtime.caching.storage.local_disk_cache_storage.LocalDiskCacheStorageManager.clear_all"
    )
    @patch("streamlit.runtime.caching.cache_resource.clear")
    def test_cache_clear_all_caches(self, clear_resource_caches, clear_data_caches):
        """cli.clear_cache should clear st.cache_data and st.cache_resource"""
        self.runner.invoke(cli, ["cache", "clear"])
        clear_resource_caches.assert_called_once()
        clear_data_caches.assert_called_once()

    def test_activate_command(self):
        """Tests activating a credential"""
        mock_credential = MagicMock()
        with mock.patch(
            "streamlit.runtime.credentials.Credentials.get_current",
            return_value=mock_credential,
        ):
            self.runner.invoke(cli, ["activate"])
            mock_credential.activate.assert_called()

    def test_activate_without_command(self):
        """Tests that it doesn't activate the credential when not specified"""
        mock_credential = MagicMock()
        with mock.patch(
            "streamlit.runtime.credentials.Credentials.get_current",
            return_value=mock_credential,
        ):
            self.runner.invoke(cli)
            mock_credential.activate.assert_not_called()

    def test_reset_command(self):
        """Tests resetting a credential"""
        mock_credential = MagicMock()
        with mock.patch(
            "streamlit.runtime.credentials.Credentials.get_current",
            return_value=mock_credential,
        ):
            self.runner.invoke(cli, ["activate", "reset"])
            mock_credential.reset.assert_called()


class HTTPServerIntegrationTest(unittest.TestCase):
    def get_http_session(self) -> requests.Session:
        http_session = requests.Session()
        http_session.mount(
            "https://", HTTPAdapter(max_retries=Retry(total=10, backoff_factor=0.2))
        )
        http_session.mount("http://", HTTPAdapter(max_retries=None))
        return http_session

    @unittest.skipIf(
        "win32" in sys.platform, "openssl not present on windows by default"
    )
    def test_ssl(self):
        with contextlib.ExitStack() as exit_stack:
            tmp_home = exit_stack.enter_context(tempfile.TemporaryDirectory())
            (Path(tmp_home) / ".streamlit").mkdir()
            (Path(tmp_home) / ".streamlit" / "credentials.toml").write_text(
                '[general]\nemail = ""'
            )
            cert_file = Path(tmp_home) / "cert.cert"
            key_file = Path(tmp_home) / "key.key"
            pem_file = Path(tmp_home) / "public.pem"

            subprocess.check_call(
                [
                    "openssl",
                    "req",
                    "-x509",
                    "-newkey",
                    "rsa:4096",
                    "-keyout",
                    str(key_file),
                    "-out",
                    str(cert_file),
                    "-sha256",
                    "-days",
                    "365",
                    "-nodes",
                    "-subj",
                    "/CN=localhost",
                    # sublectAltName is required by modern browsers
                    # See: https://github.com/urllib3/urllib3/issues/497
                    "-addext",
                    "subjectAltName = DNS:localhost",
                ]
            )
            subprocess.check_call(
                [
                    "openssl",
                    "x509",
                    "-inform",
                    "PEM",
                    "-in",
                    str(cert_file),
                    "-out",
                    str(pem_file),
                ]
            )
            https_session = exit_stack.enter_context(self.get_http_session())
            proc = exit_stack.enter_context(
                subprocess.Popen(
                    [
                        sys.executable,
                        "-m",
                        "streamlit",
                        "hello",
                        "--global.developmentMode=False",
                        "--server.sslCertFile",
                        str(cert_file),
                        "--server.sslKeyFile",
                        str(key_file),
                        "--server.headless",
                        "true",
                        "--server.port=8510",
                    ],
                    env={**os.environ, "HOME": tmp_home},
                )
            )
            try:
                response = https_session.get(
                    "https://localhost:8510/healthz", verify=str(pem_file)
                )
                response.raise_for_status()
                assert response.text == "ok"
                # HTTP traffic is restricted
                with pytest.raises(requests.exceptions.ConnectionError):
                    response = https_session.get("http://localhost:8510/healthz")
                    response.raise_for_status()
            finally:
                proc.kill()


================================================
File: /lib/tests/streamlit/web/server/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/web/server/app_static_file_handler_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import mimetypes
import os
import sys
import tempfile
import unittest
from unittest.mock import MagicMock, patch

import tornado.httpserver
import tornado.testing
import tornado.web
import tornado.websocket

from streamlit.web.server import Server
from streamlit.web.server.app_static_file_handler import (
    MAX_APP_STATIC_FILE_SIZE,
    AppStaticFileHandler,
)


@unittest.skipIf(
    "win32" in sys.platform,
    "Most windows installs do not support symlinks except as admin",
)
class AppStaticFileHandlerTest(tornado.testing.AsyncHTTPTestCase):
    def setUp(self) -> None:
        self._tmpdir = tempfile.TemporaryDirectory(dir=os.getcwd())
        self._tmpfile = tempfile.NamedTemporaryFile(dir=self._tmpdir.name, delete=False)
        self._tmp_js_file = tempfile.NamedTemporaryFile(
            dir=self._tmpdir.name, suffix="script.js", delete=False
        )
        self._tmp_webp_file = tempfile.NamedTemporaryFile(
            dir=self._tmpdir.name, suffix="file.webp", delete=False
        )
        self._tmp_png_image_file = tempfile.NamedTemporaryFile(
            dir=self._tmpdir.name, suffix="image.png", delete=False
        )
        self._tmp_pdf_document_file = tempfile.NamedTemporaryFile(
            dir=self._tmpdir.name, suffix="document.pdf", delete=False
        )
        self._tmp_webp_image_file = tempfile.NamedTemporaryFile(
            dir=self._tmpdir.name, suffix="image.webp", delete=False
        )
        self._tmp_dir_inside_static_folder = tempfile.TemporaryDirectory(
            dir=self._tmpdir.name
        )

        self._symlink_outside_directory = "symlink_outside"
        self._symlink_inside_directory = "symlink_inside"

        os.symlink(
            "/", os.path.join(self._tmpdir.name, self._symlink_outside_directory)
        )
        os.symlink(
            self._tmpfile.name,
            os.path.join(self._tmpdir.name, self._symlink_inside_directory),
        )

        self._filename = os.path.basename(self._tmpfile.name)
        self._js_filename = os.path.basename(self._tmp_js_file.name)
        self._webp_filename = os.path.basename(self._tmp_webp_file.name)
        self._png_image_filename = os.path.basename(self._tmp_png_image_file.name)
        self._pdf_document_filename = os.path.basename(self._tmp_pdf_document_file.name)
        self._webp_image_filename = os.path.basename(self._tmp_webp_image_file.name)

        super().setUp()

    def tearDown(self) -> None:
        super().tearDown()
        self._tmpdir.cleanup()

    def get_app(self):
        return tornado.web.Application(
            [
                (
                    r"/app/static/(.*)",
                    AppStaticFileHandler,
                    {"path": "%s" % self._tmpdir.name},
                )
            ]
        )

    def test_static_files_200(self):
        """Files with extensions NOT listed in app_static_file_handler.py
        `SAFE_APP_STATIC_FILE_EXTENSIONS` should have the `Content-Type` header value
        equals to `text-plain`.
        """
        responses = [
            # self._filename is file without extension
            self.fetch(f"/app/static/{self._filename}"),
            # self._js_filename is file with '.js' extension
            self.fetch(f"/app/static/{self._js_filename}"),
            # self._symlink_inside_directory is symlink to
            # self._tmpfile (inside static directory)
            self.fetch(f"/app/static/{self._symlink_inside_directory}"),
        ]
        for r in responses:
            assert r.headers["Content-Type"] == "text/plain"
            assert r.headers["X-Content-Type-Options"] == "nosniff"
            assert r.code == 200

    def test_static_png_image_200(self):
        """Files with extensions listed in app_static_file_handler.py
        `SAFE_APP_STATIC_FILE_EXTENSIONS` (e.g. png) should have the
        `Content-Type` header based on their extension.
        """
        response = self.fetch(f"/app/static/{self._png_image_filename}")

        assert response.code == 200
        assert response.headers["Content-Type"] == "image/png"
        assert response.headers["X-Content-Type-Options"] == "nosniff"

    def test_static_webp_image_200(self):
        """Files with extensions listed in app_static_file_handler.py
        `SAFE_APP_STATIC_FILE_EXTENSIONS` (e.g. webp) should have the
        `Content-Type` header based on their extension.
        """
        response = self.fetch(f"/app/static/{self._webp_image_filename}")

        assert response.code == 200
        assert response.headers["Content-Type"] == "image/webp"
        assert response.headers["X-Content-Type-Options"] == "nosniff"

    def test_static_pdf_document_200(self):
        """Files with extensions listed in app_static_file_handler.py
        `SAFE_APP_STATIC_FILE_EXTENSIONS` (e.g. pdf) should have the
        `Content-Type` header based on their extension.
        """
        response = self.fetch(f"/app/static/{self._pdf_document_filename}")

        assert response.code == 200
        assert response.headers["Content-Type"] == "application/pdf"
        assert response.headers["X-Content-Type-Options"] == "nosniff"

    @patch("os.path.getsize", MagicMock(return_value=MAX_APP_STATIC_FILE_SIZE + 1))
    def test_big_file_404(self):
        """Files with size greater than MAX_APP_STATIC_FILE_SIZE should return 404."""
        response = self.fetch(f"/app/static/{self._png_image_filename}")
        assert response.code == 404
        self.assertEqual(
            b"<html><title>404: File is too large</title>"
            b"<body>404: File is too large</body></html>",
            response.body,
        )

    def test_staticfiles_404(self):
        """Non-existent files, files outside static directory and symlinks pointing to
        files outside static directory and directories should return 404.
        """
        responses = [
            # Access to directory without trailing slash
            self.fetch("/app/static"),
            # Access to non-existent file
            self.fetch("/app/static/nonexistent.jpg"),
        ]
        for r in responses:
            assert r.code == 404
            assert (
                r.body == b"<html><title>404: Not Found</title>"
                b"<body>404: Not Found</body></html>"
            )

    def test_staticfiles_403(self):
        """files outside static directory and symlinks pointing to
        files outside static directory and directories should return 403.
        """
        responses = [
            # Access to directory with trailing slash
            self.fetch("/app/static/"),
            # Access to directory inside static folder without trailing slash
            self.fetch(f"/app/static/{self._tmp_dir_inside_static_folder.name}"),
            # Access to directory inside static folder with trailing slash
            self.fetch(f"/app/static/{self._tmp_dir_inside_static_folder.name}/"),
            # Access to file outside static directory
            self.fetch("/app/static/../test_file_outside_directory.py"),
            # Access to file outside static directory with same prefix
            self.fetch(
                f"/app/static/{self._tmpdir.name}_foo/test_file_outside_directory.py"
            ),
            # Access to symlink outside static directory
            self.fetch(f"/app/static/{self._symlink_outside_directory}"),
        ]
        for r in responses:
            assert r.code == 403
            assert (
                r.body == b"<html><title>403: Forbidden</title>"
                b"<body>403: Forbidden</body></html>"
            )

    def test_mimetype_is_overridden_by_server(self):
        """Test content type of webps are set correctly"""
        mimetypes.add_type("custom/webp", ".webp")

        r = self.fetch(f"/app/static/{self._webp_filename}")
        assert r.headers["Content-Type"] == "custom/webp"

        Server.initialize_mimetypes()

        r = self.fetch(f"/app/static/{self._webp_filename}")
        assert r.headers["Content-Type"] == "image/webp"


================================================
File: /lib/tests/streamlit/web/server/authlib_tornado_integration_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Unit tests for authlib_tornado_integration.py."""

from __future__ import annotations

import unittest
from unittest.mock import MagicMock

from streamlit.runtime.secrets import AttrDict
from streamlit.web.server.authlib_tornado_integration import TornadoIntegration


class TornadoIntegrationTest(unittest.TestCase):
    def test_load_basic_config(self):
        basic_config_mock = MagicMock(
            config={
                "google": {
                    "client_id": "GOOGLE_CLIENT_ID",
                    "client_secret": "GOOGLE_CLIENT_SECRET",
                    "something": "else",
                },
                "okta": {
                    "client_id": "OKTA_CLIENT_ID",
                    "client_secret": "OKTA_CLIENT_SECRET",
                },
            }
        )

        prepared_google_config = TornadoIntegration.load_config(
            basic_config_mock, "google", ["client_id", "client_secret"]
        )
        prepared_okta_config = TornadoIntegration.load_config(
            basic_config_mock, "okta", ["client_id", "client_secret"]
        )

        assert prepared_google_config == {
            "client_id": "GOOGLE_CLIENT_ID",
            "client_secret": "GOOGLE_CLIENT_SECRET",
        }
        assert prepared_okta_config == {
            "client_id": "OKTA_CLIENT_ID",
            "client_secret": "OKTA_CLIENT_SECRET",
        }

    def test_load_config_with_client_kwargs(self):
        config_mock = MagicMock(
            config={
                "google": {
                    "client_id": "GOOGLE_CLIENT_ID",
                    "client_secret": "GOOGLE_CLIENT_SECRET",
                    "something": "else",
                    "client_kwargs": AttrDict(
                        {"prompt": "consent", "scope": "openid email profile"}
                    ),
                },
            }
        )

        prepared_google_config = TornadoIntegration.load_config(
            config_mock, "google", ["client_id", "client_secret", "client_kwargs"]
        )

        assert prepared_google_config == {
            "client_id": "GOOGLE_CLIENT_ID",
            "client_secret": "GOOGLE_CLIENT_SECRET",
            "client_kwargs": {"prompt": "consent", "scope": "openid email profile"},
        }

    def test_load_config_with_attr_dict(self):
        config_mock = MagicMock(
            config=AttrDict(
                {
                    "google": AttrDict(
                        {
                            "client_id": "GOOGLE_CLIENT_ID",
                            "client_secret": "GOOGLE_CLIENT_SECRET",
                            "something": "else",
                            "client_kwargs": AttrDict(
                                {"prompt": "consent", "scope": "openid email profile"}
                            ),
                        }
                    ),
                }
            )
        )

        prepared_google_config = TornadoIntegration.load_config(
            config_mock, "google", ["client_id", "client_secret", "client_kwargs"]
        )

        assert prepared_google_config == {
            "client_id": "GOOGLE_CLIENT_ID",
            "client_secret": "GOOGLE_CLIENT_SECRET",
            "client_kwargs": {"prompt": "consent", "scope": "openid email profile"},
        }


================================================
File: /lib/tests/streamlit/web/server/browser_websocket_handler_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from unittest.mock import ANY, MagicMock, patch

import tornado.httpserver
import tornado.testing
import tornado.web
import tornado.websocket

from streamlit.proto.BackMsg_pb2 import BackMsg
from streamlit.proto.ForwardMsg_pb2 import ForwardMsg
from streamlit.runtime import Runtime, SessionClientDisconnectedError
from streamlit.web.server.server import BrowserWebSocketHandler
from tests.streamlit.web.server.server_test_case import ServerTestCase
from tests.testutil import patch_config_options


class BrowserWebSocketHandlerTest(ServerTestCase):
    # NOTE: These tests are quite boilerplate-y and repetitive as
    # tornado.testing.AsyncHTTPTestCase doesn't have great support for being able to
    # define async setUp and tearDown functions :(

    @tornado.testing.gen_test
    async def test_connect_with_no_session_id(self):
        with self._patch_app_session(), patch.object(
            self.server._runtime, "connect_session"
        ) as patched_connect_session:
            await self.server.start()
            await self.ws_connect()

            patched_connect_session.assert_called_with(
                client=ANY,
                user_info=ANY,
                existing_session_id=None,
            )

    @tornado.testing.gen_test
    async def test_connect_with_session_id(self):
        with self._patch_app_session(), patch.object(
            self.server._runtime, "connect_session"
        ) as patched_connect_session:
            await self.server.start()
            await self.ws_connect(existing_session_id="session_id")

            patched_connect_session.assert_called_with(
                client=ANY,
                user_info=ANY,
                existing_session_id="session_id",
            )

    @tornado.testing.gen_test
    async def test_write_forward_msg_reraises_websocket_closed_error(self):
        """`write_forward_msg` should re-raise WebSocketClosedError
        as SessionClientDisconnectedError.
        """

        with self._patch_app_session():
            await self.server.start()
            await self.ws_connect()

            # Get our connected BrowserWebSocketHandler
            session_info = self.server._runtime._session_mgr.list_active_sessions()[0]
            websocket_handler = session_info.client
            self.assertIsInstance(websocket_handler, BrowserWebSocketHandler)

            # Patch _BrowserWebSocketHandler.write_message to raise an error
            with patch.object(websocket_handler, "write_message") as write_message_mock:
                write_message_mock.side_effect = tornado.websocket.WebSocketClosedError

                msg = ForwardMsg()
                msg.script_finished = (
                    ForwardMsg.ScriptFinishedStatus.FINISHED_SUCCESSFULLY
                )

                # Send a ForwardMsg. write_message will raise a
                # WebSocketClosedError, and write_forward_msg should re-raise
                # it as a SessionClientDisconnectedError.
                with self.assertRaises(SessionClientDisconnectedError):
                    websocket_handler.write_forward_msg(msg)

                write_message_mock.assert_called_once()

    @tornado.testing.gen_test
    async def test_backmsg_deserialization_exception(self):
        """If BackMsg deserialization raises an Exception, we should call the Runtime's
        handler.
        """
        with self._patch_app_session():
            await self.server.start()
            await self.ws_connect()

            # Get our connected BrowserWebSocketHandler
            session_info = self.server._runtime._session_mgr.list_active_sessions()[0]
            websocket_handler: BrowserWebSocketHandler = session_info.client

            mock_runtime = MagicMock(spec=Runtime)
            websocket_handler._runtime = mock_runtime

            # Send a malformed BackMsg
            websocket_handler.on_message(b"NotABackMsg")

            mock_runtime.handle_backmsg_deserialization_exception.assert_called_once()
            mock_runtime.handle_backmsg.assert_not_called()

    @patch_config_options({"global.developmentMode": False})
    @tornado.testing.gen_test
    async def test_ignores_debug_disconnect_websocket_when_not_dev_mode(self):
        with self._patch_app_session():
            await self.server.start()
            await self.ws_connect()

            # Get our BrowserWebSocketHandler
            session_info = self.server._runtime._session_mgr.list_active_sessions()[0]
            websocket_handler: BrowserWebSocketHandler = session_info.client

            websocket_handler.on_message(
                BackMsg(debug_disconnect_websocket=True).SerializeToString()
            )

            self.assertIsNotNone(websocket_handler.ws_connection)

    @patch_config_options({"global.developmentMode": True})
    @tornado.testing.gen_test
    async def test_follows_debug_disconnect_websocket_when_in_dev_mode(self):
        with self._patch_app_session():
            await self.server.start()
            await self.ws_connect()

            # Get our BrowserWebSocketHandler
            session_info = self.server._runtime._session_mgr.list_active_sessions()[0]
            websocket_handler: BrowserWebSocketHandler = session_info.client

            websocket_handler.on_message(
                BackMsg(debug_disconnect_websocket=True).SerializeToString()
            )

            self.assertIsNone(websocket_handler.ws_connection)

    @patch_config_options({"global.developmentMode": False})
    @tornado.testing.gen_test
    async def test_ignores_debug_shutdown_runtime_when_not_dev_mode(self):
        with self._patch_app_session():
            await self.server.start()
            await self.ws_connect()

            # Get our BrowserWebSocketHandler
            session_info = self.server._runtime._session_mgr.list_active_sessions()[0]
            websocket_handler: BrowserWebSocketHandler = session_info.client

            with patch.object(
                websocket_handler._runtime, "stop"
            ) as patched_stop_runtime:
                websocket_handler.on_message(
                    BackMsg(debug_shutdown_runtime=True).SerializeToString()
                )

                patched_stop_runtime.assert_not_called()

    @patch_config_options({"global.developmentMode": True})
    @tornado.testing.gen_test
    async def test_follows_debug_shutdown_runtime_when_in_dev_mode(self):
        with self._patch_app_session():
            await self.server.start()
            await self.ws_connect()

            # Get our BrowserWebSocketHandler
            session_info = self.server._runtime._session_mgr.list_active_sessions()[0]
            websocket_handler: BrowserWebSocketHandler = session_info.client

            with patch.object(
                websocket_handler._runtime, "stop"
            ) as patched_stop_runtime:
                websocket_handler.on_message(
                    BackMsg(debug_shutdown_runtime=True).SerializeToString()
                )

                patched_stop_runtime.assert_called_once()


================================================
File: /lib/tests/streamlit/web/server/component_request_handler_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import mimetypes
import threading
from unittest import mock

import tornado.testing
import tornado.web

from streamlit.components.lib.local_component_registry import LocalComponentRegistry
from streamlit.components.v1.component_registry import declare_component
from streamlit.runtime import Runtime, RuntimeConfig
from streamlit.runtime.memory_media_file_storage import MemoryMediaFileStorage
from streamlit.runtime.memory_uploaded_file_manager import MemoryUploadedFileManager
from streamlit.runtime.scriptrunner import add_script_run_ctx
from streamlit.web.server import ComponentRequestHandler, Server
from tests.testutil import create_mock_script_run_ctx

URL = "http://not.a.real.url:3001"
PATH = "/not/a/real/path"

MOCK_IS_DIR_PATH = "streamlit.components.lib.local_component_registry.os.path.isdir"


class ComponentRequestHandlerTest(tornado.testing.AsyncHTTPTestCase):
    """Test /component endpoint."""

    def setUp(self) -> None:
        config = RuntimeConfig(
            script_path="mock/script/path.py",
            command_line=None,
            component_registry=LocalComponentRegistry(),
            media_file_storage=MemoryMediaFileStorage("/mock/media"),
            uploaded_file_manager=MemoryUploadedFileManager("/mock/upload"),
        )
        self.runtime = Runtime(config)
        super().setUp()

        # declare_component needs a script_run_ctx to be set
        add_script_run_ctx(threading.current_thread(), create_mock_script_run_ctx())

    def tearDown(self) -> None:
        super().tearDown()
        Runtime._instance = None

    # get_app is called in the super constructor
    def get_app(self) -> tornado.web.Application:
        return tornado.web.Application(
            [
                (
                    "/component/(.*)",
                    ComponentRequestHandler,
                    dict(registry=self.runtime.component_registry),
                )
            ]
        )

    def _request_component(self, path):
        return self.fetch("/component/%s" % path, method="GET")

    def test_success_request(self):
        """Test request success when valid parameters are provided."""

        with mock.patch(MOCK_IS_DIR_PATH):
            # We don't need the return value in this case.
            declare_component("test", path=PATH)

        with mock.patch(
            "streamlit.web.server.component_request_handler.open",
            mock.mock_open(read_data="Test Content"),
        ):
            response = self._request_component(
                "tests.streamlit.web.server.component_request_handler_test.test"
            )

        self.assertEqual(200, response.code)
        self.assertEqual(b"Test Content", response.body)

    def test_outside_component_root_request(self):
        """Tests to ensure a path based on the root directory (and therefore
        outside of the component root) is disallowed."""

        with mock.patch(MOCK_IS_DIR_PATH):
            # We don't need the return value in this case.
            declare_component("test", path=PATH)

        response = self._request_component(
            "tests.streamlit.web.server.component_request_handler_test.test//etc/hosts"
        )

        self.assertEqual(403, response.code)
        self.assertEqual(b"forbidden", response.body)

    def test_outside_component_dir_with_same_prefix_request(self):
        """Tests to ensure a path based on the same prefix but a different
        directory test folder is forbidden."""

        with mock.patch(MOCK_IS_DIR_PATH):
            # We don't need the return value in this case.
            declare_component("test", path=PATH)

        response = self._request_component(
            f"tests.streamlit.web.server.component_request_handler_test.test/{PATH}_really"
        )

        self.assertEqual(403, response.code)
        self.assertEqual(b"forbidden", response.body)

    def test_relative_outside_component_root_request(self):
        """Tests to ensure a path relative to the component root directory
        (and specifically outside of the component root) is disallowed."""

        with mock.patch(MOCK_IS_DIR_PATH):
            # We don't need the return value in this case.
            declare_component("test", path=PATH)

        response = self._request_component(
            "tests.streamlit.web.server.component_request_handler_test.test/../foo"
        )

        self.assertEqual(403, response.code)
        self.assertEqual(b"forbidden", response.body)

    def test_invalid_component_request(self):
        """Test request failure when invalid component name is provided."""

        response = self._request_component("invalid_component")
        self.assertEqual(404, response.code)
        self.assertEqual(b"not found", response.body)

    def test_invalid_content_request(self):
        """Test request failure when invalid content (file) is provided."""

        with mock.patch(MOCK_IS_DIR_PATH):
            declare_component("test", path=PATH)

        with mock.patch("streamlit.web.server.component_request_handler.open") as m:
            m.side_effect = OSError("Invalid content")
            response = self._request_component(
                "tests.streamlit.web.server.component_request_handler_test.test"
            )

        self.assertEqual(404, response.code)
        self.assertEqual(
            b"read error",
            response.body,
        )

    def test_support_binary_files_request(self):
        """Test support for binary files reads."""

        def _open_read(m, payload):
            is_binary = False
            args, kwargs = m.call_args
            if len(args) > 1:
                if "b" in args[1]:
                    is_binary = True
            encoding = "utf-8"
            if "encoding" in kwargs:
                encoding = kwargs["encoding"]

            if is_binary:
                from io import BytesIO

                return BytesIO(payload)
            else:
                from io import TextIOWrapper

                return TextIOWrapper(str(payload, encoding=encoding))

        with mock.patch(MOCK_IS_DIR_PATH):
            declare_component("test", path=PATH)

        payload = b"\x00\x01\x00\x00\x00\x0d\x00\x80"  # binary non utf-8 payload

        with mock.patch("streamlit.web.server.component_request_handler.open") as m:
            m.return_value.__enter__ = lambda _: _open_read(m, payload)
            response = self._request_component(
                "tests.streamlit.web.server.component_request_handler_test.test"
            )

        self.assertEqual(200, response.code)
        self.assertEqual(
            payload,
            response.body,
        )

    def test_mimetype_is_overridden_by_server(self):
        """Test get_content_type function."""
        mimetypes.add_type("custom/html", ".html")
        mimetypes.add_type("custom/js", ".js")
        mimetypes.add_type("custom/css", ".css")

        assert ComponentRequestHandler.get_content_type("test.html") == "custom/html"
        assert ComponentRequestHandler.get_content_type("test.js") == "custom/js"
        assert ComponentRequestHandler.get_content_type("test.css") == "custom/css"

        # Have the server reinitialize the mimetypes
        Server.initialize_mimetypes()

        assert ComponentRequestHandler.get_content_type("test.html") == "text/html"
        assert (
            ComponentRequestHandler.get_content_type("test.js")
            == "application/javascript"
        )
        assert ComponentRequestHandler.get_content_type("test.css") == "text/css"


================================================
File: /lib/tests/streamlit/web/server/media_file_handler_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import Final
from unittest import mock
from unittest.mock import MagicMock

import tornado.testing
import tornado.web
from parameterized import parameterized

from streamlit.runtime.media_file_manager import MediaFileManager
from streamlit.runtime.memory_media_file_storage import MemoryMediaFileStorage
from streamlit.web.server.media_file_handler import MediaFileHandler

MOCK_ENDPOINT: Final = "/mock/media"


class MediaFileHandlerTest(tornado.testing.AsyncHTTPTestCase):
    def setUp(self) -> None:
        super().setUp()
        # Create a new MediaFileManager and assign its storage to
        # MediaFileHandler.
        storage = MemoryMediaFileStorage(MOCK_ENDPOINT)
        self.media_file_manager = MediaFileManager(storage)
        MediaFileHandler.initialize_storage(storage)

    def get_app(self) -> tornado.web.Application:
        return tornado.web.Application(
            [(f"{MOCK_ENDPOINT}/(.*)", MediaFileHandler, {"path": ""})]
        )

    @mock.patch(
        "streamlit.runtime.media_file_manager._get_session_id",
        MagicMock(return_value="mock_session_id"),
    )
    def test_media_file(self) -> None:
        """Requests for media files in MediaFileManager should succeed."""
        # Add a media file and read it back
        url = self.media_file_manager.add(b"mock_data", "video/mp4", "mock_coords")
        rsp = self.fetch(url, method="GET")

        self.assertEqual(200, rsp.code)
        self.assertEqual(b"mock_data", rsp.body)
        self.assertEqual("video/mp4", rsp.headers["Content-Type"])
        self.assertEqual(str(len(b"mock_data")), rsp.headers["Content-Length"])

    @parameterized.expand(
        [
            ("MockVideo.mp4", "video/mp4", 'attachment; filename="MockVideo.mp4"'),
            (
                b"\xe6\xbc\xa2\xe5\xad\x97.mp3".decode(),
                "video/mp4",
                "attachment; filename*=utf-8''%E6%BC%A2%E5%AD%97.mp3",
            ),
            (None, "text/plain", 'attachment; filename="streamlit_download.txt"'),
            (None, "video/mp4", 'attachment; filename="streamlit_download.mp4"'),
            (
                None,
                "application/octet-stream",
                'attachment; filename="streamlit_download.bin"',
            ),
        ]
    )
    @mock.patch(
        "streamlit.runtime.media_file_manager._get_session_id",
        MagicMock(return_value="mock_session_id"),
    )
    def test_downloadable_file(
        self, file_name, mimetype, content_disposition_header
    ) -> None:
        """Downloadable files get an additional 'Content-Disposition' header
        that includes their user-specified filename or
        generic filename if filename is not specified.
        """
        # Add a downloadable file with an optional filename
        url = self.media_file_manager.add(
            b"mock_data",
            mimetype,
            "mock_coords",
            file_name=file_name,
            is_for_static_download=True,
        )
        rsp = self.fetch(url, method="GET")

        self.assertEqual(200, rsp.code)
        self.assertEqual(b"mock_data", rsp.body)
        self.assertEqual(mimetype, rsp.headers["Content-Type"])
        self.assertEqual(str(len(b"mock_data")), rsp.headers["Content-Length"])
        self.assertEqual(content_disposition_header, rsp.headers["Content-Disposition"])

    def test_invalid_file(self) -> None:
        """Requests for invalid files fail with 404."""
        url = f"{MOCK_ENDPOINT}/invalid_media_file.mp4"
        rsp = self.fetch(url, method="GET")
        self.assertEqual(404, rsp.code)


================================================
File: /lib/tests/streamlit/web/server/oauth_authlib_routes_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from unittest.mock import MagicMock, patch

import tornado.httpserver
import tornado.testing
import tornado.web
import tornado.websocket

from streamlit.auth_util import encode_provider_token
from streamlit.web.server import oauth_authlib_routes
from streamlit.web.server.oauth_authlib_routes import (
    AuthCache,
    AuthCallbackHandler,
    AuthLoginHandler,
    AuthLogoutHandler,
)


class SecretMock(dict):
    def to_dict(self):
        return self


SECRETS_MOCK = SecretMock(
    {
        "redirect_uri": "http://localhost:8501/oauth2callback",
        "google": {
            "client_id": "CLIENT_ID",
            "client_secret": "CLIENT_SECRET",
            "server_metadata_url": "https://accounts.google.com/.well-known/openid-configuration",
        },
    }
)


@patch(
    "streamlit.auth_util.secrets_singleton",
    MagicMock(
        load_if_toml_exists=MagicMock(return_value=True),
        get=MagicMock(return_value=SECRETS_MOCK),
    ),
)
class LoginHandlerTest(tornado.testing.AsyncHTTPTestCase):
    def get_app(self):
        return tornado.web.Application(
            [
                (
                    r"/auth/login",
                    AuthLoginHandler,
                    {"base_url": ""},
                )
            ]
        )

    @patch(
        "streamlit.web.server.oidc_mixin.TornadoOAuth2App.client_cls.request",
        MagicMock(
            return_value=MagicMock(
                json=MagicMock(
                    return_value={
                        "authorization_endpoint": "https://accounts.google.com/o/oauth2/v2/auth",
                    }
                )
            )
        ),
    )
    def test_login_handler_success(self):
        """Test login handler success, when .well-known contains authorization_endpoint."""
        token = encode_provider_token("google")
        response = self.fetch(f"/auth/login?provider={token}", follow_redirects=False)

        authorization_url = response.headers["Location"]

        assert response.code == 302
        assert authorization_url.startswith(
            "https://accounts.google.com/o/oauth2/v2/auth"
        )
        assert "&client_id=CLIENT_ID" in authorization_url
        assert "CLIENT_SECRET" not in authorization_url
        assert "&prompt=select_account" in authorization_url
        assert "&scope=openid+email+profile" in authorization_url
        assert "&state=" in authorization_url
        assert (
            "&redirect_uri=http%3A%2F%2Flocalhost%3A8501%2Foauth2callback"
            in authorization_url
        )

    @patch(
        "streamlit.web.server.oidc_mixin.TornadoOAuth2App.client_cls.request",
        MagicMock(
            return_value=MagicMock(
                json=MagicMock(
                    return_value={
                        "invalid": "payload",
                    }
                )
            )
        ),
    )
    def test_login_handler_fail_on_malformed_wellknown(self):
        """Test login handler fail, when .well-known does not contain authorization_endpoint."""
        token = encode_provider_token("google")
        response = self.fetch(f"/auth/login?provider={token}", follow_redirects=False)
        assert response.code == 400
        assert b'400: Missing "authorize_url" value' in response.body
        assert "Location" not in response.headers

    @patch(
        "streamlit.web.server.oidc_mixin.TornadoOAuth2App.client_cls.request",
        MagicMock(
            return_value=MagicMock(
                raise_for_status=MagicMock(side_effect=Exception("Bad status")),
            )
        ),
    )
    def test_login_handler_fail_on_bad_status(self):
        """Test login handler fail, when .well-known request fails."""
        token = encode_provider_token("google")
        response = self.fetch(f"/auth/login?provider={token}", follow_redirects=False)
        assert response.code == 400
        assert b"400: Bad status" in response.body
        assert "Location" not in response.headers

    def test_login_handler_fail_on_missing_provider(self):
        """Test login handler fail, when provider is missing."""
        response = self.fetch("/auth/login", follow_redirects=False)
        assert response.code == 302
        assert response.headers["Location"] == "/"


class LogoutHandlerTest(tornado.testing.AsyncHTTPTestCase):
    def get_app(self):
        return tornado.web.Application(
            [
                (
                    r"/auth/logout",
                    AuthLogoutHandler,
                    {"base_url": ""},
                )
            ]
        )

    def test_logout_success(self):
        """Test logout handler success clear cookie."""
        response = self.fetch("/auth/logout", follow_redirects=False)
        assert response.code == 302
        assert response.headers["Location"] == "/"
        assert '_streamlit_user="";' in response.headers["Set-Cookie"]


@patch(
    "streamlit.auth_util.secrets_singleton",
    MagicMock(
        load_if_toml_exists=MagicMock(return_value=True),
        get=MagicMock(return_value=SECRETS_MOCK),
    ),
)
class AuthCallbackHandlerTest(tornado.testing.AsyncHTTPTestCase):
    def get_app(self):
        return tornado.web.Application(
            [
                (
                    r"/oauth2callback",
                    AuthCallbackHandler,
                    {"base_url": ""},
                )
            ],
            cookie_secret="AAAA",
        )

    def setUp(self) -> None:
        super().setUp()

        self.old_value = oauth_authlib_routes.auth_cache
        oauth_authlib_routes.auth_cache = AuthCache()
        oauth_authlib_routes.auth_cache.set("a_b_google_123", "AAA", None)

    def tearDown(self) -> None:
        oauth_authlib_routes.auth_cache = self.old_value

    @patch.object(AuthCallbackHandler, "set_auth_cookie")
    @patch(
        "streamlit.web.server.oauth_authlib_routes.create_oauth_client",
        return_value=(
            MagicMock(
                authorize_access_token=MagicMock(
                    return_value={"userinfo": {"email": "test@example.com"}}
                )
            ),
            MagicMock(),
        ),
    )
    def test_auth_callback_success(
        self, mock_create_oauth_client, mock_set_auth_cookie
    ):
        """Test auth callback success."""
        response = self.fetch("/oauth2callback?state=123", follow_redirects=False)
        mock_create_oauth_client.assert_called_with("google")
        mock_set_auth_cookie.assert_called_with(
            {
                "email": "test@example.com",
                "origin": "http://localhost:8501",
                "is_logged_in": True,
            }
        )

        assert response.code == 302
        assert response.headers["Location"] == "/"

    @patch.object(AuthCallbackHandler, "set_auth_cookie")
    def test_auth_callback_failure_missing_provider(self, mock_set_auth_cookie):
        """Test auth callback missing provider failure."""
        response = self.fetch("/oauth2callback?state=456", follow_redirects=False)
        mock_set_auth_cookie.assert_not_called()

        assert response.code == 302
        assert response.headers["Location"] == "/"

    def test_auth_callback_failure_missing_state(self):
        """Test auth callback failure missing state."""
        response = self.fetch("/oauth2callback", follow_redirects=False)
        assert response.code == 400

    @patch.object(AuthCallbackHandler, "set_auth_cookie")
    def test_auth_callback_with_error_query_param(self, mock_set_auth_cookie):
        response = self.fetch(
            "/oauth2callback?state=123&error=foo", follow_redirects=False
        )
        mock_set_auth_cookie.assert_not_called()

        assert response.code == 302
        assert response.headers["Location"] == "/"


================================================
File: /lib/tests/streamlit/web/server/oidc_mixin_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Unit tests for oidc_mixin.py."""

from __future__ import annotations

import unittest
from unittest.mock import MagicMock, patch

import pytest
from authlib.integrations.base_client import OAuthError

from streamlit.web.server.oidc_mixin import TornadoOAuth2App


class TornadoOAuth2AppTest(unittest.TestCase):
    @patch(
        "streamlit.web.server.oidc_mixin.OAuth2Mixin.load_server_metadata",
        MagicMock(
            return_value={
                "authorization_endpoint": "https://accounts.google.com/o/oauth2/v2/auth",
            }
        ),
    )
    def test_load_server_metadata_empty(self):
        """Test load_server_metadata with empty dict."""
        app = TornadoOAuth2App(MagicMock())
        result = app.load_server_metadata()
        assert result == {
            "authorization_endpoint": "https://accounts.google.com/o/oauth2/v2/auth"
        }
        assert app.client_kwargs == {}

    @patch(
        "streamlit.web.server.oidc_mixin.OAuth2Mixin.load_server_metadata",
        MagicMock(
            return_value={
                "authorization_endpoint": "https://accounts.google.com/o/oauth2/v2/auth",
                "code_challenge_methods_supported": ["plain", "S256"],
            }
        ),
    )
    def test_load_server_metadata_s256_plain(self):
        """Test load_server_metadata with S256 and plain code challenge methods."""
        app = TornadoOAuth2App(MagicMock())
        result = app.load_server_metadata()
        assert result == {
            "authorization_endpoint": "https://accounts.google.com/o/oauth2/v2/auth",
            "code_challenge_methods_supported": ["plain", "S256"],
        }
        assert app.client_kwargs == {"code_challenge_method": "S256"}

    def test_authorize_redirect(self):
        """Test authorize_redirect."""
        app = TornadoOAuth2App(MagicMock())
        app.create_authorization_url = MagicMock(
            return_value={"url": "https://example.com", "state": "some_state"}
        )
        request_handler = MagicMock()

        app.authorize_redirect(request_handler)
        request_handler.redirect.assert_called_once_with(
            "https://example.com", status=302
        )

        app.framework.set_state_data.assert_called_once_with(
            None, "some_state", {"redirect_uri": None, "url": "https://example.com"}
        )

    def test_authorize_redirect_error_no_state(self):
        """Test authorize_redirect without state raises error."""
        app = TornadoOAuth2App(MagicMock())
        app.create_authorization_url = MagicMock(
            return_value={"url": "https://example.com"}
        )
        request_handler = MagicMock()
        with pytest.raises(RuntimeError) as e:
            app.authorize_redirect(request_handler)

        assert e.match("Missing state value")

    def test_authorize_access_token_error(self):
        """Test authorize_access_token with error."""
        app = TornadoOAuth2App(MagicMock())
        with pytest.raises(OAuthError) as e:
            app.authorize_access_token(
                MagicMock(
                    get_argument=lambda x, *args: "some_error" if x == "error" else None
                )
            )
        assert e.match("some_error")

    @patch(
        "streamlit.web.server.oidc_mixin.TornadoOAuth2App.client_cls.request",
        MagicMock(
            return_value=MagicMock(
                json=MagicMock(
                    return_value={
                        "access_token": "payload",
                        "id_token": "id_token_payload",
                    }
                ),
                status_code=200,
            )
        ),
    )
    def test_authorize_access_token_success(self):
        """Test authorize_access_token with success."""
        app = TornadoOAuth2App(
            MagicMock(
                get_state_data=MagicMock(
                    return_value={
                        "redirect_uri": "http://localhost:8501/oauth2callback",
                        "nonce": "some_nonce",
                    }
                )
            )
        )

        app.parse_id_token = MagicMock(
            return_value={"email": "authed_user@example.com"}
        )

        def get_argument_mock(name: str, *args):
            if name == "code":
                return "some_code"
            if name == "state":
                return "some_state"
            return None

        token = app.authorize_access_token(MagicMock(get_argument=get_argument_mock))

        app.parse_id_token.assert_called_once_with(
            {
                "access_token": "payload",
                "id_token": "id_token_payload",
            },
            nonce="some_nonce",
            claims_options=None,
        )

        assert token == {
            "access_token": "payload",
            "id_token": "id_token_payload",
            "userinfo": {
                "email": "authed_user@example.com",
            },
        }


================================================
File: /lib/tests/streamlit/web/server/routes_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import json
import mimetypes
import os
import tempfile
from unittest.mock import MagicMock

import tornado.httpserver
import tornado.testing
import tornado.web
import tornado.websocket

from streamlit.runtime.forward_msg_cache import ForwardMsgCache, populate_hash_if_needed
from streamlit.runtime.runtime_util import serialize_forward_msg
from streamlit.web.server import Server
from streamlit.web.server.routes import _DEFAULT_ALLOWED_MESSAGE_ORIGINS
from streamlit.web.server.server import (
    HEALTH_ENDPOINT,
    HOST_CONFIG_ENDPOINT,
    MESSAGE_ENDPOINT,
    NEW_HEALTH_ENDPOINT,
    AddSlashHandler,
    HealthHandler,
    HostConfigHandler,
    MessageCacheHandler,
    RemoveSlashHandler,
    StaticFileHandler,
)
from tests.streamlit.message_mocks import create_dataframe_msg
from tests.testutil import patch_config_options


class HealthHandlerTest(tornado.testing.AsyncHTTPTestCase):
    """Tests the /_stcore/health endpoint"""

    def setUp(self):
        super().setUp()
        self._is_healthy = True

    async def is_healthy(self):
        return self._is_healthy, "ok"

    def get_app(self):
        return tornado.web.Application(
            [(rf"/{HEALTH_ENDPOINT}", HealthHandler, dict(callback=self.is_healthy))]
        )

    def test_health(self):
        response = self.fetch("/_stcore/health")
        self.assertEqual(200, response.code)
        self.assertEqual(b"ok", response.body)

        self._is_healthy = False
        response = self.fetch("/_stcore/health")
        self.assertEqual(503, response.code)

    def test_health_head(self):
        response = self.fetch("/_stcore/health", method="HEAD")
        self.assertEqual(200, response.code)

        self._is_healthy = False
        response = self.fetch("/_stcore/health", method="HEAD")
        self.assertEqual(503, response.code)

    @patch_config_options({"server.enableXsrfProtection": False})
    def test_health_without_csrf(self):
        response = self.fetch("/_stcore/health")
        self.assertEqual(200, response.code)
        self.assertEqual(b"ok", response.body)
        self.assertNotIn("Set-Cookie", response.headers)

    @patch_config_options({"server.enableXsrfProtection": True})
    def test_health_with_csrf(self):
        response = self.fetch("/_stcore/health")
        self.assertEqual(200, response.code)
        self.assertEqual(b"ok", response.body)
        self.assertIn("Set-Cookie", response.headers)

    def test_health_deprecated(self):
        response = self.fetch("/healthz")
        self.assertEqual(
            response.headers["link"],
            f'<http://127.0.0.1:{self.get_http_port()}/_stcore/health>; rel="alternate"',
        )
        self.assertEqual(response.headers["deprecation"], "True")

    def test_new_health_endpoint_should_not_display_deprecation_warning(self):
        response = self.fetch("/_stcore/health")
        self.assertNotIn("link", response.headers)
        self.assertNotIn("deprecation", response.headers)


class MessageCacheHandlerTest(tornado.testing.AsyncHTTPTestCase):
    def get_app(self):
        self._cache = ForwardMsgCache()
        return tornado.web.Application(
            [(rf"/{MESSAGE_ENDPOINT}", MessageCacheHandler, dict(cache=self._cache))]
        )

    def test_message_cache(self):
        # Create a new ForwardMsg and cache it
        msg = create_dataframe_msg([1, 2, 3])
        msg_hash = populate_hash_if_needed(msg)
        self._cache.add_message(msg, MagicMock(), 0)

        # Cache hit
        response = self.fetch("/_stcore/message?hash=%s" % msg_hash)
        self.assertEqual(200, response.code)
        self.assertEqual(serialize_forward_msg(msg), response.body)

        # Cache misses
        self.assertEqual(404, self.fetch("/_stcore/message").code)
        self.assertEqual(404, self.fetch("/_stcore/message?id=non_existent").code)


class StaticFileHandlerTest(tornado.testing.AsyncHTTPTestCase):
    def setUp(self) -> None:
        self._tmpdir = tempfile.TemporaryDirectory()
        self._tmpfile = tempfile.NamedTemporaryFile(dir=self._tmpdir.name, delete=False)
        self._tmp_js_file = tempfile.NamedTemporaryFile(
            dir=self._tmpdir.name, suffix="script.js", delete=False
        )
        self._tmp_html_file = tempfile.NamedTemporaryFile(
            dir=self._tmpdir.name, suffix="file.html", delete=False
        )
        self._tmp_css_file = tempfile.NamedTemporaryFile(
            dir=self._tmpdir.name, suffix="stylesheet.css", delete=False
        )
        self._filename = os.path.basename(self._tmpfile.name)
        self._js_filename = os.path.basename(self._tmp_js_file.name)
        self._html_filename = os.path.basename(self._tmp_html_file.name)
        self._css_filename = os.path.basename(self._tmp_css_file.name)

        super().setUp()

    def tearDown(self) -> None:
        super().tearDown()

        self._tmpfile.close()
        self._tmpdir.cleanup()

    def get_app(self):
        return tornado.web.Application(
            [
                (
                    r"/(.*)",
                    StaticFileHandler,
                    {
                        "path": self._tmpdir.name,
                        "default_filename": self._filename,
                        "reserved_paths": [
                            NEW_HEALTH_ENDPOINT,
                            HOST_CONFIG_ENDPOINT,
                        ],
                    },
                )
            ]
        )

    def test_parse_url_path_200(self):
        responses = [
            self.fetch("/"),
            self.fetch(f"/{self._filename}"),
            self.fetch("/page1/"),
            self.fetch(f"/page1/{self._filename}"),
            self.fetch("/page2/"),
            self.fetch(f"/page2/{self._filename}"),
        ]

        for r in responses:
            assert r.code == 200

    def test_nonexistent_urls_return_default_page(self):
        responses = [
            self.fetch("/nonexistent"),
            self.fetch("/page2/nonexistent"),
            self.fetch(f"/page3/{self._filename}"),
        ]

        for r in responses:
            assert r.code == 200

    def test_reserved_paths_serve_404(self):
        responses = [
            self.fetch("/nonexistent/_stcore/health"),
            self.fetch("/page2/_stcore/host-config"),
        ]

        for r in responses:
            assert r.code == 404

    def test_mimetype_is_overridden_by_server(self):
        """Test get_content_type function."""
        mimetypes.add_type("custom/html", ".html")
        mimetypes.add_type("custom/js", ".js")
        mimetypes.add_type("custom/css", ".css")

        r = self.fetch(f"/{self._html_filename}")
        assert r.headers["Content-Type"] == "custom/html"

        r = self.fetch(f"/{self._js_filename}")
        assert r.headers["Content-Type"] == "custom/js"

        r = self.fetch(f"/{self._css_filename}")
        assert r.headers["Content-Type"] == "custom/css"

        Server.initialize_mimetypes()

        r = self.fetch(f"/{self._html_filename}")
        assert r.headers["Content-Type"] == "text/html"

        r = self.fetch(f"/{self._js_filename}")
        assert r.headers["Content-Type"] == "application/javascript"

        r = self.fetch(f"/{self._css_filename}")
        assert r.headers["Content-Type"] == "text/css"


class RemoveSlashHandlerTest(tornado.testing.AsyncHTTPTestCase):
    def get_app(self):
        return tornado.web.Application(
            [
                (
                    r"^/(?!/)(.*)",
                    RemoveSlashHandler,
                )
            ]
        )

    def test_parse_url_path_301(self):
        paths = ["/page1/", "/page2/page3/"]
        responses = [self.fetch(path, follow_redirects=False) for path in paths]

        for idx, r in enumerate(responses):
            assert r.code == 301
            assert r.headers["Location"] == paths[idx].rstrip("/")

    def test_parse_url_path_404(self):
        paths = ["//page1/", "//page2/page3/"]
        responses = [self.fetch(path, follow_redirects=False) for path in paths]

        for r in responses:
            assert r.code == 404


class AddSlashHandlerTest(tornado.testing.AsyncHTTPTestCase):
    def get_app(self):
        return tornado.web.Application(
            [
                (
                    r"/(.*)",
                    AddSlashHandler,
                )
            ]
        )

    def test_parse_url_path_301(self):
        paths = ["/page1"]
        responses = [self.fetch(path, follow_redirects=False) for path in paths]

        for idx, r in enumerate(responses):
            assert r.code == 301
            assert r.headers["Location"] == paths[idx] + "/"


class HostConfigHandlerTest(tornado.testing.AsyncHTTPTestCase):
    def setUp(self):
        super().setUp()

    def get_app(self):
        return tornado.web.Application(
            [
                (
                    rf"/{HOST_CONFIG_ENDPOINT}",
                    HostConfigHandler,
                )
            ]
        )

    @patch_config_options({"global.developmentMode": False})
    def test_allowed_message_origins(self):
        response = self.fetch("/_stcore/host-config")
        response_body = json.loads(response.body)
        self.assertEqual(200, response.code)
        self.assertEqual(
            {
                "allowedOrigins": _DEFAULT_ALLOWED_MESSAGE_ORIGINS,
                "useExternalAuthToken": False,
                # Default host configuration settings:
                "enableCustomParentMessages": False,
                "enforceDownloadInNewTab": False,
                "metricsUrl": "",
            },
            response_body,
        )
        # Check that localhost NOT appended/allowed outside dev mode
        self.assertNotIn(
            "http://localhost",
            response_body["allowedOrigins"],
        )

    @patch_config_options({"global.developmentMode": True})
    def test_allowed_message_origins_dev_mode(self):
        response = self.fetch("/_stcore/host-config")
        self.assertEqual(200, response.code)
        # Check that localhost has been appended/allowed in dev mode
        origins_list = json.loads(response.body)["allowedOrigins"]
        self.assertIn("http://localhost", origins_list)


================================================
File: /lib/tests/streamlit/web/server/server_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Server.py unit tests"""

from __future__ import annotations

import asyncio
import contextlib
import errno
import os
import subprocess
import sys
import tempfile
import unittest
from pathlib import Path
from unittest import mock
from unittest.mock import patch

import pytest
import tornado.httpserver
import tornado.testing
import tornado.web
import tornado.websocket
from parameterized import parameterized

import streamlit.web.server.server
from streamlit import config
from streamlit.logger import get_logger
from streamlit.proto.ForwardMsg_pb2 import ForwardMsg
from streamlit.runtime import Runtime, RuntimeState
from streamlit.web.server.server import (
    MAX_PORT_SEARCH_RETRIES,
    RetriesExceeded,
    Server,
    start_listening,
)
from tests.streamlit.message_mocks import create_dataframe_msg
from tests.streamlit.web.server.server_test_case import ServerTestCase
from tests.testutil import patch_config_options

LOGGER = get_logger(__name__)


def _create_script_finished_msg(status) -> ForwardMsg:
    msg = ForwardMsg()
    msg.script_finished = status
    return msg


class ServerTest(ServerTestCase):
    def setUp(self) -> None:
        self.original_ws_compression = config.get_option(
            "server.enableWebsocketCompression"
        )
        return super().setUp()

    def tearDown(self):
        config.set_option(
            "server.enableWebsocketCompression", self.original_ws_compression
        )
        return super().tearDown()

    @tornado.testing.gen_test
    async def test_start_stop(self):
        """Test that we can start and stop the server."""
        with self._patch_app_session():
            await self.server.start()
            self.assertEqual(
                RuntimeState.NO_SESSIONS_CONNECTED, self.server._runtime._state
            )

            await self.ws_connect()
            self.assertEqual(
                RuntimeState.ONE_OR_MORE_SESSIONS_CONNECTED, self.server._runtime._state
            )

            self.server.stop()
            await asyncio.sleep(0)  # Wait a tick for the stop to be acknowledged
            self.assertEqual(RuntimeState.STOPPING, self.server._runtime._state)

            await asyncio.sleep(0.1)
            self.assertEqual(RuntimeState.STOPPED, self.server._runtime._state)

    @tornado.testing.gen_test
    async def test_websocket_connect(self):
        """Test that we can connect to the server via websocket."""
        with self._patch_app_session():
            await self.server.start()

            self.assertFalse(self.server.browser_is_connected)

            # Open a websocket connection
            ws_client = await self.ws_connect()
            self.assertTrue(self.server.browser_is_connected)

            # Get this client's SessionInfo object
            self.assertEqual(1, self.server._runtime._session_mgr.num_active_sessions())
            session_info = self.server._runtime._session_mgr.list_active_sessions()[0]

            # Close the connection
            ws_client.close()
            await asyncio.sleep(0.1)
            self.assertFalse(self.server.browser_is_connected)

            # Ensure AppSession.disconnect_file_watchers() was called, and that our
            # session exists but is no longer active.
            session_info.session.disconnect_file_watchers.assert_called_once()
            self.assertEqual(0, self.server._runtime._session_mgr.num_active_sessions())
            self.assertEqual(1, self.server._runtime._session_mgr.num_sessions())

    @tornado.testing.gen_test
    async def test_websocket_connect_to_nonexistent_session(self):
        with self._patch_app_session():
            await self.server.start()

            ws_client = await self.ws_connect(existing_session_id="nonexistent_session")

            session_info = self.server._runtime._session_mgr.list_active_sessions()[0]

            self.assertNotEqual(session_info.session.id, "nonexistent_session")

            ws_client.close()
            await asyncio.sleep(0.1)

    @tornado.testing.gen_test
    async def test_websocket_disconnect_and_reconnect(self):
        with self._patch_app_session():
            await self.server.start()

            ws_client = await self.ws_connect()
            original_session_info = (
                self.server._runtime._session_mgr.list_active_sessions()[0]
            )

            # Disconnect, reconnect with the same session_id, and confirm that the
            # session was reused.
            ws_client.close()
            await asyncio.sleep(0.1)

            ws_client = await self.ws_connect(
                existing_session_id=original_session_info.session.id
            )

            self.assertEqual(self.server._runtime._session_mgr.num_active_sessions(), 1)
            new_session_info = self.server._runtime._session_mgr.list_active_sessions()[
                0
            ]
            self.assertEqual(new_session_info.session, original_session_info.session)

            ws_client.close()
            await asyncio.sleep(0.1)

    @tornado.testing.gen_test
    async def test_multiple_connections(self):
        """Test multiple websockets can connect simultaneously."""
        with self._patch_app_session():
            await self.server.start()

            self.assertFalse(self.server.browser_is_connected)

            # Open a websocket connection
            ws_client1 = await self.ws_connect()
            self.assertTrue(self.server.browser_is_connected)

            # Open another
            ws_client2 = await self.ws_connect()
            self.assertTrue(self.server.browser_is_connected)

            # Assert that our session_infos are sane
            session_infos = self.server._runtime._session_mgr.list_active_sessions()
            self.assertEqual(2, len(session_infos))
            self.assertNotEqual(
                session_infos[0].session.id,
                session_infos[1].session.id,
            )

            # Close the first
            ws_client1.close()
            await asyncio.sleep(0.1)
            self.assertTrue(self.server.browser_is_connected)

            # Close the second
            ws_client2.close()
            await asyncio.sleep(0.1)
            self.assertFalse(self.server.browser_is_connected)

    @tornado.testing.gen_test
    async def test_websocket_compression(self):
        with self._patch_app_session():
            config._set_option("server.enableWebsocketCompression", True, "test")
            await self.server.start()

            # Connect to the server, and explicitly request compression.
            ws_client = await tornado.websocket.websocket_connect(
                self.get_ws_url("/_stcore/stream"), compression_options={}
            )

            # Ensure that the "permessage-deflate" extension is returned
            # from the server.
            extensions = ws_client.headers.get("Sec-Websocket-Extensions")
            self.assertIn("permessage-deflate", extensions)

    @tornado.testing.gen_test
    async def test_websocket_compression_disabled(self):
        with self._patch_app_session():
            config._set_option("server.enableWebsocketCompression", False, "test")
            await self.server.start()

            # Connect to the server, and explicitly request compression.
            ws_client = await tornado.websocket.websocket_connect(
                self.get_ws_url("/_stcore/stream"), compression_options={}
            )

            # Ensure that the "Sec-Websocket-Extensions" header is not
            # present in the response from the server.
            self.assertIsNone(ws_client.headers.get("Sec-Websocket-Extensions"))

    @tornado.testing.gen_test
    async def test_send_message_to_disconnected_websocket(self):
        """Sending a message to a disconnected SessionClient raises an error.
        We should gracefully handle the error by cleaning up the session.
        """
        with self._patch_app_session():
            await self.server.start()
            await self.ws_connect()

            # Get the server's socket and session for this client
            session_info = self.server._runtime._session_mgr.list_active_sessions()[0]

            with patch.object(
                session_info.session, "flush_browser_queue"
            ) as flush_browser_queue, patch.object(
                session_info.client, "write_message"
            ) as ws_write_message:
                # Patch flush_browser_queue to simulate a pending message.
                flush_browser_queue.return_value = [create_dataframe_msg([1, 2, 3])]

                # Patch the session's WebsocketHandler to raise a
                # WebSocketClosedError when we write to it.
                ws_write_message.side_effect = tornado.websocket.WebSocketClosedError()

                # Tick the server. Our session's browser_queue will be flushed,
                # and the Websocket client's write_message will be called,
                # raising our WebSocketClosedError.
                while not flush_browser_queue.called:
                    self.server._runtime._get_async_objs().need_send_data.set()
                    await asyncio.sleep(0)

                flush_browser_queue.assert_called_once()
                ws_write_message.assert_called_once()

                # Our session should have been removed from the server as
                # a result of the WebSocketClosedError.
                self.assertIsNone(
                    self.server._runtime._session_mgr.get_active_session_info(
                        session_info.session.id
                    )
                )


class PortRotateAHundredTest(unittest.TestCase):
    """Tests port rotation handles a MAX_PORT_SEARCH_RETRIES attempts then sys exits"""

    def setUp(self) -> None:
        self.original_port = config.get_option("server.port")
        return super().setUp()

    def tearDown(self) -> None:
        config.set_option("server.port", self.original_port)
        return super().tearDown()

    @staticmethod
    def get_httpserver():
        httpserver = mock.MagicMock()

        httpserver.listen = mock.Mock()
        httpserver.listen.side_effect = OSError(errno.EADDRINUSE, "test", "asd")

        return httpserver

    def test_rotates_a_hundred_ports(self):
        app = mock.MagicMock()

        RetriesExceeded = streamlit.web.server.server.RetriesExceeded
        with pytest.raises(RetriesExceeded) as pytest_wrapped_e:
            with patch(
                "streamlit.web.server.server.HTTPServer",
                return_value=self.get_httpserver(),
            ) as mock_server:
                start_listening(app)
                self.assertEqual(pytest_wrapped_e.type, SystemExit)
                self.assertEqual(pytest_wrapped_e.value.code, errno.EADDRINUSE)
                self.assertEqual(mock_server.listen.call_count, MAX_PORT_SEARCH_RETRIES)


class PortRotateOneTest(unittest.TestCase):
    """Tests port rotates one port"""

    which_port = mock.Mock()

    @staticmethod
    def get_httpserver():
        httpserver = mock.MagicMock()

        httpserver.listen = mock.Mock()
        httpserver.listen.side_effect = OSError(errno.EADDRINUSE, "test", "asd")

        return httpserver

    @mock.patch("streamlit.web.server.server.config._set_option")
    @mock.patch("streamlit.web.server.server.server_port_is_manually_set")
    def test_rotates_one_port(
        self, patched_server_port_is_manually_set, patched__set_option
    ):
        app = mock.MagicMock()

        patched_server_port_is_manually_set.return_value = False
        with pytest.raises(RetriesExceeded):
            with patch(
                "streamlit.web.server.server.HTTPServer",
                return_value=self.get_httpserver(),
            ):
                start_listening(app)

                PortRotateOneTest.which_port.assert_called_with(8502)

                patched__set_option.assert_called_with(
                    "server.port", 8501, config.ConfigOption.STREAMLIT_DEFINITION
                )


class SslServerTest(unittest.TestCase):
    """Tests SSL server"""

    @parameterized.expand(["server.sslCertFile", "server.sslKeyFile"])
    def test_requires_two_options(self, option_name):
        """
        The test checks the behavior whenever one of the two required configuration
        option is set.
        """
        with patch_config_options({option_name: "/tmp/file"}), pytest.raises(
            SystemExit
        ), self.assertLogs("streamlit.web.server.server") as logs:
            start_listening(mock.MagicMock())
        self.assertEqual(
            logs.output,
            [
                "ERROR:streamlit.web.server.server:Options 'server.sslCertFile' and "
                "'server.sslKeyFile' must be set together. Set missing options or "
                "delete existing options."
            ],
        )

    @parameterized.expand(["server.sslCertFile", "server.sslKeyFile"])
    def test_missing_file(self, option_name):
        """
        The test checks the behavior whenever one of the two requires file is missing.
        """
        with contextlib.ExitStack() as exit_stack:
            tmp_dir = exit_stack.enter_context(tempfile.TemporaryDirectory())

            cert_file = Path(tmp_dir) / "cert.cert"
            key_file = Path(tmp_dir) / "key.key"

            new_options = {
                "server.sslCertFile": cert_file,
                "server.sslKeyFile": key_file,
            }
            exit_stack.enter_context(patch_config_options(new_options))

            # Create only one file
            Path(new_options[option_name]).write_text("TEST-CONTENT")

            exit_stack.enter_context(pytest.raises(SystemExit))
            logs = exit_stack.enter_context(
                self.assertLogs("streamlit.web.server.server")
            )

            start_listening(mock.MagicMock())

        self.assertRegex(
            logs.output[0],
            r"ERROR:streamlit\.web\.server\.server:(Cert|Key) file "
            r"'.+' does not exist\.",
        )

    @parameterized.expand(["server.sslCertFile", "server.sslKeyFile"])
    @unittest.skipIf("win32" in sys.platform, "Windows does not natively have openssl")
    def test_invalid_file_content(self, option_name):
        """
        The test checks the behavior whenever one of the two requires file is corrupted.
        """
        with contextlib.ExitStack() as exit_stack:
            tmp_dir = exit_stack.enter_context(tempfile.TemporaryDirectory())
            cert_file = Path(tmp_dir) / "cert.cert"
            key_file = Path(tmp_dir) / "key.key"

            subprocess.check_call(
                [
                    "openssl",
                    "req",
                    "-x509",
                    "-newkey",
                    "rsa:4096",
                    "-keyout",
                    str(key_file),
                    "-out",
                    str(cert_file),
                    "-sha256",
                    "-days",
                    "365",
                    "-nodes",
                    "-subj",
                    "/CN=localhost",
                    # sublectAltName is required by modern browsers
                    # See: https://github.com/urllib3/urllib3/issues/497
                    "-addext",
                    "subjectAltName = DNS:localhost",
                ]
            )
            new_options = {
                "server.sslCertFile": cert_file,
                "server.sslKeyFile": key_file,
            }
            exit_stack.enter_context(patch_config_options(new_options))

            # Overwrite file with invalid content
            Path(new_options[option_name]).write_text("INVALID-CONTENT")

            exit_stack.enter_context(pytest.raises(SystemExit))
            logs = exit_stack.enter_context(
                self.assertLogs("streamlit.web.server.server")
            )

            start_listening(mock.MagicMock())
        self.assertRegex(
            logs.output[0],
            r"ERROR:streamlit\.web\.server\.server:Failed to load SSL certificate\. "
            r"Make sure cert file '.+' and key file '.+' are correct\.",
        )


class UnixSocketTest(unittest.TestCase):
    """Tests start_listening uses a unix socket when socket.address starts with
    unix://"""

    def setUp(self) -> None:
        self.original_address = config.get_option("server.address")
        return super().setUp()

    def tearDown(self) -> None:
        config.set_option("server.address", self.original_address)
        return super().tearDown()

    @staticmethod
    def get_httpserver():
        httpserver = mock.MagicMock()

        httpserver.add_socket = mock.Mock()

        return httpserver

    @unittest.skipIf("win32" in sys.platform, "Windows does not have unit sockets")
    def test_unix_socket(self):
        app = mock.MagicMock()

        config.set_option("server.address", "unix://~/fancy-test/testasd")
        some_socket = object()

        mock_server = self.get_httpserver()
        with patch(
            "streamlit.web.server.server.HTTPServer", return_value=mock_server
        ), patch.object(
            tornado.netutil, "bind_unix_socket", return_value=some_socket
        ) as bind_unix_socket, patch.dict(
            os.environ, {"HOME": "/home/superfakehomedir"}
        ):
            start_listening(app)

            bind_unix_socket.assert_called_with(
                "/home/superfakehomedir/fancy-test/testasd"
            )
            mock_server.add_socket.assert_called_with(some_socket)


class ScriptCheckEndpointExistsTest(tornado.testing.AsyncHTTPTestCase):
    async def does_script_run_without_error(self):
        return True, "test_message"

    def setUp(self):
        self._old_config = config.get_option("server.scriptHealthCheckEnabled")
        config._set_option("server.scriptHealthCheckEnabled", True, "test")
        super().setUp()

    def tearDown(self):
        config._set_option("server.scriptHealthCheckEnabled", self._old_config, "test")
        Runtime._instance = None
        super().tearDown()

    def get_app(self):
        server = Server("mock/script/path", is_hello=False)
        server._runtime.does_script_run_without_error = (
            self.does_script_run_without_error
        )
        server._runtime._eventloop = self.io_loop.asyncio_loop
        return server._create_app()

    def test_endpoint(self):
        response = self.fetch("/_stcore/script-health-check")
        self.assertEqual(200, response.code)
        self.assertEqual(b"test_message", response.body)

    def test_deprecated_endpoint(self):
        response = self.fetch("/script-health-check")
        self.assertEqual(200, response.code)
        self.assertEqual(b"test_message", response.body)
        self.assertEqual(
            response.headers["link"],
            f'<http://127.0.0.1:{self.get_http_port()}/_stcore/script-health-check>; rel="alternate"',
        )
        self.assertEqual(response.headers["deprecation"], "True")


class ScriptCheckEndpointDoesNotExistTest(tornado.testing.AsyncHTTPTestCase):
    async def does_script_run_without_error(self):
        self.fail("Should not be called")

    def setUp(self):
        self._old_config = config.get_option("server.scriptHealthCheckEnabled")
        config._set_option("server.scriptHealthCheckEnabled", False, "test")
        super().setUp()

    def tearDown(self):
        config._set_option("server.scriptHealthCheckEnabled", self._old_config, "test")
        Runtime._instance = None
        super().tearDown()

    def get_app(self):
        server = Server("mock/script/path", is_hello=False)
        server._runtime.does_script_run_without_error = (
            self.does_script_run_without_error
        )
        return server._create_app()

    def test_endpoint(self):
        response = self.fetch("/script-health-check")
        self.assertEqual(404, response.code)


================================================
File: /lib/tests/streamlit/web/server/server_test_case.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import urllib.parse
from typing import TYPE_CHECKING
from unittest import mock

import tornado.testing
import tornado.web
import tornado.websocket

from streamlit.proto.ForwardMsg_pb2 import ForwardMsg
from streamlit.runtime import Runtime
from streamlit.runtime.app_session import AppSession
from streamlit.web.server import Server

if TYPE_CHECKING:
    from tornado.websocket import WebSocketClientConnection


class ServerTestCase(tornado.testing.AsyncHTTPTestCase):
    """Base class for async streamlit.server testing.

    Subclasses should patch 'streamlit.server.server.AppSession',
    to prevent AppSessions from being created, and scripts from
    being run. (Script running involves creating new threads, which
    interfere with other tests if not properly terminated.)

    See the "ServerTest" class for example usage.
    """

    _next_session_id = 0

    def tearDown(self) -> None:
        super().tearDown()
        # Server._create_app() will create the Runtime singleton.
        # We null it out in tearDown() so that it doesn't interfere with
        # future tests.
        Runtime._instance = None

    def get_app(self) -> tornado.web.Application:
        self.server = Server(
            "/not/a/script.py",
            is_hello=False,
        )
        app = self.server._create_app()
        return app

    def get_ws_url(self, path):
        """Return a ws:// URL with the given path for our test server."""
        # get_url() gives us a result with the 'http' scheme;
        # we swap it out for 'ws'.
        url = self.get_url(path)
        parts = list(urllib.parse.urlparse(url))
        parts[0] = "ws"
        return urllib.parse.urlunparse(tuple(parts))

    async def ws_connect(self, existing_session_id=None) -> WebSocketClientConnection:
        """Open a websocket connection to the server.

        Returns
        -------
        WebSocketClientConnection
            The connected websocket client.
        """
        # See the comment in WebsocketConnection.tsx about how we repurpose the
        # Sec-WebSocket-Protocol header for more information on how this works.
        if existing_session_id is None:
            subprotocols = ["streamlit", "PLACEHOLDER_AUTH_TOKEN"]
        else:
            subprotocols = ["streamlit", "PLACEHOLDER_AUTH_TOKEN", existing_session_id]

        return await tornado.websocket.websocket_connect(
            self.get_ws_url("/_stcore/stream"),
            subprotocols=subprotocols,
        )

    async def read_forward_msg(
        self, ws_client: WebSocketClientConnection
    ) -> ForwardMsg:
        """Parse the next message from a Websocket client into a ForwardMsg."""
        data = await ws_client.read_message()
        message = ForwardMsg()
        message.ParseFromString(data)
        return message

    @staticmethod
    def _create_mock_app_session(*args, **kwargs):
        """Create a mock AppSession. Each mocked instance will have
        its own unique ID."""
        mock_id = mock.PropertyMock(
            return_value=f"mock_id:{ServerTestCase._next_session_id}"
        )
        ServerTestCase._next_session_id += 1

        mock_session = mock.MagicMock(AppSession, autospec=True, *args, **kwargs)  # noqa: B026
        type(mock_session).id = mock_id
        return mock_session

    def _patch_app_session(self):
        """Mock the Server's AppSession import. We don't want
        actual sessions to be instantiated, or scripts to be run.
        """

        return mock.patch(
            "streamlit.runtime.websocket_session_manager.AppSession",
            # new_callable must return a function, not an object, or else
            # there will only be a single AppSession mock. Hence the lambda.
            new_callable=lambda: self._create_mock_app_session,
        )


================================================
File: /lib/tests/streamlit/web/server/server_util_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Unit tests for server_util.py."""

from __future__ import annotations

import unittest
from unittest.mock import patch

from parameterized import parameterized

import streamlit.web.server.server_util as server_util
from streamlit import config
from tests import testutil


class ServerUtilTest(unittest.TestCase):
    def test_is_url_from_allowed_origins_allowed_domains(self):
        self.assertTrue(server_util.is_url_from_allowed_origins("localhost"))
        self.assertTrue(server_util.is_url_from_allowed_origins("127.0.0.1"))

    def test_is_url_from_allowed_origins_CORS_off(self):
        with patch(
            "streamlit.web.server.server_util.config.get_option", side_effect=[False]
        ):
            self.assertTrue(server_util.is_url_from_allowed_origins("does not matter"))

    def test_is_url_from_allowed_origins_browser_serverAddress(self):
        with patch(
            "streamlit.web.server.server_util.config.is_manually_set",
            side_effect=[True],
        ), patch(
            "streamlit.web.server.server_util.config.get_option",
            side_effect=[True, "browser.server.address"],
        ):
            self.assertTrue(
                server_util.is_url_from_allowed_origins("browser.server.address")
            )

    @parameterized.expand(
        [
            (None, 8501, "http://the_ip_address:8501"),
            (None, 9988, "http://the_ip_address:9988"),
            ("foo", 8501, "http://the_ip_address:8501/foo"),
            ("foo/", 8501, "http://the_ip_address:8501/foo"),
            ("/foo/bar/", 8501, "http://the_ip_address:8501/foo/bar"),
            ("/foo/bar/", 9988, "http://the_ip_address:9988/foo/bar"),
        ]
    )
    def test_get_url(self, base_url: str | None, port: int, expected_url: str):
        options = {"server.headless": False, "global.developmentMode": False}

        if base_url:
            options["server.baseUrlPath"] = base_url

        options["server.port"] = port

        mock_get_option = testutil.build_mock_config_get_option(options)

        with patch.object(config, "get_option", new=mock_get_option):
            actual_url = server_util.get_url("the_ip_address")

        self.assertEqual(expected_url, actual_url)

    def test_make_url_path_regex(self):
        assert (
            server_util.make_url_path_regex("foo") == r"^/foo/?$"
        )  # defaults to optional
        assert (
            server_util.make_url_path_regex("foo", trailing_slash="optional")
            == r"^/foo/?$"
        )
        assert (
            server_util.make_url_path_regex("foo", trailing_slash="required")
            == r"^/foo/$"
        )
        assert (
            server_util.make_url_path_regex("foo", trailing_slash="prohibited")
            == r"^/foo$"
        )


================================================
File: /lib/tests/streamlit/web/server/stats_handler_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from unittest.mock import MagicMock

import tornado.testing
import tornado.web
from google.protobuf.json_format import MessageToDict
from tornado.httputil import HTTPHeaders

from streamlit.proto.openmetrics_data_model_pb2 import MetricSet as MetricSetProto
from streamlit.runtime.stats import CacheStat
from streamlit.web.server.server import METRIC_ENDPOINT
from streamlit.web.server.stats_request_handler import StatsRequestHandler


class StatsHandlerTest(tornado.testing.AsyncHTTPTestCase):
    def get_app(self):
        self.mock_stats = []
        mock_stats_manager = MagicMock()
        mock_stats_manager.get_stats = MagicMock(side_effect=lambda: self.mock_stats)
        return tornado.web.Application(
            [
                (
                    rf"/{METRIC_ENDPOINT}",
                    StatsRequestHandler,
                    dict(stats_manager=mock_stats_manager),
                )
            ]
        )

    def test_no_stats(self):
        """If we have no stats, we expect to see just the header and footer."""
        response = self.fetch("/_stcore/metrics")
        self.assertEqual(200, response.code)

        expected_body = (
            b"# TYPE cache_memory_bytes gauge\n"
            b"# UNIT cache_memory_bytes bytes\n"
            b"# HELP Total memory consumed by a cache.\n"
            b"# EOF\n"
        )

        self.assertEqual(expected_body, response.body)

    def test_deprecated_endpoint(self):
        response = self.fetch("/st-metrics")

        self.assertEqual(200, response.code)
        self.assertEqual(
            response.headers["link"],
            f'<http://127.0.0.1:{self.get_http_port()}/_stcore/metrics>; rel="alternate"',
        )
        self.assertEqual(response.headers["deprecation"], "True")

    def test_has_stats(self):
        self.mock_stats = [
            CacheStat(
                category_name="st.singleton",
                cache_name="foo",
                byte_length=128,
            ),
            CacheStat(
                category_name="st.memo",
                cache_name="bar",
                byte_length=256,
            ),
        ]

        response = self.fetch("/_stcore/metrics")
        self.assertEqual(200, response.code)
        self.assertEqual(
            "application/openmetrics-text", response.headers.get("Content-Type")
        )

        expected_body = (
            b"# TYPE cache_memory_bytes gauge\n"
            b"# UNIT cache_memory_bytes bytes\n"
            b"# HELP Total memory consumed by a cache.\n"
            b'cache_memory_bytes{cache_type="st.singleton",cache="foo"} 128\n'
            b'cache_memory_bytes{cache_type="st.memo",cache="bar"} 256\n'
            b"# EOF\n"
        )

        self.assertEqual(expected_body, response.body)

    def test_new_metrics_endpoint_should_not_display_deprecation_warning(self):
        response = self.fetch("/_stcore/metrics")
        self.assertNotIn("link", response.headers)
        self.assertNotIn("deprecation", response.headers)

    def test_protobuf_stats(self):
        """Stats requests are returned in OpenMetrics protobuf format
        if the request's Content-Type header is protobuf.
        """
        self.mock_stats = [
            CacheStat(
                category_name="st.singleton",
                cache_name="foo",
                byte_length=128,
            ),
            CacheStat(
                category_name="st.memo",
                cache_name="bar",
                byte_length=256,
            ),
        ]

        # Requests can have multiple Accept headers. Only one of them needs
        # to specify protobuf in order to get back protobuf.
        headers = HTTPHeaders()
        headers.add("Accept", "application/openmetrics-text")
        headers.add("Accept", "application/x-protobuf")
        headers.add("Accept", "text/html")

        response = self.fetch("/_stcore/metrics", headers=headers)
        self.assertEqual(200, response.code)
        self.assertEqual("application/x-protobuf", response.headers.get("Content-Type"))

        metric_set = MetricSetProto()
        metric_set.ParseFromString(response.body)

        expected = {
            "metricFamilies": [
                {
                    "name": "cache_memory_bytes",
                    "type": "GAUGE",
                    "unit": "bytes",
                    "help": "Total memory consumed by a cache.",
                    "metrics": [
                        {
                            "labels": [
                                {"name": "cache_type", "value": "st.singleton"},
                                {"name": "cache", "value": "foo"},
                            ],
                            "metricPoints": [{"gaugeValue": {"intValue": "128"}}],
                        },
                        {
                            "labels": [
                                {"name": "cache_type", "value": "st.memo"},
                                {"name": "cache", "value": "bar"},
                            ],
                            "metricPoints": [{"gaugeValue": {"intValue": "256"}}],
                        },
                    ],
                }
            ]
        }

        self.assertEqual(expected, MessageToDict(metric_set))


================================================
File: /lib/tests/streamlit/web/server/upload_file_request_handler_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""UploadFileHandler.py unit tests"""

from __future__ import annotations

from typing import NamedTuple

import requests
import tornado.testing
import tornado.web
import tornado.websocket

from streamlit.logger import get_logger
from streamlit.runtime.memory_uploaded_file_manager import MemoryUploadedFileManager
from streamlit.web.server.server import UPLOAD_FILE_ENDPOINT
from streamlit.web.server.upload_file_request_handler import UploadFileRequestHandler

LOGGER = get_logger(__name__)


class MockFile(NamedTuple):
    name: str
    data: bytes


def _get_filename(file):
    """Sort key for lists of UploadedFiles"""
    return file.name


class UploadFileRequestHandlerTest(tornado.testing.AsyncHTTPTestCase):
    """Tests the /upload_file endpoint."""

    def get_app(self):
        self.file_mgr = MemoryUploadedFileManager(upload_endpoint=UPLOAD_FILE_ENDPOINT)
        return tornado.web.Application(
            [
                (
                    f"{UPLOAD_FILE_ENDPOINT}/(?P<session_id>[^/]+)/(?P<file_id>[^/]+)",
                    UploadFileRequestHandler,
                    dict(
                        file_mgr=self.file_mgr,
                        is_active_session=lambda session_id: True,
                    ),
                ),
            ]
        )

    def _upload_files(self, files_body, session_id, file_id):
        # We use requests.Request to construct our multipart/form-data request
        # here, because they are absurdly fiddly to compose, and Tornado
        # doesn't include a utility for building them. We then use self.fetch()
        # to actually send the request to the test server.
        req = requests.Request(
            method="PUT",
            url=self.get_url(f"{UPLOAD_FILE_ENDPOINT}/{session_id}/{file_id}"),
            files=files_body,
        ).prepare()

        return self.fetch(
            req.url,
            method=req.method,
            headers=req.headers,
            body=req.body,
        )

    def test_upload_one_file(self):
        """Uploading a file should populate our file_mgr."""
        file = MockFile("filename", b"123")
        params = {file.name: file.data}
        response = self._upload_files(
            params, session_id="test_session_id", file_id=file.name
        )

        self.assertEqual(204, response.code, response.reason)

        self.assertEqual(
            [(file.name, file.name, file.data)],
            [
                (rec.file_id, rec.name, rec.data)
                for rec in self.file_mgr.get_files("test_session_id", [file.name])
            ],
        )

    def test_upload_multiple_files_error(self):
        """Uploading multiple files will error"""
        file_1 = MockFile("file1", b"123")
        file_2 = MockFile("file2", b"456")

        files_body = {
            file_1.name: file_1.data,
            file_2.name: file_2.data,
        }
        response = self._upload_files(
            files_body, session_id="some-session-id", file_id="some-file-id"
        )
        self.assertEqual(400, response.code)
        self.assertIn("Expected 1 file, but got 2", response.reason)

    def test_upload_missing_session_id_error(self):
        """Missing session_id in the path should fail with 404 status."""
        file_body = {
            "image.png": ("image.png", b"1234"),
        }

        response = self._upload_files(file_body, session_id="", file_id="file_id")
        self.assertEqual(404, response.code)
        self.assertIn("Not Found", response.reason)

    def test_upload_missing_file_id_error(self):
        """Missing file_id in the path should fail with 404 status."""
        file_body = {
            "image.png": ("image.png", b"1234"),
        }

        response = self._upload_files(file_body, session_id="session_id", file_id="")
        self.assertEqual(404, response.code)
        self.assertIn("Not Found", response.reason)

    def test_upload_missing_file_error(self):
        """Missing file should fail with 400 status."""
        file_body = {
            "file1": (None, b"123"),
        }
        response = self._upload_files(
            file_body, session_id="sessionId", file_id="fileId"
        )

        self.assertEqual(400, response.code)
        self.assertIn("Expected 1 file, but got 0", response.reason)


class UploadFileRequestHandlerInvalidSessionTest(tornado.testing.AsyncHTTPTestCase):
    """Tests the /upload_file endpoint."""

    def get_app(self):
        self.file_mgr = MemoryUploadedFileManager(upload_endpoint=UPLOAD_FILE_ENDPOINT)
        return tornado.web.Application(
            [
                (
                    f"{UPLOAD_FILE_ENDPOINT}/(?P<session_id>[^/]+)/(?P<file_id>[^/]+)",
                    UploadFileRequestHandler,
                    dict(
                        file_mgr=self.file_mgr,
                        is_active_session=lambda session_id: False,
                    ),
                ),
            ]
        )

    def _upload_files(self, files_body, session_id, file_id):
        # We use requests.Request to construct our multipart/form-data request
        # here, because they are absurdly fiddly to compose, and Tornado
        # doesn't include a utility for building them. We then use self.fetch()
        # to actually send the request to the test server.
        req = requests.Request(
            method="PUT",
            url=self.get_url(f"{UPLOAD_FILE_ENDPOINT}/{session_id}/{file_id}"),
            files=files_body,
        ).prepare()

        return self.fetch(
            req.url,
            method=req.method,
            headers=req.headers,
            body=req.body,
        )

    def test_upload_one_file(self):
        """Upload should fail if the sessionId doesn't exist."""
        file = MockFile("filename", b"123")
        params = {file.name: file.data}
        response = self._upload_files(params, session_id="sessionId", file_id="fileId")
        self.assertEqual(400, response.code)
        self.assertIn("Invalid session_id", response.reason)
        self.assertEqual(self.file_mgr.get_files("sessionId", ["fileId"]), [])


================================================
File: /lib/tests/streamlit/web/server/websocket_headers_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from unittest.mock import MagicMock, Mock, patch

import tornado.testing
import tornado.websocket

from streamlit.runtime.scriptrunner import ScriptRunContext
from streamlit.web.server import websocket_headers
from streamlit.web.server.browser_websocket_handler import BrowserWebSocketHandler
from tests.streamlit.web.server.server_test_case import ServerTestCase


class WebSocketHeadersTest(ServerTestCase):
    @tornado.testing.gen_test
    async def test_get_websocket_headers(self):
        """`get_websocket_headers()` returns the current session's
        `BrowserWebSocketHandler.request.headers`.
        """
        with self._patch_app_session():
            await self.server.start()
            await self.ws_connect()

            session_mgr = self.server._runtime._session_mgr

            # Get our client's session_id and some other stuff
            self.assertEqual(1, session_mgr.num_active_sessions())
            session_info = session_mgr.list_active_sessions()[0]
            session_id = session_info.session.id
            self.assertIsInstance(session_info.client, BrowserWebSocketHandler)

            # Mock get_script_run_ctx() to return our session_id
            mock_script_run_ctx = MagicMock(spec=ScriptRunContext)
            mock_script_run_ctx.session_id = session_id
            with patch(
                "streamlit.web.server.websocket_headers.get_script_run_ctx",
                return_value=mock_script_run_ctx,
            ):
                # Assert that our headers are equal to our BrowserWebSocketHandler's
                # request headers.
                headers = websocket_headers._get_websocket_headers()
                self.assertEqual(headers, dict(session_info.client.request.headers))

                # Assert the presence of some (arbitrary) headers that should always
                # be in a WebSocket request.
                self.assertIn("Host", headers)
                self.assertIn("Upgrade", headers)
                self.assertIn("Connection", headers)

    @patch("streamlit.web.server.websocket_headers.show_deprecation_warning")
    def test_deprecation_warnings(self, show_warning_mock: Mock):
        """We show deprecation warnings when using `_get_websocket_headers()`."""

        websocket_headers._get_websocket_headers()

        show_warning_mock.assert_called_once_with(
            websocket_headers._GET_WEBSOCKET_HEADERS_DEPRECATE_MSG
        )


================================================
File: /proto/streamlit/proto/Alert.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "AlertProto";

// NOTE: This proto type is used by some external services so needs to remain
// relatively stable. While it isn't entirely set in stone, changing it
// may require a good amount of effort so should be avoided if possible.
message Alert {
  // Content to display.
  string body = 1;
  Format format = 2;
  string icon = 3;

  // Type of Alert
  enum Format {
    // Plain, fixed width text.
    UNUSED = 0;

    // Shows an error message.
    ERROR = 1;

    // Shows a warning message.
    WARNING = 2;

    // Shows an info log.
    INFO = 3;

    // Shows a success message.
    SUCCESS = 4;
  }
}


================================================
File: /proto/streamlit/proto/AppPage.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "AppPageProto";

// A page in the app. Includes both the name of the page as well as the full
// path to the corresponding script file.
//
// NOTE: This proto type is used by some external services so needs to remain
// relatively stable. While it isn't entirely set in stone, changing it
// may require a good amount of effort so should be avoided if possible.
message AppPage {
  string page_script_hash = 1;
  string page_name = 2;
  string icon = 3;

  // A feature for MPA v2 to inform the frontend what's the default page
  bool is_default = 4;
  string section_header = 5;
  string url_pathname = 6;
}


================================================
File: /proto/streamlit/proto/Arrow.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "ArrowProto";

message Arrow {
  // The serialized arrow dataframe
  bytes data = 1;
  // Pandas styler information
  Styler styler = 2;
  // Width in pixels
  uint32 width = 3;
  // Height in pixels
  uint32 height = 4;
  // If True, will overwrite the dataframe width to fit to container.
  bool use_container_width = 5;
  // The id of the widget, this is required if the dataframe is editable
  string id = 6;
  // Column configuration as JSON
  string columns = 7;
  // Activate table editing
  EditingMode editing_mode = 8;
  // Deactivates editing
  bool disabled = 9;
  // The form ID of the widget, this is required if the dataframe is editable
  string form_id = 10;
  // Defines the order in which columns are displayed
  repeated string column_order = 11;
  // Activated dataframe selections events
  repeated SelectionMode selection_mode = 12;

  // Available editing modes:
  enum EditingMode {
    READ_ONLY = 0; // Read-only table.
    FIXED = 1; // Activates editing but only allow editing of existing cells.
    DYNAMIC = 2; // Activates editing and allow adding & deleting rows.
  }

  // Available editing modes:
  enum SelectionMode {
    SINGLE_ROW = 0; // Only one row can be selected at a time.
    MULTI_ROW = 1; // Multiple rows can be selected at a time.
    SINGLE_COLUMN = 2; // Only one column can be selected at a time.
    MULTI_COLUMN = 3; // Multiple columns can be selected at a time.
  }
}

message Styler {
  // The Styler's source UUID (if the user provided one), or the path-based
  // hash that we generate (if no source UUID was provided).
  string uuid = 1;

  // The table's caption.
  string caption = 2;

  // `styles` contains the CSS for the entire source table.
  string styles = 3;

  // display_values is another ArrowTable: a copy of the source table, but
  // with all the display values formatted to the user-specified rules.
  bytes display_values = 4;
}



================================================
File: /proto/streamlit/proto/ArrowNamedDataSet.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "ArrowNamedDataSetProto";

import "streamlit/proto/Arrow.proto";

// A dataset that can be referenced by name.
message ArrowNamedDataSet {
  // The dataset name.
  string name = 1;

  // True if the name field (above) was manually set. This is used to get
  // around proto3 not having a way to check whether something was set.
  bool has_name = 3;

  // The data itself.
  Arrow data = 2;
}


================================================
File: /proto/streamlit/proto/ArrowVegaLiteChart.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "ArrowVegaLiteChartProto";

import "streamlit/proto/Arrow.proto";
import "streamlit/proto/ArrowNamedDataSet.proto";

message ArrowVegaLiteChart {
  // The a JSON-formatted string with the Vega-Lite spec.
  string spec = 1;

  // The dataframe that will be used as the chart's main data source, if
  // specified using Vega-Lite's inline API.
  Arrow data = 2;

  // Dataframes associated with this chart using Vega-Lite's datasets API, if
  // any. The data is either in `data` field or in the `datasets` field.
  repeated ArrowNamedDataSet datasets = 4;

  // If True, will overwrite the chart width spec to fit to container.
  bool use_container_width = 5;

  // override the properties with a theme. Currently, only "streamlit" or None are accepted.
  string theme = 6;

  // ID, required for selection events.
  string id = 7;

  // Named selection parameters that are activated to trigger reruns.
  repeated string selection_mode = 8;

  // The form ID of the widget, this is required if selections are activated on the chart.
  string form_id = 9;

  reserved 3;
}


================================================
File: /proto/streamlit/proto/Audio.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "AudioProto";

message Audio {
  string url = 5;

  // The currentTime attribute of the HTML <audio> tag's <source> subtag.
  int32 start_time = 3;

  // The time at which the audio should stop playing. If not specified, plays to the end.
  int32 end_time = 6;

  // Indicates whether the audio should start over from the beginning once it ends.
  bool loop = 7;

  bool autoplay = 8;

  string id = 9;

  reserved 1, 2, 4;
  reserved "data", "format";
}


================================================
File: /proto/streamlit/proto/AudioInput.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "AudioInputProto";

import "streamlit/proto/LabelVisibilityMessage.proto";


message AudioInput {
  string id = 1;
  string label = 2;
  string help = 3;
  string form_id = 4;
  bool disabled = 5;
  LabelVisibilityMessage label_visibility = 6;
}



================================================
File: /proto/streamlit/proto/AuthRedirect.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "AuthRedirectProto";

message AuthRedirect {
  string url = 1; // URL TO REDIRECT TO
}


================================================
File: /proto/streamlit/proto/AutoRerun.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "AutoRerunProto";

message AutoRerun {
  // The interval of reruns in seconds
  float interval = 1;

  // The fragment ID to rerun
  string fragment_id = 2;
}


================================================
File: /proto/streamlit/proto/BackMsg.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "BackMsgProto";

import "streamlit/proto/ClientState.proto";
import "streamlit/proto/Common.proto";

// A message from the browser to the server.
message BackMsg {
  oneof type {
    // DEPRECATED. Set to true to ask the server to display the inline help.
    // bool help = 1;

    // DEPRECATED. Asks the server to run the script.
    //bool rerun_script = 3;

    // DEPRECATED. Asks the server to run the script with this object
    // ReRun rerun = 4;

    // Requests that the app's @st_cache be cleared
    bool clear_cache = 5;

    // Requests that the runOnSave behavior for this app be set
    // to the given value
    bool set_run_on_save = 6;

    // Requests that the script's execution be stopped
    bool stop_script = 7;

    // DEPRECATED.
    // string widget_json = 8;

    // DEPRECATED. This is now inside ClientState.
    // WidgetStates update_widgets = 9;

    // DEPRECATED. Set to true to ask the server to close the connection
    // bool close_connection = 10;

    ClientState rerun_script = 11;

    bool load_git_info = 12;

    // Test and dev-mode only field used to ask the server to disconnect the
    // client's websocket connection. This message is IGNORED unless the
    // runtime is configured with global.developmentMode = True.
    bool debug_disconnect_websocket = 14;

    // Test and dev-mode only field used to ask the server to shut down the
    // runtime. This message is IGNORED unless the runtime is configured with
    // global.developmentMode = True.
    bool debug_shutdown_runtime = 15;

    // Requests that the server generate URLs for getting/uploading/deleting
    // files for the `st.file_uploader` widget
    FileURLsRequest file_urls_request = 16;

    // Sends an app heartbeat message through the websocket
    bool app_heartbeat = 17;
  }

  // An ID used to associate this BackMsg with the corresponding ForwardMsgs
  // that are sent to the client due to it. As its name suggests, this field
  // should only be used for testing.
  string debug_last_backmsg_id = 13;

  reserved 1, 2, 3, 4, 8, 9, 10;

  // Next: 18
}


================================================
File: /proto/streamlit/proto/Balloons.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "BalloonsProto";

// A python empty.
message Balloons {
  bool show = 3;  // Dummy boolean because protos need to have something.

  reserved 1, 2;
}


================================================
File: /proto/streamlit/proto/Block.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "BlockProto";

message Block {
  oneof type {
    Vertical vertical = 1;
    Horizontal horizontal = 2;
    Column column = 3;
    Expandable expandable = 4;
    Form form = 5;
    TabContainer tab_container = 6;
    Tab tab = 7;
    ChatMessage chat_message = 9;
    Popover popover = 10;
    Dialog dialog = 11;
  }

  bool allow_empty = 8;
  optional string id = 12;

  message Vertical {
    bool border = 1;
    // Height of the container, activates scrolling
    uint32 height = 2;
  }

  message Horizontal {
    string gap = 1;
  }

  message Column {
    double weight = 1;
    string gap = 2;

    enum VerticalAlignment {
      TOP = 0;
      CENTER = 1;
      BOTTOM = 2;
    }
    VerticalAlignment vertical_alignment = 3;
    bool show_border = 4;
  }

  message Expandable {
    string label = 1;
    optional bool expanded = 2;
    string icon = 3;
  }

  message Dialog {
    enum DialogWidth {
      SMALL = 0;
      LARGE = 1;
    }

    string title = 1;
    bool dismissible = 2;
    DialogWidth width = 3;
    optional bool is_open = 4;
  }

  message Form {
    string form_id = 1;
    bool clear_on_submit = 2;
    bool border = 3;
    bool enter_to_submit = 4;
  }

  message TabContainer {
  }

  message Tab {
    string label = 1;
  }

  message Popover {
    string label = 1;
    bool use_container_width = 2;
    string help = 3;
    bool disabled = 4;
    string icon = 5;
  }


  message ChatMessage {
    enum AvatarType {
      IMAGE = 0;
      EMOJI = 1;
      ICON = 2;
    }

    string name = 1;
    string avatar = 2;
    AvatarType avatar_type = 3;
  }

  // Next ID: 13
}


================================================
File: /proto/streamlit/proto/BokehChart.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "BokehChartProto";

message BokehChart {
  // A JSON-formatted string from the Bokeh chart figure.
  string figure = 1;

  // If True, will overwrite the chart width spec to fit to container.
  bool use_container_width = 2;

  // A unique ID of this element.
  string element_id = 3;
}


================================================
File: /proto/streamlit/proto/Button.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "ButtonProto";

message Button {
  string id = 1;
  string label = 2;
  bool default = 3;
  string help = 4;
  string form_id = 5;

  // If true, this is a form submission button. The frontend will defer
  // sending updates for all widgets inside the button's form until
  // the button is pressed.
  bool is_form_submitter = 6;
  string type = 7;
  bool disabled = 8;
  bool use_container_width = 9;
  string icon = 10;
}


================================================
File: /proto/streamlit/proto/ButtonGroup.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "ButtonGroupProto";

import "streamlit/proto/LabelVisibilityMessage.proto";

message ButtonGroup {
  enum ClickMode {
      SINGLE_SELECT = 0;
      MULTI_SELECT = 1;
  }

  message Option {
    string content = 1;
    // when set, this is the content that will be displayed when the option is selected
    optional string selected_content = 2;
    // when set, this is the icon that will be displayed next to the option
    optional string content_icon = 3;
    // when set, this is the icon that will be displayed next to the option when then option is selected
    optional string selected_content_icon = 4;
  }

  string id = 1;
  repeated Option options = 2;
  // default is an array of indexes that are selected by default
  repeated uint32 default = 3;
  bool disabled = 4;
  ClickMode click_mode = 5;
  string form_id = 6;

  // value passed by the backend
  repeated uint32 value = 7;
  bool set_value = 8;

  enum SelectionVisualization {
    ONLY_SELECTED = 0;
    ALL_UP_TO_SELECTED = 1;
  }
  SelectionVisualization selection_visualization = 9;

  enum Style {
    SEGMENTED_CONTROL = 0;
    PILLS = 1;
    BORDERLESS = 2;
  }
  Style style = 10;

  string label = 11;
  LabelVisibilityMessage label_visibility = 12;
  optional string help = 13;

  // next id: 14
}


================================================
File: /proto/streamlit/proto/CameraInput.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "CameraInputProto";

import "streamlit/proto/LabelVisibilityMessage.proto";

message CameraInput {
  string id = 1;
  string label = 2;
  string help = 3;
  string form_id = 4;
  bool disabled = 5;
  LabelVisibilityMessage label_visibility = 6;
}



================================================
File: /proto/streamlit/proto/ChatInput.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "ChatInputProto";

message ChatInput {
  string id = 1;
  string placeholder = 2;
  uint32 max_chars = 3;
  bool disabled = 4;
  string value = 5;
  bool set_value = 6;
  string default = 7;

  // DEPRECATED: position property is deprecated and unused.
  enum Position {
    BOTTOM = 0;
  }
  Position position = 8;
}


================================================
File: /proto/streamlit/proto/Checkbox.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "CheckboxProto";

import "streamlit/proto/LabelVisibilityMessage.proto";

message Checkbox {
  enum StyleType {
    DEFAULT = 0;
    TOGGLE = 1;
  }

  string id = 1;
  string label = 2;
  bool default = 3;
  string help = 4;
  string form_id = 5;
  bool value = 6;
  bool set_value = 7;
  bool disabled = 8;
  LabelVisibilityMessage label_visibility = 9;
  StyleType type = 10;
}


================================================
File: /proto/streamlit/proto/ClientState.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "ClientStateProto";

import "streamlit/proto/WidgetStates.proto";


message ClientState {
  string query_string = 1;
  WidgetStates widget_states = 2;
  string page_script_hash = 3;
  string page_name = 4;
  string fragment_id = 5;
  bool is_auto_rerun = 6;
}


================================================
File: /proto/streamlit/proto/Code.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "CodeProto";

// st.code
message Code {
  // Content to display.
  string code_text = 1;

  string language = 2;

  bool show_line_numbers = 3;
  bool wrap_lines = 4;

  uint32 height = 5;
}


================================================
File: /proto/streamlit/proto/ColorPicker.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "ColorPickerProto";

import "streamlit/proto/LabelVisibilityMessage.proto";

message ColorPicker {
  string id = 1;
  string label = 2;
  string default = 3;
  string help = 4;
  string form_id = 5;
  string value = 6;
  bool set_value = 7;
  bool disabled = 8;
  LabelVisibilityMessage label_visibility = 9;
}


================================================
File: /proto/streamlit/proto/Common.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "CommonProto";

// Message types that are common to multiple protobufs.

message StringArray {
  repeated string data = 1;
}

message DoubleArray {
  repeated double data = 1;
}

message Int32Array {
  repeated int32 data = 1;
}

message Int64Array {
  repeated int64 data = 1;
}

message SInt64Array {
  repeated sint64 data = 1;
}

message UInt32Array {
  repeated uint32 data = 1;
}

message StringTriggerValue {
  optional string data = 1;
}

// NOTE: The FileURLsRequest, FileURLs, and FileURLsResponse message types
// must remain stable as some external services rely on them to support
// `st.file_uploader`. These types aren't completely set in stone, but changing
// them requires a good amount of effort so should be avoided if possible.
message FileURLsRequest {
  string request_id = 1;
  repeated string file_names = 2;
  string session_id = 3;
}

message FileURLs {
  string file_id = 1;
  string upload_url = 2;
  string delete_url = 3;
}

message FileURLsResponse {
  string response_id = 1;
  repeated FileURLs file_urls = 2;
  string error_msg = 3;
}

// Information on a file uploaded via the file_uploader widget.
message UploadedFileInfo {
  // DEPRECATED.
  sint64 id = 1;

  string name = 2;

  // The size of this file in bytes.
  uint64 size = 3;

  // ID that can be used to retrieve a file.
  string file_id = 4;

  // Metadata containing information about file_urls.
  FileURLs file_urls = 5;
}

message FileUploaderState {
  // DEPRECATED
  sint64 max_file_id = 1;

  repeated UploadedFileInfo uploaded_file_info = 2;
}


================================================
File: /proto/streamlit/proto/Components.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "ComponentsProto";

message ComponentInstance {
  // The instance's "widget ID", used to uniquely identify it.
  string id = 1;

  // Argument dictionary, for JSON-serializable args.
  string json_args = 2;

  // Additional, non-JSON args. These require special processing
  // on the other end.
  repeated SpecialArg special_args = 3;

  // The component type's unique name.
  string component_name = 4;

  // Optional URL to load the component from. By default this is not set,
  // but while testing, a user can e.g. point this to a local node server
  // that they're developing their component in.
  string url = 5;

  string form_id = 6;
}

message SpecialArg {
  string key = 1;

  oneof value {
    ArrowDataframe arrow_dataframe = 2;
    bytes bytes = 3;
  }
}

// Components uses Apache Arrow for dataframe serialization.
// This is distinct from `Arrow.proto`: Components was created before
// Streamlit supported Arrow for internal dataframe serialization, and the
// two implementations currently use different logic + data structures.
message ArrowDataframe {
  ArrowTable data = 1;
  uint32 height = 2;
  uint32 width = 3;
}

message ArrowTable {
  bytes data = 1;
  bytes index = 2;
  bytes columns = 3;
  ArrowTableStyler styler = 5;
}

message ArrowTableStyler {
  string uuid = 1;
  string caption = 2;
  string styles = 3;
  bytes display_values = 4;
}


================================================
File: /proto/streamlit/proto/DataFrame.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "DataFrameProto";

import "streamlit/proto/Common.proto";

// DEPRECATED: This proto message is deprecated and unsused. Use Arrow.proto instead.
// Represents a pandas DataFrame.
message DataFrame {
  // The data in the array.
  Table data = 1;

  // List of row names. (Multiple implies a multi-index.)
  Index index = 2;

  // List of column names. (Multiple implies a multi-index.)
  Index columns = 3;

  // Cell style and formatting data. Optional.
  TableStyle style = 4;
}

// An index in the dataFrame
message Index {
  oneof type {
    PlainIndex plain_index = 1;
    RangeIndex range_index = 2;
    // CategoricalIndex categorical_index = 3;
    MultiIndex multi_index = 4;
    // IntervalIndex interval_index = 5;
    DatetimeIndex datetime_index = 6;
    TimedeltaIndex timedelta_index = 7;
    // PeriodIndex period_index = 8;
    Int64Index int_64_index = 9;
    // UInt64Index uint_64_index = 10;
    Float64Index float_64_index = 11;
  }
}

// Basic, 1D index.
message PlainIndex {
  AnyArray data = 1;

  //// Not yet implemented:
  // DType dtype = 2;
  // bool copy = 3;
  // string name = 4;
  // bool tupleize_cols = 5;
}

// Range index. See:
// https://pandas.pydata.org/pandas-docs/stable/generated/pandas.RangeIndex.html
message RangeIndex {
  int64 start = 1;
  int64 stop = 2;

  //// Not yet implemented:
  // string name = 4;
  // bool copy = 5;
}

// A multi-level, or hierarchical, Index. See:
// https://pandas.pydata.org/pandas-docs/stable/generated/pandas.MultiIndex.html
message MultiIndex {
  repeated Index levels = 1;
  repeated Int32Array labels = 2;

  //// Not yet implemented:
  // int sort_order = 3;
  // StringArray names = 4;
  // bool copy = 5;
  // bool verify_integrity = 6;
}

// A date represented internally as nano second epoch int64. See:
// https://pandas.pydata.org/pandas-docs/stable/generated/pandas.DatetimeIndex.html
message DatetimeIndex {
  StringArray data = 1;
}

// A time interval represented internally as nano second epoch int64. See:
// https://pandas.pydata.org/pandas-docs/stable/generated/pandas.TimedeltaIndex.html
message TimedeltaIndex {
  Int64Array data = 1;
}

// See:
// https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Int64Index.html
message Int64Index {
  Int64Array data = 1;
}

// See:
// https://pandas.pydata.org/pandas-docs/stable/generated/pandas.Int64Index.html
message Float64Index {
  DoubleArray data = 1;
}

message CSSStyle {
  string property = 1;
  string value = 2;
}

message CellStyle {
  repeated CSSStyle css = 1;
  string display_value = 2;       // e.g. '21.96%'

  // The default value for a string field in proto3 is '', so we need
  // this extra bool to indicate the presence of a user-specified
  // display_value, which itself could be ''.
  bool has_display_value = 3;
}

message CellStyleArray {
  repeated CellStyle styles = 1;
}

message AnyArray {
  oneof type {
    StringArray strings = 1;
    DoubleArray doubles = 2;
    Int64Array int64s = 3;
    StringArray datetimes = 4;
    Int64Array timedeltas = 5;
  }
}

message Table {
  repeated AnyArray cols = 1;
}

message TableStyle {
  repeated CellStyleArray cols = 1;
}


================================================
File: /proto/streamlit/proto/DateInput.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "DateInputProto";

import "streamlit/proto/LabelVisibilityMessage.proto";

message DateInput {
  string id = 1;
  string label = 2;
  repeated string default = 3;
  string min = 4;
  string max = 5;
  bool is_range = 6;
  string help = 7;
  string form_id = 8;
  repeated string value = 9;
  bool set_value = 10;
  bool disabled = 11;
  LabelVisibilityMessage label_visibility = 12;
  string format = 13;
}


================================================
File: /proto/streamlit/proto/DeckGlJsonChart.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "DeckGlJsonChartProto";

message DeckGlJsonChart {
  // The json of the pydeck object (https://deckgl.readthedocs.io/en/latest/deck.html)
  string json = 1;

  string tooltip = 2;

  // If True, will overwrite the chart width spec to fit to container.
  bool use_container_width = 4;

  // ID, required for selection events.
  string id = 5;

  // The user-configured Mapbox token. If empty, the token id fetched from https://data.streamlit.io/tokens.json
  string mapbox_token = 6;

  // Width in pixels
  uint32 width = 7;

  // Height in pixels
  uint32 height = 8;

  // If non-empty, treat this instance as a Widget
  repeated SelectionMode selection_mode = 9;

  // The form ID of the widget, this is required if the chart has selection events
  string form_id = 10;

  // Available selection modes:
  enum SelectionMode {
    SINGLE_OBJECT = 0; // Only one object can be selected at a time.
    MULTI_OBJECT = 1; // Multiple objects can be selected at a time.
  }
}


================================================
File: /proto/streamlit/proto/Delta.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "DeltaProto";

import "streamlit/proto/Block.proto";
import "streamlit/proto/Element.proto";
import "streamlit/proto/NamedDataSet.proto";
import "streamlit/proto/ArrowNamedDataSet.proto";

// A change to an element.
message Delta {
  oneof type {
    // Append a new element to the frontend.
    Element new_element = 3;

    // Append a new block to the frontend.
    Block add_block = 6;

    // Append data to a DataFrame in for current element. The element to add to
    // is identified by the ID field, above. The dataframe is identified either
    // by NamedDataSet.name or by setting NamedDataSet.has_name to false.
    // All elements that contain a DataFrame should support add_rows.
    NamedDataSet add_rows = 5;
    ArrowNamedDataSet arrow_add_rows = 7;
  }

  string fragment_id = 8;
}


================================================
File: /proto/streamlit/proto/DocString.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "DocStringProto";

// Formatted text
message DocString {

  // [DEPRECATED] The name of the object.
  //string name = 1;
  reserved 1;

  // [DEPRECATED] The module of the object
  //string module = 2;
  reserved 2;

  // The doc string.
  string doc_string = 3;

  // The type of the object.
  string type = 4;

  // [DEPRECATED] The signature of the object, if it's a function. Else, unset.
  //string signature = 5;
  reserved 5;

  // The name the user gave to the variable holding this object.
  string name = 6;

  // A string representation of this object's value.
  string value = 7;

  // List of this object's methods and member variables.
  repeated Member members = 8;
}


message Member {
  // The name of the object.
  string name = 1;

  // The type of the object.
  string type = 2;

  oneof contents {
    // A string representation of this member's value.
    string value = 3;

    // The doc string.
    string doc_string = 4;
  }
}


================================================
File: /proto/streamlit/proto/DownloadButton.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "DownloadButtonProto";

message DownloadButton {
  string id = 1;
  string label = 2;
  bool default = 3;
  string help = 4;
  string form_id = 5;
  string url = 6;
  bool disabled = 7;
  bool use_container_width = 8;
  string type = 9;
  string icon = 10;
}


================================================
File: /proto/streamlit/proto/Element.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "ElementProto";

import "streamlit/proto/Alert.proto";
import "streamlit/proto/Arrow.proto";
import "streamlit/proto/Audio.proto";
import "streamlit/proto/AudioInput.proto";
import "streamlit/proto/Balloons.proto";
import "streamlit/proto/ArrowVegaLiteChart.proto";
import "streamlit/proto/BokehChart.proto";
import "streamlit/proto/Button.proto";
import "streamlit/proto/ButtonGroup.proto";
import "streamlit/proto/DownloadButton.proto";
import "streamlit/proto/CameraInput.proto";
import "streamlit/proto/ChatInput.proto";
import "streamlit/proto/Checkbox.proto";
import "streamlit/proto/Code.proto";
import "streamlit/proto/ColorPicker.proto";
import "streamlit/proto/DataFrame.proto";
import "streamlit/proto/DateInput.proto";
import "streamlit/proto/DeckGlJsonChart.proto";
import "streamlit/proto/DocString.proto";
import "streamlit/proto/Empty.proto";
import "streamlit/proto/Exception.proto";
import "streamlit/proto/Favicon.proto";
import "streamlit/proto/FileUploader.proto";
import "streamlit/proto/GraphVizChart.proto";
import "streamlit/proto/Html.proto";
import "streamlit/proto/IFrame.proto";
import "streamlit/proto/Image.proto";
import "streamlit/proto/Json.proto";
import "streamlit/proto/LinkButton.proto";
import "streamlit/proto/NumberInput.proto";
import "streamlit/proto/Markdown.proto";
import "streamlit/proto/Metric.proto";
import "streamlit/proto/MultiSelect.proto";
import "streamlit/proto/PageLink.proto";
import "streamlit/proto/PlotlyChart.proto";
import "streamlit/proto/Components.proto";
import "streamlit/proto/Progress.proto";
import "streamlit/proto/Snow.proto";
import "streamlit/proto/Spinner.proto";
import "streamlit/proto/Radio.proto";
import "streamlit/proto/Selectbox.proto";
import "streamlit/proto/Skeleton.proto";
import "streamlit/proto/Slider.proto";
import "streamlit/proto/Text.proto";
import "streamlit/proto/TextArea.proto";
import "streamlit/proto/TextInput.proto";
import "streamlit/proto/TimeInput.proto";
import "streamlit/proto/Toast.proto";
import "streamlit/proto/VegaLiteChart.proto";
import "streamlit/proto/Video.proto";
import "streamlit/proto/Heading.proto";

// An element which can be displayed on the screen.
message Element {

  // An element can be one of the following element types.
  oneof type {
    Alert alert = 30;
    Arrow arrow_data_frame = 40;
    Arrow arrow_table = 39;
    ArrowVegaLiteChart arrow_vega_lite_chart = 41;
    Audio audio = 13;
    AudioInput audio_input = 56;
    Balloons balloons = 12;
    BokehChart bokeh_chart = 17;
    Button button = 19;
    ButtonGroup button_group = 55;
    DownloadButton download_button = 43;
    CameraInput camera_input = 45;
    ChatInput chat_input = 49;
    Checkbox checkbox = 20;
    ColorPicker color_picker = 35;
    ComponentInstance component_instance = 37;
    // DEPRECATED: This element is deprecated and unused:
    DataFrame data_frame = 3;
    // DEPRECATED: This element is deprecated and unused:
    DataFrame table = 11;
    DateInput date_input = 27;
    DeckGlJsonChart deck_gl_json_chart = 34;
    DocString doc_string = 7;
    Empty empty = 2;
    Exception exception = 8;
    Favicon favicon = 36;
    FileUploader file_uploader = 33;
    GraphVizChart graphviz_chart = 18;
    Html html = 54;
    IFrame iframe = 38;
    ImageList imgs = 6;
    Json json = 31;
    LinkButton link_button = 51;
    Markdown markdown = 29;
    Metric metric = 42;
    MultiSelect multiselect = 28;
    NumberInput number_input = 32;
    PageLink page_link = 53;
    PlotlyChart plotly_chart = 16;
    Progress progress = 5;
    Radio radio = 23;
    Selectbox selectbox = 25;
    Skeleton skeleton = 52;
    Slider slider = 21;
    Snow snow = 46;
    Spinner spinner = 44;
    Text text = 1;
    TextArea text_area = 22;
    TextInput text_input = 24;
    TimeInput time_input = 26;
    Toast toast = 50;
    // DEPRECATED: This element is deprecated and unused:
    VegaLiteChart vega_lite_chart = 10;
    Video video = 14;
    Heading heading = 47;
    Code code = 48;
    // Next ID: 57
  }

  reserved 9;
}


================================================
File: /proto/streamlit/proto/Empty.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "EmptyProto";

// A python empty.
message Empty {
}


================================================
File: /proto/streamlit/proto/Exception.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "ExceptionProto";

// A python exception.
//
// NOTE: This proto type is used by some external services so needs to remain
// relatively stable. While it isn't entirely set in stone, changing it
// may require a good amount of effort so should be avoided if possible.
message Exception {

  // The type of the exception. This can be any string, but is usually a valid
  // Python exception type, like 'RuntimeError'.
  string type = 1;

  // The exception's message.
  string message = 2;

  // If true, the exception message should be rendered as Markdown text.
  bool message_is_markdown = 4;

  // The stack trace to print.
  repeated string stack_trace = 3;

  // If true, this is an error that doesn't stop the execution flow. So it gets
  // rendered differently for clarity.
  bool is_warning = 5;
}


================================================
File: /proto/streamlit/proto/Favicon.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "FaviconProto";

message Favicon {
  string url = 1;
}


================================================
File: /proto/streamlit/proto/FileUploader.proto
================================================
/**!
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

option java_package = "com.snowflake.apps.streamlit";
option java_outer_classname = "FileUploaderProto";

import "streamlit/proto/LabelVisibilityMessage.proto";

// file_uploader widget
message FileUploader {
  // The widget id
  string id = 1;

  // Text to be displayed before the widget
  string label = 2;

  // Supported types: For example: ["png","jpg","img"]
  repeated string type = 3;

  // Max file size allowed by server config
  int32 max_upload_size_mb = 4;

  // If true, the widget accepts multiple files for upload.
  bool multiple_files = 6;

  string help = 7;

