 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { createContext } from "react"

type ElementFullscreenContextShape = {
  width: number
  height: number | undefined
  expanded: boolean
  expand: () => void
  collapse: () => void
}

export const ElementFullscreenContext =
  createContext<ElementFullscreenContextShape | null>(null)
ElementFullscreenContext.displayName = "ElementFullscreenContext"


================================================
File: /frontend/lib/src/components/shared/ElementFullscreen/ElementFullscreenWrapper.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, PropsWithChildren, useMemo } from "react"

import { useTheme } from "@emotion/react"

import { StyledFullScreenFrame } from "@streamlit/lib/src/components/shared/FullScreenWrapper/styled-components"
import { ElementFullscreenContext } from "@streamlit/lib/src/components/shared/ElementFullscreen/ElementFullscreenContext"
import { EmotionTheme } from "@streamlit/lib/src/theme"

import { useFullscreen } from "./useFullscreen"

type ElementFullscreenWrapperProps = PropsWithChildren<{
  height?: number
  width: number
}>

const ElementFullscreenWrapper: FC<ElementFullscreenWrapperProps> = ({
  children,
  height,
  width,
}) => {
  const theme: EmotionTheme = useTheme()
  const { expanded, fullHeight, fullWidth, zoomIn, zoomOut } = useFullscreen()

  const fullscreenContextValue = useMemo(() => {
    return {
      width: expanded ? fullWidth : width,
      height: expanded ? fullHeight : height,
      expanded,
      expand: zoomIn,
      collapse: zoomOut,
    }
  }, [expanded, fullHeight, fullWidth, height, width, zoomIn, zoomOut])

  return (
    <ElementFullscreenContext.Provider value={fullscreenContextValue}>
      <StyledFullScreenFrame
        isExpanded={expanded}
        data-testid="stFullScreenFrame"
        theme={theme}
      >
        {children}
      </StyledFullScreenFrame>
    </ElementFullscreenContext.Provider>
  )
}

export default ElementFullscreenWrapper


================================================
File: /frontend/lib/src/components/shared/ElementFullscreen/testUtils.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, PropsWithChildren, ReactElement } from "react"

/* eslint-disable import/no-extraneous-dependencies */
import { RenderOptions, RenderResult } from "@testing-library/react"
import {
  renderHook as reactTestingLibraryRenderHook,
  RenderHookOptions,
} from "@testing-library/react-hooks"

import ElementFullscreenWrapper from "@streamlit/lib/src/components/shared/ElementFullscreen/ElementFullscreenWrapper"
import {
  TestAppWrapper,
  render as testUtilRender,
} from "@streamlit/lib/src/test_util"

/**
 * Reusable test harness for rendering components in a fullscreen context.
 * Prefer to utilize `renderWithContext` and `renderHookWithContext` instead of
 * using this directly.
 */
const FullscreenHarness: FC<PropsWithChildren> = ({ children }) => {
  return (
    <TestAppWrapper>
      {/* 500 is an arbitrary value for the width, as it's not actually used in the tests */}
      <ElementFullscreenWrapper width={500}>
        {children}
      </ElementFullscreenWrapper>
    </TestAppWrapper>
  )
}

export function render(
  ui: ReactElement,
  options?: Omit<RenderOptions, "queries" | "wrapper">
): RenderResult {
  return testUtilRender(ui, { wrapper: FullscreenHarness, ...options })
}

// eslint-disable-next-line @typescript-eslint/explicit-function-return-type
export function renderHook<Props, Result>(
  hook: (props: Props) => Result,
  options: Omit<RenderHookOptions<Props>, "wrapper"> | undefined
) {
  return reactTestingLibraryRenderHook(hook, {
    // @ts-expect-error This works but TS is being weird about it
    wrapper: FullscreenHarness,
    ...options,
  })
}


================================================
File: /frontend/lib/src/components/shared/ElementFullscreen/useFullscreen.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { useCallback, useContext, useEffect, useMemo, useState } from "react"

import { LibContext } from "@streamlit/lib/src/components/core/LibContext"
import { WindowDimensionsContext } from "@streamlit/lib/src/components/shared/WindowDimensions"
import { useRequiredContext } from "@streamlit/lib/src/hooks/useRequiredContext"

export type UseEscapeToCollapseArgs = {
  expanded: boolean
  zoomOut: () => void
}

export type UseFullscreenShape = {
  expanded: boolean
  fullHeight: number
  fullWidth: number
  zoomIn: () => void
  zoomOut: () => void
}

export const useFullscreen = (): UseFullscreenShape => {
  const { setFullScreen } = useContext(LibContext)
  const [expanded, setExpanded] = useState(false)
  const { fullHeight, fullWidth } = useRequiredContext(WindowDimensionsContext)

  const setExpandedState = useCallback(
    (isExpanded: boolean) => {
      // Set the local component-level state
      setExpanded(isExpanded)
      // Set the context-level state
      setFullScreen(isExpanded)
    },
    [setFullScreen]
  )

  const zoomIn = useCallback(() => {
    document.body.style.overflow = "hidden"
    setExpandedState(true)
  }, [setExpandedState])

  const zoomOut = useCallback(() => {
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    document.body.style.overflow = "unset"
    setExpandedState(false)
  }, [setExpandedState])

  const controlKeys = useCallback(
    (event: KeyboardEvent) => {
      /**
       * keyCode 27 is the ESC key
       * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode
       */
      if (event.keyCode === 27 && expanded) {
        // Exit fullscreen
        zoomOut()
      }
    },
    [zoomOut, expanded]
  )

  useEffect(() => {
    document.addEventListener("keydown", controlKeys, false)

    return () => {
      document.removeEventListener("keydown", controlKeys, false)
    }
  }, [controlKeys])

  return useMemo(() => {
    return { expanded, zoomIn, zoomOut, fullHeight, fullWidth }
  }, [expanded, zoomIn, zoomOut, fullHeight, fullWidth])
}


================================================
File: /frontend/lib/src/components/shared/ErrorBoundary/ErrorBoundary.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import ErrorElement from "@streamlit/lib/src/components/shared/ErrorElement"
import { logError } from "@streamlit/lib/src/util/log"
import { StyledInlineCode } from "@streamlit/lib/src/components/elements/CodeBlock/styled-components"

export interface Props {
  width?: number
}

export interface State {
  error?: Error | null
}

/**
 * A component that catches errors that take place when React is asynchronously
 * rendering child components.
 */
class ErrorBoundary extends React.PureComponent<
  React.PropsWithChildren<Props>,
  State
> {
  public state: State = {
    error: null,
  }

  public static getDerivedStateFromError = (error: Error): State => {
    // Return the state update so the next render will show the fallback UI.
    return {
      error,
    }
  }

  public componentDidCatch = (error: Error): void => {
    logError(`${error.name}: ${error.message}\n${error.stack}`)
  }

  public render(): React.ReactNode {
    const { error } = this.state

    if (error) {
      if (error.name === "ChunkLoadError") {
        return (
          <ErrorElement
            width={this.props.width}
            name="Network issue"
            message={
              <p>
                Cannot load Streamlit frontend code. This can happen when you
                update Streamlit while a Streamlit app is running.
                <br />
                To fix this, simply reload this app by pressing{" "}
                <StyledInlineCode>F5</StyledInlineCode>,{" "}
                <StyledInlineCode>Ctrl+R</StyledInlineCode>, or{" "}
                <StyledInlineCode>Cmd+R</StyledInlineCode>.
                <br />
                If the error persists, try force-clearing your browser's cache
                as described{" "}
                <a
                  href="https://en.wikipedia.org/wiki/Wikipedia:Bypass_your_cache#Cache_clearing_and_disabling"
                  rel="noopener noreferrer"
                  target="_blank"
                >
                  here
                </a>
              </p>
            }
          />
        )
      }

      return (
        <ErrorElement
          width={this.props.width}
          name={error.name}
          message={error.message}
          stack={error.stack}
        />
      )
    }

    return this.props.children
  }
}

export default ErrorBoundary


================================================
File: /frontend/lib/src/components/shared/ErrorBoundary/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./ErrorBoundary"


================================================
File: /frontend/lib/src/components/shared/ErrorElement/ErrorElement.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import ErrorElement, { ErrorElementProps } from "./ErrorElement"

const getProps = (
  propOverrides: Partial<ErrorElementProps> = {}
): ErrorElementProps => ({
  name: "Name",
  message: "Message",
  stack: "Stack\nLine 1   \nLine 2\n",
  width: 100,
  ...propOverrides,
})

describe("ErrorElement element", () => {
  it("renders an AlertElement without crashing", () => {
    const props = getProps()
    render(<ErrorElement {...props} />)

    expect(screen.getByTestId("stAlertContainer")).toBeInTheDocument()
  })

  it("renders stack without first line and trimmed lines", () => {
    const props = getProps()
    render(<ErrorElement {...props} />)

    expect(screen.getByTestId("stErrorElementStack")).toHaveTextContent(
      "Line 1 Line 2"
    )
  })

  it("does not render the stack when not defined", () => {
    const props = getProps({ stack: undefined })
    render(<ErrorElement {...props} />)

    expect(screen.queryByTestId("stErrorElementStack")).not.toBeInTheDocument()
  })
})


================================================
File: /frontend/lib/src/components/shared/ErrorElement/ErrorElement.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import AlertContainer, {
  Kind,
} from "@streamlit/lib/src/components/shared/AlertContainer"
import { StyledCode } from "@streamlit/lib/src/components/elements/CodeBlock/styled-components"

import { StyledErrorName, StyledStackTrace } from "./styled-components"

export interface ErrorElementProps {
  name: string
  message: string | ReactElement
  stack?: string
  width?: number
}

/**
 * A component that draws an error on the screen. This is for internal use
 * only. That is, this should not be an element that a user purposefully places
 * in a Streamlit app. For that, see st.exception / Exception.tsx or
 * st.error / Text.tsx.
 */
function ErrorElement(props: ErrorElementProps): ReactElement {
  const { name, message, stack, width } = props

  // Remove first line from stack (because it's just the error message) and
  // trim indentation.
  const stackArray = stack ? stack.split("\n") : []
  stackArray.shift()
  const cleanedStack = stackArray.map(s => s.trim()).join("\n")

  return (
    <AlertContainer kind={Kind.ERROR} width={width}>
      <StyledErrorName>{name}: </StyledErrorName>
      {message}
      {stack ? (
        <StyledStackTrace data-testid="stErrorElementStack">
          <StyledCode>{cleanedStack}</StyledCode>
        </StyledStackTrace>
      ) : null}
    </AlertContainer>
  )
}

export default ErrorElement


================================================
File: /frontend/lib/src/components/shared/ErrorElement/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./ErrorElement"


================================================
File: /frontend/lib/src/components/shared/ErrorElement/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledStackTrace = styled.pre(({ theme }) => ({
  whiteSpace: "pre-wrap",
  wordWrap: "break-word",
  color: "inherit",
  fontSize: theme.fontSizes.sm,
  fontFamily: theme.genericFonts.codeFont,
  backgroundColor: theme.colors.transparent,
  overflowX: "auto",
  margin: `0 0 ${theme.spacing.lg} 0`,
  borderRadius: theme.radii.default,
  padding: theme.spacing.lg,
  border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
}))

export const StyledErrorName = styled.strong(({ theme }) => ({
  fontWeight: theme.fontWeights.bold,
}))


================================================
File: /frontend/lib/src/components/shared/FullScreenWrapper/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default as withFullScreenWrapper } from "./withFullScreenWrapper"


================================================
File: /frontend/lib/src/components/shared/FullScreenWrapper/styled-components.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export interface StyledFullScreenFrameProps {
  isExpanded: boolean
}

export const StyledFullScreenFrame = styled.div<StyledFullScreenFrameProps>(
  ({ theme, isExpanded }) => ({
    ...(isExpanded
      ? {
          position: "fixed",
          top: 0,
          left: 0,
          bottom: 0,
          right: 0,
          background: theme.colors.bgColor,
          zIndex: theme.zIndices.fullscreenWrapper,
          padding: theme.spacing.md,
          paddingTop: theme.sizes.fullScreenHeaderHeight,
          overflow: ["auto", "overlay"],
          display: "flex", // To avoid extra spaces that lead to scrollbars.
          alignItems: "center",
          justifyContent: "center",
        }
      : {}),
  })
)


================================================
File: /frontend/lib/src/components/shared/FullScreenWrapper/withFullScreenWrapper.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { PureComponent, ReactNode } from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import withFullScreenWrapper from "./withFullScreenWrapper"

interface TestProps {
  width: number
  isFullScreen: boolean
  label: string
  height?: number
  expand: () => void
  collapse: () => void
}

class TestComponent extends PureComponent<TestProps> {
  public render = (): ReactNode => (
    <>
      <div>{this.props.label}</div>
      <div>
        {this.props.isFullScreen ? "isFullScreen" : "NOT isFullScreen"}
      </div>
    </>
  )
}

const getProps = (props: Partial<TestProps> = {}): TestProps => ({
  width: 100,
  isFullScreen: false,
  expand: vi.fn(),
  collapse: vi.fn(),
  label: "label",
  ...props,
})

const WrappedTestComponent = withFullScreenWrapper(TestComponent)

describe("withFullScreenWrapper HOC", () => {
  it("renders without crashing", () => {
    render(<WrappedTestComponent {...getProps()} />)

    expect(screen.getByTestId("stFullScreenFrame")).toBeInTheDocument()
  })

  it("renders a component wrapped with FullScreenWrapper", () => {
    const props = getProps()
    render(<WrappedTestComponent {...props} />)

    expect(screen.getByTestId("stFullScreenFrame")).toHaveStyle(
      `width: ${props.width}`
    )
  })

  it("renders FullScreenWrapper with specified height", () => {
    const props = getProps({ width: 123, label: "label", height: 455 })
    render(<WrappedTestComponent {...props} />)

    expect(screen.getByTestId("stFullScreenFrame")).toHaveStyle(
      `width: ${props.width}`
    )
    expect(screen.getByTestId("stFullScreenFrame")).toHaveStyle(
      `height: ${props.height}`
    )
  })

  it("passes unrelated props to wrapped component", () => {
    const props = getProps()
    render(<WrappedTestComponent {...props} />)

    expect(screen.getByTestId("stFullScreenFrame")).toBeInTheDocument()
    expect(screen.getByText(`${props.label}`)).toBeInTheDocument()
  })

  it("defines `displayName`", () => {
    expect(WrappedTestComponent.displayName).toEqual(
      "withFullScreenWrapper(TestComponent)"
    )
  })
})


================================================
File: /frontend/lib/src/components/shared/FullScreenWrapper/withFullScreenWrapper.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ComponentType, ReactElement } from "react"

import hoistNonReactStatics from "hoist-non-react-statics"

import ElementFullscreenWrapper from "@streamlit/lib/src/components/shared/ElementFullscreen/ElementFullscreenWrapper"

function withFullScreenWrapper<P extends { width: number }>(
  WrappedComponent: ComponentType<React.PropsWithChildren<P>>
): ComponentType<React.PropsWithChildren<P>> {
  const ComponentWithFullScreenWrapper = (props: P): ReactElement => {
    return (
      <ElementFullscreenWrapper width={props.width}>
        <WrappedComponent {...(props as P)}></WrappedComponent>
      </ElementFullscreenWrapper>
    )
  }
  ComponentWithFullScreenWrapper.displayName = `withFullScreenWrapper(${
    WrappedComponent.displayName || WrappedComponent.name
  })`

  // Static methods must be copied over
  // https://en.reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over
  return hoistNonReactStatics(ComponentWithFullScreenWrapper, WrappedComponent)
}

export default withFullScreenWrapper


================================================
File: /frontend/lib/src/components/shared/Icon/DynamicIcon.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import {
  DynamicIcon,
  DynamicIconProps,
  getFilledStarIconSrc,
} from "./DynamicIcon"

const getProps = (
  props: Partial<DynamicIconProps> = {}
): DynamicIconProps => ({
  iconValue: ":material/flag:",
  ...props,
})

describe("Dynamic icon", () => {
  it("renders without crashing with Material icon", () => {
    const props = getProps({ iconValue: ":material/add_circle:" })
    render(<DynamicIcon {...props} />)
    const testId = screen.getByTestId("stIconMaterial")
    const icon = screen.getByText("add_circle")

    expect(testId).toBeInTheDocument()
    expect(icon).toBeInTheDocument()
    expect(testId.textContent).toEqual(icon.textContent)
  })

  it("renders without crashing with Emoji icon", () => {
    const props = getProps({ iconValue: "⛰️" })
    render(<DynamicIcon {...props} />)
    const testId = screen.getByTestId("stIconEmoji")
    const icon = screen.getByText("⛰️")

    expect(testId).toBeInTheDocument()
    expect(icon).toBeInTheDocument()
    expect(testId.textContent).toEqual(icon.textContent)
  })

  it("renders without crashing Styled image", () => {
    const props = getProps({ iconValue: ":material/star_filled:" })
    render(<DynamicIcon {...props} />)
    const testId = screen.getByTestId("stImageIcon")
    const srcAttr = testId.getAttribute("src")

    expect(testId).toBeInTheDocument()
    expect(srcAttr).toEqual(getFilledStarIconSrc())
  })
})


================================================
File: /frontend/lib/src/components/shared/Icon/DynamicIcon.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { Suspense } from "react"

import { IconSize, ThemeColor } from "@streamlit/lib/src/theme"

import { EmojiIcon } from "./Icon"
import MaterialFontIcon from "./Material/MaterialFontIcon"
import { StyledDynamicIcon, StyledImageIcon } from "./styled-components"

interface IconPackEntry {
  pack: string
  icon: string
}

function parseIconPackEntry(iconName: string): IconPackEntry {
  // This is a regex to match icon pack and icon name from the strings of format
  // :pack/icon: like :material/settings_suggest:
  const matchResult = iconName.match(/^:(.+)\/(.+):$/)
  if (matchResult === null) {
    return { pack: "emoji", icon: iconName }
  }
  const iconPack = matchResult[1]
  const iconNameInPack = matchResult[2]
  return { pack: iconPack, icon: iconNameInPack }
}

/**
 *
 * @returns returns an img tag with a yellow filled star icon svg as base64 data
 */
export function getFilledStarIconSrc(): string {
  return "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIHZpZXdCb3g9IjAgMCAyMCAyMCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMTg2MF84NDMpIj48cGF0aCBkPSJNOS45OTk5NCAxNC4zOTE2TDEzLjQ1ODMgMTYuNDgzM0MxNC4wOTE2IDE2Ljg2NjYgMTQuODY2NiAxNi4zIDE0LjY5OTkgMTUuNTgzM0wxMy43ODMzIDExLjY1TDE2Ljg0MTYgOC45OTk5N0MxNy4zOTk5IDguNTE2NjMgMTcuMDk5OSA3LjU5OTk3IDE2LjM2NjYgNy41NDE2M0wxMi4zNDE2IDcuMTk5OTdMMTAuNzY2NiAzLjQ4MzNDMTAuNDgzMyAyLjgwODMgOS41MTY2MSAyLjgwODMgOS4yMzMyNyAzLjQ4MzNMNy42NTgyNyA3LjE5MTYzTDMuNjMzMjcgNy41MzMzQzIuODk5OTQgNy41OTE2MyAyLjU5OTk0IDguNTA4MyAzLjE1ODI3IDguOTkxNjNMNi4yMTY2MSAxMS42NDE2TDUuMjk5OTQgMTUuNTc1QzUuMTMzMjcgMTYuMjkxNiA1LjkwODI3IDE2Ljg1ODMgNi41NDE2MSAxNi40NzVMOS45OTk5NCAxNC4zOTE2WiIgZmlsbD0iI0ZBQ0EyQiIvPjwvZz48ZGVmcz48Y2xpcFBhdGggaWQ9ImNsaXAwXzE4NjBfODQzIj48cmVjdCB3aWR0aD0iMjAiIGhlaWdodD0iMjAiIGZpbGw9IndoaXRlIi8+PC9jbGlwUGF0aD48L2RlZnM+PC9zdmc+"
}

export interface DynamicIconProps {
  iconValue: string
  size?: IconSize
  margin?: string
  padding?: string
  testid?: string
  color?: ThemeColor
}

const DynamicIconDispatcher = ({
  iconValue,
  ...props
}: DynamicIconProps): React.ReactElement => {
  const { pack, icon } = parseIconPackEntry(iconValue)
  switch (pack) {
    case "material":
      switch (icon) {
        case "star_filled":
          return (
            <StyledDynamicIcon {...props}>
              <StyledImageIcon
                src={getFilledStarIconSrc()}
                data-testid={props.testid || "stImageIcon"}
              />
            </StyledDynamicIcon>
          )
        default:
          return (
            <StyledDynamicIcon {...props}>
              <MaterialFontIcon pack={pack} iconName={icon} {...props} />
            </StyledDynamicIcon>
          )
      }
    case "emoji":
    default:
      return (
        <StyledDynamicIcon {...props}>
          <EmojiIcon {...props}>{icon}</EmojiIcon>
        </StyledDynamicIcon>
      )
  }
}

export const DynamicIcon = (props: DynamicIconProps): React.ReactElement => (
  <Suspense
    fallback={
      <StyledDynamicIcon {...props}>
        <EmojiIcon {...props}>&nbsp;</EmojiIcon>
      </StyledDynamicIcon>
    }
    key={props.iconValue}
  >
    <DynamicIconDispatcher {...props} />
  </Suspense>
)


================================================
File: /frontend/lib/src/components/shared/Icon/Icon.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, ReactNode } from "react"

import { EmotionIcon } from "@emotion-icons/emotion-icon"

import { IconSize, ThemeColor } from "@streamlit/lib/src/theme"

import { StyledEmojiIcon, StyledIcon } from "./styled-components"

interface GetDefaultPropsArgs {
  size?: IconSize
  margin?: string
  padding?: string
}

interface DefaultProps {
  size: IconSize
  margin: string
  padding: string
}

const getDefaultProps = ({
  size,
  margin,
  padding,
}: GetDefaultPropsArgs): DefaultProps => ({
  size: size || "md",
  margin: margin || "",
  padding: padding || "",
})

interface IconProps {
  content: EmotionIcon
  size?: IconSize
  color?: ThemeColor
  margin?: string
  padding?: string
  testid?: string
}

const Icon = ({
  content,
  color,
  size,
  margin,
  padding,
  testid,
}: IconProps): ReactElement => (
  <StyledIcon
    as={content}
    color={color || "inherit"}
    aria-hidden="true"
    data-testid={testid}
    {...getDefaultProps({ size, margin, padding })}
  />
)

interface EmojiIconProps {
  size?: IconSize
  margin?: string
  padding?: string
  children: ReactNode
  testid?: string
}

export const EmojiIcon = ({
  size,
  margin,
  padding,
  children,
  testid,
}: EmojiIconProps): ReactElement => (
  <StyledEmojiIcon
    data-testid={testid || "stIconEmoji"}
    aria-hidden="true"
    {...getDefaultProps({ size, margin, padding })}
  >
    {children}
  </StyledEmojiIcon>
)

export default Icon


================================================
File: /frontend/lib/src/components/shared/Icon/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default, EmojiIcon } from "./Icon"
export { DynamicIcon, getFilledStarIconSrc } from "./DynamicIcon"
export { StyledIcon, StyledSpinnerIcon } from "./styled-components"


================================================
File: /frontend/lib/src/components/shared/Icon/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { EmotionIcon } from "@emotion-icons/emotion-icon"
import isPropValid from "@emotion/is-prop-valid"
import styled from "@emotion/styled"
import { Spinner } from "baseui/spinner"

import {
  computeSpacingStyle,
  IconSize,
  ThemeColor,
} from "@streamlit/lib/src/theme"

interface StyledSpinnerIconProps {
  usingCustomTheme: boolean
  size: IconSize
  margin: string
  padding: string
}

export const StyledSpinnerIcon = styled(Spinner, {
  shouldForwardProp: (prop: string) =>
    isPropValid(prop) && !["size"].includes(prop),
})<StyledSpinnerIconProps>(
  ({ usingCustomTheme, size, margin, padding, theme }) => {
    return {
      width: theme.iconSizes[size],
      height: theme.iconSizes[size],
      fontSize: theme.iconSizes[size],
      justifyContents: "center",
      margin: computeSpacingStyle(margin, theme),
      padding: computeSpacingStyle(padding, theme),
      borderColor: theme.colors.borderColor,
      borderTopColor: usingCustomTheme
        ? theme.colors.primary
        : theme.colors.blue70,
      borderWidth: theme.sizes.spinnerThickness,
      flexGrow: 0,
      flexShrink: 0,
    }
  }
)

interface StyledIconProps {
  as?: EmotionIcon
  color: ThemeColor
  size: IconSize
  margin: string
  padding: string
}

export const StyledIcon = styled("span", {
  shouldForwardProp: (prop: string) =>
    isPropValid(prop) && !["size", "as"].includes(prop),
})<StyledIconProps>(({ color, size, margin, padding, theme }) => {
  return {
    color: theme.colors[color],
    fill: "currentColor",
    display: "inline-flex",
    alignItems: "center",
    justifyContents: "center",
    fontSize: theme.iconSizes[size],
    width: theme.iconSizes[size],
    height: theme.iconSizes[size],
    margin: computeSpacingStyle(margin, theme),
    padding: computeSpacingStyle(padding, theme),
    flexShrink: 0,
  }
})

export interface StyledDynamicIconProps {
  size?: IconSize
  margin?: string
  padding?: string
}

export const StyledDynamicIcon = styled.span<StyledDynamicIconProps>(
  ({ size = "lg", margin = "", padding = "", theme }) => {
    return {
      fill: "currentColor",
      display: "inline-flex",
      alignItems: "center",
      justifyContents: "center",
      fontSize: theme.iconSizes[size],
      width: theme.iconSizes[size],
      height: theme.iconSizes[size],
      margin: computeSpacingStyle(margin, theme),
      padding: computeSpacingStyle(padding, theme),
      flexShrink: 0,
    }
  }
)

export const StyledImageIcon = styled.img(({}) => {
  return {
    width: "100%",
    height: "100%",
  }
})

interface StyledEmojiIconProps {
  size: IconSize
  margin: string
  padding: string
}

export const StyledEmojiIcon = styled.span<StyledEmojiIconProps>(
  ({ size, margin, padding, theme }) => {
    return {
      display: "inline-flex",
      alignItems: "center",
      justifyContents: "center",
      fontSize: theme.iconSizes[size],
      width: theme.iconSizes[size],
      height: theme.iconSizes[size],
      margin: computeSpacingStyle(margin, theme),
      padding: computeSpacingStyle(padding, theme),
    }
  }
)


================================================
File: /frontend/lib/src/components/shared/Icon/Material/MaterialFontIcon.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import snakeCase from "lodash/snakeCase"

import { IconSize, ThemeColor } from "@streamlit/lib/src/theme"

import {
  StyledMaterialIcon,
  StyledMaterialIconProps,
} from "./styled-components"

interface MaterialIconProps {
  iconName: string
  pack: string
  size?: IconSize
  color?: ThemeColor
  margin?: string
  padding?: string
  testid?: string
}

const getDefaultProps = ({
  size,
  margin,
  padding,
  color,
}: Partial<StyledMaterialIconProps>): StyledMaterialIconProps => ({
  size: size || "md",
  margin: margin || "",
  padding: padding || "",
  color: color || "inherit",
})

const MaterialFontIcon = ({
  iconName,
  ...props
}: MaterialIconProps): ReactElement => {
  return (
    <StyledMaterialIcon
      {...getDefaultProps(props)}
      data-testid={props.testid || "stIconMaterial"}
    >
      {snakeCase(iconName)}
    </StyledMaterialIcon>
  )
}

export default MaterialFontIcon


================================================
File: /frontend/lib/src/components/shared/Icon/Material/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

import { computeSpacingStyle, IconSize } from "@streamlit/lib/src/theme"

export interface StyledMaterialIconProps {
  size: IconSize
  margin: string
  padding: string
  color: string
}

export const StyledMaterialIcon = styled.span<StyledMaterialIconProps>(
  ({ size, margin, padding, theme, color }) => {
    return {
      display: "inline-flex",
      alignItems: "center",
      justifyContents: "center",
      color: color,
      fontSize: theme.iconSizes[size],
      width: theme.iconSizes[size],
      height: theme.iconSizes[size],
      margin: computeSpacingStyle(margin, theme),
      padding: computeSpacingStyle(padding, theme),
      userSelect: "none",
      fontFamily: theme.genericFonts.iconFont,
      fontWeight: theme.fontWeights.normal,
      fontStyle: "normal",
      lineHeight: theme.lineHeights.none,
      letterSpacing: "normal",
      textTransform: "none",
      whiteSpace: "nowrap",
      wordWrap: "normal",
      direction: "ltr",
      fontFeatureSettings: "liga",
      MozFontFeatureSettings: "liga",
      WebkitFontFeatureSettings: "liga",
      WebkitFontSmoothing: "antialiased",
    }
  }
)


================================================
File: /frontend/lib/src/components/shared/InputInstructions/InputInstructions.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import InputInstructions, { Props } from "./InputInstructions"

const getProps = (props: Partial<Props> = {}): Props => ({
  dirty: true,
  value: "asd",
  inForm: false,
  ...props,
})

describe("InputInstructions", () => {
  const props = getProps()

  it("renders without crashing", () => {
    render(<InputInstructions {...props} />)

    expect(screen.getByTestId("InputInstructions").textContent).toBeDefined()
  })

  it("should show Enter instructions by default", () => {
    render(<InputInstructions {...props} />)

    expect(screen.getByText("Press Enter to apply")).toBeVisible()
  })

  describe("Multiline type", () => {
    const props = getProps({
      type: "multiline",
    })

    it("should show Ctrl+Enter instructions", () => {
      render(<InputInstructions {...props} />)
      expect(screen.getByText("Press Ctrl+Enter to apply")).toBeVisible()
    })

    it("show ⌘+Enter instructions", () => {
      Object.defineProperty(navigator, "platform", {
        value: "MacIntel",
        writable: true,
      })

      const props = getProps({
        type: "multiline",
      })
      render(<InputInstructions {...props} />)

      expect(screen.getByText("Press ⌘+Enter to apply")).toBeVisible()
    })

    it("should show instructions for max length", () => {
      const props = getProps({
        type: "multiline",
        maxLength: 3,
      })
      render(<InputInstructions {...props} />)

      expect(screen.getByTestId("InputInstructions").textContent).toBe(
        "Press ⌘+Enter to apply3/3"
      )
    })
  })

  it("should show instructions for max length", () => {
    const props = getProps({
      maxLength: 3,
    })
    render(<InputInstructions {...props} />)

    expect(screen.getByTestId("InputInstructions").textContent).toBe(
      "Press Enter to apply3/3"
    )
  })

  describe("Chat type", () => {
    const props = getProps({
      type: "chat",
    })

    it("should not show instructions", () => {
      render(<InputInstructions {...props} />)
      expect(screen.getByTestId("InputInstructions").textContent).toBe("")
    })

    it("should show instructions for max length", () => {
      const props = getProps({
        type: "chat",
        maxLength: 3,
      })
      render(<InputInstructions {...props} />)

      expect(screen.getByText("3/3")).toBeVisible()
    })
  })

  describe("In Form", () => {
    it("should show correct instructions to submit form with single line input", () => {
      const props = getProps({
        inForm: true,
        type: "single",
      })
      render(<InputInstructions {...props} />)

      expect(screen.getByText("Press Enter to submit form")).toBeVisible()
    })

    it("should show correct instructions to submit form with multiline input", () => {
      const props = getProps({
        inForm: true,
        type: "multiline",
      })
      render(<InputInstructions {...props} />)

      expect(screen.getByText("Press ⌘+Enter to submit form")).toBeVisible()
    })

    it("should not show enter instructions if allowEnterToSubmit is false", () => {
      const props = getProps({
        inForm: true,
        allowEnterToSubmit: false,
      })
      render(<InputInstructions {...props} />)

      expect(screen.getByTestId("InputInstructions")).toHaveTextContent("")
    })
  })
})


================================================
File: /frontend/lib/src/components/shared/InputInstructions/InputInstructions.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { isFromMac } from "@streamlit/lib/src/util/utils"
import { StyledWidgetInstructions } from "@streamlit/lib/src/components/widgets/BaseWidget"

import { StyledMessage } from "./styled-components"

export interface Props {
  dirty: boolean
  value: string
  inForm: boolean
  maxLength?: number
  className?: string
  type?: "multiline" | "single" | "chat"
  allowEnterToSubmit?: boolean
}

const InputInstructions = ({
  dirty,
  value,
  inForm,
  maxLength,
  className,
  type = "single",
  allowEnterToSubmit = true,
}: Props): ReactElement => {
  const messages: ReactElement[] = []
  const addMessage = (text: string, shouldBlink = false): void => {
    messages.push(
      <StyledMessage
        key={messages.length}
        includeDot={messages.length > 0}
        shouldBlink={shouldBlink}
      >
        {text}
      </StyledMessage>
    )
  }

  // Show enter instruction if not a form or form allows Enter to submit
  if (allowEnterToSubmit) {
    const toSubmitFormOrApplyText = inForm ? "submit form" : "apply"
    if (type === "multiline") {
      const commandKey = isFromMac() ? "⌘" : "Ctrl"
      addMessage(`Press ${commandKey}+Enter to ${toSubmitFormOrApplyText}`)
    } else if (type === "single") {
      addMessage(`Press Enter to ${toSubmitFormOrApplyText}`)
    }
  }

  if (maxLength && (type !== "chat" || dirty)) {
    addMessage(
      `${value.length}/${maxLength}`,
      dirty && value.length >= maxLength
    )
  }

  return (
    <StyledWidgetInstructions
      data-testid="InputInstructions"
      className={className}
    >
      {messages}
    </StyledWidgetInstructions>
  )
}

export default InputInstructions


================================================
File: /frontend/lib/src/components/shared/InputInstructions/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { keyframes } from "@emotion/react"
import styled from "@emotion/styled"

const blink = keyframes`
  50% {
    color: rgba(0, 0, 0, 0);
  }
`

export interface StyledMessageProps {
  includeDot: boolean
  shouldBlink: boolean
}

export const StyledMessage = styled.span<StyledMessageProps>(
  ({ includeDot, shouldBlink, theme }) => ({
    ...(includeDot
      ? {
          "&::before": {
            opacity: 1,
            content: '"•"',
            animation: "none",
            color: theme.colors.gray,
            margin: `0 ${theme.spacing.twoXS}`,
          },
        }
      : {}),
    ...(shouldBlink
      ? {
          color: theme.colors.red,
          animationName: `${blink}`,
          animationDuration: "0.5s",
          animationIterationCount: 5,
        }
      : {}),
  })
)


================================================
File: /frontend/lib/src/components/shared/Modal/Modal.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { BaseProvider, LightTheme } from "baseui"
import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import Modal, { calculateModalSize } from "./Modal"

describe("Modal component", () => {
  it("renders without crashing", () => {
    render(
      <BaseProvider theme={LightTheme}>
        <Modal isOpen />
      </BaseProvider>
    )

    const modalElement = screen.getByTestId("stDialog")
    expect(modalElement).toBeInTheDocument()
    expect(modalElement).toHaveClass("stDialog")
  })
})
describe("calculateModalSize", () => {
  it("returns the default size when no size is provided", () => {
    const size = calculateModalSize(undefined)
    expect(size).toBe("default")
  })
  it("returns the auto size when passed size is 'auto'", () => {
    const size = calculateModalSize("auto")
    expect(size).toBe("auto")
  })
  it("calculated the size based on the spacaing and content width when size is 'full'", () => {
    const size = calculateModalSize("full", "100px", "100px")
    expect(size).toBe("calc(100px + 100px)")
  })
})


================================================
File: /frontend/lib/src/components/shared/Modal/Modal.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FunctionComponent, ReactElement, ReactNode } from "react"

import { useTheme } from "@emotion/react"
import {
  ModalProps,
  SIZE,
  Modal as UIModal,
  ModalBody as UIModalBody,
  ModalFooter as UIModalFooter,
  ModalHeader as UIModalHeader,
} from "baseui/modal"
import merge from "lodash/merge"

import BaseButton, {
  BaseButtonProps,
} from "@streamlit/lib/src/components/shared/BaseButton"
import { EmotionTheme } from "@streamlit/lib/src/theme"

import { StyledModalButton } from "./styled-components"

export interface ModalHeaderProps {
  children: ReactNode
}

function ModalHeader({ children }: Readonly<ModalHeaderProps>): ReactElement {
  const {
    genericFonts,
    fontSizes,
    spacing,
    fontWeights,
    lineHeights,
  }: EmotionTheme = useTheme()

  return (
    <UIModalHeader
      style={{
        marginTop: spacing.none,
        marginLeft: spacing.none,
        marginRight: spacing.none,
        marginBottom: spacing.none,
        paddingTop: spacing.twoXL,
        paddingRight: spacing.twoXL,
        paddingBottom: spacing.md,
        paddingLeft: spacing.twoXL,
        fontFamily: genericFonts.bodyFont,
        fontSize: fontSizes.xl,
        fontWeight: fontWeights.bold,
        margin: spacing.none,
        lineHeight: lineHeights.small,
        textTransform: "none",
        display: "flex",
        alignItems: "center",
        maxHeight: "80vh",
        flexDirection: "row",
      }}
    >
      {children}
    </UIModalHeader>
  )
}

export interface ModalBodyProps {
  children: ReactNode
}

function ModalBody({ children }: Readonly<ModalBodyProps>): ReactElement {
  const { colors, fontSizes, spacing }: EmotionTheme = useTheme()

  return (
    <UIModalBody
      style={{
        marginTop: spacing.none,
        marginLeft: spacing.none,
        marginRight: spacing.none,
        marginBottom: spacing.none,
        paddingTop: spacing.md,
        paddingRight: spacing.twoXL,
        paddingBottom: spacing.twoXL,
        paddingLeft: spacing.twoXL,
        color: colors.bodyText,
        fontSize: fontSizes.md,
      }}
    >
      {children}
    </UIModalBody>
  )
}

export interface ModalFooterProps {
  children: ReactNode
}

function ModalFooter({ children }: Readonly<ModalFooterProps>): ReactElement {
  const { spacing }: EmotionTheme = useTheme()

  return (
    <UIModalFooter
      style={{
        marginTop: spacing.none,
        marginLeft: spacing.none,
        marginRight: spacing.none,
        marginBottom: spacing.none,
        paddingTop: spacing.md,
        paddingRight: spacing.md,
        paddingBottom: spacing.md,
        paddingLeft: spacing.md,
      }}
    >
      <div>{children}</div>
    </UIModalFooter>
  )
}

const ModalButton: FunctionComponent<
  React.PropsWithChildren<BaseButtonProps>
> = buttonProps => (
  <StyledModalButton>
    <BaseButton {...buttonProps} />
  </StyledModalButton>
)

export type StreamlitModalProps = Omit<ModalProps, "size"> & {
  size?: "auto" | "default" | "full"
}

/**
 * Maps our own StreamlitModal size to the Baseweb Modal size or a calculated string.
 * This abstraction allows us later to swap the Baseweb Modal size without touching
 * the other components again.
 *
 * @param size the StreamlitModal size to be mapped
 * @param width the width of the modal if 'full' size is selected
 * @param padding the padding added to the modal if 'full' size is selected
 * @returns the Baseweb Modal comaptible size
 */
export function calculateModalSize(
  size: StreamlitModalProps["size"],
  width?: string,
  padding?: string
): ModalProps["size"] {
  if (size === "full" && width && padding) {
    // This is the same width incl. padding as the AppView container is using 704px (736px (= contentMaxWidth) - 32px padding).
    // The dialog's total left and right padding is 48px. So the dialog needs a total width of 752px (=704px + 48px).
    // The used calculation here makes the relation to the app content width more comprehendable than hardcoding.
    // Note that a Modal has max-width:100%, so it looks good on mobile independent of the calculated size here.
    const paddingDifferenceDialogAndAppView = padding // the dialog has 0.5rem more padding left and right => 1rem
    return `calc(${width} + ${paddingDifferenceDialogAndAppView})`
  } else if (size === "auto") {
    return SIZE.auto
  }

  return SIZE.default
}

function Modal(props: StreamlitModalProps): ReactElement {
  const { spacing, radii, colors, sizes }: EmotionTheme = useTheme()

  const defaultOverrides = {
    Root: {
      style: {
        background: colors.darkenedBgMix25,
      },
      props: {
        className: "stDialog",
        "data-testid": "stDialog",
      },
    },
    DialogContainer: {
      style: {
        alignItems: "start",
        paddingTop: spacing.threeXL,
      },
    },
    Dialog: {
      style: {
        borderBottomRightRadius: radii.xxl,
        borderBottomLeftRadius: radii.xxl,
        borderTopRightRadius: radii.xxl,
        borderTopLeftRadius: radii.xxl,
        // make sure the modal is not too small on mobile
        minWidth: sizes.minPopupWidth,
      },
    },
    Close: {
      style: {
        top: `calc(${spacing.twoXL} + .375rem)`, // Trying to center the button on the available space.
        right: spacing.twoXL,
      },
    },
  }

  const modalSize: ModalProps["size"] = calculateModalSize(
    props.size,
    sizes.contentMaxWidth,
    spacing.lg
  )
  const mergedOverrides = merge(defaultOverrides, props.overrides)
  const overridenProps = { ...props, size: modalSize }
  return <UIModal {...overridenProps} overrides={mergedOverrides} />
}

export default Modal
export { ModalHeader, ModalBody, ModalFooter, ModalButton }


================================================
File: /frontend/lib/src/components/shared/Modal/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export {
  default,
  ModalHeader,
  ModalBody,
  ModalFooter,
  ModalButton,
} from "./Modal"


================================================
File: /frontend/lib/src/components/shared/Modal/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledModalButton = styled.span(({ theme }) => ({
  marginRight: theme.spacing.twoXS,
}))


================================================
File: /frontend/lib/src/components/shared/Profiler/CircularBuffer.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { describe, expect, it } from "vitest"

import { CircularBuffer } from "./CircularBuffer"

describe("CircularBuffer", () => {
  it("should initialize with the correct size", () => {
    const buffer = new CircularBuffer<number>(3)
    expect(buffer.buffer.length).toBe(3)
  })

  it("should add elements to the buffer", () => {
    const buffer = new CircularBuffer<number>(3)
    buffer.push(1)
    buffer.push(2)
    buffer.push(3)
    expect(buffer.buffer).toEqual([1, 2, 3])
  })

  it("should overwrite elements when the buffer is full", () => {
    const buffer = new CircularBuffer<number>(3)
    buffer.push(1)
    buffer.push(2)
    buffer.push(3)
    buffer.push(4)
    expect(buffer.buffer).toEqual([4, 2, 3])
  })

  it("should correctly count total written entries", () => {
    const buffer = new CircularBuffer<number>(3)
    buffer.push(1)
    buffer.push(2)
    buffer.push(3)
    buffer.push(4)
    buffer.push(5)
    expect(buffer.totalWrittenEntries).toBe(5)
  })

  it("should handle different data types", () => {
    const buffer = new CircularBuffer<string>(2)
    buffer.push("a")
    buffer.push("b")
    buffer.push("c")
    expect(buffer.buffer).toEqual(["c", "b"])
  })
})


================================================
File: /frontend/lib/src/components/shared/Profiler/CircularBuffer.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * A circular buffer implementation.
 */
export class CircularBuffer<T> {
  private _buffer: T[]

  private _size: number

  private _index: number

  private _wrappedCount: number

  /**
   * Creates an instance of CircularBuffer.
   * @param {number} size - The size of the buffer.
   */
  constructor(size: number) {
    this._buffer = new Array(size)
    this._size = size
    this._index = 0
    this._wrappedCount = 0
  }

  /**
   * Adds a value to the buffer.
   * @param {T} value - The value to add to the buffer.
   */
  push(value: T): void {
    this._buffer[this._index] = value
    this._index = (this._index + 1) % this._size

    if (this._index === 0) {
      this._wrappedCount = this._wrappedCount + 1
    }
  }

  /**
   * Gets the current state of the buffer.
   * @returns {readonly T[]} The buffer array.
   */
  get buffer(): readonly T[] {
    return this._buffer
  }

  /**
   * Gets the total number of entries written to the buffer.
   * @returns {number} The total number of written entries.
   */
  get totalWrittenEntries(): number {
    return this._wrappedCount * this._size + this._index
  }
}


================================================
File: /frontend/lib/src/components/shared/Profiler/Profiler.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  FC,
  ProfilerOnRenderCallback,
  PropsWithChildren,
  Profiler as ReactProfiler,
} from "react"

import { CircularBuffer } from "./CircularBuffer"

export type ProfilerProps = PropsWithChildren<{
  /**
   * The unique ID of a Profiler.
   * Statically typed so we can enforce which profiles are being collected.
   */
  id: "Main" | "Sidebar" | "Bottom" | "Event"
}>

/**
 * Callback function for React Profiler that collects performance data and
 * writes it to the global `window.__streamlit_profiles__` object so that it can
 * be collected in our performance tests.
 */
const handleRender: ProfilerOnRenderCallback = (
  id,
  phase,
  actualDuration,
  baseDuration,
  startTime,
  commitTime
) => {
  window.__streamlit_profiles__ = window.__streamlit_profiles__ || {}

  window.__streamlit_profiles__[id] =
    window.__streamlit_profiles__[id] ||
    // Use a CircularBuffer to limit the number of profiles stored in memory to
    // prevent any potential memory leaks.
    // 1000 is an arbitrary number that should be enough to store more than
    // enough entries for debugging purposes without consuming too much memory.
    new CircularBuffer<(typeof window.__streamlit_profiles__)[string]>(1000)

  window.__streamlit_profiles__[id].push({
    phase,
    actualDuration,
    baseDuration,
    startTime,
    commitTime,
  })
}

/**
 * Programmatic profiler component that collects performance data from React
 * Profiler.
 *
 * Since the Profiling build of React is not used in production, this component
 * is only doing something meaningful in tests. Otherwise it is effectively a
 * no-op since the callback will never be called.
 */
export const Profiler: FC<ProfilerProps> = ({ id, children }) => {
  return (
    <ReactProfiler id={id} onRender={handleRender}>
      {children}
    </ReactProfiler>
  )
}


================================================
File: /frontend/lib/src/components/shared/Profiler/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { CircularBuffer } from "./CircularBuffer"
export { Profiler } from "./Profiler"


================================================
File: /frontend/lib/src/components/shared/ProgressBar/ProgressBar.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import ProgressBar from "./ProgressBar"

describe("ProgressBar component", () => {
  it("renders without crashing", () => {
    render(<ProgressBar value={50} width={100} />)

    const progressBarElement = screen.getByRole("progressbar")
    expect(progressBarElement).toBeInTheDocument()
  })

  it("sets the value correctly", () => {
    render(<ProgressBar value={75} width={100} />)
    const progressBarElement = screen.getByRole("progressbar")
    expect(progressBarElement).toHaveAttribute("aria-valuenow", "75")
  })
})


================================================
File: /frontend/lib/src/components/shared/ProgressBar/ProgressBar.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { useTheme } from "@emotion/react"
import {
  ProgressBarOverrides,
  ProgressBar as UIProgressBar,
} from "baseui/progress-bar"
import { mergeOverrides } from "baseui"
import { Overrides } from "baseui/overrides"

import { EmotionTheme, isPresetTheme } from "@streamlit/lib/src/theme"
import { LibContext } from "@streamlit/lib/src/components/core/LibContext"

export enum Size {
  EXTRASMALL = "xs",
  SMALL = "sm",
  MEDIUM = "md",
  LARGE = "lg",
  EXTRALARGE = "xl",
}

export interface ProgressBarProps {
  width?: number
  value: number
  overrides?: Overrides<any>
  size?: Size
}

function ProgressBar({
  value,
  width,
  size = Size.SMALL,
  overrides,
}: ProgressBarProps): ReactElement {
  const theme: EmotionTheme = useTheme()
  const heightMap = {
    xs: theme.spacing.twoXS,
    sm: theme.spacing.sm,
    md: theme.spacing.lg,
    lg: theme.spacing.xl,
    xl: theme.spacing.twoXL,
  }
  const { activeTheme } = React.useContext(LibContext)
  const usingCustomTheme = !isPresetTheme(activeTheme)
  const defaultOverrides: Overrides<ProgressBarOverrides> = {
    BarContainer: {
      style: {
        marginTop: theme.spacing.none,
        marginBottom: theme.spacing.none,
        marginRight: theme.spacing.none,
        marginLeft: theme.spacing.none,
      },
    },
    Bar: {
      style: ({ $theme }: { $theme: any }) => ({
        width: width ? width.toString() : undefined,
        marginTop: theme.spacing.none,
        marginBottom: theme.spacing.none,
        marginRight: theme.spacing.none,
        marginLeft: theme.spacing.none,
        height: heightMap[size],
        backgroundColor: $theme.colors.progressbarTrackFill,
        borderTopLeftRadius: theme.spacing.twoXS,
        borderTopRightRadius: theme.spacing.twoXS,
        borderBottomLeftRadius: theme.spacing.twoXS,
        borderBottomRightRadius: theme.spacing.twoXS,
      }),
    },
    BarProgress: {
      style: () => ({
        backgroundColor: usingCustomTheme
          ? theme.colors.primary
          : theme.colors.blue70,
        borderTopLeftRadius: theme.spacing.twoXS,
        borderTopRightRadius: theme.spacing.twoXS,
        borderBottomLeftRadius: theme.spacing.twoXS,
        borderBottomRightRadius: theme.spacing.twoXS,
      }),
    },
  }

  return (
    <UIProgressBar
      value={value}
      overrides={mergeOverrides(defaultOverrides, overrides)}
    />
  )
}

export default ProgressBar


================================================
File: /frontend/lib/src/components/shared/ProgressBar/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default, Size } from "./ProgressBar"


================================================
File: /frontend/lib/src/components/shared/Radio/Radio.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { LabelVisibilityOptions } from "@streamlit/lib/src/util/utils"

import Radio, { Props } from "./Radio"

const getProps = (props: Partial<Props> = {}): Props => ({
  width: 0,
  disabled: false,
  horizontal: false,
  value: 0,
  onChange: () => {},
  options: ["a", "b", "c"],
  captions: [],
  label: "Label",
  ...props,
})

describe("Radio widget", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<Radio {...props} />)
    const radioGroup = screen.getByRole("radiogroup")
    const radioOptions = screen.getAllByRole("radio")

    expect(radioGroup).toBeInTheDocument()
    expect(radioOptions).toHaveLength(3)
  })

  it("renders without crashing if no label is provided", () => {
    const props = getProps({ label: undefined })
    render(<Radio {...props} />)
    const widgetLabel = screen.queryByText("Label")
    const radioOptions = screen.getByRole("radiogroup")

    expect(widgetLabel).toBeNull()
    expect(radioOptions).toBeInTheDocument()
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when hidden", () => {
    const props = getProps({
      labelVisibility: LabelVisibilityOptions.Hidden,
    })
    render(<Radio {...props} />)

    const widgetLabel = screen.getByText("Label")
    expect(widgetLabel).toHaveStyle("visibility: hidden")
    expect(widgetLabel).not.toBeVisible()
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when collapsed", () => {
    const props = getProps({
      labelVisibility: LabelVisibilityOptions.Collapsed,
    })
    render(<Radio {...props} />)
    const widgetLabel = screen.getByText("Label")
    expect(widgetLabel).not.toBeVisible()
  })

  it("has correct className and style", () => {
    const props = getProps()
    render(<Radio {...props} />)
    const radioElement = screen.getByTestId("stRadio")

    expect(radioElement).toHaveClass("stRadio")
    expect(radioElement).toHaveStyle(`width: ${props.width}px`)
  })

  it("renders a label", () => {
    const props = getProps()
    render(<Radio {...props} />)
    const widgetLabel = screen.queryByText(`${props.label}`)

    expect(widgetLabel).toBeInTheDocument()
  })

  it("has a default value", () => {
    const props = getProps()
    render(<Radio {...props} />)
    const radioOptions = screen.getAllByRole("radio")
    expect(radioOptions).toHaveLength(3)

    // @ts-expect-error
    const checked = radioOptions[props.value]
    expect(checked).toBeChecked()
  })

  it("can be disabled", () => {
    const props = getProps({ disabled: true })
    render(<Radio {...props} />)
    const radioOptions = screen.getAllByRole("radio")

    radioOptions.forEach(option => {
      expect(option).toBeDisabled()
    })
  })

  it("has the correct options", () => {
    const props = getProps()
    render(<Radio {...props} />)

    props.options.forEach(option => {
      expect(screen.getByText(option)).toBeInTheDocument()
    })
  })

  it("doesn't render captions when there are none", () => {
    const props = getProps()
    render(<Radio {...props} />)

    expect(screen.queryAllByTestId("stCaptionContainer")).toHaveLength(0)
  })

  it("renders non-blank captions", () => {
    const props = getProps({ captions: ["caption1", "", "caption2"] })
    render(<Radio {...props} />)

    expect(screen.getAllByTestId("stCaptionContainer")).toHaveLength(3)

    expect(screen.getByText("caption1")).toBeInTheDocument()
    expect(screen.getByText("caption2")).toBeInTheDocument()
  })

  it("has the correct captions", () => {
    const props = getProps({ captions: ["caption1", "caption2", "caption3"] })
    render(<Radio {...props} />)

    expect(screen.getAllByTestId("stCaptionContainer")).toHaveLength(3)

    props.captions.forEach(caption => {
      expect(screen.getByText(caption)).toBeInTheDocument()
    })
  })

  it("shows a message when there are no options to be shown", () => {
    const props = getProps({ options: [] })
    render(<Radio {...props} />)
    const radioOptions = screen.getAllByRole("radio")
    const noOptionLabel = screen.getByText("No options to select.")

    expect(radioOptions).toHaveLength(1)
    expect(noOptionLabel).toBeInTheDocument()
  })

  it("handles value changes", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<Radio {...props} />)
    const radioOptions = screen.getAllByRole("radio")

    const secondOption = radioOptions[1]

    await user.click(secondOption)

    expect(secondOption).toBeChecked()
  })
})


================================================
File: /frontend/lib/src/components/shared/Radio/Radio.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  memo,
  ReactElement,
  useCallback,
  useEffect,
  useState,
} from "react"

import { useTheme } from "@emotion/react"
import { ALIGN, RadioGroup, Radio as UIRadio } from "baseui/radio"

import {
  StyledWidgetLabelHelpInline,
  WidgetLabel,
} from "@streamlit/lib/src/components/widgets/BaseWidget"
import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import { LabelVisibilityOptions } from "@streamlit/lib/src/util/utils"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown/StreamlitMarkdown"

export interface Props {
  disabled: boolean
  horizontal: boolean
  width?: number
  value: number | null
  onChange: (selectedIndex: number) => any
  options: any[]
  captions: any[]
  label?: string
  labelVisibility?: LabelVisibilityOptions
  help?: string
}

function Radio({
  disabled,
  horizontal,
  width,
  value: defaultValue,
  onChange,
  options,
  captions,
  label,
  labelVisibility,
  help,
}: Readonly<Props>): ReactElement {
  const [value, setValue] = useState(defaultValue ?? null)

  useEffect(() => {
    if (defaultValue === value) {
      return
    }

    setValue(defaultValue ?? null)

    // Exclude value from the dependency list on purpose to avoid a loop.
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    /* eslint-disable react-hooks/exhaustive-deps */
  }, [defaultValue])

  const onChangeCallback = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>): void => {
      const selectedIndex = parseInt(e.target.value, 10)
      setValue(selectedIndex)
      onChange(selectedIndex) // Needs to happen later, no?
    },
    [onChange]
  )

  const theme = useTheme()
  const { colors, radii } = theme
  const style = { width }
  const hasCaptions = captions.length > 0
  const hasOptions = options.length > 0
  const cleanedOptions = hasOptions ? options : ["No options to select."]

  // Either the user specified it as disabled or it's disabled because we don't have any options
  const shouldDisable = disabled || !hasOptions

  const spacerNeeded = (caption: string): string => {
    // When captions are provided for only some options in horizontal
    // layout we need to add a spacer for the options without captions
    const spacer = caption == "" && horizontal && hasCaptions
    return spacer ? "&nbsp;" : caption
  }

  return (
    <div className="stRadio" data-testid="stRadio" style={style}>
      <WidgetLabel
        label={label}
        disabled={shouldDisable}
        labelVisibility={labelVisibility}
      >
        {help && (
          <StyledWidgetLabelHelpInline>
            <TooltipIcon content={help} placement={Placement.TOP_RIGHT} />
          </StyledWidgetLabelHelpInline>
        )}
      </WidgetLabel>
      <RadioGroup
        onChange={onChangeCallback}
        value={value !== null ? value.toString() : undefined}
        disabled={shouldDisable}
        align={horizontal ? ALIGN.horizontal : ALIGN.vertical}
        aria-label={label}
        data-testid="stRadioGroup"
        overrides={{
          RadioGroupRoot: {
            style: {
              gap: hasCaptions ? theme.spacing.sm : theme.spacing.none,
              minHeight: theme.sizes.minElementHeight,
            },
          },
        }}
      >
        {cleanedOptions.map((option: string, index: number) => (
          <UIRadio
            key={index}
            value={index.toString()}
            overrides={{
              Root: {
                style: ({
                  $isFocusVisible,
                }: {
                  $isFocusVisible: boolean
                }) => ({
                  marginBottom: theme.spacing.none,
                  marginTop: theme.spacing.none,
                  marginRight: hasCaptions
                    ? theme.spacing.sm
                    : theme.spacing.lg,
                  // Make left and right padding look the same visually.
                  paddingLeft: theme.spacing.none,
                  alignItems: "start",
                  paddingRight: theme.spacing.threeXS,
                  backgroundColor: $isFocusVisible
                    ? colors.darkenedBgMix25
                    : "",
                  borderTopLeftRadius: radii.md,
                  borderTopRightRadius: radii.md,
                  borderBottomLeftRadius: radii.md,
                  borderBottomRightRadius: radii.md,
                }),
              },
              RadioMarkOuter: {
                style: ({ $checked }: { $checked: boolean }) => ({
                  width: theme.sizes.checkbox,
                  height: theme.sizes.checkbox,
                  // The margin top is needed to align the radio buttons
                  // with the text label baseline.
                  // The text label has a line-height of 1.6
                  // making the font height around 1.6rem
                  // while the radio icon has a height of 1rem.
                  //eslint-disable-next-line streamlit-custom/no-hardcoded-theme-values
                  marginTop: "0.35rem",
                  marginRight: theme.spacing.none,
                  marginLeft: theme.spacing.none,
                  backgroundColor:
                    $checked && !shouldDisable
                      ? colors.primary
                      : colors.fadedText40,
                }),
              },
              RadioMarkInner: {
                style: ({ $checked }: { $checked: boolean }) => ({
                  // If checked, it should fill 37.5% of the total radio size.
                  // if not checked, show a border of spacing.threeXS.
                  height: $checked
                    ? "37.5%"
                    : `calc(${theme.sizes.checkbox} - ${theme.spacing.threeXS})`,
                  width: $checked
                    ? "37.5%"
                    : `calc(${theme.sizes.checkbox} - ${theme.spacing.threeXS})`,
                }),
              },
              Label: {
                style: {
                  color: shouldDisable ? colors.fadedText40 : colors.bodyText,
                  position: "relative",
                  top: theme.spacing.px,
                },
              },
            }}
          >
            <StreamlitMarkdown
              source={option}
              allowHTML={false}
              isLabel
              largerLabel
            />
            {hasCaptions && (
              <StreamlitMarkdown
                source={spacerNeeded(captions[index])}
                allowHTML={false}
                isCaption
                isLabel
              />
            )}
          </UIRadio>
        ))}
      </RadioGroup>
    </div>
  )
}

export default memo(Radio)


================================================
File: /frontend/lib/src/components/shared/Radio/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Radio"


================================================
File: /frontend/lib/src/components/shared/StreamlitMarkdown/Heading.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { Heading as HeadingProto } from "@streamlit/lib/src/proto"
import IsDialogContext from "@streamlit/lib/src/components/core/IsDialogContext"
import IsSidebarContext from "@streamlit/lib/src/components/core/IsSidebarContext"

import Heading, { HeadingProtoProps } from "./Heading"

const getHeadingProps = (
  elementProps: Partial<HeadingProto> = {}
): HeadingProtoProps => ({
  width: 300,
  element: HeadingProto.create({
    anchor: "some-anchor",
    tag: "h1",
    body: `hello world
             this is a new line`,
    ...elementProps,
  }),
})

describe("Heading", () => {
  it("renders properly after a new line", () => {
    const props = getHeadingProps()
    render(<Heading {...props} />)

    const heading = screen.getByRole("heading")
    expect(heading).toHaveTextContent("hello world")
    expect(heading).not.toHaveTextContent("this is a new line")
    expect(screen.getByText("this is a new line")).toBeInTheDocument()
    expect(screen.getAllByTestId("stMarkdownContainer")).toHaveLength(1)

    const headingElement = screen.getByTestId("stHeading")
    expect(headingElement).toHaveClass("stHeading")
  })

  it("renders properly without a new line", () => {
    const props = getHeadingProps({ body: "hello" })
    render(<Heading {...props} />)

    expect(screen.getByRole("heading")).toHaveTextContent("hello")
    expect(screen.getAllByTestId("stMarkdownContainer")).toHaveLength(1)
  })

  it("renders anchor link", () => {
    const props = getHeadingProps({ body: "hello" })
    render(<Heading {...props} />)

    // trying to trigger the :hover css state did not work, so using 'hidden: true' here. We have an e2e test to check the hovering.
    const link = screen.getByRole("link", { hidden: true })
    expect(link).toHaveAttribute("href", "#some-anchor")
  })

  it("does not render anchor link when it is hidden", () => {
    const props = getHeadingProps({ body: "hello", hideAnchor: true })
    render(<Heading {...props} />)

    expect(screen.queryByRole("link")).not.toBeInTheDocument()
  })

  it("does not render anchor link in sidebar", () => {
    const props = getHeadingProps()
    render(
      <IsSidebarContext.Provider value={true}>
        <Heading {...props} />
      </IsSidebarContext.Provider>
    )
    expect(screen.queryByRole("link")).not.toBeInTheDocument()
  })

  it("does not render anchor link in dialog", () => {
    const props = getHeadingProps()
    render(
      <IsDialogContext.Provider value={true}>
        <Heading {...props} />
      </IsDialogContext.Provider>
    )
    expect(screen.queryByRole("link")).not.toBeInTheDocument()
  })

  it("renders properly with help text", () => {
    const props = getHeadingProps({ body: "hello", help: "help text" })
    render(<Heading {...props} />)

    expect(screen.getByRole("heading")).toHaveTextContent("hello")
    expect(screen.getAllByTestId("stMarkdownContainer")).toHaveLength(1)

    const tooltip = screen.getByTestId("stTooltipIcon")
    expect(tooltip).toBeInTheDocument()
  })

  it("renders properly with help text in sidebar", () => {
    const props = getHeadingProps({ body: "hello", help: "help text" })
    render(
      <IsSidebarContext.Provider value={true}>
        <Heading {...props} />
      </IsSidebarContext.Provider>
    )

    expect(screen.getByRole("heading")).toHaveTextContent("hello")
    expect(screen.getAllByTestId("stMarkdownContainer")).toHaveLength(1)

    const tooltip = screen.getByTestId("stTooltipIcon")
    expect(tooltip).toBeInTheDocument()
  })

  it("renders properly with help text in dialog", () => {
    const props = getHeadingProps({ body: "hello", help: "help text" })
    render(
      <IsDialogContext.Provider value={true}>
        <Heading {...props} />
      </IsDialogContext.Provider>
    )

    expect(screen.getByRole("heading")).toHaveTextContent("hello")
    expect(screen.getAllByTestId("stMarkdownContainer")).toHaveLength(1)

    const tooltip = screen.getByTestId("stTooltipIcon")
    expect(tooltip).toBeInTheDocument()
  })

  it("does not render ol block", () => {
    const props = getHeadingProps({ body: "1) hello" })
    render(<Heading {...props} />)

    expect(screen.getByRole("heading")).toHaveTextContent("1) hello")
    expect(screen.queryByRole("list")).not.toBeInTheDocument()
  })

  it("does not render ul block", () => {
    const props = getHeadingProps({ body: "* hello" })
    render(<Heading {...props} />)

    expect(screen.getByRole("heading")).toHaveTextContent("* hello")
    expect(screen.queryByRole("list")).not.toBeInTheDocument()
  })

  it("does not render blockquote with >", () => {
    const props = getHeadingProps({ body: ">hello" })
    render(<Heading {...props} />)

    expect(screen.getByRole("heading")).toHaveTextContent(">hello")
    expect(screen.queryByRole("blockquote")).not.toBeInTheDocument()
  })

  it("does not render tables", () => {
    const props = getHeadingProps({
      body: `| Syntax | Description |
           | ----------- | ----------- |
           | Header      | Title       |
           | Paragraph   | Text        |`,
    })
    render(<Heading {...props} />)

    expect(screen.getByTestId("stMarkdownContainer")).toHaveTextContent(
      "| Syntax | Description || ----------- | ----------- | | Header | Title | | Paragraph | Text |"
    )
    expect(screen.getByRole("heading")).toHaveTextContent(
      `| Syntax | Description |`
    )
    expect(screen.queryByRole("table")).not.toBeInTheDocument()
    expect(screen.getAllByTestId("stMarkdownContainer")).toHaveLength(1)
  })

  it("renders no divider by default", () => {
    const props = getHeadingProps()
    render(<Heading {...props} />)

    expect(screen.queryByTestId("stHeadingDivider")).not.toBeInTheDocument()
  })

  it("renders a divider with given color", () => {
    // correct divider color mapping handled in Block.tsx
    const props = getHeadingProps({ divider: "#0068c9" })
    render(<Heading {...props} />)

    const divider = screen.getByTestId("stHeadingDivider")
    expect(divider).toBeInTheDocument()
    expect(divider).toHaveStyle("background-color: #0068c9")
  })
})


================================================
File: /frontend/lib/src/components/shared/StreamlitMarkdown/Heading.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { Fragment, ReactElement } from "react"

import { Heading as HeadingProto } from "@streamlit/lib/src/proto"
import IsSidebarContext from "@streamlit/lib/src/components/core/IsSidebarContext"
import IsDialogContext from "@streamlit/lib/src/components/core/IsDialogContext"

import {
  StyledHeaderDivider,
  StyledStreamlitMarkdown,
} from "./styled-components"
import "katex/dist/katex.min.css"
import {
  HeadingWithActionElements,
  RenderedMarkdown,
  Tags,
} from "./StreamlitMarkdown"

export interface HeadingProtoProps {
  width: number
  element: HeadingProto
}

function makeMarkdownHeading(tag: string, markdown: string): string {
  switch (tag.toLowerCase()) {
    case Tags.H1: {
      return `# ${markdown}`
    }
    case Tags.H2: {
      return `## ${markdown}`
    }
    case Tags.H3: {
      return `### ${markdown}`
    }
    default: {
      throw new Error(`Unrecognized tag for header: ${tag}`)
    }
  }
}

function Heading(props: HeadingProtoProps): ReactElement {
  const { width, element } = props
  const { tag, anchor, body, help, hideAnchor, divider } = element
  const isInSidebar = React.useContext(IsSidebarContext)
  const isInDialog = React.useContext(IsDialogContext)
  // st.header can contain new lines which are just interpreted as new
  // markdown to be rendered as such.
  const [heading, ...rest] = body.split("\n")

  return (
    <div style={{ width }} className="stHeading" data-testid="stHeading">
      <StyledStreamlitMarkdown
        isCaption={Boolean(false)}
        isInSidebarOrDialog={isInSidebar || isInDialog}
        style={{ width }}
        data-testid="stMarkdownContainer"
      >
        <HeadingWithActionElements
          anchor={anchor}
          help={help}
          hideAnchor={hideAnchor}
          tag={tag}
        >
          <RenderedMarkdown
            allowHTML={false}
            source={makeMarkdownHeading(tag, heading)}
            // this is purely an inline string
            overrideComponents={{
              p: Fragment,
              h1: Fragment,
              h2: Fragment,
              h3: Fragment,
              h4: Fragment,
              h5: Fragment,
              h6: Fragment,
            }}
          />
        </HeadingWithActionElements>
        {/* Only the first line of the body is used as a heading, the remaining text is added as regular mardkown below. */}
        {rest.length > 0 && (
          <RenderedMarkdown source={rest.join("\n")} allowHTML={false} />
        )}
      </StyledStreamlitMarkdown>
      {divider && (
        <StyledHeaderDivider
          data-testid="stHeadingDivider"
          rainbow={divider.includes("linear")}
          color={divider}
        />
      )}
    </div>
  )
}

export default Heading


================================================
File: /frontend/lib/src/components/shared/StreamlitMarkdown/StreamlitMarkdown.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import ReactMarkdown from "react-markdown"
// eslint-disable-next-line testing-library/no-manual-cleanup
import { cleanup, screen } from "@testing-library/react"
import { transparentize } from "color2k"

import { render } from "@streamlit/lib/src/test_util"
import IsSidebarContext from "@streamlit/lib/src/components/core/IsSidebarContext"
import { colors } from "@streamlit/lib/src/theme/primitives/colors"
import IsDialogContext from "@streamlit/lib/src/components/core/IsDialogContext"

import StreamlitMarkdown, {
  createAnchorFromText,
  CustomCodeTag,
  CustomCodeTagProps,
  CustomPreTag,
  LinkWithTargetBlank,
} from "./StreamlitMarkdown"

// Fixture Generator
const getMarkdownElement = (body: string): ReactElement => {
  const components = {
    a: LinkWithTargetBlank,
  }
  return <ReactMarkdown components={components}>{body}</ReactMarkdown>
}

describe("createAnchorFromText", () => {
  it("generates slugs correctly", () => {
    const cases = [
      ["some header", "some-header"],
      ["some -24$35-9824  header", "some-24-35-9824-header"],
      ["blah___blah___blah", "blah-blah-blah"],
    ]

    cases.forEach(([s, want]) => {
      expect(createAnchorFromText(s)).toEqual(want)
    })
  })
})

describe("linkReference", () => {
  it("renders a link with _blank target", () => {
    const body = "Some random URL like [Streamlit](https://streamlit.io/)"
    render(getMarkdownElement(body))
    expect(screen.getByText("Streamlit")).toHaveAttribute(
      "href",
      "https://streamlit.io/"
    )
    expect(screen.getByText("Streamlit")).toHaveAttribute("target", "_blank")
  })

  it("renders a link without title", () => {
    const body =
      "Everybody loves [The Internet Archive](https://archive.org/)."
    render(getMarkdownElement(body))
    const link = screen.getByText("The Internet Archive")
    expect(link).toHaveAttribute("href", "https://archive.org/")
    expect(link).not.toHaveAttribute("title")
  })

  it("renders a link containing a title", () => {
    const body =
      "My favorite search engine is " +
      '[Duck Duck Go](https://duckduckgo.com/ "The best search engine for privacy").'
    render(getMarkdownElement(body))
    const link = screen.getByText("Duck Duck Go")
    expect(link).toHaveAttribute("href", "https://duckduckgo.com/")
    expect(link).toHaveAttribute("title", "The best search engine for privacy")
  })

  it("renders a link containing parentheses", () => {
    const body =
      "Here's a link containing parentheses [Yikes](http://msdn.microsoft.com/en-us/library/aa752574(VS.85).aspx)"
    render(getMarkdownElement(body))
    const link = screen.getByText("Yikes")
    expect(link instanceof HTMLAnchorElement).toBe(true)
    expect(link).toHaveAttribute(
      "href",
      "http://msdn.microsoft.com/en-us/library/aa752574(VS.85).aspx"
    )
  })

  it("does not render a link if only [text] and no (href)", () => {
    const body = "Don't convert to a link if only [text] and missing (href)"
    render(getMarkdownElement(body))
    const element = screen.getByText("text", { exact: false })
    expect(element).toHaveTextContent(
      "Don't convert to a link if only [text] and missing (href)"
    )
    expect(element instanceof HTMLAnchorElement).toBe(false)
  })
})

describe("StreamlitMarkdown", () => {
  it("renders header anchors when isInSidebar is false", () => {
    const source = "# header"
    render(
      <IsSidebarContext.Provider value={false}>
        <StreamlitMarkdown source={source} allowHTML={false} />
      </IsSidebarContext.Provider>
    )
    expect(
      screen.getByTestId("stHeadingWithActionElements")
    ).toBeInTheDocument()
  })

  it("renders header anchors when isInDialog is false", () => {
    const source = "# header"
    render(
      <IsDialogContext.Provider value={false}>
        <StreamlitMarkdown source={source} allowHTML={false} />
      </IsDialogContext.Provider>
    )
    expect(
      screen.getByTestId("stHeadingWithActionElements")
    ).toBeInTheDocument()
  })

  it("passes props properly", () => {
    const source =
      "<a class='nav_item' href='//0.0.0.0:8501/?p=some_page' target='_self'>Some Page</a>"
    render(<StreamlitMarkdown source={source} allowHTML={true} />)
    expect(screen.getByText("Some Page")).toHaveAttribute(
      "href",
      "//0.0.0.0:8501/?p=some_page"
    )
    expect(screen.getByText("Some Page")).toHaveAttribute("target", "_self")
  })

  it("doesn't render header anchors when isInSidebar is true", () => {
    const source = "# header"
    render(
      <IsSidebarContext.Provider value={true}>
        <StreamlitMarkdown source={source} allowHTML={false} />
      </IsSidebarContext.Provider>
    )
    expect(
      screen.queryByTestId("stHeadingWithActionElements")
    ).not.toBeInTheDocument()
  })

  it("doesn't render header anchors when isInDialog is true", () => {
    const source = "# header"
    render(
      <IsDialogContext.Provider value={true}>
        <StreamlitMarkdown source={source} allowHTML={false} />
      </IsDialogContext.Provider>
    )
    expect(
      screen.queryByTestId("stHeadingWithActionElements")
    ).not.toBeInTheDocument()
  })

  it("propagates header attributes to custom header", () => {
    const source = '<h1 data-test="lol">alsdkjhflaf</h1>'
    render(<StreamlitMarkdown source={source} allowHTML />)
    const h1 = screen.getByRole("heading")
    expect(h1).toHaveAttribute("data-test", "lol")
  })

  it("displays captions correctly", () => {
    const source = "hello this is a caption"
    render(<StreamlitMarkdown allowHTML={false} source={source} isCaption />)
    const caption = screen.getByTestId("stCaptionContainer")
    expect(caption).toHaveTextContent("hello this is a caption")
  })

  // Valid Markdown - italics, bold, strikethrough, code, links, emojis, shortcodes
  const validCases = [
    { input: "*Italicized Text*", tag: "em", expected: "Italicized Text" },
    { input: "**Bold Text**", tag: "strong", expected: "Bold Text" },
    {
      input: "~Strikethough Text~",
      tag: "del",
      expected: "Strikethough Text",
    },
    { input: "`Code Block`", tag: "code", expected: "Code Block" },
    { input: "[Link Text](www.example.com)", tag: "a", expected: "Link Text" },
    { input: "🐶", tag: "p", expected: "🐶" },
    { input: ":joy:", tag: "p", expected: "😂" },
    { input: ":material/search:", tag: "span", expected: "search" },
  ]

  test.each(validCases)(
    "renders valid markdown when isLabel is true - $tag",
    ({ input, tag, expected }) => {
      render(<StreamlitMarkdown source={input} allowHTML={false} isLabel />)
      const markdownText = screen.getByText(expected)
      expect(markdownText).toBeInTheDocument()

      const expectedTag = markdownText.nodeName.toLowerCase()
      expect(expectedTag).toEqual(tag)

      // Removes rendered StreamlitMarkdown component before next case run
      cleanup()
    }
  )

  it("renders streamlit logo in markdown when isLabel is true", () => {
    render(
      <StreamlitMarkdown source={":streamlit:"} allowHTML={false} isLabel />
    )
    const image = screen.getByRole("img")
    expect(image).toHaveAttribute("alt", "Streamlit logo")
    expect(image).toHaveAttribute(
      "src",
      expect.stringContaining("streamlit-mark-color")
    )
  })

  // Typographical symbol replacements
  const symbolReplacementCases = [
    { input: "a -> b", tag: "p", expected: "a → b" },
    { input: "a <- b", tag: "p", expected: "a ← b" },
    { input: "a <-> b", tag: "p", expected: "a ↔ b" },
    { input: "a -- b", tag: "p", expected: "a — b" },
    { input: "a >= b", tag: "p", expected: "a ≥ b" },
    { input: "a <= b", tag: "p", expected: "a ≤ b" },
    { input: "a ~= b", tag: "p", expected: "a ≈ b" },
    {
      input: "[Link ->](https://example.com/arrow->)",
      tag: "a",
      expected: "Link ->",
    },
    { input: "`Code ->`", tag: "code", expected: "Code ->" },
  ]

  test.each(symbolReplacementCases)(
    "replaces symbols with nicer typographical symbols - $input",
    ({ input, tag, expected }) => {
      render(<StreamlitMarkdown source={input} allowHTML={false} isLabel />)
      const markdownText = screen.getByText(expected)
      expect(markdownText).toBeInTheDocument()

      const expectedTag = markdownText.nodeName.toLowerCase()
      expect(expectedTag).toEqual(tag)

      // Removes rendered StreamlitMarkdown component before next case run
      cleanup()
    }
  )

  // Invalid Markdown - images, table elements, headings, unordered/ordered lists, task lists, horizontal rules, & blockquotes
  const table = `| Syntax | Description |
  | ----------- | ----------- |
  | Header      | Title       |
  | Paragraph   | Text        |`
  const tableText = "Syntax Description Header Title Paragraph Text"
  const horizontalRule = `

  ---

  Horizontal rule
  `

  const invalidCases = [
    { input: table, tag: "table", expected: tableText },
    { input: table, tag: "thead", expected: tableText },
    { input: table, tag: "tbody", expected: tableText },
    { input: table, tag: "tr", expected: tableText },
    { input: table, tag: "th", expected: tableText },
    { input: table, tag: "td", expected: tableText },
    { input: "# Heading 1", tag: "h1", expected: "Heading 1" },
    { input: "## Heading 2", tag: "h2", expected: "Heading 2" },
    { input: "### Heading 3", tag: "h3", expected: "Heading 3" },
    { input: "#### Heading 4", tag: "h4", expected: "Heading 4" },
    { input: "##### Heading 5", tag: "h5", expected: "Heading 5" },
    { input: "###### Heading 6", tag: "h6", expected: "Heading 6" },
    { input: "- List Item 1", tag: "ul", expected: "List Item 1" },
    { input: "- List Item 1", tag: "li", expected: "List Item 1" },
    { input: "1. List Item 1", tag: "ol", expected: "List Item 1" },
    { input: "1. List Item 1", tag: "li", expected: "List Item 1" },
    {
      input: "- [ ] Task List Item 1",
      tag: "input",
      expected: "Task List Item 1",
    },
    { input: horizontalRule, tag: "hr", expected: "Horizontal rule" },
    { input: "> Blockquote", tag: "blockquote", expected: "Blockquote" },
  ]

  test.each(invalidCases)(
    "does NOT render invalid markdown when isLabel is true - $tag",
    ({ input, tag, expected }) => {
      render(<StreamlitMarkdown source={input} allowHTML={false} isLabel />)
      const markdownText = screen.getByText(expected)
      expect(markdownText).toBeInTheDocument()

      const expectedTag = markdownText.nodeName.toLowerCase()
      expect(expectedTag).not.toEqual(tag)

      // Removes rendered StreamlitMarkdown component before next case run
      cleanup()
    }
  )

  it("doesn't render links when disableLinks is true", () => {
    // Valid markdown further restricted with buttons to eliminate links
    const source = "[Link text](www.example.com)"
    render(
      <StreamlitMarkdown
        source={source}
        allowHTML={false}
        isLabel
        disableLinks
      />
    )
    const tag = screen.getByText("Link text")
    expect(tag instanceof HTMLAnchorElement).toBe(false)
  })

  it("renders smaller text sizing when isToast is true", () => {
    const source = "Here is some toast text"
    render(<StreamlitMarkdown source={source} allowHTML={false} isToast />)

    const textTag = screen.getByText("Here is some toast text")
    expect(textTag).toBeInTheDocument()

    // Use the smaller font size for the markdown container
    const markdownContainer = screen.getByTestId("stMarkdownContainer")
    expect(markdownContainer).toHaveStyle("font-size: 14px")
  })

  it("renders regular text sizing when largerLabel is true", () => {
    const source = "Here is some checkbox label text"
    render(
      <StreamlitMarkdown
        source={source}
        allowHTML={false}
        isLabel
        largerLabel
      />
    )

    const textTag = screen.getByText("Here is some checkbox label text")
    expect(textTag).toHaveStyle("font-size: inherit")
  })

  it("renders bold label text when boldLabel is true", () => {
    const source = "Here is some checkbox label text"
    render(
      <StreamlitMarkdown
        source={source}
        allowHTML={false}
        isLabel
        boldLabel
        largerLabel
      />
    )

    const textTag = screen.getByText("Here is some checkbox label text")
    expect(textTag).toHaveStyle("font-weight: 600")
  })

  it("colours text properly", () => {
    const colorMapping = new Map([
      ["red", colors.red80],
      ["blue", colors.blue80],
      ["green", colors.green90],
      ["violet", colors.purple80],
      ["orange", colors.orange100],
      ["gray", colors.gray80],
      ["grey", colors.gray80],
      ["rainbow", "rgba(0, 0, 0, 0)"],
    ])

    colorMapping.forEach(function (style, color) {
      const source = `:${color}[text]`
      render(<StreamlitMarkdown source={source} allowHTML={false} />)
      const markdown = screen.getByText("text")
      const tagName = markdown.nodeName.toLowerCase()
      expect(tagName).toBe("span")
      expect(markdown).toHaveStyle(`color: ${style}`)

      // Removes rendered StreamlitMarkdown component before next case run
      cleanup()
    })
  })

  it("properly adds custom material icon", () => {
    const source = `:material/search: Icon`
    render(<StreamlitMarkdown source={source} allowHTML={false} />)
    const markdown = screen.getByText("search")
    const tagName = markdown.nodeName.toLowerCase()
    expect(tagName).toBe("span")
    expect(markdown).toHaveStyle(`font-family: Material Symbols Rounded`)
    expect(markdown).toHaveStyle(`user-select: none`)
    expect(markdown).toHaveStyle(`vertical-align: bottom`)
  })

  it("does not remove unknown directive", () => {
    const source = `test :foo test:test :`
    render(<StreamlitMarkdown source={source} allowHTML={false} />)
    const markdown = screen.getByText("test :foo test:test :")
    expect(markdown).toBeInTheDocument()
  })

  it("properly adds background colors", () => {
    const redbg = transparentize(colors.red80, 0.9)
    const orangebg = transparentize(colors.yellow70, 0.9)
    const greenbg = transparentize(colors.green70, 0.9)
    const bluebg = transparentize(colors.blue70, 0.9)
    const violetbg = transparentize(colors.purple70, 0.9)
    const graybg = transparentize(colors.gray70, 0.9)

    const colorMapping = new Map([
      ["red", redbg],
      ["blue", bluebg],
      ["green", greenbg],
      ["violet", violetbg],
      ["orange", orangebg],
      ["gray", graybg],
      ["grey", graybg],
    ])

    colorMapping.forEach(function (style, color) {
      const source = `:${color}-background[text]`
      render(<StreamlitMarkdown source={source} allowHTML={false} />)
      const markdown = screen.getByText("text")
      const tagName = markdown.nodeName.toLowerCase()
      expect(tagName).toBe("span")
      expect(markdown).toHaveStyle(`background-color: ${style}`)

      // Removes rendered StreamlitMarkdown component before next case run
      cleanup()
    })
  })

  it("properly adds rainbow background color", () => {
    const redbg = transparentize(colors.red80, 0.9)
    const orangebg = transparentize(colors.yellow70, 0.9)
    const yellowbg = transparentize(colors.yellow70, 0.9)
    const greenbg = transparentize(colors.green70, 0.9)
    const bluebg = transparentize(colors.blue70, 0.9)
    const violetbg = transparentize(colors.purple70, 0.9)
    const purplebg = transparentize(colors.purple90, 0.9)

    const colorMapping = new Map([
      [
        "rainbow",
        `linear-gradient(to right, ${redbg}, ${orangebg}, ${yellowbg}, ${greenbg}, ${bluebg}, ${violetbg}, ${purplebg})`,
      ],
    ])

    colorMapping.forEach(function (style, color) {
      const source = `:${color}-background[text]`
      render(<StreamlitMarkdown source={source} allowHTML={false} />)
      const markdown = screen.getByText("text")
      const tagName = markdown.nodeName.toLowerCase()
      expect(tagName).toBe("span")
      expect(markdown).toHaveStyle(`background: ${style}`)

      // Removes rendered StreamlitMarkdown component before next case run
      cleanup()
    })
  })
})

const getCustomCodeTagProps = (
  props: Partial<CustomCodeTagProps> = {}
): CustomCodeTagProps => ({
  children: [
    `import streamlit as st

st.write("Hello")
`,
  ],
  node: { type: "element", tagName: "tagName", children: [] },
  ...props,
})

describe("CustomCodeTag Element", () => {
  it("should render without crashing", () => {
    const props = getCustomCodeTagProps()
    render(<CustomCodeTag {...props} />)

    const stCode = screen.getByTestId("stCode")
    expect(stCode).toBeInTheDocument()
  })

  it("should render as plaintext", () => {
    const props = getCustomCodeTagProps({ className: "language-plaintext" })
    render(<CustomCodeTag {...props} />)

    const stCode = screen.getByTestId("stCode")
    expect(stCode.innerHTML.indexOf(`class="language-plaintext"`)).not.toBe(-1)
  })

  it("should render copy button when code block has content", () => {
    const props = getCustomCodeTagProps({
      children: ["i am not empty"],
    })
    render(<CustomCodeTag {...props} />)
    const copyButton = screen.getByTitle("Copy to clipboard")

    expect(copyButton).not.toBeNull()
  })

  it("should not render copy button when code block is empty", () => {
    const props = getCustomCodeTagProps({
      children: [""],
    })
    render(<CustomCodeTag {...props} />)
    // queryBy returns null vs. error
    const copyButton = screen.queryByRole("button") // eslint-disable-line testing-library/prefer-presence-queries

    expect(copyButton).toBeNull()
  })

  it("should render inline", () => {
    const props = getCustomCodeTagProps({ inline: true })
    const { baseElement } = render(<CustomCodeTag {...props} />)
    const codeWithoutClass = baseElement.innerHTML.replace(
      /class="(.*)"/,
      'class="foo"'
    )

    expect(codeWithoutClass).toBe(
      '<div><code class="foo">' +
        "import streamlit as st\n\n" +
        'st.write("Hello")\n' +
        "</code></div>"
    )
  })
})

describe("CustomPreTag", () => {
  it("should render without crashing", () => {
    const props = getCustomCodeTagProps()
    render(<CustomPreTag {...props} />)

    const preTag = screen.getByTestId("stMarkdownPre")
    const tagName = preTag.nodeName.toLowerCase()

    expect(preTag).toBeInTheDocument()
    expect(tagName).toBe("div")
    expect(preTag).toHaveTextContent(
      'import streamlit as st st.write("Hello")'
    )
  })
})


================================================
File: /frontend/lib/src/components/shared/StreamlitMarkdown/StreamlitMarkdown.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  CSSProperties,
  FunctionComponent,
  HTMLProps,
  memo,
  ReactElement,
  ReactNode,
  useContext,
} from "react"

import { visit } from "unist-util-visit"
import { useTheme } from "@emotion/react"
import ReactMarkdown from "react-markdown"
import { PluggableList } from "react-markdown/lib/react-markdown"
import {
  Components,
  ReactMarkdownProps,
} from "react-markdown/lib/ast-to-react"
import once from "lodash/once"
import omit from "lodash/omit"
import remarkDirective from "remark-directive"
import remarkMathPlugin from "remark-math"
import rehypeRaw from "rehype-raw"
import rehypeKatex from "rehype-katex"
import { Link2 as LinkIcon } from "react-feather"
import remarkEmoji from "remark-emoji"
import remarkGfm from "remark-gfm"
import { findAndReplace } from "mdast-util-find-and-replace"
import xxhash from "xxhashjs"

import StreamlitSyntaxHighlighter from "@streamlit/lib/src/components/elements/CodeBlock/StreamlitSyntaxHighlighter"
import { StyledInlineCode } from "@streamlit/lib/src/components/elements/CodeBlock/styled-components"
import IsDialogContext from "@streamlit/lib/src/components/core/IsDialogContext"
import IsSidebarContext from "@streamlit/lib/src/components/core/IsSidebarContext"
import ErrorBoundary from "@streamlit/lib/src/components/shared/ErrorBoundary"
import { InlineTooltipIcon } from "@streamlit/lib/src/components/shared/TooltipIcon"
import {
  EmotionTheme,
  getMarkdownBgColors,
  getMarkdownTextColors,
} from "@streamlit/lib/src/theme"
import { LibContext } from "@streamlit/lib/src/components/core/LibContext"
import streamlitLogo from "@streamlit/lib/src/assets/img/streamlit-logo/streamlit-mark-color.svg"

import {
  StyledHeadingActionElements,
  StyledHeadingWithActionElements,
  StyledLinkIcon,
  StyledPreWrapper,
  StyledStreamlitMarkdown,
} from "./styled-components"

import "katex/dist/katex.min.css"

export enum Tags {
  H1 = "h1",
  H2 = "h2",
  H3 = "h3",
}

export interface Props {
  /**
   * The Markdown formatted text to render.
   */
  source: string

  /**
   * True if HTML is allowed in the source string. If this is false,
   * any HTML will be escaped in the output.
   */
  allowHTML: boolean
  style?: CSSProperties
  isCaption?: boolean

  /**
   * Indicates widget labels & restricts allowed elements
   */
  isLabel?: boolean

  /**
   * Make the label bold
   */
  boldLabel?: boolean

  /**
   * Checkbox labels have larger font sizing
   */
  largerLabel?: boolean

  /**
   * Does not allow links
   */
  disableLinks?: boolean

  /**
   * Toast has smaller font sizing & special CSS
   */
  isToast?: boolean
}

/**
 * Creates a slug suitable for use as an anchor given a string.
 * Splits the string on non-alphanumeric characters, and joins with a dash.
 */
export function createAnchorFromText(text: string | null): string {
  let newAnchor = ""
  // Check if the text is valid ASCII characters - necessary for fully functional anchors (issue #5291)
  const isASCII = text && /^[\x00-\x7F]*$/.test(text)

  if (isASCII) {
    newAnchor = text
      ?.toLowerCase()
      .split(/[^\p{L}\p{N}]+/gu) // split on non-alphanumeric characters
      .filter(Boolean) // filter out falsy values using Boolean constructor
      .join("-")
  } else if (text) {
    // if the text is not valid ASCII, use a hash of the text
    newAnchor = xxhash.h32(text, 0xabcd).toString(16)
  }
  return newAnchor
}

// Note: React markdown limits hrefs to specific protocols ('http', 'https',
// 'mailto', 'tel') We are essentially allowing any URL (a data URL). It can
// be considered a security flaw, but developers can choose to expose it.
function transformLinkUri(href: string): string {
  return href
}

// wrapping in `once` ensures we only scroll once
const scrollNodeIntoView = once((node: HTMLElement): void => {
  node.scrollIntoView(true)
})

interface HeadingActionElements {
  elementId?: string
  help?: string
  hideAnchor?: boolean
}

const HeaderActionElements: FunctionComponent<HeadingActionElements> = ({
  elementId,
  help,
  hideAnchor,
}) => {
  const theme: EmotionTheme = useTheme()
  if (!help && hideAnchor) {
    return <></>
  }

  return (
    <StyledHeadingActionElements data-testid="stHeaderActionElements">
      {help && <InlineTooltipIcon content={help} />}
      {elementId && !hideAnchor && (
        <StyledLinkIcon href={`#${elementId}`}>
          <LinkIcon size={theme.iconSizes.base} />
        </StyledLinkIcon>
      )}
    </StyledHeadingActionElements>
  )
}

interface HeadingWithActionElementsProps {
  tag: string
  anchor?: string
  hideAnchor?: boolean
  children: ReactNode[] | ReactNode
  tagProps?: HTMLProps<HTMLHeadingElement>
  help?: string
}

export const HeadingWithActionElements: FunctionComponent<
  React.PropsWithChildren<HeadingWithActionElementsProps>
> = ({ tag, anchor: propsAnchor, help, hideAnchor, children, tagProps }) => {
  const isInSidebar = React.useContext(IsSidebarContext)
  const isInDialog = React.useContext(IsDialogContext)
  const [elementId, setElementId] = React.useState(propsAnchor)
  const [target, setTarget] = React.useState<HTMLElement | null>(null)

  const { addScriptFinishedHandler, removeScriptFinishedHandler } =
    React.useContext(LibContext)
  const onScriptFinished = React.useCallback(() => {
    if (target !== null) {
      // wait a bit for everything on page to finish loading
      window.setTimeout(() => {
        scrollNodeIntoView(target)
      }, 300)
    }
  }, [target])

  React.useEffect(() => {
    addScriptFinishedHandler(onScriptFinished)
    return () => {
      removeScriptFinishedHandler(onScriptFinished)
    }
  }, [addScriptFinishedHandler, removeScriptFinishedHandler, onScriptFinished])

  const ref = React.useCallback(
    (node: any) => {
      if (node === null) {
        return
      }

      const anchor = propsAnchor || createAnchorFromText(node.textContent)
      setElementId(anchor)
      const windowHash = window.location.hash.slice(1)
      if (windowHash && windowHash === anchor) {
        setTarget(node)
      }
    },
    [propsAnchor]
  )

  const isInSidebarOrDialog = isInSidebar || isInDialog
  const actionElements = (
    <HeaderActionElements
      elementId={elementId}
      help={help}
      hideAnchor={hideAnchor || isInSidebarOrDialog}
    />
  )

  const attributes = isInSidebarOrDialog ? {} : { ref, id: elementId }
  // We nest the action-elements (tooltip, link-icon) into the header element (e.g. h1),
  // so that it appears inline. For context: we also tried setting the h's display attribute to 'inline', but
  // then we would need to add padding to the outer container and fiddle with the vertical alignment.
  const headerElementWithActions = React.createElement(
    tag,
    {
      ...tagProps,
      ...attributes,
    },
    <>
      {children}
      {actionElements}
    </>
  )

  // we don't want to apply styling, so return the "raw" header
  if (isInSidebarOrDialog) {
    return headerElementWithActions
  }

  return (
    <StyledHeadingWithActionElements data-testid="stHeadingWithActionElements">
      {headerElementWithActions}
    </StyledHeadingWithActionElements>
  )
}

type HeadingProps = JSX.IntrinsicElements["h1"] &
  ReactMarkdownProps & { level: number; "data-anchor"?: string }

export const CustomHeading: FunctionComponent<
  React.PropsWithChildren<HeadingProps>
> = ({ node, children, ...rest }) => {
  const anchor = rest["data-anchor"]
  return (
    <HeadingWithActionElements
      tag={node.tagName}
      anchor={anchor}
      tagProps={rest}
    >
      {children}
    </HeadingWithActionElements>
  )
}
export interface RenderedMarkdownProps {
  /**
   * The Markdown formatted text to render.
   */
  source: string

  /**
   * True if HTML is allowed in the source string. If this is false,
   * any HTML will be escaped in the output.
   */
  allowHTML: boolean

  overrideComponents?: Components

  /**
   * Indicates widget labels & restricts allowed elements
   */
  isLabel?: boolean

  /**
   * Does not allow links
   */
  disableLinks?: boolean
}

export type CustomCodeTagProps = JSX.IntrinsicElements["code"] &
  ReactMarkdownProps & { inline?: boolean }

/**
 * Renders code tag with highlighting based on requested language.
 */
export const CustomCodeTag: FunctionComponent<
  React.PropsWithChildren<CustomCodeTagProps>
> = ({ inline, className, children, ...props }) => {
  const match = /language-(\w+)/.exec(className || "")
  const codeText = String(children).trim().replace(/\n$/, "")

  const language = (match && match[1]) || ""
  return !inline ? (
    <StreamlitSyntaxHighlighter language={language} showLineNumbers={false}>
      {codeText}
    </StreamlitSyntaxHighlighter>
  ) : (
    <StyledInlineCode className={className} {...omit(props, "node")}>
      {children}
    </StyledInlineCode>
  )
}

/**
 * Renders pre tag with added margin.
 */
export const CustomPreTag: FunctionComponent<
  React.PropsWithChildren<ReactMarkdownProps>
> = ({ children }) => {
  return (
    <StyledPreWrapper data-testid="stMarkdownPre">{children}</StyledPreWrapper>
  )
}

export function RenderedMarkdown({
  allowHTML,
  source,
  overrideComponents,
  isLabel,
  disableLinks,
}: Readonly<RenderedMarkdownProps>): ReactElement {
  const renderers: Components = {
    pre: CustomPreTag,
    code: CustomCodeTag,
    a: LinkWithTargetBlank,
    h1: CustomHeading,
    h2: CustomHeading,
    h3: CustomHeading,
    h4: CustomHeading,
    h5: CustomHeading,
    h6: CustomHeading,
    ...(overrideComponents || {}),
  }
  const theme: EmotionTheme = useTheme()
  const { red, orange, yellow, green, blue, violet, purple, gray, primary } =
    getMarkdownTextColors(theme)
  const {
    redbg,
    orangebg,
    yellowbg,
    greenbg,
    bluebg,
    violetbg,
    purplebg,
    graybg,
    primarybg,
  } = getMarkdownBgColors(theme)
  const colorMapping = new Map(
    Object.entries({
      red: `color: ${red}`,
      blue: `color: ${blue}`,
      green: `color: ${green}`,
      violet: `color: ${violet}`,
      orange: `color: ${orange}`,
      gray: `color: ${gray}`,
      grey: `color: ${gray}`,
      primary: `color: ${primary}`,
      // Gradient from red, orange, yellow, green, blue, violet, purple
      rainbow: `color: transparent; background-clip: text; -webkit-background-clip: text; background-image: linear-gradient(to right,
        ${red}, ${orange}, ${yellow}, ${green}, ${blue}, ${violet}, ${purple});`,
      "red-background": `background-color: ${redbg}`,
      "blue-background": `background-color: ${bluebg}`,
      "green-background": `background-color: ${greenbg}`,
      "violet-background": `background-color: ${violetbg}`,
      "orange-background": `background-color: ${orangebg}`,
      "gray-background": `background-color: ${graybg}`,
      "grey-background": `background-color: ${graybg}`,
      "primary-background": `background-color: ${primarybg}`,
      // Gradient from red, orange, yellow, green, blue, violet, purple
      "rainbow-background": `background: linear-gradient(to right,
        ${redbg}, ${orangebg}, ${yellowbg}, ${greenbg}, ${bluebg}, ${violetbg}, ${purplebg});`,
    })
  )
  function remarkColoring() {
    return (tree: any) => {
      visit(tree, "textDirective", (node, _index, _parent) => {
        const nodeName = String(node.name)
        if (colorMapping.has(nodeName)) {
          const data = node.data || (node.data = {})
          const style = colorMapping.get(nodeName)
          data.hName = "span"
          data.hProperties = data.hProperties || {}
          data.hProperties.style = style
          // Add class for background color for custom styling
          if (
            style &&
            (/background-color:/.test(style) || /background:/.test(style))
          ) {
            data.hProperties.className =
              (data.hProperties.className || "") + " has-background-color"
          }
        } else {
          // Workaround to convert unsupported text directives to plain text to avoid them being
          // ignored / not rendered. See https://github.com/streamlit/streamlit/issues/8726,
          // https://github.com/streamlit/streamlit/issues/5968
          node.type = "text"
          node.value = `:${nodeName}`
          node.data = {}
        }
      })
    }
  }

  function remarkMaterialIcons() {
    return (tree: any) => {
      function replace(fullMatch: string, iconName: string): any {
        return {
          type: "text",
          value: fullMatch,
          data: {
            hName: "span",
            hProperties: {
              role: "img",
              ariaLabel: iconName + " icon",
              style: {
                display: "inline-block",
                fontFamily: theme.genericFonts.iconFont,
                fontWeight: theme.fontWeights.normal,
                // Disable selection for copying it as text.
                // Allowing this leads to copying the underlying icon name,
                // which can be confusing / unexpected.
                userSelect: "none",
                verticalAlign: "bottom",
                whiteSpace: "nowrap",
                wordWrap: "normal",
              },
            },
            hChildren: [{ type: "text", value: iconName }],
          },
        }
      }
      // We replace all `:material/` occurrences with `:material_` to avoid
      // conflicts with the directive plugin.
      // Since all `:material/` already got replaced with `:material_`
      // within the markdown text (see below), we need to use `:material_`
      // within the regex.
      findAndReplace(tree, [[/:material_(\w+):/g, replace]])
      return tree
    }
  }

  function remarkStreamlitLogo() {
    return (tree: any) => {
      function replaceStreamlit(): any {
        return {
          type: "text",
          value: "",
          data: {
            hName: "img",
            hProperties: {
              src: streamlitLogo,
              alt: "Streamlit logo",
              style: {
                display: "inline-block",
                // Disable selection for copying it as text.
                // Allowing this leads to copying the alt text,
                // which can be confusing / unexpected.
                userSelect: "none",
                height: "0.75em",
                verticalAlign: "baseline",
                // The base of the Streamlit logo is curved, so move it down a bit to
                // make it look aligned with the text.
                // eslint-disable-next-line streamlit-custom/no-hardcoded-theme-values
                marginBottom: "-0.05ex",
              },
            },
          },
        }
      }
      findAndReplace(tree, [[/:streamlit:/g, replaceStreamlit]])
      return tree
    }
  }

  function remarkTypographicalSymbols() {
    return (tree: any) => {
      visit(tree, (node, index, parent) => {
        if (
          parent &&
          (parent.type === "link" || parent.type === "linkReference")
        ) {
          // Don't replace symbols in links.
          // Note that remark extensions are not applied in code blocks and latex
          // formulas, so we don't need to worry about them here.
          return
        }

        if (node.type === "text" && node.value) {
          // Only replace symbols wrapped in spaces, so it's a bit safer in case the
          // symbols are used as part of a word or longer string of symbols.
          const replacements = [
            [/(^|\s)<->(\s|$)/g, "$1↔$2"],
            [/(^|\s)->(\s|$)/g, "$1→$2"],
            [/(^|\s)<-(\s|$)/g, "$1←$2"],
            [/(^|\s)--(\s|$)/g, "$1—$2"],
            [/(^|\s)>=(\s|$)/g, "$1≥$2"],
            [/(^|\s)<=(\s|$)/g, "$1≤$2"],
            [/(^|\s)~=(\s|$)/g, "$1≈$2"],
          ]

          let newValue = node.value
          for (const [pattern, replacement] of replacements) {
            newValue = newValue.replace(pattern, replacement as string)
          }

          if (newValue !== node.value) {
            node.value = newValue
          }
        }
      })

      return tree
    }
  }

  const plugins = [
    remarkMathPlugin,
    remarkEmoji,
    remarkGfm,
    remarkDirective,
    remarkColoring,
    remarkMaterialIcons,
    remarkStreamlitLogo,
    remarkTypographicalSymbols,
  ]

  const rehypePlugins: PluggableList = [
    rehypeKatex,
    ...(allowHTML ? [rehypeRaw] : []),
  ]

  // :material/ is detected as an directive by remark directive logic.
  // However, the directive logic ignores emoji shortcodes. As a workaround,
  // we can make it look like an emoji shortcode by replacing the `/` with `_`.
  const processedSource = source.replaceAll(":material/", ":material_")

  // Sets disallowed markdown for widget labels
  const disallowed = [
    // Restricts table elements, headings, unordered/ordered lists, task lists, horizontal rules, & blockquotes
    // Note that images are allowed but have a max height equal to the text height
    "table",
    "thead",
    "tbody",
    "tr",
    "th",
    "td",
    "h1",
    "h2",
    "h3",
    "h4",
    "h5",
    "h6",
    "ul",
    "ol",
    "li",
    "input",
    "hr",
    "blockquote",
    // additionally restrict links
    ...(disableLinks ? ["a"] : []),
  ]

  return (
    <ErrorBoundary>
      <ReactMarkdown
        remarkPlugins={plugins}
        rehypePlugins={rehypePlugins}
        components={renderers}
        transformLinkUri={transformLinkUri}
        disallowedElements={isLabel ? disallowed : []}
        // unwrap and render children from invalid markdown
        unwrapDisallowed={true}
      >
        {processedSource}
      </ReactMarkdown>
    </ErrorBoundary>
  )
}

/**
 * Wraps the <ReactMarkdown> component to include our standard
 * renderers and AST plugins (for syntax highlighting, HTML support, etc).
 */
const StreamlitMarkdown: React.FC<Props> = ({
  source,
  allowHTML,
  style,
  isCaption,
  isLabel,
  boldLabel,
  largerLabel,
  disableLinks,
  isToast,
}) => {
  const isInSidebar = useContext(IsSidebarContext)
  const isInDialog = useContext(IsDialogContext)

  return (
    <StyledStreamlitMarkdown
      isCaption={Boolean(isCaption)}
      isInSidebarOrDialog={isInSidebar || isInDialog}
      isLabel={isLabel}
      boldLabel={boldLabel}
      largerLabel={largerLabel}
      isToast={isToast}
      style={style}
      data-testid={isCaption ? "stCaptionContainer" : "stMarkdownContainer"}
    >
      <RenderedMarkdown
        source={source}
        allowHTML={allowHTML}
        isLabel={isLabel}
        disableLinks={disableLinks}
      />
    </StyledStreamlitMarkdown>
  )
}

interface LinkProps {
  node: any
  children: ReactNode[]
  href?: string
  title?: string
  target?: string
  rel?: string
}

// Using target="_blank" without rel="noopener noreferrer" is a security risk:
// see https://mathiasbynens.github.io/rel-noopener
export function LinkWithTargetBlank(props: LinkProps): ReactElement {
  // if it's a #hash link, don't open in new tab
  const { href } = props
  if (href && href.startsWith("#")) {
    const { children, ...rest } = props
    return <a {...omit(rest, "node")}>{children}</a>
  }

  const { title, children, target, rel, ...rest } = props
  return (
    <a
      href={href}
      title={title}
      target={target || "_blank"}
      rel={rel || "noopener noreferrer"}
      {...omit(rest, "node")}
    >
      {children}
    </a>
  )
}

export default memo(StreamlitMarkdown)


================================================
File: /frontend/lib/src/components/shared/StreamlitMarkdown/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Props as _StreamlitMarkdownProps } from "./StreamlitMarkdown"

export { default } from "./StreamlitMarkdown"
export type StreamlitMarkdownProps = _StreamlitMarkdownProps


================================================
File: /frontend/lib/src/components/shared/StreamlitMarkdown/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Theme } from "@emotion/react"
import styled from "@emotion/styled"

export interface StyledStreamlitMarkdownProps {
  isCaption: boolean
  isInSidebarOrDialog: boolean
  isLabel?: boolean
  boldLabel?: boolean
  largerLabel?: boolean
  isToast?: boolean
}

function convertRemToEm(s: string): string {
  return s.replace(/rem$/, "em")
}

function sharedMarkdownStyle(theme: Theme): any {
  return {
    a: {
      color: theme.colors.linkText,
      textDecoration: "underline",
    },
  }
}

/**
 * Caption sizes taken from default styles, but using em instead of rem, so it
 * inherits the <small>'s shrunk size
 *
 */
function convertFontSizes(
  fontSize: string,
  smallFontSize: string,
  captionFontSize: string,
  smallCaptionFontSize: string,
  useSmallerHeadings: boolean,
  isCaption: boolean
): string {
  if (useSmallerHeadings) {
    return isCaption ? convertRemToEm(smallCaptionFontSize) : smallFontSize
  }

  return isCaption ? convertRemToEm(captionFontSize) : fontSize
}

function getMarkdownHeadingDefinitions(
  theme: Theme,
  useSmallerHeadings: boolean,
  isCaption: boolean
): any {
  return {
    "h1, h2, h3, h4, h5, h6": {
      fontFamily: theme.genericFonts.headingFont,
      fontWeight: theme.fontWeights.bold,
      lineHeight: theme.lineHeights.headings,
      margin: 0,
      color: "inherit",
    },
    h1: {
      fontSize: convertFontSizes(
        theme.fontSizes.fourXL,
        theme.fontSizes.xl,
        theme.fontSizes.threeXL,
        theme.fontSizes.xl,
        useSmallerHeadings,
        isCaption
      ),
      fontWeight: useSmallerHeadings
        ? theme.fontWeights.bold
        : theme.fontWeights.extrabold,
      padding: `${theme.spacing.xl} 0 ${theme.spacing.lg} 0`,
    },
    "h1 b, h1 strong": {
      fontWeight: theme.fontWeights.extrabold,
    },
    "h2, h3": {
      letterSpacing: "-0.005em",
    },
    h2: {
      fontSize: convertFontSizes(
        theme.fontSizes.threeXL,
        theme.fontSizes.lg,
        theme.fontSizes.twoXL,
        theme.fontSizes.lg,
        useSmallerHeadings,
        isCaption
      ),
      padding: `${theme.spacing.lg} 0 ${theme.spacing.lg} 0`,
    },
    h3: {
      fontSize: convertFontSizes(
        theme.fontSizes.twoXL,
        theme.fontSizes.mdLg,
        theme.fontSizes.lg,
        theme.fontSizes.mdLg,
        useSmallerHeadings,
        isCaption
      ),
      padding: `${theme.spacing.sm} 0 ${theme.spacing.lg} 0`,
    },
    h4: {
      fontSize: convertFontSizes(
        theme.fontSizes.xl,
        theme.fontSizes.md,
        theme.fontSizes.md,
        theme.fontSizes.md,
        useSmallerHeadings,
        isCaption
      ),
      padding: `${theme.spacing.md} 0 ${theme.spacing.lg} 0`,
    },
    h5: {
      fontSize: convertFontSizes(
        theme.fontSizes.lg,
        theme.fontSizes.sm,
        theme.fontSizes.md,
        theme.fontSizes.md,
        useSmallerHeadings,
        isCaption
      ),
      padding: `0 0 ${theme.spacing.lg} 0`,
    },
    h6: {
      fontSize: convertFontSizes(
        theme.fontSizes.md,
        theme.fontSizes.twoSm,
        theme.fontSizes.md,
        theme.fontSizes.md,
        useSmallerHeadings,
        isCaption
      ),
      padding: `0 0 ${theme.spacing.lg} 0`,
    },
  }
}

export const StyledStreamlitMarkdown =
  styled.div<StyledStreamlitMarkdownProps>(
    ({
      theme,
      isCaption,
      isInSidebarOrDialog,
      isLabel,
      boldLabel,
      largerLabel,
      isToast,
    }) => {
      // Widget Labels have smaller font size with exception of Button/Checkbox/Radio Button labels
      // Toasts also have smaller font size
      const useSmallerFontSize =
        (isLabel && !largerLabel) || isToast || isCaption

      return {
        fontFamily: theme.genericFonts.bodyFont,
        fontSize: useSmallerFontSize ? theme.fontSizes.sm : theme.fontSizes.md,
        marginBottom: isLabel ? "" : `-${theme.spacing.lg}`,
        opacity: isCaption ? 0.6 : undefined,
        color: "inherit",
        ...sharedMarkdownStyle(theme),
        ...getMarkdownHeadingDefinitions(
          theme,
          isInSidebarOrDialog,
          isCaption
        ),

        p: {
          wordBreak: "break-word",
          marginBottom: isLabel ? theme.spacing.none : "",
          fontWeight: boldLabel ? theme.fontWeights.bold : "",
          marginTop: theme.spacing.none,
          marginLeft: theme.spacing.none,
          marginRight: theme.spacing.none,
        },

        img: {
          // Images in markdown should never be wider
          // than the content area.
          maxWidth: "100%",
          // In labels, widgets should never be taller than the text.
          maxHeight: isLabel ? "1em" : undefined,
          verticalAlign: "middle",
        },

        li: {
          // TODO(lukasmasuch): We might want to refactor
          // these settings to use our spacing props instead.
          // But this would require some styling changes.
          margin: "0.2em 0 0.2em 1.2em",
          padding: "0 0 0 0.6em",
        },

        // Handles quotes:
        blockquote: {
          margin: "1em 0 1em 0",
          padding: "0 0 0 1.2em",
          borderLeft: `${theme.sizes.borderWidth} solid ${theme.colors.lightGray}`,
        },

        "b, strong": {
          fontWeight: theme.fontWeights.bold,
        },

        // Handles the horizontal divider:
        hr: {
          margin: "2em 0",
          padding: 0,
          // Reset Firefox's gray color:
          color: "inherit",
          backgroundColor: "transparent",
          border: "none",
          borderBottom: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
          // Set correct height and prevent the size attribute
          // to make the hr look like an input field:
          "&:not([size])": {
            height: theme.sizes.borderWidth,
          },
        },

        table: {
          // Add some space below the markdown tables
          marginBottom: theme.spacing.lg,
          // Prevent double borders
          borderCollapse: "collapse",
        },

        tr: {
          borderTop: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
        },

        th: {
          textAlign: "inherit",
        },

        "th, td": {
          padding: `${theme.spacing.xs} ${theme.spacing.md}`,
          border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
        },

        "span.has-background-color": {
          padding: `${theme.spacing.threeXS} ${theme.spacing.twoXS}`,
          margin: theme.spacing.none,
          borderRadius: theme.radii.md,
        },

        "p, ol, ul, dl, li": {
          fontSize: "inherit",
        },
      }
    }
  )

export const StyledLinkIcon = styled.a(({ theme }) => ({
  // center icon
  lineHeight: 0,
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",

  svg: {
    // same color as the tooltip-icon
    stroke: theme.colors.fadedText60,
    strokeWidth: 2.25,
  },

  "&:hover svg": {
    stroke: theme.colors.bodyText,
  },
}))

export const StyledHeadingWithActionElements = styled.div(({ theme }) => ({
  "h1, h2, h3, h4, h5, h6, span": {
    scrollMarginTop: theme.sizes.headerHeight,
  },
  ...sharedMarkdownStyle(theme),

  // break-word & pretty makes most headings break in a nicer way than break-all while still
  // preventing overflowing of the container to the side. Long headings without whitespaces or hyphens might still look weird
  wordBreak: "break-word",
  textWrap: "pretty",

  // show link-icon when hovering somewhere over the heading
  [StyledLinkIcon as any]: {
    visibility: "hidden",
  },

  // we have to set the hover here so that the link icon becomes visible when hovering anywhere over the heading
  "&:hover": {
    [StyledLinkIcon as any]: {
      visibility: "visible",
    },
  },
}))

export const StyledHeadingActionElements = styled.span(({ theme }) => ({
  marginLeft: theme.spacing.sm,
  display: "inline-flex",
  gap: theme.spacing.sm,

  verticalAlign: "middle",

  "& > *": {
    // remove margins of inner elements as they are wrapped in a container that applies the margin
    marginLeft: "0 !important",
  },
}))

export interface StyledDividerProps {
  rainbow: boolean
  color: string
}

export const StyledHeaderDivider = styled.hr<StyledDividerProps>(
  ({ theme, rainbow, color }) => {
    return {
      // Height needs to be !important due to globalStyles.tsx hr height override - line #170
      height: `${theme.spacing.threeXS} !important`,
      marginTop: theme.spacing.sm,
      marginBottom: theme.spacing.none,
      border: "none",
      borderRadius: theme.radii.full,
      ...(rainbow ? { background: color } : { backgroundColor: color }),
    }
  }
)

export const StyledPreWrapper = styled.div(({ theme }) => ({
  // Set spacing between pre-elements inside of markdown similar to our gap spacing between elements
  marginBottom: theme.spacing.lg,
}))


================================================
File: /frontend/lib/src/components/shared/TextElements/Text.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export enum Kind {
  DANGER = "danger",
}

interface TextProps {
  kind?: Kind
}

export const Small = styled.small<TextProps>(({ kind, theme }) => {
  const { danger, fadedText60 } = theme.colors

  return {
    color: kind === Kind.DANGER ? danger : fadedText60,
    fontSize: theme.fontSizes.sm,
    lineHeight: theme.lineHeights.tight,
  }
})


================================================
File: /frontend/lib/src/components/shared/TextElements/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { Small, Kind } from "./Text"


================================================
File: /frontend/lib/src/components/shared/Toolbar/Toolbar.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { Info } from "@emotion-icons/material-outlined"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"

import Toolbar, {
  ToolbarAction,
  ToolbarActionProps,
  ToolbarProps,
} from "./Toolbar"

const onExpand = vi.fn()
const onCollapse = vi.fn()

const getToolbarProps = (
  propOverrides: Partial<ToolbarProps> = {}
): ToolbarProps => ({
  onExpand: onExpand,
  onCollapse: onCollapse,
  isFullScreen: false,
  locked: true,
  ...propOverrides,
})

const getToolbarActionsProps = (
  propOverrides: Partial<ToolbarActionProps> = {}
): ToolbarActionProps => ({
  onClick: vi.fn(),
  icon: Info,
  label: "info",
  show_label: false,
  ...propOverrides,
})

describe("Toolbar element", () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it("renders a Toolbar", async () => {
    render(
      <Toolbar {...getToolbarProps()}>
        <ToolbarAction {...getToolbarActionsProps()} />
      </Toolbar>
    )

    const toolbar = screen.getByTestId("stElementToolbar")
    expect(toolbar).toBeInTheDocument()
    expect(toolbar).toBeVisible()
    expect(toolbar).toHaveClass("stElementToolbar")

    // Check if toolbar buttons are rendered:
    const toolbarButton = screen.getAllByTestId("stElementToolbarButton")
    expect(toolbarButton).toHaveLength(2)
  })

  it("doesn't show toolbar if not locked", async () => {
    render(
      <Toolbar {...getToolbarProps({ locked: false })}>
        <ToolbarAction {...getToolbarActionsProps()} />
      </Toolbar>
    )

    const toolbar = screen.getByTestId("stElementToolbar")
    expect(toolbar).toBeInTheDocument()
    // Should not be visible
    expect(toolbar).not.toBeVisible()
  })

  it("allows expanding into fullscreen mode", async () => {
    const user = userEvent.setup()
    render(
      <Toolbar {...getToolbarProps()}>
        <ToolbarAction {...getToolbarActionsProps()} />
      </Toolbar>
    )

    const toolbar = screen.getByTestId("stElementToolbar")
    expect(toolbar).toBeInTheDocument()
    // Toolbar is always visible in fullscreen:
    expect(toolbar).toBeVisible()

    const toolbarButton = screen.getAllByRole("button")
    expect(toolbarButton).toHaveLength(2)
    // Clicking the second button should close the fullscreen mode
    await user.click(toolbarButton[1])

    // Check that onCollapse was clicked
    expect(onExpand).toHaveBeenCalled()
  })

  it("adapts to fullscreen mode", async () => {
    const user = userEvent.setup()
    render(
      <Toolbar {...getToolbarProps({ locked: false, isFullScreen: true })}>
        <ToolbarAction {...getToolbarActionsProps()} />
      </Toolbar>
    )

    const toolbar = screen.getByTestId("stElementToolbar")
    expect(toolbar).toBeInTheDocument()
    // Toolbar is always visible in fullscreen:
    expect(toolbar).toBeVisible()

    const toolbarButton = screen.getAllByRole("button")
    expect(toolbarButton).toHaveLength(2)
    // Clicking the second button should close the fullscreen mode
    await user.click(toolbarButton[1])

    // Check that onCollapse was clicked
    expect(onCollapse).toHaveBeenCalled()
  })

  it("deactivates fullscreen mode via props", async () => {
    render(
      <Toolbar
        {...getToolbarProps({ locked: false, disableFullscreenMode: true })}
      >
        <ToolbarAction {...getToolbarActionsProps()} />
      </Toolbar>
    )

    // Check that there is only one toolbar button.
    // The fullscreen actions should not be visible.
    const toolbarButton = screen.getAllByTestId("stElementToolbarButton")
    expect(toolbarButton).toHaveLength(1)
  })
})

describe("ToolbarAction Button element", () => {
  it("renders correctly", async () => {
    render(<ToolbarAction {...getToolbarActionsProps()} />)
    // Check if toolbar button is rendered:
    const toolbarButton = screen.getByTestId("stElementToolbarButton")
    expect(toolbarButton).toBeInTheDocument()

    // Check if the toolbar icon is shown:
    const toolbarButtonIcon = screen.getByTestId("stElementToolbarButtonIcon")
    expect(toolbarButtonIcon).toBeInTheDocument()
  })

  it("shows a label if show_labe=true", async () => {
    render(<ToolbarAction {...getToolbarActionsProps({ show_label: true })} />)
    // Check that the info label is visible
    const infoLabel = screen.getByText("info")
    expect(infoLabel).toBeVisible()
  })

  it("doesn't show an icon if icon=undefined", async () => {
    render(
      <ToolbarAction
        {...getToolbarActionsProps({ show_label: true, icon: undefined })}
      />
    )
    // Check that the info label is visible
    const infoLabel = screen.getByText("info")
    expect(infoLabel).toBeVisible()

    // Check if the toolbar icon is not shown:
    const toolbarButtonIcon = screen.queryByTestId(
      "stElementToolbarButtonIcon"
    )
    expect(toolbarButtonIcon).toBeNull()
  })

  it("calls callback on click", async () => {
    const user = userEvent.setup()
    const onClickMock = vi.fn()

    render(
      <ToolbarAction {...getToolbarActionsProps({ onClick: onClickMock })} />
    )
    // Check if toolbar button is rendered:
    const toolbarButton = screen.getByRole("button")
    expect(toolbarButton).toBeInTheDocument()

    await user.click(toolbarButton)

    // Check that onClick callback was clicked
    expect(onClickMock).toHaveBeenCalled()
  })
})


================================================
File: /frontend/lib/src/components/shared/Toolbar/Toolbar.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { EmotionIcon } from "@emotion-icons/emotion-icon"
import { useTheme } from "@emotion/react"
import { StyledComponent } from "@emotion/styled"
import { Fullscreen, FullscreenExit } from "@emotion-icons/material-outlined"

import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"
import Tooltip, {
  Placement,
} from "@streamlit/lib/src/components/shared/Tooltip"
import Button, {
  BaseButtonKind,
} from "@streamlit/lib/src/components/shared/BaseButton"
import Icon from "@streamlit/lib/src/components/shared/Icon"
import { EmotionTheme } from "@streamlit/lib/src/theme"

import { StyledToolbar, StyledToolbarWrapper } from "./styled-components"

export interface ToolbarActionProps {
  label: string
  icon?: EmotionIcon
  show_label?: boolean
  onClick: () => void
}

export function ToolbarAction({
  label,
  show_label,
  icon,
  onClick,
}: ToolbarActionProps): ReactElement {
  const theme: EmotionTheme = useTheme()

  const displayLabel = show_label ? label : ""
  return (
    <div data-testid="stElementToolbarButton">
      <Tooltip
        content={
          <StreamlitMarkdown
            source={label}
            allowHTML={false}
            style={{ fontSize: theme.fontSizes.sm }}
          />
        }
        placement={Placement.TOP}
        // The default tooltip delay (== how fast the tooltip is triggered) of 200ms
        // is a bit too fast for the toolbar use case. Therefore, we are setting it to 1000ms.
        onMouseEnterDelay={1000}
        inline
      >
        <Button
          onClick={event => {
            if (onClick) {
              onClick()
            }
            event.stopPropagation()
          }}
          kind={BaseButtonKind.ELEMENT_TOOLBAR}
          aria-label={label}
        >
          {icon && (
            <Icon
              content={icon}
              size="md"
              testid="stElementToolbarButtonIcon"
            />
          )}
          {displayLabel && <span>{displayLabel}</span>}
        </Button>
      </Tooltip>
    </div>
  )
}

export interface ToolbarProps {
  onExpand?: () => void
  onCollapse?: () => void
  isFullScreen?: boolean
  locked?: boolean
  target?: StyledComponent<any, any, any>
  disableFullscreenMode?: boolean
}

const Toolbar: React.FC<React.PropsWithChildren<ToolbarProps>> = ({
  onExpand,
  onCollapse,
  isFullScreen,
  locked,
  children,
  target,
  disableFullscreenMode,
}): ReactElement => {
  return (
    <StyledToolbarWrapper
      className="stElementToolbar"
      data-testid="stElementToolbar"
      locked={locked || isFullScreen}
      target={target}
    >
      <StyledToolbar>
        {children}
        {onExpand && !disableFullscreenMode && !isFullScreen && (
          <ToolbarAction
            label="Fullscreen"
            icon={Fullscreen}
            onClick={() => onExpand()}
          />
        )}
        {onCollapse && !disableFullscreenMode && isFullScreen && (
          <ToolbarAction
            label="Close fullscreen"
            icon={FullscreenExit}
            onClick={() => onCollapse()}
          />
        )}
      </StyledToolbar>
    </StyledToolbarWrapper>
  )
}

export default Toolbar


================================================
File: /frontend/lib/src/components/shared/Toolbar/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default, ToolbarAction } from "./Toolbar"
export { StyledToolbarElementContainer } from "./styled-components"


================================================
File: /frontend/lib/src/components/shared/Toolbar/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled, { StyledComponent } from "@emotion/styled"

import { hasLightBackgroundColor } from "@streamlit/lib/src/theme"

const TOP_DISTANCE = "-2.4rem"

export interface StyledToolbarWrapperProps {
  locked?: boolean
  target?: StyledComponent<any, any, any>
}

export const StyledToolbarWrapper = styled.div<StyledToolbarWrapperProps>(
  ({ theme, locked, target }) => ({
    padding: `${theme.spacing.sm} 0 ${theme.spacing.sm} ${theme.spacing.sm}`,
    position: "absolute",
    top: locked ? TOP_DISTANCE : "-1rem",
    right: theme.spacing.none,
    transition: "none",
    ...(!locked && {
      opacity: 0,
      "&:active, &:focus-visible, &:hover": {
        transition: "opacity 150ms 100ms, top 100ms 100ms",
        opacity: 1,
        top: TOP_DISTANCE,
      },
      ...(target && {
        [`${target}:hover &, ${target}:active &, ${target}:focus-visible &`]: {
          transition: "opacity 150ms 100ms, top 100ms 100ms",
          opacity: 1,
          top: TOP_DISTANCE,
        },
      }),
    }),
  })
)

export const StyledToolbar = styled.div(({ theme }) => ({
  color: hasLightBackgroundColor(theme)
    ? theme.colors.fadedText60
    : theme.colors.bodyText,
  display: "flex",
  flexDirection: "row",
  alignItems: "center",
  justifyContent: "flex-end",
  boxShadow: "1px 2px 8px rgba(0, 0, 0, 0.08)",
  borderRadius: theme.radii.default,
  backgroundColor: theme.colors.lightenedBg05,
  width: "fit-content",
  zIndex: theme.zIndices.sidebar + 1,
}))

export const StyledToolbarElementContainer = styled.div<{
  width?: number
  height?: number
  useContainerWidth: boolean
  topCentered?: boolean
}>(({ width, height, useContainerWidth, topCentered }) => ({
  position: "relative",
  height: useContainerWidth && height ? height : "fit-content",
  width: useContainerWidth ? width : "fit-content",
  maxWidth: "100%",
  ...(topCentered
    ? {
        display: "flex",
        justifyContent: "center",
      }
    : {}),
}))


================================================
File: /frontend/lib/src/components/shared/Tooltip/OverflowTooltip.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { render, screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { mockTheme } from "@streamlit/lib/src/mocks/mockTheme"
import ThemeProvider from "@streamlit/lib/src/components/core/ThemeProvider"

import OverflowTooltip from "./OverflowTooltip"
import { Placement } from "./Tooltip"

describe("Tooltip component", () => {
  afterEach(() => {
    vi.restoreAllMocks()
  })

  it("should render when it fits onscreen", async () => {
    const user = userEvent.setup()
    const useRefSpy = vi.spyOn(React, "useRef").mockReturnValue({
      current: {
        // Pretend the body is greater than its onscreen area.
        offsetWidth: 200,
        scrollWidth: 100,
      },
    })

    vi.spyOn(React, "useEffect").mockImplementation(f => f())

    render(
      <OverflowTooltip
        content="the content"
        placement={Placement.AUTO}
        style={{}}
      >
        the child
      </OverflowTooltip>,
      {
        wrapper: ({ children }) => (
          <ThemeProvider theme={mockTheme.emotion}>{children}</ThemeProvider>
        ),
      }
    )

    const tooltip = screen.getByTestId("stTooltipHoverTarget")
    await user.hover(tooltip)

    expect(screen.queryByText("the content")).not.toBeInTheDocument()

    expect(useRefSpy).toHaveBeenCalledWith(null)
  })

  it("should render when ellipsized", async () => {
    const user = userEvent.setup()
    const useRefSpy = vi.spyOn(React, "useRef").mockReturnValue({
      current: {
        // Pretend the body is smaller than its onscreen area.
        offsetWidth: 100,
        scrollWidth: 200,
      },
    })

    vi.spyOn(React, "useEffect").mockImplementation(f => f())

    render(
      <OverflowTooltip
        content="the content"
        placement={Placement.AUTO}
        style={{}}
      >
        the child
      </OverflowTooltip>,
      {
        wrapper: ({ children }) => (
          <ThemeProvider theme={mockTheme.emotion}>{children}</ThemeProvider>
        ),
      }
    )

    const tooltip = screen.getByTestId("stTooltipHoverTarget")
    await user.hover(tooltip)

    const tooltipContent = await screen.findByText("the content")
    expect(tooltipContent).toBeInTheDocument()

    expect(useRefSpy).toHaveBeenCalledWith(null)
  })
})


================================================
File: /frontend/lib/src/components/shared/Tooltip/OverflowTooltip.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, ReactNode, useState } from "react"

import Tooltip, { Placement } from "./Tooltip"
import { StyledEllipsizedDiv, StyledWrapper } from "./styled-components"

export interface OverflowTooltipProps {
  content: ReactNode
  placement: Placement
  children: ReactNode
  inline?: boolean
  style?: React.CSSProperties
}

/**
 * Tooltip that only shows when the children are overflowing (in which case,
 * this also ellipsizes the children).
 */
function OverflowTooltip({
  content,
  placement,
  children,
  inline,
  style,
}: OverflowTooltipProps): ReactElement {
  const childRef = React.useRef<HTMLDivElement>(null)
  const [allowTooltip, setAllowTooltip] = useState(false)

  React.useEffect(() => {
    const newAllowTooltip = childRef?.current
      ? childRef.current.offsetWidth < childRef.current.scrollWidth
      : false
    if (newAllowTooltip !== allowTooltip) {
      setAllowTooltip(newAllowTooltip)
    }
  }, [children, allowTooltip])

  return (
    <Tooltip
      content={allowTooltip ? content : ""}
      placement={placement}
      inline={inline}
    >
      <StyledWrapper>
        <StyledEllipsizedDiv ref={childRef} style={style}>
          {children}
        </StyledEllipsizedDiv>
      </StyledWrapper>
    </Tooltip>
  )
}

export default OverflowTooltip


================================================
File: /frontend/lib/src/components/shared/Tooltip/Tooltip.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { BaseProvider, LightTheme } from "baseui"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"

import Tooltip, { Placement, TooltipProps } from "./Tooltip"

const getProps = (
  propOverrides: Partial<TooltipProps> = {}
): TooltipProps => ({
  placement: Placement.AUTO,
  content: <div>Tooltip content text.</div>,
  children: null,
  ...propOverrides,
})

// Wrap in BaseProvider to avoid warnings
const renderTooltip = (props: Partial<TooltipProps> = {}): any => {
  return render(
    <BaseProvider theme={LightTheme}>
      <Tooltip {...getProps(props)} />
    </BaseProvider>
  )
}

describe("Tooltip element", () => {
  it("renders a Tooltip", async () => {
    const user = userEvent.setup()
    renderTooltip()

    const tooltipTarget = screen.getByTestId("stTooltipHoverTarget")
    expect(tooltipTarget).toBeInTheDocument()

    // Hover to see tooltip content
    await user.hover(tooltipTarget)

    const tooltipContent = await screen.findByTestId("stTooltipContent")
    expect(tooltipContent).toHaveTextContent("Tooltip content text.")
  })

  it("renders its children", () => {
    renderTooltip({ children: <div>Child Element</div> })

    expect(screen.getByTestId("stTooltipHoverTarget")).toBeInTheDocument()
    expect(screen.getByText("Child Element")).toBeInTheDocument()
  })

  it("sets the same content", async () => {
    const user = userEvent.setup()
    const content = <span>Help Text</span>
    renderTooltip({ content })

    const tooltipTarget = screen.getByTestId("stTooltipHoverTarget")
    expect(tooltipTarget).toBeInTheDocument()

    // Hover to see tooltip content
    await user.hover(tooltipTarget)

    const tooltipContent = await screen.findByTestId("stTooltipContent")
    expect(tooltipContent).toHaveTextContent("Help Text")
  })
})


================================================
File: /frontend/lib/src/components/shared/Tooltip/Tooltip.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, ReactNode, useRef } from "react"

import { useTheme } from "@emotion/react"
import { ACCESSIBILITY_TYPE, PLACEMENT, StatefulTooltip } from "baseui/tooltip"

import {
  EmotionTheme,
  hasLightBackgroundColor,
} from "@streamlit/lib/src/theme"

import { StyledTooltipContentWrapper } from "./styled-components"

export enum Placement {
  AUTO = "auto",
  TOP_LEFT = "topLeft",
  TOP = "top",
  TOP_RIGHT = "topRight",
  RIGHT_TOP = "rightTop",
  RIGHT = "right",
  RIGHT_BOTTOM = "rightBottom",
  BOTTOM_RIGHT = "bottomRight",
  BOTTOM = "bottom",
  BOTTOM_LEFT = "bottomLeft",
  LEFT_BOTTOM = "leftBottom",
  LEFT = "left",
  LEFT_TOP = "leftTop",
}

export interface TooltipProps {
  content: ReactNode
  placement: Placement
  children: ReactNode
  inline?: boolean
  style?: React.CSSProperties
  onMouseEnterDelay?: number
}

function Tooltip({
  content,
  placement,
  children,
  inline,
  style,
  onMouseEnterDelay,
}: TooltipProps): ReactElement {
  const theme: EmotionTheme = useTheme()
  const { colors, fontSizes, radii, fontWeights } = theme

  const tooltipRef = useRef<HTMLDivElement>(null)

  return (
    <StatefulTooltip
      onOpen={() => {
        const parentElement = tooltipRef.current?.parentElement
        if (!parentElement) {
          return
        }
        // if the tooltip is offscreen to the left, move it to the right by the same amount of pixels
        // use a timeout to that parentElement.getBoundingClientRect returns the correct value; otherwise
        // I have observed it to be "0".
        setTimeout(() => {
          const boundingClientRect = parentElement.getBoundingClientRect()
          const xCoordinate = boundingClientRect.x

          const overflowRight =
            xCoordinate + boundingClientRect.width - window.innerWidth

          // this is the out-of-tree Basweb DOM structure. For the right overflow,
          // this is the element that has the transform-style property set that needs
          // to be modified.
          const parentsParentElement = parentElement.parentElement

          if (overflowRight > 0 && parentsParentElement) {
            // Baseweb uses a transform to position the tooltip, so we need to adjust the transform instead
            // of the left / right property, otherwise it looks weird when the tooltip overflows the right side
            const transformStyleMatrix = new DOMMatrix(
              window.getComputedStyle(parentsParentElement)?.transform
            )
            parentsParentElement.style.transform = `translate3d(${
              transformStyleMatrix.e - overflowRight
            }px, ${transformStyleMatrix.f}px, 0px)`
          }

          if (xCoordinate < 0) {
            parentElement.style.left = `${-xCoordinate}px`
          }
        }, 0)
      }}
      content={
        content ? (
          <StyledTooltipContentWrapper
            className="stTooltipContent"
            data-testid="stTooltipContent"
            ref={tooltipRef}
          >
            {content}
          </StyledTooltipContentWrapper>
        ) : null
      }
      placement={PLACEMENT[placement]}
      accessibilityType={ACCESSIBILITY_TYPE.tooltip}
      showArrow={false}
      popoverMargin={10}
      onMouseEnterDelay={onMouseEnterDelay}
      overrides={{
        Body: {
          style: {
            // This is annoying, but a bunch of warnings get logged when the
            // shorthand version `borderRadius` is used here since the long
            // names are used by BaseWeb and mixing the two is apparently
            // bad :(
            borderTopLeftRadius: radii.default,
            borderTopRightRadius: radii.default,
            borderBottomLeftRadius: radii.default,
            borderBottomRightRadius: radii.default,

            paddingTop: "0 !important",
            paddingBottom: "0 !important",
            paddingLeft: "0 !important",
            paddingRight: "0 !important",

            backgroundColor: "transparent",
          },
        },
        Inner: {
          style: {
            backgroundColor: hasLightBackgroundColor(theme)
              ? colors.bgColor
              : colors.secondaryBg,
            color: colors.bodyText,
            fontSize: fontSizes.sm,
            fontWeight: fontWeights.normal,

            // See the long comment about `borderRadius`. The same applies here
            // to `padding`.
            paddingTop: "0 !important",
            paddingBottom: "0 !important",
            paddingLeft: "0 !important",
            paddingRight: "0 !important",
          },
        },
      }}
    >
      {/* BaseWeb manipulates its child, so we create a wrapper div for protection */}
      <div
        style={{
          display: "flex",
          flexDirection: "row",
          justifyContent: inline ? "flex-end" : "",
          ...style,
        }}
        data-testid="stTooltipHoverTarget"
        className="stTooltipHoverTarget"
      >
        {children}
      </div>
    </StatefulTooltip>
  )
}

export default Tooltip


================================================
File: /frontend/lib/src/components/shared/Tooltip/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default, Placement } from "./Tooltip"
export { default as OverflowTooltip } from "./OverflowTooltip"
export { StyledEllipsizedDiv } from "./styled-components"


================================================
File: /frontend/lib/src/components/shared/Tooltip/styled-components.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledWrapper = styled.div({
  display: "table",
  tableLayout: "fixed",
  width: "100%",
})

export const StyledEllipsizedDiv = styled.div({
  overflow: "hidden",
  whiteSpace: "nowrap",
  textOverflow: "ellipsis",
  display: "table-cell",
})

export const StyledTooltipContentWrapper = styled.div(({ theme }) => ({
  boxSizing: "border-box",
  fontSize: `${theme.fontSizes.sm}`,
  maxWidth: `calc(${theme.sizes.contentMaxWidth} - 2 * ${theme.spacing.threeXL})`,
  maxHeight: theme.sizes.maxTooltipHeight,
  overflow: ["auto", "overlay"],
  padding: `${theme.spacing.xs} ${theme.spacing.md}`,

  [`@media (max-width: ${theme.breakpoints.sm})`]: {
    maxWidth: `calc(100% - ${theme.spacing.threeXL})`,
  },
  img: {
    maxWidth: "100%",
  },
  "*": {
    fontSize: `${theme.fontSizes.sm} !important`,
  },
}))


================================================
File: /frontend/lib/src/components/shared/TooltipIcon/TooltipIcon.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import ThemeProvider from "@streamlit/lib/src/components/core/ThemeProvider"
import { mockTheme } from "@streamlit/lib/src/mocks/mockTheme"

import TooltipIcon from "./TooltipIcon"

describe("TooltipIcon element", () => {
  it("renders a TooltipIcon", () => {
    render(
      <ThemeProvider
        theme={mockTheme.emotion}
        baseuiTheme={mockTheme.basewebTheme}
      >
        <TooltipIcon content="" />
      </ThemeProvider>
    )
    const tooltipIcon = screen.getByTestId("stTooltipIcon")
    expect(tooltipIcon).toBeInTheDocument()
  })
})


================================================
File: /frontend/lib/src/components/shared/TooltipIcon/TooltipIcon.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, ReactNode } from "react"

import { HelpCircle as HelpCircleIcon } from "react-feather"
import { useTheme } from "@emotion/react"

import Tooltip, {
  Placement,
} from "@streamlit/lib/src/components/shared/Tooltip"
import StreamlitMarkdown, {
  StreamlitMarkdownProps,
} from "@streamlit/lib/src/components/shared/StreamlitMarkdown"
import { EmotionTheme } from "@streamlit/lib/src/theme"

import {
  StyledLabelHelpInline,
  StyledTooltipIconWrapper,
} from "./styled-components"

export interface TooltipIconProps {
  placement?: Placement
  isLatex?: boolean
  content: string
  children?: ReactNode
  markdownProps?: Partial<StreamlitMarkdownProps>
  onMouseEnterDelay?: number
}

function TooltipIcon({
  placement = Placement.AUTO,
  isLatex = false,
  content,
  children,
  markdownProps,
  onMouseEnterDelay,
}: TooltipIconProps): ReactElement {
  const theme: EmotionTheme = useTheme()
  return (
    <StyledTooltipIconWrapper
      className="stTooltipIcon"
      data-testid="stTooltipIcon"
      isLatex={isLatex}
    >
      <Tooltip
        content={
          <StreamlitMarkdown
            style={{ fontSize: theme.fontSizes.sm }}
            source={content}
            allowHTML={false}
            {...(markdownProps || {})}
          />
        }
        placement={placement}
        onMouseEnterDelay={onMouseEnterDelay}
        inline
      >
        {children || (
          <HelpCircleIcon className="icon" size={theme.iconSizes.base} />
        )}
      </Tooltip>
    </StyledTooltipIconWrapper>
  )
}

export const InlineTooltipIcon = ({
  placement = Placement.TOP_RIGHT,
  isLatex = false,
  content,
  children,
  markdownProps,
}: TooltipIconProps): ReactElement => {
  return (
    <StyledLabelHelpInline>
      <TooltipIcon
        placement={placement}
        isLatex={isLatex}
        content={content}
        markdownProps={markdownProps}
      >
        {children}
      </TooltipIcon>
    </StyledLabelHelpInline>
  )
}

export default TooltipIcon


================================================
File: /frontend/lib/src/components/shared/TooltipIcon/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from "./TooltipIcon"
export { default } from "./TooltipIcon"
export { StyledLabelHelpWrapper } from "./styled-components"


================================================
File: /frontend/lib/src/components/shared/TooltipIcon/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

interface StyledTooltipIconWrapperProps {
  isLatex?: boolean
}

interface StyledLabelHelpWrapperProps {
  isLatex?: boolean
}

export const StyledTooltipIconWrapper =
  styled.div<StyledTooltipIconWrapperProps>(({ isLatex, theme }) => ({
    display: "flex",
    alignItems: "center",
    marginTop: isLatex ? theme.spacing.md : "0",

    "& .stTooltipHoverTarget > svg": {
      stroke: theme.colors.fadedText60,
      strokeWidth: 2.25,
    },
  }))

export const StyledLabelHelpWrapper = styled.div<StyledLabelHelpWrapperProps>(
  ({ isLatex }) => ({
    display: "flex",
    visibility: "visible",
    verticalAlign: "middle",
    flexDirection: "row",
    alignItems: "center",
    ...(isLatex ? { justifyContent: "center" } : {}),
  })
)

export const StyledLabelHelpInline = styled.label(({ theme }) => ({
  marginLeft: theme.spacing.xs,
  position: "relative",
  display: "flex",
  flexDirection: "row",
}))


================================================
File: /frontend/lib/src/components/shared/WindowDimensions/Provider.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC } from "react"

import { render, screen } from "@testing-library/react"

import ThemeProvider from "@streamlit/lib/src/components/core/ThemeProvider"
import { mockTheme } from "@streamlit/lib/src/mocks/mockTheme"
import { useRequiredContext } from "@streamlit/lib/src/hooks/useRequiredContext"
import { WindowDimensionsProvider } from "@streamlit/lib/src/components/shared/WindowDimensions/Provider"
import { WindowDimensionsContext } from "@streamlit/lib/src/components/shared/WindowDimensions"

describe("WindowDimensionsProvider", () => {
  it("should provide the width and height of the window and take into account the theme padding", () => {
    vi.spyOn(window, "getComputedStyle").mockReturnValue({
      fontSize: "16px",
    } as any)

    const MyComponent: FC = () => {
      const dimensions = useRequiredContext(WindowDimensionsContext)
      return <div>{`${dimensions.fullWidth}x${dimensions.fullHeight}`}</div>
    }

    render(
      <ThemeProvider theme={mockTheme.emotion}>
        <WindowDimensionsProvider>
          <MyComponent />
        </WindowDimensionsProvider>
      </ThemeProvider>
    )

    expect(screen.getByText("1000x710")).toBeVisible()
  })

  it("should throw an error if there are multiple providers in the tree", () => {
    const consoleError = vi
      .spyOn(console, "error")
      .mockImplementation(() => {})

    const Provider: FC = () => (
      <ThemeProvider theme={mockTheme.emotion}>
        <WindowDimensionsProvider>
          <WindowDimensionsProvider>
            <div>Children content</div>
          </WindowDimensionsProvider>
        </WindowDimensionsProvider>
      </ThemeProvider>
    )

    expect(() => render(<Provider />)).toThrowError(
      "WindowDimensionsProvider should only be used once per app. If you need to read window dimensions, utilize `useRequiredContext(WindowDimensionsContext)` instead."
    )
    consoleError.mockRestore()
  })
})


================================================
File: /frontend/lib/src/components/shared/WindowDimensions/Provider.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, PropsWithChildren, useContext } from "react"

import { useWindowDimensions } from "@streamlit/lib/src/components/shared/WindowDimensions/useWindowDimensions"
import { WindowDimensionsContext } from "@streamlit/lib/src/components/shared/WindowDimensions"

/**
 * Registers the current window dimensions in the context. A runtime error will
 * be thrown if used multiple times. Since it listens to window resize events,
 * any additional instances would cause unnecessary performance overhead.
 */
export const WindowDimensionsProvider: FC<PropsWithChildren> = ({
  children,
}) => {
  const dimensions = useWindowDimensions()

  const existingDimensions = useContext(WindowDimensionsContext)

  if (existingDimensions) {
    throw new Error(
      "WindowDimensionsProvider should only be used once per app. If you need to read window dimensions, utilize `useRequiredContext(WindowDimensionsContext)` instead."
    )
  }

  return (
    <WindowDimensionsContext.Provider value={dimensions}>
      {children}
    </WindowDimensionsContext.Provider>
  )
}


================================================
File: /frontend/lib/src/components/shared/WindowDimensions/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { createContext } from "react"

import { WindowDimensions } from "./useWindowDimensions"

export const WindowDimensionsContext = createContext<WindowDimensions | null>(
  null
)
WindowDimensionsContext.displayName = "WindowDimensionsContext"


================================================
File: /frontend/lib/src/components/shared/WindowDimensions/useWindowDimensions.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { useCallback, useEffect, useState } from "react"

import { useTheme } from "@emotion/react"

import { convertRemToPx } from "@streamlit/lib/src/theme/utils"

export type WindowDimensions = {
  fullWidth: number
  fullHeight: number
}

export const useWindowDimensions = (): WindowDimensions => {
  const theme = useTheme()
  const [windowDimensions, setWindowDimensions] = useState<WindowDimensions>({
    fullWidth: 0,
    fullHeight: 0,
  })

  const getWindowDimensions = useCallback((): WindowDimensions => {
    const padding = convertRemToPx(theme.spacing.md)
    const paddingTop = convertRemToPx(theme.sizes.fullScreenHeaderHeight)

    return {
      fullWidth: window.innerWidth - padding * 2, // Left and right
      fullHeight: window.innerHeight - (padding + paddingTop), // Bottom and Top
    }
  }, [theme.sizes.fullScreenHeaderHeight, theme.spacing.md])

  const updateWindowDimensions = useCallback(() => {
    setWindowDimensions(getWindowDimensions())
  }, [getWindowDimensions])

  useEffect(() => {
    window.addEventListener("resize", updateWindowDimensions)

    return () => {
      window.removeEventListener("resize", updateWindowDimensions)
    }
  }, [updateWindowDimensions])

  useEffect(() => {
    // Measure once on load, let resize handlers take over from there
    updateWindowDimensions()
  }, [updateWindowDimensions])

  return windowDimensions
}


================================================
File: /frontend/lib/src/components/widgets/AudioInput/AudioInput.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  memo,
  ReactElement,
  useCallback,
  useEffect,
  useState,
} from "react"

import { useTheme } from "@emotion/react"
import WaveSurfer from "wavesurfer.js"
import RecordPlugin from "wavesurfer.js/dist/plugins/record"
import { Delete, FileDownload } from "@emotion-icons/material-outlined"
import isEqual from "lodash/isEqual"

import { FormClearHelper } from "@streamlit/lib/src/components/widgets/Form"
import { FileUploadClient } from "@streamlit/lib/src/FileUploadClient"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import { AudioInput as AudioInputProto } from "@streamlit/lib/src/proto"
import Toolbar, {
  ToolbarAction,
} from "@streamlit/lib/src/components/shared/Toolbar"
import {
  isNullOrUndefined,
  labelVisibilityProtoValueToEnum,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"
import { blend, convertRemToPx } from "@streamlit/lib/src/theme/utils"
import { uploadFiles } from "@streamlit/lib/src/util/uploadFiles"
import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"
import { WidgetLabel } from "@streamlit/lib/src/components/widgets/BaseWidget"
import { usePrevious } from "@streamlit/lib/src/util/Hooks"
import useWidgetManagerElementState from "@streamlit/lib/src/hooks/useWidgetManagerElementState"
import useDownloadUrl from "@streamlit/lib/src/hooks/useDownloadUrl"

import {
  StyledAudioInputContainerDiv,
  StyledWaveformContainerDiv,
  StyledWaveformInnerDiv,
  StyledWaveformTimeCode,
  StyledWaveSurferDiv,
  StyledWidgetLabelHelp,
} from "./styled-components"
import NoMicPermissions from "./NoMicPermissions"
import Placeholder from "./Placeholder"
import {
  BAR_GAP,
  BAR_RADIUS,
  BAR_WIDTH,
  CURSOR_WIDTH,
  STARTING_TIME_STRING,
  WAVEFORM_PADDING,
} from "./constants"
import formatTime from "./formatTime"
import AudioInputActionButtons from "./AudioInputActionButtons"
import convertAudioToWav from "./convertAudioToWav"
import AudioInputErrorState from "./AudioInputErrorState"

export interface Props {
  element: AudioInputProto
  uploadClient: FileUploadClient
  widgetMgr: WidgetStateManager
  fragmentId?: string
  disabled: boolean
}

const AudioInput: React.FC<Props> = ({
  element,
  uploadClient,
  widgetMgr,
  fragmentId,
  disabled,
}): ReactElement => {
  const theme = useTheme()
  const previousTheme = usePrevious(theme)
  const [wavesurfer, setWavesurfer] = useState<WaveSurfer | null>(null)
  const waveSurferRef = React.useRef<HTMLDivElement | null>(null)
  const [deleteFileUrl, setDeleteFileUrl] = useWidgetManagerElementState<
    string | null
  >({
    widgetMgr,
    id: element.id,
    key: "deleteFileUrl",
    defaultValue: null,
  })
  const [recordPlugin, setRecordPlugin] = useState<RecordPlugin | null>(null)
  // to eventually show the user the available audio devices
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [availableAudioDevices, setAvailableAudioDevices] = useState<
    MediaDeviceInfo[]
  >([])
  const [activeAudioDeviceId, setActiveAudioDeviceId] = useState<
    string | null
  >(null)

  const [recordingUrl, setRecordingUrl] = useWidgetManagerElementState<
    string | null
  >({
    widgetMgr,
    id: element.id,
    key: "recordingUrl",
    defaultValue: null,
  })
  const [, setRerender] = useState(0)
  const forceRerender = (): void => {
    setRerender(prev => prev + 1)
  }
  const [progressTime, setProgressTime] = useState(STARTING_TIME_STRING)

  const [recordingTime, setRecordingTime] =
    useWidgetManagerElementState<string>({
      widgetMgr,
      id: element.id,
      formId: element.formId,
      key: "recordingTime",
      defaultValue: STARTING_TIME_STRING,
    })

  const [shouldUpdatePlaybackTime, setShouldUpdatePlaybackTime] =
    useState(false)
  const [hasNoMicPermissions, setHasNoMicPermissions] = useState(false)
  const [hasRequestedMicPermissions, setHasRequestedMicPermissions] =
    useState(false)
  const [isUploading, setIsUploading] = useState(false)
  const [isError, setIsError] = useState(false)

  const widgetId = element.id
  const widgetFormId = element.formId

  const transcodeAndUploadFile = useCallback(
    async (blob: Blob) => {
      setIsUploading(true)
      if (notNullOrUndefined(widgetFormId))
        widgetMgr.setFormsWithUploadsInProgress(new Set([widgetFormId]))

      let wavBlob: Blob | undefined = undefined

      if (blob.type === "audio/wav") {
        wavBlob = blob
      } else {
        wavBlob = await convertAudioToWav(blob)
      }

      if (!wavBlob) {
        setIsError(true)
        return
      }

      const url = URL.createObjectURL(wavBlob)
      const timestamp = new Date().toISOString().slice(0, 16).replace(":", "-")
      const file = new File([wavBlob], `${timestamp}_audio.wav`, {
        type: wavBlob.type,
      })

      setRecordingUrl(url)

      uploadFiles({
        files: [file],
        uploadClient,
        widgetMgr,
        widgetInfo: { id: widgetId, formId: widgetFormId },
        fragmentId,
      })
        .then(({ successfulUploads, failedUploads }) => {
          if (failedUploads.length > 0) {
            setIsError(true)
            return
          }
          const upload = successfulUploads[0]
          if (upload && upload.fileUrl.deleteUrl) {
            setDeleteFileUrl(upload.fileUrl.deleteUrl)
          }
        })
        .finally(() => {
          if (notNullOrUndefined(widgetFormId))
            widgetMgr.setFormsWithUploadsInProgress(new Set())

          setIsUploading(false)
        })
    },
    [
      setRecordingUrl,
      uploadClient,
      widgetMgr,
      widgetId,
      widgetFormId,
      fragmentId,
      setDeleteFileUrl,
    ]
  )

  const handleClear = useCallback(
    ({
      updateWidgetManager,
      deleteFile,
    }: {
      updateWidgetManager: boolean
      deleteFile: boolean
    }) => {
      if (isNullOrUndefined(wavesurfer) || isNullOrUndefined(deleteFileUrl)) {
        return
      }
      setRecordingUrl(null)
      wavesurfer.empty()
      if (deleteFile) {
        uploadClient.deleteFile(deleteFileUrl)
      }
      setDeleteFileUrl(null)
      setProgressTime(STARTING_TIME_STRING)
      setRecordingTime(STARTING_TIME_STRING)
      if (updateWidgetManager) {
        widgetMgr.setFileUploaderStateValue(
          element,
          {},
          { fromUi: true },
          fragmentId
        )
      }
      setShouldUpdatePlaybackTime(false)
      if (notNullOrUndefined(recordingUrl)) {
        URL.revokeObjectURL(recordingUrl)
      }
    },
    [
      deleteFileUrl,
      recordingUrl,
      uploadClient,
      wavesurfer,
      element,
      widgetMgr,
      fragmentId,
      setRecordingTime,
      setRecordingUrl,
      setDeleteFileUrl,
    ]
  )

  useEffect(() => {
    if (isNullOrUndefined(widgetFormId)) return

    const formClearHelper = new FormClearHelper()
    formClearHelper.manageFormClearListener(widgetMgr, widgetFormId, () =>
      handleClear({ updateWidgetManager: true, deleteFile: false })
    )

    return () => formClearHelper.disconnect()
  }, [widgetFormId, handleClear, widgetMgr])

  const initializeWaveSurfer = useCallback(() => {
    if (waveSurferRef.current === null) return

    const ws = WaveSurfer.create({
      container: waveSurferRef.current,
      waveColor: recordingUrl
        ? blend(theme.colors.fadedText40, theme.colors.secondaryBg)
        : theme.colors.primary,
      progressColor: theme.colors.bodyText,
      height:
        convertRemToPx(theme.sizes.largestElementHeight) -
        2 * WAVEFORM_PADDING,
      barWidth: BAR_WIDTH,
      barGap: BAR_GAP,
      barRadius: BAR_RADIUS,
      cursorWidth: CURSOR_WIDTH,
      url: recordingUrl ?? undefined,
    })

    ws.on("timeupdate", time => {
      setProgressTime(formatTime(time * 1000)) // get from seconds to milliseconds
    })

    ws.on("pause", () => {
      forceRerender()
    })

    const rp = ws.registerPlugin(
      RecordPlugin.create({
        scrollingWaveform: false,
        renderRecordedAudio: true,
      })
    )

    rp.on("record-end", async blob => {
      transcodeAndUploadFile(blob)
    })

    rp.on("record-progress", time => {
      setRecordingTime(formatTime(time))
    })

    setWavesurfer(ws)
    setRecordPlugin(rp)

    return () => {
      if (ws) ws.destroy()
      if (rp) rp.destroy()
    }
    // note: intentionally excluding theme so that we don't have to recreate the wavesurfer instance
    // and colors will be updated separately
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [transcodeAndUploadFile])

  useEffect(() => initializeWaveSurfer(), [initializeWaveSurfer])

  useEffect(() => {
    if (!isEqual(previousTheme, theme)) {
      wavesurfer?.setOptions({
        waveColor: recordingUrl
          ? blend(theme.colors.fadedText40, theme.colors.secondaryBg)
          : theme.colors.primary,
        progressColor: theme.colors.bodyText,
      })
    }
  }, [theme, previousTheme, recordingUrl, wavesurfer])

  const onClickPlayPause = useCallback(() => {
    if (wavesurfer) {
      wavesurfer.playPause()
      // This is because we want the time to be the duration of the audio when they stop recording,
      // but once they start playing it, we want it to be the current time. So, once they start playing it
      // we'll start keeping track of the playback time from that point onwards (until re-recording).
      setShouldUpdatePlaybackTime(true)
      // despite the state change above, this is still needed to force a rerender and make the time styling work
      forceRerender()
    }
  }, [wavesurfer])

  const startRecording = useCallback(async () => {
    let audioDeviceId = activeAudioDeviceId

    if (!hasRequestedMicPermissions) {
      // this first part is to ensure we prompt for getting the user's media devices
      await navigator.mediaDevices
        .getUserMedia({ audio: true })
        .then(() =>
          RecordPlugin.getAvailableAudioDevices().then(devices => {
            setAvailableAudioDevices(devices)
            if (devices.length > 0) {
              const { deviceId } = devices[0]
              setActiveAudioDeviceId(deviceId)
              audioDeviceId = deviceId
            }
          })
        )
        .catch(_err => {
          setHasNoMicPermissions(true)
        })
      setHasRequestedMicPermissions(true)
    }

    if (!recordPlugin || !audioDeviceId || !wavesurfer) {
      return
    }

    wavesurfer.setOptions({
      waveColor: theme.colors.primary,
    })

    if (recordingUrl) {
      handleClear({ updateWidgetManager: false, deleteFile: true })
    }

    recordPlugin.startRecording({ deviceId: audioDeviceId }).then(() => {
      // Update the record button to show the user that they can stop recording
      forceRerender()
    })
  }, [
    activeAudioDeviceId,
    recordPlugin,
    theme,
    wavesurfer,
    recordingUrl,
    handleClear,
    hasRequestedMicPermissions,
  ])

  const stopRecording = useCallback(() => {
    if (!recordPlugin) return

    recordPlugin.stopRecording()

    wavesurfer?.setOptions({
      // We are blending this color instead of directly using the theme color (fadedText40)
      // because the "faded" part of fadedText40 means introducing some transparency, which
      // causes problems with the progress waveform color because wavesurfer is choosing to
      // tint the waveColor with the progressColor instead of directly setting the progressColor.
      // This means that the low opacity of fadedText40 causes the progress waveform to
      // have the same opacity which makes it impossible to darken it enough to match designs.
      // We fix this by blending the colors to figure out what the resulting color should be at
      // full opacity, and we usee that color to set the waveColor.
      waveColor: blend(theme.colors.fadedText40, theme.colors.secondaryBg),
    })
  }, [recordPlugin, wavesurfer, theme])

  const downloadRecording = useDownloadUrl(recordingUrl, "recording.wav")

  const isRecording = Boolean(recordPlugin?.isRecording())
  const isPlaying = Boolean(wavesurfer?.isPlaying())

  const isPlayingOrRecording = isRecording || isPlaying
  const showPlaceholder = !isRecording && !recordingUrl && !hasNoMicPermissions

  const showNoMicPermissionsOrPlaceholderOrError =
    hasNoMicPermissions || showPlaceholder || isError

  const isDisabled = disabled || hasNoMicPermissions

  return (
    <StyledAudioInputContainerDiv
      className="stAudioInput"
      data-testid="stAudioInput"
    >
      <WidgetLabel
        label={element.label}
        disabled={isDisabled}
        labelVisibility={labelVisibilityProtoValueToEnum(
          element.labelVisibility?.value
        )}
      >
        {element.help && (
          <StyledWidgetLabelHelp>
            <TooltipIcon content={element.help} placement={Placement.TOP} />
          </StyledWidgetLabelHelp>
        )}
      </WidgetLabel>
      <StyledWaveformContainerDiv>
        <Toolbar
          isFullScreen={false}
          disableFullscreenMode={true}
          target={StyledWaveformContainerDiv}
        >
          {recordingUrl && (
            <ToolbarAction
              label="Download as WAV"
              icon={FileDownload}
              onClick={() => downloadRecording()}
            />
          )}
          {deleteFileUrl && (
            <ToolbarAction
              label="Clear recording"
              icon={Delete}
              onClick={() =>
                handleClear({ updateWidgetManager: true, deleteFile: true })
              }
            />
          )}
        </Toolbar>
        <AudioInputActionButtons
          isRecording={isRecording}
          isPlaying={isPlaying}
          isUploading={isUploading}
          isError={isError}
          recordingUrlExists={Boolean(recordingUrl)}
          startRecording={startRecording}
          stopRecording={stopRecording}
          onClickPlayPause={onClickPlayPause}
          onClear={() => {
            handleClear({ updateWidgetManager: false, deleteFile: true })
            setIsError(false)
          }}
          disabled={isDisabled}
        />
        <StyledWaveformInnerDiv>
          {isError && <AudioInputErrorState />}
          {showPlaceholder && <Placeholder />}
          {hasNoMicPermissions && <NoMicPermissions />}
          <StyledWaveSurferDiv
            data-testid="stAudioInputWaveSurfer"
            ref={waveSurferRef}
            show={!showNoMicPermissionsOrPlaceholderOrError}
          />
        </StyledWaveformInnerDiv>
        <StyledWaveformTimeCode
          isPlayingOrRecording={isPlayingOrRecording}
          data-testid="stAudioInputWaveformTimeCode"
        >
          {shouldUpdatePlaybackTime ? progressTime : recordingTime}
        </StyledWaveformTimeCode>
      </StyledWaveformContainerDiv>
    </StyledAudioInputContainerDiv>
  )
}

export default memo(AudioInput)


================================================
File: /frontend/lib/src/components/widgets/AudioInput/AudioInputActionButtons.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"

import AudioInputActionButtons, {
  AudioInputActionButtonProps,
} from "./AudioInputActionButtons"

const getProps = (): AudioInputActionButtonProps => ({
  disabled: false,
  isRecording: false,
  isPlaying: false,
  isUploading: false,
  recordingUrlExists: false,
  isError: false,
  startRecording: vi.fn(),
  stopRecording: vi.fn(),
  onClickPlayPause: vi.fn(),
  onClear: vi.fn(),
})

describe("AudioInputActionButton", () => {
  it("should render without crashing", () => {
    render(<AudioInputActionButtons {...getProps()} />)

    expect(screen.getByTestId("stAudioInputActionButton")).toBeInTheDocument()
  })

  it("should start recording when recording button is pressed", async () => {
    const user = userEvent.setup()
    const startRecording = vi.fn()
    render(
      <AudioInputActionButtons
        {...getProps()}
        startRecording={startRecording}
      />
    )

    expect(screen.getByLabelText("Record")).toBeInTheDocument()
    await user.click(screen.getByLabelText("Record"))
    expect(startRecording).toHaveBeenCalled()
  })

  it("should stop recording when recording button is pressed", async () => {
    const user = userEvent.setup()
    const stopRecording = vi.fn()
    render(
      <AudioInputActionButtons
        {...getProps()}
        isRecording={true}
        stopRecording={stopRecording}
      />
    )

    expect(screen.getByLabelText("Stop recording")).toBeInTheDocument()
    await user.click(screen.getByLabelText("Stop recording"))
    expect(stopRecording).toHaveBeenCalled()
  })

  it("should play when play button is pressed", async () => {
    const user = userEvent.setup()
    const onClickPlayPause = vi.fn()
    render(
      <AudioInputActionButtons
        {...getProps()}
        recordingUrlExists={true}
        onClickPlayPause={onClickPlayPause}
      />
    )

    expect(screen.getByLabelText("Record")).toBeInTheDocument()
    expect(screen.getByLabelText("Play")).toBeInTheDocument()
    await user.click(screen.getByLabelText("Play"))
    expect(onClickPlayPause).toHaveBeenCalled()
  })

  it("should pause when pause button is pressed", async () => {
    const user = userEvent.setup()
    const onClickPlayPause = vi.fn()
    render(
      <AudioInputActionButtons
        {...getProps()}
        isPlaying={true}
        recordingUrlExists={true}
        onClickPlayPause={onClickPlayPause}
      />
    )

    expect(screen.getByLabelText("Record")).toBeInTheDocument()
    expect(screen.getByLabelText("Pause")).toBeInTheDocument()
    await user.click(screen.getByLabelText("Pause"))
    expect(onClickPlayPause).toHaveBeenCalled()
  })

  describe("when disabled", () => {
    it("should not start recording when recording button is pressed", async () => {
      const user = userEvent.setup()
      const startRecording = vi.fn()
      render(
        <AudioInputActionButtons
          {...getProps()}
          disabled={true}
          startRecording={startRecording}
        />
      )

      expect(screen.getByLabelText("Record")).toBeInTheDocument()
      await user.click(screen.getByLabelText("Record"))
      expect(startRecording).not.toHaveBeenCalled()
    })
  })

  describe("when uploading", () => {
    it("should render the uploading spinner", () => {
      render(<AudioInputActionButtons {...getProps()} isUploading={true} />)

      expect(screen.getByLabelText("Uploading")).toBeInTheDocument()
    })
  })

  describe("when error", () => {
    it("should render the error message", () => {
      render(<AudioInputActionButtons {...getProps()} isError={true} />)

      expect(screen.getByLabelText("Reset")).toBeInTheDocument()
    })
  })
})


================================================
File: /frontend/lib/src/components/widgets/AudioInput/AudioInputActionButtons.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { memo } from "react"

import { Mic } from "@emotion-icons/material-outlined"
import {
  Pause,
  PlayArrow,
  Refresh,
  StopCircle,
} from "@emotion-icons/material-rounded"
import { EmotionIcon } from "@emotion-icons/emotion-icon"

import BaseButton, {
  BaseButtonKind,
} from "@streamlit/lib/src/components/shared/BaseButton"
import Icon from "@streamlit/lib/src/components/shared/Icon"

import {
  StyledActionButtonContainerDiv,
  StyledActionButtonPlayPauseDiv,
  StyledActionButtonStartRecordingDiv,
  StyledActionButtonStopRecordingDiv,
  StyledSpinner,
} from "./styled-components"

interface BaseActionButtonProps {
  onClick: () => void
  disabled: boolean
  ariaLabel: string
  iconContent: EmotionIcon
}

const ActionButton: React.FC<BaseActionButtonProps> = ({
  onClick,
  disabled,
  ariaLabel,
  iconContent,
}) => (
  <BaseButton
    kind={BaseButtonKind.BORDERLESS_ICON}
    onClick={onClick}
    disabled={disabled}
    aria-label={ariaLabel}
    fluidWidth
    data-testid="stAudioInputActionButton"
  >
    <Icon content={iconContent} size="lg" color="inherit" />
  </BaseButton>
)

export interface AudioInputActionButtonProps {
  disabled: boolean
  isRecording: boolean
  isPlaying: boolean
  isUploading: boolean
  isError: boolean
  recordingUrlExists: boolean
  startRecording(): void
  stopRecording(): void
  onClickPlayPause(): void
  onClear(): void
}

interface AudioInputStopRecordingButtonProps {
  disabled: boolean
  stopRecording(): void
}

interface AudioInputPlayPauseButtonProps {
  disabled: boolean
  isPlaying: boolean
  onClickPlayPause(): void
}

interface AudioInputStartRecordingButtonProps {
  disabled: boolean
  startRecording(): void
}

interface AudioInputResetButtonProps {
  onClick(): void
}

export const AudioInputStopRecordingButton: React.FC<
  AudioInputStopRecordingButtonProps
> = ({ disabled, stopRecording }) => (
  <StyledActionButtonStopRecordingDiv>
    <ActionButton
      onClick={stopRecording}
      disabled={disabled}
      ariaLabel="Stop recording"
      iconContent={StopCircle}
    />
  </StyledActionButtonStopRecordingDiv>
)

export const AudioInputPlayPauseButton: React.FC<
  AudioInputPlayPauseButtonProps
> = ({ disabled, isPlaying, onClickPlayPause }) => {
  return (
    <StyledActionButtonPlayPauseDiv>
      {isPlaying ? (
        <ActionButton
          onClick={onClickPlayPause}
          disabled={disabled}
          ariaLabel="Pause"
          iconContent={Pause}
        />
      ) : (
        <ActionButton
          onClick={onClickPlayPause}
          disabled={disabled}
          ariaLabel="Play"
          iconContent={PlayArrow}
        />
      )}
    </StyledActionButtonPlayPauseDiv>
  )
}

export const AudioInputStartRecordingButton: React.FC<
  AudioInputStartRecordingButtonProps
> = ({ disabled, startRecording }) => (
  <StyledActionButtonStartRecordingDiv>
    <ActionButton
      onClick={startRecording}
      disabled={disabled}
      ariaLabel="Record"
      iconContent={Mic}
    />
  </StyledActionButtonStartRecordingDiv>
)

export const AudioInputResetButton: React.FC<AudioInputResetButtonProps> = ({
  onClick,
}) => (
  <StyledActionButtonPlayPauseDiv>
    <ActionButton
      disabled={false}
      onClick={onClick}
      ariaLabel="Reset"
      iconContent={Refresh}
    />
  </StyledActionButtonPlayPauseDiv>
)

const AudioInputActionButtons: React.FC<AudioInputActionButtonProps> = ({
  disabled,
  isRecording,
  isPlaying,
  isUploading,
  isError,
  recordingUrlExists,
  startRecording,
  stopRecording,
  onClickPlayPause,
  onClear,
}) => {
  if (isError) {
    return (
      <StyledActionButtonContainerDiv>
        <AudioInputResetButton onClick={onClear} />
      </StyledActionButtonContainerDiv>
    )
  }

  if (isUploading) {
    return (
      <StyledActionButtonContainerDiv>
        <StyledSpinner aria-label="Uploading" />
      </StyledActionButtonContainerDiv>
    )
  }

  return (
    <StyledActionButtonContainerDiv>
      {isRecording ? (
        <AudioInputStopRecordingButton
          disabled={disabled}
          stopRecording={stopRecording}
        />
      ) : (
        <AudioInputStartRecordingButton
          disabled={disabled}
          startRecording={startRecording}
        />
      )}
      {recordingUrlExists && (
        <AudioInputPlayPauseButton
          disabled={disabled}
          isPlaying={isPlaying}
          onClickPlayPause={onClickPlayPause}
        />
      )}
    </StyledActionButtonContainerDiv>
  )
}

export default memo(AudioInputActionButtons)


================================================
File: /frontend/lib/src/components/widgets/AudioInput/AudioInputErrorState.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import {
  StyledErrorContainerDiv,
  StyledErrorTextSpan,
} from "./styled-components"

const AudioInputErrorState = (): ReactElement => {
  return (
    <StyledErrorContainerDiv>
      <StyledErrorTextSpan>
        An error has occurred, please try again.
      </StyledErrorTextSpan>
    </StyledErrorContainerDiv>
  )
}

export default AudioInputErrorState


================================================
File: /frontend/lib/src/components/widgets/AudioInput/NoMicPermissions.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { ENABLE_PERIPHERALS_DOCS_URL } from "@streamlit/lib/src/urls"

import {
  StyledErrorContainerDiv,
  StyledErrorTextSpan,
  StyledNoMicInputLearnMoreLink,
} from "./styled-components"

const NoMicPermissions = (): ReactElement => {
  return (
    <StyledErrorContainerDiv>
      <StyledErrorTextSpan>
        This app would like to use your microphone.
      </StyledErrorTextSpan>{" "}
      <StyledNoMicInputLearnMoreLink href={ENABLE_PERIPHERALS_DOCS_URL}>
        Learn how to allow access.
      </StyledNoMicInputLearnMoreLink>
    </StyledErrorContainerDiv>
  )
}

export default NoMicPermissions


================================================
File: /frontend/lib/src/components/widgets/AudioInput/Placeholder.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import {
  StyledPlaceholderContainerDiv,
  StyledPlaceholderDotsDiv,
} from "./styled-components"

const Placeholder = (): ReactElement => {
  return (
    <StyledPlaceholderContainerDiv>
      <StyledPlaceholderDotsDiv />
    </StyledPlaceholderContainerDiv>
  )
}

export default Placeholder


================================================
File: /frontend/lib/src/components/widgets/AudioInput/constants.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export const WAVEFORM_PADDING = 4
export const BAR_WIDTH = 4
export const BAR_GAP = 4
export const BAR_RADIUS = 8
export const CURSOR_WIDTH = 0

export const STARTING_TIME_STRING = "00:00"


================================================
File: /frontend/lib/src/components/widgets/AudioInput/convertAudioToWav.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
// code in this file was adapted from recorder.js library

import { logError } from "@streamlit/lib/src/util/log"

/**
 * Converts a file Blob (audio/video) to a WAV Blob.
 * @param fileBlob - The input file as a Blob.
 * @returns - A Promise resolving with the WAV file as a Blob.
 */
async function convertFileToWav(fileBlob: Blob): Promise<Blob | undefined> {
  const audioContext = new window.AudioContext()
  const arrayBuffer = await fileBlob.arrayBuffer()

  let audioBuffer: AudioBuffer
  try {
    audioBuffer = await audioContext.decodeAudioData(arrayBuffer)
  } catch (error) {
    logError(error)
    return undefined // Return undefined if decoding fails
  }

  const HEADER_HEIGHT = 44
  const numOfChan = audioBuffer.numberOfChannels
  const sampleRate = audioBuffer.sampleRate
  const length = audioBuffer.length * numOfChan * 2 + HEADER_HEIGHT
  const buffer = new ArrayBuffer(length)
  const view = new DataView(buffer)

  // WAV header metadata
  const wavHeader = {
    0: { type: "string", value: "RIFF" },
    4: { type: "uint32", value: length - 8 },
    8: { type: "string", value: "WAVE" },
    12: { type: "string", value: "fmt " },
    16: { type: "uint32", value: 16 }, // PCM format
    20: { type: "uint16", value: 1 }, // PCM format code
    22: { type: "uint16", value: numOfChan }, // Number of channels
    24: { type: "uint32", value: sampleRate }, // Sample rate
    28: { type: "uint32", value: sampleRate * numOfChan * 2 }, // Byte rate
    32: { type: "uint16", value: numOfChan * 2 }, // Block align
    34: { type: "uint16", value: 16 }, // Bits per sample (16-bit)
    36: { type: "string", value: "data" },
    40: { type: "uint32", value: audioBuffer.length * numOfChan * 2 }, // Data chunk length
  }

  // Write WAV header from the dictionary using Object.entries
  Object.entries(wavHeader).forEach(([offset, { type, value }]) => {
    const intOffset = parseInt(offset, 10)
    if (type === "string") {
      writeString(view, intOffset, value as string)
    } else if (type === "uint32") {
      view.setUint32(intOffset, value as number, true)
    } else if (type === "uint16") {
      view.setUint16(intOffset, value as number, true)
    }
  })

  // Write PCM data
  let offset = HEADER_HEIGHT
  for (let i = 0; i < audioBuffer.length; i++) {
