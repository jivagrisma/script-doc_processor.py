        // No need to reconstruct something.
        return
      }

      editingState.current.fromJson(initialWidgetValue, originalColumns)
      setNumRows(editingState.current.getNumRows())
    },
    // We only want to run this effect once during the initial component load
    // so we disable the eslint rule.
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  )

  const { getCellContent: getOriginalCellContent } = useDataLoader(
    data,
    originalColumns,
    numRows,
    editingState
  )

  const { columns, sortColumn, getOriginalIndex, getCellContent } =
    useColumnSort(originalNumRows, originalColumns, getOriginalCellContent)

  /**
   * Synchronizes the selection state with the state of the widget state of the component.
   * This might also send a rerun message to the backend if the selection state has changed.
   *
   * This is the inner version to be used by the debounce callback below.
   * Its split out to allow better dependency inspection.
   *
   * @param newSelection - The new selection state
   */
  const innerSyncSelectionState = React.useCallback(
    (newSelection: GridSelection) => {
      // If we want to support selections also with the editable mode,
      // we would need to integrate the `syncEditState` and `syncSelections` functions
      // into a single function that updates the widget state with both the editing
      // state and the selection state.

      const selectionState: DataframeState = {
        selection: {
          rows: [] as number[],
          columns: [] as string[],
        },
      }

      selectionState.selection.rows = newSelection.rows.toArray().map(row => {
        return getOriginalIndex(row)
      })
      selectionState.selection.columns = newSelection.columns
        .toArray()
        .map(columnIdx => {
          return getColumnName(columns[columnIdx])
        })
      const newWidgetState = JSON.stringify(selectionState)
      const currentWidgetState = widgetMgr.getStringValue({
        id: element.id,
        formId: element.formId,
      } as WidgetInfo)

      // Only update if there is actually a difference to the previous selection state
      if (
        currentWidgetState === undefined ||
        currentWidgetState !== newWidgetState
      ) {
        widgetMgr.setStringValue(
          {
            id: element.id,
            formId: element.formId,
          } as WidgetInfo,
          newWidgetState,
          {
            fromUi: true,
          },
          fragmentId
        )
      }
    },
    [
      columns,
      element.id,
      element.formId,
      widgetMgr,
      fragmentId,
      getOriginalIndex,
    ]
  )

  // Use a debounce to prevent rapid updates to the widget state.
  const { debouncedCallback: syncSelectionState } = useDebouncedCallback(
    innerSyncSelectionState,
    DEBOUNCE_TIME_MS
  )

  const {
    gridSelection,
    isRowSelectionActivated,
    isMultiRowSelectionActivated,
    isColumnSelectionActivated,
    isMultiColumnSelectionActivated,
    isRowSelected,
    isColumnSelected,
    isCellSelected,
    clearSelection,
    processSelectionChange,
  } = useSelectionHandler(
    element,
    isEmptyTable,
    disabled,
    columns,
    syncSelectionState
  )

  React.useEffect(() => {
    // Clear cell selections if fullscreen mode changes
    // but keep row & column selections.
    // In the past we saw some weird side-effects, so we decided to clean
    // it when entering fullscreen-mode. If we decide to change this, we have
    // to play around and get to the bottom of it.
    clearSelection(true, true)
    // Only run this on changes to the fullscreen mode:
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isFullScreen])

  // This callback is used to refresh the rendering of specified cells
  const refreshCells = React.useCallback(
    (
      cells: {
        cell: GridCellPosition
      }[]
    ) => {
      dataEditorRef.current?.updateCells(cells)
    },
    []
  )

  /**
   * On the first rendering, try to load initial selection state
   * from the widget state if it exists. This is required in the
   * case that other elements are inserted before this widget.
   *
   * This effect needs to run after the fullscreen effect that
   * clears cell selections, since both modify the same state object.
   */
  React.useEffect(
    () => {
      if (!isRowSelectionActivated && !isColumnSelectionActivated) {
        // Only run this if selections are activated.
        return
      }

      const initialWidgetValue = widgetMgr.getStringValue({
        id: element.id,
        formId: element.formId,
      } as WidgetInfo)

      if (initialWidgetValue) {
        const columnNames: string[] = columns.map(column => {
          return getColumnName(column)
        })

        const selectionState: DataframeState = JSON.parse(initialWidgetValue)

        let rowSelection = CompactSelection.empty()
        let columnSelection = CompactSelection.empty()

        selectionState.selection?.rows?.forEach(row => {
          rowSelection = rowSelection.add(row)
        })

        selectionState.selection?.columns?.forEach(column => {
          columnSelection = columnSelection.add(columnNames.indexOf(column))
        })

        if (rowSelection.length > 0 || columnSelection.length > 0) {
          // Update the initial selection state if something was selected
          const initialSelection: GridSelection = {
            rows: rowSelection,
            columns: columnSelection,
            current: undefined,
          }
          processSelectionChange(initialSelection)
        }
      }
    },
    // We only want to run this effect once during the initial component load
    // so we disable the eslint rule.
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  )

  /**
   * This callback is used to update the number of rows based
   * on the latest editing state. This is required to keep the
   * component state in sync with the editing state.
   */
  const updateNumRows = React.useCallback(() => {
    if (numRows !== editingState.current.getNumRows()) {
      // Reset the number of rows if it has been changed in the editing state
      setNumRows(editingState.current.getNumRows())
    }
  }, [numRows])

  /**
   * This callback is used to synchronize the editing state with
   * the widget state of the component. This might also send a rerun message
   * to the backend if the editing state has changed.
   *
   * This is the inner version to be used by the debounce callback below.
   * Its split out to allow better dependency inspection.
   */
  const innerSyncEditState = React.useCallback(() => {
    const currentEditingState = editingState.current.toJson(columns)
    let currentWidgetState = widgetMgr.getStringValue({
      id: element.id,
      formId: element.formId,
    } as WidgetInfo)

    if (currentWidgetState === undefined) {
      // Create an empty widget state
      currentWidgetState = new EditingState(0).toJson([])
    }

    // Only update if there is actually a difference between editing and widget state
    if (currentEditingState !== currentWidgetState) {
      widgetMgr.setStringValue(
        {
          id: element.id,
          formId: element.formId,
        } as WidgetInfo,
        currentEditingState,
        {
          fromUi: true,
        },
        fragmentId
      )
    }
  }, [columns, element.id, element.formId, widgetMgr, fragmentId])

  // Use a debounce to prevent rapid updates to the widget state.
  const { debouncedCallback: syncEditState } = useDebouncedCallback(
    innerSyncEditState,
    DEBOUNCE_TIME_MS
  )

  const { exportToCsv } = useDataExporter(
    getCellContent,
    columns,
    numRows,
    enforceDownloadInNewTab
  )

  const { onCellEdited, onPaste, onRowAppended, onDelete, validateCell } =
    useDataEditor(
      columns,
      element.editingMode !== DYNAMIC,
      editingState,
      getCellContent,
      getOriginalIndex,
      refreshCells,
      updateNumRows,
      syncEditState,
      clearSelection
    )

  const {
    tooltip,
    clearTooltip,
    onItemHovered: handleTooltips,
  } = useTooltips(columns, getCellContent)

  const { drawCell, customRenderers } = useCustomRenderer(columns)

  const transformedColumns = React.useMemo(
    () => columns.map(column => toGlideColumn(column)),
    [columns]
  )
  const { columns: glideColumns, onColumnResize } =
    useColumnSizer(transformedColumns)

  // To activate the group row feature (multi-level headers),
  // we need more than one header row.
  const usesGroupRow = data.dimensions.numHeaderRows > 1
  const {
    minHeight,
    maxHeight,
    minWidth,
    maxWidth,
    rowHeight,
    resizableSize,
    setResizableSize,
  } = useTableSizer(
    element,
    gridTheme,
    numRows,
    usesGroupRow,
    containerWidth,
    containerHeight,
    isFullScreen
  )

  // This is used as fallback in case the table is empty to
  // insert cells indicating this state:
  const getEmptyStateContent = React.useCallback(
    ([_col, _row]: readonly [number, number]): GridCell => {
      return {
        ...getTextCell(true, false),
        displayData: "empty",
        contentAlign: "center",
        allowOverlay: false,
        themeOverride: {
          textDark: gridTheme.glideTheme.textLight,
        },
        span: [0, Math.max(columns.length - 1, 0)],
      } as GridCell
    },
    [columns, gridTheme.glideTheme.textLight]
  )

  const onFormCleared = React.useCallback(() => {
    // Clear the editing state and the selection state
    resetEditingState()
    clearSelection()
  }, [resetEditingState, clearSelection])

  useFormClearHelper({ element, widgetMgr, onFormCleared })

  const isDynamicAndEditable =
    !isEmptyTable && element.editingMode === DYNAMIC && !disabled

  const { pinColumn, unpinColumn, freezeColumns } = useColumnPinning(
    columns,
    isEmptyTable,
    containerWidth,
    gridTheme.minColumnWidth,
    clearSelection,
    setColumnConfigMapping
  )

  const { onColumnMoved } = useColumnReordering(
    columns,
    freezeColumns,
    pinColumn,
    unpinColumn,
    setColumnOrder
  )

  // Determine if the table requires horizontal or vertical scrolling:
  React.useEffect(() => {
    // The setTimeout is a workaround to get the scroll area bounding box
    // after the grid has been rendered. Otherwise, the scroll area div
    // (dvn-stack) might not have been created yet.
    setTimeout(() => {
      if (resizableContainerRef.current && dataEditorRef.current) {
        // Get the bounds of the glide-data-grid scroll area (dvn-stack):
        const scrollAreaBounds = resizableContainerRef.current
          ?.querySelector(".dvn-stack")
          ?.getBoundingClientRect()

        // We might also be able to use the following as an alternative,
        // but it seems to cause "Maximum update depth exceeded" when scrollbars
        // are activated or deactivated.
        // const scrollAreaBounds = dataEditorRef.current?.getBounds()
        // Also see: https://github.com/glideapps/glide-data-grid/issues/784
        if (scrollAreaBounds) {
          setHasVerticalScroll(
            scrollAreaBounds.height >
              resizableContainerRef.current.clientHeight
          )
          setHasHorizontalScroll(
            scrollAreaBounds.width > resizableContainerRef.current.clientWidth
          )
        }
      }
    }, 1)
  }, [resizableSize, numRows, glideColumns])

  return (
    <StyledResizableContainer
      className="stDataFrame"
      data-testid="stDataFrame"
      hasCustomizedScrollbars={hasCustomizedScrollbars}
      ref={resizableContainerRef}
      onMouseDown={e => {
        if (resizableContainerRef.current && hasCustomizedScrollbars) {
          // Prevent clicks on the scrollbar handle to propagate to the grid:
          const boundingClient =
            resizableContainerRef.current.getBoundingClientRect()

          if (
            // For whatever reason, we are still able to use the scrollbars even
            // if the mouse is one pixel outside of the scrollbar. Therefore, we add
            // an additional pixel.
            hasHorizontalScroll &&
            boundingClient.height - (WEBKIT_SCROLLBAR_SIZE + 1) <
              e.clientY - boundingClient.top
          ) {
            e.stopPropagation()
          }
          if (
            hasVerticalScroll &&
            boundingClient.width - (WEBKIT_SCROLLBAR_SIZE + 1) <
              e.clientX - boundingClient.left
          ) {
            e.stopPropagation()
          }
        }
      }}
      onBlur={event => {
        // If the container loses focus, clear the current selection.
        // Touch screen devices have issues with this, so we don't clear
        // the selection on those devices.
        // We also don't want to clear the selection if the user clicks on
        // on the toolbar by checking that relatedTarget is not a children of
        // this element. Unfortunately, this check isn't working reliably in Safari.
        if (
          !isFocused &&
          !isTouchDevice &&
          !event.currentTarget.contains(
            event.relatedTarget as HTMLElement | null
          )
        ) {
          // Clear cell selections, but keep row & column selections.
          clearSelection(true, true)
        }
      }}
    >
      <Toolbar
        isFullScreen={isFullScreen}
        disableFullscreenMode={disableFullscreenMode}
        // Lock the toolbar in some specific situations:
        locked={
          (isRowSelected && !isRowSelectionActivated) ||
          isCellSelected ||
          (isTouchDevice && isFocused)
        }
        onExpand={expand}
        onCollapse={collapse}
        target={StyledResizableContainer}
      >
        {((isRowSelectionActivated && isRowSelected) ||
          (isColumnSelectionActivated && isColumnSelected)) && (
          // Add clear selection action if selections are active
          // and a valid selections currently exists. Cell selections
          // are not relevant since they are not synced to the backend
          // at the moment.
          <ToolbarAction
            label="Clear selection"
            icon={Close}
            onClick={() => {
              clearSelection()
              clearTooltip()
            }}
          />
        )}
        {isDynamicAndEditable && isRowSelected && (
          <ToolbarAction
            label="Delete row(s)"
            icon={Delete}
            onClick={() => {
              if (onDelete) {
                onDelete(gridSelection)
                clearTooltip()
              }
            }}
          />
        )}
        {isDynamicAndEditable && !isRowSelected && (
          <ToolbarAction
            label="Add row"
            icon={Add}
            onClick={() => {
              if (onRowAppended) {
                setIsFocused(true)
                onRowAppended()
                clearTooltip()
              }
            }}
          />
        )}
        {!isLargeTable && !isEmptyTable && (
          <ToolbarAction
            label="Download as CSV"
            icon={FileDownload}
            onClick={() => exportToCsv()}
          />
        )}
        {!isEmptyTable && (
          <ToolbarAction
            label="Search"
            icon={Search}
            onClick={() => {
              if (!showSearch) {
                setIsFocused(true)
                setShowSearch(true)
              } else {
                setShowSearch(false)
              }
              clearTooltip()
            }}
          />
        )}
      </Toolbar>
      <Resizable
        data-testid="stDataFrameResizable"
        ref={resizableRef}
        defaultSize={resizableSize}
        style={{
          border: `${gridTheme.tableBorderWidth}px solid ${gridTheme.glideTheme.borderColor}`,
          borderRadius: `${gridTheme.tableBorderRadius}`,
        }}
        minHeight={minHeight}
        maxHeight={maxHeight}
        minWidth={minWidth}
        maxWidth={maxWidth}
        size={resizableSize}
        enable={{
          top: false,
          right: false,
          bottom: false,
          left: false,
          topRight: false,
          bottomRight: true,
          bottomLeft: false,
          topLeft: false,
        }}
        grid={[1, rowHeight]}
        snapGap={rowHeight / 3}
        onResizeStop={(_event, _direction, _ref, _delta) => {
          if (resizableRef.current) {
            const borderThreshold = 2 * gridTheme.tableBorderWidth
            setResizableSize({
              width: resizableRef.current.size.width,
              height:
                // Add additional pixels if it is stretched to full width
                // to allow the full cell border to be visible
                maxHeight - resizableRef.current.size.height ===
                borderThreshold
                  ? resizableRef.current.size.height + borderThreshold
                  : resizableRef.current.size.height,
            })
          }
        }}
      >
        <GlideDataEditor
          // The className is used in styled components:
          className="stDataFrameGlideDataEditor"
          data-testid="stDataFrameGlideDataEditor"
          ref={dataEditorRef}
          columns={glideColumns}
          rows={isEmptyTable ? 1 : numRows}
          minColumnWidth={gridTheme.minColumnWidth}
          maxColumnWidth={gridTheme.maxColumnWidth}
          maxColumnAutoWidth={gridTheme.maxColumnAutoWidth}
          rowHeight={rowHeight}
          headerHeight={gridTheme.defaultHeaderHeight}
          getCellContent={isEmptyTable ? getEmptyStateContent : getCellContent}
          onColumnResize={isTouchDevice ? undefined : onColumnResize}
          // Configure resize indicator to only show on the header:
          resizeIndicator={"header"}
          // Freeze all index columns:
          freezeColumns={freezeColumns}
          smoothScrollX={true}
          smoothScrollY={true}
          // Show borders between cells:
          verticalBorder={true}
          // Activate copy to clipboard functionality:
          getCellsForSelection={true}
          // Deactivate row markers and numbers:
          rowMarkers={"none"}
          // Deactivate selections:
          rangeSelect={isTouchDevice ? "cell" : "rect"}
          columnSelect={"none"}
          rowSelect={"none"}
          // Enable interactive column reordering:
          onColumnMoved={
            // Column selection is not compatible with column reordering.
            isColumnSelectionActivated ? undefined : onColumnMoved
          }
          // Enable tooltips and row hovering theme on hover of a cell or column header:
          onItemHovered={(args: GridMouseEventArgs) => {
            handleRowHover?.(args)
            handleTooltips?.(args)
          }}
          // Activate keybindings:
          keybindings={{ downFill: true }}
          // Search needs to be activated manually, to support search
          // via the toolbar:
          onKeyDown={event => {
            if ((event.ctrlKey || event.metaKey) && event.key === "f") {
              setShowSearch(cv => !cv)
              event.stopPropagation()
              event.preventDefault()
            }
          }}
          showSearch={showSearch}
          onSearchClose={() => {
            setShowSearch(false)
            clearTooltip()
          }}
          // Header click is used for column sorting:
          onHeaderClicked={(colIndex: number, _event) => {
            if (isEmptyTable || isLargeTable || isColumnSelectionActivated) {
              // Deactivate sorting for empty state, for large dataframes, or
              // when column selection is activated.
              return
            }

            if (isRowSelectionActivated && isRowSelected) {
              // Keeping row selections when sorting columns is not supported at the moment.
              // So we need to clear the selection before we do the sorting.
              // The reason is that the user would expect the selection to be kept on
              // the same row after sorting, hover that would require us to map the selection
              // to the new index of the selected row which adds complexity.
              clearSelection()
            }
            sortColumn(colIndex)
          }}
          gridSelection={gridSelection}
          // We don't have to react to "onSelectionCleared" since
          // we already correctly process selections in
          // the "onGridSelectionChange" callback.
          onGridSelectionChange={(newSelection: GridSelection) => {
            // Only allow selection changes if the grid is focused.
            // This is mainly done because there is a bug when overlay click actions
            // are outside of the bounds of the table (e.g. select dropdown or date picker).
            // This results in the first cell being selected for a short period of time
            // But for touch devices, preventing this can cause issues to select cells.
            // So we allow selection changes for touch devices even when it is not focused.
            if (isFocused || isTouchDevice) {
              processSelectionChange(newSelection)
              if (tooltip !== undefined) {
                // Remove the tooltip on every grid selection change:
                clearTooltip()
              }
            }
          }}
          theme={gridTheme.glideTheme}
          getRowThemeOverride={getRowThemeOverride}
          onMouseMove={(args: GridMouseEventArgs) => {
            // Determine if the dataframe is focused or not
            if (args.kind === "out-of-bounds" && isFocused) {
              setIsFocused(false)
            } else if (args.kind !== "out-of-bounds" && !isFocused) {
              setIsFocused(true)
            }
          }}
          // Add shadow for index columns and header on scroll:
          fixedShadowX={true}
          fixedShadowY={true}
          experimental={{
            // We use overflow scrollbars, so we need to deactivate the native
            // scrollbar override:
            scrollbarWidthOverride: 0,
            ...(hasCustomizedScrollbars && {
              // Add negative padding to the right and bottom to allow the scrollbars in
              // webkit to overlay the table:
              paddingBottom: hasHorizontalScroll
                ? -WEBKIT_SCROLLBAR_SIZE
                : undefined,
              paddingRight: hasVerticalScroll
                ? -WEBKIT_SCROLLBAR_SIZE
                : undefined,
            }),
          }}
          // Apply custom rendering (e.g. for missing or required cells):
          drawCell={drawCell}
          // Add support for additional cells:
          customRenderers={customRenderers}
          // Custom image editor to render single images:
          imageEditorOverride={ImageCellEditor}
          // Add our custom SVG header icons:
          headerIcons={gridTheme.headerIcons}
          // Add support for user input validation:
          validateCell={validateCell}
          // The default setup is read only, and therefore we deactivate paste here:
          onPaste={false}
          // Activate features required for row selection:
          {...(isRowSelectionActivated && {
            rowMarkers: {
              // Apply style settings for the row markers column:
              kind: "checkbox",
              checkboxStyle: "square",
              theme: {
                bgCell: gridTheme.glideTheme.bgHeader,
                bgCellMedium: gridTheme.glideTheme.bgHeader,
              },
            },
            rowSelectionMode: isMultiRowSelectionActivated ? "multi" : "auto",
            rowSelect: disabled
              ? "none"
              : isMultiRowSelectionActivated
              ? "multi"
              : "single",
            rowSelectionBlending: "mixed",
            // Deactivate the combination of row selections
            // and cell selections. This will automatically clear
            // selected cells when a row is selected.
            // We are doing this to prevent some issues with drag
            // and drop selection.
            rangeSelectionBlending: "exclusive",
          })}
          // Activate features required for column selection:
          {...(isColumnSelectionActivated && {
            columnSelect: disabled
              ? "none"
              : isMultiColumnSelectionActivated
              ? "multi"
              : "single",
            columnSelectionBlending: "mixed",
            // Deactivate the combination of column selections
            // and cell selections. This will automatically clear
            // selected cells when a column is selected.
            // We are doing this to prevent some issues with drag
            // and drop selection.
            rangeSelectionBlending: "exclusive",
          })}
          // If element is editable, enable editing features:
          {...(!isEmptyTable &&
            element.editingMode !== READ_ONLY &&
            !disabled && {
              // Support fill handle for bulk editing:
              fillHandle: !isTouchDevice,
              // Support editing:
              onCellEdited,
              // Support pasting data for bulk editing:
              onPaste,
              // Support deleting cells & rows:
              onDelete,
            })}
          // If element is dynamic, enable adding & deleting rows:
          {...(!isEmptyTable &&
            element.editingMode === DYNAMIC && {
              // Support adding rows:
              trailingRowOptions: {
                sticky: false,
                tint: true,
              },
              rowMarkers: {
                kind: "checkbox",
                checkboxStyle: "square",
                theme: {
                  bgCell: gridTheme.glideTheme.bgHeader,
                  bgCellMedium: gridTheme.glideTheme.bgHeader,
                },
              },
              rowSelectionMode: "multi",
              rowSelect: disabled ? "none" : "multi",
              // Support adding rows:
              onRowAppended: disabled ? undefined : onRowAppended,
              // Deactivate sorting, since it is not supported with dynamic editing:
              onHeaderClicked: undefined,
            })}
        />
      </Resizable>
      {tooltip && tooltip.content && (
        <Tooltip
          top={tooltip.top}
          left={tooltip.left}
          content={tooltip.content}
          clearTooltip={clearTooltip}
        ></Tooltip>
      )}
    </StyledResizableContainer>
  )
}

export default withFullScreenWrapper(DataFrame)


================================================
File: /frontend/lib/src/components/widgets/DataFrame/EditingState.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCell, GridCellKind, TextCell } from "@glideapps/glide-data-grid"

import {
  BaseColumnProps,
  TextColumn,
} from "@streamlit/lib/src/components/widgets/DataFrame/columns"

import EditingState from "./EditingState"

const MOCK_TEXT_CELL_1: TextCell = {
  kind: GridCellKind.Text,
  displayData: "foo",
  data: "foo",
  allowOverlay: true,
}

const MOCK_TEXT_CELL_2: TextCell = {
  kind: GridCellKind.Text,
  displayData: "foo",
  data: "foo",
  allowOverlay: true,
}

const MOCK_TEXT_MISSING_CELL = {
  kind: GridCellKind.Text,
  displayData: "",
  data: "",
  isMissingValue: true,
  allowOverlay: true,
} as TextCell

describe("EditingState class", () => {
  it("allows to set edited cells", () => {
    const NUM_OF_ROWS = 3
    const editingState = new EditingState(NUM_OF_ROWS)
    editingState.setCell(0, 0, MOCK_TEXT_CELL_1)
    expect(editingState.getCell(0, 0)).toEqual(MOCK_TEXT_CELL_1)
    expect(editingState.getCell(1, 1)).toEqual(undefined)

    // Overwrite cell
    editingState.setCell(0, 0, MOCK_TEXT_CELL_2)
    expect(editingState.getCell(0, 0)).toEqual(MOCK_TEXT_CELL_2)
  })

  it("allows to add rows", () => {
    const NUM_OF_ROWS = 3
    const editingState = new EditingState(NUM_OF_ROWS)

    const rowCells: Map<number, GridCell> = new Map()
    rowCells.set(0, MOCK_TEXT_CELL_1)
    rowCells.set(1, MOCK_TEXT_CELL_2)

    // Add a row and check values
    editingState.addRow(rowCells)
    expect(editingState.getNumRows()).toEqual(NUM_OF_ROWS + 1)
    expect(editingState.isAddedRow(2)).toEqual(false)
    expect(editingState.isAddedRow(3)).toEqual(true)
    expect(editingState.getCell(0, 3)).toEqual(MOCK_TEXT_CELL_1)
    expect(editingState.getCell(1, 3)).toEqual(MOCK_TEXT_CELL_2)

    // Add another row
    editingState.addRow(rowCells)
    expect(editingState.getNumRows()).toEqual(NUM_OF_ROWS + 2)
    expect(editingState.getCell(0, 4)).toEqual(MOCK_TEXT_CELL_1)
    expect(editingState.getCell(1, 4)).toEqual(MOCK_TEXT_CELL_2)
  })

  it("allows to delete a single row", () => {
    const NUM_OF_ROWS = 3
    const editingState = new EditingState(NUM_OF_ROWS)

    // Delete first row
    editingState.deleteRow(0)
    expect(editingState.getNumRows()).toEqual(NUM_OF_ROWS - 1)

    // The current row 0 should be the original row 1
    expect(editingState.getOriginalRowIndex(0)).toEqual(1)
  })

  it("allows to add and delete multiple rows", () => {
    const NUM_OF_ROWS = 3
    const editingState = new EditingState(NUM_OF_ROWS)

    const rowCells: Map<number, GridCell> = new Map()
    rowCells.set(0, MOCK_TEXT_CELL_1)
    rowCells.set(1, MOCK_TEXT_CELL_2)

    // Add two rows
    editingState.addRow(rowCells)
    editingState.addRow(rowCells)
    // Should have 5 rows
    expect(editingState.getNumRows()).toEqual(NUM_OF_ROWS + 2)

    // Delete one row
    editingState.deleteRow(3)
    // Should have 4 rows
    expect(editingState.getNumRows()).toEqual(NUM_OF_ROWS + 1)
    // Last row should be an edited row
    let LAST_ROW_ID = editingState.getOriginalRowIndex(
      editingState.getNumRows() - 1
    )
    expect(editingState.isAddedRow(LAST_ROW_ID)).toEqual(true)
    expect(editingState.getCell(0, LAST_ROW_ID)).toEqual(MOCK_TEXT_CELL_1)
    expect(editingState.getCell(1, LAST_ROW_ID)).toEqual(MOCK_TEXT_CELL_2)

    // Delete a row from existing data
    editingState.deleteRow(0)
    // Should have 3 rows
    expect(editingState.getNumRows()).toEqual(NUM_OF_ROWS)

    // Last row should be an edited row
    LAST_ROW_ID = editingState.getOriginalRowIndex(
      editingState.getNumRows() - 1
    )
    expect(editingState.isAddedRow(LAST_ROW_ID)).toEqual(true)
    expect(editingState.getCell(0, LAST_ROW_ID)).toEqual(MOCK_TEXT_CELL_1)
    expect(editingState.getCell(1, LAST_ROW_ID)).toEqual(MOCK_TEXT_CELL_2)

    // Delete remaining rows via deleteRows
    editingState.deleteRows([
      editingState.getOriginalRowIndex(0),
      editingState.getOriginalRowIndex(1),
      editingState.getOriginalRowIndex(2),
    ])
    expect(editingState.getNumRows()).toEqual(0)
  })

  it("ignores rows with required empty values in toJson", () => {
    const NUM_OF_ROWS = 3
    const editingState = new EditingState(NUM_OF_ROWS)

    const rowCells: Map<number, GridCell> = new Map()
    rowCells.set(0, MOCK_TEXT_CELL_1)
    rowCells.set(1, MOCK_TEXT_MISSING_CELL)

    // Add a row and check values
    editingState.addRow(rowCells)
    expect(editingState.getNumRows()).toEqual(NUM_OF_ROWS + 1)

    const baseColumnProps = {
      id: "column_1",
      title: "column_1",
      indexNumber: 0,
      arrowType: {
        pandas_type: "unicode",
        numpy_type: "object",
      },
      isEditable: true,
      isRequired: true,
      isHidden: false,
      isIndex: false,
      isPinned: false,
      isStretched: false,
    } as BaseColumnProps

    // Convert to JSON
    const json = editingState.toJson([
      TextColumn({
        ...baseColumnProps,
        indexNumber: 0,
        id: "column_1",
      }),
      TextColumn({
        ...baseColumnProps,
        indexNumber: 1,
        id: "column_2",
      }),
    ])

    // Row should npt be included in the JSON:
    expect(json).toEqual(
      '{"edited_rows":{},"added_rows":[],"deleted_rows":[]}'
    )
  })

  it("converts editing state to JSON", () => {
    const NUM_OF_ROWS = 3
    const editingState = new EditingState(NUM_OF_ROWS)

    // Edit a cell
    editingState.setCell(0, 0, MOCK_TEXT_CELL_1)

    // Add row
    const rowCells: Map<number, GridCell> = new Map()
    rowCells.set(0, MOCK_TEXT_CELL_1)
    rowCells.set(1, MOCK_TEXT_CELL_2)
    editingState.addRow(rowCells)

    // Delete a row
    editingState.deleteRow(1)

    const baseColumnProps = {
      id: "column_1",
      name: "column_1",
      title: "column_1",
      indexNumber: 0,
      arrowType: {
        pandas_type: "unicode",
        numpy_type: "object",
      },
      isEditable: false,
      isHidden: false,
      isIndex: false,
      isPinned: false,
      isStretched: false,
    } as BaseColumnProps

    // Convert to JSON
    const json = editingState.toJson([
      TextColumn({
        ...baseColumnProps,
        indexNumber: 0,
        id: "column_1",
        name: "column_1",
      }),
      TextColumn({
        ...baseColumnProps,
        indexNumber: 1,
        id: "column_2",
        name: "column_2",
      }),
    ])

    expect(json).toEqual(
      '{"edited_rows":{"0":{"column_1":"foo"}},"added_rows":[{"column_1":"foo","column_2":"foo"}],"deleted_rows":[1]}'
    )
  })

  it.each([
    [
      `{"edited_rows":{"0":{"column_1":"foo"}},"added_rows":[{"column_1":"foo","column_2":"foo"}],"deleted_rows":[1]}`,
    ],
    [`{"edited_rows":{},"added_rows":[],"deleted_rows":[]}`],
    [
      `{"edited_rows":{},"added_rows":[{"column_1":"foo","column_2":"foo"}],"deleted_rows":[]}`,
    ],
    [`{"edited_rows":{},"added_rows":[],"deleted_rows":[1]}`],
    [
      `{"edited_rows":{"0":{"column_1":"foo"}},"added_rows":[],"deleted_rows":[]}`,
    ],
    [
      `{"edited_rows":{"0":{"_index":"foo"}},"added_rows":[],"deleted_rows":[]}`,
    ],
  ])("converts JSON to editing state: %p", (editingStateJson: string) => {
    const NUM_OF_ROWS = 3
    const editingState = new EditingState(NUM_OF_ROWS)

    const MOCK_COLUMN_PROPS = {
      id: "column_1",
      name: "column_1",
      title: "column_1",
      indexNumber: 0,
      arrowType: {
        pandas_type: "unicode",
        numpy_type: "object",
      },
      isEditable: false,
      isRequired: false,
      isHidden: false,
      isIndex: false,
      isPinned: false,
      isStretched: false,
    } as BaseColumnProps

    const MOCK_COLUMNS = [
      TextColumn({
        ...MOCK_COLUMN_PROPS,
        isIndex: true,
        indexNumber: 0,
        id: "index_col",
        name: "index_col",
      }),
      TextColumn({
        ...MOCK_COLUMN_PROPS,
        indexNumber: 1,
        id: "column_1",
        name: "column_1",
      }),
      TextColumn({
        ...MOCK_COLUMN_PROPS,
        indexNumber: 2,
        id: "column_2",
        name: "column_2",
      }),
    ]
    editingState.fromJson(editingStateJson, MOCK_COLUMNS)
    // Test again if the edits were applied correctly:
    expect(editingState.toJson(MOCK_COLUMNS)).toEqual(editingStateJson)
  })

  it("ensure all cells of added rows are filled even if empty", () => {
    const NUM_OF_ROWS = 3
    const editingState = new EditingState(NUM_OF_ROWS)

    const MOCK_COLUMN_PROPS = {
      id: "column_1",
      name: "column_1",
      title: "column_1",
      indexNumber: 0,
      arrowType: {
        pandas_type: "unicode",
        numpy_type: "object",
      },
      isEditable: false,
      isRequired: false,
      isHidden: false,
      isIndex: false,
      isPinned: false,
      isStretched: false,
    } as BaseColumnProps

    const MOCK_COLUMNS = [
      TextColumn({
        ...MOCK_COLUMN_PROPS,
        isIndex: true,
        indexNumber: 0,
        id: "index_col",
        name: "index_col",
      }),
      TextColumn({
        ...MOCK_COLUMN_PROPS,
        indexNumber: 1,
        id: "column_1",
        name: "column_1",
      }),
      TextColumn({
        ...MOCK_COLUMN_PROPS,
        indexNumber: 2,
        id: "column_2",
        name: "column_2",
      }),
    ]
    editingState.fromJson(
      `{"edited_rows":{},"added_rows":[{"column_1":"foo"}],"deleted_rows":[]}`,
      MOCK_COLUMNS
    )
    // Should have the value from the JSON:
    expect(editingState.getCell(1, 3)).toEqual(MOCK_COLUMNS[1].getCell("foo"))
    // Should have an empty cell since it wasn't specified in the JSON:
    expect(editingState.getCell(2, 3)).toEqual(MOCK_COLUMNS[2].getCell(null))
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/EditingState.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCell } from "@glideapps/glide-data-grid"

import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

import { BaseColumn, isMissingValueCell } from "./columns"
import { INDEX_IDENTIFIER } from "./hooks/useColumnLoader"

/**
 * Get the column name for a given column to use in the widget state.
 * This is either the column name or the index identifier for index columns.
 */
export function getColumnName(column: BaseColumn): string {
  // TODO(lukasmasuch): We need to adapt this once we want to support multi-index columns.
  return column.isIndex
    ? INDEX_IDENTIFIER
    : isNullOrUndefined(column.name)
    ? ""
    : column.name
}

/**
 * The editing state keeps track of all table edits applied by the user.
 */
class EditingState {
  // row -> column -> GridCell
  // Using [number, number] as a key for a Map would not work.
  private editedCells: Map<number, Map<number, GridCell>> = new Map()

  // List of rows represented by of column -> GridCell mappings
  private addedRows: Array<Map<number, GridCell>> = []

  // List of deleted row IDs
  private deletedRows: number[] = []

  // The original number of rows in the table (without potential additions & deletions)
  private numRows = 0

  constructor(numRows: number) {
    this.numRows = numRows
  }

  /**
   * Convert the current editing state to a JSON string.
   *
   * @param columns - The columns of the table
   * @returns JSON string
   */
  toJson(columns: BaseColumn[]): string {
    const columnsByIndex = new Map<number, BaseColumn>()
    columns.forEach(column => {
      columnsByIndex.set(column.indexNumber, column)
    })

    const currentState = {
      // We use snake case here since this is the widget state
      // that is sent and used in the backend. Therefore, it should
      // conform with the Python naming conventions.
      edited_rows: {} as Record<number, Record<string, any>>,
      added_rows: [] as Record<string, any>[],
      deleted_rows: [] as number[],
    }

    // Loop through all edited cells and transform into the structure
    // we use for the JSON-compatible widget state:
    // row position -> column name -> edited value
    this.editedCells.forEach(
      (row: Map<number, GridCell>, rowIndex: number, _map) => {
        const editedRow: Record<string, any> = {}
        row.forEach((cell: GridCell, colIndex: number, _map) => {
          const column = columnsByIndex.get(colIndex)
          if (column) {
            editedRow[getColumnName(column)] = column.getCellValue(cell)
          }
        })
        currentState.edited_rows[rowIndex] = editedRow
      }
    )

    // Loop through all added rows and transform into the format that
    // we use for the JSON-compatible widget state:
    // List of column name -> edited value
    this.addedRows.forEach((row: Map<number, GridCell>) => {
      const addedRow: Record<string, any> = {}
      // This flags is used to check if the row is incomplete
      // (i.e. missing required values) and should therefore not be included in
      // the current state version.
      let isIncomplete = false
      row.forEach((cell: GridCell, colIndex: number, _map) => {
        const column = columnsByIndex.get(colIndex)
        if (column) {
          const cellValue = column.getCellValue(cell)

          if (
            column.isRequired &&
            column.isEditable &&
            isMissingValueCell(cell)
          ) {
            // If the cell is missing a required value, the row is incomplete
            isIncomplete = true
          }

          if (notNullOrUndefined(cellValue)) {
            addedRow[getColumnName(column)] = cellValue
          }
        }
      })
      if (!isIncomplete) {
        currentState.added_rows.push(addedRow)
      }
    })

    // The deleted rows don't need to be transformed
    currentState.deleted_rows = this.deletedRows

    // Convert undefined values to null, otherwise this is removed here since
    // undefined does not exist in JSON.
    const json = JSON.stringify(currentState, (_k, v) =>
      v === undefined ? null : v
    )
    return json
  }

  /**
   * Load the editing state from a JSON string.
   *
   * @param columns - The columns of the table
   * @returns JSON string
   */
  fromJson(editingStateJson: string, columns: BaseColumn[]): void {
    // Clear existing state:
    this.editedCells = new Map()
    this.addedRows = []
    this.deletedRows = []

    // Parse JSON editing string:
    const editingState = JSON.parse(editingStateJson)
    // Map columns to column index
    const columnsByIndex = new Map<number, BaseColumn>()
    columns.forEach(column => {
      columnsByIndex.set(column.indexNumber, column)
    })

    // Map column name to columns
    const columnsByName = new Map<string, BaseColumn>()
    columns.forEach(column => {
      columnsByName.set(getColumnName(column), column)
    })

    // Loop through all edited cells and transform into the structure
    // we use for the editing state:
    // row -> column -> GridCell
    Object.keys(editingState.edited_rows).forEach(key => {
      const rowIndex = Number(key)
      const editedRow = editingState.edited_rows[key]
      Object.keys(editedRow).forEach((colName: string) => {
        const cellValue = editedRow[colName]
        const column = columnsByName.get(colName)
        if (column) {
          const cell = column.getCell(cellValue)
          if (cell) {
            if (!this.editedCells.has(rowIndex)) {
              this.editedCells.set(rowIndex, new Map())
            }
            this.editedCells.get(rowIndex)?.set(column.indexNumber, cell)
          }
        }
      })
    })

    // Loop through all added rows and transform into the format that
    // we use for the editing state:
    // List of column index -> edited value
    editingState.added_rows.forEach((row: Record<string, any>) => {
      const addedRow: Map<number, GridCell> = new Map()
      // Initialize all columns with null (empty) values first
      // This is necessary to ensure that all columns are present in the added row.
      // We will overwrite the empty values with the actual values below
      // if the actual value exists. We need to do this since we are only
      // putting none-empty values in the widget state for optimization reasons.
      columns.forEach(column => {
        addedRow.set(column.indexNumber, column.getCell(null))
      })

      // Set the cells that were actually edited in the row
      Object.keys(row).forEach(colName => {
        const cellValue = row[colName]

        const column = columnsByName.get(colName)

        if (column) {
          const cell = column.getCell(cellValue)
          if (cell) {
            addedRow.set(column.indexNumber, cell)
          }
        }
      })
      this.addedRows.push(addedRow)
    })

    // The deleted rows don't need to be transformed
    this.deletedRows = editingState.deleted_rows
  }

  /**
   * Returns true if the given row was added by the user through the UI.
   */
  isAddedRow(row: number): boolean {
    return row >= this.numRows
  }

  /**
   * Returns the cell at the given column and row,
   * in case the cell was edited or added.
   *
   * @param col - The column index
   * @param row - The row index
   *
   * @returns The edited cell at the given column and row
   */
  getCell(col: number, row: number): GridCell | undefined {
    if (this.isAddedRow(row)) {
      // Added rows have their own editing state
      return this.addedRows[row - this.numRows].get(col)
    }

    const rowCache = this.editedCells.get(row)
    if (rowCache === undefined) {
      return undefined
    }

    return rowCache.get(col)
  }

  /**
   * Adds a cell to the editing state for the given column and row index.
   *
   * @param col - The column index
   * @param row - The row index
   * @param cell - The cell to add to the editing state
   */
  setCell(col: number, row: number, cell: GridCell): void {
    if (this.isAddedRow(row)) {
      if (row - this.numRows >= this.addedRows.length) {
        // Added row does not exist. This is only expected to happen
        // in relation to a trailing row issue in glide-data-grid.
        return
      }
      // Added rows have their own editing state
      this.addedRows[row - this.numRows].set(col, cell)
    } else {
      if (this.editedCells.get(row) === undefined) {
        this.editedCells.set(row, new Map())
      }

      const rowCache = this.editedCells.get(row) as Map<number, GridCell>
      rowCache.set(col, cell)
    }
  }

  /**
   * Adds a new row to the editing state.
   *
   * @param rowCells - The cells of the row to add
   */
  addRow(rowCells: Map<number, GridCell>): void {
    this.addedRows.push(rowCells)
  }

  /**
   * Deletes the given rows from the editing state.
   *
   * @param rows - The rows to delete
   */
  deleteRows(rows: number[]): void {
    // Delete row one by one starting from the row with the highest index
    rows
      .sort((a, b) => b - a)
      .forEach(row => {
        this.deleteRow(row)
      })
  }

  /**
   * Deletes the given row from the editing state.
   *
   * @param row - The row to delete
   */
  deleteRow(row: number): void {
    if (isNullOrUndefined(row) || row < 0) {
      // This should never happen
      return
    }

    if (this.isAddedRow(row)) {
      // Remove from added rows:
      this.addedRows.splice(row - this.numRows, 1)
      // there is nothing more we have to do
      return
    }

    if (!this.deletedRows.includes(row)) {
      // Add to the set
      this.deletedRows.push(row)
      // Sort the deleted rows (important for calculation of the original row index)
      this.deletedRows = this.deletedRows.sort((a, b) => a - b)
    }

    // Remove all cells from cell state associated with this row:
    this.editedCells.delete(row)
  }

  /**
   * Returns the original row index of the given row.
   * Since the user can delete rows, the original row index and the
   * current one can diverge.
   *
   * @param row - The row index from the current state
   *
   * @returns The original row index
   */
  getOriginalRowIndex(row: number): number {
    // Just count all deleted rows before this row to determine the original row index:
    let originalIndex = row
    for (let i = 0; i < this.deletedRows.length; i++) {
      if (this.deletedRows[i] > originalIndex) {
        break
      }
      originalIndex += 1
    }
    return originalIndex
  }

  /**
   * Returns the total number of rows of the current state.
   */
  getNumRows(): number {
    return this.numRows + this.addedRows.length - this.deletedRows.length
  }
}

export default EditingState


================================================
File: /frontend/lib/src/components/widgets/DataFrame/Tooltip.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import Tooltip, { TooltipProps } from "./Tooltip"

describe("Dataframe Tooltip", () => {
  const defaultProps: TooltipProps = {
    top: 100,
    left: 100,
    content: "**This is a tooltip.**",
    clearTooltip: vi.fn(),
  }

  test("renders the tooltip with provided content", () => {
    render(<Tooltip {...defaultProps} />)

    const tooltipContent = screen.getByText("This is a tooltip.")
    expect(tooltipContent).toBeInTheDocument()
    // Uses markdown to render the content:
    expect(tooltipContent).toHaveStyle("font-weight: 600")
  })

  test("renders the tooltip at the correct position", () => {
    const customPositionProps: TooltipProps = {
      top: 200,
      left: 300,
      content: "Positioned tooltip.",
      clearTooltip: vi.fn(),
    }

    render(<Tooltip {...customPositionProps} />)

    const tooltipContent = screen.getByText("Positioned tooltip.")
    expect(tooltipContent).toBeInTheDocument()

    const invisibleDiv = screen.getByTestId("stDataFrameTooltipTarget")

    expect(invisibleDiv).toHaveStyle("position: fixed")
    expect(invisibleDiv).toHaveStyle("top: 200px")
    expect(invisibleDiv).toHaveStyle("left: 300px")
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/Tooltip.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { useTheme } from "@emotion/react"
import { ACCESSIBILITY_TYPE, PLACEMENT, Popover } from "baseui/popover"

import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown/StreamlitMarkdown"
import { StyledTooltipContentWrapper } from "@streamlit/lib/src/components/shared/Tooltip/styled-components"
import {
  EmotionTheme,
  hasLightBackgroundColor,
} from "@streamlit/lib/src/theme"

export interface TooltipProps {
  // The top position of the tooltip.
  top: number
  // The left position of the tooltip.
  left: number
  // The markdown content of the tooltip.
  content: string
  // Callback from useTooltips hook to clear the tooltip
  clearTooltip: () => void
}

/**
 * A tooltip that can be positioned anywhere on the screen.
 *
 * This is mostly the same as the shared tooltip implementation, but
 * we cannot use that one since it is a StatefulTooltip and requires
 * a target component and cannot be triggered programmatically.
 * We need to be able to position the tooltip anywhere on the screen, so we use a Popover
 * instead. Since Popover doesn't support positioning to a virtual position,
 * we are using an invisible div as a workaround.
 *
 * @param top The top position of the tooltip.
 * @param left The left position of the tooltip.
 * @param content The markdown content of the tooltip.
 * @returns The tooltip react element.
 */
function Tooltip({
  top,
  left,
  content,
  clearTooltip,
}: TooltipProps): ReactElement {
  const [open, setOpen] = React.useState(true)
  const theme: EmotionTheme = useTheme()
  const { colors, fontSizes, radii, fontWeights } = theme

  const closeTooltip = React.useCallback((): void => {
    setOpen(false)
    clearTooltip()
  }, [clearTooltip, setOpen])

  return (
    <Popover
      content={
        <StyledTooltipContentWrapper data-testid="stDataFrameTooltipContent">
          <StreamlitMarkdown
            style={{ fontSize: fontSizes.sm }}
            source={content}
            allowHTML={false}
          />
        </StyledTooltipContentWrapper>
      }
      placement={PLACEMENT.top}
      accessibilityType={ACCESSIBILITY_TYPE.tooltip}
      showArrow={false}
      popoverMargin={5}
      onClickOutside={closeTooltip}
      onEsc={closeTooltip}
      overrides={{
        Body: {
          style: {
            // This is annoying, but a bunch of warnings get logged when the
            // shorthand version `borderRadius` is used here since the long
            // names are used by BaseWeb and mixing the two is apparently
            // bad :(
            borderTopLeftRadius: radii.default,
            borderTopRightRadius: radii.default,
            borderBottomLeftRadius: radii.default,
            borderBottomRightRadius: radii.default,

            paddingTop: "0 !important",
            paddingBottom: "0 !important",
            paddingLeft: "0 !important",
            paddingRight: "0 !important",

            backgroundColor: "transparent",
          },
        },
        Inner: {
          style: {
            backgroundColor: hasLightBackgroundColor(theme)
              ? colors.bgColor
              : colors.secondaryBg,
            color: colors.bodyText,
            fontSize: fontSizes.sm,
            fontWeight: fontWeights.normal,
            // See the long comment about `borderRadius`. The same applies here
            // to `padding`.
            paddingTop: "0 !important",
            paddingBottom: "0 !important",
            paddingLeft: "0 !important",
            paddingRight: "0 !important",
          },
        },
      }}
      isOpen={open}
    >
      <div
        data-testid="stDataFrameTooltipTarget"
        style={{
          // This is an invisible div that's used to position the tooltip.
          // The position is provided from outside via the `top` and `left` properties.
          // This a workaround for the fact that BaseWeb's Popover  doesn't support
          // positioning to a virtual position and always requires a target
          // component for positioning.
          position: "fixed",
          top,
          left,
        }}
      ></div>
    </Popover>
  )
}

export default Tooltip


================================================
File: /frontend/lib/src/components/widgets/DataFrame/arrowUtils.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { PandasColumnType as ArrowType } from "@streamlit/lib/src/dataframes/arrowTypeUtils"
import { DataFrameCell, Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import {
  CATEGORICAL_COLUMN,
  DECIMAL,
  DISPLAY_VALUES,
  EMPTY,
  MULTI,
  STYLER,
  UNICODE,
} from "@streamlit/lib/src/mocks/arrow"
import { Arrow as ArrowProto } from "@streamlit/lib/src/proto"

import {
  applyPandasStylerCss,
  extractCssProperty,
  getAllColumnsFromArrow,
  getCellFromArrow,
  getColumnFromArrow,
  getColumnTypeFromArrow,
  getIndexFromArrow,
} from "./arrowUtils"
import {
  CheckboxColumn,
  ColumnCreator,
  DateColumn,
  DateTimeColumn,
  getTextCell,
  ListColumn,
  NumberColumn,
  ObjectColumn,
  SelectboxColumn,
  TextColumn,
  TimeColumn,
} from "./columns"

const MOCK_TEXT_COLUMN = TextColumn({
  id: "1",
  name: "text_column",
  title: "Text column",
  indexNumber: 0,
  isEditable: false,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
  arrowType: {
    pandas_type: "unicode",
    numpy_type: "object",
  },
})

const MOCK_NUMBER_COLUMN = NumberColumn({
  id: "1",
  name: "number_column",
  title: "Number column",
  indexNumber: 0,
  isEditable: false,
  isHidden: false,
  isIndex: false,
  isStretched: false,
  isPinned: false,
  arrowType: {
    pandas_type: "int64",
    numpy_type: "int64",
  },
})

describe("extractCssProperty", () => {
  it("should extract the correct property value", () => {
    const cssStyle1 = `
  #T_f116e_row10_col0, #T_f116e_row10_col1, #T_f116e_row10_col3 { color: red }
  #T_f116e_row0_col1, #T_f116e_row1_col0 { color: white; background-color: pink }
  #T_f116e_row0_col2 { color: red; opacity: 20% }
  #T_f116e_row2_col2, #T_f116e_row5_col1 { opacity: 20% }
  #T_f116e_row3_col3, #T_f116e_row12_col1 { color: white; background-color: darkblue; color: white; background-color: pink }
  #T_f116e_row11_col10, #T_f116e_row11_col10 {  background-color: darkblue }`

    // All color-value formats
    const cssStyle2 = `
  #T_7e5cc_row6_col0 { background-color: #f8fcc9; color: #000000 }
  #T_7e5cc_row7_col1 { background-color: #1c2d81; color: #f1f1f1 }
  #T_7e5cc_row8_col0 { background-color: #289cc1; color: #f1f1f1 }
  #T_7e5cc_row8_col1 { background-color: #2165ab; color: #f1f1f1 }
  #T_7e5cc_row9_col0 { background-color: #f0f9b8; color: #000000 }
  #T_f116e_row12_col14 { background-color: blue }
  #T_f116e_row13_col14 { background-color: #f1f1f1 }
  #T_f116e_row14_col1 { background-color: rgba(72 122 180 / .2); }
  #T_f116e_row15_col1 { background-color: rgba(255, 0, 12, .2)}
  #T_f116e_row16_col14 { background-color: hsla(240, 100%, 90%) }
  #T_f116e_row17_col1 { background-color: hsl(255, 0, 12)}`

    // Badly Formatted
    const cssStyle3 = `
  #T_f116e_row10_col0,#T_7e5cc_row6_col0   {   background-color: #f8fcc9;     color: #000000 }
  #T_7e5cc_row7_col1{ background-color:#1c2d81; color: #f1f1f1 }
  #T_7e5cc_row8_col0{background-color: #289cc1;color: #f1f1f1}
  #T_f116e_row18_col1, #T_f116e_row18_col14 { background-color: hsla(240, 100%,    90%) }
  #T_f116e_row19_col1, #T_f116e_row19_col14 { background-color: hsl(240, 100%,90%) }`

    expect(extractCssProperty("#T_f116e_row10_col1", "color", cssStyle1)).toBe(
      "red"
    )
    expect(
      extractCssProperty("#T_f116e_row12_col1", "background-color", cssStyle1)
    ).toBe("pink")
    expect(extractCssProperty("#T_f116e_row5_col1", "color", cssStyle1)).toBe(
      undefined
    )
    expect(extractCssProperty("foo", "color", cssStyle1)).toBe(undefined)
    expect(extractCssProperty("#T_f116e_row0_col2", "color", cssStyle1)).toBe(
      "red"
    )
    expect(
      extractCssProperty("#T_f116e_row11_col10", "background-color", cssStyle1)
    ).toBe("darkblue")
    // Should not extract if it only partly matches:
    expect(
      extractCssProperty("#T_f116e_row11_col1", "background-color", cssStyle1)
    ).toBe(undefined)

    expect(
      extractCssProperty("#T_7e5cc_row6_col0", "background-color", cssStyle2)
    ).toBe("#f8fcc9")
    expect(extractCssProperty("#T_7e5cc_row9_col0", "color", cssStyle2)).toBe(
      "#000000"
    )
    expect(
      extractCssProperty("#T_f116e_row12_col14", "background-color", cssStyle2)
    ).toBe("blue")
    expect(
      extractCssProperty("#T_f116e_row13_col14", "background-color", cssStyle2)
    ).toBe("#f1f1f1")
    expect(
      extractCssProperty("#T_f116e_row14_col1", "background-color", cssStyle2)
    ).toBe("rgba(72 122 180 / .2)")
    expect(
      extractCssProperty("#T_f116e_row15_col1", "background-color", cssStyle2)
    ).toBe("rgba(255, 0, 12, .2)")
    expect(
      extractCssProperty("#T_f116e_row16_col14", "background-color", cssStyle2)
    ).toBe("hsla(240, 100%, 90%)")
    expect(
      extractCssProperty("#T_f116e_row17_col1", "background-color", cssStyle2)
    ).toBe("hsl(255, 0, 12)")

    expect(
      extractCssProperty("#T_f116e_row10_col0", "background-color", cssStyle3)
    ).toBe("#f8fcc9")
    expect(
      extractCssProperty("#T_7e5cc_row8_col0", "background-color", cssStyle3)
    ).toBe("#289cc1")
    expect(
      extractCssProperty("#T_f116e_row18_col14", "background-color", cssStyle3)
    ).toBe("hsla(240, 100%,    90%)")
    expect(
      extractCssProperty("#T_f116e_row19_col14", "background-color", cssStyle3)
    ).toBe("hsl(240, 100%,90%)")
    expect(extractCssProperty("#T_7e5cc_row8_col0", "color", cssStyle3)).toBe(
      "#f1f1f1"
    )
  })
})

describe("applyPandasStylerCss", () => {
  it("should apply css to a cells", () => {
    const CSS_STYLES = `
  #T_f116e_row10_col0, #T_f116e_row10_col1, #T_f116e_row10_col3 { color: red }
  #T_f116e_row0_col1, #T_f116e_row1_col0 { color: white; background-color: pink }
  #T_f116e_row0_col2 { color: red; opacity: 20% }
  #T_f116e_row2_col2, #T_f116e_row5_col1 { opacity: 20% }
  #T_f116e_row3_col3, #T_f116e_row12_col1 { color: white; background-color: darkblue; color: white; background-color: pink }
  #T_f116e_row11_col10, #T_f116e_row11_col10 {  background-color: darkblue }`

    const MOCK_CELL = getTextCell(true, false)
    let styledCell = applyPandasStylerCss(
      MOCK_CELL,
      "#T_f116e_row11_col10",
      CSS_STYLES
    )
    expect(styledCell.themeOverride).toEqual({
      bgCell: "darkblue",
    })

    styledCell = applyPandasStylerCss(
      MOCK_CELL,
      "#T_f116e_row0_col2",
      CSS_STYLES
    )
    expect(styledCell.themeOverride).toEqual({
      textDark: "red",
    })

    styledCell = applyPandasStylerCss(
      MOCK_CELL,
      "#T_f116e_row3_col3",
      CSS_STYLES
    )
    expect(styledCell.themeOverride).toEqual({
      bgCell: "pink",
      textDark: "white",
    })

    styledCell = applyPandasStylerCss(MOCK_CELL, "invalid_key", CSS_STYLES)
    expect(styledCell.themeOverride).toEqual({})
  })

  it("should use a grey color when background is yellow", () => {
    const CSS_STYLES = `#T_f116e_row0_col0 { background-color: yellow }`
    const styledCell = applyPandasStylerCss(
      getTextCell(true, false),
      "#T_f116e_row0_col0",
      CSS_STYLES
    )
    expect(styledCell.themeOverride).toEqual({
      bgCell: "yellow",
      textDark: "#31333F",
    })
  })
})

describe("getIndexFromArrow", () => {
  it("returns a valid index", () => {
    const element = ArrowProto.create({
      data: UNICODE,
    })
    const data = new Quiver(element)

    const indexColumn = getIndexFromArrow(data, 0)
    expect(indexColumn).toEqual({
      id: `_index-0`,
      isEditable: true,
      name: "",
      title: "",
      arrowType: {
        meta: null,
        numpy_type: "object",
        pandas_type: "unicode",
      },
      isIndex: true,
      isPinned: true,
      isHidden: false,
    })
  })

  it("works with multi-index", () => {
    const element = ArrowProto.create({
      data: MULTI,
    })
    const data = new Quiver(element)

    const indexColumn1 = getIndexFromArrow(data, 0)
    expect(indexColumn1).toEqual({
      id: `_index-0`,
      isEditable: true,
      name: "number",
      title: "number",
      arrowType: {
        meta: null,
        numpy_type: "int64",
        pandas_type: "int64",
      },
      isIndex: true,
      isPinned: true,
      isHidden: false,
    })

    const indexColumn2 = getIndexFromArrow(data, 1)
    expect(indexColumn2).toEqual({
      id: `_index-1`,
      isEditable: true,
      name: "color",
      title: "color",
      arrowType: {
        meta: null,
        numpy_type: "object",
        pandas_type: "unicode",
      },
      isIndex: true,
      isPinned: true,
      isHidden: false,
    })
  })
})

describe("getColumnFromArrow", () => {
  it("returns a valid column", () => {
    const element = ArrowProto.create({
      data: UNICODE,
    })
    const data = new Quiver(element)

    const column = getColumnFromArrow(data, 0)
    expect(column).toEqual({
      id: "_column-c1-0",
      name: "c1",
      title: "c1",
      isEditable: true,
      arrowType: {
        meta: null,
        numpy_type: "object",
        pandas_type: "unicode",
      },
      isIndex: false,
      isPinned: false,
      isHidden: false,
    })
  })

  it("works with multi-index headers", () => {
    const element = ArrowProto.create({
      data: MULTI,
    })
    const data = new Quiver(element)

    const column = getColumnFromArrow(data, 0)
    expect(column).toEqual({
      id: "_column-red-0",
      name: "red",
      title: "red",
      isEditable: true,
      arrowType: {
        meta: null,
        numpy_type: "object",
        pandas_type: "unicode",
      },
      isIndex: false,
      isPinned: false,
      isHidden: false,
      group: "1",
    })
  })

  it("adds categorical options to type metadata", () => {
    const element = ArrowProto.create({
      data: CATEGORICAL_COLUMN,
    })
    const data = new Quiver(element)

    const column = getColumnFromArrow(data, 0)
    expect(column).toEqual({
      id: "_column-c1-0",
      name: "c1",
      title: "c1",
      isEditable: true,
      arrowType: {
        meta: {
          num_categories: 2,
          ordered: false,
        },
        numpy_type: "int8",
        pandas_type: "categorical",
      },
      isIndex: false,
      isPinned: false,
      isHidden: false,
      columnTypeOptions: {
        options: ["bar", "foo"],
      },
    })
  })
})
describe("getAllColumnsFromArrow", () => {
  it("extracts all columns", () => {
    const element = ArrowProto.create({
      data: UNICODE,
    })
    const data = new Quiver(element)
    const columns = getAllColumnsFromArrow(data)

    expect(columns).toEqual([
      {
        arrowType: {
          meta: null,
          numpy_type: "object",
          pandas_type: "unicode",
        },
        id: "_index-0",
        indexNumber: 0,
        isEditable: true,
        isHidden: false,
        isIndex: true,
        isPinned: true,
        name: "",
        title: "",
      },
      {
        arrowType: {
          meta: null,
          numpy_type: "object",
          pandas_type: "unicode",
        },
        columnTypeOptions: undefined,
        id: "_column-c1-0",
        indexNumber: 1,
        isEditable: true,
        isHidden: false,
        isIndex: false,
        isPinned: false,
        name: "c1",
        title: "c1",
      },
      {
        arrowType: {
          meta: null,
          numpy_type: "object",
          pandas_type: "unicode",
        },
        columnTypeOptions: undefined,
        id: "_column-c2-1",
        indexNumber: 2,
        isEditable: true,
        isHidden: false,
        isIndex: false,
        isPinned: false,
        name: "c2",
        title: "c2",
      },
    ])
  })

  it("handles empty dataframes correctly", () => {
    // TODO: is this correct
    const element = ArrowProto.create({
      data: EMPTY,
    })
    const data = new Quiver(element)
    const columns = getAllColumnsFromArrow(data)

    expect(columns).toEqual([
      {
        arrowType: {
          meta: null,
          numpy_type: "object",
          pandas_type: "empty",
        },
        id: "_index-0",
        indexNumber: 0,
        isEditable: true,
        isHidden: false,
        isIndex: true,
        isPinned: true,
        name: "",
        title: "",
      },
    ])
  })
})

describe("getCellFromArrow", () => {
  it("creates a valid glide-compatible cell", () => {
    const element = ArrowProto.create({
      data: UNICODE,
    })
    const data = new Quiver(element)
    const cell = getCellFromArrow(MOCK_TEXT_COLUMN, data.getCell(1, 1))

    expect(cell).toEqual({
      allowOverlay: true,
      contentAlignment: undefined,
      data: "foo",
      displayData: "foo",
      isMissingValue: false,
      kind: "text",
      readonly: true,
      style: "normal",
    })
  })

  it("handles decimal types correctly", () => {
    const decimalColumn = NumberColumn({
      id: "1",
      name: "decimal_column",
      title: "Decimal column",
      indexNumber: 0,
      isEditable: false,
      isHidden: false,
      isIndex: false,
      isPinned: false,
      isStretched: false,
      arrowType: {
        pandas_type: "decimal",
        numpy_type: "object",
        meta: { precision: 6, scale: 1 },
      },
    })

    const element = ArrowProto.create({
      data: DECIMAL, // should be interpreted as object
    })
    const data = new Quiver(element)
    const cell = getCellFromArrow(decimalColumn, data.getCell(1, 1))

    expect(cell).toEqual({
      allowNegative: true,
      allowOverlay: true,
      contentAlign: "right",
      copyData: "1.1",
      data: 1.1,
      displayData: "1.1",
      isMissingValue: false,
      fixedDecimals: undefined,
      kind: "number",
      readonly: true,
      style: "normal",
      thousandSeparator: "",
    })
  })

  it("applies display content overwrite to time cells", () => {
    const MOCK_TIME_COLUMN = {
      ...TimeColumn({
        id: "1",
        name: "time_column",
        title: "Time column",
        indexNumber: 0,
        isEditable: false,
        isHidden: false,
        isIndex: false,
        isPinned: false,
        isStretched: false,
        arrowType: {
          pandas_type: "time",
          numpy_type: "object",
        },
      }),
    }

    // Create a mock arrowCell object with time data
    const arrowCell = {
      // Unix timestamp in microseconds Wed Sep 29 2021 21:13:20
      // Our default unit is seconds, so it needs to be adjusted internally
      content: BigInt(1632950000123000),
      contentType: null,
      field: {
        type: {
          unit: 2, // Microseconds
        },
      },
      displayContent: "FOOO",
      cssId: null,
      cssClass: null,
      type: "columns",
    } as object as DataFrameCell

    // Call the getCellFromArrow function
    const cell = getCellFromArrow(MOCK_TIME_COLUMN, arrowCell)
    expect((cell as any).data.displayDate).toEqual("FOOO")
  })

  it("doesnt apply display content from styler if format is set", () => {
    const MOCK_TIME_COLUMN = {
      ...TimeColumn({
        id: "1",
        name: "time_column",
        title: "Time column",
        indexNumber: 0,
        isEditable: false,
        isHidden: false,
        isIndex: false,
        isPinned: false,
        isStretched: false,
        columnTypeOptions: {
          format: "YYYY",
        },
        arrowType: {
          pandas_type: "time",
          numpy_type: "object",
        },
      }),
    }

    // Create a mock arrowCell object with time data
    const arrowCell = {
      // Unix timestamp in microseconds Wed Sep 29 2021 21:13:20
      // Our default unit is seconds, so it needs to be adjusted internally
      content: BigInt(1632950000123000),
      contentType: null,
      field: {
        type: {
          unit: 2, // Microseconds
        },
      },
      displayContent: "FOOO",
      cssId: null,
      cssClass: null,
      type: "columns",
    } as object as DataFrameCell

    // Call the getCellFromArrow function
    const cell = getCellFromArrow(MOCK_TIME_COLUMN, arrowCell)
    // Should use the formatted value from the cell and not the displayContent
    // from pandas styler
    expect((cell as any).data.displayDate).toEqual("2021")
  })

  it("parses numeric timestamps for time columns into valid Date values", () => {
    const MOCK_TIME_COLUMN = {
      ...TimeColumn({
        id: "1",
        name: "time_column",
        title: "Time column",
        indexNumber: 0,
        isEditable: false,
        isHidden: false,
        isIndex: false,
        isPinned: false,
        isStretched: false,
        arrowType: {
          pandas_type: "time",
          numpy_type: "object",
        },
      }),
      getCell: vi.fn().mockReturnValue(getTextCell(false, false)),
    }

    // Create a mock arrowCell object with time data
    const arrowCell = {
      // Unix timestamp in microseconds Wed Sep 29 2021 21:13:20
      // Our default unit is seconds, so it needs to be adjusted internally
      content: BigInt(1632950000123000),
      contentType: null,
      field: {
        type: {
          unit: 2, // Microseconds
        },
      },
      displayContent: null,
      cssId: null,
      cssClass: null,
      type: "columns",
    } as object as DataFrameCell

    // Call the getCellFromArrow function
    getCellFromArrow(MOCK_TIME_COLUMN, arrowCell)

    // Check if the timestamp is adjusted properly
    expect(MOCK_TIME_COLUMN.getCell).toHaveBeenCalledWith(
      new Date("2021-09-29T21:13:20.123Z")
    )
  })

  it("parses numeric timestamps for datetime columns into valid Date values", () => {
    const MOCK_TIME_COLUMN = {
      ...TimeColumn({
        id: "1",
        name: "datetime_column",
        title: "Datetime column",
        indexNumber: 0,
        isEditable: false,
        isHidden: false,
        isIndex: false,
        isPinned: false,
        isStretched: false,
        arrowType: {
          pandas_type: "datetime",
          numpy_type: "datetime64[ns]",
        },
      }),
      getCell: vi.fn().mockReturnValue(getTextCell(false, false)),
    }

    // Create a mock arrowCell object with time data
    const arrowCell = {
      // Unix timestamp in milliseconds (Wed Sep 29 2021 21:13:20)
      // Milliseconds is the default unit that is used for all datetime values
      // in arrow. So we don't need to adjust based on the unit here. It just
      // needs conversion from milliseconds unix timestamp to Date object.
      // Our internal parsing assumes seconds as default unit.
      content: 1632950000123,
      contentType: null,
      displayContent: null,
      cssId: null,
      cssClass: null,
      type: "columns",
    } as object as DataFrameCell

    // Call the getCellFromArrow function
    getCellFromArrow(MOCK_TIME_COLUMN, arrowCell)

    // Check if the timestamp is adjusted properly
    expect(MOCK_TIME_COLUMN.getCell).toHaveBeenCalledWith(
      new Date("2021-09-29T21:13:20.123Z")
    )
  })

  it("applies display content from arrow cell", () => {
    const element = {
      data: STYLER,
      styler: {
        uuid: "FAKE_UUID",
        styles: "FAKE_CSS",
        displayValues: DISPLAY_VALUES,
        caption: "FAKE_CAPTION",
      },
    }
    const data = new Quiver(element)
    const cell = getCellFromArrow(MOCK_NUMBER_COLUMN, data.getCell(1, 1))

    expect(cell).toEqual({
      allowOverlay: true,
      contentAlign: "right",
      copyData: "1",
      data: 1,
      displayData: "1",
      isMissingValue: false,
      kind: "number",
      readonly: true,
      style: "normal",
      thousandSeparator: "",
      allowNegative: true,
      fixedDecimals: 0,
    })
  })

  it("applies Pandas styler CSS", () => {
    const element = {
      data: STYLER,
      styler: {
        uuid: "FAKE_UUID",
        styles:
          "#T_FAKE_UUIDrow1_col1, #T_FAKE_UUIDrow0_col0 { color: white; background-color: pink }",
        displayValues: DISPLAY_VALUES,
        caption: "FAKE_CAPTION",
      },
    }
    const data = new Quiver(element)

    const cell = getCellFromArrow(
      MOCK_NUMBER_COLUMN,
      data.getCell(1, 1),
      element.styler.styles
    )

    expect(cell).toEqual({
      allowOverlay: true,
      contentAlign: "right",
      copyData: "1",
      data: 1,
      displayData: "1",
      isMissingValue: false,
      kind: "number",
      readonly: true,
      style: "normal",
      allowNegative: true,
      fixedDecimals: 0,
      themeOverride: {
        bgCell: "pink",
        textDark: "white",
      },
      thousandSeparator: "",
    })
  })
})

it("doesn't apply Pandas Styler CSS for editable columns", () => {
  const element = {
    data: STYLER,
    styler: {
      uuid: "FAKE_UUID",
      styles:
        "#T_FAKE_UUIDrow1_col1, #T_FAKE_UUIDrow0_col0 { color: white; background-color: pink }",
      displayValues: DISPLAY_VALUES,
      caption: "FAKE_CAPTION",
    },
  }
  const data = new Quiver(element)

  const cell = getCellFromArrow(
    { ...MOCK_NUMBER_COLUMN, isEditable: true },
    data.getCell(1, 1),
    element.styler.styles
  )

  expect(cell).toEqual({
    allowOverlay: true,
    contentAlign: "right",
    copyData: "1",
    data: 1,
    displayData: "1",
    isMissingValue: false,
    kind: "number",
    readonly: true,
    style: "normal",
    thousandSeparator: "",
    allowNegative: true,
    fixedDecimals: 0,
  })
})

describe("getColumnTypeFromArrow", () => {
  it.each([
    [
      {
        pandas_type: "float64",
        numpy_type: "float64",
      },
      NumberColumn,
    ],
    [
      {
        pandas_type: "int64",
        numpy_type: "int64",
      },
      NumberColumn,
    ],
    [
      {
        pandas_type: "uint64",
        numpy_type: "uint64",
      },
      NumberColumn,
    ],
    [
      {
        pandas_type: "unicode",
        numpy_type: "object",
      },
      TextColumn,
    ],
    [
      {
        pandas_type: "unicode",
        numpy_type: "string",
      },
      TextColumn,
    ],
    [
      {
        pandas_type: "bool",
        numpy_type: "bool",
      },
      CheckboxColumn,
    ],
    [
      {
        pandas_type: "bool",
        numpy_type: "boolean",
      },
      CheckboxColumn,
    ],
    [
      {
        pandas_type: "categorical",
        numpy_type: "int8",
      },
      SelectboxColumn,
    ],
    [
      {
        pandas_type: "object",
        numpy_type: "list[unicode]",
      },
      ListColumn,
    ],
    [
      {
        pandas_type: "object",
        numpy_type: "object",
      },
      ObjectColumn,
    ],
    [
      {
        pandas_type: "decimal",
        numpy_type: "object",
      },
      NumberColumn,
    ],
    [
      {
        pandas_type: "empty",
        numpy_type: "object",
      },
      TextColumn,
    ],
    [
      {
        pandas_type: "datetime",
        numpy_type: "datetime64[ns]",
      },
      DateTimeColumn,
    ],
    [
      {
        pandas_type: "datetimetz",
        numpy_type: "datetime64[ns]",
      },
      DateTimeColumn,
    ],
    [
      {
        pandas_type: "time",
        numpy_type: "object",
      },
      TimeColumn,
    ],
    [
      {
        pandas_type: "date",
        numpy_type: "object",
      },
      DateColumn,
    ],
    [
      {
        pandas_type: "object",
        numpy_type: "period[H]",
      },
      ObjectColumn,
    ],
    [
      {
        pandas_type: "object",
        numpy_type: "interval[int64, both]",
      },
      ObjectColumn,
    ],
    [
      {
        pandas_type: "bytes",
        numpy_type: "object",
      },
      ObjectColumn,
    ],
  ])(
    "interprets %p as column type: %p",
    (arrowType: ArrowType, expectedType: ColumnCreator) => {
      expect(getColumnTypeFromArrow(arrowType)).toEqual(expectedType)
    }
  )
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/arrowUtils.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  Theme as GlideTheme,
  GridCell,
  GridCellKind,
  NumberCell,
  TextCell,
  UriCell,
} from "@glideapps/glide-data-grid"
import { DatePickerType } from "@glideapps/glide-data-grid-cells"
import moment from "moment"

import { DataFrameCell, Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import {
  convertTimeToDate,
  format as formatArrowCell,
} from "@streamlit/lib/src/dataframes/arrowFormatUtils"
import {
  PandasColumnType as ArrowType,
  isBooleanType,
  isBytesType,
  isCategoricalType,
  isDatetimeType,
  isDateType,
  isDecimalType,
  isEmptyType,
  isListType,
  isNumericType,
  isObjectType,
  isRangeIndexType,
  isStringType,
  isTimeType,
} from "@streamlit/lib/src/dataframes/arrowTypeUtils"
import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

import {
  BaseColumn,
  BaseColumnProps,
  CheckboxColumn,
  ColumnCreator,
  DateColumn,
  DateTimeColumn,
  DateTimeColumnParams,
  isErrorCell,
  LinkColumnParams,
  ListColumn,
  NumberColumn,
  NumberColumnParams,
  ObjectColumn,
  removeLineBreaks,
  SelectboxColumn,
  TextColumn,
  TimeColumn,
} from "./columns"

/**
 * Extracts a CSS property value from a given CSS style string by using a regex.
 *
 * @param htmlElementId - The ID of the HTML element to extract the property for.
 * @param property - The css property to extract the value for.
 * @param cssStyle - The css style string.
 *
 * @return the CSS property value or undefined if the property is not found.
 */
export function extractCssProperty(
  htmlElementId: string,
  property: string,
  cssStyle: string
): string | undefined {
  // This regex is supposed to extract the value of a CSS property
  // for a specified HTML element ID from a CSS style string:
  const regex = new RegExp(
    `${htmlElementId}[,\\s].*{(?:[^}]*[\\s;]{1})?${property}:\\s*([^;}]+)[;]?.*}`,
    "gm"
  )
  // Makes the regex simpler to match the element correctly:
  cssStyle = cssStyle.replace(/{/g, " {")

  const match = regex.exec(cssStyle)
  if (match) {
    return match[1].trim()
  }

  return undefined
}
/**
 * Applies pandas styler CSS to style the cell.
 *
 * @param cell: The cell to style.
 * @param cssId: The css ID of the cell.
 * @param cssStyles: All CSS styles from pandas styler.
 *
 * @return a styled grid cell.
 */
export function applyPandasStylerCss(
  cell: GridCell,
  cssId: string,
  cssStyles: string
): GridCell {
  const themeOverride = {} as Partial<GlideTheme>

  // Extract and apply the font color
  const fontColor = extractCssProperty(cssId, "color", cssStyles)
  if (fontColor) {
    themeOverride.textDark = fontColor
  }

  // Extract and apply the background color
  const backgroundColor = extractCssProperty(
    cssId,
    "background-color",
    cssStyles
  )
  if (backgroundColor) {
    themeOverride.bgCell = backgroundColor
  }

  if (backgroundColor === "yellow" && fontColor === undefined) {
    // Yellow is used by pandas styler as the default highlight color.
    // But yellow won't work well with our default font color in dark mode.
    // Therefore, we are overriding the font color to our dark font color which
    // always works well with yellow background.
    themeOverride.textDark = "#31333F"
  }

  if (themeOverride) {
    // Apply the background and font color in the theme override
    return {
      ...cell,
      themeOverride,
    }
  }
  return cell
}

/**
 * Maps the data type from Arrow to a column type.
 */
export function getColumnTypeFromArrow(arrowType: ArrowType): ColumnCreator {
  if (isStringType(arrowType) || isEmptyType(arrowType)) {
    return TextColumn
  }
  if (isDatetimeType(arrowType)) {
    return DateTimeColumn
  }
  if (isTimeType(arrowType)) {
    return TimeColumn
  }
  if (isDateType(arrowType)) {
    return DateColumn
  }
  if (isObjectType(arrowType) || isBytesType(arrowType)) {
    return ObjectColumn
  }
  if (isBooleanType(arrowType)) {
    return CheckboxColumn
  }
  if (isNumericType(arrowType)) {
    return NumberColumn
  }
  if (isCategoricalType(arrowType)) {
    return SelectboxColumn
  }
  if (isListType(arrowType)) {
    return ListColumn
  }

  return ObjectColumn
}

/**
 * Creates the column props for an index column from the Arrow metadata.
 *
 * @param data - The Arrow data.
 * @param indexPosition - The numeric position of the index column.
 *
 * @return the column props for the index column.
 */
export function getIndexFromArrow(
  data: Quiver,
  indexPosition: number
): BaseColumnProps {
  const arrowType = data.columnTypes.index[indexPosition]
  const title = data.indexNames[indexPosition]
  let isEditable = true

  if (isRangeIndexType(arrowType)) {
    // Range indices are not editable
    isEditable = false
  }

  return {
    id: `_index-${indexPosition}`,
    name: title,
    title,
    isEditable,
    arrowType,
    isIndex: true,
    isPinned: true,
    isHidden: false,
  } as BaseColumnProps
}

/**
 * Creates the column props for a data column from the Arrow metadata.
 *
 * @param data - The Arrow data.
 * @param columnPosition - The numeric position of the data column.
 *        Starts with 0 at the first non-index column.
 *
 * @return the column props for the data column.
 */
export function getColumnFromArrow(
  data: Quiver,
  columnPosition: number
): BaseColumnProps {
  // columnNames a matrix of column names.
  // Multi-level headers will have more than one row of column names.
  const columnHeaderNames = data.columnNames.map(
    column => column[columnPosition]
  )
  const title =
    columnHeaderNames.length > 0
      ? columnHeaderNames[columnHeaderNames.length - 1]
      : ""

  // If there are > 1 header columns, join all these headers with a "/"
  // and use it as the group name, but ignore empty strings headers.
  // This does not include the last column, which we use as the actual
  // column name. E.g.
  // columnHeaders = ["a", "b", "c"] -> group = "a / b" name: "c"
  // columnHeaders = ["", "b", "c"] -> group = "b" name: "c"
  // columnHeaders = ["a", "", ""] -> group = "a" name: ""

  const group =
    columnHeaderNames.length > 1
      ? columnHeaderNames
          .slice(0, -1)
          .filter(column => column !== "")
          .join(" / ")
      : undefined

  let arrowType = data.columnTypes.data[columnPosition]

  if (isNullOrUndefined(arrowType)) {
    // Use empty column type as fallback
    arrowType = {
      meta: null,
      numpy_type: "object",
      pandas_type: "object",
    } as ArrowType
  }

  let columnTypeOptions
  if (isCategoricalType(arrowType)) {
    // Get the available categories and use it in column type metadata
    const options = data.getCategoricalOptions(columnPosition)
    if (notNullOrUndefined(options)) {
      columnTypeOptions = {
        options,
      }
    }
  }

  return {
    id: `_column-${title}-${columnPosition}`,
    name: title,
    title,
    isEditable: true,
    arrowType,
    columnTypeOptions,
    isIndex: false,
    isPinned: false,
    isHidden: false,
    group,
  } as BaseColumnProps
}

/**
 * Creates the column props for an empty index column.
 * This is used for DataFrames that don't have any index.
 * At least one column is required for glide.
 */
export function getEmptyIndexColumn(): BaseColumnProps {
  return {
    id: `_empty-index`,
    title: "",
    indexNumber: 0,
    isEditable: false,
    isIndex: true,
    isPinned: true,
  } as BaseColumnProps
}

/**
 * Creates the column props for all columns from the Arrow metadata.
 *
 * @param data - The Arrow data.
 * @return the column props for all columns.
 */
export function getAllColumnsFromArrow(data: Quiver): BaseColumnProps[] {
  const columns: BaseColumnProps[] = []

  const { dimensions } = data
  const numIndices = dimensions.numIndexColumns
  const numColumns = dimensions.numDataColumns

  if (numIndices === 0 && numColumns === 0) {
    // Tables that don't have any columns cause an exception in glide-data-grid.
    // As a workaround, we are adding an empty index column in this case.
    columns.push(getEmptyIndexColumn())
    return columns
  }

  for (let i = 0; i < numIndices; i++) {
    const column = {
      ...getIndexFromArrow(data, i),
      indexNumber: i,
    } as BaseColumnProps

    columns.push(column)
  }

  for (let i = 0; i < numColumns; i++) {
    const column = {
      ...getColumnFromArrow(data, i),
      indexNumber: i + numIndices,
    } as BaseColumnProps

    columns.push(column)
  }
  return columns
}

/**
 * Returns a glide-data-grid compatible cell object based on the
 * cell data from the Quiver (Arrow) object. Different types of data will
 * result in different cell types.
 *
 * @param column - The colum of the cell.
 * @param arrowCell - The dataframe cell object from Arrow.
 * @param cssStyles - Optional css styles to apply on the cell.
 *
 * @return a GridCell object that can be used by glide-data-grid.
 */
export function getCellFromArrow(
  column: BaseColumn,
  arrowCell: DataFrameCell,
  cssStyles: string | undefined = undefined
): GridCell {
  let cellTemplate
  if (column.kind === "object") {
    // Always use display value from Quiver for object types
    // these are special types that the dataframe only support in read-only mode.

    // TODO(lukasmasuch): Move this to object column once the
    // field information is available in the arrowType.
    cellTemplate = column.getCell(
      notNullOrUndefined(arrowCell.content)
        ? removeLineBreaks(
            formatArrowCell(
              arrowCell.content,
              arrowCell.contentType,
              arrowCell.field
            )
          )
        : null
    )
  } else if (
    ["time", "date", "datetime"].includes(column.kind) &&
    notNullOrUndefined(arrowCell.content) &&
    (typeof arrowCell.content === "number" ||
      typeof arrowCell.content === "bigint")
  ) {
    // This is a special case where we want to already parse a numerical timestamp
    // to a date object based on the arrow field metadata.
    // Our implementation only supports unix timestamps in seconds, so we need to
    // do some custom conversion here.

    // TODO(lukasmasuch): Move this to time/date/datetime column once the
    // field information is available in the arrowType.
    let parsedDate
    if (
      isTimeType(column.arrowType) &&
      notNullOrUndefined(arrowCell.field?.type?.unit)
    ) {
      // Time values needs to be adjusted to seconds based on the unit
      parsedDate = convertTimeToDate(arrowCell.content, arrowCell.field)
    } else {
      // All other datetime related values are assumed to be in milliseconds
      parsedDate = moment.utc(Number(arrowCell.content)).toDate()
    }

    cellTemplate = column.getCell(parsedDate)
  } else if (isDecimalType(column.arrowType)) {
    // This is a special case where we want to already prepare a decimal value
    // to a number string based on the arrow field metadata. This is required
    // because we don't have access to the required scale in the number column.

    // TODO(lukasmasuch): Move this to number column once the
    // field information is available in the arrowType.
    const decimalStr = isNullOrUndefined(arrowCell.content)
      ? null
      : formatArrowCell(
          arrowCell.content,
          arrowCell.contentType,
          arrowCell.field
        )
    cellTemplate = column.getCell(decimalStr)
  } else {
    cellTemplate = column.getCell(arrowCell.content)
  }

  if (isErrorCell(cellTemplate)) {
    // Directly return error cells without any additional modification
    return cellTemplate
  }

  if (!column.isEditable) {
    // Only apply display content and css styles to non-editable cells.
    if (notNullOrUndefined(arrowCell.displayContent)) {
      const displayData = removeLineBreaks(arrowCell.displayContent)
      // If the display content is set, use that instead of the content.
      // This is only supported for text, object, date, datetime, time and number cells.
      // Non-editable datetime cells will use the text cell kind
      // so we don't need to handle date-time-cell cells extra here.
      if (cellTemplate.kind === GridCellKind.Text) {
        cellTemplate = {
          ...cellTemplate,
          displayData,
        } as TextCell
      } else if (
        cellTemplate.kind === GridCellKind.Number &&
        // Only apply styler value if format was not explicitly set by the user.
        isNullOrUndefined(
          (column.columnTypeOptions as NumberColumnParams)?.format
        )
      ) {
        cellTemplate = {
          ...cellTemplate,
          displayData,
        } as NumberCell
      } else if (
        cellTemplate.kind === GridCellKind.Uri &&
        // Only apply styler value if display text was not explicitly set by the user.
        isNullOrUndefined(
          (column.columnTypeOptions as LinkColumnParams)?.display_text
        )
      ) {
        cellTemplate = {
          ...cellTemplate,
          displayData,
        } as UriCell
      } else if (
        cellTemplate.kind === GridCellKind.Custom &&
        (cellTemplate as DatePickerType).data?.kind === "date-picker-cell" &&
        // Only apply styler value if format was not explicitly set by the user.
        isNullOrUndefined(
          (column.columnTypeOptions as DateTimeColumnParams)?.format
        )
      ) {
        cellTemplate = {
          ...cellTemplate,
          data: {
            ...(cellTemplate as DatePickerType).data,
            displayDate: displayData,
          },
        } as DatePickerType
      }
    }

    if (cssStyles && arrowCell.cssId) {
      cellTemplate = applyPandasStylerCss(
        cellTemplate,
        arrowCell.cssId,
        cssStyles
      )
    }
  }
  return cellTemplate
}


================================================
File: /frontend/lib/src/components/widgets/DataFrame/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./DataFrame"


================================================
File: /frontend/lib/src/components/widgets/DataFrame/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export interface StyledResizableContainerProps {
  hasCustomizedScrollbars: boolean
}

/**
 * A resizable data grid container component.
 */
export const StyledResizableContainer =
  styled.div<StyledResizableContainerProps>(
    ({ hasCustomizedScrollbars, theme }) => ({
      position: "relative",
      display: "inline-block",

      "& .stDataFrameGlideDataEditor": {
        height: "100%",
        minWidth: "100%",
        borderRadius: theme.radii.default,
      },

      "& .dvn-scroller": {
        // We only want to configure scrollbar aspects for browsers that
        // don't support custom scrollbars (e.g. Firefox). Also, applying this
        // in Chrome causes the scrollbar to change to the default scrollbar style.
        ...(!hasCustomizedScrollbars && { scrollbarWidth: "thin" }),
        ["overflowX" as any]: "auto !important",
        ["overflowY" as any]: "auto !important",
      },
    })
  )


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/ChartColumn.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCellKind } from "@glideapps/glide-data-grid"
import { SparklineCellType } from "@glideapps/glide-data-grid-cells"

import {
  AREA_CHART_TYPE,
  AreaChartColumn,
  BAR_CHART_TYPE,
  BarChartColumn,
  ChartColumnParams,
  LINE_CHART_TYPE,
  LineChartColumn,
} from "./ChartColumn"
import { BaseColumnProps, isErrorCell } from "./utils"

const CHART_COLUMN_TEMPLATE = {
  id: "1",
  name: "chart_column",
  title: "Chart column",
  indexNumber: 0,
  isEditable: false,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
  arrowType: {
    // The arrow type of the underlying data is
    // not used for anything inside the column.
    pandas_type: "object",
    numpy_type: "list[float64]",
  },
} as BaseColumnProps

function getLineChartColumn(
  params?: ChartColumnParams
): ReturnType<typeof LineChartColumn> {
  return LineChartColumn({
    ...CHART_COLUMN_TEMPLATE,
    columnTypeOptions: params,
  } as BaseColumnProps)
}

function getBarChartColumn(
  params?: ChartColumnParams
): ReturnType<typeof BarChartColumn> {
  return BarChartColumn({
    ...CHART_COLUMN_TEMPLATE,
    columnTypeOptions: params,
  } as BaseColumnProps)
}

function getAreaChartColumn(
  params?: ChartColumnParams
): ReturnType<typeof AreaChartColumn> {
  return AreaChartColumn({
    ...CHART_COLUMN_TEMPLATE,
    columnTypeOptions: params,
  } as BaseColumnProps)
}

describe("ChartColumn", () => {
  it("creates a valid column instance", () => {
    const mockColumn = getLineChartColumn()
    expect(mockColumn.kind).toEqual(LINE_CHART_TYPE)
    expect(mockColumn.title).toEqual(CHART_COLUMN_TEMPLATE.title)
    expect(mockColumn.id).toEqual(CHART_COLUMN_TEMPLATE.id)
    expect(mockColumn.sortMode).toEqual("default")

    // Column should be readonly:
    expect(mockColumn.isEditable).toEqual(false)

    const mockCell = mockColumn.getCell([0.1, 0.2, 0.3])
    expect(mockCell.kind).toEqual(GridCellKind.Custom)
    expect((mockCell as SparklineCellType).data?.values).toEqual([
      0.1, 0.2, 0.3,
    ])
    expect((mockCell as SparklineCellType).data?.displayValues).toEqual([
      "0.1",
      "0.2",
      "0.3",
    ])
  })

  it("supports configuring the chart type", () => {
    const mockColumn = getLineChartColumn()
    expect(mockColumn.kind).toEqual(LINE_CHART_TYPE)
    const mockCell = mockColumn.getCell([0.1, 0.2, 0.3])
    // Default chart type is line
    expect((mockCell as SparklineCellType).data?.graphKind).toEqual("line")

    const mockBarChartColumn = getBarChartColumn()
    expect(mockBarChartColumn.kind).toEqual(BAR_CHART_TYPE)
    const mockBarChartCell = mockBarChartColumn.getCell([0.1, 0.2, 0.3])
    // Chart type should be bar
    expect((mockBarChartCell as SparklineCellType).data?.graphKind).toEqual(
      "bar"
    )

    const mockAreaChartColumn = getAreaChartColumn()
    expect(mockAreaChartColumn.kind).toEqual(AREA_CHART_TYPE)
    const mockAreaChartCell = mockAreaChartColumn.getCell([0.1, 0.2, 0.3])
    // Chart type should be area
    expect((mockAreaChartCell as SparklineCellType).data?.graphKind).toEqual(
      "area"
    )
  })

  it("supports configuring min/max scale", () => {
    const mockColumn = getLineChartColumn()
    const mockCell = mockColumn.getCell([-100, 0, 100])
    // Default min/max scale is 0/1 so the values should be normalized:
    expect((mockCell as SparklineCellType).data?.values).toEqual([0, 0.5, 1])

    // Use a different scale
    const mockColumn1 = getLineChartColumn({
      y_min: -100,
      y_max: 100,
    })
    const mockCell1 = mockColumn1.getCell([-100, 0, 100])
    expect((mockCell1 as SparklineCellType).data?.values).toEqual([
      -100, 0, 100,
    ])

    // Use a different scale
    const mockColumn2 = getLineChartColumn({
      y_min: -1,
      y_max: 1,
    })
    const mockCell2 = mockColumn2.getCell([-100, 0, 100])
    // This should automatically normalize the values to the min/max scale:
    expect((mockCell2 as SparklineCellType).data?.values).toEqual([-1, 0, 1])

    // Use a different scale
    const mockColumn3 = getLineChartColumn({
      y_min: 0,
      y_max: 200,
    })
    const mockCell3 = mockColumn3.getCell([-100, 0, 100])
    // This should automatically normalize the values to the min/max scale:
    expect((mockCell3 as SparklineCellType).data?.values).toEqual([
      0, 100, 200,
    ])

    // Use a different scale
    const mockColumn4 = getLineChartColumn({
      y_min: -200,
      y_max: 200,
    })
    const mockCell4 = mockColumn4.getCell([-100, 0, 100])
    // The values fit into the scale, so don't do anything:
    expect((mockCell4 as SparklineCellType).data?.values).toEqual([
      -100, 0, 100,
    ])

    // Use a different scale
    const mockColumn5 = getLineChartColumn({
      y_min: 100,
      y_max: -100,
    })
    const mockCell5 = mockColumn5.getCell([-100, 0, 100])
    // min needs to be bigger than max, so this should be an error cell:
    expect(isErrorCell(mockCell5)).toEqual(true)

    // Use a different scale
    const mockColumn6 = getLineChartColumn({
      y_min: undefined,
      y_max: -100,
    })
    const mockCell6 = mockColumn6.getCell([-100, 0, 100])
    // min and max need to be defined, so this should be an error cell:
    expect(isErrorCell(mockCell6)).toEqual(true)
  })

  it("works with single values or only same values without running into division by zero", () => {
    const mockColumn = getBarChartColumn({
      y_min: 0,
      y_max: 100,
    })

    const mockCell1 = mockColumn.getCell([101])
    // The value should be normalized to 100:
    expect((mockCell1 as SparklineCellType).data?.values).toEqual([100])

    const mockCell2 = mockColumn.getCell([101, 101])
    // All values should be normalized to 100:
    expect((mockCell2 as SparklineCellType).data?.values).toEqual([100, 100])

    const mockCell3 = mockColumn.getCell([-1, -1])
    // All values should be normalized to 0:
    expect((mockCell3 as SparklineCellType).data?.values).toEqual([0, 0])
  })

  it.each([
    // Supports almost the same as toSafeArray
    [null, null],
    [undefined, null],
    ["", null],
    [[], null],
    // Comma separated syntax
    ["0.1,0.2", [0.1, 0.2]],
    // JSON Array syntax
    [`["0.1","0.2"]`, [0.1, 0.2]],
    ["1", [1]],
    [0, [0]],
    [1, [1]],
    [
      [0, 0.2, 0.1],
      [0, 0.2, 0.1],
    ],
    [true, [1]],
    [false, [0]],
  ])(
    "supports numerical array-compatible value (%p parsed as %p)",
    (input: any, value: any[] | null) => {
      const mockColumn = getBarChartColumn()
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
    }
  )

  it.each([
    ["foo"],
    ["foo, bar"],
    ["0.1,0.4,foo"],
    ["0.1,0.4,"],
    [["foo", "bar"]],
    [[0.1, 0.4, "foo"]],
    [[0.1, 0.4, null]],
  ])("%p results in error cell", (input: any) => {
    const mockColumn = getLineChartColumn()
    const cell = mockColumn.getCell(input)
    expect(isErrorCell(cell)).toEqual(true)
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/ChartColumn.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  GridCell,
  GridCellKind,
  LoadingCell,
} from "@glideapps/glide-data-grid"
import { SparklineCellType } from "@glideapps/glide-data-grid-cells"

import { isNullOrUndefined } from "@streamlit/lib/src/util/utils"

import {
  BaseColumn,
  BaseColumnProps,
  formatNumber,
  getEmptyCell,
  getErrorCell,
  mergeColumnParameters,
  toSafeArray,
  toSafeNumber,
  toSafeString,
} from "./utils"

export const LINE_CHART_TYPE = "line_chart"
export const AREA_CHART_TYPE = "area_chart"
export const BAR_CHART_TYPE = "bar_chart"

export interface ChartColumnParams {
  // The minimum value used for plotting the chart. Defaults to 0.
  readonly y_min?: number
  // The maximum value used for plotting the chart. Defaults to 1.
  readonly y_max?: number
}

/**
 * Base class for chart columns. This class is not meant to be used directly.
 * Instead, use the LineChartColumn and BarChartColumn classes.
 */
function BaseChartColumn(
  kind: string,
  props: BaseColumnProps,
  chart_type: "line" | "bar" | "area"
): BaseColumn {
  const parameters = mergeColumnParameters(
    // Default parameters:
    {
      y_min: 0,
      y_max: 1,
    },
    // User parameters:
    props.columnTypeOptions
  ) as ChartColumnParams

  const cellTemplate = {
    kind: GridCellKind.Custom,
    allowOverlay: false,
    copyData: "",
    contentAlign: props.contentAlignment,
    data: {
      kind: "sparkline-cell",
      values: [],
      displayValues: [],
      graphKind: chart_type,
      yAxis: [parameters.y_min, parameters.y_max],
    },
  } as SparklineCellType

  return {
    ...props,
    kind,
    sortMode: "default",
    isEditable: false, // Chart column is always read-only
    getCell(data?: any): GridCell {
      if (
        isNullOrUndefined(parameters.y_min) ||
        isNullOrUndefined(parameters.y_max) ||
        Number.isNaN(parameters.y_min) ||
        Number.isNaN(parameters.y_max) ||
        parameters.y_min >= parameters.y_max
      ) {
        return getErrorCell(
          "Invalid min/max y-axis configuration",
          `The y_min (${parameters.y_min}) and y_max (${parameters.y_max}) configuration options must be valid numbers.`
        )
      }

      if (isNullOrUndefined(data)) {
        // TODO(lukasmasuch): Use a missing cell?
        return getEmptyCell()
      }

      const chartData = toSafeArray(data)

      const convertedChartData: number[] = []
      let normalizedChartData: number[] = []
      if (chartData.length === 0) {
        return getEmptyCell()
      }

      // Initialize with smallest and biggest number
      let maxValue = Number.MIN_SAFE_INTEGER
      let minValue = Number.MAX_SAFE_INTEGER

      // Try to convert all values to numbers and find min/max
      for (let i = 0; i < chartData.length; i++) {
        const convertedValue = toSafeNumber(chartData[i])
        if (
          Number.isNaN(convertedValue) ||
          isNullOrUndefined(convertedValue)
        ) {
          return getErrorCell(
            toSafeString(chartData),
            `The value cannot be interpreted as a numeric array. ${toSafeString(
              convertedValue
            )} is not a number.`
          )
        }

        if (convertedValue > maxValue) {
          maxValue = convertedValue
        }

        if (convertedValue < minValue) {
          minValue = convertedValue
        }

        convertedChartData.push(convertedValue)
      }

      if (
        convertedChartData.length > 0 &&
        (maxValue > parameters.y_max || minValue < parameters.y_min)
      ) {
        // Normalize values between the configured range
        normalizedChartData = convertedChartData.map(v =>
          maxValue - minValue === 0 // Prevent division by zero
            ? maxValue > (parameters.y_max || 1)
              ? parameters.y_max || 1 // Use max value
              : parameters.y_min || 0 // Use min value
            : ((parameters.y_max || 1) - (parameters.y_min || 0)) *
                ((v - minValue) / (maxValue - minValue)) +
              (parameters.y_min || 0)
        )
      } else {
        // Values are already in the configured range
        normalizedChartData = convertedChartData
      }

      return {
        ...cellTemplate,
        copyData: convertedChartData.join(","), // Column sorting is done via the copyData value
        data: {
          ...cellTemplate.data,
          values: normalizedChartData,
          displayValues: convertedChartData.map(v => formatNumber(v)),
        },
        isMissingValue: isNullOrUndefined(data),
      } as SparklineCellType
    },
    getCellValue(
      cell: SparklineCellType | LoadingCell
    ): readonly number[] | null {
      if (cell.kind === GridCellKind.Loading) {
        return null
      }

      return cell.data?.values === undefined ? null : cell.data?.values
    },
  }
}

/**
 * A column type that renders the cell value as a line-chart.
 * The data is expected to be a numeric array.
 *
 * This column type is currently read-only.
 */
export function LineChartColumn(props: BaseColumnProps): BaseColumn {
  return BaseChartColumn(LINE_CHART_TYPE, props, "line")
}

LineChartColumn.isEditableType = false

/**
 * A column type that renders the cell value as a bar-chart.
 * The data is expected to be a numeric array.
 *
 * This column type is currently read-only.
 */
export function BarChartColumn(props: BaseColumnProps): BaseColumn {
  return BaseChartColumn(BAR_CHART_TYPE, props, "bar")
}

BarChartColumn.isEditableType = false

/**
 * A column type that renders the cell value as an area-chart.
 * The data is expected to be a numeric array.
 *
 * This column type is currently read-only.
 */
export function AreaChartColumn(props: BaseColumnProps): BaseColumn {
  return BaseChartColumn(AREA_CHART_TYPE, props, "area")
}

AreaChartColumn.isEditableType = false


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/CheckboxColumn.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { BooleanCell, GridCellKind } from "@glideapps/glide-data-grid"

import CheckboxColumn from "./CheckboxColumn"
import { isErrorCell } from "./utils"

const MOCK_CHECKBOX_COLUMN_PROPS = {
  id: "1",
  name: "checkbox_column",
  title: "Checkbox column",
  indexNumber: 0,
  isEditable: false,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
  arrowType: {
    // The arrow type of the underlying data is
    // not used for anything inside the column.
    pandas_type: "bool",
    numpy_type: "bool",
  },
}

describe("CheckboxColumn", () => {
  it("creates a valid column instance", () => {
    const mockColumn = CheckboxColumn(MOCK_CHECKBOX_COLUMN_PROPS)
    expect(mockColumn.kind).toEqual("checkbox")
    expect(mockColumn.title).toEqual(MOCK_CHECKBOX_COLUMN_PROPS.title)
    expect(mockColumn.id).toEqual(MOCK_CHECKBOX_COLUMN_PROPS.id)
    expect(mockColumn.sortMode).toEqual("default")

    const mockCell = mockColumn.getCell(true)
    expect(mockCell.kind).toEqual(GridCellKind.Boolean)
    expect((mockCell as BooleanCell).data).toEqual(true)
  })

  it.each([
    [true, true],
    [false, false],
    ["true", true],
    ["false", false],
    ["yes", true],
    ["no", false],
    ["t", true],
    ["f", false],
    ["y", true],
    ["n", false],
    ["on", true],
    ["off", false],
    ["1", true],
    ["0", false],
    [1, true],
    [0, false],
    [[], null],
    [null, null],
    [undefined, null],
    ["", null],
  ])(
    "supports boolean compatible value (%p parsed as %p)",
    (input: any, value: boolean | null) => {
      const mockColumn = CheckboxColumn(MOCK_CHECKBOX_COLUMN_PROPS)
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
      expect(isErrorCell(cell)).toEqual(false)
    }
  )

  it.each([["foo"], [12345], [0.1], [["foo", "bar"]]])(
    "%p results in error cell: %p",
    (input: any) => {
      const mockColumn = CheckboxColumn(MOCK_CHECKBOX_COLUMN_PROPS)
      const cell = mockColumn.getCell(input)
      expect(isErrorCell(cell)).toEqual(true)
    }
  )
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/CheckboxColumn.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  BooleanCell,
  GridCell,
  GridCellKind,
} from "@glideapps/glide-data-grid"

import { isNullOrUndefined } from "@streamlit/lib/src/util/utils"

import {
  BaseColumn,
  BaseColumnProps,
  getErrorCell,
  toSafeBoolean,
  toSafeString,
} from "./utils"

/**
 * A column type that supports optimized rendering and editing for boolean values
 * by using checkboxes.
 */
function CheckboxColumn(props: BaseColumnProps): BaseColumn {
  const cellTemplate = {
    kind: GridCellKind.Boolean,
    data: false,
    allowOverlay: false, // no overlay possible
    contentAlign: props.contentAlignment,
    readonly: !props.isEditable,
    style: "normal",
  } as BooleanCell

  return {
    ...props,
    kind: "checkbox",
    sortMode: "default",
    getCell(data?: any): GridCell {
      let cellData = null

      cellData = toSafeBoolean(data)
      if (cellData === undefined) {
        return getErrorCell(
          toSafeString(data),
          `The value cannot be interpreted as boolean.`
        )
      }

      // We are not setting isMissingValue here because the checkbox column
      // does not work with the missing cell rendering.
      return {
        ...cellTemplate,
        data: cellData,
        isMissingValue: isNullOrUndefined(cellData),
      } as BooleanCell
    },
    getCellValue(cell: BooleanCell): boolean | null {
      return cell.data === undefined ? null : cell.data
    },
  }
}

CheckboxColumn.isEditableType = true

export default CheckboxColumn


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/DateTimeColumn.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable  @typescript-eslint/no-non-null-assertion */

import { GridCellKind } from "@glideapps/glide-data-grid"
import { DatePickerType } from "@glideapps/glide-data-grid-cells"

import DateTimeColumn, { DateColumn, TimeColumn } from "./DateTimeColumn"
import { BaseColumnProps, isErrorCell } from "./utils"

const MOCK_DATETIME_COLUMN_TEMPLATE: BaseColumnProps = {
  id: "1",
  name: "datetime_column",
  title: "datetime_column",
  indexNumber: 0,
  isEditable: true,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
  arrowType: {
    // The arrow type of the underlying data is
    // not used for anything inside the column.
    pandas_type: "datetime",
    numpy_type: "datetime64",
  },
}

const MOCK_DATE_COLUMN_TEMPLATE: BaseColumnProps = {
  id: "1",
  name: "date_column",
  title: "date_column",
  indexNumber: 0,
  isEditable: true,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
  arrowType: {
    // The arrow type of the underlying data is
    // not used for anything inside the column.
    pandas_type: "date",
    numpy_type: "object",
  },
}

const MOCK_TIME_COLUMN_TEMPLATE: BaseColumnProps = {
  id: "1",
  name: "time_column",
  title: "time_column",
  indexNumber: 0,
  isEditable: true,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
  arrowType: {
    // The arrow type of the underlying data is
    // not used for anything inside the column.
    pandas_type: "time",
    numpy_type: "object",
  },
}

function getTodayIsoDate(): string {
  return new Date().toISOString().split("T")[0]
}

const EXAMPLE_DATE = new Date("2023-04-25T10:30:00.000Z")

describe("DateTimeColumn", () => {
  it("creates a valid column instance", () => {
    const mockColumn = DateTimeColumn(MOCK_DATETIME_COLUMN_TEMPLATE)
    expect(mockColumn.kind).toEqual("datetime")
    expect(mockColumn.title).toEqual(MOCK_DATETIME_COLUMN_TEMPLATE.title)
    expect(mockColumn.id).toEqual(MOCK_DATETIME_COLUMN_TEMPLATE.id)
    expect(mockColumn.sortMode).toEqual("default")

    const mockCell = mockColumn.getCell(EXAMPLE_DATE)
    expect(mockCell.kind).toEqual(GridCellKind.Custom)
    expect((mockCell as DatePickerType).data.date).toEqual(EXAMPLE_DATE)
  })

  it.each([
    // valid date object
    [new Date("2023-04-25"), "2023-04-25T00:00:00.000"],
    // undefined value
    [undefined, null],
    // null value
    [null, null],
    // empty string
    ["", null],
    // valid date string
    ["2023-04-25", "2023-04-25T00:00:00.000"],
    // valid unix timestamp
    [1671951600, "2022-12-25T07:00:00.000"],
    // valid bigint
    [BigInt(1671951600), "2022-12-25T07:00:00.000"],
    // other date formats:
    ["04/25/2023", "2023-04-25T00:00:00.000"],
    // valid ISO date string
    ["2023-04-25T10:30:00.000Z", "2023-04-25T10:30:00.000"],
    // valid date string with time
    ["2023-04-25 10:30", "2023-04-25T10:30:00.000"],
    // valid date string with timezone
    ["2023-04-25T10:30:00.000+02:00", "2023-04-25T08:30:00.000"],
    // valid time string
    ["10:30", getTodayIsoDate() + "T10:30:00.000"],
    // valid time string with milliseconds
    ["10:30:25.123", getTodayIsoDate() + "T10:30:25.123"],
    // valid time string with seconds
    ["10:30:25", getTodayIsoDate() + "T10:30:25.000"],
    // valid month string
    ["Jan 2023", "2023-01-01T00:00:00.000"],
    // valid month string with day
    ["Jan 15, 2023", "2023-01-15T00:00:00.000"],
    // valid date string with day and month names
    ["25 April 2023", "2023-04-25T00:00:00.000"],
    // valid date string with day and short month names
    ["25 Apr 2023", "2023-04-25T00:00:00.000"],
    // valid date string with short day and month names
    ["Tue, 25 Apr 2023", "2023-04-25T00:00:00.000"],
    // valid date string with time and AM/PM
    ["2023-04-25 10:30 AM", "2023-04-25T10:30:00.000"],
    // valid Unix timestamp in milliseconds as a string
    ["1671951600", "2022-12-25T07:00:00.000"],
  ])(
    "supports datetime-compatible value (%p parsed as %p)",
    (input: any, value: string | null) => {
      const mockColumn = DateTimeColumn(MOCK_DATETIME_COLUMN_TEMPLATE)
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
    }
  )

  it.each([[NaN], ["foo"]])("%p results in error cell", (input: any) => {
    const mockColumn = DateTimeColumn(MOCK_DATETIME_COLUMN_TEMPLATE)
    const cell = mockColumn.getCell(input)
    expect(isErrorCell(cell)).toEqual(true)
  })

  it("respects min_value config option", () => {
    const MOCK_DATETIME_COLUMN_WITH_MIN: BaseColumnProps = {
      ...MOCK_DATETIME_COLUMN_TEMPLATE,
      columnTypeOptions: {
        min_value: "2023-04-24T00:00:00",
      },
    }

    const mockColumn = DateTimeColumn(MOCK_DATETIME_COLUMN_WITH_MIN)
    const minValue = new Date("2023-04-24T00:00:00.000Z")
    const belowMinValue = new Date("2023-04-23T23:59:59.000Z")
    const aboveMinValue = new Date("2023-04-25T23:59:59.000Z")

    // Check valid values
    const minCell = mockColumn.getCell(minValue, true)
    expect(mockColumn.validateInput!(minValue)).toBeTruthy()
    expect(mockColumn.getCellValue(minCell)).toEqual("2023-04-24T00:00:00.000")

    const aboveMinValueCell = mockColumn.getCell(aboveMinValue, true)
    expect(mockColumn.validateInput!(aboveMinValue)).toBeTruthy()
    expect(mockColumn.getCellValue(aboveMinValueCell)).toEqual(
      "2023-04-25T23:59:59.000"
    )

    // Check invalid values
    const belowMinCell = mockColumn.getCell(belowMinValue, true)
    expect(mockColumn.validateInput!(belowMinValue)).toBeFalsy()
    expect(isErrorCell(belowMinCell)).toEqual(true)
  })

  it("respects max_value config option", () => {
    const MOCK_DATETIME_COLUMN_WITH_MAX: BaseColumnProps = {
      ...MOCK_DATETIME_COLUMN_TEMPLATE,
      columnTypeOptions: {
        max_value: "2023-04-24T00:00:00",
      },
    }

    const mockColumn = DateTimeColumn(MOCK_DATETIME_COLUMN_WITH_MAX)
    const maxValue = new Date("2023-04-24T00:00:00.000Z")
    const belowMaxValue = new Date("2023-04-23T23:59:59.000Z")
    const aboveMaxValue = new Date("2023-04-25T23:59:59.000Z")

    // Check valid values
    const maxCell = mockColumn.getCell(maxValue, true)
    expect(mockColumn.validateInput!(maxValue)).toBeTruthy()
    expect(mockColumn.getCellValue(maxCell)).toEqual("2023-04-24T00:00:00.000")

    const belowMaxValueCell = mockColumn.getCell(belowMaxValue, true)
    expect(mockColumn.validateInput!(belowMaxValue)).toBeTruthy()
    expect(mockColumn.getCellValue(belowMaxValueCell)).toEqual(
      "2023-04-23T23:59:59.000"
    )

    // Check invalid values
    const aboveMaxCell = mockColumn.getCell(aboveMaxValue, true)
    expect(mockColumn.validateInput!(aboveMaxValue)).toBeFalsy()
    expect(isErrorCell(aboveMaxCell)).toEqual(true)
  })

  it("changes the step size based on the config option", () => {
    const MOCK_DATETIME_COLUMN_WITH_STEP: BaseColumnProps = {
      ...MOCK_DATETIME_COLUMN_TEMPLATE,
      columnTypeOptions: {
        step: 60,
      },
    }

    const mockColumn = DateTimeColumn(MOCK_DATETIME_COLUMN_WITH_STEP)
    const newCell = mockColumn.getCell(EXAMPLE_DATE)
    expect((newCell as DatePickerType).data.step).toBe("60")
  })

  it("formats according to the provided format config option", () => {
    const MOCK_DATETIME_COLUMN_CUSTOM_FORMAT = {
      ...MOCK_DATETIME_COLUMN_TEMPLATE,
      columnTypeOptions: {
        format: "MMM Do, YYYY - HH:mm",
      },
    }

    const mockColumn = DateTimeColumn(MOCK_DATETIME_COLUMN_CUSTOM_FORMAT)
    const cell = mockColumn.getCell(EXAMPLE_DATE)
    expect((cell as DatePickerType).data.displayDate).toEqual(
      "Apr 25th, 2023 - 10:30"
    )
  })

  it("supports columns with timezone", () => {
    const MOCK_DATETIME_COLUMN_TEMPLATE_WITH_TIMEZONE: BaseColumnProps = {
      ...MOCK_DATETIME_COLUMN_TEMPLATE,
      arrowType: {
        ...MOCK_DATETIME_COLUMN_TEMPLATE.arrowType,
        meta: { timezone: "+05:00" },
      },
    }

    const mockColumn = DateTimeColumn(
      MOCK_DATETIME_COLUMN_TEMPLATE_WITH_TIMEZONE
    )
    const mockCell = mockColumn.getCell(EXAMPLE_DATE)
    expect((mockCell as DatePickerType).data.date).toEqual(EXAMPLE_DATE)
    expect((mockCell as DatePickerType).data.displayDate).toEqual(
      "2023-04-25 15:30:00+05:00"
    )
    expect((mockCell as DatePickerType).data.timezoneOffset).toEqual(300)
  })
})

describe("DateColumn", () => {
  it("creates a valid column instance", () => {
    const mockColumn = DateColumn(MOCK_DATE_COLUMN_TEMPLATE)
    expect(mockColumn.kind).toEqual("date")
    expect(mockColumn.title).toEqual(MOCK_DATE_COLUMN_TEMPLATE.title)
    expect(mockColumn.id).toEqual(MOCK_DATE_COLUMN_TEMPLATE.id)
    expect(mockColumn.sortMode).toEqual("default")

    const mockCell = mockColumn.getCell(EXAMPLE_DATE)
    expect(mockCell.kind).toEqual(GridCellKind.Custom)
    expect((mockCell as DatePickerType).copyData).toEqual("2023-04-25")
  })

  it.each([
    // valid date object
    [new Date("2023-04-25"), "2023-04-25"],
    // undefined value
    [undefined, null],
    // null value
    [null, null],
    // empty string
    ["", null],
    // valid date string
    ["2023-04-25", "2023-04-25"],
    // valid unix timestamp
    [1671951600, "2022-12-25"],
    // valid bigint
    [BigInt(1671951600), "2022-12-25"],
    // other date formats:
    ["04/25/2023", "2023-04-25"],
    // valid ISO date string
    ["2023-04-25T10:30:00.000Z", "2023-04-25"],
    // valid date string with time
    ["2023-04-25 10:30", "2023-04-25"],
    // valid date string with timezone
    ["2023-04-25T10:30:00.000+02:00", "2023-04-25"],
    // valid time string
    ["10:30", getTodayIsoDate()],
    // valid time string with milliseconds
    ["10:30:25.123", getTodayIsoDate()],
    // valid time string with seconds
    ["10:30:25", getTodayIsoDate()],
    // valid month string
    ["Jan 2023", "2023-01-01"],
    // valid month string with day
    ["Jan 15, 2023", "2023-01-15"],
    // valid date string with day and month names
    ["25 April 2023", "2023-04-25"],
    // valid date string with day and short month names
    ["25 Apr 2023", "2023-04-25"],
    // valid date string with short day and month names
    ["Tue, 25 Apr 2023", "2023-04-25"],
    // valid date string with time and AM/PM
    ["2023-04-25 10:30 AM", "2023-04-25"],
    // valid Unix timestamp in seconds as a string
    ["1671951600", "2022-12-25"],
  ])(
    "supports date-compatible value (%p parsed as %p)",
    (input: any, value: string | null) => {
      const mockColumn = DateColumn(MOCK_DATE_COLUMN_TEMPLATE)
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
    }
  )

  it.each([[NaN], ["foo"]])("%p results in error cell", (input: any) => {
    const mockColumn = DateColumn(MOCK_DATE_COLUMN_TEMPLATE)
    const cell = mockColumn.getCell(input)
    expect(isErrorCell(cell)).toEqual(true)
  })

  it("respects min_value config option", () => {
    const MOCK_DATE_COLUMN_TEMPLATE_WITH_MIN: BaseColumnProps = {
      ...MOCK_DATE_COLUMN_TEMPLATE,
      columnTypeOptions: {
        min_value: "2023-04-24",
      },
    }

    const mockColumn = DateColumn(MOCK_DATE_COLUMN_TEMPLATE_WITH_MIN)
    const minValue = new Date("2023-04-24")
    const belowMinValue = new Date("2023-04-23")
    const aboveMinValue = new Date("2023-04-25")

    // Check valid values
    const minCell = mockColumn.getCell(minValue, true)
    expect(mockColumn.validateInput!(minValue)).toBeTruthy()
    expect(mockColumn.getCellValue(minCell)).toEqual("2023-04-24")

    const aboveMinValueCell = mockColumn.getCell(aboveMinValue, true)
    expect(mockColumn.validateInput!(aboveMinValue)).toBeTruthy()
    expect(mockColumn.getCellValue(aboveMinValueCell)).toEqual("2023-04-25")

    // Check invalid values
    const belowMinCell = mockColumn.getCell(belowMinValue, true)
    expect(mockColumn.validateInput!(belowMinValue)).toBeFalsy()
    expect(isErrorCell(belowMinCell)).toEqual(true)
  })

  it("respects max_value config option", () => {
    const MOCK_DATE_COLUMN_TEMPLATE_WITH_MAX: BaseColumnProps = {
      ...MOCK_DATE_COLUMN_TEMPLATE,
      columnTypeOptions: {
        max_value: "2023-04-24",
      },
    }

    const mockColumn = DateColumn(MOCK_DATE_COLUMN_TEMPLATE_WITH_MAX)
    const maxValue = new Date("2023-04-24")
    const belowMaxValue = new Date("2023-04-23")
    const aboveMaxValue = new Date("2023-04-25")

    // Check valid values
    const maxCell = mockColumn.getCell(maxValue, true)
    expect(mockColumn.validateInput!(maxValue)).toBeTruthy()
    expect(mockColumn.getCellValue(maxCell)).toEqual("2023-04-24")

    const belowMaxValueCell = mockColumn.getCell(belowMaxValue, true)
    expect(mockColumn.validateInput!(belowMaxValue)).toBeTruthy()
    expect(mockColumn.getCellValue(belowMaxValueCell)).toEqual("2023-04-23")

    // Check invalid values
    const aboveMaxCell = mockColumn.getCell(aboveMaxValue, true)
    expect(mockColumn.validateInput!(aboveMaxValue)).toBeFalsy()
    expect(isErrorCell(aboveMaxCell)).toEqual(true)
  })

  it("changes the step size based on the config option", () => {
    const MOCK_DATE_COLUMN_WITH_STEP: BaseColumnProps = {
      ...MOCK_DATE_COLUMN_TEMPLATE,
      columnTypeOptions: {
        step: 2,
      },
    }

    const mockColumn = DateColumn(MOCK_DATE_COLUMN_WITH_STEP)
    const newCell = mockColumn.getCell(EXAMPLE_DATE)
    expect((newCell as DatePickerType).data.step).toBe("2")
  })

  it("formats according to the provided format config option", () => {
    const MOCK_DATE_COLUMN_CUSTOM_FORMAT = {
      ...MOCK_DATE_COLUMN_TEMPLATE,
      columnTypeOptions: {
        format: "MMM Do, YYYY",
      },
    }

    const mockColumn = DateColumn(MOCK_DATE_COLUMN_CUSTOM_FORMAT)
    const cell = mockColumn.getCell(EXAMPLE_DATE)
    expect((cell as DatePickerType).data.displayDate).toEqual("Apr 25th, 2023")
  })
})

describe("TimeColumn", () => {
  it("creates a valid column instance", () => {
    const mockColumn = TimeColumn(MOCK_TIME_COLUMN_TEMPLATE)
    expect(mockColumn.kind).toEqual("time")
    expect(mockColumn.title).toEqual(MOCK_TIME_COLUMN_TEMPLATE.title)
    expect(mockColumn.id).toEqual(MOCK_TIME_COLUMN_TEMPLATE.id)
    expect(mockColumn.sortMode).toEqual("default")

    const mockCell = mockColumn.getCell(EXAMPLE_DATE)
    expect(mockCell.kind).toEqual(GridCellKind.Custom)
    expect((mockCell as DatePickerType).copyData).toEqual("10:30:00")
  })

  it.each([
    // valid date object
    [new Date("2023-04-25"), "00:00:00.000"],
    // undefined value
    [undefined, null],
    // null value
    [null, null],
    // empty string
    ["", null],
    // valid date string
    ["2023-04-25", "00:00:00.000"],
    // valid unix timestamp
    [1671951600, "07:00:00.000"],
    // valid bigint
    [BigInt(1671951600), "07:00:00.000"],
    // other date formats:
    ["04/25/2023", "00:00:00.000"],
    // valid ISO date string
    ["2023-04-25T10:30:00.000Z", "10:30:00.000"],
    // valid date string with time
    ["2023-04-25 10:30", "10:30:00.000"],
    // valid date string with timezone
    ["2023-04-25T10:30:00.000+02:00", "08:30:00.000"],
    // valid time string
    ["10:30", "10:30:00.000"],
    // valid time string with milliseconds
    ["10:30:25.123", "10:30:25.123"],
    // valid time string with seconds
    ["10:30:25", "10:30:25.000"],
    // valid month string
    ["Jan 2023", "00:00:00.000"],
    // valid date string with day and month names
    ["25 April 2023", "00:00:00.000"],
    // valid date string with short day and month names
    ["Tue, 25 Apr 2023", "00:00:00.000"],
    // valid date string with time and AM/PM
    ["2023-04-25 10:30 AM", "10:30:00.000"],
    // valid Unix timestamp in milliseconds as a string
    ["1671951600", "07:00:00.000"],
  ])(
    "supports time-compatible value (%p parsed as %p)",
    (input: any, value: string | null) => {
      const mockColumn = TimeColumn(MOCK_TIME_COLUMN_TEMPLATE)
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
    }
  )

  it.each([[NaN], ["foo"]])("%p results in error cell", (input: any) => {
    const mockColumn = TimeColumn(MOCK_TIME_COLUMN_TEMPLATE)
    const cell = mockColumn.getCell(input)
    expect(isErrorCell(cell)).toEqual(true)
  })

  it("respects min_value config option", () => {
    const MOCK_TIME_COLUMN_TEMPLATE_WITH_MIN: BaseColumnProps = {
      ...MOCK_TIME_COLUMN_TEMPLATE,
      columnTypeOptions: {
        min_value: "10:59:59",
      },
    }

    const mockColumn = TimeColumn(MOCK_TIME_COLUMN_TEMPLATE_WITH_MIN)
    const minValue = "10:59:59.000"
    const belowMinValue = "10:59:58.345"
    const aboveMinValue = "11:00:00.123"

    // Check valid values
    const minCell = mockColumn.getCell(minValue, true)
    expect(mockColumn.getCellValue(minCell)).toEqual("10:59:59.000")
    expect(mockColumn.validateInput!(minValue)).toBeTruthy()

    const aboveMinValueCell = mockColumn.getCell(aboveMinValue, true)
    expect(mockColumn.getCellValue(aboveMinValueCell)).toEqual("11:00:00.123")
    expect(mockColumn.validateInput!(aboveMinValue)).toBeTruthy()

    // Check invalid values
    const belowMinCell = mockColumn.getCell(belowMinValue, true)
    expect(mockColumn.validateInput!(belowMinValue)).toBeFalsy()
    expect(isErrorCell(belowMinCell)).toEqual(true)
  })

  it("respects max_value config option", () => {
    const MOCK_TIME_COLUMN_TEMPLATE_WITH_MAX: BaseColumnProps = {
      ...MOCK_TIME_COLUMN_TEMPLATE,
      columnTypeOptions: {
        max_value: "10:59:59",
      },
    }

    const mockColumn = TimeColumn(MOCK_TIME_COLUMN_TEMPLATE_WITH_MAX)
    const maxValue = "10:59:59.000"
    const belowMaxValue = "10:59:58.345"
    const aboveMaxValue = "11:00:00.123"

    // Check valid values
    const maxCell = mockColumn.getCell(maxValue, true)
    expect(mockColumn.getCellValue(maxCell)).toEqual("10:59:59.000")
    expect(mockColumn.validateInput!(maxValue)).toBeTruthy()

    const belowMaxValueCell = mockColumn.getCell(belowMaxValue, true)
    expect(mockColumn.validateInput!(belowMaxValue)).toBeTruthy()
    expect(mockColumn.getCellValue(belowMaxValueCell)).toEqual("10:59:58.345")

    // Check invalid values
    const aboveMaxCell = mockColumn.getCell(aboveMaxValue, true)
    expect(mockColumn.validateInput!(aboveMaxValue)).toBeFalsy()
    expect(isErrorCell(aboveMaxCell)).toEqual(true)
  })

  it("changes the step size based on the config option", () => {
    const MOCK_TIME_COLUMN_WITH_STEP: BaseColumnProps = {
      ...MOCK_TIME_COLUMN_TEMPLATE,
      columnTypeOptions: {
        step: 60,
      },
    }

    const mockColumn = TimeColumn(MOCK_TIME_COLUMN_WITH_STEP)
    const newCell = mockColumn.getCell(EXAMPLE_DATE)
    expect((newCell as DatePickerType).data.step).toBe("60")
  })

  it("formats according to the provided format config option", () => {
    const MOCK_TIME_COLUMN_CUSTOM_FORMAT = {
      ...MOCK_TIME_COLUMN_TEMPLATE,
      columnTypeOptions: {
        format: "HH:mm",
      },
    }

    const mockColumn = DateColumn(MOCK_TIME_COLUMN_CUSTOM_FORMAT)
    const cell = mockColumn.getCell(EXAMPLE_DATE)
    expect((cell as DatePickerType).data.displayDate).toEqual("10:30")
  })

  it("adapts default format based on step size", () => {
    const MOCK_TIME_COLUMN_WITH_STEP: BaseColumnProps = {
      ...MOCK_TIME_COLUMN_TEMPLATE,
      columnTypeOptions: {
        step: 60,
      },
    }

    const mockColumn = TimeColumn(MOCK_TIME_COLUMN_WITH_STEP)
    const newCell = mockColumn.getCell(EXAMPLE_DATE)
    expect((newCell as DatePickerType).data.displayDate).toBe("10:30")
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/DateTimeColumn.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCell, GridCellKind } from "@glideapps/glide-data-grid"
import { DatePickerType } from "@glideapps/glide-data-grid-cells"
import moment, { Moment } from "moment-timezone"

import { getTimezone } from "@streamlit/lib/src/dataframes/arrowTypeUtils"
import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

import {
  BaseColumn,
  BaseColumnProps,
  formatMoment,
  getErrorCell,
  mergeColumnParameters,
  toSafeDate,
  toSafeString,
} from "./utils"

/**
 * Apply a timezone to a MomentJS date.
 *
 * @param momentDate The date to apply the timezone to
 * @param timezone The timezone to apply. This can be a timezone name
 * (e.g. "America/New_York" or "UTC") or a UTC offset (e.g. "+05:00" or "-08:00")
 * @returns The date with the timezone applied
 */
function applyTimezone(momentDate: Moment, timezone: string): Moment {
  if (timezone.startsWith("+") || timezone.startsWith("-")) {
    // Timezone is a UTC offset (e.g. "+05:00" or "-08:00")
    momentDate = momentDate.utcOffset(timezone, false)
  } else {
    // Timezone is a timezone name (e.g. "America/New_York" or "UTC")
    momentDate = momentDate.tz(timezone)
  }
  return momentDate
}

export interface DateTimeColumnParams {
  // A momentJS formatting syntax to format the display value.
  readonly format?: string
  // Specifies the granularity that the value must adhere.
  // For time and datetime, this is the number of seconds between each allowed value.
  // For date, this is the number of days between each allowed value.
  readonly step?: number
  // A timezone identifier, e.g. "America/New_York", "+05:00", or "UTC"
  readonly timezone?: string
  // The minimum allowed value for editing. This needs to be an ISO formatted datetime/date/time string (UTC).
  readonly min_value?: string
  // The maximum allowed value for editing. This needs to be an ISO formatted datetime/date/time string (UTC).
  readonly max_value?: string
}

/**
 * Base class for datetime columns. This class is not meant to be used directly.
 * Instead, use the DateColumn, TimeColumn, or DateTimeColumn classes.
 *
 * @param kind The kind of column. This should be one of "date", "time", or "datetime".
 * @param props The column properties
 * @param defaultFormat The default format to use for rendering and copy data
 * @param defaultStep The default step to use, can be overridden by the user
 * @param inputType The type of input to use for editing. This should be one of "datetime-local", "time", or "date".
 * @param toISOString A function that converts a Date object to an ISO formatted string
 * @param timezone The timezone to use to make the datetime values timezone aware.
 *
 * @returns A BaseColumn object
 */
function BaseDateTimeColumn(
  kind: string,
  props: BaseColumnProps,
  defaultFormat: string, // used for rendering and copy data
  defaultStep: number,
  inputType: "datetime-local" | "time" | "date",
  toISOString: (date: Date) => string,
  timezone?: string
): BaseColumn {
  const parameters = mergeColumnParameters(
    // Default parameters:
    {
      format: defaultFormat,
      step: defaultStep,
      timezone,
    },
    // User parameters:
    props.columnTypeOptions
  ) as DateTimeColumnParams

  let defaultTimezoneOffset: number | undefined = undefined
  if (notNullOrUndefined(parameters.timezone)) {
    // We try to determine the timezone offset based on today's date
    // This is needed for the date picker to work correctly when the value is null
    // TODO(lukasmasuch): But this might not be correct for dates in the past or future
    // since the timezone offset might have changed based on a timezone name.
    try {
      defaultTimezoneOffset =
        applyTimezone(moment(), parameters.timezone)?.utcOffset() || undefined
    } catch (error) {
      // Do nothing
    }
  }

  let minDate: Date | undefined = undefined
  if (notNullOrUndefined(parameters.min_value)) {
    minDate = toSafeDate(parameters.min_value) || undefined
  }

  let maxDate: Date | undefined = undefined
  if (notNullOrUndefined(parameters.max_value)) {
    maxDate = toSafeDate(parameters.max_value) || undefined
  }

  const cellTemplate = {
    kind: GridCellKind.Custom,
    allowOverlay: true,
    copyData: "",
    readonly: !props.isEditable,
    contentAlign: props.contentAlignment,
    // The text in pinned columns should be faded.
    style: props.isPinned ? "faded" : "normal",
    data: {
      kind: "date-picker-cell",
      date: undefined,
      displayDate: "",
      step: parameters.step?.toString() || "1",
      format: inputType,
      min: minDate,
      max: maxDate,
    },
  } as DatePickerType

  const validateInput = (data?: any): boolean | Date => {
    const cellData: Date | null | undefined = toSafeDate(data)
    if (cellData === null) {
      if (props.isRequired) {
        return false
      }
      return true
    }

    if (cellData === undefined) {
      // Input cannot be interpreted as a date
      return false
    }

    // Apply min_value configuration option:
    if (
      notNullOrUndefined(minDate) &&
      // We compare on a string level so that it also works correctly for time and date values
      toISOString(cellData) < toISOString(minDate)
    ) {
      return false
    }

    // Apply min_value configuration option:
    if (
      notNullOrUndefined(maxDate) &&
      toISOString(cellData) > toISOString(maxDate)
    ) {
      return false
    }

    // TODO: validate step size

    return true
  }

  return {
    ...props,
    kind,
    sortMode: "default",
    validateInput,
    getCell(data?: any, validate?: boolean): GridCell {
      if (validate === true) {
        const validationResult = validateInput(data)
        if (validationResult === false) {
          // The input is invalid, we return an error cell which will
          // prevent this cell to be inserted into the table.
          return getErrorCell(toSafeString(data), "Invalid input.")
        } else if (validationResult instanceof Date) {
          // Apply corrections:
          data = validationResult
        }
      }

      const cellData = toSafeDate(data)

      let copyData = ""
      let displayDate = ""
      // Initialize with default offset base on today's date
      let timezoneOffset = defaultTimezoneOffset

      if (cellData === undefined) {
        return getErrorCell(
          toSafeString(data),
          "The value cannot be interpreted as a datetime object."
        )
      }

      if (cellData !== null) {
        // Convert to moment object
        let momentDate = moment.utc(cellData)

        if (!momentDate.isValid()) {
          // The moment date should never be invalid here.
          return getErrorCell(
            toSafeString(cellData),
            `Invalid moment date. This should never happen. Please report this bug. \nError: ${momentDate.toString()}`
          )
        }

        if (parameters.timezone) {
          try {
            momentDate = applyTimezone(momentDate, parameters.timezone)
          } catch (error) {
            return getErrorCell(
              momentDate.toISOString(),
              `Failed to adjust to the provided timezone: ${parameters.timezone}. \nError: ${error}`
            )
          }

          timezoneOffset = momentDate.utcOffset()
        }

        try {
          displayDate = formatMoment(
            momentDate,
            parameters.format || defaultFormat
          )
        } catch (error) {
          return getErrorCell(
            momentDate.toISOString(),
            `Failed to format the date for rendering with: ${parameters.format}. \nError: ${error}`
          )
        }
        // Copy data should always use the default format
        copyData = formatMoment(momentDate, defaultFormat)
      }

      return {
        ...cellTemplate,
        copyData,
        isMissingValue: isNullOrUndefined(cellData),
        data: {
          ...cellTemplate.data,
          date: cellData,
          displayDate,
          timezoneOffset,
        },
      } as DatePickerType
    },
    getCellValue(cell: DatePickerType): string | null {
      return isNullOrUndefined(cell?.data?.date)
        ? null
        : toISOString(cell.data.date)
    },
  }
}

/**
 * Creates a new datetime column.
 * A datetime column supports optimized rendering and editing for datetime values.
 *
 * @param props The column properties.
 * @returns The new column.
 */
export default function DateTimeColumn(props: BaseColumnProps): BaseColumn {
  // Do a smart selection of the default format based on the step size
  let defaultFormat = "YYYY-MM-DD HH:mm:ss"
  if (props.columnTypeOptions?.step >= 60) {
    defaultFormat = "YYYY-MM-DD HH:mm"
  } else if (props.columnTypeOptions?.step < 1) {
    defaultFormat = "YYYY-MM-DD HH:mm:ss.SSS"
  }

  const timezone = getTimezone(props.arrowType)
  const hasTimezone: boolean =
    notNullOrUndefined(timezone) ||
    // Timezone can also be configure by the user:
    notNullOrUndefined(props?.columnTypeOptions?.timezone)

  return BaseDateTimeColumn(
    "datetime",
    props,
    hasTimezone ? defaultFormat + "Z" : defaultFormat,
    1,
    "datetime-local",
    (date: Date): string => {
      if (hasTimezone) {
        return date.toISOString()
      }
      return date.toISOString().replace("Z", "")
    },
    timezone
  )
}

DateTimeColumn.isEditableType = true

/**
 * Creates a new time column.
 * A time column supports optimized rendering and editing for time values.
 *
 * @param props The column properties.
 * @returns The new column.
 */
export function TimeColumn(props: BaseColumnProps): BaseColumn {
  // Do a smart selection of the default format based on the step size
  let defaultFormat = "HH:mm:ss"
  if (props.columnTypeOptions?.step >= 60) {
    defaultFormat = "HH:mm"
  } else if (props.columnTypeOptions?.step < 1) {
    defaultFormat = "HH:mm:ss.SSS"
  }

  return BaseDateTimeColumn(
    "time",
    props,
    defaultFormat,
    1,
    "time",
    (date: Date): string => {
      // Only return the time part of the ISO string:
      return date.toISOString().split("T")[1].replace("Z", "")
    }
  )
}

TimeColumn.isEditableType = true

/**
 * Creates a new date column.
 * A date column supports optimized rendering and editing for date values.
 *
 * @param props The column properties.
 * @returns The new column.
 */
export function DateColumn(props: BaseColumnProps): BaseColumn {
  return BaseDateTimeColumn(
    "date",
    props,
    "YYYY-MM-DD",
    1,
    "date",
    (date: Date): string => {
      // Only return the date part of the ISO string:
      return date.toISOString().split("T")[0]
    }
  )
}

DateColumn.isEditableType = true


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/ImageColumn.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCellKind, ImageCell } from "@glideapps/glide-data-grid"

import ImageColumn from "./ImageColumn"

const MOCK_IMAGE_COLUMN_PROPS = {
  id: "1",
  name: "image_column",
  title: "Image column",
  indexNumber: 0,
  isEditable: false,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
  arrowType: {
    // The arrow type of the underlying data is
    // not used for anything inside the column.
    pandas_type: "unicode",
    numpy_type: "object",
  },
}

describe("ImageColumn", () => {
  it("creates a valid column instance", () => {
    const mockColumn = ImageColumn(MOCK_IMAGE_COLUMN_PROPS)
    expect(mockColumn.kind).toEqual("image")
    expect(mockColumn.title).toEqual(MOCK_IMAGE_COLUMN_PROPS.title)
    expect(mockColumn.id).toEqual(MOCK_IMAGE_COLUMN_PROPS.id)
    expect(mockColumn.sortMode).toEqual("default")

    const mockCell = mockColumn.getCell(
      "https://streamlit.io/images/brand/streamlit-logo-primary-colormark-darktext.png"
    )
    expect(mockCell.kind).toEqual(GridCellKind.Image)
    expect(mockCell.contentAlign).toEqual("center")
    expect((mockCell as ImageCell).data).toEqual([
      "https://streamlit.io/images/brand/streamlit-logo-primary-colormark-darktext.png",
    ])
  })

  it("ignores isEditable configuration", () => {
    const mockColumn = ImageColumn({
      ...MOCK_IMAGE_COLUMN_PROPS,
      isEditable: true,
    })

    // Column should be readonly, even if isEditable was true
    expect(mockColumn.isEditable).toEqual(false)
  })

  it.each([
    // Image column supports the
    // same conversions as the text column:
    [
      "https://streamlit.io/images/brand/streamlit-logo-primary-colormark-darktext.png",
      "https://streamlit.io/images/brand/streamlit-logo-primary-colormark-darktext.png",
    ],
    ["/foo", "/foo"],
    ["", ""],
    [[], ""],
    [
      "data:image/png;base64,iVBORw0KGgoAAAAAAAAyCAYAAAAUYybjAAAgAElE...",
      "data:image/png;base64,iVBORw0KGgoAAAAAAAAyCAYAAAAUYybjAAAgAElE...",
    ],
    [null, null],
    [undefined, null],
  ])(
    "supports string-compatible value (%p parsed as %p)",
    (input: any, value: string | null) => {
      const mockColumn = ImageColumn(MOCK_IMAGE_COLUMN_PROPS)
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
    }
  )
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/ImageColumn.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCell, GridCellKind, ImageCell } from "@glideapps/glide-data-grid"

import { notNullOrUndefined } from "@streamlit/lib/src/util/utils"

import { BaseColumn, BaseColumnProps, toSafeString } from "./utils"

/**
 * A column type that renders an image as a cell value. On cell selection, open
 * the cell overlay with a full version of the image.
 *
 * This column type is currently read-only.
 */
function ImageColumn(props: BaseColumnProps): BaseColumn {
  const cellTemplate = {
    kind: GridCellKind.Image,
    data: [],
    displayData: [],
    readonly: true,
    allowOverlay: true,
    contentAlign: props.contentAlignment || "center",
    style: "normal",
  } as ImageCell

  return {
    ...props,
    kind: "image",
    sortMode: "default",
    isEditable: false, // Image columns are always read-only
    getCell(data?: any): GridCell {
      // The native image cell implementation in glide-data-grid expects an array
      // of image URLs. For our usecase, we only support single images. We
      // need to wrap the image URL in an array to have it compatible with the
      // implementation in glide-data-grid.
      const imageUrls = notNullOrUndefined(data) ? [toSafeString(data)] : []

      return {
        ...cellTemplate,
        data: imageUrls,
        isMissingValue: !notNullOrUndefined(data),
        displayData: imageUrls,
      } as ImageCell
    },
    getCellValue(cell: ImageCell): string | null {
      if (cell.data === undefined || cell.data.length === 0) {
        return null
      }

      // We use the image cell only for single images,
      // so we can safely return just the first element
      return cell.data[0]
    },
  }
}

ImageColumn.isEditableType = false

export default ImageColumn


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/LinkColumn.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable  @typescript-eslint/no-non-null-assertion */

import { GridCellKind, UriCell } from "@glideapps/glide-data-grid"

import LinkColumn from "./LinkColumn"
import { ErrorCell, isErrorCell } from "./utils"

const MOCK_LINK_COLUMN_PROPS = {
  id: "1",
  name: "link_column",
  title: "Link column",
  indexNumber: 0,
  isEditable: false,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
  arrowType: {
    // The arrow type of the underlying data is
    // not used for anything inside the column.
    pandas_type: "unicode",
    numpy_type: "object",
  },
}

describe("LinkColumn", () => {
  it("creates a valid column instance", () => {
    const mockColumn = LinkColumn(MOCK_LINK_COLUMN_PROPS)
    expect(mockColumn.kind).toEqual("link")
    expect(mockColumn.title).toEqual(MOCK_LINK_COLUMN_PROPS.title)
    expect(mockColumn.id).toEqual(MOCK_LINK_COLUMN_PROPS.id)
    expect(mockColumn.sortMode).toEqual("default")

    const mockCell = mockColumn.getCell("https://streamlit.io") as UriCell
    expect(mockCell.kind).toEqual(GridCellKind.Uri)
    expect(mockCell.data).toEqual("https://streamlit.io")
    expect(mockCell.displayData).toEqual("https://streamlit.io")
  })

  it.each([
    ["foo", "foo"],
    ["https://streamlit.io", "https://streamlit.io"],
    ["/path/to/file", "/path/to/file"],
    [null, null],
    [undefined, null],
    // All the values that are supported by the TextColumn
    // should also be supported by the UrlColumn.
  ])(
    "supports string-compatible value (%p parsed as %p)",
    (input: any, value: any | null) => {
      const mockColumn = LinkColumn(MOCK_LINK_COLUMN_PROPS)
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
    }
  )

  it("validates input based on max_chars", () => {
    const mockColumn = LinkColumn({
      ...MOCK_LINK_COLUMN_PROPS,
      columnTypeOptions: { max_chars: 5 },
    })

    expect(mockColumn.validateInput!("12345")).toBe(true)
    expect(mockColumn.validateInput!("123456")).toBe(false)
    expect(mockColumn.validateInput!("1234567890")).toBe(false)
  })

  it("validates input based on validate regex", () => {
    const mockColumn = LinkColumn({
      ...MOCK_LINK_COLUMN_PROPS,
      columnTypeOptions: {
        validate:
          "^https://(?:www.)?(?:[a-zA-Z0-9-]+.)*streamlit.app(?:/.*)?$",
      },
    })

    expect(mockColumn.validateInput!("https://issues.streamlit.app/")).toBe(
      true
    )
    expect(
      mockColumn.validateInput!(
        "https://issues.streamlit.app/Streamlit_Issues_Leaderboard?issue=10"
      )
    ).toBe(true)
    expect(mockColumn.validateInput!("issues.streamlit.app/")).toBe(false)
    expect(mockColumn.validateInput!("https://issues.streamlit.io/")).toBe(
      false
    )
  })

  it("applies input validation in the getCell call based on max_chars and validate regex", () => {
    const mockColumn = LinkColumn({
      ...MOCK_LINK_COLUMN_PROPS,
      columnTypeOptions: {
        max_chars: 40,
        validate:
          "^https://(?:www.)?(?:[a-zA-Z0-9-]+.)*streamlit.app(?:/.*)?$",
      },
    })

    expect(
      isErrorCell(mockColumn.getCell("https://issues.streamlit.app/", true))
    ).toBe(false)
    expect(
      isErrorCell(mockColumn.getCell("https://issues.streamlit.io/", true))
    ).toBe(true)

    // We do not auto fix a link cell that's too long
    expect(
      isErrorCell(
        mockColumn.getCell(
          "https://issues.streamlit.app/Streamlit_Issues_Leaderboard?issue=10",
          true
        )
      )
    ).toBe(true)
  })

  it("handles invalid validate regex", () => {
    const mockColumn = LinkColumn({
      ...MOCK_LINK_COLUMN_PROPS,
      columnTypeOptions: { validate: "[" }, // Invalid regex
    })

    const cell = mockColumn.getCell("test", true)
    expect(isErrorCell(cell)).toEqual(true)
    expect((cell as ErrorCell).data).toContain("test")
    expect((cell as ErrorCell).errorDetails).toContain(
      "Invalid validate regex"
    )
  })

  it("ignores empty validate", () => {
    const mockColumn = LinkColumn({
      ...MOCK_LINK_COLUMN_PROPS,
      columnTypeOptions: { validate: "" },
    })

    const cell = mockColumn.getCell("test", true)
    expect(isErrorCell(cell)).toEqual(false)
  })

  it("sets the href and displayText values correctly", () => {
    const mockColumn = LinkColumn({
      ...MOCK_LINK_COLUMN_PROPS,
      columnTypeOptions: { display_text: "Click me" },
    })

    const cell = mockColumn.getCell("https://streamlit.io", true) as UriCell

    const cellValue = mockColumn.getCellValue(cell)
    expect(cellValue).toBe("https://streamlit.io")
    expect(cell.displayData).toBe("Click me")
  })

  it("sets displayed value to be the href when displayText is empty", () => {
    const mockColumn = LinkColumn({
      ...MOCK_LINK_COLUMN_PROPS,
      columnTypeOptions: { display_text: undefined },
    })

    const cell = mockColumn.getCell("https://streamlit.io", true) as UriCell

    expect(cell.displayData).toBe("https://streamlit.io")
  })

  it("sets displayed value to be displayText when displayText is defined and not a regexp", () => {
    const mockColumn = LinkColumn({
      ...MOCK_LINK_COLUMN_PROPS,
      columnTypeOptions: { display_text: "streamlit" },
    })

    const cell = mockColumn.getCell("https://streamlit.io", true) as UriCell

    expect(cell.displayData).toBe("streamlit")
  })

  it("sets displayed value as the applied regex to the href when displayText is a regex", () => {
    const mockColumn = LinkColumn({
      ...MOCK_LINK_COLUMN_PROPS,
      columnTypeOptions: { display_text: "https://(.*?).streamlit.app" },
    })

    const cell = mockColumn.getCell(
      "https://roadmap.streamlit.app",
      true
    ) as UriCell

    expect(cell.displayData).toBe("roadmap")
  })

  it("sets displayed value as the applied regex to the href when displayText is a regex with URL encoding", () => {
    const mockColumn = LinkColumn({
      ...MOCK_LINK_COLUMN_PROPS,
      columnTypeOptions: {
        display_text: "https://streamlit\\.app\\?app=(.*)",
      },
    })

    const cell = mockColumn.getCell(
      "https://streamlit.app?app=foo%20app%20%25",
      true
    ) as UriCell

    expect(cell.displayData).toBe("foo app %")
  })

  it("sets displayed value as the href, when displayText is a regex but there is no match", () => {
    const mockColumn = LinkColumn({
      ...MOCK_LINK_COLUMN_PROPS,
      // eslint-disable-next-line prettier/prettier
      columnTypeOptions: { display_text: "https://(.*?)\\.google.com" },
    })

    const cell = mockColumn.getCell(
      "https://roadmap.streamlit.app",
      true
    ) as UriCell

    expect(cell.displayData).toBe("https://roadmap.streamlit.app")
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/LinkColumn.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCell, GridCellKind, UriCell } from "@glideapps/glide-data-grid"

import { isNullOrUndefined } from "@streamlit/lib/src/util/utils"

import {
  BaseColumn,
  BaseColumnProps,
  getErrorCell,
  getLinkDisplayValueFromRegex,
  toSafeString,
} from "./utils"

export interface LinkColumnParams {
  // The maximum number of characters the user can enter into the text input.
  readonly max_chars?: number
  // Regular expression that the input's value must match for the value to pass
  readonly validate?: string
  // a value to display in the link cell. Can be a regex to parse out a specific substring of the url to be displayed
  readonly display_text?: string
}

/**
 * The link column is a special column that interprets the cell content as
 * an hyperlink / url and allows the user to click on it.
 */
function LinkColumn(props: BaseColumnProps): BaseColumn {
  const parameters = (props.columnTypeOptions as LinkColumnParams) || {}

  let validateRegex: RegExp | string | undefined = undefined

  if (parameters.validate) {
    // Prepare the validation regex:
    try {
      // u flag allows unicode characters
      // s flag allows . to match newlines
      validateRegex = new RegExp(parameters.validate, "us")
    } catch (error) {
      // Put error message in validateRegex so we can display it in the cell
      validateRegex = `Invalid validate regex: ${parameters.validate}.\nError: ${error}`
    }
  }

  // Determine if the user's provided display text is a regexp pattern or not.
  let displayTextRegex: RegExp | undefined = undefined
  if (
    !isNullOrUndefined(parameters.display_text) &&
    parameters.display_text.includes("(") &&
    parameters.display_text.includes(")")
  ) {
    try {
      displayTextRegex = new RegExp(parameters.display_text, "us")
    } catch (error) {
      // The regex is invalid, interpret it as static display text.
      displayTextRegex = undefined
    }
  }

  const cellTemplate = {
    kind: GridCellKind.Uri,
    readonly: !props.isEditable,
    allowOverlay: true,
    contentAlign: props.contentAlignment,
    style: "normal",
    hoverEffect: true,
    data: "",
    displayData: "",
    copyData: "",
  } as UriCell

  const validateInput = (href?: string): boolean => {
    if (isNullOrUndefined(href)) {
      if (props.isRequired) {
        return false
      }
      return true
    }

    const cellHref = toSafeString(href)

    if (parameters.max_chars && cellHref.length > parameters.max_chars) {
      // value is too long
      return false
    }

    if (
      validateRegex instanceof RegExp &&
      validateRegex.test(cellHref) === false
    ) {
      return false
    }

    return true
  }

  return {
    ...props,
    kind: "link",
    sortMode: "default",
    validateInput,
    getCell(data?: any, validate?: boolean): GridCell {
      if (isNullOrUndefined(data)) {
        return {
          ...cellTemplate,
          data: null as any,
          isMissingValue: true,
          onClickUri: () => {},
        } as UriCell
      }

      const href: string = data
      if (typeof validateRegex === "string") {
        // The regex is invalid, we return an error to indicate this
        // to the developer:
        return getErrorCell(toSafeString(href), validateRegex)
      }

      if (validate) {
        const validationResult = validateInput(href)
        if (validationResult === false) {
          // The input is invalid, we return an error cell which will
          // prevent this cell to be inserted into the table.
          // This cell should never be actually displayed to the user.
          // It's mostly used internally to prevent invalid input to be
          // inserted into the table.
          return getErrorCell(toSafeString(href), "Invalid input.")
        }
      }

      let displayText = ""
      if (href) {
        if (displayTextRegex !== undefined) {
          // Set display value to be the regex extracted portion of the href.
          displayText = getLinkDisplayValueFromRegex(displayTextRegex, href)
        } else {
          // Use user provided display_text unless it's null, undefined, or an empty string.
          // If it's any of those falsy values, use the href.
          displayText = parameters.display_text || href
        }
      }

      return {
        ...cellTemplate,
        data: href,
        displayData: displayText,
        isMissingValue: isNullOrUndefined(href),
        onClickUri: a => {
          window.open(
            href.startsWith("www.") ? `https://${href}` : href,
            "_blank",
            "noopener,noreferrer"
          )
          a.preventDefault()
        },
        copyData: href,
      } as UriCell
    },
    getCellValue(cell: UriCell): string | null {
      return isNullOrUndefined(cell.data) ? null : cell.data
    },
  }
}

LinkColumn.isEditableType = true

export default LinkColumn


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/ListColumn.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { BubbleCell, GridCellKind } from "@glideapps/glide-data-grid"

import ListColumn from "./ListColumn"

const MOCK_LIST_COLUMN_PROPS = {
  id: "1",
  name: "list_column",
  title: "List column",
  indexNumber: 0,
  isEditable: false,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
  arrowType: {
    // The arrow type of the underlying data is
    // not used for anything inside the column.
    pandas_type: "object",
    numpy_type: "list[unicode]",
  },
}

describe("ListColumn", () => {
  it("creates a valid column instance", () => {
    const mockColumn = ListColumn(MOCK_LIST_COLUMN_PROPS)
    expect(mockColumn.kind).toEqual("list")
    expect(mockColumn.title).toEqual(MOCK_LIST_COLUMN_PROPS.title)
    expect(mockColumn.id).toEqual(MOCK_LIST_COLUMN_PROPS.id)
    expect(mockColumn.sortMode).toEqual("default")

    const mockCell = mockColumn.getCell(["foo", "bar"])
    expect(mockCell.kind).toEqual(GridCellKind.Bubble)
    expect((mockCell as BubbleCell).data).toEqual(["foo", "bar"])
  })

  it("ignores isEditable configuration", () => {
    const mockColumn = ListColumn({
      ...MOCK_LIST_COLUMN_PROPS,
      isEditable: true,
    })

    // Column should be readonly, even if isEditable was true
    expect(mockColumn.isEditable).toEqual(false)
  })

  it.each([
    // Supports almost the same as toSafeArray
    [null, null],
    [undefined, null],
    ["", []],
    [[], []],
    ["[]", []],
    ["foo", ["foo"]],
    // Comma separated syntax
    ["foo,bar", ["foo", "bar"]],
    ["foo,bar,", ["foo", "bar", ""]],
    ["foo,bar,,", ["foo", "bar", "", ""]],
    // JSON Array syntax
    [`["foo","bar"]`, ["foo", "bar"]],
    // non-string values
    [0, [0]],
    [1, [1]],
    [
      [0, 1.2],
      [0, 1.2],
    ],
    [true, [true]],
    [false, [false]],
    [
      [true, false],
      [true, false],
    ],
  ])(
    "supports array-compatible value (%p parsed as %p)",
    (input: any, value: any[] | null) => {
      const mockColumn = ListColumn(MOCK_LIST_COLUMN_PROPS)
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
    }
  )

  it.each([
    [null, ""],
    [undefined, ""],
    [[], ""],
    [["foo", "bar"], "foo,bar"],
    [["foo", "bar", ""], "foo,bar,"],
    [["foo", "comma,in value"], "foo,comma in value"],
    [[0, 1.2], "0,1.2"],
    [[true, false], "true,false"],
  ])(
    "correctly prepares data for copy (%p parsed as %p)",
    (input: any, copyData: string | undefined) => {
      const mockColumn = ListColumn(MOCK_LIST_COLUMN_PROPS)
      const cell = mockColumn.getCell(input)
      expect((cell as any).copyData).toEqual(copyData)
    }
  )
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/ListColumn.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { BubbleCell, GridCell, GridCellKind } from "@glideapps/glide-data-grid"

import { isNullOrUndefined } from "@streamlit/lib/src/util/utils"

import {
  BaseColumn,
  BaseColumnProps,
  isMissingValueCell,
  toSafeArray,
  toSafeString,
} from "./utils"

/**
 * A column type that supports optimized rendering values of array/list types.
 */
function ListColumn(props: BaseColumnProps): BaseColumn {
  const cellTemplate = {
    kind: GridCellKind.Bubble,
    data: [],
    allowOverlay: true,
    contentAlign: props.contentAlignment,
    style: "normal",
  } as BubbleCell

  return {
    ...props,
    kind: "list",
    sortMode: "default",
    isEditable: false, // List column is always readonly
    getCell(data?: any): GridCell {
      const cellData = isNullOrUndefined(data) ? [] : toSafeArray(data)

      return {
        ...cellTemplate,
        data: cellData,
        isMissingValue: isNullOrUndefined(data),
        copyData: isNullOrUndefined(data)
          ? ""
          : toSafeString(
              cellData.map((x: any) =>
                // Replace commas with spaces since commas are used to
                // separate the list items.
                typeof x === "string" && x.includes(",")
                  ? x.replace(/,/g, " ")
                  : x
              )
            ),
      } as BubbleCell
    },
    getCellValue(cell: BubbleCell): string[] | null {
      if (isNullOrUndefined(cell.data) || isMissingValueCell(cell)) {
        return null
      }

      return cell.data
    },
  }
}

ListColumn.isEditableType = false

export default ListColumn


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/NumberColumn.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable  @typescript-eslint/no-non-null-assertion */

import { GridCellKind, NumberCell } from "@glideapps/glide-data-grid"

import {
  PandasColumnType as ArrowType,
  DataType,
} from "@streamlit/lib/src/dataframes/arrowTypeUtils"

import NumberColumn, { NumberColumnParams } from "./NumberColumn"
import { BaseColumnProps, ErrorCell, isErrorCell } from "./utils"

const MOCK_FLOAT_ARROW_TYPE: ArrowType = {
  pandas_type: "float64",
  numpy_type: "float64",
}

const MOCK_INT_ARROW_TYPE: ArrowType = {
  pandas_type: "int64",
  numpy_type: "int64",
}

const MOCK_UINT_ARROW_TYPE: ArrowType = {
  pandas_type: "uint64",
  numpy_type: "uint64",
}

const NUMBER_COLUMN_TEMPLATE: Partial<BaseColumnProps> = {
  id: "1",
  name: "number_column",
  title: "Number column",
  indexNumber: 0,
  isEditable: false,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
}

function getNumberColumn(
  arrowType: ArrowType,
  params?: NumberColumnParams
): ReturnType<typeof NumberColumn> {
  return NumberColumn({
    ...NUMBER_COLUMN_TEMPLATE,
    arrowType,
    columnTypeOptions: params,
  } as BaseColumnProps)
}

describe("NumberColumn", () => {
  it("creates a valid column instance", () => {
    const mockColumn = getNumberColumn(MOCK_FLOAT_ARROW_TYPE)
    expect(mockColumn.kind).toEqual("number")
    expect(mockColumn.title).toEqual(NUMBER_COLUMN_TEMPLATE.title)
    expect(mockColumn.id).toEqual(NUMBER_COLUMN_TEMPLATE.id)
    expect(mockColumn.isEditable).toEqual(NUMBER_COLUMN_TEMPLATE.isEditable)
    expect(mockColumn.sortMode).toEqual("smart")

    const mockCell = mockColumn.getCell("1.234")
    expect(mockCell.kind).toEqual(GridCellKind.Number)
    expect((mockCell as NumberCell).displayData).toEqual("1.234")
    expect((mockCell as NumberCell).data).toEqual(1.234)
  })

  it("alignes numbers to the right", () => {
    const mockColumn = getNumberColumn(MOCK_FLOAT_ARROW_TYPE)
    const mockCell = mockColumn.getCell("1.123")
    expect(mockCell.contentAlign).toEqual("right")
  })

  it.each([
    [true, 1],
    [false, 0],
    ["4.12", 4.12],
    ["-4.12", -4.12],
    ["4", 4],
    [1.3122, 1.3122],
    [-1.3122, -1.3122],
    ["1,212.12", 1212.12],
    [".1312314", 0.1312314],
    [null, null],
    [undefined, null],
    ["", null],
  ])(
    "supports float64 value (%p parsed as %p)",
    (input: DataType | null | undefined, value: number | null) => {
      const mockColumn = getNumberColumn(MOCK_FLOAT_ARROW_TYPE)
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
    }
  )

  it.each([
    [100, 100],
    [-100, -100],
    ["4", 4],
    ["4.12", 4],
    ["4.61", 4],
    ["-4.12", -4],
    [1.3122, 1],
    [-1.3122, -1],
    ["1,212", 1212],
    ["1,212,123,312", 1212123312],
    [null, null],
  ])(
    "supports integer value (%p parsed as %p)",
    (input: DataType | null, value: number | null) => {
      const mockColumn = getNumberColumn(MOCK_INT_ARROW_TYPE)
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
    }
  )

  it("properly configures the column for unsigned integers", () => {
    const mockColumn = getNumberColumn(MOCK_UINT_ARROW_TYPE)
    expect(mockColumn.kind).toEqual("number")

    const mockCell = mockColumn.getCell("104")
    expect(mockCell.kind).toEqual(GridCellKind.Number)
    expect((mockCell as any).fixedDecimals).toEqual(0)
    expect((mockCell as any).allowNegative).toEqual(false)
  })

  it.each([
    [100, true],
    [-100, false],
    ["4", true],
    ["-4.12", false],
  ])(
    "supports unsigned integer validation (%p validates to %p)",
    (input: DataType | null, valid: boolean) => {
      const mockColumn = getNumberColumn(MOCK_UINT_ARROW_TYPE)
      expect(mockColumn.validateInput!(input)).toEqual(valid)
    }
  )

  it.each([
    [0, 1.234567, 1],
    [0.1, 1.234567, 1.2],
    [0.01, 1.234567, 1.23],
    [0.001, 1.234567, 1.234],
    [0.0001, 1.234567, 1.2345],
    [0.001, 1.1, 1.1],
    [0.00000001, 1, 1],
  ])(
    "converts value to precision from step %p (%p converted to %p)",
    (step: number, input: DataType, value: number | null) => {
      const mockColumn = getNumberColumn(MOCK_FLOAT_ARROW_TYPE, {
        step,
      })
      const mockCell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(mockCell)).toEqual(value)
    }
  )

  it.each([
    [0, 1.234567, "1"],
    [0.1, 1.234567, "1.2"],
    [0.01, 1.234567, "1.23"],
    [0.001, 1.234567, "1.234"],
    [0.0001, 1.234567, "1.2345"],
    [0.001, 1.1, "1.100"],
    [0.00000001, 1, "1.00000000"],
  ])(
    "correctly adapts default value to precision from step %p (%p displayed as %p)",
    (step: number, input: DataType, displayValue: string) => {
      const mockColumn = getNumberColumn(MOCK_FLOAT_ARROW_TYPE, {
        step,
      })
      const mockCell = mockColumn.getCell(input)
      expect((mockCell as NumberCell).displayData).toEqual(displayValue)
    }
  )

  it.each([
    [10, 10, true],
    [10, 100, true],
    [10, 5, false],
    [10, -5, false],
  ])(
    "supports minimal value configuration %p (%p validates to %p)",
    (min_value: number, input: DataType, valid: boolean) => {
      const mockColumn = getNumberColumn(MOCK_FLOAT_ARROW_TYPE, {
        min_value,
      })
      expect(mockColumn.validateInput!(input)).toEqual(valid)
    }
  )

  it.each([
    [10, 10, true],
    [10, 100, 10],
    [10, 5, true],
    [10, -5, true],
  ])(
    "supports maximal value configuration %p (%p validates to %p)",
    (max_value: number, input: DataType, validation: number | boolean) => {
      const mockColumn = getNumberColumn(MOCK_FLOAT_ARROW_TYPE, {
        max_value,
      })
      expect(mockColumn.validateInput!(input)).toEqual(validation)
    }
  )

  it.each([
    [[]],
    ["foo"],
    [[1, 2]],
    ["123.124.123"],
    ["--123"],
    ["2,,2"],
    ["12345678987654321"],
  ])("%p results in error cell", (input: any) => {
    const mockColumn = getNumberColumn(MOCK_FLOAT_ARROW_TYPE)
    const cell = mockColumn.getCell(input)
    expect(isErrorCell(cell)).toEqual(true)
  })

  it("shows an error cell if the numeric value is too large", () => {
    const mockColumn = getNumberColumn(MOCK_INT_ARROW_TYPE)
    const unsafeCell = mockColumn.getCell("1234567898765432123")
    expect(isErrorCell(unsafeCell)).toEqual(true)
    expect((unsafeCell as ErrorCell)?.data).toEqual("1234567898765432123")
    expect((unsafeCell as ErrorCell)?.errorDetails).toEqual(
      "The value is larger than the maximum supported integer values in number columns (2^53)."
    )
  })

  it("doesn't show an error for large integers with a size up to 2^53", () => {
    const mockColumn = getNumberColumn(MOCK_INT_ARROW_TYPE)

    const safeCell = mockColumn.getCell("1234567898765432")
    expect(isErrorCell(safeCell)).toEqual(false)
  })

  it.each([
    // This should support everything that is supported by formatNumber
    // So we are not testing all the cases here, just a few to make sure it works
    // All other cases are tested for formatNumber in utils.test.ts
    [10.123, "%d", "10"],
    [10.123, "%i", "10"],
    [10.123, "%u", "10"],
    [10.123, "%f", "10.123"],
    [10.123, "%g", "10.123"],
    [10, "$%.2f", "$10.00"],
    [10.126, "$%.2f", "$10.13"],
    [10.123, "%.2f€", "10.12€"],
    [10.126, "($%.2f)", "($10.13)"],
    [65, "%d years", "65 years"],
    [1234567898765432, "%d ⭐", "1234567898765432 ⭐"],
    [72.3, "%.1f%%", "72.3%"],
    [-5.678, "%.1f", "-5.7"],
    [0.12, "percent", "12.00%"],
    [1100, "compact", "1.1K"],
  ])(
    "formats %p with sprintf format %p to %p",
    (input: number, format: string, displayValue: string) => {
      const mockColumn = getNumberColumn(MOCK_FLOAT_ARROW_TYPE, {
        format,
      })

      const cell = mockColumn.getCell(input)
      expect((cell as NumberCell).displayData).toEqual(displayValue)
    }
  )

  it.each([
    [10, "%d %d"],
    [1234567.89, "%'_,.2f"],
    [1234.5678, "%+.2E"],
    [0.000123456, "%+.2E"],
    [-0.000123456, "%+.2E"],
    [255, "%#x"],
    [4096, "%#X"],
    [42, "% d"],
    [1000, "%,.0f"],
    [25000.25, "$%,.2f"],
    [9876543210, "%,.0f"],
  ])(
    "cannot format %p using the sprintf format %p",
    (input: number, format: string) => {
      const mockColumn = getNumberColumn(MOCK_FLOAT_ARROW_TYPE, {
        format,
      })

      const cell = mockColumn.getCell(input)
      expect(isErrorCell(cell)).toEqual(true)
    }
  )

  it.each([
    [10, "10"],
    [1234567, "1234567"],
    [12345.678, "12345.678"],
    [-0.000123456, "-0.000123456"],
    [null, ""],
    [undefined, ""],
  ])(
    "uses raw number for copyData so that %p is copied as %p",
    (input: number | null | undefined, expectedCopyData: string) => {
      const mockColumn = getNumberColumn(MOCK_FLOAT_ARROW_TYPE, {
        format: "$%.2f",
      })

      const cell = mockColumn.getCell(input)
      expect(cell.copyData).toEqual(expectedCopyData)
    }
  )
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/NumberColumn.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCell, GridCellKind, NumberCell } from "@glideapps/glide-data-grid"

import { format as formatArrowCell } from "@streamlit/lib/src/dataframes/arrowFormatUtils"
import {
  isDurationType,
  isIntegerType,
  isPeriodType,
  isUnsignedIntegerType,
} from "@streamlit/lib/src/dataframes/arrowTypeUtils"
import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

import {
  BaseColumn,
  BaseColumnProps,
  countDecimals,
  formatNumber,
  getErrorCell,
  mergeColumnParameters,
  toSafeNumber,
  toSafeString,
  truncateDecimals,
} from "./utils"

export interface NumberColumnParams {
  // The minimum allowed value for editing. Is set to 0 for unsigned values.
  readonly min_value?: number
  // The maximum allowed value for editing.
  readonly max_value?: number
  // A formatting syntax (e.g. sprintf) to format the display value.
  // This can be used for adding prefix or suffix, or changing the number of decimals of the display value.
  readonly format?: string
  // Specifies the granularity that the value must adhere.
  // This will also influence the maximum precision. This will impact the number of decimals
  // allowed to be entered as well as the number of decimals displayed (if format is not specified).
  // This is set to 1 for integer types.
  readonly step?: number
}

/**
 * A column types that supports optimized rendering and editing for numbers.
 * This supports float, integer, and unsigned integer types.
 */
function NumberColumn(props: BaseColumnProps): BaseColumn {
  const parameters = mergeColumnParameters(
    // Default parameters:
    {
      // Set step to 1 for integer types
      step: isIntegerType(props.arrowType) ? 1 : undefined,
      // if uint (unsigned int), only positive numbers are allowed
      min_value: isUnsignedIntegerType(props.arrowType) ? 0 : undefined,
    } as NumberColumnParams,
    // User parameters:
    props.columnTypeOptions
  ) as NumberColumnParams

  // If no custom format is provided & the column type is duration or period,
  // instruct the column to use the arrow formatting for the display value.
  const useArrowFormatting =
    !parameters.format &&
    (isDurationType(props.arrowType) || isPeriodType(props.arrowType))

  const allowNegative =
    isNullOrUndefined(parameters.min_value) || parameters.min_value < 0

  const fixedDecimals =
    notNullOrUndefined(parameters.step) && !Number.isNaN(parameters.step)
      ? countDecimals(parameters.step)
      : undefined

  const cellTemplate = {
    kind: GridCellKind.Number,
    data: undefined,
    displayData: "",
    readonly: !props.isEditable,
    allowOverlay: true,
    contentAlign: props.contentAlignment || "right",
    // The text in pinned columns should be faded.
    style: props.isPinned ? "faded" : "normal",
    allowNegative,
    fixedDecimals,
    // We don't want to show any thousand separators
    // in the cell overlay/editor:
    thousandSeparator: "",
  } as NumberCell

  const validateInput = (data?: any): boolean | number => {
    let cellData: number | null = toSafeNumber(data)

    if (isNullOrUndefined(cellData)) {
      if (props.isRequired) {
        return false
      }
      return true
    }

    if (Number.isNaN(cellData)) {
      return false
    }

    // A flag to indicate whether the value has been auto-corrected.
    // This is used to decide if we should return the corrected value or true.
    // But we still run all other validations on the corrected value below.
    let corrected = false

    // Apply max_value configuration option:
    if (
      notNullOrUndefined(parameters.max_value) &&
      cellData > parameters.max_value
    ) {
      cellData = parameters.max_value
      corrected = true
    }

    // Apply min_value configuration option:
    if (
      notNullOrUndefined(parameters.min_value) &&
      cellData < parameters.min_value
    ) {
      // Only return false, since correcting it negatively impacts
      // the user experience.
      return false
    }

    // TODO(lukasmasuch): validate step size?
    // if (notNullOrUndefined(parameters.step) && parameters.step !== 1)

    return corrected ? cellData : true
  }

  return {
    ...props,
    kind: "number",
    sortMode: "smart",
    validateInput,
    getCell(data?: any, validate?: boolean): GridCell {
      if (validate === true) {
        const validationResult = validateInput(data)
        if (validationResult === false) {
          // The input is invalid, we return an error cell which will
          // prevent this cell to be inserted into the table.
          // This cell should never be actually displayed to the user.
          // It's mostly used internally to prevent invalid input to be
          // inserted into the table.
          return getErrorCell(toSafeString(data), "Invalid input.")
        } else if (typeof validationResult === "number") {
          // Apply corrections:
          data = validationResult
        }
      }

      let cellData: number | null = toSafeNumber(data)
      let displayData = ""

      if (notNullOrUndefined(cellData)) {
        if (Number.isNaN(cellData)) {
          return getErrorCell(
            toSafeString(data),
            "The value cannot be interpreted as a number."
          )
        }

        // Cut decimals:
        if (notNullOrUndefined(fixedDecimals)) {
          cellData = truncateDecimals(cellData, fixedDecimals)
        }

        // Check if the value is larger than the maximum supported value:
        if (Number.isInteger(cellData) && !Number.isSafeInteger(cellData)) {
          return getErrorCell(
            toSafeString(data),
            "The value is larger than the maximum supported integer values in number columns (2^53)."
          )
        }

        try {
          if (useArrowFormatting) {
            // Use arrow formatting for some selected types (see above)
            displayData = formatArrowCell(cellData, props.arrowType)
          } else {
            displayData = formatNumber(
              cellData,
              parameters.format,
              fixedDecimals
            )
          }
        } catch (error) {
          return getErrorCell(
            toSafeString(cellData),
            notNullOrUndefined(parameters.format)
              ? `Failed to format the number based on the provided format configuration: (${parameters.format}). Error: ${error}`
              : `Failed to format the number. Error: ${error}`
          )
        }
      }

      return {
        ...cellTemplate,
        data: cellData,
        displayData,
        isMissingValue: isNullOrUndefined(cellData),
        // We want to enforce the raw number without formatting when its copied:
        copyData: isNullOrUndefined(cellData) ? "" : toSafeString(cellData),
      } as NumberCell
    },
    getCellValue(cell: NumberCell): number | null {
      return cell.data === undefined ? null : cell.data
    },
  }
}

NumberColumn.isEditableType = true

export default NumberColumn


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/ObjectColumn.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCellKind, TextCell } from "@glideapps/glide-data-grid"

import ObjectColumn from "./ObjectColumn"

const MOCK_OBJECT_COLUMN_PROPS = {
  id: "1",
  name: "object_column",
  title: "Object column",
  indexNumber: 0,
  isEditable: false,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
  arrowType: {
    // The arrow type of the underlying data is
    // not used for anything inside the column.
    pandas_type: "object",
    numpy_type: "object",
  },
}

describe("ObjectColumn", () => {
  it("creates a valid column instance", () => {
    const mockColumn = ObjectColumn(MOCK_OBJECT_COLUMN_PROPS)
    expect(mockColumn.kind).toEqual("object")
    expect(mockColumn.title).toEqual(MOCK_OBJECT_COLUMN_PROPS.title)
    expect(mockColumn.id).toEqual(MOCK_OBJECT_COLUMN_PROPS.id)
    expect(mockColumn.sortMode).toEqual("default")

    const mockCell = mockColumn.getCell("foo")
    expect(mockCell.kind).toEqual(GridCellKind.Text)
    expect((mockCell as TextCell).data).toEqual("foo")
  })

  it("ignores isEditable configuration", () => {
    const mockColumn = ObjectColumn({
      ...MOCK_OBJECT_COLUMN_PROPS,
      isEditable: true,
    })

    // Column should be readonly, even if isEditable was true
    expect(mockColumn.isEditable).toEqual(false)
    // Cells from object column should always be readonly
    expect((mockColumn.getCell("foo") as TextCell).readonly).toEqual(true)
  })

  it.each([
    // Object column supports the
    // same conversions as the text column:
    ["foo", "foo"],
    ["abc def 1234 $", "abc def 1234 $"],
    [1, "1"],
    [0, "0"],
    [0.123, "0.123"],
    ["", ""],
    [[], ""],
    [["foo", "bar"], "foo,bar"],
    [[1, 2, 0.1231], "1,2,0.1231"],
    [true, "true"],
    [
      {
        foo: "bar",
      },
      "[object Object]",
    ],
    [null, null],
    [undefined, null],
  ])(
    "supports string-compatible value (%p parsed as %p)",
    (input: any, value: string | null) => {
      const mockColumn = ObjectColumn(MOCK_OBJECT_COLUMN_PROPS)
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
    }
  )
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/ObjectColumn.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCell, GridCellKind, TextCell } from "@glideapps/glide-data-grid"

import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

import {
  BaseColumn,
  BaseColumnProps,
  getErrorCell,
  removeLineBreaks,
  toSafeString,
} from "./utils"

/**
 * A column type for read-only cells used as a fallback
 * for data types that are currently not supported for editing.
 */
function ObjectColumn(props: BaseColumnProps): BaseColumn {
  const cellTemplate = {
    kind: GridCellKind.Text,
    data: "",
    displayData: "",
    allowOverlay: true,
    contentAlignment: props.contentAlignment,
    readonly: true,
    // The text in pinned columns should be faded.
    style: props.isPinned ? "faded" : "normal",
  } as TextCell
  return {
    ...props,
    kind: "object",
    sortMode: "default",
    isEditable: false, // Object columns are read-only.
    getCell(data?: any): GridCell {
      try {
        const cellData = notNullOrUndefined(data) ? toSafeString(data) : null
        const displayData = notNullOrUndefined(cellData)
          ? removeLineBreaks(cellData) // Remove line breaks to show all content in the cell
          : ""
        return {
          ...cellTemplate,
          data: cellData,
          displayData,
          isMissingValue: isNullOrUndefined(data),
        } as TextCell
      } catch (error) {
        return getErrorCell(
          toSafeString(data),
          `The value cannot be interpreted as a string. Error: ${error}`
        )
      }
    },
    getCellValue(cell: TextCell): string | null {
      return cell.data === undefined ? null : cell.data
    },
  }
}

ObjectColumn.isEditableType = false

export default ObjectColumn


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/ProgressColumn.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCellKind } from "@glideapps/glide-data-grid"
import { RangeCellType } from "@glideapps/glide-data-grid-cells"

import ProgressColumn, { ProgressColumnParams } from "./ProgressColumn"
import { BaseColumnProps, ErrorCell, isErrorCell } from "./utils"

const PROGRESS_COLUMN_TEMPLATE = {
  id: "1",
  name: "progress_column",
  title: "Progress column",
  indexNumber: 0,
  isEditable: false,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
  arrowType: {
    // The arrow type of the underlying data is
    // not used for anything inside the column.
    pandas_type: "float64",
    numpy_type: "float64",
  },
} as BaseColumnProps

function getProgressColumn(
  params?: ProgressColumnParams
): ReturnType<typeof ProgressColumn> {
  return ProgressColumn({
    ...PROGRESS_COLUMN_TEMPLATE,
    columnTypeOptions: params,
  } as BaseColumnProps)
}

describe("ProgressColumn", () => {
  it("creates a valid column instance", () => {
    const mockColumn = getProgressColumn()
    expect(mockColumn.kind).toEqual("progress")
    expect(mockColumn.title).toEqual(PROGRESS_COLUMN_TEMPLATE.title)
    expect(mockColumn.id).toEqual(PROGRESS_COLUMN_TEMPLATE.id)
    expect(mockColumn.sortMode).toEqual("smart")

    // Column should be readonly:
    expect(mockColumn.isEditable).toEqual(false)

    const mockCell = mockColumn.getCell(0.5)
    expect(mockCell.kind).toEqual(GridCellKind.Custom)
    expect((mockCell as RangeCellType).data?.value).toEqual(0.5)
    expect((mockCell as RangeCellType).data?.label).toEqual("50.00%")
  })

  it("supports configuring min/max scale", () => {
    const mockColumn = getProgressColumn()
    const mockCell = mockColumn.getCell(50)
    // Default min/max scale is 0/1 so the value should be at the maximum
    expect((mockCell as RangeCellType).data?.value).toEqual(1)

    // Use a different scale
    const mockColumn1 = getProgressColumn({
      min_value: -100,
      max_value: 100,
    })
    const mockCell1 = mockColumn1.getCell(50)
    // The value fits into the scale, so don't do anything:
    expect((mockCell1 as RangeCellType).data?.value).toEqual(50)

    // Use a different scale
    const mockColumn2 = getProgressColumn({
      min_value: 100,
      max_value: -100,
    })
    const mockCell2 = mockColumn2.getCell(50)
    // min needs to be bigger than max, so this should be an error cell:
    expect(isErrorCell(mockCell2)).toEqual(true)

    // Use a different scale
    const mockColumn3 = getProgressColumn({
      min_value: undefined,
      max_value: -100,
    })
    const mockCell3 = mockColumn3.getCell(50)
    // min and max need to be defined, so this should be an error cell:
    expect(isErrorCell(mockCell3)).toEqual(true)
  })

  it.each([
    // Supports almost the same as toSafeNumber
    [null, null],
    [undefined, null],
    ["", null],
    [[], null],
    ["0.1", 0.1],
    [0.1234, 0.1234],
  ])(
    "supports number-compatible value (%p parsed as %p)",
    (input: any, value: number | null) => {
      const mockColumn = getProgressColumn()
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
    }
  )

  it.each([
    ["foo"],
    [[]],
    ["foo"],
    [[1, 2]],
    ["123.124.123"],
    ["--123"],
    ["2,,2"],
  ])("%p results in error cell", (input: any) => {
    const mockColumn = getProgressColumn()
    const cell = mockColumn.getCell(input)
    expect(isErrorCell(cell)).toEqual(true)
  })

  it.each([
    // This should support everything that is supported by formatNumber
    // So we are not testing all the cases here, just a few to make sure it works
    // All other cases are tested for formatNumber in utils.test.ts
    [10.123, "%d", "10"],
    [10.123, "%i", "10"],
    [10.123, "%u", "10"],
    [10.123, "%f", "10.123"],
    [10.123, "%g", "10.123"],
    [10, "$%.2f", "$10.00"],
    [10.126, "$%.2f", "$10.13"],
    [10.123, "%.2f€", "10.12€"],
    [10.126, "($%.2f)", "($10.13)"],
    [65, "%d years", "65 years"],
    [1234567898765432, "%d ⭐", "1234567898765432 ⭐"],
    [72.3, "%.1f%%", "72.3%"],
    [-5.678, "%.1f", "-5.7"],
    [0.12, "percent", "12.00%"],
    [1100, "compact", "1.1K"],
  ])(
    "formats %p with sprintf format %p to %p",
    (input: number, format: string, displayValue: string) => {
      const mockColumn = getProgressColumn({
        format,
      })

      const cell = mockColumn.getCell(input)
      expect((cell as RangeCellType).data.label).toEqual(displayValue)
    }
  )

  it("shows an error cell if the numeric value is too large", () => {
    const mockColumn = getProgressColumn()
    const unsafeCell = mockColumn.getCell("1234567898765432123")
    expect(isErrorCell(unsafeCell)).toEqual(true)
    expect((unsafeCell as ErrorCell)?.data).toEqual("1234567898765432123")
    expect((unsafeCell as ErrorCell)?.errorDetails).toEqual(
      "The value is larger than the maximum supported integer values in number columns (2^53)."
    )
  })

  it.each([
    [10, "%d %d"],
    [1234567.89, "%'_,.2f"],
    [1234.5678, "%+.2E"],
    [0.000123456, "%+.2E"],
    [-0.000123456, "%+.2E"],
    [255, "%#x"],
    [4096, "%#X"],
    [42, "% d"],
    [1000, "%,.0f"],
    [25000.25, "$%,.2f"],
    [9876543210, "%,.0f"],
  ])(
    "cannot format %p using the sprintf format %p",
    (input: number, format: string) => {
      const mockColumn = getProgressColumn({
        format,
      })

      const cell = mockColumn.getCell(input)
      expect(isErrorCell(cell)).toEqual(true)
    }
  )

  it("correctly formats float values to percentage", () => {
    const mockColumn = getProgressColumn()
    const mockCell = mockColumn.getCell(0.52356)
    expect((mockCell as RangeCellType).data?.min).toEqual(0)
    expect((mockCell as RangeCellType).data?.max).toEqual(1)
    expect((mockCell as RangeCellType).data?.step).toEqual(0.01)
    // Correctly formats float values to percentage:
    expect((mockCell as RangeCellType).data?.value).toEqual(0.52356)
    expect((mockCell as RangeCellType).data?.label).toEqual("52.36%")
  })

  it("correctly formats int values to percentage", () => {
    const mockColumn = ProgressColumn({
      ...PROGRESS_COLUMN_TEMPLATE,
      arrowType: {
        pandas_type: "int64",
        numpy_type: "int64",
      },
    } as BaseColumnProps)
    const mockCell = mockColumn.getCell(52)
    expect((mockCell as RangeCellType).data?.min).toEqual(0)
    expect((mockCell as RangeCellType).data?.max).toEqual(100)
    expect((mockCell as RangeCellType).data?.step).toEqual(1)
    // Correctly formats int values to percentage:
    expect((mockCell as RangeCellType).data?.value).toEqual(52)
    expect((mockCell as RangeCellType).data?.label).toEqual(" 52%")
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/ProgressColumn.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  GridCell,
  GridCellKind,
  LoadingCell,
} from "@glideapps/glide-data-grid"
import { RangeCellType } from "@glideapps/glide-data-grid-cells"

import { isIntegerType } from "@streamlit/lib/src/dataframes/arrowTypeUtils"
import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

import {
  BaseColumn,
  BaseColumnProps,
  countDecimals,
  formatNumber,
  getEmptyCell,
  getErrorCell,
  mergeColumnParameters,
  toSafeNumber,
  toSafeString,
} from "./utils"

export interface ProgressColumnParams {
  // The minimum permitted value. Defaults to 0.
  readonly min_value?: number
  // The maximum permitted value. Defaults to 100 if the underlying data is integer,
  // or 1 for all others types.
  readonly max_value?: number
  // A formatting syntax (e.g. sprintf) to format the display value.
  // This can be used for adding prefix or suffix, or changing the number of decimals of the display value.
  readonly format?: string
  // The stepping interval. Defaults to 0.01.
  // Mainly useful once we provide editing capabilities.
  readonly step?: number
}

/**
 * A read-only column type to support rendering values that have a defined
 * range. This is rendered via a progress-bar-like visualization.
 */
function ProgressColumn(props: BaseColumnProps): BaseColumn {
  const isInteger = isIntegerType(props.arrowType)

  const parameters = mergeColumnParameters(
    // Default parameters:
    {
      min_value: 0,
      max_value: isInteger ? 100 : 1,
      step: isInteger ? 1 : 0.01,
      format: isInteger ? "%3d%%" : "percent",
    } as ProgressColumnParams,
    // User parameters:
    props.columnTypeOptions
  ) as ProgressColumnParams

  // Measure the display value of the max value, so that all progress bars are aligned correctly:
  let measureLabel: string
  try {
    measureLabel = formatNumber(
      parameters.max_value as number,
      parameters.format
    )
  } catch (error) {
    measureLabel = toSafeString(parameters.max_value)
  }

  const fixedDecimals =
    isNullOrUndefined(parameters.step) || Number.isNaN(parameters.step)
      ? undefined
      : countDecimals(parameters.step)

  const cellTemplate = {
    kind: GridCellKind.Custom,
    allowOverlay: false,
    copyData: "",
    contentAlign: props.contentAlignment,
    data: {
      kind: "range-cell",
      min: parameters.min_value,
      max: parameters.max_value,
      step: parameters.step,
      value: parameters.min_value,
      label: String(parameters.min_value),
      measureLabel,
      readonly: true,
    },
  } as RangeCellType

  return {
    ...props,
    kind: "progress",
    sortMode: "smart",
    isEditable: false, // Progress column is always readonly
    getCell(data?: any): GridCell {
      if (isNullOrUndefined(data)) {
        // TODO(lukasmasuch): Use a missing cell?
        return getEmptyCell()
      }

      if (
        isNullOrUndefined(parameters.min_value) ||
        isNullOrUndefined(parameters.max_value) ||
        Number.isNaN(parameters.min_value) ||
        Number.isNaN(parameters.max_value) ||
        parameters.min_value >= parameters.max_value
      ) {
        return getErrorCell(
          "Invalid min/max parameters",
          `The min_value (${parameters.min_value}) and max_value (${parameters.max_value}) parameters must be valid numbers.`
        )
      }

      if (
        isNullOrUndefined(parameters.step) ||
        Number.isNaN(parameters.step)
      ) {
        return getErrorCell(
          "Invalid step parameter",
          `The step parameter (${parameters.step}) must be a valid number.`
        )
      }

      const cellData = toSafeNumber(data)

      if (Number.isNaN(cellData) || isNullOrUndefined(cellData)) {
        return getErrorCell(
          toSafeString(data),
          "The value cannot be interpreted as a number."
        )
      }

      // Check if the value is larger than the maximum supported value:
      if (Number.isInteger(cellData) && !Number.isSafeInteger(cellData)) {
        return getErrorCell(
          toSafeString(data),
          "The value is larger than the maximum supported integer values in number columns (2^53)."
        )
      }

      let displayData = ""

      try {
        displayData = formatNumber(cellData, parameters.format, fixedDecimals)
      } catch (error) {
        return getErrorCell(
          toSafeString(cellData),
          notNullOrUndefined(parameters.format)
            ? `Failed to format the number based on the provided format configuration: (${parameters.format}). Error: ${error}`
            : `Failed to format the number. Error: ${error}`
        )
      }

      // If the value is outside the range, we scale it to the min/max
      // for the visualization.
      const normalizeCellValue = Math.min(
        parameters.max_value,
        Math.max(parameters.min_value, cellData)
      )

      return {
        ...cellTemplate,
        isMissingValue: isNullOrUndefined(data),
        copyData: String(cellData), // Column sorting is done via the copyData value
        data: {
          ...cellTemplate.data,
          value: normalizeCellValue,
          label: displayData,
        },
      } as RangeCellType
    },
    getCellValue(cell: RangeCellType | LoadingCell): number | null {
      if (cell.kind === GridCellKind.Loading) {
        return null
      }
      return cell.data?.value === undefined ? null : cell.data?.value
    },
  }
}

ProgressColumn.isEditableType = false

export default ProgressColumn


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/SelectboxColumn.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCellKind } from "@glideapps/glide-data-grid"
import { DropdownCellType } from "@glideapps/glide-data-grid-cells"

import { PandasColumnType as ArrowType } from "@streamlit/lib/src/dataframes/arrowTypeUtils"

import SelectboxColumn, { SelectboxColumnParams } from "./SelectboxColumn"
import { BaseColumnProps, isErrorCell, isMissingValueCell } from "./utils"

const MOCK_CATEGORICAL_TYPE: ArrowType = {
  pandas_type: "int8",
  numpy_type: "categorical",
}

const MOCK_BOOLEAN_ARROW_TYPE: ArrowType = {
  pandas_type: "bool",
  numpy_type: "bool",
}

const SELECTBOX_COLUMN_TEMPLATE: Partial<BaseColumnProps> = {
  id: "1",
  name: "selectbox_column",
  title: "Selectbox column",
  indexNumber: 0,
  isEditable: true,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
}

function getSelectboxColumn(
  arrowType: ArrowType,
  params?: SelectboxColumnParams,
  column_props_overwrites?: Partial<BaseColumnProps>
): ReturnType<typeof SelectboxColumn> {
  return SelectboxColumn({
    ...SELECTBOX_COLUMN_TEMPLATE,
    ...column_props_overwrites,
    arrowType,
    columnTypeOptions: params,
  } as BaseColumnProps)
}

describe("SelectboxColumn", () => {
  it("creates a valid column instance with string values", () => {
    const mockColumn = getSelectboxColumn(MOCK_CATEGORICAL_TYPE, {
      options: ["foo", "bar"],
    })
    expect(mockColumn.kind).toEqual("selectbox")
    expect(mockColumn.title).toEqual(SELECTBOX_COLUMN_TEMPLATE.title)
    expect(mockColumn.id).toEqual(SELECTBOX_COLUMN_TEMPLATE.id)
    expect(mockColumn.sortMode).toEqual("default")

    const mockCell = mockColumn.getCell("foo")
    expect(mockCell.kind).toEqual(GridCellKind.Custom)
    expect(mockColumn.getCellValue(mockCell)).toEqual("foo")

    expect((mockCell as DropdownCellType).data.allowedValues).toEqual([
      null,
      "foo",
      "bar",
    ])
  })

  it("creates a valid column instance number values", () => {
    const mockColumn = getSelectboxColumn(MOCK_CATEGORICAL_TYPE, {
      options: [1, 2, 3],
    })
    expect(mockColumn.kind).toEqual("selectbox")
    expect(mockColumn.title).toEqual(SELECTBOX_COLUMN_TEMPLATE.title)
    expect(mockColumn.id).toEqual(SELECTBOX_COLUMN_TEMPLATE.id)
    expect(mockColumn.sortMode).toEqual("default")

    const mockCell = mockColumn.getCell(1)
    expect(mockCell.kind).toEqual(GridCellKind.Custom)
    expect(mockColumn.getCellValue(mockCell)).toEqual(1)

    expect((mockCell as DropdownCellType).data.allowedValues).toEqual([
      null,
      "1",
      "2",
      "3",
    ])
  })

  it("creates a valid column instance from boolean type", () => {
    const mockColumn = getSelectboxColumn(MOCK_BOOLEAN_ARROW_TYPE)
    expect(mockColumn.kind).toEqual("selectbox")
    expect(mockColumn.title).toEqual(SELECTBOX_COLUMN_TEMPLATE.title)

    const mockCell = mockColumn.getCell(true)
    expect(mockCell.kind).toEqual(GridCellKind.Custom)
    expect(mockColumn.getCellValue(mockCell)).toEqual(true)

    expect((mockCell as DropdownCellType).data.allowedValues).toEqual([
      null,
      "true",
      "false",
    ])
  })

  it("creates a required column that does not add the empty value", () => {
    const mockColumn = getSelectboxColumn(
      MOCK_CATEGORICAL_TYPE,
      {
        options: ["foo", "bar"],
      },
      { isRequired: true }
    )
    const mockCell = mockColumn.getCell("foo")
    expect((mockCell as DropdownCellType).data.allowedValues).toEqual([
      "foo",
      "bar",
    ])

    const errorCell = mockColumn.getCell(null, true)
    expect(isErrorCell(errorCell)).toEqual(true)
  })

  it("uses faded style for pinned columns", () => {
    const mockColumn = getSelectboxColumn(
      MOCK_CATEGORICAL_TYPE,
      {
        options: ["foo", "bar"],
      },
      {
        isPinned: true,
      }
    )

    const mockCell = mockColumn.getCell("foo")
    expect(mockCell.style).toEqual("faded")
  })

  it("creates error cell if value is not in options", () => {
    const mockColumn = getSelectboxColumn(MOCK_CATEGORICAL_TYPE, {
      options: ["foo", "bar"],
    })
    const mockCell = mockColumn.getCell("baz", true)
    expect(isErrorCell(mockCell)).toEqual(true)
  })

  it.each([[null], [undefined], [""]])(
    "%p is interpreted as missing value",
    (input: any) => {
      const mockColumn = getSelectboxColumn(MOCK_CATEGORICAL_TYPE, {
        options: ["foo", "bar"],
      })
      const mockCell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(mockCell)).toEqual(null)
      expect(isMissingValueCell(mockCell)).toEqual(true)
    }
  )
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/SelectboxColumn.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCell, GridCellKind } from "@glideapps/glide-data-grid"
import { DropdownCellType } from "@glideapps/glide-data-grid-cells"

import { isBooleanType } from "@streamlit/lib/src/dataframes/arrowTypeUtils"
import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

import {
  BaseColumn,
  BaseColumnProps,
  getErrorCell,
  mergeColumnParameters,
  toSafeBoolean,
  toSafeNumber,
  toSafeString,
} from "./utils"

export interface SelectboxColumnParams {
  /** A list of options available in the selectbox.
   * Every value in the column needs to match one of the options.
   */
  readonly options: (string | number | boolean)[]
}

/**
 * A column type that supports optimized rendering and editing for categorical values
 * by using a selectbox. This is automatically used by categorical columns (Pandas).
 *
 */
function SelectboxColumn(props: BaseColumnProps): BaseColumn {
  // The selectbox column can be either string, number or boolean type
  // based on the options type.
  let dataType: "number" | "boolean" | "string" = "string"

  const parameters = mergeColumnParameters(
    // Default parameters:
    {
      options: isBooleanType(props.arrowType) ? [true, false] : [],
    },
    // User parameters:
    props.columnTypeOptions
  ) as SelectboxColumnParams

  const uniqueTypes = new Set(parameters.options.map(x => typeof x))
  if (uniqueTypes.size === 1) {
    if (uniqueTypes.has("number") || uniqueTypes.has("bigint")) {
      dataType = "number"
    } else if (uniqueTypes.has("boolean")) {
      dataType = "boolean"
    }
  }

  const cellTemplate = {
    kind: GridCellKind.Custom,
    allowOverlay: true,
    copyData: "",
    contentAlign: props.contentAlignment,
    readonly: !props.isEditable,
    // The text in pinned columns should be faded.
    style: props.isPinned ? "faded" : "normal",
    data: {
      kind: "dropdown-cell",
      allowedValues: [
        // Add empty option if the column is not configured as required:
        ...(props.isRequired !== true ? [null] : []),
        ...parameters.options
          .filter(opt => opt !== null && opt !== "") // ignore empty option if it exists
          .map(opt => toSafeString(opt)), // convert everything to string
      ],
      value: "",
    },
  } as DropdownCellType

  return {
    ...props,
    kind: "selectbox",
    sortMode: "default",
    getCell(data?: any, validate?: boolean): GridCell {
      // Empty string refers to a missing value
      let cellData = null
      if (notNullOrUndefined(data) && data !== "") {
        cellData = toSafeString(data)
      }

      if (validate && !cellTemplate.data.allowedValues.includes(cellData)) {
        return getErrorCell(
          toSafeString(cellData),
          `The value is not part of the allowed options.`
        )
      }

      return {
        ...cellTemplate,
        isMissingValue: cellData === null,
        copyData: cellData || "", // Column sorting is done via the copyData value
        data: {
          ...cellTemplate.data,
          value: cellData,
        },
      } as DropdownCellType
    },
    getCellValue(cell: DropdownCellType): string | number | boolean | null {
      if (isNullOrUndefined(cell.data?.value) || cell.data?.value === "") {
        return null
      }
      if (dataType === "number") {
        return toSafeNumber(cell.data?.value) ?? null
      } else if (dataType === "boolean") {
        return toSafeBoolean(cell.data?.value) ?? null
      }
      return cell.data?.value
    },
  }
}

SelectboxColumn.isEditableType = true

export default SelectboxColumn


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/TextColumn.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable  @typescript-eslint/no-non-null-assertion */

import { GridCellKind, TextCell } from "@glideapps/glide-data-grid"

import TextColumn from "./TextColumn"
import { ErrorCell, isErrorCell } from "./utils"

const MOCK_TEXT_COLUMN_PROPS = {
  id: "1",
  name: "text_column",
  title: "Text column",
  indexNumber: 0,
  isEditable: false,
  isHidden: false,
  isIndex: false,
  isPinned: false,
  isStretched: false,
  arrowType: {
    // The arrow type of the underlying data is
    // not used for anything inside the column.
    pandas_type: "unicode",
    numpy_type: "object",
  },
}

describe("TextColumn", () => {
  it("creates a valid column instance", () => {
    const mockColumn = TextColumn(MOCK_TEXT_COLUMN_PROPS)
    expect(mockColumn.kind).toEqual("text")
    expect(mockColumn.title).toEqual(MOCK_TEXT_COLUMN_PROPS.title)
    expect(mockColumn.id).toEqual(MOCK_TEXT_COLUMN_PROPS.id)
    expect(mockColumn.sortMode).toEqual("default")

    const mockCell = mockColumn.getCell("foo")
    expect(mockCell.kind).toEqual(GridCellKind.Text)
    expect((mockCell as TextCell).data).toEqual("foo")
  })

  it.each([
    ["foo", "foo"],
    ["abc def 1234 $", "abc def 1234 $"],
    [1, "1"],
    [0, "0"],
    [0.123, "0.123"],
    ["", ""],
    [[], ""],
    [["foo", "bar"], "foo,bar"],
    [[1, 2, 0.1231], "1,2,0.1231"],
    [true, "true"],
    [
      {
        foo: "bar",
      },
      "[object Object]",
    ],
    [null, null],
    [undefined, null],
  ])(
    "supports string-compatible value (%p parsed as %p)",
    (input: any, value: string | null) => {
      const mockColumn = TextColumn(MOCK_TEXT_COLUMN_PROPS)
      const cell = mockColumn.getCell(input)
      expect(mockColumn.getCellValue(cell)).toEqual(value)
    }
  )

  it("validates input based on max_chars", () => {
    const mockColumn = TextColumn({
      ...MOCK_TEXT_COLUMN_PROPS,
      columnTypeOptions: { max_chars: 5 },
    })

    expect(mockColumn.validateInput!("12345")).toBe(true)
    expect(mockColumn.validateInput!("123456")).toBe("12345")
    expect(mockColumn.validateInput!("1234567890")).toBe("12345")
  })

  it("validates input based on validate regex", () => {
    const mockColumn = TextColumn({
      ...MOCK_TEXT_COLUMN_PROPS,
      columnTypeOptions: { validate: "^[a-zA-Z]+$" },
    })

    expect(mockColumn.validateInput!("abcde")).toBe(true)
    expect(mockColumn.validateInput!("12345")).toBe(false)
    expect(mockColumn.validateInput!("abc123")).toBe(false)
  })

  it("validates input based on max_chars and validate regex", () => {
    const mockColumn = TextColumn({
      ...MOCK_TEXT_COLUMN_PROPS,
      columnTypeOptions: { max_chars: 5, validate: "^[a-zA-Z]+$" },
    })

    expect(mockColumn.validateInput!("abcde")).toBe(true)
    expect(mockColumn.validateInput!("abcdef")).toBe("abcde")
    expect(mockColumn.validateInput!("12345")).toBe(false)
    expect(mockColumn.validateInput!("abc123")).toBe(false)
  })

  it("applies input validation in the getCell call based on max_chars and validate regex", () => {
    const mockColumn = TextColumn({
      ...MOCK_TEXT_COLUMN_PROPS,
      columnTypeOptions: { max_chars: 5, validate: "^[a-zA-Z]+$" },
    })

    expect(isErrorCell(mockColumn.getCell("abcde", true))).toBe(false)
    expect(isErrorCell(mockColumn.getCell("12345", true))).toBe(true)
    // A too long input is fine since it can be auto fixed
    expect(isErrorCell(mockColumn.getCell("abcdef", true))).toBe(false)
    // Applies the max chars limit
    expect((mockColumn.getCell("abcdef", true) as TextCell).data).toBe("abcde")
    // But a too long input that is still wrong after fixing should result in error
    expect(isErrorCell(mockColumn.getCell("1234567", true))).toBe(true)
  })

  it("handles invalid validate regex", () => {
    const mockColumn = TextColumn({
      ...MOCK_TEXT_COLUMN_PROPS,
      columnTypeOptions: { validate: "[" }, // Invalid regex
    })

    const cell = mockColumn.getCell("test", true)
    expect(isErrorCell(cell)).toEqual(true)
    // Data should contain the initial raw data
    expect((cell as ErrorCell).data).toContain("test")
    expect((cell as ErrorCell).errorDetails).toContain(
      "Invalid validate regex"
    )
  })

  it("ignores empty validate", () => {
    const mockColumn = TextColumn({
      ...MOCK_TEXT_COLUMN_PROPS,
      columnTypeOptions: { validate: "" },
    })

    const cell = mockColumn.getCell("test", true)
    expect(isErrorCell(cell)).toEqual(false)
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/columns/TextColumn.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { GridCell, GridCellKind, TextCell } from "@glideapps/glide-data-grid"

import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

import {
  BaseColumn,
  BaseColumnProps,
  getErrorCell,
  removeLineBreaks,
  toSafeString,
} from "./utils"

export interface TextColumnParams {
  // The maximum number of characters the user can enter into the text input.
  readonly max_chars?: number
  // Regular expression that the input's value must match for the value to pass
  readonly validate?: string
}

/**
 * A column that supports rendering & editing of text values.
 */
function TextColumn(props: BaseColumnProps): BaseColumn {
  const parameters = (props.columnTypeOptions as TextColumnParams) || {}

  let validateRegex: RegExp | string | undefined = undefined

  if (parameters.validate) {
    // Prepare the validation regex:
    try {
      // u flag allows unicode characters
      // s flag allows . to match newlines
      validateRegex = new RegExp(parameters.validate, "us")
    } catch (error) {
      // Put error message in validateRegex so we can display it in the cell
      validateRegex = `Invalid validate regex: ${parameters.validate}.\nError: ${error}`
    }
  }

  const cellTemplate = {
    kind: GridCellKind.Text,
    data: "",
    displayData: "",
    allowOverlay: true,
    contentAlignment: props.contentAlignment,
    readonly: !props.isEditable,
    // The text in pinned columns should be faded.
    style: props.isPinned ? "faded" : "normal",
  } as TextCell

  const validateInput = (data?: any): boolean | string => {
    if (isNullOrUndefined(data)) {
      if (props.isRequired) {
        return false
      }
      return true
    }

    let cellData = toSafeString(data)
    // A flag to indicate whether the value has been auto-corrected.
    // This is used to decide if we should return the corrected value or true.
