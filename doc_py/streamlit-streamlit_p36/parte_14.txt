    for (let channel = 0; channel < numOfChan; channel++) {
      const sample = Math.max(
        -1,
        Math.min(1, audioBuffer.getChannelData(channel)[i])
      )
      view.setInt16(offset, sample * 0x7fff, true)
      offset += 2
    }
  }

  const wavArray = new Uint8Array(buffer)
  return new Blob([wavArray], { type: "audio/wav" })
}

/**
 * Writes a string to a DataView at the specified offset.
 * @param view - The DataView to write to.
 * @param offset - The starting offset in the DataView.
 * @param string - The string to write.
 */
function writeString(view: DataView, offset: number, string: string): void {
  for (let i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i))
  }
}

export default convertFileToWav


================================================
File: /frontend/lib/src/components/widgets/AudioInput/formatTime.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { withTimezones } from "@streamlit/lib/src/util/withTimezones"

import formatTime from "./formatTime"

withTimezones(() => {
  describe("formatTime", () => {
    it('should format 0 milliseconds as "00:00"', () => {
      expect(formatTime(0)).toBe("00:00")
    })

    it('should format 1000 milliseconds as "00:01"', () => {
      expect(formatTime(1000)).toBe("00:01")
    })

    it('should format 90000 milliseconds as "01:30"', () => {
      expect(formatTime(90000)).toBe("01:30")
    })
  })
})


================================================
File: /frontend/lib/src/components/widgets/AudioInput/formatTime.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const formatTime = (timeMs: number): string => {
  const date = new Date(timeMs)

  return date.toLocaleTimeString(undefined, {
    minute: "2-digit",
    second: "2-digit",
    timeZone: "UTC",
  })
}

export default formatTime


================================================
File: /frontend/lib/src/components/widgets/AudioInput/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./AudioInput"


================================================
File: /frontend/lib/src/components/widgets/AudioInput/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"
import { Spinner } from "baseui/spinner"

export const StyledAudioInputContainerDiv = styled.div()

export const StyledWaveformContainerDiv = styled.div(({ theme }) => ({
  height: theme.sizes.largestElementHeight,
  width: "100%",
  background: theme.colors.secondaryBg,
  borderRadius: theme.radii.default,
  marginBottom: theme.spacing.twoXS,
  display: "flex",
  alignItems: "center",
  position: "relative",
  paddingLeft: theme.spacing.xs,
  paddingRight: theme.spacing.sm,
}))

export const StyledWaveformInnerDiv = styled.div({
  flex: 1,
})

export const StyledWaveSurferDiv = styled.div<{ show: boolean }>(
  ({ show }) => ({
    display: show ? "block" : "none",
  })
)

export const StyledWaveformTimeCode = styled.span<{
  isPlayingOrRecording: boolean
}>(({ theme, isPlayingOrRecording }) => ({
  margin: theme.spacing.sm,
  fontFamily: theme.fonts.monospace,
  color: isPlayingOrRecording
    ? theme.colors.bodyText
    : theme.colors.fadedText60,
  backgroundColor: theme.colors.secondaryBg,
  fontSize: theme.fontSizes.sm,
}))

export const StyledErrorContainerDiv = styled.div({
  width: "100%",
  textAlign: "center",
  overflow: "hidden",
})

export const StyledErrorTextSpan = styled.span(({ theme }) => ({
  color: theme.colors.bodyText,
}))

export const StyledNoMicInputLearnMoreLink = styled.a(({ theme }) => ({
  color: theme.colors.linkText,
  textDecoration: "underline",
}))

// Placeholder
export const StyledPlaceholderContainerDiv = styled.div(({ theme }) => ({
  height: theme.sizes.largestElementHeight,
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
}))

export const StyledPlaceholderDotsDiv = styled.div(({ theme }) => {
  const dotSize = "0.625em"
  return {
    opacity: 0.2,
    width: "100%",
    height: dotSize,
    backgroundSize: dotSize,
    backgroundImage: `radial-gradient(${theme.colors.fadedText10} 40%, transparent 40%)`,
    backgroundRepeat: "repeat",
  }
})

export const StyledActionButtonStopRecordingDiv = styled.span(({ theme }) => ({
  "& > button": {
    color: theme.colors.primary,
    padding: theme.spacing.threeXS,
  },
  "& > button:hover, & > button:focus": {
    color: theme.colors.red,
  },
}))

export const StyledActionButtonStartRecordingDiv = styled.span(
  ({ theme }) => ({
    "& > button": {
      padding: theme.spacing.threeXS,
      color: theme.colors.fadedText40,
    },
    "& > button:hover, & > button:focus": {
      color: theme.colors.primary,
    },
  })
)

export const StyledActionButtonPlayPauseDiv = styled.span(({ theme }) => ({
  "& > button": {
    padding: theme.spacing.threeXS,
    color: theme.colors.fadedText60,
  },
  "& > button:hover, & > button:focus": {
    color: theme.colors.bodyText,
  },
}))

export const StyledActionButtonContainerDiv = styled.div(({ theme }) => ({
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  flexGrow: 0,
  flexShrink: 1,
  padding: theme.spacing.xs,
  gap: theme.spacing.twoXS,
  marginRight: theme.spacing.twoXS,
}))

export const StyledWidgetLabelHelp = styled.div(({ theme }) => ({
  marginLeft: theme.spacing.sm,
}))

export const StyledSpinner = styled(Spinner)(({ theme }) => {
  return {
    fontSize: theme.fontSizes.sm,
    width: theme.sizes.spinnerSize,
    height: theme.sizes.spinnerSize,
    borderWidth: theme.sizes.spinnerThickness,
    radius: theme.radii.md,
    justifyContents: "center",
    padding: theme.spacing.none,
    margin: theme.spacing.none,
    borderColor: theme.colors.borderColor,
    borderTopColor: theme.colors.primary,
    flexGrow: 0,
    flexShrink: 0,
  }
})


================================================
File: /frontend/lib/src/components/widgets/BaseWidget/WidgetLabel.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { LabelVisibilityOptions } from "@streamlit/lib/src/util/utils"

import { LabelProps, WidgetLabel } from "./WidgetLabel"

const getProps = (props?: Partial<LabelProps>): LabelProps => ({
  label: "Label",
  ...props,
})

describe("Widget Label", () => {
  it("renders WidgetLabel as expected", () => {
    const props = getProps()
    render(<WidgetLabel {...props} />)

    expect(screen.getByTestId("stWidgetLabel")).toBeInTheDocument()
  })

  it("renders label text as expected", () => {
    const props = getProps()
    render(<WidgetLabel {...props} />)

    expect(screen.getByTestId("stWidgetLabel")).toBeInTheDocument()

    // Use the smaller font size for the markdown container
    const markdownContainer = screen.getByTestId("stMarkdownContainer")
    expect(markdownContainer).toHaveStyle("font-size: 14px")
  })

  it("can be disabled", () => {
    const props = getProps({ disabled: true })
    render(<WidgetLabel {...props} />)

    expect(screen.getByTestId("stWidgetLabel")).toHaveAttribute("disabled")
  })

  it("can hide label visibility", () => {
    const props = getProps({ labelVisibility: LabelVisibilityOptions.Hidden })
    render(<WidgetLabel {...props} />)

    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle(
      "visibility: hidden"
    )
  })
})


================================================
File: /frontend/lib/src/components/widgets/BaseWidget/WidgetLabel.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import {
  isNullOrUndefined,
  LabelVisibilityOptions,
} from "@streamlit/lib/src/util/utils"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"

import { StyledWidgetLabel } from "./styled-components"

export interface LabelProps {
  // Label body text. If nullsy, WidgetLabel won't show. But if empty string it will.
  label?: string | null

  // Used to specify other elements that should go inside the label container, like a help icon.
  children?: React.ReactNode

  // Used to specify whether widget disabled or enabled.
  disabled?: boolean | null

  // Used to specify whether widget is visible or not.
  labelVisibility?: LabelVisibilityOptions

  // Associates the label with the input field programatically. Makes it possible to focus input by clicking on label.
  htmlFor?: string
}

export function WidgetLabel({
  label,
  children,
  disabled,
  labelVisibility,
  htmlFor,
}: LabelProps): React.ReactElement {
  if (isNullOrUndefined(label)) {
    return <></>
  }

  return (
    // we use aria-hidden to disable ARIA for StyleWidgetLabel, because each
    // widget should have its own aria-label and/or implement accessibility.
    <StyledWidgetLabel
      data-testid="stWidgetLabel"
      aria-hidden="true"
      disabled={disabled}
      labelVisibility={labelVisibility}
      htmlFor={htmlFor}
    >
      <StreamlitMarkdown source={label} allowHTML={false} isLabel />
      {children}
    </StyledWidgetLabel>
  )
}


================================================
File: /frontend/lib/src/components/widgets/BaseWidget/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export {
  StyledWidgetInstructions,
  StyledWidgetLabel,
  StyledWidgetLabelHelp,
  StyledWidgetLabelHelpInline,
} from "./styled-components"

export { WidgetLabel } from "./WidgetLabel"


================================================
File: /frontend/lib/src/components/widgets/BaseWidget/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

import { LabelVisibilityOptions } from "@streamlit/lib/src/util/utils"

export interface StyledWidgetProps {
  disabled?: boolean | null
  labelVisibility?: LabelVisibilityOptions
}

export const StyledWidgetLabel = styled.label<StyledWidgetProps>(
  ({ disabled, labelVisibility, theme }) => ({
    fontSize: theme.fontSizes.sm,
    color: disabled ? theme.colors.fadedText40 : theme.colors.bodyText,
    display:
      labelVisibility === LabelVisibilityOptions.Collapsed ? "none" : "flex",
    visibility:
      labelVisibility === LabelVisibilityOptions.Hidden ? "hidden" : "visible",
    marginBottom: theme.spacing.twoXS,
    height: "auto",
    minHeight: theme.fontSizes.xl,
    verticalAlign: "middle",
    flexDirection: "row",
    alignItems: "center",
  })
)

export const StyledWidgetLabelHelp = styled.div({
  display: "flex",
  flexDirection: "row",
  justifyContent: "flex-end",
  flex: 1,
})

export const StyledWidgetInstructions = styled.div(({ theme }) => ({
  fontSize: theme.fontSizes.twoSm,
  color: theme.colors.fadedText60,
  margin: theme.spacing.none,
  textAlign: "right",
  position: "absolute",
  bottom: 0,
  right: `calc(${theme.fontSizes.sm} * 0.5)`,
}))

export const StyledWidgetLabelHelpInline = styled.label(({ theme }) => ({
  marginLeft: theme.spacing.xs,
  position: "relative",
  display: "flex",
  flexDirection: "row",
}))


================================================
File: /frontend/lib/src/components/widgets/Button/Button.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import { Button as ButtonProto } from "@streamlit/lib/src/proto"

import Button, { Props } from "./Button"

vi.mock("@streamlit/lib/src/WidgetStateManager")

const sendBackMsg = vi.fn()

const getProps = (
  elementProps: Partial<ButtonProto> = {},
  widgetProps: Partial<Props> = {}
): Props => ({
  element: ButtonProto.create({
    id: "1",
    label: "Label",
    ...elementProps,
  }),
  width: 250,
  disabled: false,
  // @ts-expect-error
  widgetMgr: new WidgetStateManager(sendBackMsg),
  ...widgetProps,
})

describe("Button widget", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<Button {...props} />)

    const buttonWidget = screen.getByRole("button")
    expect(buttonWidget).toBeInTheDocument()
  })

  it("should have correct className and style", () => {
    const props = getProps()
    render(<Button {...props} />)

    const stButtonDiv = screen.getByTestId("stButton")

    expect(stButtonDiv).toHaveClass("stButton")
    expect(stButtonDiv).toHaveStyle(`width: ${props.width}px`)
  })

  it("should render a label within the button", () => {
    const props = getProps()
    render(<Button {...props} />)

    const buttonWidget = screen.getByRole("button", {
      name: `${props.element.label}`,
    })

    expect(buttonWidget).toBeInTheDocument()
  })

  describe("BaseButton props should work", () => {
    it("onClick prop", async () => {
      const user = userEvent.setup()
      const props = getProps()
      render(<Button {...props} />)

      const buttonWidget = screen.getByRole("button")
      await user.click(buttonWidget)

      expect(props.widgetMgr.setTriggerValue).toHaveBeenCalledWith(
        props.element,
        { fromUi: true },
        undefined
      )
    })

    it("passes fragmentId to onClick prop", async () => {
      const user = userEvent.setup()
      const props = getProps(undefined, {
        fragmentId: "myFragmentId",
      })
      render(<Button {...props} />)

      const buttonWidget = screen.getByRole("button")
      await user.click(buttonWidget)

      expect(props.widgetMgr.setTriggerValue).toHaveBeenCalledWith(
        props.element,
        { fromUi: true },
        "myFragmentId"
      )
    })

    it("can be disabled", () => {
      const props = getProps({}, { disabled: true })
      render(<Button {...props} />)

      const buttonWidget = screen.getByRole("button")

      expect(buttonWidget).toBeDisabled()
    })
  })

  it("does not use container width by default", () => {
    render(<Button {...getProps()}>Hello</Button>)

    const buttonWidget = screen.getByRole("button")
    expect(buttonWidget).toHaveStyle("width: auto")
  })

  it("passes useContainerWidth property without help correctly", () => {
    render(<Button {...getProps({ useContainerWidth: true })}>Hello</Button>)

    const buttonWidget = screen.getByRole("button")
    expect(buttonWidget).toHaveStyle("width: 100%")
  })

  it("passes useContainerWidth property with help correctly", () => {
    render(
      <Button {...getProps({ useContainerWidth: true, help: "mockHelpText" })}>
        Hello
      </Button>
    )

    const buttonWidget = screen.getByRole("button")
    expect(buttonWidget).toHaveStyle(`width: ${250}px`)
  })
})


================================================
File: /frontend/lib/src/components/widgets/Button/Button.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { Button as ButtonProto } from "@streamlit/lib/src/proto"
import BaseButton, {
  BaseButtonKind,
  BaseButtonSize,
  BaseButtonTooltip,
  DynamicButtonLabel,
} from "@streamlit/lib/src/components/shared/BaseButton"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"

export interface Props {
  disabled: boolean
  element: ButtonProto
  widgetMgr: WidgetStateManager
  width: number
  fragmentId?: string
}

function Button(props: Props): ReactElement {
  const { disabled, element, widgetMgr, width, fragmentId } = props
  const style = { width }

  let kind = BaseButtonKind.SECONDARY
  if (element.type === "primary") {
    kind = BaseButtonKind.PRIMARY
  } else if (element.type === "tertiary") {
    kind = BaseButtonKind.TERTIARY
  }

  // When useContainerWidth true & has help tooltip,
  // we need to pass the container width down to the button
  const fluidWidth = element.help ? width : true

  return (
    <div className="stButton" data-testid="stButton" style={style}>
      <BaseButtonTooltip help={element.help}>
        <BaseButton
          kind={kind}
          size={BaseButtonSize.SMALL}
          disabled={disabled}
          fluidWidth={element.useContainerWidth ? fluidWidth : false}
          onClick={() =>
            widgetMgr.setTriggerValue(element, { fromUi: true }, fragmentId)
          }
        >
          <DynamicButtonLabel icon={element.icon} label={element.label} />
        </BaseButton>
      </BaseButtonTooltip>
    </div>
  )
}

export default Button


================================================
File: /frontend/lib/src/components/widgets/Button/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Button"


================================================
File: /frontend/lib/src/components/widgets/ButtonGroup/ButtonGroup.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { act, screen, within } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  ButtonGroup as ButtonGroupProto,
  LabelVisibilityMessage as LabelVisibilityMessageProto,
} from "@streamlit/lib/src/proto"
import {
  BaseButtonKind,
  BaseButtonSize,
  DynamicButtonLabel,
} from "@streamlit/lib/src/components/shared/BaseButton"

import ButtonGroup, { getContentElement, Props } from "./ButtonGroup"

const materialIconNames = ["icon", "icon_2", "icon_3", "icon_4"]
const defaultSelectedIndex = 2

const expectHighlightStyle = (
  element: HTMLElement,
  should_exist = true
): void => {
  // eslint-disable-next-line vitest/valid-expect
  let expectCheck: any = expect(element)
  if (!should_exist) {
    expectCheck = expect.not
  }
  expectCheck.toHaveStyle("color: rgb(49, 51, 63);")
}

const getButtonGroupButtons = (): HTMLElement[] => {
  const buttonGroupWidget = screen.getByTestId("stButtonGroup")
  return within(buttonGroupWidget).getAllByRole("button")
}

// options where content is only a material icon; used by st.feedback
const materialIconOnlyOptions = [
  ButtonGroupProto.Option.create({
    contentIcon: `:material/${materialIconNames[0]}:`,
  }),
  ButtonGroupProto.Option.create({
    contentIcon: `:material/${materialIconNames[1]}:`,
    selectedContentIcon: ":material/icon2_selected:",
  }),
  ButtonGroupProto.Option.create({
    contentIcon: `:material/${materialIconNames[2]}:`,
  }),
  ButtonGroupProto.Option.create({
    contentIcon: `:material/${materialIconNames[3]}:`,
  }),
]

const options = [
  ButtonGroupProto.Option.create({
    content: `Some text: ${materialIconNames[0]}:`,
    contentIcon: "🔥",
  }),
  ButtonGroupProto.Option.create({
    content: `Some other text: ${materialIconNames[1]}:`,
    contentIcon: `:material/${materialIconNames[1]}:`,
  }),
]

const getProps = (
  elementProps: Partial<ButtonGroupProto> = {},
  widgetProps: Partial<Props> = {}
): Props => ({
  element: ButtonGroupProto.create({
    id: "1",
    clickMode: ButtonGroupProto.ClickMode.SINGLE_SELECT,
    default: [defaultSelectedIndex],
    disabled: false,
    label: "My ButtonGroup label",
    options: [...materialIconOnlyOptions, ...options],
    selectionVisualization:
      ButtonGroupProto.SelectionVisualization.ONLY_SELECTED,
    style: ButtonGroupProto.Style.BORDERLESS,
    ...elementProps,
  }),
  disabled: false,
  widgetMgr: new WidgetStateManager({
    sendRerunBackMsg: vi.fn(),
    formsDataChanged: vi.fn(),
  }),
  ...widgetProps,
})
const EXPECTED_BUTTONS_LENGTH = materialIconOnlyOptions.length + options.length

describe("ButtonGroup widget", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<ButtonGroup {...props} />)

    const buttonGroupWidget = screen.getByTestId("stButtonGroup")
    expect(buttonGroupWidget).toBeInTheDocument()
    expect(buttonGroupWidget).toHaveClass("stButtonGroup")
  })

  it("option-children with material-icon render correctly", () => {
    const props = getProps({ default: [], options: materialIconOnlyOptions })
    render(<ButtonGroup {...props} />)

    const buttons = getButtonGroupButtons()
    expect(buttons).toHaveLength(materialIconOnlyOptions.length)
    buttons.forEach((button, index) => {
      expect(button).toHaveAttribute("kind", "borderlessIcon")
      const icon = within(button).getByTestId("stIconMaterial")
      expect(icon.textContent).toContain(materialIconNames[index])
    })
  })

  it("option-children with contentIcon render correctly", () => {
    const props = getProps({
      default: [],
      options: options,
      style: ButtonGroupProto.Style.SEGMENTED_CONTROL,
    })
    render(<ButtonGroup {...props} />)

    const buttonGroupWidget = screen.getByTestId("stButtonGroup")
    const buttons = within(buttonGroupWidget).getAllByRole("button")
    expect(buttons).toHaveLength(options.length)

    let button = buttons[0]
    expect(button).toHaveAttribute("kind", "segmented_control")
    let text = within(button).getByTestId("stMarkdownContainer")
    expect(text.textContent).toContain(materialIconNames[0])
    let icon = within(button).getByTestId("stIconEmoji")
    expect(icon.textContent).toContain("🔥")

    button = buttons[1]
    expect(button).toHaveAttribute("kind", "segmented_control")
    text = within(button).getByTestId("stMarkdownContainer")
    expect(text.textContent).toContain(materialIconNames[1])
    icon = within(button).getByTestId("stIconMaterial")
    expect(icon.textContent).toContain(materialIconNames[1])
  })

  it("sets widget value on mount", () => {
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setIntArrayValue")

    render(<ButtonGroup {...props} />)
    expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledWith(
      props.element,
      props.element.default,
      {
        fromUi: false,
      },
      undefined
    )
  })

  describe("ButtonGroup props should work", () => {
    it("renders with empty options", () => {
      const props = getProps({ default: [], options: [] })
      render(<ButtonGroup {...props} />)

      const buttonGroup = screen.getByTestId("stButtonGroup")
      expect(buttonGroup).toBeInTheDocument()
      const buttons = within(buttonGroup).queryAllByRole("button")
      expect(buttons).toHaveLength(0)
    })

    it("onClick prop for single select", async () => {
      const user = userEvent.setup()
      const props = getProps()
      vi.spyOn(props.widgetMgr, "setIntArrayValue")

      render(<ButtonGroup {...props} />)

      const buttons = getButtonGroupButtons()
      expect(buttons).toHaveLength(EXPECTED_BUTTONS_LENGTH)
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledWith(
        props.element,
        props.element.default,
        { fromUi: false },
        undefined
      )
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledTimes(1)

      // click element at index 1 to select it
      await user.click(buttons[1])
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledWith(
        props.element,
        [1],
        { fromUi: true },
        undefined
      )
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledTimes(2)

      // click element at index 0 to select it
      await user.click(getButtonGroupButtons()[0])
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledWith(
        props.element,
        [0],
        { fromUi: true },
        undefined
      )
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledTimes(3)

      // click on same button does deselect it
      await user.click(getButtonGroupButtons()[0])
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledWith(
        props.element,
        [],
        { fromUi: true },
        undefined
      )
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledTimes(4)
    })

    it("onClick prop for multi select", async () => {
      const user = userEvent.setup()
      const props = getProps({
        clickMode: ButtonGroupProto.ClickMode.MULTI_SELECT,
      })
      vi.spyOn(props.widgetMgr, "setIntArrayValue")
      render(<ButtonGroup {...props} />)

      const buttons = getButtonGroupButtons()
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledWith(
        props.element,
        props.element.default,
        { fromUi: false },
        undefined
      )

      await user.click(buttons[1])
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledWith(
        props.element,
        // the 2 is default value
        [2, 1],
        { fromUi: true },
        undefined
      )

      await user.click(getButtonGroupButtons()[0])
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledWith(
        props.element,
        [2, 1, 0],
        { fromUi: true },
        undefined
      )

      // unselect the second button
      await user.click(getButtonGroupButtons()[1])
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledWith(
        props.element,
        [2, 0],
        { fromUi: true },
        undefined
      )
    })

    it("passes fragmentId to onClick prop", async () => {
      const user = userEvent.setup()
      const props = getProps(
        {},
        {
          fragmentId: "myFragmentId",
        }
      )
      vi.spyOn(props.widgetMgr, "setIntArrayValue")
      render(<ButtonGroup {...props} />)

      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledWith(
        props.element,
        props.element.default,
        { fromUi: false },
        "myFragmentId"
      )

      const button = getButtonGroupButtons()[0]
      await user.click(button)
      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledWith(
        props.element,
        [0],
        { fromUi: true },
        "myFragmentId"
      )
    })

    it("can be disabled", () => {
      const props = getProps({}, { disabled: true })
      render(<ButtonGroup {...props} />)

      const buttonGroupWidget = screen.getByTestId("stButtonGroup")
      const buttons = within(buttonGroupWidget).getAllByRole("button")
      expect(buttons).toHaveLength(EXPECTED_BUTTONS_LENGTH)
      buttons.forEach(button => {
        expect(button).toBeDisabled()
      })
    })

    it("sets widget value on update", () => {
      const props = getProps({ value: [3], setValue: true })
      vi.spyOn(props.widgetMgr, "setIntArrayValue")

      render(<ButtonGroup {...props} />)
      const buttons = getButtonGroupButtons()
      expectHighlightStyle(buttons[3])
      expectHighlightStyle(buttons[defaultSelectedIndex], false)

      expect(props.widgetMgr.setIntArrayValue).toHaveBeenCalledWith(
        props.element,
        props.element.default,
        {
          fromUi: false,
        },
        undefined
      )
    })

    it("renders correct pills button style", () => {
      const props = getProps({
        default: [],
        options: options,
        style: ButtonGroupProto.Style.PILLS,
      })
      render(<ButtonGroup {...props} />)

      const buttons = getButtonGroupButtons()
      expect(buttons).toHaveLength(options.length)
      buttons.forEach(button => {
        expect(button).toHaveAttribute("kind", "pills")
      })
    })

    it("renders correct segmented control button style", () => {
      const props = getProps({
        default: [],
        options: options,
        style: ButtonGroupProto.Style.SEGMENTED_CONTROL,
      })
      render(<ButtonGroup {...props} />)

      const buttons = getButtonGroupButtons()
      expect(buttons).toHaveLength(options.length)
      buttons.forEach(button => {
        expect(button).toHaveAttribute("kind", "segmented_control")
      })
    })

    it("renders a label", () => {
      const props = getProps()
      render(<ButtonGroup {...props} />)

      const widgetLabel = screen.queryByText(`${props.element.label}`)
      expect(widgetLabel).toBeInTheDocument()
    })

    it("passes labelVisibility prop correctly when hidden", () => {
      const props = getProps({
        labelVisibility: {
          value: LabelVisibilityMessageProto.LabelVisibilityOptions.HIDDEN,
        },
      })
      render(<ButtonGroup {...props} />)
      expect(screen.getByTestId("stWidgetLabel")).toHaveStyle(
        "visibility: hidden"
      )
    })

    it("passes labelVisibility prop correctly when collapsed", () => {
      const props = getProps({
        labelVisibility: {
          value: LabelVisibilityMessageProto.LabelVisibilityOptions.COLLAPSED,
        },
      })
      render(<ButtonGroup {...props} />)
      expect(screen.getByTestId("stWidgetLabel")).toHaveStyle("display: none")
    })

    it("renders help prop correctly", async () => {
      const user = userEvent.setup()
      const props = getProps({
        help: "help text",
      })
      render(<ButtonGroup {...props} />)
      const tooltip = screen.getByTestId("stTooltipHoverTarget")
      expect(tooltip).toBeInTheDocument()

      await user.hover(tooltip)
      const helpText = await screen.findByText("help text")
      expect(helpText).toBeInTheDocument()
    })

    describe("visualizes selection behavior", () => {
      // eslint-disable-next-line vitest/expect-expect
      it("visualize only selected option", async () => {
        const user = userEvent.setup()
        const props = getProps({
          selectionVisualization:
            ButtonGroupProto.SelectionVisualization.ONLY_SELECTED,
        })
        render(<ButtonGroup {...props} />)

        await user.click(getButtonGroupButtons()[0])
        const buttons = getButtonGroupButtons()
        expectHighlightStyle(buttons[0])
        expectHighlightStyle(buttons[1], false)
        expectHighlightStyle(buttons[2], false)
      })

      // eslint-disable-next-line vitest/expect-expect
      it("visualizes all up to the selected option", async () => {
        const user = userEvent.setup()
        const props = getProps({
          selectionVisualization:
            ButtonGroupProto.SelectionVisualization.ALL_UP_TO_SELECTED,
        })
        render(<ButtonGroup {...props} />)

        const buttonGroupWidget = screen.getByTestId("stButtonGroup")
        const buttons = within(buttonGroupWidget).getAllByRole("button")
        const buttonToClick = buttons[2]
        await user.click(buttonToClick)
        expectHighlightStyle(buttonToClick)
        expectHighlightStyle(buttons[0])
        // the second button has selectedContent set, so it should not be highlighted visually
        expectHighlightStyle(buttons[1], false)
        expectHighlightStyle(buttons[3], false)
      })

      // eslint-disable-next-line vitest/expect-expect
      it("has no default visualization when selected content present", async () => {
        const user = userEvent.setup()
        // used for example by feedback stars
        const disabledVisualizationOption = [
          ButtonGroupProto.Option.create({
            content: "Some text",
            selectedContent: "Some text selected",
          }),
          ButtonGroupProto.Option.create({
            content: "Some text 2",
            selectedContent: "Some text selected 2",
          }),
        ]
        const props = getProps({
          selectionVisualization:
            ButtonGroupProto.SelectionVisualization.ALL_UP_TO_SELECTED,
          options: disabledVisualizationOption,
        })
        render(<ButtonGroup {...props} />)

        const buttonGroupWidget = screen.getByTestId("stButtonGroup")
        const buttons = within(buttonGroupWidget).getAllByRole("button")
        const buttonToClick = buttons[1]
        await user.click(buttonToClick)
        expectHighlightStyle(buttonToClick, false)
        expectHighlightStyle(buttons[0], false)
      })
    })

    it("shows selection content when selected and available", async () => {
      const user = userEvent.setup()
      const props = getProps({ default: [], options: materialIconOnlyOptions })
      render(<ButtonGroup {...props} />)

      const buttons = getButtonGroupButtons()
      buttons.forEach((button, index) => {
        expect(button).toHaveAttribute("kind", "borderlessIcon")
        const icon = within(button).getByTestId("stIconMaterial")
        expect(icon.textContent).toContain(materialIconNames[index])
      })

      await user.click(buttons[1])
      expect(getButtonGroupButtons()[1].textContent).toContain(
        "icon_2_selected"
      )
    })

    it("shows bigger icons for borderless ButtonGroup", () => {
      const props = getProps({ default: [], options: materialIconOnlyOptions })
      render(<ButtonGroup {...props} />)
      const buttons = getButtonGroupButtons()
      buttons.forEach((button, index) => {
        expect(button).toHaveAttribute("kind", "borderlessIcon")
        const icon = within(button).getByTestId("stIconMaterial")
        expect(icon.textContent).toContain(materialIconNames[index])
        expect(icon).toHaveStyle("width: 1.25rem")
      })
    })

    it("shows smaller icons for non-borderless ButtonGroup", () => {
      const props = getProps({
        default: [],
        options: materialIconOnlyOptions,
        style: ButtonGroupProto.Style.SEGMENTED_CONTROL,
      })
      render(<ButtonGroup {...props} />)
      const buttons = getButtonGroupButtons()
      buttons.forEach((button, index) => {
        expect(button).toHaveAttribute("kind", "segmented_control")
        const icon = within(button).getByTestId("stIconMaterial")
        expect(icon.textContent).toContain(materialIconNames[index])
        expect(icon).toHaveStyle("width: 1rem")
      })
    })
  })

  it("resets its value when form is cleared", async () => {
    const user = userEvent.setup()
    // Create a widget in a clearOnSubmit form
    const props = getProps({
      formId: "form",
      clickMode: ButtonGroupProto.ClickMode.MULTI_SELECT,
    })
    props.widgetMgr.setFormSubmitBehaviors("form", true)

    vi.spyOn(props.widgetMgr, "setIntArrayValue")

    render(<ButtonGroup {...props} />)

    // Change the widget value
    // de-select default value
    await user.click(getButtonGroupButtons()[0])
    await user.click(getButtonGroupButtons()[1])
    let buttons = getButtonGroupButtons()
    expectHighlightStyle(buttons[0])
    // the second button has selectedContent set, so it should not be highlighted visually
    expectHighlightStyle(buttons[1], false)
    expectHighlightStyle(buttons[2], false)
    expectHighlightStyle(buttons[3], false)

    // "Submit" the form
    act(() => props.widgetMgr.submitForm("form", undefined))

    buttons = getButtonGroupButtons()
    // default option selected
    expectHighlightStyle(buttons[0], false)
    expectHighlightStyle(buttons[1], false)
    expectHighlightStyle(buttons[2])
    expect(props.widgetMgr.setIntArrayValue).toHaveBeenLastCalledWith(
      props.element,
      props.element.default,
      { fromUi: true },
      undefined
    )
  })
})

describe("ButtonGroup getContentElement", () => {
  it("tests element with content, icon and borderless-style", () => {
    const { element, kind, size } = getContentElement(
      "foo",
      "bar",
      ButtonGroupProto.Style.BORDERLESS
    )

    expect(element.type).toBe(DynamicButtonLabel)
    expect(element.props).toEqual({
      label: "foo",
      icon: "bar",
      iconSize: "lg",
    })
    expect(kind).toBe(BaseButtonKind.BORDERLESS_ICON)
    expect(size).toBe(BaseButtonSize.XSMALL)
  })

  it("tests element with content and no icon and borderless-style", () => {
    const { element, kind, size } = getContentElement(
      "foo",
      undefined,
      ButtonGroupProto.Style.BORDERLESS
    )

    expect(element.type).toBe(DynamicButtonLabel)
    expect(element.props).toEqual({
      label: "foo",
      icon: undefined,
      iconSize: "lg",
    })
    expect(kind).toBe(BaseButtonKind.BORDERLESS_ICON)
    expect(size).toBe(BaseButtonSize.XSMALL)
  })

  it("tests element with no content, an icon and borderless-style", () => {
    const { element, kind, size } = getContentElement(
      "",
      "foo",
      ButtonGroupProto.Style.BORDERLESS
    )

    expect(element.type).toBe(DynamicButtonLabel)
    expect(element.props).toEqual({
      label: "",
      icon: "foo",
      iconSize: "lg",
    })
    expect(kind).toBe(BaseButtonKind.BORDERLESS_ICON)
    expect(size).toBe(BaseButtonSize.XSMALL)
  })

  it("tests element with content, icon and non-borderless-style", () => {
    const { element, kind, size } = getContentElement(
      "foo",
      "bar",
      ButtonGroupProto.Style.PILLS
    )

    expect(element.type).toBe(DynamicButtonLabel)
    expect(element.props).toEqual({
      label: "foo",
      icon: "bar",
      iconSize: "base",
    })
    expect(kind).toBe(BaseButtonKind.PILLS)
    expect(size).toBe(BaseButtonSize.MEDIUM)
  })
})


================================================
File: /frontend/lib/src/components/widgets/ButtonGroup/ButtonGroup.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  forwardRef,
  memo,
  ReactElement,
  Ref,
  useCallback,
  useMemo,
} from "react"

import { useTheme } from "@emotion/react"
import { ButtonGroup as BasewebButtonGroup, MODE } from "baseui/button-group"

import BaseButton, {
  BaseButtonKind,
  BaseButtonSize,
  DynamicButtonLabel,
} from "@streamlit/lib/src/components/shared/BaseButton"
import { EmotionTheme } from "@streamlit/lib/src/theme"
import {
  ButtonGroup as ButtonGroupProto,
  LabelVisibilityMessage,
} from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  StyledWidgetLabelHelpInline,
  WidgetLabel,
} from "@streamlit/lib/src/components/widgets/BaseWidget"
import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"
import { labelVisibilityProtoValueToEnum } from "@streamlit/lib/src/util/utils"
import {
  useBasicWidgetState,
  ValueWithSource,
} from "@streamlit/lib/src/hooks/useBasicWidgetState"

export interface Props {
  disabled: boolean
  element: ButtonGroupProto
  widgetMgr: WidgetStateManager
  fragmentId?: string
}

function handleMultiSelection(
  index: number,
  currentSelection: number[]
): number[] {
  if (!currentSelection.includes(index)) {
    return [...currentSelection, index]
  }
  return currentSelection.filter(value => value !== index)
}

function handleSelection(
  mode: ButtonGroupProto.ClickMode,
  index: number,
  currentSelection?: number[]
): number[] {
  if (mode == ButtonGroupProto.ClickMode.MULTI_SELECT) {
    return handleMultiSelection(index, currentSelection ?? [])
  }

  // unselect if item is already selected
  return currentSelection?.includes(index) ? [] : [index]
}

function getSingleSelection(currentSelection: number[]): number {
  if (currentSelection.length === 0) {
    return -1
  }
  return currentSelection[0]
}

function syncWithWidgetManager(
  element: ButtonGroupProto,
  widgetMgr: WidgetStateManager,
  valueWithSource: ValueWithSource<ButtonGroupValue>,
  fragmentId?: string
): void {
  widgetMgr.setIntArrayValue(
    element,
    valueWithSource.value,
    { fromUi: valueWithSource.fromUi },
    fragmentId
  )
}

export function getContentElement(
  content: string,
  icon?: string,
  style?: ButtonGroupProto.Style
): { element: ReactElement; kind: BaseButtonKind; size: BaseButtonSize } {
  const kind =
    style === ButtonGroupProto.Style.PILLS
      ? BaseButtonKind.PILLS
      : style === ButtonGroupProto.Style.BORDERLESS
      ? BaseButtonKind.BORDERLESS_ICON
      : BaseButtonKind.SEGMENTED_CONTROL
  const size =
    style === ButtonGroupProto.Style.BORDERLESS
      ? BaseButtonSize.XSMALL
      : BaseButtonSize.MEDIUM

  const iconSize = style === ButtonGroupProto.Style.BORDERLESS ? "lg" : "base"

  return {
    element: (
      <DynamicButtonLabel icon={icon} label={content} iconSize={iconSize} />
    ),
    kind: kind,
    size: size,
  }
}

/**
 * Returns true if the element should be shown as selected (even though its technically not).
 * This is used, for example, to show all elements as selected that come before the actually selected element.
 *
 * @param selectionVisualization sets the visualization mode
 * @param clickMode either SINGLE_SELECT or MULTI_SELECT
 * @param selected list of selected indices. Since only SINGLE_SELECT is considered, this list will always have a length of 1.
 * @param index of the current element
 * @returns true if the element is the selected one, or if click_mode is SINGLE_SELECT and selectionVisualization is set to
 *  ALL_UP_TO_SELECTED and the index of the element is smaller than the index of the selected element, false otherwise.
 */
function showAsSelected(
  selectionVisualization: ButtonGroupProto.SelectionVisualization,
  clickMode: ButtonGroupProto.ClickMode,
  selected: number[],
  index: number
): boolean {
  if (selected.indexOf(index) > -1) {
    return true
  }

  if (
    clickMode !== ButtonGroupProto.ClickMode.SINGLE_SELECT ||
    selectionVisualization !==
      ButtonGroupProto.SelectionVisualization.ALL_UP_TO_SELECTED
  ) {
    return false
  }

  return selected.length > 0 && index < selected[0]
}

function getButtonKindAndSize(
  isVisuallySelected: boolean,
  buttonKind: BaseButtonKind
): BaseButtonKind {
  if (isVisuallySelected) {
    buttonKind = `${buttonKind}Active` as BaseButtonKind
  }

  return buttonKind
}

function getButtonGroupOverridesStyle(
  style: ButtonGroupProto.Style,
  spacing: EmotionTheme["spacing"]
): Record<string, any> {
  const baseStyle = { flexWrap: "wrap", maxWidth: "fit-content" }

  switch (style) {
    case ButtonGroupProto.Style.BORDERLESS:
      return {
        ...baseStyle,
        columnGap: spacing.threeXS,
        rowGap: spacing.threeXS,
      }
    case ButtonGroupProto.Style.PILLS:
      return {
        ...baseStyle,
        columnGap: spacing.twoXS,
        rowGap: spacing.twoXS,
      }
    case ButtonGroupProto.Style.SEGMENTED_CONTROL:
      return {
        ...baseStyle,
        columnGap: spacing.none,
        rowGap: spacing.twoXS,
        // Adding an empty pseudo-element after the last button in the group.
        // This will make buttons only as big as needed without stretching to the whole container width (aka let them 'hug' to the side)
        "::after": {
          content: "''",
          flex: 10000,
        },
      }
    default:
      return baseStyle
  }
}

function createOptionChild(
  option: ButtonGroupProto.IOption,
  index: number,
  selectionVisualization: ButtonGroupProto.SelectionVisualization,
  clickMode: ButtonGroupProto.ClickMode,
  selected: number[],
  style: ButtonGroupProto.Style
): React.FunctionComponent {
  const isVisuallySelected = showAsSelected(
    selectionVisualization,
    clickMode,
    selected,
    index
  )

  let content = option.content
  let icon = option.contentIcon
  if (isVisuallySelected) {
    content = option.selectedContent ? option.selectedContent : content
    icon = option.selectedContentIcon ? option.selectedContentIcon : icon
  }

  // we have to use forwardRef here because BasewebButtonGroup passes the ref down to its children
  // and we see a console.error otherwise
  return forwardRef(function BaseButtonGroup(
    props: any,
    _: Ref<BasewebButtonGroup>
  ): ReactElement {
    const { element, kind, size } = getContentElement(
      content ?? "",
      icon ?? undefined,
      style
    )
    const buttonKind = getButtonKindAndSize(
      !!(
        isVisuallySelected &&
        !option.selectedContent &&
        !option.selectedContentIcon
      ),
      kind
    )
    return (
      <BaseButton {...props} size={size} kind={buttonKind}>
        {element}
      </BaseButton>
    )
  })
}

type ButtonGroupValue = number[]

function getInitialValue(
  widgetMgr: WidgetStateManager,
  element: ButtonGroupProto
): ButtonGroupValue | undefined {
  return widgetMgr.getIntArrayValue(element)
}

function getDefaultStateFromProto(
  element: ButtonGroupProto
): ButtonGroupValue {
  return element.default ?? null
}

function getCurrStateFromProto(element: ButtonGroupProto): ButtonGroupValue {
  return element.value ?? null
}

function ButtonGroup(props: Readonly<Props>): ReactElement {
  const { disabled, element, fragmentId, widgetMgr } = props
  const {
    clickMode,
    options,
    selectionVisualization,
    style,
    label,
    labelVisibility,
    help,
  } = element
  const theme: EmotionTheme = useTheme()

  const [value, setValueWithSource] = useBasicWidgetState<
    ButtonGroupValue,
    ButtonGroupProto
  >({
    getStateFromWidgetMgr: getInitialValue,
    getDefaultStateFromProto,
    getCurrStateFromProto,
    updateWidgetMgrState: syncWithWidgetManager,
    element,
    widgetMgr,
    fragmentId,
  })

  const onClick = (
    _event: React.SyntheticEvent<HTMLButtonElement>,
    index: number
  ): void => {
    const newSelected = handleSelection(clickMode, index, value)
    setValueWithSource({ value: newSelected, fromUi: true })
  }

  let mode = undefined
  if (clickMode === ButtonGroupProto.ClickMode.SINGLE_SELECT) {
    mode = MODE.radio
  } else if (clickMode === ButtonGroupProto.ClickMode.MULTI_SELECT) {
    mode = MODE.checkbox
  }

  const optionElements = useMemo(
    () =>
      options.map((option, index) => {
        const Element = createOptionChild(
          option,
          index,
          selectionVisualization,
          clickMode,
          value,
          style
        )
        return <Element key={`${option.content}-${index}`} />
      }),
    [clickMode, options, selectionVisualization, style, value]
  )

  return (
    <div className="stButtonGroup" data-testid="stButtonGroup">
      <WidgetLabel
        label={label}
        disabled={disabled}
        labelVisibility={labelVisibilityProtoValueToEnum(
          labelVisibility?.value ??
            LabelVisibilityMessage.LabelVisibilityOptions.COLLAPSED
        )}
      >
        {help && (
          <StyledWidgetLabelHelpInline>
            <TooltipIcon content={help} placement={Placement.TOP} />
          </StyledWidgetLabelHelpInline>
        )}
      </WidgetLabel>
      <BasewebButtonGroup
        disabled={disabled}
        mode={mode}
        onClick={onClick}
        selected={
          clickMode === ButtonGroupProto.ClickMode.MULTI_SELECT
            ? value
            : getSingleSelection(value)
        }
        overrides={{
          Root: {
            style: useCallback(
              () => getButtonGroupOverridesStyle(style, theme.spacing),
              [style, theme.spacing]
            ),
          },
        }}
      >
        {optionElements}
      </BasewebButtonGroup>
    </div>
  )
}

export default memo(ButtonGroup)


================================================
File: /frontend/lib/src/components/widgets/ButtonGroup/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./ButtonGroup"


================================================
File: /frontend/lib/src/components/widgets/CameraInput/CameraInput.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import createFetchMock from "vitest-fetch-mock"

import { render } from "@streamlit/lib/src/test_util"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  CameraInput as CameraInputProto,
  FileURLs as FileURLsProto,
  LabelVisibilityMessage as LabelVisibilityMessageProto,
} from "@streamlit/lib/src/proto"

import CameraInput, { Props } from "./CameraInput"

vi.mock("react-webcam")
const fetchMocker = createFetchMock(vi)

const getProps = (
  elementProps: Partial<CameraInputProto> = {},
  props: Partial<Props> = {}
): Props => {
  return {
    element: CameraInputProto.create({
      id: "id",
      label: "test_label",
      help: "help",
      formId: "",
      ...elementProps,
    }),
    width: 0,
    disabled: false,
    widgetMgr: new WidgetStateManager({
      sendRerunBackMsg: vi.fn(),
      formsDataChanged: vi.fn(),
    }),
    // @ts-expect-error
    uploadClient: {
      uploadFile: vi.fn().mockImplementation(() => {
        return Promise.resolve()
      }),
      fetchFileURLs: vi.fn().mockImplementation((acceptedFiles: File[]) => {
        return Promise.resolve(
          acceptedFiles.map(file => {
            return new FileURLsProto({
              fileId: file.name,
              uploadUrl: file.name,
              deleteUrl: file.name,
            })
          })
        )
      }),
      deleteFile: vi.fn(),
    },
    ...props,
  }
}

describe("CameraInput widget", () => {
  fetchMocker.enableMocks()
  it("renders without crashing", () => {
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setFileUploaderStateValue")
    render(<CameraInput {...props} />)
    const cameraInput = screen.getByTestId("stCameraInput")
    expect(cameraInput).toBeInTheDocument()
    expect(cameraInput).toHaveClass("stCameraInput")

    expect(screen.getByText("Take Photo")).toBeInTheDocument()
    // WidgetStateManager should have been called on mounting
    expect(props.widgetMgr.setFileUploaderStateValue).toHaveBeenCalledTimes(1)
  })

  it("shows a label", () => {
    const props = getProps()
    render(<CameraInput {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveTextContent(
      props.element.label
    )
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when hidden", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.HIDDEN,
      },
    })
    render(<CameraInput {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle(
      "visibility: hidden"
    )
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when collapsed", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.COLLAPSED,
      },
    })
    render(<CameraInput {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle("display: none")
  })
})


================================================
File: /frontend/lib/src/components/widgets/CameraInput/CameraInput.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { X } from "@emotion-icons/open-iconic"
import axios from "axios"
import isEqual from "lodash/isEqual"

import {
  CameraInput as CameraInputProto,
  FileUploaderState as FileUploaderStateProto,
  FileURLs as FileURLsProto,
  IFileURLs,
  UploadedFileInfo as UploadedFileInfoProto,
} from "@streamlit/lib/src/proto"
import Icon from "@streamlit/lib/src/components/shared/Icon"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"
import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import {
  StyledWidgetLabelHelp,
  WidgetLabel,
} from "@streamlit/lib/src/components/widgets/BaseWidget"
import { FormClearHelper } from "@streamlit/lib/src/components/widgets/Form"
import { FileUploadClient } from "@streamlit/lib/src/FileUploadClient"
import { logError } from "@streamlit/lib/src/util/log"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  isNullOrUndefined,
  labelVisibilityProtoValueToEnum,
} from "@streamlit/lib/src/util/utils"
import {
  UploadedStatus,
  UploadFileInfo,
  UploadingStatus,
} from "@streamlit/lib/src/components/widgets/FileUploader/UploadFileInfo"

import CameraInputButton from "./CameraInputButton"
import { FacingMode } from "./SwitchFacingModeButton"
import {
  StyledBox,
  StyledCameraInput,
  StyledImg,
  StyledSpan,
} from "./styled-components"
import WebcamComponent, { WebcamPermission } from "./WebcamComponent"

export interface Props {
  element: CameraInputProto
  widgetMgr: WidgetStateManager
  uploadClient: FileUploadClient
  disabled: boolean
  width: number
  fragmentId?: string
  // Allow for unit testing
  testOverride?: WebcamPermission
}

type FileUploaderStatus =
  | "ready" // FileUploader can upload or delete files
  | "updating" // at least one file is being uploaded or deleted

export interface State {
  /**
   * Base64-encoded image data of the current frame from the camera.
   */
  imgSrc: string | null

  shutter: boolean

  minShutterEffectPassed: boolean
  /**
   * List of files (snapshots) captured by the user.
   * Should contain exact one element if the user has taken a snapshot.
   */
  files: UploadFileInfo[]

  /**
   * Represents whether the component is in clear photo mode,
   * when snapshot removed and new Webcam component is not shown yet.
   * Time interval between `Clear Photo` button clicked and access to Webcam received again
   */
  clearPhotoInProgress: boolean

  /**
   * User facing mode for mobile devices. If `user`, the camera will be facing the user (front camera).
   * If `environment`, the camera will be facing the environment (back camera).
   */
  facingMode: FacingMode
}

const MIN_SHUTTER_EFFECT_TIME_MS = 150

class CameraInput extends React.PureComponent<Props, State> {
  private localFileIdCounter = 1

  private RESTORED_FROM_WIDGET_STRING = "RESTORED_FROM_WIDGET"

  private readonly formClearHelper = new FormClearHelper()

  public constructor(props: Props) {
    super(props)
    this.state = this.initialValue
  }

  private getProgress = (): number | null | undefined => {
    if (
      this.state.files.length > 0 &&
      this.state.files[this.state.files.length - 1].status.type === "uploading"
    ) {
      const status = this.state.files[this.state.files.length - 1]
        .status as UploadingStatus
      return status.progress
    }
    return undefined
  }

  private setClearPhotoInProgress = (clearPhotoInProgress: boolean): void => {
    this.setState({ clearPhotoInProgress })
  }

  private setFacingMode = (): void => {
    this.setState(prevState => ({
      facingMode:
        prevState.facingMode === FacingMode.USER
          ? FacingMode.ENVIRONMENT
          : FacingMode.USER,
    }))
  }

  private handleCapture = (imgSrc: string | null): Promise<void> => {
    if (imgSrc === null) {
      return Promise.resolve()
    }

    this.setState({
      imgSrc,
      shutter: true,
      minShutterEffectPassed: false,
    })

    const delay = (t: number): Promise<ReturnType<typeof setTimeout>> =>
      new Promise(resolve => setTimeout(resolve, t))

    return urltoFile(
      imgSrc,
      `camera-input-${new Date().toISOString().replace(/:/g, "_")}.jpg`
    )
      .then(file =>
        this.props.uploadClient
          .fetchFileURLs([file])
          .then(fileURLsArray => ({ file: file, fileUrls: fileURLsArray[0] }))
      )
      .then(({ file, fileUrls }) => this.uploadFile(fileUrls, file))
      .then(() => delay(MIN_SHUTTER_EFFECT_TIME_MS))
      .then(() => {
        this.setState((prevState, _) => {
          return {
            imgSrc,
            shutter: prevState.shutter,
            minShutterEffectPassed: true,
          }
        })
      })
      .catch(err => {
        logError(err)
      })
  }

  private removeCapture = (): void => {
    if (this.state.files.length === 0) {
      return
    }

    this.state.files.forEach(file => this.deleteFile(file.id))

    this.setState({
      imgSrc: null,
      clearPhotoInProgress: true,
    })
  }

  get initialValue(): State {
    const emptyState = {
      files: [],
      imgSrc: null,
      shutter: false,
      minShutterEffectPassed: true,
      clearPhotoInProgress: false,
      facingMode: FacingMode.USER,
    }
    const { widgetMgr, element } = this.props

    const widgetValue = widgetMgr.getFileUploaderStateValue(element)

    if (isNullOrUndefined(widgetValue)) {
      return emptyState
    }

    const { uploadedFileInfo } = widgetValue
    if (isNullOrUndefined(uploadedFileInfo) || uploadedFileInfo.length === 0) {
      return emptyState
    }

    return {
      files: uploadedFileInfo.map(f => {
        const name = f.name as string
        const size = f.size as number

        const fileId = f.fileId as string
        const fileUrls = f.fileUrls as FileURLsProto

        return new UploadFileInfo(name, size, this.nextLocalFileId(), {
          type: "uploaded",
          fileId,
          fileUrls,
        })
      }),
      imgSrc:
        uploadedFileInfo.length === 0 ? "" : this.RESTORED_FROM_WIDGET_STRING,
      shutter: false,
      minShutterEffectPassed: false,
      clearPhotoInProgress: false,
      facingMode: FacingMode.USER,
    }
  }

  public componentWillUnmount(): void {
    this.formClearHelper.disconnect()
  }

  /**
   * Return the FileUploader's current status, which is derived from
   * its state.
   */
  public get status(): FileUploaderStatus {
    const isFileUpdating = (file: UploadFileInfo): boolean =>
      file.status.type === "uploading"

    // If any of our files is Uploading or Deleting, then we're currently
    // updating.
    if (this.state.files.some(isFileUpdating)) {
      return "updating"
    }

    return "ready"
  }

  public componentDidUpdate = (): void => {
    // If our status is not "ready", then we have uploads in progress.
    // We won't submit a new widgetValue until all uploads have resolved.
    if (this.status !== "ready") {
      return
    }

    // If we have had no completed uploads, our widgetValue will be
    // undefined, and we can early-out of the state update.
    const newWidgetValue = this.createWidgetValue()

    const { element, widgetMgr, fragmentId } = this.props

    // Maybe send a widgetValue update to the widgetStateManager.
    const prevWidgetValue = widgetMgr.getFileUploaderStateValue(element)
    if (!isEqual(newWidgetValue, prevWidgetValue)) {
      widgetMgr.setFileUploaderStateValue(
        element,
        newWidgetValue,
        {
          fromUi: true,
        },
        fragmentId
      )
    }
  }

  public componentDidMount(): void {
    const newWidgetValue = this.createWidgetValue()
    const { element, widgetMgr, fragmentId } = this.props

    // Set the state value on mount, to avoid triggering an extra rerun after
    // the first rerun.
    // We use same primitives as in file uploader widget,
    // since simanticly camera_input is just a special case of file uploader.
    const prevWidgetValue = widgetMgr.getFileUploaderStateValue(element)
    if (prevWidgetValue === undefined) {
      widgetMgr.setFileUploaderStateValue(
        element,
        newWidgetValue,
        {
          fromUi: false,
        },
        fragmentId
      )
    }
  }

  private createWidgetValue(): FileUploaderStateProto {
    const uploadedFileInfo: UploadedFileInfoProto[] = this.state.files
      .filter(f => f.status.type === "uploaded")
      .map(f => {
        const { name, size, status } = f
        return new UploadedFileInfoProto({
          fileId: (status as UploadedStatus).fileId,
          fileUrls: (status as UploadedStatus).fileUrls,
          name,
          size,
        })
      })

    return new FileUploaderStateProto({ uploadedFileInfo })
  }

  /**
   * If we're part of a clear_on_submit form, this will be called when our
   * form is submitted. Restore our default value and update the WidgetManager.
   */
  private onFormCleared = (): void => {
    this.setState({ files: [] }, () => {
      const newWidgetValue = this.createWidgetValue()
      if (isNullOrUndefined(newWidgetValue)) {
        return
      }

      this.setState({
        imgSrc: null,
      })

      const { widgetMgr, element, fragmentId } = this.props
      widgetMgr.setFileUploaderStateValue(
        element,
        newWidgetValue,
        { fromUi: true },
        fragmentId
      )
    })
  }

  public render(): React.ReactNode {
    const { element, widgetMgr, disabled, width } = this.props

    // Manage our form-clear event handler.
    this.formClearHelper.manageFormClearListener(
      widgetMgr,
      element.formId,
      this.onFormCleared
    )

    return (
      <StyledCameraInput className="stCameraInput" data-testid="stCameraInput">
        <WidgetLabel
          label={element.label}
          disabled={disabled}
          labelVisibility={labelVisibilityProtoValueToEnum(
            element.labelVisibility?.value
          )}
        >
          {element.help && (
            <StyledWidgetLabelHelp>
              <TooltipIcon
                content={element.help}
                placement={Placement.TOP_RIGHT}
              />
            </StyledWidgetLabelHelp>
          )}
        </WidgetLabel>
        {this.state.imgSrc ? (
          <>
            <StyledBox width={width}>
              {this.state.imgSrc !== this.RESTORED_FROM_WIDGET_STRING && (
                <StyledImg
                  src={this.state.imgSrc}
                  alt="Snapshot"
                  opacity={
                    this.state.shutter || !this.state.minShutterEffectPassed
                      ? "50%"
                      : "100%"
                  }
                  width={width}
                  height={(width * 9) / 16}
                />
              )}
            </StyledBox>
            <CameraInputButton
              onClick={this.removeCapture}
              progress={this.getProgress()}
              disabled={!!this.getProgress() || disabled}
            >
              {this.getProgress() ? (
                "Uploading..."
              ) : (
                <StyledSpan>
                  <Icon content={X} margin="0 xs 0 0" size="sm" /> Clear photo
                </StyledSpan>
              )}
            </CameraInputButton>
          </>
        ) : (
          <WebcamComponent
            handleCapture={this.handleCapture}
            width={width}
            disabled={disabled}
            clearPhotoInProgress={this.state.clearPhotoInProgress}
            setClearPhotoInProgress={this.setClearPhotoInProgress}
            facingMode={this.state.facingMode}
            setFacingMode={this.setFacingMode}
            testOverride={this.props.testOverride}
          />
        )}
      </StyledCameraInput>
    )
  }

  private nextLocalFileId(): number {
    return this.localFileIdCounter++
  }

  /**
   * Delete the file with the given ID:
   * - Cancel the file upload if it's in progress
   * - Remove the fileID from our local state
   * We don't actually tell the server to delete the file. It will garbage
   * collect it.
   */
  public deleteFile = (fileId: number): void => {
    const file = this.getFile(fileId)
    if (isNullOrUndefined(file)) {
      return
    }

    if (file.status.type === "uploading") {
      // The file hasn't been uploaded. Let's cancel the request.
      // However, it may have been received by the server so we'll still
      // send out a request to delete.
      file.status.cancelToken.cancel()
    }

    if (file.status.type === "uploaded" && file.status.fileUrls.deleteUrl) {
      this.props.uploadClient.deleteFile(file.status.fileUrls.deleteUrl)
    }
    this.removeFile(fileId)
  }

  /** Append the given file to `state.files`. */
  private addFile = (file: UploadFileInfo): void => {
    this.setState(state => ({ files: [...state.files, file] }))
  }

  /** Remove the file with the given ID from `state.files`. */
  private removeFile = (idToRemove: number): void => {
    this.setState(state => ({
      files: state.files.filter(file => file.id !== idToRemove),
    }))
  }

  /**
   * Return the file with the given ID, if one exists.
   */
  private getFile = (fileId: number): UploadFileInfo | undefined => {
    return this.state.files.find(file => file.id === fileId)
  }

  /** Replace the file with the given id in `state.files`. */
  private updateFile = (curFileId: number, newFile: UploadFileInfo): void => {
    this.setState(curState => {
      return {
        files: curState.files.map(file =>
          file.id === curFileId ? newFile : file
        ),
      }
    })
  }

  /**
   * Called when an upload has completed. Updates the file's status, and
   * assigns it the new file ID returned from the server.
   */
  private onUploadComplete = (
    localFileId: number,
    fileUrls: IFileURLs
  ): void => {
    this.setState(() => ({
      shutter: false,
    }))

    const curFile = this.getFile(localFileId)
    if (isNullOrUndefined(curFile) || curFile.status.type !== "uploading") {
      // The file may have been canceled right before the upload
      // completed. In this case, we just bail.
      return
    }

    this.updateFile(
      curFile.id,
      curFile.setStatus({
        type: "uploaded",
        fileId: fileUrls.fileId as string,
        fileUrls,
      })
    )
  }

  /**
   * Callback for file upload progress. Updates a single file's local `progress`
   * state.
   */
  private onUploadProgress = (event: ProgressEvent, fileId: number): void => {
    const file = this.getFile(fileId)
    if (isNullOrUndefined(file) || file.status.type !== "uploading") {
      return
    }

    const newProgress = Math.round((event.loaded * 100) / event.total)
    if (file.status.progress === newProgress) {
      return
    }

    // Update file.progress
    this.updateFile(
      fileId,
      file.setStatus({
        type: "uploading",
        cancelToken: file.status.cancelToken,
        progress: newProgress,
      })
    )
  }

  /**
   * Clear files and errors, and reset the widget to its READY state.
   */
  private reset = (): void => {
    this.setState({ files: [], imgSrc: null })
  }

  public uploadFile = (fileURLs: IFileURLs, file: File): void => {
    // Create an UploadFileInfo for this file and add it to our state.
    const cancelToken = axios.CancelToken.source()
    const uploadingFileInfo = new UploadFileInfo(
      file.name,
      file.size,
      this.nextLocalFileId(),
      {
        type: "uploading",
        cancelToken,
        progress: 1,
      }
    )
    this.addFile(uploadingFileInfo)

    this.props.uploadClient
      .uploadFile(
        this.props.element,
        fileURLs.uploadUrl as string,
        file,
        e => this.onUploadProgress(e, uploadingFileInfo.id),
        cancelToken.token
      )
      .then(() => this.onUploadComplete(uploadingFileInfo.id, fileURLs))
      .catch(err => {
        // If this was a cancel error, we don't show the user an error -
        // the cancellation was in response to an action they took.
        if (!axios.isCancel(err)) {
          this.updateFile(
            uploadingFileInfo.id,
            uploadingFileInfo.setStatus({
              type: "error",
              errorMessage: err ? err.toString() : "Unknown error",
            })
          )
        }
      })
  }
}

function urltoFile(url: string, filename: string): Promise<File> {
  return fetch(url)
    .then(res => res.arrayBuffer())
    .then(buf => new File([buf], filename, { type: "image/jpeg" }))
}

export default CameraInput


================================================
File: /frontend/lib/src/components/widgets/CameraInput/CameraInputButton.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import CameraInputButton, { CameraInputButtonProps } from "./CameraInputButton"

const getProps = (
  props: Partial<CameraInputButtonProps> = {}
): CameraInputButtonProps => {
  return {
    onClick: vi.fn(),
    disabled: false,
    progress: 0,
    ...props,
  }
}

describe("Testing Camera Input Button", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<CameraInputButton {...props} />)
    expect(screen.getByTestId("stCameraInputButton")).toBeInTheDocument()
  })

  it("plumbs progress properly", () => {
    const props = getProps({ progress: 50 })

    render(<CameraInputButton {...props} />)

    const progress = screen.getByRole("progressbar")
    expect(progress).toHaveAttribute("aria-valuenow", "50")
  })
})


================================================
File: /frontend/lib/src/components/widgets/CameraInput/CameraInputButton.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { MouseEvent, ReactElement, ReactNode } from "react"

import ProgressBar, {
  Size as ProgressBarSize,
} from "@streamlit/lib/src/components/shared/ProgressBar"

import {
  StyledCameraInputBaseButton,
  StyledProgressBar,
} from "./styled-components"

export interface CameraInputButtonProps {
  onClick?: (event: MouseEvent<HTMLButtonElement>) => any
  disabled?: boolean
  progress?: number | null
  children?: ReactNode
}

function CameraInputButton({
  disabled,
  onClick,
  children,
  progress,
}: CameraInputButtonProps): ReactElement {
  return (
    <StyledCameraInputBaseButton
      disabled={disabled || false}
      onClick={onClick || (() => {})}
      progress={progress || null}
      data-testid="stCameraInputButton"
    >
      {children}
      {progress && (
        <StyledProgressBar>
          <ProgressBar
            value={progress}
            size={ProgressBarSize.EXTRASMALL}
            overrides={{
              Bar: {
                style: {
                  borderTopLeftRadius: 0,
                  borderTopRightRadius: 0,
                },
              },
              BarProgress: {
                style: {
                  borderTopLeftRadius: 0,
                  borderTopRightRadius: 0,
                },
              },
              BarContainer: {
                style: {
                  borderTopLeftRadius: 0,
                  borderTopRightRadius: 0,
                },
              },
            }}
          />
        </StyledProgressBar>
      )}
    </StyledCameraInputBaseButton>
  )
}

export default CameraInputButton


================================================
File: /frontend/lib/src/components/widgets/CameraInput/SwitchFacingModeButton.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { SwitchCamera } from "@emotion-icons/material-rounded"

import BaseButton, {
  BaseButtonKind,
} from "@streamlit/lib/src/components/shared/BaseButton"
import Icon from "@streamlit/lib/src/components/shared/Icon"
import Tooltip, {
  Placement,
} from "@streamlit/lib/src/components/shared/Tooltip"
import themeColors from "@streamlit/lib/src/theme/emotionBaseTheme/themeColors"

import { StyledSwitchFacingModeButton } from "./styled-components"

export enum FacingMode {
  USER = "user",
  ENVIRONMENT = "environment",
}

export interface SwitchFacingModeButtonProps {
  switchFacingMode: () => void
}

const SwitchFacingModeButton = ({
  switchFacingMode,
}: SwitchFacingModeButtonProps): ReactElement => {
  return (
    <StyledSwitchFacingModeButton data-testid="stCameraInputSwitchButton">
      <Tooltip content="Switch camera" placement={Placement.TOP_RIGHT}>
        <BaseButton kind={BaseButtonKind.MINIMAL} onClick={switchFacingMode}>
          <Icon
            content={SwitchCamera}
            size="twoXL"
            color={themeColors.white}
          />
        </BaseButton>
      </Tooltip>
    </StyledSwitchFacingModeButton>
  )
}

export default SwitchFacingModeButton


================================================
File: /frontend/lib/src/components/widgets/CameraInput/WebcamComponent.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen, within } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"

import { FacingMode } from "./SwitchFacingModeButton"
import WebcamComponent, { Props, WebcamPermission } from "./WebcamComponent"

vi.mock("react-webcam")

vi.mock("react-device-detect", () => {
  return {
    isMobile: true,
  }
})

const getProps = (props: Partial<Props> = {}): Props => {
  return {
    handleCapture: vi.fn(),
    width: 500,
    disabled: false,
    setClearPhotoInProgress: vi.fn(),
    clearPhotoInProgress: false,
    facingMode: FacingMode.USER,
    setFacingMode: vi.fn(),
    testOverride: WebcamPermission.PENDING,
    ...props,
  }
}

describe("Test Webcam Component", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<WebcamComponent {...props} />)
    expect(
      screen.getByTestId("stCameraInputWebcamComponent")
    ).toBeInTheDocument()
  })

  it("renders ask permission screen when pending state", () => {
    const props = getProps()
    render(<WebcamComponent {...props} />)
    expect(
      screen.getByTestId("stCameraInputWebcamComponent")
    ).toBeInTheDocument()
    expect(
      screen.getByText("This app would like to use your camera.")
    ).toBeInTheDocument()
    expect(screen.getByRole("link")).toHaveTextContent(
      "Learn how to allow access."
    )
    // hidden style should be there and webcam should not show
    expect(screen.getByTestId("stCameraInputWebcamStyledBox")).toHaveAttribute(
      "hidden"
    )
  })

  it("renders ask permission screen when error state", () => {
    const props = getProps({ testOverride: WebcamPermission.ERROR })
    render(<WebcamComponent {...props} />)
    expect(
      screen.getByTestId("stCameraInputWebcamComponent")
    ).toBeInTheDocument()

    expect(
      screen.getByText("This app would like to use your camera.")
    ).toBeInTheDocument()
    expect(screen.getByRole("link")).toHaveTextContent(
      "Learn how to allow access."
    )
    // hidden style should be there and webcam should not show
    expect(screen.getByTestId("stCameraInputWebcamStyledBox")).toHaveAttribute(
      "hidden"
    )
  })

  it("does not render ask permission screen in success state", () => {
    const props = getProps({ testOverride: WebcamPermission.SUCCESS })
    render(<WebcamComponent {...props} />)
    expect(
      screen.getByTestId("stCameraInputWebcamComponent")
    ).toBeInTheDocument()

    // hidden style should not be there and webcam should show
    expect(
      screen.getByTestId("stCameraInputWebcamStyledBox")
    ).not.toHaveAttribute("hidden")
  })

  it("shows a SwitchFacingMode button", () => {
    const props = getProps({ testOverride: WebcamPermission.SUCCESS })
    render(<WebcamComponent {...props} />)
    expect(
      screen.getByTestId("stCameraInputWebcamComponent")
    ).toBeInTheDocument()
    expect(screen.getByTestId("stCameraInputSwitchButton")).toBeInTheDocument()
  })

  it("changes `facingMode` when SwitchFacingMode button clicked", async () => {
    const user = userEvent.setup()
    const props = getProps({ testOverride: WebcamPermission.SUCCESS })
    render(<WebcamComponent {...props} />)

    expect(screen.getByTestId("stCameraInputSwitchButton")).toBeInTheDocument()

    const switchButton = within(
      screen.getByTestId("stCameraInputSwitchButton")
    ).getByRole("button")

    await user.click(switchButton)

    expect(props.setFacingMode).toHaveBeenCalledTimes(1)
  })

  it("test handle capture function", async () => {
    const user = userEvent.setup()
    const props = getProps({ testOverride: WebcamPermission.SUCCESS })
    render(<WebcamComponent {...props} />)
    expect(
      screen.getByTestId("stCameraInputWebcamComponent")
    ).toBeInTheDocument()

    await user.click(screen.getByRole("button", { name: "Take Photo" }))

    expect(props.handleCapture).toHaveBeenCalled()
  })
})


================================================
File: /frontend/lib/src/components/widgets/CameraInput/WebcamComponent.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  ReactElement,
  useCallback,
  useEffect,
  useRef,
  useState,
} from "react"

import { Video } from "@emotion-icons/open-iconic"
import { useTheme } from "@emotion/react"
import { isMobile } from "react-device-detect"
import Webcam from "react-webcam"

import { debounce } from "@streamlit/lib/src/util/utils"
import Icon from "@streamlit/lib/src/components/shared/Icon"
import { EmotionTheme } from "@streamlit/lib/src/theme"
import themeColors from "@streamlit/lib/src/theme/emotionBaseTheme/themeColors"
import { CAMERA_PERMISSION_URL } from "@streamlit/lib/src/urls"

import CameraInputButton from "./CameraInputButton"
import SwitchFacingModeButton, { FacingMode } from "./SwitchFacingModeButton"
import {
  StyledBox,
  StyledCameraInput,
  StyledDescription,
  StyledLink,
} from "./styled-components"

export interface Props {
  handleCapture: (capturedPhoto: string | null) => void
  width: number
  disabled: boolean
  clearPhotoInProgress: boolean
  setClearPhotoInProgress: (clearPhotoInProgress: boolean) => void
  facingMode: FacingMode
  setFacingMode: () => void
  // Allow for unit testing
  testOverride?: WebcamPermission
}

export enum WebcamPermission {
  PENDING = "pending",
  SUCCESS = "success",
  ERROR = "error",
}

interface AskForCameraPermissionProps {
  width: number
}

export const AskForCameraPermission = ({
  width,
}: AskForCameraPermissionProps): ReactElement => {
  return (
    <StyledBox width={width}>
      <Icon size="threeXL" color={themeColors.gray60} content={Video} />
      <StyledDescription>
        This app would like to use your camera.
        <StyledLink
          href={CAMERA_PERMISSION_URL}
          rel="noopener noreferrer"
          target="_blank"
        >
          Learn how to allow access.
        </StyledLink>
      </StyledDescription>
    </StyledBox>
  )
}

const WebcamComponent = ({
  handleCapture,
  width,
  disabled,
  clearPhotoInProgress,
  setClearPhotoInProgress,
  facingMode,
  setFacingMode,
  testOverride,
}: Props): ReactElement => {
  const [webcamPermission, setWebcamPermissionState] = useState(
    testOverride || WebcamPermission.PENDING
  )
  const videoRef = useRef<Webcam>(null)

  const [debouncedWidth, setDebouncedWidth] = useState(width)

  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const memoizedSetDebouncedCallback = useCallback(
    debounce(1000, setDebouncedWidth),
    []
  )

  useEffect(() => {
    memoizedSetDebouncedCallback(width)
  }, [width, memoizedSetDebouncedCallback])

  function capture(): void {
    if (videoRef.current !== null) {
      const imageSrc = videoRef.current.getScreenshot()
      handleCapture(imageSrc)
    }
  }

  const theme: EmotionTheme = useTheme()

  return (
    <StyledCameraInput data-testid="stCameraInputWebcamComponent">
      {webcamPermission !== WebcamPermission.SUCCESS &&
      !disabled &&
      !clearPhotoInProgress ? (
        <AskForCameraPermission width={debouncedWidth} />
      ) : (
        isMobile && <SwitchFacingModeButton switchFacingMode={setFacingMode} />
      )}
      <StyledBox
        data-testid="stCameraInputWebcamStyledBox"
        hidden={
          webcamPermission !== WebcamPermission.SUCCESS &&
          !disabled &&
          !clearPhotoInProgress
        }
        width={debouncedWidth}
      >
        {!disabled && (
          <Webcam
            audio={false}
            ref={videoRef}
            screenshotFormat="image/jpeg"
            screenshotQuality={1}
            width={debouncedWidth}
            // We keep Aspect ratio of container always equal 16 / 9.
            // The aspect ration of video stream may be different depending on a camera.
            height={(debouncedWidth * 9) / 16}
            style={{
              borderRadius: `${theme.radii.default} ${theme.radii.default} 0 0`,
            }}
            onUserMediaError={() => {
              setWebcamPermissionState(WebcamPermission.ERROR)
            }}
            onUserMedia={() => {
              setWebcamPermissionState(WebcamPermission.SUCCESS)
              setClearPhotoInProgress(false)
            }}
            videoConstraints={{
              width: { ideal: debouncedWidth },
              facingMode,
            }}
          />
        )}
      </StyledBox>
      <CameraInputButton
        onClick={capture}
        disabled={
          webcamPermission !== WebcamPermission.SUCCESS ||
          disabled ||
          clearPhotoInProgress
        }
      >
        Take Photo
      </CameraInputButton>
    </StyledCameraInput>
  )
}

export default WebcamComponent


================================================
File: /frontend/lib/src/components/widgets/CameraInput/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./CameraInput"


================================================
File: /frontend/lib/src/components/widgets/CameraInput/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { MouseEvent, ReactNode } from "react"

import styled, { CSSObject } from "@emotion/styled"
import { transparentize } from "color2k"

import { EmotionTheme } from "@streamlit/lib/src/theme"

export interface CameraInputButtonProps {
  onClick?: (event: MouseEvent<HTMLButtonElement>) => any
  disabled?: boolean
  children: ReactNode
  progress?: number | null
}

enum Size {
  XSMALL = "xsmall",
  SMALL = "small",
  MEDIUM = "medium",
  LARGE = "large",
}

function getSizeStyle(size: Size, theme: EmotionTheme): CSSObject {
  switch (size) {
    case Size.XSMALL:
      return {
        padding: `${theme.spacing.twoXS} ${theme.spacing.sm}`,
        fontSize: theme.fontSizes.sm,
      }
    case Size.SMALL:
      return {
        padding: `${theme.spacing.twoXS} ${theme.spacing.md}`,
      }
    case Size.LARGE:
      return {
        padding: `${theme.spacing.md} ${theme.spacing.md}`,
      }
    default:
      return {
        padding: `${theme.spacing.xs} ${theme.spacing.md}`,
      }
  }
}

type RequiredCameraInputButtonProps = Required<CameraInputButtonProps>

export const StyledCameraInput = styled.div({
  // This is used to position the "Switch facing mode" button
  // with respect to the webcam block.
  position: "relative",
  overflow: "hidden",
  width: "100%",
  objectFit: "contain",
})

export interface StyledBoxProps {
  width: number
}

export const StyledBox = styled.div<StyledBoxProps>(({ theme, width }) => ({
  backgroundColor: theme.colors.secondaryBg,
  borderRadius: `${theme.radii.default} ${theme.radii.default} 0 0`,
  width: "100%",
  height: (width * 9) / 16,
  display: "flex",
  flexDirection: "column",
  justifyContent: "center",
  alignItems: "center",
}))

export const StyledDescription = styled.p(({ theme }) => ({
  marginTop: theme.spacing.sm,
  textAlign: "center",
}))

export interface StyledImgProps {
  opacity: string
}

export const StyledImg = styled.img<StyledImgProps>(({ theme, opacity }) => ({
  borderRadius: `${theme.radii.default} ${theme.radii.default} 0 0`,
  objectFit: "contain",
  opacity,
}))

export const StyledLink = styled.a(({ theme }) => ({
  color: theme.colors.primary,
  display: "block",
  textDecoration: "none",
}))

export const StyledSpan = styled.span({
  display: "flex",
  alignItems: "center",
})

export const StyledSwitchFacingModeButton = styled.div(({ theme }) => ({
  position: "absolute",
  top: theme.spacing.lg,
  right: theme.spacing.lg,
  zIndex: theme.zIndices.priority,
  color: theme.colors.fadedText40,
  mixBlendMode: "difference",
  opacity: 0.6,
}))

export const StyledWebcamWrapper = styled.div({
  display: "flex",
})

export const StyledProgressBar = styled.div({
  height: "fit-content",
  width: "100%",
  position: "absolute",
  bottom: 0,
})

export const StyledCameraInputBaseButton =
  styled.button<RequiredCameraInputButtonProps>(({ theme }) => ({
    position: "relative",
    display: "inline-flex",
    flexDirection: "column",
    alignItems: "center",
    justifyContent: "center",
    backgroundColor: theme.colors.lightenedBg05,
    border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
    borderRadius: `0 0 ${theme.radii.default} ${theme.radii.default}`,
    "&:hover": {
      borderColor: theme.colors.primary,
      color: theme.colors.primary,
    },
    "&:active": {
      color: theme.colors.white,
      borderColor: theme.colors.primary,
      backgroundColor: theme.colors.primary,
    },
    "&:focus:not(:active)": {
      borderColor: theme.colors.primary,
      color: theme.colors.primary,
    },
    "&:disabled, &:disabled:hover, &:disabled:active": {
      color: theme.colors.fadedText40,
    },
    fontWeight: theme.fontWeights.normal,
    padding: `${theme.spacing.xs} ${theme.spacing.md}`,
    margin: theme.spacing.none,
    lineHeight: theme.lineHeights.base,
    color: "inherit",
    width: "100%",
    userSelect: "none",
    "&:focus": {
      outline: "none",
    },
    "&:focus-visible": {
      boxShadow: `0 0 0 0.2rem ${transparentize(theme.colors.primary, 0.5)}`,
    },
    ...getSizeStyle(Size.MEDIUM, theme),
  }))


================================================
File: /frontend/lib/src/components/widgets/ChatInput/ChatInput.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { fireEvent, screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { ChatInput as ChatInputProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"

import ChatInput, { Props } from "./ChatInput"

const getProps = (
  elementProps: Partial<ChatInputProto> = {},
  widgetProps: Partial<Props> = {}
): Props => ({
  element: ChatInputProto.create({
    id: "123",
    placeholder: "Enter Text Here",
    disabled: false,
    default: "",
    ...elementProps,
  }),
  width: 300,
  disabled: false,
  widgetMgr: new WidgetStateManager({
    sendRerunBackMsg: vi.fn(),
    formsDataChanged: vi.fn(),
  }),
  ...widgetProps,
})

describe("ChatInput widget", () => {
  afterEach(() => {
    vi.restoreAllMocks()
  })

  it("renders without crashing", () => {
    const props = getProps()
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    expect(chatInput).toBeInTheDocument()
  })

  it("shows a placeholder", () => {
    const props = getProps()
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    expect(chatInput).toHaveAttribute("placeholder", props.element.placeholder)
  })

  it("sets the aria label to the placeholder", () => {
    const props = getProps()
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    expect(chatInput).toHaveAttribute("aria-label", props.element.placeholder)
  })

  it("sets the value intially to the element default", () => {
    const props = getProps()
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    expect(chatInput).toHaveTextContent(props.element.default)
  })

  it("sets the value when values are typed in", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    await user.type(chatInput, "Sample text")
    expect(chatInput).toHaveTextContent("Sample text")
  })

  it("does not increase text value when maxChars is set", async () => {
    const user = userEvent.setup()
    const props = getProps({ maxChars: 10 })
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    await user.type(chatInput, "1234567890")
    expect(chatInput).toHaveTextContent("1234567890")
    await user.type(chatInput, "1")
    expect(chatInput).toHaveTextContent("1234567890")
  })

  it("sends and resets the value on enter", async () => {
    const user = userEvent.setup()
    const props = getProps()
    const spy = vi.spyOn(props.widgetMgr, "setStringTriggerValue")
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    await user.type(chatInput, "1234567890{enter}")
    expect(spy).toHaveBeenCalledWith(
      props.element,
      "1234567890",
      {
        fromUi: true,
      },
      undefined
    )
    expect(chatInput).toHaveTextContent("")
  })

  it("ensures chat input has focus on submit by keyboard", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    await user.type(chatInput, "1234567890{enter}")
    expect(chatInput).toHaveFocus()
  })

  it("ensures chat input has focus on submit by button click", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    const chatButton = screen.getByTestId("stChatInputSubmitButton")
    await user.type(chatInput, "1234567890")
    await user.click(chatButton)
    expect(chatInput).toHaveFocus()
  })

  it("can set fragmentId when sending value", async () => {
    const user = userEvent.setup()
    const props = getProps(undefined, { fragmentId: "myFragmentId" })
    const spy = vi.spyOn(props.widgetMgr, "setStringTriggerValue")
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    await user.type(chatInput, "1234567890{enter}")
    expect(spy).toHaveBeenCalledWith(
      props.element,
      "1234567890",
      {
        fromUi: true,
      },
      "myFragmentId"
    )
  })

  it("will not send an empty value on enter if empty", async () => {
    const user = userEvent.setup()
    const props = getProps()
    const spy = vi.spyOn(props.widgetMgr, "setStringTriggerValue")
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    await user.type(chatInput, "{enter}")
    expect(spy).not.toHaveBeenCalledWith(props.element, "", {
      fromUi: true,
    })
    expect(chatInput).toHaveTextContent("")
  })

  it("will not show instructions when the text has changed", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    const instructions = screen.getByTestId("InputInstructions")
    expect(instructions).toHaveTextContent("")

    await user.type(chatInput, "1234567890")
    expect(instructions).toHaveTextContent("")
  })

  it("does not send/clear on shift + enter", async () => {
    const user = userEvent.setup()
    const props = getProps()
    const spy = vi.spyOn(props.widgetMgr, "setStringTriggerValue")
    render(<ChatInput {...props} />)
    const chatInput = screen.getByTestId("stChatInputTextArea")

    await user.type(chatInput, "1234567890")
    expect(chatInput).toHaveTextContent("1234567890")
    await user.type(chatInput, "{shift>}{enter}{/shift}")
    expect(chatInput).not.toHaveTextContent("")
    expect(spy).not.toHaveBeenCalled()
  })

  it("does not send/clear on ctrl + enter", async () => {
    const user = userEvent.setup()
    const props = getProps()
    const spy = vi.spyOn(props.widgetMgr, "setStringTriggerValue")
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    await user.type(chatInput, "1234567890")
    expect(chatInput).toHaveTextContent("1234567890")
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.keyDown(chatInput, { key: "Enter", ctrlKey: true })
    // We cannot test the value to be changed cause that is essentially a
    // change event.
    expect(chatInput).not.toHaveTextContent("")
    expect(spy).not.toHaveBeenCalled()
  })

  it("does not send/clear on meta + enter", async () => {
    const user = userEvent.setup()
    const props = getProps()
    const spy = vi.spyOn(props.widgetMgr, "setStringTriggerValue")
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    await user.type(chatInput, "1234567890")
    expect(chatInput).toHaveTextContent("1234567890")
    await user.type(chatInput, "{meta>}{enter}{/meta}")
    expect(chatInput).not.toHaveTextContent("")
    expect(spy).not.toHaveBeenCalled()
  })

  it("does sets the value if specified from protobuf to set it", () => {
    const props = getProps({ value: "12345", setValue: true })
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    expect(chatInput).toHaveTextContent("12345")
  })

  it("does not set the value if protobuf does not specify to set it", () => {
    const props = getProps({ value: "12345", setValue: false })
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    expect(chatInput).toHaveTextContent("")
  })

  it("disables the textarea and button", () => {
    const props = getProps({ disabled: true })
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    expect(chatInput).toBeDisabled()

    const button = screen.getByRole("button")
    expect(button).toBeDisabled()
  })

  it("not disable the textarea by default", () => {
    const props = getProps()
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    expect(chatInput).not.toBeDisabled()

    const button = screen.getByRole("button")
    expect(button).toBeDisabled()
  })

  it("disables the send button by default since there's no text", () => {
    const props = getProps()
    render(<ChatInput {...props} />)

    const button = screen.getByRole("button")
    expect(button).toBeDisabled()
  })

  it("enables the send button when text is set, disables it when removed", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<ChatInput {...props} />)

    const chatInput = screen.getByTestId("stChatInputTextArea")
    await user.type(chatInput, "Sample text")

    const button = screen.getByRole("button")
    expect(button).not.toBeDisabled()

    await user.clear(chatInput)
    // await user.type(chatInput, "")
    expect(button).toBeDisabled()
  })
})


================================================
File: /frontend/lib/src/components/widgets/ChatInput/ChatInput.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  ChangeEvent,
  KeyboardEvent,
  useEffect,
  useRef,
  useState,
} from "react"

import { useTheme } from "@emotion/react"
import { Send } from "@emotion-icons/material-rounded"
import { Textarea as UITextArea } from "baseui/textarea"

import { ChatInput as ChatInputProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import Icon from "@streamlit/lib/src/components/shared/Icon"
import InputInstructions from "@streamlit/lib/src/components/shared/InputInstructions/InputInstructions"
import { isEnterKeyPressed } from "@streamlit/lib/src/util/inputUtils"

import {
  StyledChatInput,
  StyledChatInputContainer,
  StyledInputInstructionsContainer,
  StyledSendIconButton,
  StyledSendIconButtonContainer,
} from "./styled-components"

export interface Props {
  disabled: boolean
  element: ChatInputProto
  widgetMgr: WidgetStateManager
  width: number
  fragmentId?: string
}

// We want to show easily that there's scrolling so we deliberately choose
// a half size.
const MAX_VISIBLE_NUM_LINES = 6.5
// Rounding errors can arbitrarily create scrollbars. We add a rounding offset
// to manage it better.
const ROUNDING_OFFSET = 1

function ChatInput({
  width,
  element,
  widgetMgr,
  fragmentId,
}: Props): React.ReactElement {
  const theme = useTheme()
  // True if the user-specified state.value has not yet been synced to the WidgetStateManager.
  const [dirty, setDirty] = useState(false)
  // The value specified by the user via the UI. If the user didn't touch this widget's UI, the default value is used.
  const [value, setValue] = useState(element.default)
  // The value of the height of the textarea. It depends on a variety of factors including the default height, and autogrowing
  const [scrollHeight, setScrollHeight] = useState(0)
  const chatInputRef = useRef<HTMLTextAreaElement>(null)
  const heightGuidance = useRef({ minHeight: 0, maxHeight: 0 })

  const getScrollHeight = (): number => {
    let scrollHeight = 0
    const { current: textarea } = chatInputRef
    if (textarea) {
      const placeholder = textarea.placeholder
      textarea.placeholder = ""
      textarea.style.height = "auto"
      scrollHeight = textarea.scrollHeight
      textarea.placeholder = placeholder
      textarea.style.height = ""
    }

    return scrollHeight
  }

  const handleSubmit = (): void => {
    // We want the chat input to always be in focus
    // even if the user clicks the submit button
    if (chatInputRef.current) {
      chatInputRef.current.focus()
    }

    if (!value) {
      return
    }

    widgetMgr.setStringTriggerValue(
      element,
      value,
      { fromUi: true },
      fragmentId
    )
    setDirty(false)
    setValue("")
    setScrollHeight(0)
  }

  const handleKeyDown = (e: KeyboardEvent<HTMLTextAreaElement>): void => {
    const { metaKey, ctrlKey, shiftKey } = e
    const shouldSubmit =
      isEnterKeyPressed(e) && !shiftKey && !ctrlKey && !metaKey

    if (shouldSubmit) {
      e.preventDefault()

      handleSubmit()
    }
  }

  const handleChange = (e: ChangeEvent<HTMLTextAreaElement>): void => {
    const { value } = e.target
    const { maxChars } = element

    if (maxChars !== 0 && value.length > maxChars) {
      return
    }

    setDirty(value !== "")
    setValue(value)
    setScrollHeight(getScrollHeight())
  }

  useEffect(() => {
    if (element.setValue) {
      // We are intentionally setting this to avoid regularly calling this effect.
      // TODO: Update to match React best practices
      // eslint-disable-next-line react-compiler/react-compiler
      element.setValue = false
      const val = element.value || ""
      setValue(val)
      setDirty(val !== "")
    }
  }, [element])

  useEffect(() => {
    if (chatInputRef.current) {
      const { offsetHeight } = chatInputRef.current
      heightGuidance.current.minHeight = offsetHeight
      heightGuidance.current.maxHeight = offsetHeight * MAX_VISIBLE_NUM_LINES
    }
  }, [chatInputRef])

  const { disabled, placeholder, maxChars } = element
  const { minHeight, maxHeight } = heightGuidance.current

  const isInputExtended =
    scrollHeight > 0 && chatInputRef.current
      ? Math.abs(scrollHeight - minHeight) > ROUNDING_OFFSET
      : false

  return (
    <StyledChatInputContainer
      className="stChatInput"
      data-testid="stChatInput"
      width={width}
    >
      <StyledChatInput>
        <UITextArea
          inputRef={chatInputRef}
          value={value}
          placeholder={placeholder}
          onChange={handleChange}
          onKeyDown={handleKeyDown}
          aria-label={placeholder}
          disabled={disabled}
          rows={1}
          overrides={{
            Root: {
              style: {
                minHeight: theme.sizes.minElementHeight,
                outline: "none",
                backgroundColor: theme.colors.transparent,
                // Baseweb requires long-hand props, short-hand leads to weird bugs & warnings.
                borderRadius: theme.radii.xxxl,
                borderLeftWidth: theme.sizes.borderWidth,
                borderRightWidth: theme.sizes.borderWidth,
                borderTopWidth: theme.sizes.borderWidth,
                borderBottomWidth: theme.sizes.borderWidth,
                width: `${width}px`,
              },
            },
            InputContainer: {
              style: {
                backgroundColor: theme.colors.transparent,
              },
            },
            Input: {
              props: {
                "data-testid": "stChatInputTextArea",
              },
              style: {
                lineHeight: theme.lineHeights.inputWidget,
                backgroundColor: theme.colors.transparent,
                // Disable resizing via drag and drop
                resize: "none",
                "::placeholder": {
                  opacity: "0.7",
                },
                height: isInputExtended
                  ? `${scrollHeight + ROUNDING_OFFSET}px`
                  : "auto",
                maxHeight: maxHeight ? `${maxHeight}px` : "none",
                // Baseweb requires long-hand props, short-hand leads to weird bugs & warnings.
                paddingLeft: theme.spacing.lg,
                paddingBottom: theme.spacing.sm,
                paddingTop: theme.spacing.sm,
                // Calculate the right padding to account for the send icon (iconSizes.xl + 2 * spacing.sm)
                // and some additional margin between the icon and the text (spacing.sm).
                paddingRight: `calc(${theme.iconSizes.xl} + 2 * ${theme.spacing.sm} + ${theme.spacing.sm})`,
              },
            },
          }}
        />
        {/* Hide the character limit in small widget sizes */}
        {width > theme.breakpoints.hideWidgetDetails && (
          <StyledInputInstructionsContainer>
            <InputInstructions
              dirty={dirty}
              value={value}
              maxLength={maxChars}
              type="chat"
              // Chat Input are not able to be used in forms
              inForm={false}
            />
          </StyledInputInstructionsContainer>
        )}
        <StyledSendIconButtonContainer>
          <StyledSendIconButton
            onClick={handleSubmit}
            disabled={!dirty || disabled}
            extended={isInputExtended}
            data-testid="stChatInputSubmitButton"
          >
            <Icon content={Send} size="xl" color="inherit" />
          </StyledSendIconButton>
        </StyledSendIconButtonContainer>
      </StyledChatInput>
    </StyledChatInputContainer>
  )
}

export default ChatInput


================================================
File: /frontend/lib/src/components/widgets/ChatInput/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
export { default } from "./ChatInput"


================================================
File: /frontend/lib/src/components/widgets/ChatInput/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import styled from "@emotion/styled"

import { hasLightBackgroundColor } from "@streamlit/lib/src/theme"

export interface StyledChatInputContainerProps {
  width: number
}

export const StyledChatInputContainer =
  styled.div<StyledChatInputContainerProps>(({ theme, width }) => {
    return {
      borderRadius: theme.radii.xxxl,
      display: "flex",
      backgroundColor:
        theme.colors.widgetBackgroundColor ?? theme.colors.secondaryBg,
      width: `${width}px`,
    }
  })

export const StyledChatInput = styled.div(({ theme }) => {
  return {
    backgroundColor: theme.colors.transparent,
    position: "relative",
    flexGrow: 1,
    borderRadius: theme.radii.xxxl,
    display: "flex",
    alignItems: "center",
  }
})

interface StyledSendIconButtonProps {
  disabled: boolean
  extended: boolean
}

export const StyledSendIconButton = styled.button<StyledSendIconButtonProps>(
  ({ theme, disabled, extended }) => {
    const lightTheme = hasLightBackgroundColor(theme)
    const [cleanIconColor, dirtyIconColor] = lightTheme
      ? [theme.colors.gray60, theme.colors.gray80]
      : [theme.colors.gray80, theme.colors.gray40]
    return {
      border: "none",
      backgroundColor: theme.colors.transparent,
      borderTopRightRadius: extended ? "0" : theme.radii.xxxl,
      borderTopLeftRadius: extended ? theme.radii.default : "0",
      borderBottomRightRadius: theme.radii.xxxl,
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      lineHeight: theme.lineHeights.none,
      margin: theme.spacing.none,
      padding: theme.spacing.sm,
      color: disabled ? cleanIconColor : dirtyIconColor,
      pointerEvents: "auto",
      "&:focus": {
        outline: "none",
      },
      ":focus": {
        outline: "none",
      },
      "&:focus-visible": {
        backgroundColor: lightTheme
          ? theme.colors.gray10
          : theme.colors.gray90,
      },
      "&:hover": {
        color: theme.colors.primary,
      },
      "&:disabled, &:disabled:hover, &:disabled:active": {
        backgroundColor: theme.colors.transparent,
        borderColor: theme.colors.transparent,
        color: theme.colors.gray,
      },
    }
  }
)

export const StyledSendIconButtonContainer = styled.div({
  display: "flex",
  alignItems: "flex-end",
  height: "100%",
  position: "absolute",
  right: 0,
  pointerEvents: "none",
})

export const StyledInputInstructionsContainer = styled.div(({ theme }) => ({
  position: "absolute",
  bottom: "0px",
  // Calculate the right padding to account for the send icon (iconSizes.xl + 2 * spacing.sm)
  // and some additional margin between the icon and the text (spacing.sm).
  right: `calc(${theme.iconSizes.xl} + 2 * ${theme.spacing.sm} + ${theme.spacing.sm})`,
}))


================================================
File: /frontend/lib/src/components/widgets/Checkbox/Checkbox.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { act, screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import { render } from "@streamlit/lib/src/test_util"
import {
  Checkbox as CheckboxProto,
  LabelVisibilityMessage as LabelVisibilityMessageProto,
} from "@streamlit/lib/src/proto"

import Checkbox, { Props } from "./Checkbox"

const getProps = (
  elementProps: Partial<CheckboxProto> = {},
  widgetProps: Partial<Props> = {}
): Props => ({
  element: CheckboxProto.create({
    id: "1",
    label: "Label",
    default: false,
    type: CheckboxProto.StyleType.DEFAULT,
    ...elementProps,
  }),
  width: 0,
  disabled: false,
  widgetMgr: new WidgetStateManager({
    sendRerunBackMsg: vi.fn(),
    formsDataChanged: vi.fn(),
  }),
  ...widgetProps,
})

describe("Checkbox widget", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<Checkbox {...props} />)

    expect(screen.getByRole("checkbox")).toBeInTheDocument()
  })

  it("sets widget value on mount", () => {
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setBoolValue")

    render(<Checkbox {...props} />)

    expect(props.widgetMgr.setBoolValue).toHaveBeenCalledWith(
      props.element,
      props.element.default,
      { fromUi: false },
      undefined
    )
  })

  it("has correct className and style", () => {
    const props = getProps()
    render(<Checkbox {...props} />)
    const checkboxElement = screen.getByTestId("stCheckbox")

    expect(checkboxElement).toHaveClass("stCheckbox")
    expect(checkboxElement).toHaveStyle(`width: ${props.width}px`)
  })

  it("renders a label", () => {
    const props = getProps()
    render(<Checkbox {...props} />)
    expect(screen.getByText(props.element.label)).toBeInTheDocument()
  })

  it("pass labelVisibility prop to StyledContent correctly when hidden", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.HIDDEN,
      },
    })

    render(<Checkbox {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle(
      "visibility: hidden"
    )
  })

  it("pass labelVisibility prop to StyledContent correctly when collapsed", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.COLLAPSED,
      },
    })

    render(<Checkbox {...props} />)

    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle("display: none")
  })

  it("is unchecked by default", () => {
    const props = getProps()
    render(<Checkbox {...props} />)

    expect(screen.getByRole("checkbox")).not.toBeChecked()
  })

  it("is not disabled by default", () => {
    const props = getProps()
    render(<Checkbox {...props} />)

    expect(screen.getByRole("checkbox")).not.toBeDisabled()
  })

  it("handles the onChange event", async () => {
    const user = userEvent.setup()
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setBoolValue")

    render(<Checkbox {...props} />)

    await user.click(screen.getByRole("checkbox"))

    expect(props.widgetMgr.setBoolValue).toHaveBeenCalledWith(
      props.element,
      true,
      { fromUi: true },
      undefined
    )
    expect(screen.getByRole("checkbox")).toBeChecked()
  })

  it("can pass fragmentId to setBoolValue", async () => {
    const user = userEvent.setup()
    const props = getProps(undefined, { fragmentId: "myFragmentId" })
    vi.spyOn(props.widgetMgr, "setBoolValue")

    render(<Checkbox {...props} />)

    await user.click(screen.getByRole("checkbox"))

    expect(props.widgetMgr.setBoolValue).toHaveBeenCalledWith(
      props.element,
      true,
      { fromUi: true },
      "myFragmentId"
    )
  })

  it("resets its value when form is cleared", async () => {
    const user = userEvent.setup()
    // Create a widget in a clearOnSubmit form
    const props = getProps({ formId: "form" })
    props.widgetMgr.setFormSubmitBehaviors("form", true)

    vi.spyOn(props.widgetMgr, "setBoolValue")

    render(<Checkbox {...props} />)

    // Change the widget value
    await user.click(screen.getByRole("checkbox"))

    expect(screen.getByRole("checkbox")).toBeChecked()
    expect(props.widgetMgr.setBoolValue).toHaveBeenLastCalledWith(
      props.element,
      true,
      { fromUi: true },
      undefined
    )

    // "Submit" the form
    act(() => {
      props.widgetMgr.submitForm("form", undefined)
    })

    // Our widget should be reset, and the widgetMgr should be updated
    expect(screen.getByRole("checkbox")).not.toBeChecked()
    expect(props.widgetMgr.setBoolValue).toHaveBeenLastCalledWith(
      props.element,
      props.element.default,
      {
        fromUi: true,
      },
      undefined
    )
  })
})


================================================
File: /frontend/lib/src/components/widgets/Checkbox/Checkbox.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { memo, ReactElement, useCallback } from "react"

import { useTheme } from "@emotion/react"
import {
  LABEL_PLACEMENT,
  STYLE_TYPE,
  Checkbox as UICheckbox,
} from "baseui/checkbox"
import { transparentize } from "color2k"

import { labelVisibilityProtoValueToEnum } from "@streamlit/lib/src/util/utils"
import { Checkbox as CheckboxProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  useBasicWidgetState,
  ValueWithSource,
} from "@streamlit/lib/src/hooks/useBasicWidgetState"
import { hasLightBackgroundColor } from "@streamlit/lib/src/theme"
import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"
import { StyledWidgetLabelHelpInline } from "@streamlit/lib/src/components/widgets/BaseWidget"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"

import { StyledCheckbox, StyledContent } from "./styled-components"

export interface Props {
  disabled: boolean
  element: CheckboxProto
  widgetMgr: WidgetStateManager
  width: number
  fragmentId?: string
}

function Checkbox({
  width,
  element,
  disabled,
  widgetMgr,
  fragmentId,
}: Readonly<Props>): ReactElement {
  const [value, setValueWithSource] = useBasicWidgetState<
    boolean,
    CheckboxProto
  >({
    getStateFromWidgetMgr,
    getDefaultStateFromProto,
    getCurrStateFromProto,
    updateWidgetMgrState,
    element,
    widgetMgr,
    fragmentId,
  })

  const onChange = useCallback(
    (e: React.ChangeEvent<HTMLInputElement>): void => {
      setValueWithSource({ value: e.target.checked, fromUi: true })
    },
    // ESLint complains if we remove this unnecessary dep.
    [setValueWithSource]
  )

  const theme = useTheme()
  const { colors, spacing, sizes } = theme

  const lightTheme = hasLightBackgroundColor(theme)

  const color = disabled ? colors.fadedText40 : colors.bodyText

  return (
    <StyledCheckbox
      className="row-widget stCheckbox"
      data-testid="stCheckbox"
      width={width}
    >
      <UICheckbox
        checked={value}
        disabled={disabled}
        onChange={onChange}
        aria-label={element.label}
        checkmarkType={
          element.type === CheckboxProto.StyleType.TOGGLE
            ? STYLE_TYPE.toggle
            : STYLE_TYPE.default
        }
        labelPlacement={LABEL_PLACEMENT.right}
        overrides={{
          Root: {
            style: ({ $isFocusVisible }: { $isFocusVisible: boolean }) => ({
              marginBottom: spacing.none,
              marginTop: spacing.none,
              backgroundColor: $isFocusVisible ? colors.darkenedBgMix25 : "",
              display: "flex",
              alignItems: "start",
            }),
          },
          Toggle: {
            style: ({ $checked }: { $checked: boolean }) => {
              let backgroundColor = lightTheme
                ? colors.bgColor
                : colors.bodyText

              if (disabled) {
                backgroundColor = lightTheme ? colors.gray70 : colors.gray90
              }
              return {
                width: `calc(${sizes.checkbox} - ${theme.spacing.twoXS})`,
                height: `calc(${sizes.checkbox} - ${theme.spacing.twoXS})`,
                transform: $checked ? `translateX(${sizes.checkbox})` : "",
                backgroundColor,
                boxShadow: "",
              }
            },
          },
          ToggleTrack: {
            style: ({
              $checked,
              $isHovered,
            }: {
              $checked: boolean
              $isHovered: boolean
            }) => {
              let backgroundColor = colors.fadedText40

              if ($isHovered && !disabled) {
                backgroundColor = colors.fadedText20
              }

              if ($checked && !disabled) {
                backgroundColor = colors.primary
              }

              return {
                marginRight: 0,
                marginLeft: 0,
                marginBottom: 0,
                marginTop: theme.spacing.twoXS,
                paddingLeft: theme.spacing.threeXS,
                paddingRight: theme.spacing.threeXS,
                width: `calc(2 * ${sizes.checkbox})`,
                minWidth: `calc(2 * ${sizes.checkbox})`,
                height: sizes.checkbox,
                minHeight: sizes.checkbox,
                borderBottomLeftRadius: theme.radii.full,
                borderTopLeftRadius: theme.radii.full,
                borderBottomRightRadius: theme.radii.full,
                borderTopRightRadius: theme.radii.full,
                backgroundColor,
              }
            },
          },
          Checkmark: {
            style: ({
              $isFocusVisible,
              $checked,
            }: {
              $isFocusVisible: boolean
              $checked: boolean
            }) => {
              const borderColor =
                $checked && !disabled ? colors.primary : colors.fadedText40

              return {
                outline: 0,
                width: sizes.checkbox,
                height: sizes.checkbox,
                marginTop: theme.spacing.twoXS,
                marginLeft: 0,
                marginBottom: 0,
                boxShadow:
                  $isFocusVisible && $checked
                    ? `0 0 0 0.2rem ${transparentize(colors.primary, 0.5)}`
                    : "",
                // This is painfully verbose, but baseweb seems to internally
                // use the long-hand version, which means we can't use the
                // shorthand names here as if we do we'll end up with warn
                // logs spamming us every time a checkbox is rendered.
                borderLeftWidth: sizes.borderWidth,
                borderRightWidth: sizes.borderWidth,
                borderTopWidth: sizes.borderWidth,
                borderBottomWidth: sizes.borderWidth,
                borderLeftColor: borderColor,
                borderRightColor: borderColor,
                borderTopColor: borderColor,
                borderBottomColor: borderColor,
              }
            },
          },
          Label: {
            style: {
              lineHeight: theme.lineHeights.small,
              paddingLeft: theme.spacing.sm,
              position: "relative",
              color,
            },
          },
        }}
      >
        <StyledContent
          visibility={labelVisibilityProtoValueToEnum(
            element.labelVisibility?.value
          )}
          data-testid="stWidgetLabel"
        >
          <StreamlitMarkdown
            source={element.label}
            allowHTML={false}
            isLabel
            largerLabel
          />
          {element.help && (
            <StyledWidgetLabelHelpInline color={color}>
              <TooltipIcon
                content={element.help}
                placement={Placement.TOP_RIGHT}
              />
            </StyledWidgetLabelHelpInline>
          )}
        </StyledContent>
      </UICheckbox>
    </StyledCheckbox>
  )
}

function getStateFromWidgetMgr(
  widgetMgr: WidgetStateManager,
  element: CheckboxProto
): boolean | undefined {
  return widgetMgr.getBoolValue(element)
}

function getDefaultStateFromProto(element: CheckboxProto): boolean {
  return element.default ?? null
}

function getCurrStateFromProto(element: CheckboxProto): boolean {
  return element.value ?? null
}

function updateWidgetMgrState(
  element: CheckboxProto,
  widgetMgr: WidgetStateManager,
  vws: ValueWithSource<boolean>,
  fragmentId?: string
): void {
  widgetMgr.setBoolValue(
    element,
    vws.value,
    { fromUi: vws.fromUi },
    fragmentId
  )
}

export default memo(Checkbox)


================================================
File: /frontend/lib/src/components/widgets/Checkbox/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Checkbox"


================================================
File: /frontend/lib/src/components/widgets/Checkbox/styled-components.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

import { LabelVisibilityOptions } from "@streamlit/lib/src/util/utils"

export interface StyledCheckboxProps {
  width: number
}

export const StyledCheckbox = styled.div<StyledCheckboxProps>(
  ({ width, theme }) => ({
    width,
    display: "flex",
    alignItems: "center",
    minHeight: theme.sizes.smallElementHeight,
  })
)

export interface StyledContentProps {
  visibility?: LabelVisibilityOptions
}

export const StyledContent = styled.div<StyledContentProps>(
  ({ visibility }) => ({
    display: visibility === LabelVisibilityOptions.Collapsed ? "none" : "flex",
    visibility:
      visibility === LabelVisibilityOptions.Hidden ? "hidden" : "visible",
    verticalAlign: "middle",
    flexDirection: "row",
    alignItems: "center",
  })
)


================================================
File: /frontend/lib/src/components/widgets/ColorPicker/ColorPicker.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { act, fireEvent, screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { ColorPicker as ColorPickerProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"

import ColorPicker, { Props } from "./ColorPicker"

const getProps = (
  elementProps: Partial<ColorPickerProto> = {},
  widgetProps: Partial<Props> = {}
): Props => ({
  element: ColorPickerProto.create({
    id: "1",
    label: "Label",
    default: "#000000",
    ...elementProps,
  }),
  width: 0,
  disabled: false,
  widgetMgr: new WidgetStateManager({
    sendRerunBackMsg: vi.fn(),
    formsDataChanged: vi.fn(),
  }),
  ...widgetProps,
})

describe("ColorPicker widget", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<ColorPicker {...props} />)
    const colorPicker = screen.getByTestId("stColorPicker")
    expect(colorPicker).toBeInTheDocument()
    expect(colorPicker).toHaveClass("stColorPicker")
  })

  it("sets widget value on mount", () => {
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")

    render(<ColorPicker {...props} />)

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledWith(
      props.element,
      props.element.default,
      { fromUi: false },
      undefined
    )
  })

  it("can pass fragmentId to setStringValue", () => {
    const props = getProps(undefined, { fragmentId: "myFragmentId" })
    vi.spyOn(props.widgetMgr, "setStringValue")

    render(<ColorPicker {...props} />)

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledWith(
      props.element,
      props.element.default,
      { fromUi: false },
      "myFragmentId"
    )
  })

  it("renders a default color in the preview and the color picker", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<ColorPicker {...props} />)

    const colorBlock = screen.getByTestId("stColorPickerBlock")
    await user.click(colorBlock)
    expect(colorBlock).toHaveStyle("background-color: #000000")

    const colorInput = screen.getByRole("textbox")
    expect(colorInput).toHaveValue("#000000")
  })

  it("updates its widget value when it's changed", async () => {
    const user = userEvent.setup()
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")

    render(<ColorPicker {...props} />)

    const newColor = "#e91e63"
    const colorBlock = screen.getByTestId("stColorPickerBlock")
    await user.click(colorBlock)

    // Our widget should be updated.
    const colorInput = screen.getByRole("textbox")
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.change(colorInput, { target: { value: newColor } })
    // Close out of the popover
    await user.click(colorBlock)

    // And the WidgetMgr should also be updated.
    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      newColor,
      { fromUi: true },
      undefined
    )
  })

  it("resets its value when form is cleared", async () => {
    // Create a widget in a clearOnSubmit form
    const user = userEvent.setup()
    const props = getProps({ formId: "form" })
    vi.spyOn(props.widgetMgr, "setStringValue")
    props.widgetMgr.setFormSubmitBehaviors("form", true)

    render(<ColorPicker {...props} />)

    // Choose a new color
    const newColor = "#e91e63"
    const colorBlock = screen.getByTestId("stColorPickerBlock")
    await user.click(colorBlock)

    const colorInput = screen.getByRole("textbox")
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.change(colorInput, { target: { value: newColor } })
    // Close out of the popover
    await user.click(colorBlock)

    expect(colorInput).toHaveValue(newColor)
    expect(colorBlock).toHaveStyle(`background-color: ${newColor}`)
    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      newColor,
      { fromUi: true },
      undefined
    )

    act(() => {
      // "Submit" the form
      props.widgetMgr.submitForm("form", undefined)
    })

    // Our widget should be reset, and the widgetMgr should be updated
    expect(colorBlock).toHaveStyle("background-color: #000000")
    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      props.element.default,
      {
        fromUi: true,
      },
      undefined
    )
  })
})


================================================
File: /frontend/lib/src/components/widgets/ColorPicker/ColorPicker.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, memo, useCallback } from "react"

import { ColorPicker as ColorPickerProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import BaseColorPicker from "@streamlit/lib/src/components/shared/BaseColorPicker"
import { labelVisibilityProtoValueToEnum } from "@streamlit/lib/src/util/utils"
import {
  useBasicWidgetState,
  ValueWithSource,
} from "@streamlit/lib/src/hooks/useBasicWidgetState"

export interface Props {
  disabled: boolean
  element: ColorPickerProto
  widgetMgr: WidgetStateManager
  width: number
  fragmentId?: string
}

/**
 * The value specified by the user via the UI. If the user didn't touch this
 * widget's UI, the default value is used.
 */
type ColorPickerValue = string

const getStateFromWidgetMgr = (
  widgetMgr: WidgetStateManager,
  element: ColorPickerProto
): ColorPickerValue | undefined => {
  return widgetMgr.getStringValue(element)
}

const getDefaultStateFromProto = (
  element: ColorPickerProto
): ColorPickerValue => {
  return element.default ?? null
}

const getCurrStateFromProto = (
  element: ColorPickerProto
): ColorPickerValue => {
  return element.value ?? null
}

const updateWidgetMgrState = (
  element: ColorPickerProto,
  widgetMgr: WidgetStateManager,
  valueWithSource: ValueWithSource<ColorPickerValue>,
  fragmentId?: string
): void => {
  widgetMgr.setStringValue(
    element,
    valueWithSource.value,
    { fromUi: valueWithSource.fromUi },
    fragmentId
  )
}

const ColorPicker: FC<Props> = ({
  element,
  disabled,
  widgetMgr,
  width,
  fragmentId,
}) => {
  const [value, setValueWithSource] = useBasicWidgetState<
    ColorPickerValue,
    ColorPickerProto
  >({
    getStateFromWidgetMgr,
    getDefaultStateFromProto,
    getCurrStateFromProto,
    updateWidgetMgrState,
    element,
    widgetMgr,
    fragmentId,
  })

  const handleColorClose = useCallback(
    (color: string): void => {
      setValueWithSource({ value: color, fromUi: true })
    },
    [setValueWithSource]
  )

  return (
    <BaseColorPicker
      label={element.label}
      labelVisibility={labelVisibilityProtoValueToEnum(
        element.labelVisibility?.value
      )}
      help={element.help}
      onChange={handleColorClose}
      disabled={disabled}
      width={width}
      value={value}
    />
  )
}

export default memo(ColorPicker)


================================================
File: /frontend/lib/src/components/widgets/ColorPicker/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./ColorPicker"


================================================
File: /frontend/lib/src/components/widgets/CustomComponent/ComponentInstance.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { Mock } from "vitest"
import { act, fireEvent, screen } from "@testing-library/react"

import {
  ComponentInstance as ComponentInstanceProto,
  SpecialArg,
} from "@streamlit/lib/src/proto"
import {
  DEFAULT_IFRAME_FEATURE_POLICY,
  DEFAULT_IFRAME_SANDBOX_POLICY,
} from "@streamlit/lib/src/util/IFrameUtil"
import { logWarning } from "@streamlit/lib/src/util/log"
import { buildHttpUri } from "@streamlit/lib/src/util/UriUtil"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import { bgColorToBaseString, toExportedTheme } from "@streamlit/lib/src/theme"
import { fonts } from "@streamlit/lib/src/theme/primitives/typography"
import { mockEndpoints } from "@streamlit/lib/src/mocks/mocks"
import { mockTheme } from "@streamlit/lib/src/mocks/mockTheme"
import { render } from "@streamlit/lib/src/test_util"

import ComponentInstance, {
  COMPONENT_READY_WARNING_TIME_MS,
} from "./ComponentInstance"
import { CUSTOM_COMPONENT_API_VERSION } from "./componentUtils"
import { ComponentRegistry } from "./ComponentRegistry"
import { ComponentMessageType, StreamlitMessageType } from "./enums"

// Mock log functions.
vi.mock("@streamlit/lib/src/util/log")

// We have some timeouts that we want to use fake timers for.
vi.useFakeTimers()

// Mock uri utils.
vi.mock("@streamlit/lib/src/util/UriUtil")
const mockedBuildHttpUri = buildHttpUri as Mock
mockedBuildHttpUri.mockImplementation(() => "registry/url")

// Mock our WidgetStateManager
vi.mock("@streamlit/lib/src/WidgetStateManager")

const MOCK_COMPONENT_URL = "http://a.mock.url"
const MOCK_WIDGET_ID = "mock_widget_id"
const MOCK_COMPONENT_NAME = "mock_component_name"

describe("ComponentInstance", () => {
  const getComponentRegistry = (): ComponentRegistry => {
    return new ComponentRegistry(mockEndpoints())
  }

  beforeEach(() => {
    // Clear our class mocks
    const mockWidgetStateManager = WidgetStateManager as unknown as Mock
    mockWidgetStateManager.mockClear()

    const mockLog = logWarning as Mock
    mockLog.mockClear()
  })

  it("registers a message listener on render", () => {
    const componentRegistry = getComponentRegistry()
    const registerListener = vi.spyOn(componentRegistry, "registerListener")
    render(
      <ComponentInstance
        element={createElementProp()}
        registry={componentRegistry}
        width={100}
        disabled={false}
        theme={mockTheme.emotion}
        widgetMgr={
          new WidgetStateManager({
            sendRerunBackMsg: vi.fn(),
            formsDataChanged: vi.fn(),
          })
        }
      />
    )
    expect(registerListener).toHaveBeenCalledTimes(1)
  })

  it("deregisters its message listener on rerender", () => {
    const componentRegistry = getComponentRegistry()
    const deregisterListener = vi.spyOn(
      componentRegistry,
      "deregisterListener"
    )
    const { unmount } = render(
      <ComponentInstance
        element={createElementProp()}
        registry={componentRegistry}
        width={100}
        disabled={false}
        theme={mockTheme.emotion}
        widgetMgr={
          new WidgetStateManager({
            sendRerunBackMsg: vi.fn(),
            formsDataChanged: vi.fn(),
          })
        }
      />
    )
    unmount()
    expect(deregisterListener).toHaveBeenCalledTimes(1)
  })

  it("renders its iframe correctly", () => {
    const componentRegistry = getComponentRegistry()
    render(
      <ComponentInstance
        element={createElementProp()}
        registry={componentRegistry}
        width={100}
        disabled={false}
        theme={mockTheme.emotion}
        widgetMgr={
          new WidgetStateManager({
            sendRerunBackMsg: vi.fn(),
            formsDataChanged: vi.fn(),
          })
        }
      />
    )
    const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
    expect(iframe).toHaveAttribute(
      "src",
      "http://a.mock.url?streamlitUrl=http%3A%2F%2Flocalhost%3A3000%2F"
    )
    expect(iframe).toHaveAttribute("allow", DEFAULT_IFRAME_FEATURE_POLICY)
    expect(iframe).toHaveAttribute("sandbox", DEFAULT_IFRAME_SANDBOX_POLICY)
    expect(iframe).toHaveClass("stCustomComponentV1")
  })

  it("displays a skeleton initially with a certain height", () => {
    const componentRegistry = getComponentRegistry()
    render(
      <ComponentInstance
        element={createElementProp()}
        registry={componentRegistry}
        width={100}
        disabled={false}
        theme={mockTheme.emotion}
        widgetMgr={
          new WidgetStateManager({
            sendRerunBackMsg: vi.fn(),
            formsDataChanged: vi.fn(),
          })
        }
      />
    )
    const skeleton = screen.getByTestId("stSkeleton")
    expect(skeleton).toBeInTheDocument()
    expect(skeleton).toHaveStyle("height: 2.75rem")

    const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
    expect(iframe).toHaveAttribute("height", "0")
  })

  it("will not displays a skeleton when height is explicitly set to 0", () => {
    const componentRegistry = getComponentRegistry()
    render(
      <ComponentInstance
        element={createElementProp({ height: 0 })}
        registry={componentRegistry}
        width={100}
        disabled={false}
        theme={mockTheme.emotion}
        widgetMgr={
          new WidgetStateManager({
            sendRerunBackMsg: vi.fn(),
            formsDataChanged: vi.fn(),
          })
        }
      />
    )
    expect(screen.queryByTestId("stSkeleton")).not.toBeInTheDocument()

    const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
    expect(iframe).toHaveAttribute("height", "0")
  })

  describe("COMPONENT_READY handler", () => {
    it("posts a RENDER message to the iframe", () => {
      const jsonArgs = { foo: "string", bar: 5 }
      const componentRegistry = getComponentRegistry()
      render(
        <ComponentInstance
          element={createElementProp(jsonArgs)}
          registry={componentRegistry}
          width={100}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )
      const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
      // @ts-expect-error
      const postMessage = vi.spyOn(iframe.contentWindow, "postMessage")
      // SET COMPONENT_READY
      fireEvent(
        window,
        new MessageEvent("message", {
          data: {
            isStreamlitMessage: true,
            apiVersion: 1,
            type: ComponentMessageType.COMPONENT_READY,
          },
          // @ts-expect-error
          source: iframe.contentWindow,
        })
      )
      expect(postMessage).toHaveBeenCalledWith(renderMsg(jsonArgs, []), "*")
    })

    it("hides the skeleton and maintains iframe height of 0", () => {
      const componentRegistry = getComponentRegistry()
      render(
        <ComponentInstance
          element={createElementProp()}
          registry={componentRegistry}
          width={100}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )

      const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)

      // SET COMPONENT_READY
      fireEvent(
        window,
        new MessageEvent("message", {
          data: {
            isStreamlitMessage: true,
            apiVersion: 1,
            type: ComponentMessageType.COMPONENT_READY,
          },
          // @ts-expect-error
          source: iframe.contentWindow,
        })
      )
      expect(screen.queryByTestId("stSkeleton")).not.toBeInTheDocument()
      expect(iframe).toHaveAttribute("height", "0")
    })

    it("prevents RENDER message until component is ready", () => {
      const jsonArgs = { foo: "string", bar: 5 }
      const componentRegistry = getComponentRegistry()
      render(
        <ComponentInstance
          element={createElementProp(jsonArgs)}
          registry={componentRegistry}
          width={100}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )
      const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
      // @ts-expect-error
      const postMessage = vi.spyOn(iframe.contentWindow, "postMessage")
      expect(postMessage).toHaveBeenCalledTimes(0)
    })

    it("can be called multiple times", () => {
      // It's not an error for a component to call READY multiple times.
      // (This can happen during development, when the component's devserver
      // reloads.)
      const jsonArgs = { foo: "string", bar: 5 }
      const componentRegistry = getComponentRegistry()
      render(
        <ComponentInstance
          element={createElementProp(jsonArgs)}
          registry={componentRegistry}
          width={100}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )
      const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
      // @ts-expect-error
      const postMessage = vi.spyOn(iframe.contentWindow, "postMessage")
      // SET COMPONENT_READY
      fireEvent(
        window,
        new MessageEvent("message", {
          data: {
            isStreamlitMessage: true,
            apiVersion: 1,
            type: ComponentMessageType.COMPONENT_READY,
          },
          // @ts-expect-error
          source: iframe.contentWindow,
        })
      )
      // SET COMPONENT_READY
      fireEvent(
        window,
        new MessageEvent("message", {
          data: {
            isStreamlitMessage: true,
            apiVersion: 1,
            type: ComponentMessageType.COMPONENT_READY,
          },
          // @ts-expect-error
          source: iframe.contentWindow,
        })
      )
      expect(postMessage).toHaveBeenCalledTimes(2)
    })

    it("send render message whenever the args change and the component is ready", () => {
      let jsonArgs = { foo: "string", bar: 5 }
      const componentRegistry = getComponentRegistry()
      const { rerender } = render(
        <ComponentInstance
          element={createElementProp(jsonArgs)}
          registry={componentRegistry}
          width={100}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )
      const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
      // @ts-expect-error
      const postMessage = vi.spyOn(iframe.contentWindow, "postMessage")
      // SET COMPONENT_READY
      fireEvent(
        window,
        new MessageEvent("message", {
          data: {
            isStreamlitMessage: true,
            apiVersion: 1,
            type: ComponentMessageType.COMPONENT_READY,
          },
          // @ts-expect-error
          source: iframe.contentWindow,
        })
      )
      jsonArgs = { foo: "string", bar: 10 }
      rerender(
        <ComponentInstance
          element={createElementProp(jsonArgs)}
          registry={componentRegistry}
          width={100}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )

      expect(postMessage).toHaveBeenCalledTimes(2)
    })

    it("send render message when viewport changes", () => {
      const jsonArgs = { foo: "string", bar: 5 }
      let width = 100
      const componentRegistry = getComponentRegistry()
      const { rerender } = render(
        <ComponentInstance
          element={createElementProp(jsonArgs)}
          registry={componentRegistry}
          width={width}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )
      const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
      // @ts-expect-error
      const postMessage = vi.spyOn(iframe.contentWindow, "postMessage")
      // SET COMPONENT_READY
      fireEvent(
        window,
        new MessageEvent("message", {
          data: {
            isStreamlitMessage: true,
            apiVersion: 1,
            type: ComponentMessageType.COMPONENT_READY,
          },
          // @ts-expect-error
          source: iframe.contentWindow,
        })
      )
      width = width + 1
      rerender(
        <ComponentInstance
          element={createElementProp(jsonArgs)}
          registry={componentRegistry}
          width={width}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )

      expect(postMessage).toHaveBeenCalledTimes(2)
    })

    it("errors on unrecognized API version", () => {
      const badAPIVersion = CUSTOM_COMPONENT_API_VERSION + 1
      const jsonArgs = { foo: "string", bar: 5 }
      const componentRegistry = getComponentRegistry()
      render(
        <ComponentInstance
          element={createElementProp(jsonArgs)}
          registry={componentRegistry}
          width={100}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )
      const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
      // SET COMPONENT_READY
      fireEvent(
        window,
        new MessageEvent("message", {
          data: {
            isStreamlitMessage: true,
            apiVersion: badAPIVersion,
            type: ComponentMessageType.COMPONENT_READY,
          },
          // @ts-expect-error
          source: iframe.contentWindow,
        })
      )
      expect(screen.getByTestId("stAlertContentError")).toBeVisible()
    })

    it("errors on unrecognized special args", () => {
      const jsonArgs = {}
      const element = createElementProp(jsonArgs, [
        new SpecialArg({ key: "foo" }),
      ])
      const componentRegistry = getComponentRegistry()
      render(
        <ComponentInstance
          element={element}
          registry={componentRegistry}
          width={100}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )
      expect(
        screen.getByText("Unrecognized SpecialArg type: undefined")
      ).toBeVisible()
    })

    it("warns if COMPONENT_READY hasn't been received after a timeout", () => {
      const componentRegistry = getComponentRegistry()
      render(
        <ComponentInstance
          element={createElementProp()}
          registry={componentRegistry}
          width={100}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )
      // Advance past our warning timeout, and force a re-render.
      act(() => vi.advanceTimersByTime(COMPONENT_READY_WARNING_TIME_MS))

      expect(
        screen.getByText(/The app is attempting to load the component from/)
      ).toBeVisible()
    })
  })

  describe("SET_COMPONENT_VALUE handler", () => {
    it("handles JSON values", () => {
      const jsonValue = {
        foo: "string",
        bar: 123,
        list: [1, "foo", false],
      }

      const componentRegistry = getComponentRegistry()
      const element = createElementProp(jsonValue)
      render(
        <ComponentInstance
          element={element}
          registry={componentRegistry}
          width={100}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )

      const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
      // SET COMPONENT_READY
      fireEvent(
        window,
        new MessageEvent("message", {
          data: {
            isStreamlitMessage: true,
            apiVersion: 1,
            type: ComponentMessageType.COMPONENT_READY,
          },
          // @ts-expect-error
          source: iframe.contentWindow,
        })
      )
      // SET COMPONENT_VALUE
      fireEvent(
        window,
        new MessageEvent("message", {
          data: {
            isStreamlitMessage: true,
            apiVersion: 1,
            type: ComponentMessageType.SET_COMPONENT_VALUE,
            dataType: "json",
            value: jsonValue,
          },
          // @ts-expect-error
          source: iframe.contentWindow,
        })
      )
      const widgetMgr = (WidgetStateManager as any).mock.instances[0]
      expect(widgetMgr.setJsonValue).toHaveBeenCalledWith(
        element,
        jsonValue,
        {
          fromUi: true,
        },
        undefined
      )
    })

    it("handles bytes values", () => {
      const jsonValue = {}

      const componentRegistry = getComponentRegistry()
      const element = createElementProp(jsonValue)
      render(
        <ComponentInstance
          element={element}
          registry={componentRegistry}
          width={100}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
          // Also verify that we can pass a fragmentID down to setBytesValue.
          fragmentId="myFragmentId"
        />
      )

      const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
      // SET COMPONENT_READY
      fireEvent(
        window,
        new MessageEvent("message", {
          data: {
            isStreamlitMessage: true,
            apiVersion: 1,
            type: ComponentMessageType.COMPONENT_READY,
          },
          // @ts-expect-error
          source: iframe.contentWindow,
        })
      )

      const bytesValue = new Uint8Array([0, 1, 2])
      // SET COMPONENT_VALUE
      fireEvent(
        window,
        new MessageEvent("message", {
          data: {
            isStreamlitMessage: true,
            apiVersion: 1,
            type: ComponentMessageType.SET_COMPONENT_VALUE,
            dataType: "bytes",
            value: bytesValue,
          },
          // @ts-expect-error
          source: iframe.contentWindow,
        })
      )
      const widgetMgr = (WidgetStateManager as any).mock.instances[0]
      expect(widgetMgr.setBytesValue).toHaveBeenCalledWith(
        element,
        bytesValue,
        { fromUi: true },
        "myFragmentId"
      )
    })

    //   // TODO: implement test to check handling of daataframe values

    it("warns if called before COMPONENT_READY", () => {
      const jsonValue = {
        foo: "string",
        bar: 123,
        list: [1, "foo", false],
      }

      const componentRegistry = getComponentRegistry()
      const element = createElementProp(jsonValue)
      render(
        <ComponentInstance
          element={element}
          registry={componentRegistry}
          width={100}
          disabled={false}
          theme={mockTheme.emotion}
          widgetMgr={
            new WidgetStateManager({
              sendRerunBackMsg: vi.fn(),
              formsDataChanged: vi.fn(),
            })
          }
        />
      )
      const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
      // SET COMPONENT_VALUE
      fireEvent(
        window,
        new MessageEvent("message", {
          data: {
            isStreamlitMessage: true,
            apiVersion: 1,
            type: ComponentMessageType.SET_COMPONENT_VALUE,
            dataType: "bytes",
            value: jsonValue,
          },
          // @ts-expect-error
          source: iframe.contentWindow,
        })
      )
      const widgetMgr = (WidgetStateManager as any).mock.instances[0]
      expect(widgetMgr.setJsonValue).not.toHaveBeenCalled()

      expect(logWarning).toHaveBeenCalledWith(
        `Got ${ComponentMessageType.SET_COMPONENT_VALUE} before ${ComponentMessageType.COMPONENT_READY}!`
      )
    })

    describe("SET_FRAME_HEIGHT handler", () => {
      it("updates the frameHeight without re-rendering", () => {
        const jsonValue = {}
        const componentRegistry = getComponentRegistry()
        const element = createElementProp(jsonValue)
        render(
          <ComponentInstance
            element={element}
            registry={componentRegistry}
            width={100}
            disabled={false}
            theme={mockTheme.emotion}
            widgetMgr={
              new WidgetStateManager({
                sendRerunBackMsg: vi.fn(),
                formsDataChanged: vi.fn(),
              })
            }
          />
        )
        const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
        // SET COMPONENT_READY
        fireEvent(
          window,
          new MessageEvent("message", {
            data: {
              isStreamlitMessage: true,
              apiVersion: 1,
              type: ComponentMessageType.COMPONENT_READY,
            },
            // @ts-expect-error
            source: iframe.contentWindow,
          })
        )
        // SET IFRAME_HEIGHT
        fireEvent(
          window,
          new MessageEvent("message", {
            data: {
              isStreamlitMessage: true,
              apiVersion: 1,
              type: ComponentMessageType.SET_FRAME_HEIGHT,
              height: 100,
            },
            // @ts-expect-error
            source: iframe.contentWindow,
          })
        )

        // Updating the frameheight intentionally does *not* cause a re-render
        // (instead, it directly updates the iframeRef) - so we can't check
        // that `child.prop("height") == 100`
        expect(iframe).toHaveAttribute("height", "100")
      })

      it("warns if called before COMPONENT_READY", () => {
        const jsonValue = {
          foo: "string",
          bar: 123,
          list: [1, "foo", false],
        }

        const componentRegistry = getComponentRegistry()
        const element = createElementProp(jsonValue)
        render(
          <ComponentInstance
            element={element}
            registry={componentRegistry}
            width={100}
            disabled={false}
            theme={mockTheme.emotion}
            widgetMgr={
              new WidgetStateManager({
                sendRerunBackMsg: vi.fn(),
                formsDataChanged: vi.fn(),
              })
            }
          />
        )
        const iframe = screen.getByTitle(MOCK_COMPONENT_NAME)
        // SET IFRAME_HEIGHT
        fireEvent(
          window,
          new MessageEvent("message", {
            data: {
              isStreamlitMessage: true,
              apiVersion: 1,
              type: ComponentMessageType.SET_FRAME_HEIGHT,
              height: 100,
            },
            // @ts-expect-error
            source: iframe.contentWindow,
          })
        )
        const widgetMgr = (WidgetStateManager as any).mock.instances[0]
        expect(widgetMgr.setJsonValue).not.toHaveBeenCalled()

        expect(logWarning).toHaveBeenCalledWith(
          `Got ${ComponentMessageType.SET_FRAME_HEIGHT} before ${ComponentMessageType.COMPONENT_READY}!`
        )
      })
    })
  })

  function renderMsg(
    args: { [name: string]: any },
    dataframes: any[],
    disabled = false,
    theme = {
      ...toExportedTheme(mockTheme.emotion),
      base: bgColorToBaseString(mockTheme.emotion.colors.bgColor),
      font: fonts.sansSerif,
    }
  ): any {
    return forwardMsg(StreamlitMessageType.RENDER, {
      args,
      dfs: dataframes,
      disabled,
      theme,
    })
  }

  function forwardMsg(type: StreamlitMessageType, data: any): any {
    return { type, ...data }
  }

  /** Create a ComponentInstance.props.element prop with the given args. */
  function createElementProp(
    jsonArgs: { [name: string]: any } = {},
    specialArgs: SpecialArg[] = []
  ): ComponentInstanceProto {
    return ComponentInstanceProto.create({
      jsonArgs: JSON.stringify(jsonArgs),
      specialArgs,
      componentName: MOCK_COMPONENT_NAME,
      id: MOCK_WIDGET_ID,
      url: MOCK_COMPONENT_URL,
    })
  }
})


================================================
File: /frontend/lib/src/components/widgets/CustomComponent/ComponentInstance.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, useEffect, useRef, useState } from "react"

import { withTheme } from "@emotion/react"
import queryString from "query-string"

import AlertElement from "@streamlit/lib/src/components/elements/AlertElement"
import { Skeleton } from "@streamlit/lib/src/components/elements/Skeleton"
import ErrorElement from "@streamlit/lib/src/components/shared/ErrorElement"
import { Kind } from "@streamlit/lib/src/components/shared/AlertContainer"
import useTimeout from "@streamlit/lib/src/hooks/useTimeout"
import {
  ComponentInstance as ComponentInstanceProto,
  ISpecialArg,
  Skeleton as SkeletonProto,
} from "@streamlit/lib/src/proto"
import { EmotionTheme } from "@streamlit/lib/src/theme"
import {
  DEFAULT_IFRAME_FEATURE_POLICY,
  DEFAULT_IFRAME_SANDBOX_POLICY,
} from "@streamlit/lib/src/util/IFrameUtil"
import { logWarning } from "@streamlit/lib/src/util/log"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  COMMUNITY_URL,
  COMPONENT_DEVELOPER_URL,
} from "@streamlit/lib/src/urls"
import { ensureError } from "@streamlit/lib/src/util/ErrorHandling"
import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

import { ComponentRegistry } from "./ComponentRegistry"
import {
  Args,
  createIframeMessageHandler,
  DataframeArg,
  IframeMessageHandlerProps,
  parseArgs,
  sendRenderMessage,
} from "./componentUtils"
import { StyledComponentIframe } from "./styled-components"

/**
 * If we haven't received a COMPONENT_READY message this many seconds
 * after the component has been created, explain to the user that there
 * may be a problem with their component, and offer troubleshooting advice.
 */
export const COMPONENT_READY_WARNING_TIME_MS = 60000 // 60 seconds

export interface Props {
  registry: ComponentRegistry
  widgetMgr: WidgetStateManager
  disabled: boolean
  element: ComponentInstanceProto
  width: number
  theme: EmotionTheme
  fragmentId?: string
}

/**
 * Create the iFrame `src` based on the passed `url` or, if missing, from the ComponentRegistry. Adds a `streamlitUrl` query parameter.
 * @param componentName name of the component. Only used when `url` is empty
 * @param componentRegistry component registry to get the `url` for the passed component name if `url` is empty
 * @param url used as the `src` if passed
 * @returns the iFrame src including a `streamlitUrl` query parameter
 */
function getSrc(
  componentName: string,
  componentRegistry: ComponentRegistry,
  url?: string
): string {
  let src: string
  if (notNullOrUndefined(url) && url !== "") {
    src = url
  } else {
    src = componentRegistry.getComponentURL(componentName, "index.html")
  }

  // Add streamlitUrl query parameter to src
  const currentUrl = new URL(window.location.href)
  src = queryString.stringifyUrl({
    url: src,
    query: { streamlitUrl: currentUrl.origin + currentUrl.pathname },
  })
  return src
}

/**
 * Creates a warn message. The message is different based on whether or not a `url` is provided.
 * @param componentName
 * @param url
 * @returns the created warn message
 */
function getWarnMessage(componentName: string, url?: string): string {
  let message: string
  if (url && url !== "") {
    message =
      `Your app is having trouble loading the **${componentName}** component.` +
      `\nThe app is attempting to load the component from **${url}**,` +
      `\nand hasn't received its \`Streamlit.setComponentReady()\` message.` +
      `\n\nIf this is a development build, have you started the dev server?` +
      `\n\nFor more troubleshooting help, please see the [Streamlit Component docs](${COMPONENT_DEVELOPER_URL}) or visit our [forums](${COMMUNITY_URL}).`
  } else {
    message =
      `Your app is having trouble loading the **${componentName}** component.` +
      `\n\nIf this is an installed component that works locally, the app may be having trouble accessing the component frontend assets due to network latency or proxy settings in your app deployment.` +
      `\n\nFor more troubleshooting help, please see the [Streamlit Component docs](${COMPONENT_DEVELOPER_URL}) or visit our [forums](${COMMUNITY_URL}).`
  }
  return message
}

function tryParseArgs(
  jsonArgs: string,
  specialArgs: ISpecialArg[],
  setComponentError: (e: Error) => void,
  componentError?: Error
): [newArgs: Args, dataframeArgs: DataframeArg[]] {
  if (!componentError) {
    try {
      return parseArgs(jsonArgs, specialArgs)
    } catch (e) {
      const error = ensureError(e)
      setComponentError(error)
    }
  }

  return [{}, []]
}

/**
 * Compare the two DataframeArg arrays
 *
 * @param previousDataframeArgs
 * @param newDataframeArgs
 * @returns true if the two DataframeArg arrays are equal or if all their key-value pairs (first level only) are equal
 */
function compareDataframeArgs(
  previousDataframeArgs: DataframeArg[],
  newDataframeArgs: DataframeArg[]
): boolean {
  return (
    previousDataframeArgs === newDataframeArgs ||
    (previousDataframeArgs.length === newDataframeArgs.length &&
      previousDataframeArgs.every((previousDataframeArg, i) => {
        const newDataframeArg = newDataframeArgs[i]
        return (
          previousDataframeArg.key === newDataframeArg.key &&
          previousDataframeArg.value === newDataframeArg.value
        )
      }))
  )
}

/**
 * Render the component element. If an error occurs when parsing the arguments,
 * an error element is rendered instead. If the component assets take too long to load as specified
 * by {@link COMPONENT_READY_WARNING_TIME_MS}, a warning element is rendered instead.
 */
function ComponentInstance(props: Props): ReactElement {
  const [componentError, setComponentError] = useState<Error>()

  const { disabled, element, registry, theme, widgetMgr, width, fragmentId } =
    props
  const { componentName, jsonArgs, specialArgs, url } = element

  const [parsedNewArgs, parsedDataframeArgs] = tryParseArgs(
    jsonArgs,
    specialArgs,
    setComponentError,
    componentError
  )

  // Use a ref for the args so that we can use them inside the useEffect calls without the linter complaining
  // as in the useEffect dependencies array, we don't use the parsed arg objects, but their string representation
  // and a comparing function result for the jsonArgs and dataframeArgs, respectively, for deep-equal checks and to
  // prevent calling useEffect too often
  const parsedArgsRef = useRef<{ args: Args; dataframeArgs: DataframeArg[] }>({
    args: {},
    dataframeArgs: [],
  })
  const haveDataframeArgsChanged = compareDataframeArgs(
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    parsedArgsRef.current.dataframeArgs,
    parsedDataframeArgs
  )
  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  parsedArgsRef.current.args = parsedNewArgs
  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  parsedArgsRef.current.dataframeArgs = parsedDataframeArgs

  const [isReadyTimeout, setIsReadyTimeout] = useState<boolean>()
  // By passing the args.height here, we can derive the initial height for
  // custom components that define a height property, e.g. in Python
  // my_custom_component(height=100). undefined means no explicit height
  // was specified, but will be set to the default height of 0.
  const [frameHeight, setFrameHeight] = useState<number | undefined>(
    isNaN(parsedNewArgs.height) ? undefined : parsedNewArgs.height
  )

  // Use a ref for the ready-state so that we can differentiate between sending renderMessages due to props-changes
  // and when the componentReady callback is called (for the first time)
  const isReadyRef = useRef<boolean>(false)
  const iframeRef = useRef<HTMLIFrameElement>(null)
  const onBackMsgRef = useRef<IframeMessageHandlerProps>()

  // Show a log in the console as a soft-warning to the developer before showing the more disrupting warning element
  const clearTimeoutLog = useTimeout(
    () => logWarning(getWarnMessage(componentName, url)),
    COMPONENT_READY_WARNING_TIME_MS / 4
  )
  const clearTimeoutWarningElement = useTimeout(
    () => setIsReadyTimeout(true),
    COMPONENT_READY_WARNING_TIME_MS
  )

  // Send a render message to the custom component everytime relevant props change, such as the
  // input args or the theme / width
  useEffect(() => {
    if (!isReadyRef.current) {
      return
    }
    sendRenderMessage(
      parsedArgsRef.current.args,
      parsedArgsRef.current.dataframeArgs,
      disabled,
      theme,
      iframeRef.current ?? undefined
    )
  }, [disabled, frameHeight, haveDataframeArgsChanged, jsonArgs, theme, width])

  useEffect(() => {
    const handleSetFrameHeight = (height: number | undefined): void => {
      if (height === undefined) {
        logWarning(`handleSetFrameHeight: missing 'height' prop`)
        return
      }

      if (height === frameHeight) {
        // Nothing to do!
        return
      }

      if (isNullOrUndefined(iframeRef.current)) {
        // This should not be possible.
        logWarning(`handleSetFrameHeight: missing our iframeRef!`)
        return
      }

      // We shove our new frameHeight directly into our iframe, to avoid
      // triggering a re-render. Otherwise, components will receive the RENDER
      // event several times during startup (because they will generally
      // immediately change their frameHeight after mounting). This is wasteful,
      // and it also breaks certain components.
      iframeRef.current.height = height.toString()
      setFrameHeight(height)
    }

    const componentReadyCallback = (): void => {
      // Send a render message whenever the custom component sends a ready message
      sendRenderMessage(
        parsedArgsRef.current.args,
        parsedArgsRef.current.dataframeArgs,
        disabled,
        theme,
        iframeRef.current ?? undefined
      )
      clearTimeoutLog()
      clearTimeoutWarningElement()
      isReadyRef.current = true
      setIsReadyTimeout(false)
    }

    // Update the reference fields for the callback that we
    // passed to the componentRegistry
    onBackMsgRef.current = {
      // isReady is a callback to ensure the caller receives the latest value
      isReady: () => isReadyRef.current,
      element,
      widgetMgr,
      setComponentError,
      componentReadyCallback,
      frameHeightCallback: handleSetFrameHeight,
      fragmentId,
    }
  }, [
    componentName,
    disabled,
    element,
    frameHeight,
    haveDataframeArgsChanged,
    isReadyTimeout,
    jsonArgs,
    theme,
    widgetMgr,
    clearTimeoutWarningElement,
    clearTimeoutLog,
    fragmentId,
  ])

  useEffect(() => {
    const contentWindow: Window | undefined =
      iframeRef.current?.contentWindow ?? undefined
    if (!contentWindow) {
      return
    }
    // By creating the callback using the reference variable, we
    // can access up-to-date information from the component when the callback
    // is called without the need to re-register the callback
    registry.registerListener(
      contentWindow,
      createIframeMessageHandler(onBackMsgRef)
    )

    // De-register component when unmounting and when effect is re-running
    return () => {
      if (!contentWindow) {
        return
      }
      registry.deregisterListener(contentWindow)
    }
  }, [registry, componentName])

  if (componentError) {
    return (
      <ErrorElement
        name={componentError.name}
        message={componentError.message}
      />
    )
  }

  // Show the loading Skeleton while we have not received the ready message from the custom component
  // but while we also have not waited until the ready timeout
  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  const loadingSkeleton = !isReadyRef.current &&
    !isReadyTimeout &&
    // if height is explicitly set to 0, we don’t want to show the skeleton at all
    frameHeight !== 0 && (
      // Skeletons will have a default height if no frameHeight was specified
      <Skeleton
        element={SkeletonProto.create({
          height: frameHeight,
          style: SkeletonProto.SkeletonStyle.ELEMENT,
        })}
      />
    )

  // If we've timed out waiting for the READY message from the component,
  // display a warning.
  const warns =
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    !isReadyRef.current && isReadyTimeout ? (
      <AlertElement
        width={width}
        body={getWarnMessage(componentName, url)}
        kind={Kind.WARNING}
      />
    ) : null

  // Render the iframe. We set scrolling="no", because we don't want
  // scrollbars to appear; instead, we want components to properly auto-size
  // themselves.
  //
  // Without this, there is a potential for a scrollbar to
  // appear for a brief moment after an iframe's content gets bigger,
  // and before it sends the "setFrameHeight" message back to Streamlit.
  //
  // We may ultimately want to give components control over the "scrolling"
  // property.
  //
  // While the custom component is not in ready-state, show the loading Skeleton instead
  //
  // TODO: make sure horizontal scrolling still works!
  return (
    <>
      {loadingSkeleton}
      {warns}
      <StyledComponentIframe
        className="stCustomComponentV1"
        data-testid="stCustomComponentV1"
        allow={DEFAULT_IFRAME_FEATURE_POLICY}
        ref={iframeRef}
        src={getSrc(componentName, registry, url)}
        width={width}
        // for undefined height we set the height to 0 to avoid inconsistent behavior
        height={frameHeight ?? 0}
        scrolling="no"
        sandbox={DEFAULT_IFRAME_SANDBOX_POLICY}
        title={componentName}
        // TODO: Update to match React best practices
        // eslint-disable-next-line react-compiler/react-compiler
        componentReady={isReadyRef.current}
      />
    </>
  )
}

export default withTheme(ComponentInstance)


================================================
File: /frontend/lib/src/components/widgets/CustomComponent/ComponentRegistry.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { mockEndpoints } from "@streamlit/lib/src/mocks/mocks"

import { ComponentRegistry } from "./ComponentRegistry"

describe("ComponentRegistry", () => {
  test("Constructs component URLs", () => {
    const endpoint = mockEndpoints()
    const registry = new ComponentRegistry(endpoint)
    const url = registry.getComponentURL("foo", "index.html")
    expect(url).toEqual(endpoint.buildComponentURL("foo", "index.html"))
  })

  test("Dispatches messages to listeners", () => {
    const registry = new ComponentRegistry(mockEndpoints())
    // @ts-expect-error
    const { onMessageEvent } = registry

    // Create some mocks
    const msgSource1: any = {}
    const msgSource2: any = {}
    const msgListener1 = vi.fn()
    const msgListener2 = vi.fn()

    // This should not error (and will not be handled).
    onMessageEvent(new MessageEvent("message", { source: msgSource1 }))

    // Register a listener for message events from the window.
    registry.registerListener(msgSource1, msgListener1)

    // Send a message to the registry. It should be re-dispatched
    // to our listener.
    const messageData = {
      isStreamlitMessage: true,
      type: "setComponentValue",
    }
    onMessageEvent(
      new MessageEvent("message", { source: msgSource1, data: messageData })
    )
    expect(msgListener1).toHaveBeenCalledWith(messageData.type, messageData)

    // Send a message that's missing data. It should *not* be re-dispatched.
    msgListener1.mockReset()
    onMessageEvent(new MessageEvent("message", { source: msgSource1 }))
    expect(msgListener1).not.toHaveBeenCalled()

    // De-register our listener. Messages should not be re-dispatched.
    msgListener1.mockReset()
    registry.deregisterListener(msgSource1)
    onMessageEvent(
      new MessageEvent("message", { source: msgSource1, data: messageData })
    )
    expect(msgListener1).not.toHaveBeenCalled()

    // Ensure that listeners only receive messages for their own source.
    registry.registerListener(msgSource1, msgListener1)
    registry.registerListener(msgSource2, msgListener2)

    msgListener1.mockReset()
    msgListener2.mockReset()
    onMessageEvent(
      new MessageEvent("message", { source: msgSource1, data: messageData })
    )
    expect(msgListener1).toHaveBeenCalledWith(messageData.type, messageData)
    expect(msgListener2).not.toHaveBeenCalled()

    msgListener1.mockReset()
    msgListener2.mockReset()
    onMessageEvent(
      new MessageEvent("message", { source: msgSource2, data: messageData })
    )
    expect(msgListener1).not.toHaveBeenCalled()
    expect(msgListener2).toHaveBeenCalledWith(messageData.type, messageData)
  })
})


================================================
File: /frontend/lib/src/components/widgets/CustomComponent/ComponentRegistry.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { isNullOrUndefined } from "@streamlit/lib/src/util/utils"
import { logWarning } from "@streamlit/lib/src/util/log"
import { StreamlitEndpoints } from "@streamlit/lib/src/StreamlitEndpoints"

import { ComponentMessageType } from "./enums"

export type ComponentMessageListener = (
  type: ComponentMessageType,
  data: any
) => void

/**
 * Dispatches iframe messages to ComponentInstances.
 */
export class ComponentRegistry {
  private readonly endpoints: StreamlitEndpoints

  private readonly msgListeners = new Map<
    MessageEventSource,
    ComponentMessageListener
  >()

  public constructor(endpoints: StreamlitEndpoints) {
    this.endpoints = endpoints
    window.addEventListener("message", this.onMessageEvent)
  }

  /**
   * Register a listener for component messages dispatched by the given source.
   */
  public registerListener = (
    source: MessageEventSource,
    listener: ComponentMessageListener
  ): void => {
    if (this.msgListeners.has(source)) {
      logWarning(`MessageEventSource registered multiple times!`, source)
    }

    this.msgListeners.set(source, listener)
  }

  public deregisterListener = (source: MessageEventSource): void => {
    const removed = this.msgListeners.delete(source)
    if (!removed) {
      logWarning(`Could not deregister unregistered MessageEventSource!`)
    }
  }

  /** Return a URL for fetching a resource for the given component. */
  public getComponentURL = (componentName: string, path: string): string => {
    return this.endpoints.buildComponentURL(componentName, path)
  }

  private onMessageEvent = (event: MessageEvent): void => {
    if (
      isNullOrUndefined(event.data) ||
      !event.data.hasOwnProperty("isStreamlitMessage")
    ) {
      // Disregard messages that don't come from components.
      return
    }

    if (isNullOrUndefined(event.source)) {
      // This should not be possible.
      logWarning(`Received component message with no eventSource!`, event.data)
      return
    }

    // Get the ComponentInstance associated with the event
    const listener = this.msgListeners.get(event.source)
    if (isNullOrUndefined(listener) || typeof listener !== "function") {
      logWarning(
        `Received component message for unregistered ComponentInstance!`,
        event.data
      )
      return
    }

    const { type } = event.data
    if (isNullOrUndefined(type)) {
      logWarning(`Received Streamlit message with no type!`, event.data)
      return
    }

    // Forward the message on to the appropriate ComponentInstance.
    listener(type, event.data)
  }
}


================================================
File: /frontend/lib/src/components/widgets/CustomComponent/componentUtils.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { RefObject } from "react"

import { Mock } from "vitest"

import { mockTheme } from "@streamlit/lib/src/mocks/mockTheme"
import {
  ArrowDataframe,
  ComponentInstance as ComponentInstanceProto,
} from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"

import {
  createIframeMessageHandler,
  CUSTOM_COMPONENT_API_VERSION,
  IframeMessage,
  IframeMessageHandlerProps,
  parseArgs,
  sendRenderMessage,
} from "./componentUtils"
import { ComponentMessageType, StreamlitMessageType } from "./enums"

// Mock our WidgetStateManager
vi.mock("@streamlit/lib/src/WidgetStateManager")

describe("test componentUtils", () => {
  describe("createIframeMsgHandler", () => {
    const element = ComponentInstanceProto.create({})
    let widgetMgr: WidgetStateManager
    let setComponentError: Mock
    let componentReadyCallback: Mock
    let frameHeightCallback: Mock

    let ref: RefObject<IframeMessageHandlerProps>
    let iframeMessageHandler: (type: string, data: IframeMessage) => void

    beforeEach(() => {
      // Clear our class mocks
      const mockWidgetStateManager = WidgetStateManager as unknown as Mock
      mockWidgetStateManager.mockClear()

      componentReadyCallback = vi.fn()
      frameHeightCallback = vi.fn()
      setComponentError = vi.fn()
      widgetMgr = new WidgetStateManager({
        sendRerunBackMsg: vi.fn(),
        formsDataChanged: vi.fn(),
      })
      ref = {
        current: {
          isReady: () => true,
          element,
          widgetMgr,
          setComponentError,
          componentReadyCallback,
          frameHeightCallback,
        },
      }
      iframeMessageHandler = createIframeMessageHandler(ref)
    })

    it("should call readyCallback when iframeMessageHandler receives COMPONENT_READY message", () => {
      iframeMessageHandler(ComponentMessageType.COMPONENT_READY, {
        apiVersion: CUSTOM_COMPONENT_API_VERSION,
      })
      expect(componentReadyCallback).toBeCalledTimes(1)
    })

    it("should call componentErrorCallback when iframeMessageHandler receives message with wrong API version", () => {
      iframeMessageHandler(ComponentMessageType.COMPONENT_READY, {
        apiVersion: CUSTOM_COMPONENT_API_VERSION + 1,
      })
      expect(componentReadyCallback).toBeCalledTimes(0)
      expect(setComponentError).toBeCalledTimes(1)
    })

    it("should call frameHeightCallback when iframeMessageHandler receives SET_FRAME_HEIGHT message", () => {
      const height = 100
      iframeMessageHandler(ComponentMessageType.SET_FRAME_HEIGHT, {
        height: height,
      })

      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      ref.current!.isReady = () => false
      // when isReady = false, the callback should not be called
      iframeMessageHandler(ComponentMessageType.SET_FRAME_HEIGHT, {
        height: height,
      })

      expect(frameHeightCallback).toBeCalledTimes(1)
      expect(frameHeightCallback).toBeCalledWith(height)
    })

    it("should call widgetManager when iframeMessageHandler receives SET_COMPONENT_VALUE message", () => {
      const jsonValue = { someData: "foo" }
      iframeMessageHandler(ComponentMessageType.SET_COMPONENT_VALUE, {
        value: jsonValue,
        dataType: "json",
      })

      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
      ref.current!.isReady = () => false
      // when isReady = false, the callback should not be called
      iframeMessageHandler(ComponentMessageType.SET_COMPONENT_VALUE, {
        value: jsonValue,
        dataType: "json",
      })

      expect(widgetMgr.setJsonValue).toBeCalledTimes(1)
      expect(widgetMgr.setJsonValue).toHaveBeenCalledWith(
        element,
        jsonValue,
        {
          fromUi: true,
        },
        undefined
      )
    })
  })

  describe("sendRenderMessage", () => {
    it("should send message to iframe", () => {
      const handleAction = vi.fn()

      const mockIframe: any = {
        contentWindow: {
          postMessage: handleAction,
        },
      }

      const args = { foo: "bar" }
      const dataframeArgs = [{ key: "foo", value: "bar" }]
      const disabled = true

      sendRenderMessage(
        args,
        dataframeArgs,
        disabled,
        mockTheme.emotion,
        mockIframe
      )
      expect(handleAction).toBeCalledTimes(1)
      expect(handleAction).toHaveBeenCalledWith(
        {
          type: StreamlitMessageType.RENDER,
          args,
          dfs: dataframeArgs,
          disabled,
          theme: expect.any(Object),
        },
        "*"
      )
    })

    it("should not send message when iframe is undefined", () => {
      const handleAction = vi.fn()

      const mockIframe: any = undefined
      sendRenderMessage({}, [], false, mockTheme.emotion, mockIframe)
      expect(handleAction).toBeCalledTimes(0)
    })

    it("should not send message when iframe's content window is undefined", () => {
      const handleAction = vi.fn()

      const mockIframe: any = {
        contentWindow: undefined,
      }
      sendRenderMessage({}, [], false, mockTheme.emotion, mockIframe)
      expect(handleAction).toBeCalledTimes(0)
    })
  })

  describe("parseArgs", () => {
    it("should parse jsonArgs and specialArgs", () => {
      const args = { foo: "bar", "some-bytes": new Uint8Array(8) }
      const someBytes = new Uint8Array(8)
      // set one byte to a different value
      someBytes[1] = 10
      const arrowDataframe = new ArrowDataframe()
      arrowDataframe.height = 100
      const specialArgs = [
        {
          key: "some-dataframe",
          value: "arrowDataFrame",
          arrowDataframe: arrowDataframe,
        },
        {
          key: "some-bytes",
          value: "bytes",
          bytes: someBytes,
        },
      ]

      const [newArgs, dataframeArgs] = parseArgs(
        JSON.stringify(args),
        specialArgs
      )
      expect(newArgs).toMatchObject({ foo: "bar", "some-bytes": someBytes })
      expect(dataframeArgs).toMatchObject([
        {
          key: "some-dataframe",
          value: arrowDataframe,
        },
      ])
    })

    it("should throw an error with with unknown specialArgs type", () => {
      const args = {}
      const specialArgs = [
        {
          key: "some-dataframe",
          value: "some-unknown-type",
        },
      ]

      expect(() => parseArgs(JSON.stringify(args), specialArgs)).toThrowError(
        Error
      )
    })
  })
})


================================================
File: /frontend/lib/src/components/widgets/CustomComponent/componentUtils.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { isNullOrUndefined } from "@streamlit/lib/src/util/utils"
import { logWarning } from "@streamlit/lib/src/util/log"
import {
  ArrowDataframe,
  ComponentInstance as ComponentInstanceProto,
  ISpecialArg,
  SpecialArg as SpecialArgProto,
} from "@streamlit/lib/src/proto"
import { EmotionTheme, toExportedTheme } from "@streamlit/lib/src/theme"
import {
  Source,
  WidgetStateManager,
} from "@streamlit/lib/src/WidgetStateManager"

import { ComponentMessageType, StreamlitMessageType } from "./enums"

// The custom component's value posted from the iFrame has one of the three types as defined
// in component-lib/
export type ValueType = "bytes" | "dataframe" | "json"

// Define types for messages being sent from the custom component
// The types are also defined in the component-lib/ module, and we can
// replace these here when we have a shared module. Until then,
// the typing is hopefully at least a little bit helpful for devs.
type ReadyMessage = {
  apiVersion: number
}
type ComponentValueMessage = {
  /* the value sent from the custom component can be anything */
  value: any
  dataType: ValueType
}
type FrameHeightMessage = {
  height: number
}
export type IframeMessage =
  | ReadyMessage
  | ComponentValueMessage
  | FrameHeightMessage

export interface IframeMessageHandlerProps {
  isReady: () => boolean
  element: ComponentInstanceProto
  widgetMgr: WidgetStateManager
  setComponentError: (error: Error) => void
  componentReadyCallback: () => void
  frameHeightCallback: (height: number | undefined) => void
  fragmentId?: string
}

export interface Args {
  [name: string]: any
}
export interface DataframeArg {
  key: string
  value: any
}

/**
 * The current custom component API version. If our API changes,
 * this value must be incremented. ComponentInstances send their API
 * version in the COMPONENT_READY call.
 */
export const CUSTOM_COMPONENT_API_VERSION = 1

/**
 * Create a callback to be passed to  {@link ComponentRegistry#registerListener}.
 * The passed callbacks RefObject is used in the returned function to access
 * the current fields of the reference when the callback is executed by the ComponentRegistry.
 * This ref-approach allows us to register the listener callback in a functional component only once
 * instead of keeping registering / unregistering multiple times.
 *
 * @param callbacks a ref object containing actual callbacks
 * @returns the callback function to be passed to {@link ComponentRegistry#registerListener}
 */
export function createIframeMessageHandler(
  callbacks: React.RefObject<IframeMessageHandlerProps | undefined>
): (type: string, data: IframeMessage) => void {
  return (type: string, data: IframeMessage): void => {
    if (!callbacks.current) {
      return undefined
    }

    // we receive the callbacks as a reference, so that we can use the
    //  newest version whenever the callback is called without the need
    //  to register the callback to the outside
    const {
      isReady: readyCheck,
      element,
      widgetMgr,
      setComponentError,
      componentReadyCallback,
      frameHeightCallback,
      fragmentId,
    } = callbacks.current
    const isReady = readyCheck()

    switch (type) {
      case ComponentMessageType.COMPONENT_READY: {
        // Our component is ready to begin receiving messages. Send off its
        // first render message! It is *not* an error to get multiple
        // COMPONENT_READY messages. This can happen if a component is being
        // served from the webpack dev server, and gets reloaded. We
        // always respond to this message with the most recent render
        // arguments.
        const { apiVersion } = data as ReadyMessage
        if (apiVersion !== CUSTOM_COMPONENT_API_VERSION) {
          // In the future, we may end up with multiple API versions we
          // need to support. For now, we just have the one.
          setComponentError(
            new Error(`Unrecognized component API version: '${apiVersion}'`)
          )
        } else {
          componentReadyCallback()
        }
        break
      }

      case ComponentMessageType.SET_COMPONENT_VALUE:
        if (!isReady) {
          logWarning(
            `Got ${type} before ${ComponentMessageType.COMPONENT_READY}!`
          )
        } else {
          handleSetComponentValue(
            tryGetValue(data, "value"),
            (data as ComponentValueMessage).dataType,
            { fromUi: true },
            element,
            widgetMgr,
            fragmentId
          )
        }
        break

      case ComponentMessageType.SET_FRAME_HEIGHT:
        if (!isReady) {
          logWarning(
            `Got ${type} before ${ComponentMessageType.COMPONENT_READY}!`
          )
        } else {
          frameHeightCallback(
            tryGetValue(data as FrameHeightMessage, "height")
          )
        }
        break

      default:
        logWarning(`Unrecognized ComponentBackMsgType: ${type}`)
    }
  }
}

/**
 * Parse incoming arguments and bring them into a new form.
 *
 * The `jsonArgs` are parsed to a JSON object.
 * The `specialArgs` are transformed:
 * - `specialArgs[{ key, value: 'arrowdataframe', arrowDataFrame }]` to `dataFrameArgs[{ key, value: arrowDataFrame }]`
 * - `specialArgs[{ key, value: 'bytes', bytes }]` to `newArgs{key: bytes}`
 *
 * This means that byte-values from `specialArgs` override entries in `jsonArgs` when having the same key
 *
 * @param jsonArgs JSON-string
 * @param specialArgs array of objects that hold special-typed values
 * @throws Error when `specialArgs` contains unrecognized type
 * @returns
 */
export function parseArgs(
  jsonArgs: string,
  specialArgs: ISpecialArg[]
): [newArgs: Args, dataframeArgs: DataframeArg[]] {
  // Parse arguments. Our JSON arguments are just stored in a JSON string.
  const newArgs: Args = JSON.parse(jsonArgs)

  // Some notes re: data marshalling:
  //
  // Non-JSON arguments are sent from Python in the "specialArgs"
  // protobuf list. We get DataFrames and Bytes from this list (and
  // any further non-JSON datatypes we add support for down the road will
  // also go into it).
  //
  // We don't forward raw protobuf objects onto the iframe, however.
  // Instead, JSON args and Bytes args are shipped to the iframe together
  // in a plain old JS Object called `args`.
  //
  // But! Because dataframes are delivered as instances of our custom
  // "ArrowTable" class, they can't be sent to the iframe in this same
  // `args` object. Instead, raw DataFrame data is delivered to the iframe
  // in a separate Array. The iframe then constructs the required
  // ArrowTable instances and inserts them into the `args` array itself.
  const dataframeArgs: DataframeArg[] = []
  for (const specialArg of specialArgs as SpecialArgProto[]) {
    const { key } = specialArg
    switch (specialArg.value?.toLowerCase()) {
      case "arrowdataframe":
        dataframeArgs.push({
          key,
          value: ArrowDataframe.toObject(
            specialArg.arrowDataframe as ArrowDataframe
          ),
        })
        break

      case "bytes":
        newArgs[key] = specialArg.bytes
        break

      default:
        throw new Error(`Unrecognized SpecialArg type: ${specialArg.value}`)
    }
  }

  return [newArgs, dataframeArgs]
}

/**
 * Send a RENDER message to the component with the most recent arguments
 * received from Python.
 */
export function sendRenderMessage(
  currentArgs: Args,
  currentDataframeArgs: DataframeArg[],
  disabled: boolean,
  theme: EmotionTheme,
  iframe?: HTMLIFrameElement
): void {
  if (!iframe) {
    // This should never happen!
    logWarning("Can't send ForwardMsg; missing our iframe!")
    return
  }

  if (isNullOrUndefined(iframe.contentWindow)) {
    // Nor should this!
    logWarning("Can't send ForwardMsg; iframe has no contentWindow!")
    return
  }

  // NB: if you change or remove any of the arguments here, you'll break
  // existing components. You can *add* more arguments safely, but any
  // other modifications require a CUSTOM_COMPONENT_API_VERSION bump.
  iframe.contentWindow.postMessage(
    {
      type: StreamlitMessageType.RENDER,
      args: currentArgs,
      dfs: currentDataframeArgs,
      disabled: disabled,
      theme: toExportedTheme(theme),
    },
    "*"
  )
}

/**
 * Set the component's value in the widgetManager to be passed to the backend
 * @param value posted by the custom component. Can be anything
 * @param dataType of the passed value. Determines the proto field type. See {@link ValueType}
 * @param source specifies from where the value is coming
 * @param element the element to which the value belongs
 * @param widgetMgr the widget manager to report the value to
 * @returns undefined
 */
function handleSetComponentValue(
  value: any, // we do not know what data the custom component is sending us, so we use 'any' here
  dataType: ValueType,
  source: Source,
  element: ComponentInstanceProto,
  widgetMgr: WidgetStateManager,
  fragmentId?: string
): void {
  if (value === undefined) {
    logWarning(`handleSetComponentValue: missing 'value' prop`)
    return
  }

  switch (dataType) {
    case "dataframe":
      widgetMgr.setArrowValue(element, value, source, fragmentId)
      break
    case "bytes":
      widgetMgr.setBytesValue(element, value, source, fragmentId)
      break
    default:
      widgetMgr.setJsonValue(element, value, source, fragmentId)
  }
}

/** Return the property with the given name, if it exists. */
function tryGetValue(
  obj: any,
  name: string,
  defaultValue: any = undefined
): any {
  return obj.hasOwnProperty(name) ? obj[name] : defaultValue
}


================================================
File: /frontend/lib/src/components/widgets/CustomComponent/enums.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/** Messages from Component -> Streamlit */
export enum ComponentMessageType {
  // A component sends this message when it's ready to receive messages
  // from Streamlit. Streamlit won't send any messages until it gets this.
  // Data: { apiVersion: number }
  COMPONENT_READY = "streamlit:componentReady",

  // The component has a new value. Send it back to Streamlit, which
  // will then re-run the app.
  // Data: { value: any }
  SET_COMPONENT_VALUE = "streamlit:setComponentValue",

  // The component has a new height for its iframe.
  // Data: { height: number }
  SET_FRAME_HEIGHT = "streamlit:setFrameHeight",
}

/** Messages from Streamlit -> Component */
export enum StreamlitMessageType {
  // Sent by Streamlit when the component should re-render.
  // Data: {
  //  args: { [name: string]: any },  // dict of JSON and bytes args
  //  dfs: any[],  // list of {name: string, df: ArrowTable} pairs
  //  disabled: boolean
  // }
  RENDER = "streamlit:render",
}


================================================
File: /frontend/lib/src/components/widgets/CustomComponent/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default as ComponentInstance } from "./ComponentInstance"
export { ComponentRegistry } from "./ComponentRegistry"


================================================
File: /frontend/lib/src/components/widgets/CustomComponent/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

interface StyledComponentIframeProps {
  componentReady: boolean
}

export const StyledComponentIframe = styled.iframe<StyledComponentIframeProps>(
  ({ theme, componentReady }) => ({
    colorScheme: "normal",
    border: "none",
    padding: theme.spacing.none,
    margin: theme.spacing.none,
    display: componentReady ? "initial" : "none",
  })
)


================================================
File: /frontend/lib/src/components/widgets/DataFrame/DataFrame.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import * as glideDataGridModule from "@glideapps/glide-data-grid"

import { TEN_BY_TEN } from "@streamlit/lib/src/mocks/arrow"
import { render } from "@streamlit/lib/src/test_util"
import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import { Arrow as ArrowProto } from "@streamlit/lib/src/proto"

vi.mock("@glideapps/glide-data-grid", async () => ({
  ...(await vi.importActual("@glideapps/glide-data-grid")),
  DataEditor: vi.fn(props => <div {...props} />),
}))

// The native-file-system-adapter creates some issues in the test environment
// so we mock it out. The errors might be related to the missing typescript
// distribution. But the file picker most likely wouldn't work anyways in jest-dom.
vi.mock("native-file-system-adapter", () => ({}))

import DataFrame, { DataFrameProps } from "./DataFrame"

const getProps = (
  data: Quiver,
  useContainerWidth = false,
  editingMode: ArrowProto.EditingMode = ArrowProto.EditingMode.READ_ONLY
): DataFrameProps => ({
  element: ArrowProto.create({
    data: new Uint8Array(),
    useContainerWidth,
    width: 400,
    height: 400,
    editingMode,
  }),
  data,
  width: 700,
  disabled: false,
  widgetMgr: {
    getStringValue: vi.fn(),
  } as any,
})

const { ResizeObserver } = window

describe("DataFrame widget", () => {
  const props = getProps(new Quiver({ data: TEN_BY_TEN }))

  beforeEach(() => {
    // Mocking ResizeObserver to prevent:
    // TypeError: window.ResizeObserver is not a constructor
    // @ts-expect-error
    delete window.ResizeObserver
    window.ResizeObserver = vi.fn().mockImplementation(() => ({
      observe: vi.fn(),
      unobserve: vi.fn(),
      disconnect: vi.fn(),
    }))
  })

  afterEach(() => {
    window.ResizeObserver = ResizeObserver
    vi.restoreAllMocks()
  })

  it("renders without crashing", () => {
    render(<DataFrame {...props} />)
    expect(screen.getAllByTestId("stDataFrameResizable").length).toBe(1)
  })

  it("should have correct className", () => {
    render(<DataFrame {...props} />)

    const styledResizableContainer = screen.getByTestId("stDataFrame")

    expect(styledResizableContainer).toHaveClass("stDataFrame")
  })

  it("grid container should use full width when useContainerWidth is used", () => {
    render(<DataFrame {...getProps(new Quiver({ data: TEN_BY_TEN }), true)} />)
    const dfStyle = getComputedStyle(
      screen.getByTestId("stDataFrameResizable")
    )
    expect(dfStyle.width).toBe("700px")
    expect(dfStyle.height).toBe("400px")
  })

  it("grid container should render with specific size", () => {
    render(<DataFrame {...props} />)
    const dfStyle = getComputedStyle(
      screen.getByTestId("stDataFrameResizable")
    )
    expect(dfStyle.width).toBe("400px")
    expect(dfStyle.height).toBe("400px")
  })

  it("should have a toolbar", () => {
    render(<DataFrame {...props} />)

    const dataframeToolbar = screen.getByTestId("stElementToolbar")

    expect(dataframeToolbar).toBeInTheDocument()

    const toolbarButtons = screen.getAllByTestId("stElementToolbarButton")
    expect(toolbarButtons).toHaveLength(3)
  })

  it("Touch detection correctly deactivates some features", () => {
    // Set window.matchMedia to simulate a touch device
    window.matchMedia = vi.fn().mockImplementation(() => ({
      matches: true,
    }))

    render(
      <DataFrame
        {...getProps(
          new Quiver({ data: TEN_BY_TEN }),
          true,
          ArrowProto.EditingMode.FIXED
        )}
      />
    )
    // You have to set a second arg with {} to test work and get the received props
    expect(glideDataGridModule.DataEditor).toHaveBeenCalledWith(
      expect.objectContaining({
        rangeSelect: "cell",
        fillHandle: false,
        onColumnResize: undefined,
      }),
      {}
    )
  })
})


================================================
File: /frontend/lib/src/components/widgets/DataFrame/DataFrame.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import {
  CompactSelection,
  DataEditorRef,
  DataEditor as GlideDataEditor,
  GridCell,
  Item as GridCellPosition,
  GridMouseEventArgs,
  GridSelection,
} from "@glideapps/glide-data-grid"
import { Resizable } from "re-resizable"
import {
  Add,
  Close,
  Delete,
  FileDownload,
  Search,
} from "@emotion-icons/material-outlined"

import { useFormClearHelper } from "@streamlit/lib/src/components/widgets/Form"
import { withFullScreenWrapper } from "@streamlit/lib/src/components/shared/FullScreenWrapper"
import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import { Arrow as ArrowProto } from "@streamlit/lib/src/proto"
import {
  WidgetInfo,
  WidgetStateManager,
} from "@streamlit/lib/src/WidgetStateManager"
import { isNullOrUndefined } from "@streamlit/lib/src/util/utils"
import Toolbar, {
  ToolbarAction,
} from "@streamlit/lib/src/components/shared/Toolbar"
import { LibContext } from "@streamlit/lib/src/components/core/LibContext"
import { ElementFullscreenContext } from "@streamlit/lib/src/components/shared/ElementFullscreen/ElementFullscreenContext"
import { useRequiredContext } from "@streamlit/lib/src/hooks/useRequiredContext"
import { useDebouncedCallback } from "@streamlit/lib/src/hooks/useDebouncedCallback"

import EditingState, { getColumnName } from "./EditingState"
import {
  useColumnLoader,
  useColumnPinning,
  useColumnReordering,
  useColumnSizer,
  useColumnSort,
  useCustomRenderer,
  useCustomTheme,
  useDataEditor,
  useDataExporter,
  useDataLoader,
  useRowHover,
  useSelectionHandler,
  useTableSizer,
  useTooltips,
} from "./hooks"
import { getTextCell, ImageCellEditor, toGlideColumn } from "./columns"
import Tooltip from "./Tooltip"
import { StyledResizableContainer } from "./styled-components"

import "@glideapps/glide-data-grid/dist/index.css"
import "@glideapps/glide-data-grid-cells/dist/index.css"

// Debounce time for triggering a widget state update
// This prevents rapid updates to the widget state.
const DEBOUNCE_TIME_MS = 150
// Number of rows that triggers some optimization features
// for large tables.
const LARGE_TABLE_ROWS_THRESHOLD = 150000
// The size in px of the customized webkit scrollbar (defined in globalStyles)
const WEBKIT_SCROLLBAR_SIZE = 6

// This is the state that is sent to the backend
// This needs to be the same structure that is also defined
// in the Python code.
export interface DataframeState {
  selection: {
    rows: number[]
    // We use column names instead of indices to make
    // it easier to use and unify with how data editor edits
    // are stored.
    columns: string[]
  }
}

export interface DataFrameProps {
  element: ArrowProto
  data: Quiver
  disabled: boolean
  widgetMgr: WidgetStateManager
  disableFullscreenMode?: boolean
  fragmentId?: string
  width: number
  height?: number
}

/**
 * The main component used by dataframe & data_editor to render an editable table.
 *
 * @param element - The element's proto message
 * @param data - The Arrow data to render (extracted from the proto message)
 * @param disabled - Whether the widget is disabled
 * @param widgetMgr - The widget manager
 */
function DataFrame({
  element,
  data,
  disabled,
  widgetMgr,
  disableFullscreenMode,
  fragmentId,
}: Readonly<DataFrameProps>): ReactElement {
  const {
    expanded: isFullScreen,
    expand,
    collapse,
    width: containerWidth,
    height: containerHeight,
  } = useRequiredContext(ElementFullscreenContext)

  const resizableRef = React.useRef<Resizable>(null)
  const dataEditorRef = React.useRef<DataEditorRef>(null)
  const resizableContainerRef = React.useRef<HTMLDivElement>(null)

  const gridTheme = useCustomTheme()

  const { getRowThemeOverride, onItemHovered: handleRowHover } =
    useRowHover(gridTheme)

  const {
    libConfig: { enforceDownloadInNewTab = false }, // Default to false, if no libConfig, e.g. for tests
  } = React.useContext(LibContext)

  const [isFocused, setIsFocused] = React.useState<boolean>(true)
  const [showSearch, setShowSearch] = React.useState(false)
  const [hasVerticalScroll, setHasVerticalScroll] =
    React.useState<boolean>(false)
  const [hasHorizontalScroll, setHasHorizontalScroll] =
    React.useState<boolean>(false)

  // Determine if the device is primary using touch as input:
  const isTouchDevice = React.useMemo<boolean>(
    () => window.matchMedia && window.matchMedia("(pointer: coarse)").matches,
    []
  )

  // Determine if it uses customized scrollbars (webkit browsers):
  // https://developer.mozilla.org/en-US/docs/Web/CSS/::-webkit-scrollbar#css.selectors.-webkit-scrollbar
  const hasCustomizedScrollbars = React.useMemo<boolean>(
    () =>
      (window.navigator.userAgent.includes("Mac OS") &&
        window.navigator.userAgent.includes("Safari")) ||
      window.navigator.userAgent.includes("Chrome"),
    []
  )

  // This is done to keep some backwards compatibility
  // so that old arrow proto messages from the st.dataframe
  // would still work. Those messages don't have the
  // editingMode field defined.
  if (isNullOrUndefined(element.editingMode)) {
    element.editingMode = ArrowProto.EditingMode.READ_ONLY
  }

  const { READ_ONLY, DYNAMIC } = ArrowProto.EditingMode

  // Number of rows of the table minus 1 for the header row:
  const dataDimensions = data.dimensions
  const originalNumRows = Math.max(0, dataDimensions.numDataRows)

  // For empty tables, we show an extra row that
  // contains "empty" as a way to indicate that the table is empty.
  const isEmptyTable =
    originalNumRows === 0 &&
    // We don't show empty state for dynamic mode with a table that has
    // data columns defined.
    !(element.editingMode === DYNAMIC && dataDimensions.numDataColumns > 0)

  // For large tables, we apply some optimizations to handle large data
  const isLargeTable = originalNumRows > LARGE_TABLE_ROWS_THRESHOLD

  const editingState = React.useRef<EditingState>(
    new EditingState(originalNumRows)
  )

  const [numRows, setNumRows] = React.useState(
    editingState.current.getNumRows()
  )

  React.useEffect(() => {
    editingState.current = new EditingState(originalNumRows)
    setNumRows(editingState.current.getNumRows())
  }, [originalNumRows])

  const resetEditingState = React.useCallback(() => {
    editingState.current = new EditingState(originalNumRows)
    setNumRows(editingState.current.getNumRows())
  }, [originalNumRows])

  const [columnOrder, setColumnOrder] = React.useState(element.columnOrder)

  const { columns: originalColumns, setColumnConfigMapping } = useColumnLoader(
    element,
    data,
    disabled,
    columnOrder
  )

  /**
   * On the first rendering, try to load initial widget state if
   * it exists. This is required in the case that other elements
   * are inserted before this widget. In this case, it can happen
   * that the dataframe component is unmounted and thereby loses
   * its state. Once the same element is rendered again, we try to
   * reconstruct the state from the widget manager values.
   */
  React.useEffect(
    () => {
      if (element.editingMode === READ_ONLY) {
        // We don't need to load the initial widget state
        // for read-only dataframes.
        return
      }

      const initialWidgetValue = widgetMgr.getStringValue({
        id: element.id,
        formId: element.formId,
      } as WidgetInfo)

      if (!initialWidgetValue) {
        // No initial widget value was saved in the widget manager.
