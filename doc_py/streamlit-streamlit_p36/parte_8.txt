      </Fragment>
    )

    expect(screen.getByTestId("stDialog")).toBeInTheDocument()
    // regex that is anything after Streamlit v
    const versionRegex = /^Streamlit v.*/
    const nonExistentText = screen.queryByText(versionRegex)
    expect(nonExistentText).not.toBeInTheDocument()
  })
})


================================================
File: /frontend/app/src/components/StreamlitDialog/StreamlitDialog.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { CSSProperties, ReactElement, ReactNode } from "react"

import {
  BaseButtonKind,
  IException,
  Modal,
  ModalBody,
  ModalButton,
  ModalFooter,
  ModalHeader,
  SessionInfo,
  StreamlitMarkdown,
  StreamlitSyntaxHighlighter,
} from "@streamlit/lib"
import { STREAMLIT_HOME_URL } from "@streamlit/app/src/urls"

import { SettingsDialog, Props as SettingsDialogProps } from "./SettingsDialog"
import ThemeCreatorDialog, {
  Props as ThemeCreatorDialogProps,
} from "./ThemeCreatorDialog"
import { DeployDialog, DeployDialogProps } from "./DeployDialog"
import {
  StyledAboutInfo,
  StyledAboutLink,
  StyledDeployErrorContent,
} from "./styled-components"

export type PlainEventHandler = () => void

interface SettingsProps extends SettingsDialogProps {
  type: DialogType.SETTINGS
}

interface ThemeCreatorProps extends ThemeCreatorDialogProps {
  type: DialogType.THEME_CREATOR
}

export type DialogProps =
  | AboutProps
  | ClearCacheProps
  | SettingsProps
  | ScriptCompileErrorProps
  | ThemeCreatorProps
  | WarningProps
  | DeployErrorProps
  | DeployDialogProps

export enum DialogType {
  ABOUT = "about",
  CLEAR_CACHE = "clearCache",
  SETTINGS = "settings",
  SCRIPT_COMPILE_ERROR = "scriptCompileError",
  THEME_CREATOR = "themeCreator",
  WARNING = "warning",
  DEPLOY_ERROR = "deployError",
  DEPLOY_DIALOG = "deployDialog",
}

export function StreamlitDialog(dialogProps: DialogProps): ReactNode {
  switch (dialogProps.type) {
    case DialogType.ABOUT:
      return aboutDialog(dialogProps)
    case DialogType.CLEAR_CACHE:
      return clearCacheDialog(dialogProps)
    case DialogType.SETTINGS:
      return settingsDialog(dialogProps)
    case DialogType.SCRIPT_COMPILE_ERROR:
      return scriptCompileErrorDialog(dialogProps)
    case DialogType.THEME_CREATOR:
      return <ThemeCreatorDialog {...dialogProps} />
    case DialogType.WARNING:
      return warningDialog(dialogProps)
    case DialogType.DEPLOY_DIALOG:
      return <DeployDialog {...dialogProps} />
    case DialogType.DEPLOY_ERROR:
      return deployErrorDialog(dialogProps)
    case undefined:
      return noDialog(dialogProps)
    default:
      return typeNotRecognizedDialog(dialogProps)
  }
}

interface AboutProps {
  type: DialogType.ABOUT

  sessionInfo: SessionInfo

  /** Callback to close the dialog */
  onClose: PlainEventHandler

  aboutSectionMd?: string | null
}

/** About Dialog */
function aboutDialog(props: AboutProps): ReactElement {
  if (props.aboutSectionMd) {
    const markdownStyle: CSSProperties = {
      overflowY: "auto",
      overflowX: "hidden",
      maxHeight: "35vh",
    }

    // Markdown New line is 2 spaces + \n
    const newLineMarkdown = "  \n"
    const StreamlitInfo = [
      `Made with Streamlit v${props.sessionInfo.current.streamlitVersion}`,
      STREAMLIT_HOME_URL,
      `Copyright ${new Date().getFullYear()} Snowflake Inc. All rights reserved.`,
    ].join(newLineMarkdown)

    const source = `${props.aboutSectionMd} ${newLineMarkdown} ${newLineMarkdown} ${StreamlitInfo}`

    return (
      <Modal isOpen onClose={props.onClose}>
        <ModalHeader>About</ModalHeader>
        <ModalBody>
          <StyledAboutInfo>
            <StreamlitMarkdown
              source={source}
              allowHTML={false}
              style={markdownStyle}
            />
          </StyledAboutInfo>
        </ModalBody>
      </Modal>
    )
  }
  return (
    <Modal isOpen onClose={props.onClose}>
      <ModalHeader>Made with</ModalHeader>
      <ModalBody>
        <div>
          {/* Show our version string only if SessionInfo has been created. If Streamlit
          hasn't yet connected to the server, the SessionInfo singleton will be null. */}
          {props.sessionInfo.isSet && (
            <>
              Streamlit v{props.sessionInfo.current.streamlitVersion}
              <br />
            </>
          )}
          <StyledAboutLink href={STREAMLIT_HOME_URL}>
            {STREAMLIT_HOME_URL}
          </StyledAboutLink>
          <br />
          Copyright {new Date().getFullYear()} Snowflake Inc. All rights
          reserved.
        </div>
      </ModalBody>
    </Modal>
  )
}

interface ClearCacheProps {
  type: DialogType.CLEAR_CACHE
  /** callback to send the clear_cache request to the Proxy */
  confirmCallback: () => void

  /** callback to close the dialog */
  onClose: PlainEventHandler

  /** callback to run the default action */
  defaultAction: () => void
}

/**
 * Dialog shown when the user wants to clear the cache.
 *
 * confirmCallback - callback to send the clear_cache request to the Proxy
 * onClose         - callback to close the dialog
 */
function clearCacheDialog(props: ClearCacheProps): ReactElement {
  // Markdown New line is 2 spaces + \n
  const newLineMarkdown = "  \n"
  const clearCacheInfo = [
    `**Are you sure you want to clear the app's function caches?**`,
    "This will remove all cached entries from functions using",
    "`@st.cache_data` and `@st.cache_resource`.",
  ].join(newLineMarkdown)

  return (
    <div data-testid="stClearCacheDialog">
      <Modal isOpen onClose={props.onClose}>
        <ModalHeader>Clear caches</ModalHeader>
        <ModalBody>
          <StreamlitMarkdown source={clearCacheInfo} allowHTML={false} />
        </ModalBody>
        <ModalFooter>
          <ModalButton kind={BaseButtonKind.GHOST} onClick={props.onClose}>
            Cancel
          </ModalButton>
          <ModalButton
            autoFocus
            kind={BaseButtonKind.SECONDARY}
            onClick={props.confirmCallback}
          >
            Clear caches
          </ModalButton>
        </ModalFooter>
      </Modal>
    </div>
  )
}

interface ScriptCompileErrorProps {
  type: DialogType.SCRIPT_COMPILE_ERROR
  exception: IException | null | undefined
  onClose: PlainEventHandler
}

function scriptCompileErrorDialog(
  props: ScriptCompileErrorProps
): ReactElement {
  return (
    <Modal isOpen onClose={props.onClose} size="auto" autoFocus={false}>
      <ModalHeader>Script execution error</ModalHeader>
      <ModalBody>
        <StreamlitSyntaxHighlighter showLineNumbers={false} wrapLines={false}>
          {props.exception?.message ? props.exception.message : "No message"}
        </StreamlitSyntaxHighlighter>
      </ModalBody>
      <ModalFooter>
        <ModalButton kind={BaseButtonKind.SECONDARY} onClick={props.onClose}>
          Close
        </ModalButton>
      </ModalFooter>
    </Modal>
  )
}

/**
 * Shows the settings dialog.
 */
function settingsDialog(props: SettingsProps): ReactElement {
  return <SettingsDialog {...props} />
}

interface WarningProps {
  type: DialogType.WARNING
  title: string
  msg: ReactNode
  onClose: PlainEventHandler
}

/**
 * Prints out a warning
 */
function warningDialog(props: WarningProps): ReactElement {
  return (
    <Modal isOpen onClose={props.onClose}>
      <ModalHeader>{props.title}</ModalHeader>
      <ModalBody>{props.msg}</ModalBody>
    </Modal>
  )
}

interface DeployErrorProps {
  type: DialogType.DEPLOY_ERROR
  title: string
  msg: ReactNode
  onClose: PlainEventHandler
  onContinue?: PlainEventHandler
  onTryAgain: PlainEventHandler
}

/**
 * Modal used to show deployment errors
 */
function deployErrorDialog({
  title,
  msg,
  onClose,
  onContinue,
  onTryAgain,
}: DeployErrorProps): ReactElement {
  const handlePrimaryButton = (): void => {
    onClose()

    if (onContinue) {
      onContinue()
    }
  }

  return (
    <Modal isOpen onClose={onClose}>
      <ModalHeader>{title}</ModalHeader>
      <ModalBody>
        <StyledDeployErrorContent>{msg}</StyledDeployErrorContent>
      </ModalBody>
      <ModalFooter>
        <ModalButton kind={BaseButtonKind.GHOST} onClick={onTryAgain}>
          Try again
        </ModalButton>
        <ModalButton
          kind={BaseButtonKind.SECONDARY}
          onClick={handlePrimaryButton}
        >
          {onContinue ? "Continue anyway" : "Close"}
        </ModalButton>
      </ModalFooter>
    </Modal>
  )
}

/**
 * Returns an empty dictionary, indicating that no object is to be displayed.
 */
function noDialog({ onClose }: { onClose: PlainEventHandler }): ReactElement {
  return <Modal isOpen={false} onClose={onClose} />
}

interface NotRecognizedProps {
  type: string
  onClose: PlainEventHandler
}

/**
 * If the dialog type is not recognized, display this dialog.
 */
function typeNotRecognizedDialog(props: NotRecognizedProps): ReactElement {
  return (
    <Modal isOpen onClose={props.onClose}>
      <ModalBody>{`Dialog type "${props.type}" not recognized.`}</ModalBody>
    </Modal>
  )
}


================================================
File: /frontend/app/src/components/StreamlitDialog/ThemeCreatorDialog.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { fireEvent, screen, within } from "@testing-library/react"

import {
  customRenderLibContext,
  CustomThemeConfig,
  darkTheme,
  fonts,
  LibContextProps,
  lightTheme,
  mockSessionInfo,
  toThemeInput,
} from "@streamlit/lib"
import { MetricsManager } from "@streamlit/app/src/MetricsManager"

import ThemeCreatorDialog, {
  Props as ThemeCreatorDialogProps,
  toMinimalToml,
} from "./ThemeCreatorDialog"

const mockSetTheme = vi.fn()
const mockAddThemes = vi.fn()

const getProps = (
  props: Partial<ThemeCreatorDialogProps> = {}
): ThemeCreatorDialogProps => ({
  backToSettings: vi.fn(),
  onClose: vi.fn(),
  metricsMgr: new MetricsManager(mockSessionInfo()),
  ...props,
})

const getContext = (
  extend?: Partial<LibContextProps>
): Partial<LibContextProps> => ({
  activeTheme: lightTheme,
  setTheme: mockSetTheme,
  availableThemes: [],
  addThemes: mockAddThemes,
  ...extend,
})

Object.assign(navigator, {
  clipboard: {
    writeText: vi.fn(),
  },
})

describe("Renders ThemeCreatorDialog", () => {
  it("renders theme creator dialog", () => {
    const availableThemes = [lightTheme, darkTheme]
    const props = getProps()
    const context = getContext({ availableThemes })
    customRenderLibContext(<ThemeCreatorDialog {...props} />, context)

    expect(screen.getByTestId("stThemeCreatorDialog")).toBeInTheDocument()
    expect(screen.getByText("Edit active theme")).toBeInTheDocument()
  })
})

describe("toMinimalToml", () => {
  it("outputs the correct config for the preset lightTheme", () => {
    const themeInput = toThemeInput(lightTheme.emotion)
    expect(toMinimalToml(themeInput)).toBe(`[theme]
base="light"
`)
  })

  it("is not case sensitive with color hex codes", () => {
    const themeInput = {
      ...toThemeInput(lightTheme.emotion),
      backgroundColor: "#fFfFff",
    }
    expect(toMinimalToml(themeInput)).toBe(`[theme]
base="light"
`)
  })

  it("sets base = light when closer to lightTheme", () => {
    const themeInput = {
      ...toThemeInput(lightTheme.emotion),
      primaryColor: "blue",
    }
    expect(toMinimalToml(themeInput)).toBe(`[theme]
base="light"
primaryColor="blue"
`)
  })

  it("outputs the correct config for the preset darkTheme", () => {
    const themeInput = toThemeInput(darkTheme.emotion)
    expect(toMinimalToml(themeInput)).toBe(`[theme]
base="dark"
`)
  })

  it("sets base = dark when closer to darkTheme", () => {
    const themeInput = {
      ...toThemeInput(darkTheme.emotion),
      primaryColor: "blue",
    }
    expect(toMinimalToml(themeInput)).toBe(`[theme]
base="dark"
primaryColor="blue"
`)
  })

  it("does not set base if all non-primaryColor color options are set", () => {
    const themeInput = {
      ...toThemeInput(darkTheme.emotion),
      backgroundColor: "red",
      secondaryBackgroundColor: "blue",
      textColor: "purple",
    }
    expect(toMinimalToml(themeInput)).toBe(`[theme]
backgroundColor="red"
secondaryBackgroundColor="blue"
textColor="purple"
`)
  })

  it("does not set base if all color options are set", () => {
    const themeInput = {
      ...toThemeInput(darkTheme.emotion),
      primaryColor: "pink",
      backgroundColor: "red",
      secondaryBackgroundColor: "blue",
      textColor: "purple",
    }
    expect(toMinimalToml(themeInput)).toBe(`[theme]
primaryColor="pink"
backgroundColor="red"
secondaryBackgroundColor="blue"
textColor="purple"
`)
  })

  it("sets font if not sans serif", () => {
    const themeInput = {
      ...toThemeInput(lightTheme.emotion),
      font: CustomThemeConfig.FontFamily.MONOSPACE,
    }
    expect(toMinimalToml(themeInput)).toBe(`[theme]
base="light"
font="monospace"
`)
  })
})

describe("Opened ThemeCreatorDialog", () => {
  afterEach(() => {
    vi.clearAllMocks()
  })

  it("should update theme on color change", () => {
    const props = getProps()
    customRenderLibContext(<ThemeCreatorDialog {...props} />, {
      setTheme: mockSetTheme,
      addThemes: mockAddThemes,
    })

    const themeColorPickers = screen.getAllByTestId("stColorPicker")
    expect(themeColorPickers).toHaveLength(4)

    const primaryColorPicker = within(themeColorPickers[0]).getByTestId(
      "stColorPickerBlock"
    )
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(primaryColorPicker)

    const newColor = "#e91e63"
    const colorInput = screen.getByRole("textbox")
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.change(colorInput, { target: { value: newColor } })
    // Close out of the popover
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(primaryColorPicker)

    expect(mockAddThemes).toHaveBeenCalled()
    expect(mockAddThemes.mock.calls[0][0][0].emotion.colors.primary).toBe(
      newColor
    )

    expect(mockSetTheme).toHaveBeenCalled()
    expect(mockSetTheme.mock.calls[0][0].emotion.colors.primary).toBe(newColor)
  })

  it("should update theme on font change", () => {
    const props = getProps()
    customRenderLibContext(<ThemeCreatorDialog {...props} />, {
      setTheme: mockSetTheme,
      addThemes: mockAddThemes,
    })

    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(screen.getByRole("combobox"))
    const options = screen.getAllByRole("option")

    expect(options).toHaveLength(
      Object.keys(CustomThemeConfig.FontFamily).length
    )

    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(options[2])
    expect(mockAddThemes).toHaveBeenCalled()
    expect(
      mockAddThemes.mock.calls[0][0][0].emotion.genericFonts.bodyFont
    ).toBe(fonts.monospace)

    expect(mockSetTheme).toHaveBeenCalled()
    expect(mockSetTheme.mock.calls[0][0].emotion.genericFonts.bodyFont).toBe(
      fonts.monospace
    )
  })

  it("should have font dropdown populated", () => {
    const props = getProps()
    customRenderLibContext(<ThemeCreatorDialog {...props} />, {
      setTheme: mockSetTheme,
      addThemes: mockAddThemes,
    })

    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(screen.getByRole("combobox"))
    const options = screen.getAllByRole("option")

    expect(options).toHaveLength(
      Object.keys(CustomThemeConfig.FontFamily).length
    )
    expect(options[0]).toHaveTextContent("Sans serif")
    expect(options[0]).toHaveAttribute("aria-selected", "true")
  })

  it("should call backToSettings if back button has been clicked", () => {
    const props = getProps()
    customRenderLibContext(<ThemeCreatorDialog {...props} />, {
      setTheme: mockSetTheme,
      addThemes: mockAddThemes,
    })

    const backButton = screen.getByTestId("stThemeCreatorBack")
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(backButton)
    expect(props.backToSettings).toHaveBeenCalled()
  })

  it("should copy to clipboard", () => {
    const props = getProps()
    customRenderLibContext(<ThemeCreatorDialog {...props} />, {
      setTheme: mockSetTheme,
      addThemes: mockAddThemes,
    })

    expect(screen.queryByText("Copied to clipboard")).not.toBeInTheDocument()
    const copyBtn = screen.getByRole("button", {
      name: "Copy theme to clipboard",
    })
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(copyBtn)

    expect(navigator.clipboard.writeText).toHaveBeenCalledWith(`[theme]
base="light"
`)
    expect(screen.getByText("Copied to clipboard")).toBeInTheDocument()
  })
})


================================================
File: /frontend/app/src/components/StreamlitDialog/ThemeCreatorDialog.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { Check } from "@emotion-icons/material-outlined"
import { toHex } from "color2k"
import humanizeString from "humanize-string"
import mapValues from "lodash/mapValues"

import {
  BaseButton,
  BaseButtonKind,
  BaseColorPicker,
  createTheme,
  CUSTOM_THEME_NAME,
  CustomThemeConfig,
  darkTheme,
  EmotionTheme,
  Icon,
  LibContext,
  lightTheme,
  Modal,
  ModalBody,
  ModalHeader,
  StreamlitMarkdown,
  ThemeConfig,
  toThemeInput,
  UISelectbox,
} from "@streamlit/lib"
import { MetricsManager } from "@streamlit/app/src/MetricsManager"

import {
  StyledBackButton,
  StyledDialogBody,
  StyledFullRow,
} from "./styled-components"

interface ThemeOptionBuilder {
  help: string
  title: string
  component: any
  options?: any[]
  getValue: (value: string, config: ThemeOptionBuilder) => any
}

const valueToColor = (value: string, _config: ThemeOptionBuilder): string =>
  toHex(value).toUpperCase()

const displayFontOption = (
  font: CustomThemeConfig.FontFamily | string
): string =>
  // @ts-expect-error
  humanizeString(CustomThemeConfig.FontFamily[font])

const themeBuilder: Record<string, ThemeOptionBuilder> = {
  primaryColor: {
    help: "Primary accent color for interactive elements.",
    title: "Primary color",
    component: BaseColorPicker,
    getValue: valueToColor,
  },
  backgroundColor: {
    help: "Background color for the main content area.",
    title: "Background color",
    component: BaseColorPicker,
    getValue: valueToColor,
  },
  secondaryBackgroundColor: {
    help: "Background color used for the sidebar and most interactive widgets.",
    title: "Secondary background color",
    component: BaseColorPicker,
    getValue: valueToColor,
  },
  textColor: {
    help: "Color used for almost all text.",
    title: "Text color",
    component: BaseColorPicker,
    getValue: valueToColor,
  },
  font: {
    help: "Font family for all text in the app, except code blocks.",
    title: "Font family",
    options: Object.keys(CustomThemeConfig.FontFamily).map(font =>
      humanizeString(font)
    ),
    getValue: (value: string, config: ThemeOptionBuilder): number =>
      (config.options &&
        config.options.findIndex(
          (font: string) => font === displayFontOption(value)
        )) ||
      0,
    component: UISelectbox,
  },
}

const changedColorConfig = (
  themeInput: Partial<CustomThemeConfig>,
  baseTheme: EmotionTheme
): Array<string> => {
  const toLowerCaseIfString = (x: any): any => {
    if (typeof x === "string") {
      return x.toLowerCase()
    }
    return x
  }

  const baseInput: Partial<CustomThemeConfig> = mapValues(
    toThemeInput(baseTheme),
    toLowerCaseIfString
  )
  themeInput = mapValues(themeInput, toLowerCaseIfString)
  const configLines: Array<string> = []

  // This is tedious, but typescript won't let us define an array with the keys
  // ["primaryColor", "backgroundColor", etc.] and use its elements to key into
  // themeInput and baseInput since it can't infer that the string literals in
  // the array are indeed valid fields.
  if (themeInput.primaryColor !== baseInput.primaryColor) {
    configLines.push(`primaryColor="${themeInput.primaryColor}"`)
  }
  if (themeInput.backgroundColor !== baseInput.backgroundColor) {
    configLines.push(`backgroundColor="${themeInput.backgroundColor}"`)
  }
  if (
    themeInput.secondaryBackgroundColor !== baseInput.secondaryBackgroundColor
  ) {
    configLines.push(
      `secondaryBackgroundColor="${themeInput.secondaryBackgroundColor}"`
    )
  }
  if (themeInput.textColor !== baseInput.textColor) {
    configLines.push(`textColor="${themeInput.textColor}"`)
  }

  return configLines
}

export const toMinimalToml = (
  themeInput: Partial<CustomThemeConfig>
): string => {
  const lines = ["[theme]"]

  const lightBaseConfig = changedColorConfig(themeInput, lightTheme.emotion)
  const darkBaseConfig = changedColorConfig(themeInput, darkTheme.emotion)

  const lbcLength = lightBaseConfig.length
  const dbcLength = darkBaseConfig.length

  if (lbcLength === dbcLength) {
    // Since the light and dark themes have different background, secondary
    // background, and text colors, this can only happen if all three of those
    // are changed. We don't need to define a base theme in this case.
    lines.push(...lightBaseConfig)
  } else if (lbcLength < dbcLength) {
    // Technically, the default base theme is light, but we break minimality
    // and set it here anyway to be more explicit.
    lines.push('base="light"', ...lightBaseConfig)
  } else {
    lines.push('base="dark"', ...darkBaseConfig)
  }

  if (themeInput.font) {
    const fontString = displayFontOption(themeInput.font).toLowerCase()
    lines.push(`font="${fontString}"`)
  }

  return [
    ...lines,
    // Add a newline to the end.
    "",
  ].join("\n")
}

export interface Props {
  backToSettings: (animateModal: boolean) => void
  onClose: () => void
  metricsMgr: MetricsManager
}

const ThemeCreatorDialog = (props: Props): ReactElement => {
  const [copied, updateCopied] = React.useState(false)
  const { activeTheme, addThemes, setTheme } = React.useContext(LibContext)

  const themeInput = toThemeInput(activeTheme.emotion)

  const updateTheme = (customTheme: ThemeConfig): void => {
    addThemes([customTheme])
    setTheme(customTheme)
  }

  const onThemeOptionChange = (key: string, newVal: string): void => {
    const customTheme = createTheme(CUSTOM_THEME_NAME, {
      ...themeInput,
      [key]: newVal,
    })
    updateTheme(customTheme)
    updateCopied(false)
  }

  const config = toMinimalToml(themeInput)

  const copyConfig = (): void => {
    props.metricsMgr.enqueue("menuClick", {
      label: "copyThemeToClipboard",
    })
    navigator.clipboard.writeText(config)
    updateCopied(true)
  }

  const ThemeOption = ({
    name,
    value,
  }: {
    name: string
    value: string
  }): ReactElement | null => {
    const themeOptionConfig = themeBuilder[name]
    const isColor = themeOptionConfig.component === BaseColorPicker
    // Props that vary based on component type
    const variableProps = {
      options: themeOptionConfig.options || undefined,
      showValue: isColor,
      value: themeOptionConfig.getValue(value, themeOptionConfig),
    }
    return (
      <React.Fragment key={name}>
        <themeOptionConfig.component
          disabled={false}
          label={themeOptionConfig.title}
          help={themeOptionConfig.help}
          onChange={(newVal: string) => {
            onThemeOptionChange(name, newVal)
          }}
          {...variableProps}
        />
      </React.Fragment>
    )
  }

  const onClickedBack = (): void => {
    // Disable the modal animation when returning to the settings dialog so
    // that it looks like a page transition instead of the modal
    // appearing/disappearing rapidly.
    props.backToSettings(false)
  }

  // At this point, we're guaranteed to have themeInput be a fully populated
  // CustomThemeConfig.
  const {
    primaryColor,
    textColor,
    backgroundColor,
    secondaryBackgroundColor,
  } = themeInput as {
    primaryColor: string
    textColor: string
    backgroundColor: string
    secondaryBackgroundColor: string
  }

  return (
    <Modal animate={false} isOpen onClose={props.onClose}>
      <ModalHeader>
        <StyledBackButton
          onClick={onClickedBack}
          data-testid="stThemeCreatorBack"
        />
        Edit active theme
      </ModalHeader>
      <ModalBody>
        <StyledDialogBody data-testid="stThemeCreatorDialog">
          <StyledFullRow>
            <StreamlitMarkdown
              source={`
Changes made to the active theme will exist for the duration of a
session. To discard changes and recover the original theme,
refresh the page.`}
              allowHTML={false}
              isCaption={true}
            />
          </StyledFullRow>

          <ThemeOption name="primaryColor" value={primaryColor} />
          <ThemeOption name="backgroundColor" value={backgroundColor} />
          <ThemeOption name="textColor" value={textColor} />
          <ThemeOption
            name="secondaryBackgroundColor"
            value={secondaryBackgroundColor}
          />

          <StyledFullRow>
            <ThemeOption name="font" value={String(themeInput.font)} />
          </StyledFullRow>

          <StyledFullRow>
            <StyledFullRow>
              <StreamlitMarkdown
                source={`
To save your changes, copy your custom theme into the clipboard and paste it into the
\`[theme]\` section of your \`.streamlit/config.toml\` file.
`}
                allowHTML={false}
                isCaption={true}
              />
            </StyledFullRow>
          </StyledFullRow>

          <StyledFullRow>
            <div>
              <BaseButton onClick={copyConfig} kind={BaseButtonKind.SECONDARY}>
                {copied ? (
                  <React.Fragment>
                    {"Copied to clipboard "}
                    <Icon
                      content={Check}
                      size="lg"
                      color={activeTheme.emotion.colors.success}
                    />
                  </React.Fragment>
                ) : (
                  "Copy theme to clipboard"
                )}
              </BaseButton>
            </div>
          </StyledFullRow>
        </StyledDialogBody>
      </ModalBody>
    </Modal>
  )
}

export default ThemeCreatorDialog


================================================
File: /frontend/app/src/components/StreamlitDialog/UserSettings.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export interface UserSettings {
  /**
   * If true, the app will be rendered with a wider column size
   */
  wideMode: boolean

  /**
   * Flag indicating whether the server should re-run an app's scripts automatically
   * when their source files are modified on disk.
   *
   * The server passes the initial runOnSave value in its 'NewConnection'
   * forward message. If the value is modified via {@link App.saveSettings},
   * a 'setRunOnSave' message will be sent back to the server.
   */
  runOnSave: boolean
}


================================================
File: /frontend/app/src/components/StreamlitDialog/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from "./StreamlitDialog"


================================================
File: /frontend/app/src/components/StreamlitDialog/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"
import { darken } from "color2k"
import { ChevronLeft } from "react-feather"

export const StyledShortcutLabel = styled.span({
  "&::first-letter": {
    textDecoration: "underline",
  },
})

export const StyledBackButton = styled(ChevronLeft)(({ theme }) => ({
  cursor: "pointer",
  marginRight: theme.spacing.lg,
}))

export const StyledDialogBody = styled.div(({ theme }) => ({
  display: "grid",
  gap: theme.spacing.twoXL,
  gridTemplateColumns: "1fr 1fr",
  margin: 0,
  padding: 0,
}))

export const StyledFullRow = styled.div(({ theme }) => ({
  gridColumnStart: 1,
  gridColumnEnd: -1,
  display: "grid",
  gap: theme.spacing.xs,
}))

export const StyledHeader = styled.h2(({ theme }) => ({
  paddingBottom: 0,
  paddingTop: 0,
  marginBottom: theme.spacing.md,
  marginTop: "0",
  fontWeight: theme.fontWeights.bold,
  fontSize: theme.fontSizes.md,
  lineHeight: theme.lineHeights.tight,
  color: theme.colors.bodyText,
  display: "grid",
  gridAutoFlow: "row",
  gap: theme.spacing.xs,

  // Override the default global style for a h2:first-of-type
  "&:first-of-type": {
    marginTop: 0,
  },
}))

export const StyledLabel = styled.label(({ theme }) => ({
  paddingBottom: 0,
  paddingTop: 0,
  marginBottom: 0,
  marginTop: 0,
  lineHeight: theme.lineHeights.tight,
  fontSize: theme.fontSizes.sm,
}))

export const StyledHr = styled.hr(({ theme }) => ({
  padding: 0,
  marginBottom: 0,
  marginLeft: `-${theme.spacing.xl}`,
  marginRight: `-${theme.spacing.xl}`,
  marginTop: 0,
}))

export const StyledButtonContainer = styled.div(({ theme }) => ({
  marginTop: theme.spacing.md,
}))

export const StyledCheckbox = styled.input(({ theme }) => ({
  marginRight: theme.spacing.xs,
  appearance: "none",
  border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
  width: theme.fontSizes.md,
  height: theme.fontSizes.md,
  borderRadius: theme.radii.md,
  display: "inline-flex",
  alignItems: "center",
  justifyContent: "center",
  padding: 0,
  verticalAlign: "middle",
  overflow: "hidden",

  "&:focus-visible": {
    outline: `2px solid ${theme.colors.primary}`,
  },

  "&:checked": {
    backgroundColor: theme.colors.primary,

    "&:after": {
      content: '"✓"',
      fontFamily: theme.fonts.monospace,
      fontSize: theme.fontSizes.md,
      color: theme.colors.white,
      lineHeight: theme.lineHeights.none,
    },
  },

  "&:disabled": {
    backgroundColor: theme.colors.secondaryBg,
  },
}))

export const StyledDeployErrorContent = styled.div(({ theme }) => ({
  "& > ul": {
    paddingLeft: theme.spacing.twoXL,
  },
}))

export const StyledAboutInfo = styled.div(({ theme }) => ({
  padding: `0 0 ${theme.spacing.lg} 0`,
  overflowY: "scroll",
}))

export const StyledAboutLink = styled.a(({ theme }) => ({
  color: `${theme.colors.linkText} !important`,

  "&:hover": {
    color: `${darken(theme.colors.linkText, 0.15)} !important`,
  },
}))


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployDialog/DeployCard.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { Card } from "baseui/card"
import { useTheme } from "@emotion/react"

import { EmotionTheme } from "@streamlit/lib"

interface IDeployCardProps {
  children?: React.ReactNode
}

function DeployCard(
  props: React.PropsWithChildren<IDeployCardProps>
): ReactElement {
  const { colors, spacing, radii, breakpoints, sizes }: EmotionTheme =
    useTheme()
  const { children } = props
  return (
    <Card
      overrides={{
        Root: {
          style: {
            borderTopWidth: sizes.borderWidth,
            borderBottomWidth: sizes.borderWidth,
            borderLeftWidth: sizes.borderWidth,
            borderRightWidth: sizes.borderWidth,

            borderTopStyle: "solid",
            borderBottomStyle: "none",
            borderLeftStyle: "none",
            borderRightStyle: "solid",

            borderTopColor: colors.borderColor,
            borderBottomColor: colors.borderColor,
            borderLeftColor: colors.borderColor,
            borderRightColor: colors.borderColor,

            borderTopLeftRadius: "none",
            borderTopRightRadius: "none",
            borderBottomLeftRadius: "none",
            borderBottomRightRadius: "none",

            ":last-child": {
              borderRightStyle: "none",
              borderBottomRightRadius: radii.xl,
            },
            ":first-child": {
              borderBottomLeftRadius: radii.xl,
            },

            [`@media (max-width: ${breakpoints.md})`]: {
              ":last-child": {
                borderBottomLeftRadius: radii.xl,
              },
            },
          },
        },
        Contents: {
          style: {
            marginBottom: 0,
            marginTop: 0,
            marginLeft: 0,
            marginRight: 0,
            height: "100%",
          },
        },
        Body: {
          style: {
            padding: spacing.twoXL,
            marginBottom: 0,
            marginTop: 0,
            marginLeft: 0,
            marginRight: 0,
            height: "100%",

            display: "flex",
            flexDirection: "column",

            [`@media (max-width: ${breakpoints.md})`]: {
              padding: spacing.xl,
            },
          },
        },
      }}
    >
      {children}
    </Card>
  )
}

export default DeployCard


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployDialog/DeployDialog.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, ReactNode, useCallback, useContext } from "react"

import { StyledAction, StyledBody } from "baseui/card"

import { BaseButton, BaseButtonKind, GitInfo, IGitInfo } from "@streamlit/lib"
import { MetricsManager } from "@streamlit/app/src/MetricsManager"
import {
  DialogType,
  PlainEventHandler,
} from "@streamlit/app/src/components/StreamlitDialog/StreamlitDialog"
import { AppContext } from "@streamlit/app/src/components/AppContext"
import StreamlitLogo from "@streamlit/app/src/assets/svg/logo.svg"
import Rocket from "@streamlit/app/src/assets/svg/rocket.svg"
import Snowflake from "@streamlit/app/src/assets/svg/snowflake.svg"
import {
  DEPLOY_URL,
  SNOWFLAKE_LEARN_MORE_URL,
  SNOWFLAKE_TRIAL_URL,
  STREAMLIT_CLOUD_URL,
  STREAMLIT_COMMUNITY_CLOUD_DOCS_URL,
  STREAMLIT_DEPLOY_TUTORIAL_URL,
} from "@streamlit/app/src/urls"
import {
  DetachedHead,
  ModuleIsNotAdded,
  NoRepositoryDetected,
} from "@streamlit/app/src/components/StreamlitDialog/DeployErrorDialogs"

import Modal from "./DeployModal"
import Card from "./DeployCard"
import ListElement from "./DeployListElement"
import {
  StyledActionsWrapper,
  StyledCardContainer,
  StyledHeader,
  StyledSubheader,
} from "./styled-components"

const { GitStates } = GitInfo

const openUrl = (url: string): void => {
  window.open(url, "_blank")
}

const getDeployAppUrl = (gitInfo: IGitInfo | null): string => {
  if (gitInfo) {
    // If the app was run inside a GitHub repo, autofill for a one-click deploy.
    // E.g.: https://share.streamlit.io/deploy?repository=melon&branch=develop&mainModule=streamlit_app.py
    const deployUrl = new URL(DEPLOY_URL)

    deployUrl.searchParams.set("repository", gitInfo.repository ?? "")
    deployUrl.searchParams.set("branch", gitInfo.branch ?? "")
    deployUrl.searchParams.set("mainModule", gitInfo.module ?? "")
    return deployUrl.toString()
  }
  // If not in git repo, direct them to the Streamlit Cloud page.
  return STREAMLIT_CLOUD_URL
}

export interface DeployDialogProps {
  type: DialogType.DEPLOY_DIALOG
  onClose: PlainEventHandler
  showDeployError: (
    title: string,
    errorNode: ReactNode,
    onContinue?: () => void
  ) => void
  isDeployErrorModalOpen: boolean
  metricsMgr: MetricsManager
}

export function DeployDialog(
  props: Readonly<DeployDialogProps>
): ReactElement {
  // Get latest git info from AppContext:
  const { gitInfo } = useContext(AppContext)
  const { onClose, metricsMgr } = props
  const onClickDeployApp = useCallback((): void => {
    const { showDeployError, isDeployErrorModalOpen, metricsMgr } = props
    metricsMgr.enqueue("menuClick", {
      label: "deployButtonInDialog",
    })

    if (!gitInfo) {
      const dialog = NoRepositoryDetected()

      showDeployError(dialog.title, dialog.body)

      return
    }

    const {
      repository,
      branch,
      module,
      untrackedFiles,
      state: gitState,
    } = gitInfo
    const hasMissingGitInfo = !repository || !branch || !module

    if (hasMissingGitInfo && gitState === GitStates.DEFAULT) {
      const dialog = NoRepositoryDetected()

      showDeployError(dialog.title, dialog.body)

      return
    }

    if (gitState === GitStates.HEAD_DETACHED) {
      const dialog = DetachedHead()

      showDeployError(dialog.title, dialog.body)

      return
    }

    if (module && untrackedFiles?.includes(module)) {
      const dialog = ModuleIsNotAdded(module)

      showDeployError(dialog.title, dialog.body)

      return
    }

    // We should close the modal when we try again and everything goes fine
    if (isDeployErrorModalOpen) {
      onClose()
    }

    openUrl(getDeployAppUrl(gitInfo))
  }, [props, onClose, gitInfo])

  return (
    <Modal onClose={onClose}>
      <StyledCardContainer>
        <Card>
          <StyledBody style={{ flexGrow: 1 }}>
            <img
              src={StreamlitLogo}
              alt={"Streamlit Logo"}
              data-testid={"stDeployDialogCommunityCloudIcon"}
            />
            <StyledHeader>Streamlit Community Cloud</StyledHeader>
            <StyledSubheader>For community, always free</StyledSubheader>
            <ListElement>For personal hobbies and learning</ListElement>
            <ListElement>Deploy unlimited public apps</ListElement>
            <ListElement>
              Explore and learn from Streamlit’s community and popular apps
            </ListElement>
          </StyledBody>
          <StyledAction>
            <StyledActionsWrapper>
              <BaseButton
                kind={BaseButtonKind.PRIMARY}
                onClick={onClickDeployApp}
              >
                Deploy now
              </BaseButton>
              <BaseButton
                onClick={() => {
                  metricsMgr.enqueue("menuClick", {
                    label: "readMoreCommunityCloudInDeployDialog",
                  })
                  openUrl(STREAMLIT_COMMUNITY_CLOUD_DOCS_URL)
                }}
                kind={BaseButtonKind.MINIMAL}
              >
                Learn more
              </BaseButton>
            </StyledActionsWrapper>
          </StyledAction>
        </Card>
        <Card>
          <StyledBody style={{ flexGrow: 1 }}>
            <img
              src={Snowflake}
              alt={"Snowflake"}
              data-testid={"stDeployDialogSnowflakeDeploymentIcon"}
            />
            <StyledHeader>Snowflake</StyledHeader>
            <StyledSubheader>For enterprise</StyledSubheader>
            <ListElement>
              Enterprise-level security, support, and fully managed
              infrastructure
            </ListElement>
            <ListElement>
              Deploy unlimited private apps with role-based sharing
            </ListElement>
            <ListElement>
              Integrate with Snowflake’s full data stack
            </ListElement>
          </StyledBody>
          <StyledAction>
            <StyledActionsWrapper>
              <BaseButton
                kind={BaseButtonKind.SECONDARY}
                onClick={() => {
                  metricsMgr.enqueue("menuClick", {
                    label: "startTrialInDeployDialog",
                  })
                  openUrl(SNOWFLAKE_TRIAL_URL)
                }}
              >
                Start trial
              </BaseButton>
              <BaseButton
                onClick={() => {
                  metricsMgr.enqueue("menuClick", {
                    label: "learnMoreSnowflakeInDeployDialog",
                  })
                  openUrl(SNOWFLAKE_LEARN_MORE_URL)
                }}
                kind={BaseButtonKind.MINIMAL}
              >
                Learn more
              </BaseButton>
            </StyledActionsWrapper>
          </StyledAction>
        </Card>
        <Card>
          <StyledBody style={{ flexGrow: 2 }}>
            <img
              src={Rocket}
              alt={"Rocket"}
              data-testid={"stDeployDialogCustomDeploymentIcon"}
            />
            <StyledHeader>Other platforms</StyledHeader>
            <StyledSubheader>For custom deployment </StyledSubheader>
            <ListElement>
              Deploy on your own hardware or cloud service
            </ListElement>
            <ListElement>
              Set up and maintain your own authentication, resources, and costs
            </ListElement>
          </StyledBody>
          <StyledAction>
            <StyledActionsWrapper>
              <BaseButton
                onClick={() => {
                  metricsMgr.enqueue("menuClick", {
                    label: "readMoreDeployTutorialInDeployDialog",
                  })
                  openUrl(STREAMLIT_DEPLOY_TUTORIAL_URL)
                }}
                kind={BaseButtonKind.MINIMAL}
              >
                Learn more
              </BaseButton>
            </StyledActionsWrapper>
          </StyledAction>
        </Card>
      </StyledCardContainer>
    </Modal>
  )
}


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployDialog/DeployListElement.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import Checkmark from "@streamlit/app/src/assets/svg/checkmark.svg"

import { StyledElement } from "./styled-components"

export interface IDeployListElementProps {
  children?: React.ReactNode
  extraSpacing?: boolean
}

function DeployListElement(props: IDeployListElementProps): ReactElement {
  const { children } = props
  return (
    <StyledElement>
      <img src={Checkmark} alt={"Checkmark"} />
      <span>{children}</span>
    </StyledElement>
  )
}

export default DeployListElement


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployDialog/DeployModal.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, ReactNode } from "react"

import { ModalBody as UIModalBody } from "baseui/modal"
import { CloseSource } from "baseui/modal/types"
import { useTheme } from "@emotion/react"

import { EmotionTheme, Modal, ModalHeader } from "@streamlit/lib"

interface IDeployModalProps {
  children: React.ReactNode
  onClose: (a: { closeSource?: CloseSource }) => unknown
}

export interface ModalBodyProps {
  children: ReactNode
}

function ModalBody({ children }: Readonly<ModalBodyProps>): ReactElement {
  const { colors, fontSizes, spacing }: EmotionTheme = useTheme()

  return (
    <UIModalBody
      style={{
        marginTop: spacing.none,
        marginLeft: spacing.none,
        marginRight: spacing.none,
        marginBottom: spacing.none,
        paddingTop: spacing.md,
        paddingRight: spacing.none,
        paddingBottom: spacing.none,
        paddingLeft: spacing.none,
        color: colors.bodyText,
        fontSize: fontSizes.md,
        overflowY: "auto",
      }}
    >
      {children}
    </UIModalBody>
  )
}

function DeployModal(
  props: React.PropsWithChildren<IDeployModalProps>
): ReactElement {
  const { children, onClose } = props
  return (
    <Modal isOpen={true} closeable={true} onClose={onClose} size="auto">
      <ModalHeader>Deploy this app using...</ModalHeader>
      <ModalBody>{children}</ModalBody>
    </Modal>
  )
}

export default DeployModal


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployDialog/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export * from "./DeployDialog"


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployDialog/styled-components.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledHeader = styled.div(({ theme }) => ({
  // We do not want to change the font for this based on theme.
  fontFamily: theme.fonts.sansSerif,
  fontWeight: theme.fontWeights.bold,
  fontSize: theme.fontSizes.lg,
  color: theme.colors.grey90,
  marginTop: theme.spacing.twoXL,
  marginBottom: theme.spacing.twoXS,

  [`@media (max-width: ${theme.breakpoints.md})`]: {
    marginTop: theme.spacing.md,
  },
}))

export const StyledSubheader = styled.div(({ theme }) => ({
  // We do not want to change the font for this based on theme.
  fontFamily: theme.fonts.sansSerif,
  fontWeight: theme.fontWeights.normal,
  fontSize: theme.fontSizes.md,
  color: theme.colors.grey90,
  marginTop: theme.spacing.twoXS,
  marginBottom: theme.spacing.md,

  [`@media (max-width: ${theme.breakpoints.md})`]: {
    marginTop: theme.spacing.md,
  },
}))

export const StyledCardContainer = styled.div(({ theme }) => ({
  display: "grid",
  maxWidth: `calc(1.25 * ${theme.sizes.contentMaxWidth})`,
  gridTemplateColumns: "1fr 1fr 1fr",
  gridGap: theme.spacing.none,

  [`@media (max-width: ${theme.breakpoints.md})`]: {
    gridTemplateColumns: "1fr",
  },
}))

export const StyledElement = styled.div(({ theme }) => ({
  display: "inline-flex",
  marginTop: theme.spacing.sm,

  "& > span": {
    // We do not want to change the font for this based on theme.
    fontFamily: theme.fonts.sansSerif,
    fontWeight: theme.fontWeights.normal,
    fontSize: theme.fontSizes.md,
    marginLeft: theme.spacing.twoXL,
    color: theme.colors.gray70,
  },
  "& > img": {
    position: "absolute",
    marginTop: theme.spacing.sm,
  },
}))

export const StyledActionsWrapper = styled.div(({ theme }) => ({
  display: "flex",
  marginTop: theme.spacing.threeXL,

  "& > button": {
    marginRight: theme.spacing.twoXL,
  },

  [`@media (max-width: ${theme.breakpoints.md})`]: {
    marginTop: theme.spacing.xl,
  },
}))


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployErrorDialogs/DetachedHead.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import DetachedHead from "./DetachedHead"

describe("DeployErrorDialog - DetachedHead", () => {
  it("should render without crashing", () => {
    const dialog = DetachedHead()

    expect(dialog).toMatchSnapshot()
  })
})


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployErrorDialogs/DetachedHead.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { IDeployErrorDialog } from "./types"

function DetachedHead(): IDeployErrorDialog {
  return {
    title: "Unable to deploy",
    body: (
      <>
        <p>This Git tree is in a detached HEAD state.</p>
        <p>Please commit the latest changes and push to GitHub to continue.</p>
      </>
    ),
  }
}

export default DetachedHead


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployErrorDialogs/ModuleIsNotAdded.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import ModuleIsNotAdded from "./ModuleIsNotAdded"

describe("DeployErrorDialog - ModuleIsNotAdded", () => {
  it("should render without crashing", () => {
    const dialog = ModuleIsNotAdded("module")

    expect(dialog.title).toBe("Unable to deploy")
  })
})


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployErrorDialogs/ModuleIsNotAdded.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { StreamlitMarkdown } from "@streamlit/lib"

import { IDeployErrorDialog } from "./types"

function ModuleIsNotAdded(module: string): IDeployErrorDialog {
  return {
    title: "Unable to deploy",
    body: (
      <StreamlitMarkdown
        source={`
The app's main file \`${module}\` has
not been pushed to GitHub. Please add it to continue.
`}
        allowHTML={false}
      />
    ),
  }
}

export default ModuleIsNotAdded


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployErrorDialogs/NoRepositoryDetected.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import NoRepositoryDetected from "./NoRepositoryDetected"

describe("DeployErrorDialog - NoRepositoryDetected", () => {
  it("should render without crashing", () => {
    const dialog = NoRepositoryDetected()

    expect(dialog).toMatchSnapshot()
  })
})


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployErrorDialogs/NoRepositoryDetected.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { STREAMLIT_COMMUNITY_CLOUD_DOCS_URL } from "@streamlit/app/src/urls"

import { IDeployErrorDialog } from "./types"
import { StyledParagraph } from "./styled-components"

function NoRepositoryDetected(): IDeployErrorDialog {
  return {
    title: "Unable to deploy",
    body: (
      <StyledParagraph>
        The app’s code is not connected to a remote GitHub repository. To
        deploy on Streamlit Community Cloud, please put your code in a GitHub
        repository and publish the current branch. Read more in{" "}
        <a
          href={STREAMLIT_COMMUNITY_CLOUD_DOCS_URL}
          rel="noopener noreferrer"
          target="_blank"
        >
          our documentation
        </a>
        .
      </StyledParagraph>
    ),
  }
}

export default NoRepositoryDetected


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployErrorDialogs/index.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default as DetachedHead } from "./DetachedHead"
export { default as ModuleIsNotAdded } from "./ModuleIsNotAdded"
export { default as NoRepositoryDetected } from "./NoRepositoryDetected"


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployErrorDialogs/styled-components.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledParagraph = styled.p({
  textAlign: "justify",
})


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployErrorDialogs/types.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { ReactNode } from "react"

export interface IDeployErrorDialog {
  title: string
  body: ReactNode
}


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployErrorDialogs/__snapshots__/DetachedHead.test.tsx.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`DeployErrorDialog - DetachedHead > should render without crashing 1`] = `
{
  "body": <React.Fragment>
    <p>
      This Git tree is in a detached HEAD state.
    </p>
    <p>
      Please commit the latest changes and push to GitHub to continue.
    </p>
  </React.Fragment>,
  "title": "Unable to deploy",
}
`;


================================================
File: /frontend/app/src/components/StreamlitDialog/DeployErrorDialogs/__snapshots__/NoRepositoryDetected.test.tsx.snap
================================================
// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`DeployErrorDialog - NoRepositoryDetected > should render without crashing 1`] = `
{
  "body": <Styled(p)>
    The app’s code is not connected to a remote GitHub repository. To deploy on Streamlit Community Cloud, please put your code in a GitHub repository and publish the current branch. Read more in
     
    <a
      href="https://share.streamlit.io/cloud-getting-started"
      rel="noopener noreferrer"
      target="_blank"
    >
      our documentation
    </a>
    .
  </Styled(p)>,
  "title": "Unable to deploy",
}
`;


================================================
File: /frontend/app/src/components/ToolbarActions/ToolbarActions.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { mockSessionInfo, render } from "@streamlit/lib"
import { MetricsManager } from "@streamlit/app/src/MetricsManager"

import ToolbarActions, {
  ActionButton,
  ActionButtonProps,
  ToolbarActionsProps,
} from "./ToolbarActions"

describe("ActionButton", () => {
  const getProps = (
    extended?: Partial<ActionButtonProps>
  ): ActionButtonProps => ({
    label: "the label",
    icon: "star.svg",
    onClick: vi.fn(),
    ...extended,
  })

  it("renders without crashing", () => {
    render(<ActionButton {...getProps()} />)

    expect(screen.getByTestId("stToolbarActionButton")).toBeInTheDocument()
  })

  it("does not render icon if not provided", () => {
    render(<ActionButton {...getProps({ icon: undefined })} />)

    expect(screen.getByTestId("stToolbarActionButton")).toBeInTheDocument()
    expect(
      screen.queryByTestId("stToolbarActionButtonIcon")
    ).not.toBeInTheDocument()
  })

  it("does not render label if not provided", () => {
    render(<ActionButton {...getProps({ label: undefined })} />)

    expect(screen.getByTestId("stToolbarActionButton")).toBeInTheDocument()
    expect(
      screen.queryByTestId("stToolbarActionButtonLabel")
    ).not.toBeInTheDocument()
  })
})

describe("ToolbarActions", () => {
  const getProps = (
    extended?: Partial<ToolbarActionsProps>
  ): ToolbarActionsProps => ({
    hostToolbarItems: [
      { key: "favorite", icon: "star.svg" },
      { key: "share", label: "Share" },
    ],
    sendMessageToHost: vi.fn(),
    metricsMgr: new MetricsManager(mockSessionInfo()),
    ...extended,
  })

  it("renders without crashing", () => {
    render(<ToolbarActions {...getProps()} />)
    expect(screen.getByTestId("stToolbarActions")).toBeInTheDocument()
  })

  it("renders toolbar actions and renders action buttons horizontally", () => {
    render(<ToolbarActions {...getProps()} />)
    expect(screen.getByTestId("stToolbarActions")).toHaveStyle("display: flex")
  })

  it("calls sendMessageToHost with correct args when clicked", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<ToolbarActions {...props} />)

    const favoriteButton = screen.getAllByTestId("stBaseButton-header")[0]
    await user.click(favoriteButton)
    expect(props.sendMessageToHost).toHaveBeenLastCalledWith({
      type: "TOOLBAR_ITEM_CALLBACK",
      key: "favorite",
    })

    const shareButton = screen.getByRole("button", { name: "Share" })
    await user.click(shareButton)
    expect(props.sendMessageToHost).toHaveBeenLastCalledWith({
      type: "TOOLBAR_ITEM_CALLBACK",
      key: "share",
    })
  })
})


================================================
File: /frontend/app/src/components/ToolbarActions/ToolbarActions.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import {
  BaseButton,
  BaseButtonKind,
  IGuestToHostMessage,
  IToolbarItem,
} from "@streamlit/lib"
import { MetricsManager } from "@streamlit/app/src/MetricsManager"

import {
  StyledActionButtonContainer,
  StyledActionButtonIcon,
  StyledToolbarActions,
} from "./styled-components"

export interface ActionButtonProps {
  label?: string
  icon?: string
  onClick: () => void
}

export function ActionButton({
  label,
  icon,
  onClick,
}: ActionButtonProps): ReactElement {
  return (
    <div className="stToolbarActionButton" data-testid="stToolbarActionButton">
      <BaseButton onClick={onClick} kind={BaseButtonKind.HEADER_BUTTON}>
        <StyledActionButtonContainer>
          {icon && (
            <StyledActionButtonIcon
              data-testid="stToolbarActionButtonIcon"
              icon={icon}
            />
          )}
          {label && (
            <span data-testid="stToolbarActionButtonLabel">{label}</span>
          )}
        </StyledActionButtonContainer>
      </BaseButton>
    </div>
  )
}

export interface ToolbarActionsProps {
  sendMessageToHost: (message: IGuestToHostMessage) => void
  hostToolbarItems: IToolbarItem[]
  metricsMgr: MetricsManager
}

function ToolbarActions({
  sendMessageToHost,
  hostToolbarItems,
  metricsMgr,
}: ToolbarActionsProps): ReactElement {
  return (
    <StyledToolbarActions
      className="stToolbarActions"
      data-testid="stToolbarActions"
    >
      {hostToolbarItems.map(({ key, label, icon }) => (
        <ActionButton
          key={key}
          label={label}
          icon={icon}
          onClick={() => {
            metricsMgr.enqueue("menuClick", {
              label: key,
            })
            sendMessageToHost({
              type: "TOOLBAR_ITEM_CALLBACK",
              key,
            })
          }}
        />
      ))}
    </StyledToolbarActions>
  )
}

export default ToolbarActions


================================================
File: /frontend/app/src/components/ToolbarActions/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./ToolbarActions"


================================================
File: /frontend/app/src/components/ToolbarActions/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledActionButtonContainer = styled.div(({ theme }) => ({
  display: "flex",
  gap: theme.spacing.sm,
  alignItems: "center",
  // line height should be the same as the icon size
  lineHeight: theme.iconSizes.md,
}))

export interface StyledActionButtonIconProps {
  icon: string
}

export const StyledActionButtonIcon = styled.div<StyledActionButtonIconProps>(
  ({ theme, icon }) => ({
    background: `url("${icon}") no-repeat center / contain`,
    width: theme.iconSizes.base,
    height: theme.iconSizes.base,
  })
)

export const StyledToolbarActions = styled.div(({}) => ({
  display: "flex",
  alignItems: "center",
  flexDirection: "row",
}))


================================================
File: /frontend/app/src/connection/ConnectionManager.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ReactNode } from "react"

import {
  BackMsg,
  BaseUriParts,
  ensureError,
  ForwardMsg,
  getPossibleBaseUris,
  IHostConfigResponse,
  logError,
  SessionInfo,
  StreamlitEndpoints,
} from "@streamlit/lib"

import { ConnectionState } from "./ConnectionState"
import { WebsocketConnection } from "./WebsocketConnection"

/**
 * When the websocket connection retries this many times, we show a dialog
 * letting the user know we're having problems connecting. This happens
 * after about 15 seconds as, before the 6th retry, we've set timeouts for
 * a total of approximately 0.5 + 1 + 2 + 4 + 8 = 15.5 seconds (+/- some
 * due to jitter).
 */
const RETRY_COUNT_FOR_WARNING = 6

interface Props {
  /** The app's SessionInfo instance */
  sessionInfo: SessionInfo

  /** The app's StreamlitEndpoints instance */
  endpoints: StreamlitEndpoints

  /**
   * Function to be called when we receive a message from the server.
   */
  onMessage: (message: ForwardMsg) => void

  /**
   * Function to be called when the connection errors out.
   */
  onConnectionError: (errNode: ReactNode) => void

  /**
   * Called when our ConnectionState is changed.
   */
  connectionStateChanged: (connectionState: ConnectionState) => void

  /**
   * Function to get the auth token set by the host of this app (if in a
   * relevant deployment scenario).
   */
  claimHostAuthToken: () => Promise<string | undefined>

  /**
   * Function to clear the withHostCommunication hoc's auth token. This should
   * be called after the promise returned by claimHostAuthToken successfully
   * resolves.
   */
  resetHostAuthToken: () => void

  /**
   * Function to set the host config for this app (if in a relevant deployment
   * scenario).
   */
  onHostConfigResp: (resp: IHostConfigResponse) => void
}

/**
 * Manages our connection to the Server.
 */
export class ConnectionManager {
  private readonly props: Props

  private connection?: WebsocketConnection

  private connectionState: ConnectionState = ConnectionState.INITIAL

  constructor(props: Props) {
    this.props = props

    // This method returns a promise, but we don't care about its result.
    this.connect()
  }

  /**
   * Indicates whether we're connected to the server.
   */
  public isConnected(): boolean {
    return this.connectionState === ConnectionState.CONNECTED
  }

  /**
   * Return the BaseUriParts for the server we're connected to,
   * if we are connected to a server.
   */
  public getBaseUriParts(): BaseUriParts | undefined {
    if (this.connection instanceof WebsocketConnection) {
      return this.connection.getBaseUriParts()
    }
    return undefined
  }

  public sendMessage(obj: BackMsg): void {
    if (this.connection instanceof WebsocketConnection && this.isConnected()) {
      this.connection.sendMessage(obj)
    } else {
      // Don't need to make a big deal out of this. Just print to console.
      logError(`Cannot send message when server is disconnected: ${obj}`)
    }
  }

  /**
   * Increment the runCount on our message cache, and clear entries
   * whose age is greater than the max.
   */
  public incrementMessageCacheRunCount(maxMessageAge: number): void {
    // StaticConnection does not use a MessageCache.
    if (this.connection instanceof WebsocketConnection) {
      this.connection.incrementMessageCacheRunCount(maxMessageAge)
    }
  }

  private async connect(): Promise<void> {
    try {
      this.connection = await this.connectToRunningServer()
    } catch (e) {
      const err = ensureError(e)
      logError(err.message)
      this.setConnectionState(
        ConnectionState.DISCONNECTED_FOREVER,
        err.message
      )
    }
  }

  disconnect(): void {
    this.connection?.disconnect()
  }

  private setConnectionState = (
    connectionState: ConnectionState,
    errMsg?: string
  ): void => {
    if (this.connectionState !== connectionState) {
      this.connectionState = connectionState
      this.props.connectionStateChanged(connectionState)
    }

    if (errMsg) {
      this.props.onConnectionError(errMsg)
    }
  }

  private showRetryError = (
    totalRetries: number,
    latestError: ReactNode,
    // The last argument of this function is unused and exists because the
    // WebsocketConnection.OnRetry type allows a third argument to be set to be
    // used in tests.
    _retryTimeout: number
  ): void => {
    if (totalRetries === RETRY_COUNT_FOR_WARNING) {
      this.props.onConnectionError(latestError)
    }
  }

  private connectToRunningServer(): WebsocketConnection {
    const baseUriPartsList = getPossibleBaseUris()

    return new WebsocketConnection({
      sessionInfo: this.props.sessionInfo,
      endpoints: this.props.endpoints,
      baseUriPartsList,
      onMessage: this.props.onMessage,
      onConnectionStateChange: this.setConnectionState,
      onRetry: this.showRetryError,
      claimHostAuthToken: this.props.claimHostAuthToken,
      resetHostAuthToken: this.props.resetHostAuthToken,
      onHostConfigResp: this.props.onHostConfigResp,
    })
  }
}


================================================
File: /frontend/app/src/connection/ConnectionState.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export enum ConnectionState {
  CONNECTED = "CONNECTED",
  DISCONNECTED_FOREVER = "DISCONNECTED_FOREVER",
  INITIAL = "INITIAL",
  PINGING_SERVER = "PINGING_SERVER",
  CONNECTING = "CONNECTING",
}


================================================
File: /frontend/app/src/connection/DefaultStreamlitEndpoints.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import axios from "axios"
import MockAdapter from "axios-mock-adapter"

import { BaseUriParts, buildHttpUri, ForwardMsg } from "@streamlit/lib"

import { DefaultStreamlitEndpoints } from "./DefaultStreamlitEndpoints"

const MOCK_SERVER_URI = {
  host: "streamlit.mock",
  port: 80,
  basePath: "mock/base/path",
}

function createMockForwardMsg(hash: string, cacheable = true): ForwardMsg {
  return ForwardMsg.fromObject({
    hash,
    metadata: { cacheable, deltaId: 0 },
  })
}

afterEach(() => {
  vi.clearAllMocks()
})

describe("DefaultStreamlitEndpoints", () => {
  const { location: originalLocation } = window
  beforeEach(() => {
    // Replace window.location with a mutable object that otherwise has
    // the same contents so that we can change port below.
    // @ts-expect-error
    delete window.location
    window.location = { ...originalLocation }
  })
  afterEach(() => {
    window.location = originalLocation
  })

  describe("buildComponentURL()", () => {
    it("errors if no serverURI", () => {
      // If we never connect to a server, getComponentURL will fail:
      let serverURI: BaseUriParts | undefined
      const endpoint = new DefaultStreamlitEndpoints({
        getServerUri: () => serverURI,
        csrfEnabled: true,
      })
      expect(() => endpoint.buildComponentURL("foo", "index.html")).toThrow()
    })

    it("uses current or cached serverURI if present", () => {
      let serverURI: BaseUriParts | undefined
      const endpoint = new DefaultStreamlitEndpoints({
        getServerUri: () => serverURI,
        csrfEnabled: true,
      })

      // "Connect" to the server. `buildComponentURL` will succeed.
      serverURI = MOCK_SERVER_URI
      expect(endpoint.buildComponentURL("foo", "index.html")).toEqual(
        "http://streamlit.mock:80/mock/base/path/component/foo/index.html"
      )

      // "Disconnect" from the server, and call buildComponentURL again;
      // it should return a URL constructed from the cached server URI.
      serverURI = undefined
      expect(endpoint.buildComponentURL("bar", "index.html")).toEqual(
        "http://streamlit.mock:80/mock/base/path/component/bar/index.html"
      )
    })
  })

  describe("buildMediaURL", () => {
    const endpoints = new DefaultStreamlitEndpoints({
      getServerUri: () => MOCK_SERVER_URI,
      csrfEnabled: false,
    })

    it("builds URL correctly for streamlit-served media", () => {
      const url = endpoints.buildMediaURL("/media/1234567890.png")
      expect(url).toBe(
        "http://streamlit.mock:80/mock/base/path/media/1234567890.png"
      )
    })

    it("passes through other media uris", () => {
      const uri = endpoints.buildMediaURL("http://example/blah.png")
      expect(uri).toBe("http://example/blah.png")
    })
  })

  describe("buildFileUploadURL", () => {
    const endpoints = new DefaultStreamlitEndpoints({
      getServerUri: () => MOCK_SERVER_URI,
      csrfEnabled: false,
    })

    it("builds URL correctly for files being uploaded to the tornado server", () => {
      const url = endpoints.buildFileUploadURL("/_stcore/upload_file/file_1")
      expect(url).toBe(
        "http://streamlit.mock:80/mock/base/path/_stcore/upload_file/file_1"
      )
    })

    it("passes through other file upload URLs unchanged", () => {
      const uri = endpoints.buildFileUploadURL(
        "http://example.com/upload_file/file_2"
      )
      expect(uri).toBe("http://example.com/upload_file/file_2")
    })

    it("respects URL prefix from fileUploadClientConfig", () => {
      endpoints.setFileUploadClientConfig({
        prefix: "https://someprefix.com/somepath/",
        headers: {},
      })

      const uri = endpoints.buildFileUploadURL("/upload_file/file_2")
      expect(uri).toBe("https://someprefix.com/somepath/upload_file/file_2")
    })
  })

  describe("buildAppPageURL", () => {
    const endpoints = new DefaultStreamlitEndpoints({
      getServerUri: () => MOCK_SERVER_URI,
      csrfEnabled: false,
    })

    const appPages = [
      {
        pageScriptHash: "main_page_hash",
        pageName: "streamlit app",
        urlPathname: "streamlit_app",
        isDefault: true,
      },
      {
        pageScriptHash: "other_page_hash",
        pageName: "my other page",
        urlPathname: "my_other_page",
      },
    ]

    it("uses window.location.port", () => {
      window.location.port = "3000"
      expect(endpoints.buildAppPageURL("", appPages[0])).toBe(
        "http://streamlit.mock:3000/mock/base/path/"
      )
      expect(endpoints.buildAppPageURL("", appPages[1])).toBe(
        "http://streamlit.mock:3000/mock/base/path/my_other_page"
      )
    })

    it("is built using pageLinkBaseURL if set", () => {
      window.location.port = "3000"
      const pageLinkBaseURL = "https://share.streamlit.io/vdonato/foo/bar"
      expect(endpoints.buildAppPageURL(pageLinkBaseURL, appPages[0])).toBe(
        "https://share.streamlit.io/vdonato/foo/bar/"
      )
      expect(endpoints.buildAppPageURL(pageLinkBaseURL, appPages[1])).toBe(
        "https://share.streamlit.io/vdonato/foo/bar/my_other_page"
      )
    })
  })

  describe("uploadFileUploaderFile()", () => {
    const MOCK_FILE = new File(["file1"], "file1.txt")

    let axiosMock: MockAdapter
    const spyRequest = vi.spyOn(axios, "request")
    let endpoints: DefaultStreamlitEndpoints

    beforeEach(() => {
      axiosMock = new MockAdapter(axios)
      endpoints = new DefaultStreamlitEndpoints({
        getServerUri: () => MOCK_SERVER_URI,
        csrfEnabled: false,
      })
    })

    afterEach(() => {
      axiosMock.restore()
    })

    it("properly constructs the correct endpoint when given a relative URL", async () => {
      axiosMock
        .onPut(
          "http://streamlit.mock:80/mock/base/path/_stcore/upload_file/file_1"
        )
        .reply(() => [200, 1])

      const mockOnUploadProgress = (_: any): void => {}
      const mockCancelToken = axios.CancelToken.source().token

      await expect(
        endpoints.uploadFileUploaderFile(
          "/_stcore/upload_file/file_1",
          MOCK_FILE,
          "mockSessionId",
          mockOnUploadProgress,
          mockCancelToken
        )
      ).resolves.toBeUndefined()

      const expectedData = new FormData()
      expectedData.append(MOCK_FILE.name, MOCK_FILE)

      expect(spyRequest).toHaveBeenCalledWith({
        url: "http://streamlit.mock:80/mock/base/path/_stcore/upload_file/file_1",
        method: "PUT",
        responseType: "text",
        data: expectedData,
        headers: {},
        cancelToken: mockCancelToken,
        onUploadProgress: mockOnUploadProgress,
      })
    })

    it("Uses the endpoint unchanged when given an absolute url", async () => {
      axiosMock
        .onPut("http://example.com/upload_file/file_2")
        .reply(() => [200, 1])

      const mockOnUploadProgress = (_: any): void => {}
      const mockCancelToken = axios.CancelToken.source().token

      await expect(
        endpoints.uploadFileUploaderFile(
          "http://example.com/upload_file/file_2",
          MOCK_FILE,
          "mockSessionId",
          mockOnUploadProgress,
          mockCancelToken
        )
      ).resolves.toBeUndefined()

      const expectedData = new FormData()
      expectedData.append(MOCK_FILE.name, MOCK_FILE)

      expect(spyRequest).toHaveBeenCalledWith({
        url: "http://example.com/upload_file/file_2",
        method: "PUT",
        responseType: "text",
        data: expectedData,
        headers: {},
        cancelToken: mockCancelToken,
        onUploadProgress: mockOnUploadProgress,
      })
    })

    it("respects fileUploadClientConfig", async () => {
      axiosMock
        .onPut("http://example.com/someprefix/upload_file/file_2")
        .reply(() => [200, 1])

      const mockOnUploadProgress = (_: any): void => {}
      const mockCancelToken = axios.CancelToken.source().token

      endpoints.setFileUploadClientConfig({
        prefix: "http://example.com/someprefix/",
        headers: {
          header1: "header1value",
          header2: "header2value",
        },
      })

      await expect(
        endpoints.uploadFileUploaderFile(
          "upload_file/file_2",
          MOCK_FILE,
          "mockSessionId",
          mockOnUploadProgress,
          mockCancelToken
        )
      ).resolves.toBeUndefined()

      const expectedData = new FormData()
      expectedData.append(MOCK_FILE.name, MOCK_FILE)

      expect(spyRequest).toHaveBeenCalledWith({
        url: "http://example.com/someprefix/upload_file/file_2",
        method: "PUT",
        responseType: "text",
        data: expectedData,
        headers: {
          header1: "header1value",
          header2: "header2value",
        },
        cancelToken: mockCancelToken,
        onUploadProgress: mockOnUploadProgress,
      })
    })

    it("errors on bad status", async () => {
      axiosMock
        .onPut("http://streamlit.mock:80/mock/base/path/_stcore/upload_file")
        .reply(() => [400])

      await expect(
        endpoints.uploadFileUploaderFile(
          "/_stcore/upload_file",
          MOCK_FILE,
          "mockSessionId"
        )
      ).rejects.toEqual(new Error("Request failed with status code 400"))
    })
  })

  describe("deleteFileAtURL()", () => {
    let axiosMock: MockAdapter
    const spyRequest = vi.spyOn(axios, "request")
    let endpoints: DefaultStreamlitEndpoints

    beforeEach(() => {
      axiosMock = new MockAdapter(axios)
      endpoints = new DefaultStreamlitEndpoints({
        getServerUri: () => MOCK_SERVER_URI,
        csrfEnabled: false,
      })
    })

    afterEach(() => {
      axiosMock.restore()
    })

    it("delete properly constructs the correct endpoint when given a relative URL", async () => {
      axiosMock
        .onDelete(
          "http://streamlit.mock:80/mock/base/path/_stcore/upload_file/file_1"
        )
        .reply(() => [204])

      await expect(
        endpoints.deleteFileAtURL(
          "/_stcore/upload_file/file_1",
          "mockSessionId"
        )
      ).resolves.toBeUndefined()

      expect(spyRequest).toHaveBeenCalledWith({
        url: "http://streamlit.mock:80/mock/base/path/_stcore/upload_file/file_1",
        method: "DELETE",
        headers: {},
        data: { sessionId: "mockSessionId" },
      })
    })

    it("respects fileUploadClientConfig", async () => {
      axiosMock
        .onDelete("http://example.com/someprefix/upload_file/file_1")
        .reply(() => [204])

      endpoints.setFileUploadClientConfig({
        prefix: "http://example.com/someprefix/",
        headers: {
          header1: "header1value",
          header2: "header2value",
        },
      })

      await expect(
        endpoints.deleteFileAtURL("upload_file/file_1", "mockSessionId")
      ).resolves.toBeUndefined()

      expect(spyRequest).toHaveBeenCalledWith({
        url: "http://example.com/someprefix/upload_file/file_1",
        method: "DELETE",
        headers: {
          header1: "header1value",
          header2: "header2value",
        },
        data: { sessionId: "mockSessionId" },
      })
    })
  })

  describe("fetchCachedForwardMsg()", () => {
    let axiosMock: MockAdapter
    let endpoints: DefaultStreamlitEndpoints

    beforeEach(() => {
      axiosMock = new MockAdapter(axios)
      endpoints = new DefaultStreamlitEndpoints({
        getServerUri: () => MOCK_SERVER_URI,
        csrfEnabled: false,
      })
    })

    afterEach(() => {
      axiosMock.restore()
    })

    it("calls the appropriate endpoint", async () => {
      const mockForwardMsgBytes = ForwardMsg.encode(
        createMockForwardMsg("mockHash")
      ).finish()

      axiosMock
        .onGet(
          "http://streamlit.mock:80/mock/base/path/_stcore/message?hash=mockHash"
        )
        .reply(() => {
          return [200, mockForwardMsgBytes]
        })

      await expect(
        endpoints.fetchCachedForwardMsg("mockHash")
      ).resolves.toEqual(new Uint8Array(mockForwardMsgBytes))
    })

    it("errors on bad status", async () => {
      axiosMock
        .onGet(
          "http://streamlit.mock:80/mock/base/path/_stcore/message?hash=mockHash"
        )
        .reply(() => [400])

      await expect(
        endpoints.fetchCachedForwardMsg("mockHash")
      ).rejects.toEqual(new Error("Request failed with status code 400"))
    })
  })

  // Test our private csrfRequest() API, which is responsible for setting
  // the "X-Xsrftoken" header.
  describe("csrfRequest()", () => {
    const spyRequest = vi.spyOn(axios, "request")
    let prevDocumentCookie: string

    beforeEach(() => {
      prevDocumentCookie = document.cookie
      document.cookie = "_streamlit_xsrf=mockXsrfCookie;"
    })

    afterEach(() => {
      document.cookie = prevDocumentCookie
    })

    it("sets token when csrfEnabled: true", () => {
      const endpoints = new DefaultStreamlitEndpoints({
        getServerUri: () => MOCK_SERVER_URI,
        csrfEnabled: true,
      })

      const url = buildHttpUri(MOCK_SERVER_URI, "mockUrl")
      // @ts-expect-error
      endpoints.csrfRequest(url, {})

      expect(spyRequest).toHaveBeenCalledWith({
        headers: { "X-Xsrftoken": "mockXsrfCookie" },
        withCredentials: true,
        url,
      })
    })

    it("omits token when csrfEnabled: false", () => {
      const endpoints = new DefaultStreamlitEndpoints({
        getServerUri: () => MOCK_SERVER_URI,
        csrfEnabled: false,
      })

      const url = buildHttpUri(MOCK_SERVER_URI, "mockUrl")
      // @ts-expect-error
      endpoints.csrfRequest(url, {})

      expect(spyRequest).toHaveBeenCalledWith({
        url,
      })
    })
  })
})


================================================
File: /frontend/app/src/connection/DefaultStreamlitEndpoints.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import axios, { AxiosRequestConfig, AxiosResponse, CancelToken } from "axios"

import {
  BaseUriParts,
  buildHttpUri,
  FileUploadClientConfig,
  getCookie,
  IAppPage,
  makePath,
  notNullOrUndefined,
  StreamlitEndpoints,
} from "@streamlit/lib"

interface Props {
  getServerUri: () => BaseUriParts | undefined
  csrfEnabled: boolean
}

const MEDIA_ENDPOINT = "/media"
const UPLOAD_FILE_ENDPOINT = "/_stcore/upload_file"
const COMPONENT_ENDPOINT_BASE = "/component"
const FORWARD_MSG_CACHE_ENDPOINT = "/_stcore/message"

/** Default Streamlit server implementation of the StreamlitEndpoints interface. */
export class DefaultStreamlitEndpoints implements StreamlitEndpoints {
  private readonly getServerUri: () => BaseUriParts | undefined

  private readonly csrfEnabled: boolean

  private cachedServerUri?: BaseUriParts

  private fileUploadClientConfig?: FileUploadClientConfig

  public constructor(props: Props) {
    this.getServerUri = props.getServerUri
    this.csrfEnabled = props.csrfEnabled
  }

  public buildComponentURL(componentName: string, path: string): string {
    return buildHttpUri(
      this.requireServerUri(),
      `${COMPONENT_ENDPOINT_BASE}/${componentName}/${path}`
    )
  }

  public setFileUploadClientConfig({
    prefix,
    headers,
  }: FileUploadClientConfig): void {
    this.fileUploadClientConfig = {
      prefix,
      headers,
    }
  }

  /**
   * Construct a URL for a media file. If the url is relative and starts with
   * "/media", assume it's being served from Streamlit and construct it
   * appropriately. Otherwise leave it alone.
   */
  public buildMediaURL(url: string): string {
    return url.startsWith(MEDIA_ENDPOINT)
      ? buildHttpUri(this.requireServerUri(), url)
      : url
  }

  /**
   * Construct a URL for uploading a file. If the `fileUploadClientConfig`
   * exists, we build URL by prefixing URL with prefix from the config,
   * otherwise if the `fileUploadClientConfig` is not present, if URL is
   * relative and starts with "/_stcore/upload_file", assume we're uploading
   * the file to the Streamlit Tornado server and construct the URL
   * appropriately. Otherwise, we're probably uploading the file to some
   * external service, so we leave the URL alone.
   */
  public buildFileUploadURL(url: string): string {
    if (this.fileUploadClientConfig) {
      return makePath(this.fileUploadClientConfig.prefix, url)
    }

    return url.startsWith(UPLOAD_FILE_ENDPOINT)
      ? buildHttpUri(this.requireServerUri(), url)
      : url
  }

  /** Construct a URL for an app page in a multi-page app. */
  public buildAppPageURL(
    pageLinkBaseURL: string | undefined,
    page: IAppPage
  ): string {
    const urlPath = page.urlPathname as string
    const navigateTo = page.isDefault ? "" : urlPath

    if (notNullOrUndefined(pageLinkBaseURL) && pageLinkBaseURL.length > 0) {
      return `${pageLinkBaseURL}/${navigateTo}`
    }

    // NOTE: We use window.location to get the port instead of
    // getBaseUriParts() because the port may differ in dev mode (since
    // the frontend is served by the react dev server and not the
    // streamlit server).
    const { port, protocol } = window.location
    const { basePath, host } = this.requireServerUri()
    const portSection = port ? `:${port}` : ""
    const basePathSection = basePath ? `${basePath}/` : ""

    return `${protocol}//${host}${portSection}/${basePathSection}${navigateTo}`
  }

  public async uploadFileUploaderFile(
    fileUploadUrl: string,
    file: File,
    sessionId: string,
    onUploadProgress?: (progressEvent: any) => void,
    cancelToken?: CancelToken
  ): Promise<void> {
    const form = new FormData()
    form.append(file.name, file)

    const headers: Record<string, string> = this.getAdditionalHeaders()

    return this.csrfRequest<number>(this.buildFileUploadURL(fileUploadUrl), {
      cancelToken,
      method: "PUT",
      data: form,
      responseType: "text",
      headers,
      onUploadProgress,
    }).then(() => undefined) // If the request succeeds, we don't care about the response body
  }

  private getAdditionalHeaders(): Record<string, string> {
    let headers: Record<string, string> = {}

    if (this.fileUploadClientConfig) {
      headers = {
        ...headers,
        ...this.fileUploadClientConfig.headers,
      }
    }
    return headers
  }

  /**
   * Send an HTTP DELETE request to the given URL.
   */
  public async deleteFileAtURL(
    fileUrl: string,
    sessionId: string
  ): Promise<void> {
    const headers: Record<string, string> = this.getAdditionalHeaders()
    return this.csrfRequest<number>(this.buildFileUploadURL(fileUrl), {
      method: "DELETE",
      data: { sessionId },
      headers,
    }).then(() => undefined) // If the request succeeds, we don't care about the response body
  }

  public async fetchCachedForwardMsg(hash: string): Promise<Uint8Array> {
    const serverURI = this.requireServerUri()
    const rsp = await axios.request({
      url: buildHttpUri(
        serverURI,
        `${FORWARD_MSG_CACHE_ENDPOINT}?hash=${hash}`
      ),
      method: "GET",
      responseType: "arraybuffer",
    })

    return new Uint8Array(rsp.data)
  }

  /**
   * Fetch the server URI. If our server is disconnected, default to the most
   * recent cached value of the URI. If we're disconnected and have no cached
   * value, throw an Error.
   */
  private requireServerUri(): BaseUriParts {
    const serverUri = this.getServerUri()
    if (notNullOrUndefined(serverUri)) {
      this.cachedServerUri = serverUri
      return serverUri
    }

    if (notNullOrUndefined(this.cachedServerUri)) {
      return this.cachedServerUri
    }

    throw new Error("not connected to a server!")
  }

  /**
   * Wrapper around axios.request to update the request config with
   * CSRF headers if client has CSRF protection enabled.
   */
  private csrfRequest<T = any, R = AxiosResponse<T>>(
    url: string,
    params: AxiosRequestConfig
  ): Promise<R> {
    params.url = url

    if (this.csrfEnabled) {
      const xsrfCookie = getCookie("_streamlit_xsrf")
      if (notNullOrUndefined(xsrfCookie)) {
        params.headers = {
          "X-Xsrftoken": xsrfCookie,
          ...(params.headers || {}),
        }
        params.withCredentials = true
      }
    }

    return axios.request<T, R>(params)
  }
}


================================================
File: /frontend/app/src/connection/WebsocketConnection.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { Fragment } from "react"

import axios from "axios"
import { default as WS } from "vitest-websocket-mock"
import zip from "lodash/zip"

import {
  BackMsg,
  mockEndpoints,
  mockSessionInfoProps,
  SessionInfo,
} from "@streamlit/lib"
import { ConnectionState } from "@streamlit/app/src/connection/ConnectionState"
import {
  Args,
  CORS_ERROR_MESSAGE_DOCUMENTATION_LINK,
  doInitPings,
  WebsocketConnection,
} from "@streamlit/app/src/connection/WebsocketConnection"

const MOCK_ALLOWED_ORIGINS_CONFIG = {
  allowedOrigins: ["list", "of", "allowed", "origins"],
  useExternalAuthToken: false,
}

const MOCK_HOST_CONFIG_RESPONSE = {
  data: MOCK_ALLOWED_ORIGINS_CONFIG,
}

const MOCK_HEALTH_RESPONSE = { status: "ok" }

/** Create mock WebsocketConnection arguments */
function createMockArgs(overrides?: Partial<Args>): Args {
  return {
    sessionInfo: new SessionInfo(),
    endpoints: mockEndpoints(),
    baseUriPartsList: [
      {
        host: "localhost",
        port: 1234,
        basePath: "/",
      },
    ],
    onMessage: vi.fn(),
    onConnectionStateChange: vi.fn(),
    onRetry: vi.fn(),
    claimHostAuthToken: () => Promise.resolve(undefined),
    resetHostAuthToken: vi.fn(),
    onHostConfigResp: vi.fn(),
    ...overrides,
  }
}

describe("doInitPings", () => {
  const MOCK_PING_DATA = {
    uri: [
      { host: "not.a.real.host", port: 3000, basePath: "/" },
      { host: "not.a.real.host", port: 3001, basePath: "/" },
    ],
    timeoutMs: 10,
    maxTimeoutMs: 100,
    retryCallback: vi.fn(),
    setAllowedOrigins: vi.fn(),
  }

  let originalAxiosGet: any

  beforeEach(() => {
    originalAxiosGet = axios.get
    MOCK_PING_DATA.retryCallback = vi.fn()
    MOCK_PING_DATA.setAllowedOrigins = vi.fn()
  })

  afterEach(() => {
    axios.get = originalAxiosGet
  })

  it("calls the /_stcore/health endpoint when pinging server", async () => {
    axios.get = vi
      .fn()
      .mockResolvedValueOnce(MOCK_HEALTH_RESPONSE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    const uriIndex = await doInitPings(
      MOCK_PING_DATA.uri,
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      MOCK_PING_DATA.retryCallback,
      MOCK_PING_DATA.setAllowedOrigins
    )
    expect(uriIndex).toEqual(0)
    expect(MOCK_PING_DATA.setAllowedOrigins).toHaveBeenCalledWith(
      MOCK_ALLOWED_ORIGINS_CONFIG
    )
  })

  it("returns the uri index and sets hostConfig for the first successful ping (0)", async () => {
    axios.get = vi
      .fn()
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    const uriIndex = await doInitPings(
      MOCK_PING_DATA.uri,
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      MOCK_PING_DATA.retryCallback,
      MOCK_PING_DATA.setAllowedOrigins
    )
    expect(uriIndex).toEqual(0)
    expect(MOCK_PING_DATA.setAllowedOrigins).toHaveBeenCalledWith(
      MOCK_ALLOWED_ORIGINS_CONFIG
    )
  })

  it("returns the uri index and sets hostConfig for the first successful ping (1)", async () => {
    axios.get = vi
      .fn()
      // First Connection attempt
      .mockRejectedValueOnce(new Error(""))
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Second Connection attempt
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    const uriIndex = await doInitPings(
      MOCK_PING_DATA.uri,
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      MOCK_PING_DATA.retryCallback,
      MOCK_PING_DATA.setAllowedOrigins
    )
    expect(uriIndex).toEqual(1)
    expect(MOCK_PING_DATA.setAllowedOrigins).toHaveBeenCalledWith(
      MOCK_ALLOWED_ORIGINS_CONFIG
    )
  })

  it("calls retry with the corresponding error message if there was an error", async () => {
    const TEST_ERROR_MESSAGE = "ERROR_MESSAGE"

    axios.get = vi
      .fn()
      // First Connection attempt
      .mockRejectedValueOnce(new Error(TEST_ERROR_MESSAGE))
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Second Connection attempt
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    await doInitPings(
      MOCK_PING_DATA.uri,
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      MOCK_PING_DATA.retryCallback,
      MOCK_PING_DATA.setAllowedOrigins
    )

    expect(MOCK_PING_DATA.retryCallback).toHaveBeenCalledWith(
      1,
      TEST_ERROR_MESSAGE,
      expect.anything()
    )
  })

  it("calls retry with 'Connection timed out.' when the error code is `ECONNABORTED`", async () => {
    const TEST_ERROR = { code: "ECONNABORTED" }

    axios.get = vi
      .fn()
      // First Connection attempt
      .mockRejectedValueOnce(TEST_ERROR)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Second Connection attempt
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    await doInitPings(
      MOCK_PING_DATA.uri,
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      MOCK_PING_DATA.retryCallback,
      MOCK_PING_DATA.setAllowedOrigins
    )

    expect(MOCK_PING_DATA.retryCallback).toHaveBeenCalledWith(
      1,
      "Connection timed out.",
      expect.anything()
    )
  })

  it("calls retry with 'Connection failed with status 0.' when there is no response", async () => {
    const TEST_ERROR = {
      response: {
        status: 0,
      },
    }

    axios.get = vi
      .fn()
      // First Connection attempt
      .mockRejectedValueOnce(TEST_ERROR)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Second Connection attempt
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    await doInitPings(
      MOCK_PING_DATA.uri,
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      MOCK_PING_DATA.retryCallback,
      MOCK_PING_DATA.setAllowedOrigins
    )

    expect(MOCK_PING_DATA.retryCallback).toHaveBeenCalledWith(
      1,
      "Connection failed with status 0.",
      expect.anything()
    )
  })

  it("calls retry with 'Connection failed with status 0.' when the request was made but no response was received", async () => {
    const TEST_ERROR = {
      request: {},
    }

    axios.get = vi
      .fn()
      // First Connection attempt
      .mockRejectedValueOnce(TEST_ERROR)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Second Connection attempt
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    await doInitPings(
      MOCK_PING_DATA.uri,
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      MOCK_PING_DATA.retryCallback,
      MOCK_PING_DATA.setAllowedOrigins
    )

    expect(MOCK_PING_DATA.retryCallback).toHaveBeenCalledWith(
      1,
      "Connection failed with status 0.",
      expect.anything()
    )
  })

  it("calls retry with corresponding fragment when there is no response from localhost", async () => {
    const MOCK_PING_DATA_LOCALHOST = {
      ...MOCK_PING_DATA,
      uri: [
        { host: "localhost", port: 3000, basePath: "/" },
        { host: "localhost", port: 3001, basePath: "/" },
      ],
    }

    const TEST_ERROR = {
      response: {
        status: 0,
      },
    }

    axios.get = vi
      .fn()
      // First Connection attempt
      .mockRejectedValueOnce(TEST_ERROR)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Second Connection attempt
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    await doInitPings(
      MOCK_PING_DATA_LOCALHOST.uri,
      MOCK_PING_DATA_LOCALHOST.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      MOCK_PING_DATA_LOCALHOST.retryCallback,
      MOCK_PING_DATA.setAllowedOrigins
    )

    expect(MOCK_PING_DATA_LOCALHOST.retryCallback).toHaveBeenCalledWith(
      1,
      expect.anything(),
      expect.anything()
    )
  })

  it("calls retry with corresponding fragment when the status is 403 (forbidden)", async () => {
    const TEST_ERROR = {
      response: {
        status: 403,
      },
    }

    const Forbidden = (
      <Fragment>
        <p>Cannot connect to Streamlit (HTTP status: 403).</p>
        <p>
          If you are trying to access a Streamlit app running on another
          server, this could be due to the app's{" "}
          <a href={CORS_ERROR_MESSAGE_DOCUMENTATION_LINK}>CORS</a> settings.
        </p>
      </Fragment>
    )

    axios.get = vi
      .fn()
      // First Connection attempt
      .mockRejectedValueOnce(TEST_ERROR)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Second Connection attempt
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    await doInitPings(
      MOCK_PING_DATA.uri,
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      MOCK_PING_DATA.retryCallback,
      MOCK_PING_DATA.setAllowedOrigins
    )

    expect(MOCK_PING_DATA.retryCallback).toHaveBeenCalledWith(
      1,
      Forbidden,
      expect.anything()
    )
  })

  it("calls retry with 'Connection failed with status ...' for any status code other than 0, 403, and 2xx", async () => {
    const TEST_ERROR = {
      response: {
        status: 500,
        data: "TEST_DATA",
      },
    }

    axios.get = vi
      .fn()
      // First Connection attempt
      .mockRejectedValueOnce(TEST_ERROR)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Second Connection attempt
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    await doInitPings(
      MOCK_PING_DATA.uri,
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      MOCK_PING_DATA.retryCallback,
      MOCK_PING_DATA.setAllowedOrigins
    )

    expect(MOCK_PING_DATA.retryCallback).toHaveBeenCalledWith(
      1,
      `Connection failed with status ${TEST_ERROR.response.status}, and response "${TEST_ERROR.response.data}".`,
      expect.anything()
    )
  })

  it("calls retry with correct total tries", async () => {
    const TEST_ERROR_MESSAGE = "TEST_ERROR_MESSAGE"

    axios.get = vi
      .fn()
      // First Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Second Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Third Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Fourth Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Fifth Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Final Attempt (to avoid infinite loop)
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    await doInitPings(
      MOCK_PING_DATA.uri,
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      MOCK_PING_DATA.retryCallback,
      MOCK_PING_DATA.setAllowedOrigins
    )

    expect(MOCK_PING_DATA.retryCallback).toHaveBeenCalledTimes(5)
  })

  it("has increasing but capped retry backoff", async () => {
    const TEST_ERROR_MESSAGE = "TEST_ERROR_MESSAGE"

    axios.get = vi
      .fn()
      // First Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Second Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Third Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Fourth Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Fifth Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Final Attempt (to avoid infinite loop)
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    const timeouts: number[] = []
    const callback = (
      _times: number,
      _errorNode: React.ReactNode,
      timeout: number
    ): void => {
      timeouts.push(timeout)
    }

    await doInitPings(
      [{ host: "not.a.real.host", port: 3000, basePath: "/" }],
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      callback,
      MOCK_PING_DATA.setAllowedOrigins
    )

    expect(timeouts.length).toEqual(5)
    expect(timeouts[0]).toEqual(10)
    expect(timeouts[4]).toEqual(100)
    // timeouts should be monotonically increasing until they hit the cap
    expect(
      zip(timeouts.slice(0, -1), timeouts.slice(1)).every(
        // @ts-expect-error
        timePair => timePair[0] < timePair[1] || timePair[0] === 100
      )
    ).toEqual(true)
  })

  it("backs off independently for each target url", async () => {
    const TEST_ERROR_MESSAGE = "TEST_ERROR_MESSAGE"

    axios.get = vi
      .fn()
      // First Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Second Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Third Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Fourth Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Fifth Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Final Attempt (to avoid infinite loop)
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    const timeouts: number[] = []
    const callback = (
      _times: number,
      _errorNode: React.ReactNode,
      timeout: number
    ): void => {
      timeouts.push(timeout)
    }

    await doInitPings(
      MOCK_PING_DATA.uri,
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      callback,
      MOCK_PING_DATA.setAllowedOrigins
    )

    expect(timeouts.length).toEqual(5)
    expect(timeouts[0]).toEqual(10)
    expect(timeouts[1]).toEqual(10)
    expect(timeouts[2]).toBeGreaterThan(timeouts[0])
    expect(timeouts[3]).toBeGreaterThan(timeouts[1])
  })

  it("resets timeout each ping call", async () => {
    const TEST_ERROR_MESSAGE = "TEST_ERROR_MESSAGE"

    axios.get = vi
      .fn()
      // First Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Second Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Third Connection attempt (successful)
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Fourth Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Fifth Connection attempt
      .mockRejectedValueOnce(TEST_ERROR_MESSAGE)
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)
      // Final Attempt (to avoid infinite loop)
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    const timeouts: number[] = []
    const callback = (
      _times: number,
      _errorNode: React.ReactNode,
      timeout: number
    ): void => {
      timeouts.push(timeout)
    }

    await doInitPings(
      [{ host: "not.a.real.host", port: 3000, basePath: "/" }],
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      callback,
      MOCK_PING_DATA.setAllowedOrigins
    )

    const timeouts2: number[] = []
    const callback2 = (
      _times: number,
      _errorNode: React.ReactNode,
      timeout: number
    ): void => {
      timeouts2.push(timeout)
    }

    await doInitPings(
      [{ host: "not.a.real.host", port: 3000, basePath: "/" }],
      MOCK_PING_DATA.timeoutMs,
      MOCK_PING_DATA.maxTimeoutMs,
      callback2,
      MOCK_PING_DATA.setAllowedOrigins
    )

    expect(timeouts[0]).toEqual(10)
    expect(timeouts[1]).toBeGreaterThan(timeouts[0])
    expect(timeouts2[0]).toEqual(10)
  })
})

describe("WebsocketConnection", () => {
  let client: WebsocketConnection
  let server: WS
  let originalAxiosGet: any

  beforeEach(() => {
    server = new WS("ws://localhost:1234/_stcore/stream")

    originalAxiosGet = axios.get
    axios.get = vi
      .fn()
      .mockResolvedValueOnce("")
      .mockResolvedValueOnce(MOCK_HOST_CONFIG_RESPONSE)

    client = new WebsocketConnection(createMockArgs())
  })

  afterEach(async () => {
    axios.get = originalAxiosGet

    // @ts-expect-error
    if (client.websocket) {
      // @ts-expect-error
      client.websocket.close()
    }
    server.close()
  })

  it("disconnect closes connection and sets state to DISCONNECTED_FOREVER", () => {
    client.disconnect()

    // @ts-expect-error
    expect(client.state).toBe(ConnectionState.DISCONNECTED_FOREVER)
    // @ts-expect-error
    expect(client.websocket).toBe(undefined)
  })

  it("increments message cache run count", () => {
    const incrementRunCountSpy = vi.spyOn(
      // @ts-expect-error
      client.cache,
      "incrementRunCount"
    )

    const TEST_MAX_MESSAGE_AGE = 10
    client.incrementMessageCacheRunCount(TEST_MAX_MESSAGE_AGE)

    expect(incrementRunCountSpy).toHaveBeenCalledWith(TEST_MAX_MESSAGE_AGE)
  })

  it("sends message with correct arguments", async () => {
    await server.connected
    // @ts-expect-error
    const sendSpy = vi.spyOn(client.websocket, "send")

    const TEST_BACK_MSG = {}
    client.sendMessage(TEST_BACK_MSG)

    const msg = BackMsg.create(TEST_BACK_MSG)
    const buffer = BackMsg.encode(msg).finish()

    expect(sendSpy).toHaveBeenCalledWith(buffer)
  })

  describe("getBaseUriParts", () => {
    it("returns correct base uri parts when ConnectionState == Connected", () => {
      // @ts-expect-error
      client.state = ConnectionState.CONNECTED

      expect(client.getBaseUriParts()).toEqual(
        createMockArgs().baseUriPartsList[0]
      )
    })

    it("returns undefined when ConnectionState != Connected", () => {
      expect(client.getBaseUriParts()).toBeUndefined()
    })
  })
})

describe("WebsocketConnection auth token handling", () => {
  let originalAxiosGet: any
  let websocketSpy: any
  let server: WS

  beforeEach(() => {
    server = new WS("ws://localhost:1234/_stcore/stream")
    websocketSpy = vi.spyOn(window, "WebSocket")

    originalAxiosGet = axios.get
    axios.get = vi.fn()
  })

  afterEach(() => {
    axios.get = originalAxiosGet

    server.close()
  })

  it("always sets first Sec-WebSocket-Protocol option to 'streamlit'", async () => {
    const resetHostAuthToken = vi.fn()
    const ws = new WebsocketConnection(createMockArgs({ resetHostAuthToken }))

    // Set correct state for this action
    // @ts-expect-error
    ws.state = ConnectionState.CONNECTING
    // @ts-expect-error
    await ws.connectToWebSocket()

    expect(websocketSpy).toHaveBeenCalledWith(
      "ws://localhost:1234/_stcore/stream",
      ["streamlit", "PLACEHOLDER_AUTH_TOKEN"]
    )
    expect(resetHostAuthToken).toHaveBeenCalledTimes(1)
  })

  it("sets second Sec-WebSocket-Protocol option to value from claimHostAuthToken", async () => {
    const resetHostAuthToken = vi.fn()
    const ws = new WebsocketConnection(
      createMockArgs({
        claimHostAuthToken: () => Promise.resolve("iAmAnAuthToken"),
        resetHostAuthToken,
      })
    )

    // Set correct state for this action
    // @ts-expect-error
    ws.state = ConnectionState.CONNECTING
    // @ts-expect-error
    await ws.connectToWebSocket()

    expect(websocketSpy).toHaveBeenCalledWith(
      "ws://localhost:1234/_stcore/stream",
      ["streamlit", "iAmAnAuthToken"]
    )
  })

  it("sets third Sec-WebSocket-Protocol option to lastSessionId if available", async () => {
    // Create a mock SessionInfo with sessionInfo.last.sessionId == "lastSessionId"
    const sessionInfo = new SessionInfo()
    sessionInfo.setCurrent(
      mockSessionInfoProps({ sessionId: "lastSessionId" })
    )
    sessionInfo.setCurrent(mockSessionInfoProps())
    expect(sessionInfo.last?.sessionId).toBe("lastSessionId")

    const ws = new WebsocketConnection(createMockArgs({ sessionInfo }))

    // Set correct state for this action
    // @ts-expect-error
    ws.state = ConnectionState.CONNECTING
    // @ts-expect-error
    await ws.connectToWebSocket()

    // "lastSessionId" should be the WebSocket's session token
    expect(websocketSpy).toHaveBeenCalledWith(
      "ws://localhost:1234/_stcore/stream",
      ["streamlit", "PLACEHOLDER_AUTH_TOKEN", "lastSessionId"]
    )
  })

  it("sets both host provided auth token and lastSessionId if both set", async () => {
    // Create a mock SessionInfo with sessionInfo.last.sessionId == "lastSessionId"
    const sessionInfo = new SessionInfo()
    sessionInfo.setCurrent(
      mockSessionInfoProps({ sessionId: "lastSessionId" })
    )
    sessionInfo.setCurrent(mockSessionInfoProps())
    expect(sessionInfo.last?.sessionId).toBe("lastSessionId")

    const resetHostAuthToken = vi.fn()
    const ws = new WebsocketConnection(
      createMockArgs({
        sessionInfo,
        claimHostAuthToken: () => Promise.resolve("iAmAnAuthToken"),
        resetHostAuthToken,
      })
    )

    // Set correct state for this action
    // @ts-expect-error
    ws.state = ConnectionState.CONNECTING

    // @ts-expect-error
    await ws.connectToWebSocket()

    expect(websocketSpy).toHaveBeenCalledWith(
      "ws://localhost:1234/_stcore/stream",
      ["streamlit", "iAmAnAuthToken", "lastSessionId"]
    )
    expect(resetHostAuthToken).toHaveBeenCalledTimes(1)
  })
})


================================================
File: /frontend/app/src/connection/WebsocketConnection.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { Fragment } from "react"

import styled from "@emotion/styled"
import axios from "axios"

import {
  BackMsg,
  BaseUriParts,
  buildHttpUri,
  buildWsUri,
  ForwardMsg,
  ForwardMsgCache,
  getCookie,
  IBackMsg,
  IHostConfigResponse,
  isNullOrUndefined,
  logError,
  logMessage,
  logWarning,
  notNullOrUndefined,
  PerformanceEvents,
  Resolver,
  SessionInfo,
  StreamlitEndpoints,
  StreamlitMarkdown,
} from "@streamlit/lib"
import { ConnectionState } from "@streamlit/app/src/connection/ConnectionState"

/**
 * Name of the logger.
 */
const LOG = "WebsocketConnection"

/**
 * The path where we should ping (via HTTP) to see if the server is up.
 */
const SERVER_PING_PATH = "_stcore/health"

/**
 * The path to fetch the host configuration and allowed-message-origins.
 */
const HOST_CONFIG_PATH = "_stcore/host-config"

/**
 * The path of the server's websocket endpoint.
 */
const WEBSOCKET_STREAM_PATH = "_stcore/stream"

/**
 * Min and max wait time between pings in millis.
 */
const PING_MINIMUM_RETRY_PERIOD_MS = 500
const PING_MAXIMUM_RETRY_PERIOD_MS = 1000 * 60

/**
 * Ping timeout in millis.
 */
const PING_TIMEOUT_MS = 15 * 1000

/**
 * Timeout when attempting to connect to a websocket, in millis.
 */
const WEBSOCKET_TIMEOUT_MS = 15 * 1000

/**
 * If the ping retrieves a 403 status code a message will be displayed.
 * This constant is the link to the documentation.
 */
export const CORS_ERROR_MESSAGE_DOCUMENTATION_LINK =
  "https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS"

type OnMessage = (ForwardMsg: any) => void
type OnConnectionStateChange = (
  connectionState: ConnectionState,
  errMsg?: string
) => void
type OnRetry = (
  totalTries: number,
  errorNode: React.ReactNode,
  retryTimeout: number
) => void

export interface Args {
  /** The application's SessionInfo instance */
  sessionInfo: SessionInfo

  endpoints: StreamlitEndpoints

  /**
   * List of URLs to connect to. We'll try the first, then the second, etc. If
   * all fail, we'll retry from the top. The number of retries depends on
   * whether this is a local connection.
   */
  baseUriPartsList: BaseUriParts[]

  /**
   * Function called when our ConnectionState changes.
   * If the new ConnectionState is ERROR, errMsg will be defined.
   */
  onConnectionStateChange: OnConnectionStateChange

  /**
   * Function called every time we ping the server for sign of life.
   */
  onRetry: OnRetry

  /**
   * Function called when we receive a new message.
   */
  onMessage: OnMessage

  /**
   * Function to get the auth token set by the host of this app (if in a
   * relevant deployment scenario).
   */
  claimHostAuthToken: () => Promise<string | undefined>

  /**
   * Function to clear the withHostCommunication hoc's auth token. This should
   * be called after the promise returned by claimHostAuthToken successfully
   * resolves.
   */
  resetHostAuthToken: () => void

  /**
   * Function to set the host config and allowed-message-origins for this app (if in a relevant deployment
   * scenario).
   */
  onHostConfigResp: (resp: IHostConfigResponse) => void
}

interface MessageQueue {
  [index: number]: any
}

/**
 * Events of the WebsocketConnection state machine. Here's what the FSM looks
 * like:
 *
 *   INITIAL
 *     │
 *     │               on ping succeed
 *     v               :
 *   PINGING_SERVER ───────────────> CONNECTING
 *     ^  ^                            │  │
 *     │  │:on timeout/error/closed    │  │
 *     │  └────────────────────────────┘  │
 *     │                                  │
 *     │:on error/closed                  │:on conn succeed
 *   CONNECTED<───────────────────────────┘
 *
 *
 *                    on fatal error or call to .disconnect()
 *                    :
 *   <ANY_STATE> ──────────────> DISCONNECTED_FOREVER
 */
type Event =
  | "INITIALIZED"
  | "CONNECTION_CLOSED"
  | "CONNECTION_ERROR"
  | "CONNECTION_SUCCEEDED"
  | "CONNECTION_TIMED_OUT"
  | "SERVER_PING_SUCCEEDED"
  | "FATAL_ERROR" // Unrecoverable error. This should never happen!

/**
 * This class connects to the server and gets deltas over a websocket connection.
 *
 */
export class WebsocketConnection {
  private readonly args: Args

  /**
   * ForwardMessages get passed through this cache. This gets initialized
   * once we connect to the server.
   */
  private readonly cache: ForwardMsgCache

  /**
   * Index to the URI in uriList that we're going to try to connect to.
   */
  private uriIndex = 0

  /**
   * To guarantee packet transmission order, this is the index of the last
   * dispatched incoming message.
   */
  private lastDispatchedMessageIndex = -1

  /**
   * And this is the index of the next message we receive.
   */
  private nextMessageIndex = 0

  /**
   * This dictionary stores received messages that we haven't sent out yet
   * (because we're still decoding previous messages)
   */
  private readonly messageQueue: MessageQueue = {}

  /**
   * The current state of this object's state machine.
   */
  private state = ConnectionState.INITIAL

  /**
   * The WebSocket object we're connecting with.
   */
  private websocket?: WebSocket

  /**
   * WebSocket objects don't support retries, so we have to implement them
   * ourselves. We use setTimeout to wait for a connection and retry once the
   * timeout fires. This field stores the timer ID from setTimeout, so we can
   * cancel it if needed.
   */
  private wsConnectionTimeoutId?: number

  constructor(props: Args) {
    this.args = props
    this.cache = new ForwardMsgCache(props.endpoints)
    this.stepFsm("INITIALIZED")
  }

  /**
   * Return the BaseUriParts for the server we're connected to,
   * if we are connected to a server.
   */
  public getBaseUriParts(): BaseUriParts | undefined {
    if (this.state === ConnectionState.CONNECTED) {
      return this.args.baseUriPartsList[this.uriIndex]
    }
    return undefined
  }

  public disconnect(): void {
    this.setFsmState(ConnectionState.DISCONNECTED_FOREVER)
  }

  // This should only be called inside stepFsm().
  private setFsmState(state: ConnectionState, errMsg?: string): void {
    logMessage(LOG, `New state: ${state}`)
    this.state = state

    // Perform pre-callback actions when entering certain states.
    switch (this.state) {
      case ConnectionState.PINGING_SERVER:
        this.pingServer()
        break

      default:
        break
    }

    this.args.onConnectionStateChange(state, errMsg)

    // Perform post-callback actions when entering certain states.
    switch (this.state) {
      case ConnectionState.CONNECTING:
        this.connectToWebSocket()
        break

      case ConnectionState.DISCONNECTED_FOREVER:
        this.closeConnection()
        break

      default:
        break
    }
  }

  /**
   * Process an event in our FSM.
   *
   * @param event The event to process.
   * @param errMsg an optional error message to send to the OnStateChanged
   * callback. This is meaningful only for the FATAL_ERROR event. The message
   * will be displayed to the user in a "Connection Error" dialog.
   */
  private stepFsm(event: Event, errMsg?: string): void {
    logMessage(LOG, `State: ${this.state}; Event: ${event}`)

    if (
      event === "FATAL_ERROR" &&
      this.state !== ConnectionState.DISCONNECTED_FOREVER
    ) {
      // If we get a fatal error, we transition to DISCONNECTED_FOREVER
      // regardless of our current state.
      this.setFsmState(ConnectionState.DISCONNECTED_FOREVER, errMsg)
      return
    }

    // Any combination of state+event that is not explicitly called out
    // below is illegal and raises an error.

    switch (this.state) {
      case ConnectionState.INITIAL:
        if (event === "INITIALIZED") {
          this.setFsmState(ConnectionState.PINGING_SERVER)
          return
        }
        break

      case ConnectionState.CONNECTING:
        if (event === "CONNECTION_SUCCEEDED") {
          this.setFsmState(ConnectionState.CONNECTED)
          return
        }
        if (
          event === "CONNECTION_TIMED_OUT" ||
          event === "CONNECTION_ERROR" ||
          event === "CONNECTION_CLOSED"
        ) {
          this.setFsmState(ConnectionState.PINGING_SERVER)
          return
        }
        break

      case ConnectionState.CONNECTED:
        if (event === "CONNECTION_CLOSED" || event === "CONNECTION_ERROR") {
          this.setFsmState(ConnectionState.PINGING_SERVER)
          return
        }
        break

      case ConnectionState.PINGING_SERVER:
        if (event === "SERVER_PING_SUCCEEDED") {
          this.setFsmState(ConnectionState.CONNECTING)
          return
        }
        break

      case ConnectionState.DISCONNECTED_FOREVER:
        // If we're in the DISCONNECTED_FOREVER state, we can't reasonably
        // process any events, and it's possible we're in this state because
        // of a fatal error. Just log these events rather than throwing more
        // exceptions.
        logWarning(
          LOG,
          `Discarding ${event} while in ${ConnectionState.DISCONNECTED_FOREVER}`
        )
        return

      default:
        break
    }

    throw new Error(
      "Unsupported state transition.\n" +
        `State: ${this.state}\n` +
        `Event: ${event}`
    )
  }

  private async pingServer(): Promise<void> {
    this.uriIndex = await doInitPings(
      this.args.baseUriPartsList,
      PING_MINIMUM_RETRY_PERIOD_MS,
      PING_MAXIMUM_RETRY_PERIOD_MS,
      this.args.onRetry,
      this.args.onHostConfigResp
    )

    this.stepFsm("SERVER_PING_SUCCEEDED")
  }

  /**
   * Get the session tokens to use to initialize a WebSocket connection.
   *
   * This method returns an array containing either one or two elements:
   *   1. The first element contains an auth token to be used in environments
   *      where the parent frame of this app needs to pass down an external
   *      auth token. If no token is provided, a placeholder is used.
   *   2. The second element is the session ID to attempt to reconnect to if
   *      one is available (that is, if this websocket has disconnected and is
   *      reconnecting). On the initial connection attempt, this is unset and
   *      the return value of this method is a singleton array.
   */
  private async getSessionTokens(): Promise<Array<string>> {
    const hostAuthToken = await this.args.claimHostAuthToken()
    const xsrfCookie = getCookie("_streamlit_xsrf")
    this.args.resetHostAuthToken()
    return [
      // NOTE: We have to set the auth token to some arbitrary placeholder if
      // not provided since the empty string is an invalid protocol option.
      hostAuthToken ?? xsrfCookie ?? "PLACEHOLDER_AUTH_TOKEN",
      ...(this.args.sessionInfo.last?.sessionId
        ? [this.args.sessionInfo.last?.sessionId]
        : []),
    ]
  }

  private async connectToWebSocket(): Promise<void> {
    const uri = buildWsUri(
      this.args.baseUriPartsList[this.uriIndex],
      WEBSOCKET_STREAM_PATH
    )

    if (notNullOrUndefined(this.websocket)) {
      // This should never happen. We set the websocket to null in both FSM
      // nodes that lead to this one.
      throw new Error("Websocket already exists")
    }

    logMessage(LOG, "creating WebSocket")

    // NOTE: We repurpose the Sec-WebSocket-Protocol header (set via the second
    // parameter to the WebSocket constructor) here in a slightly unfortunate
    // but necessary way. The browser WebSocket API doesn't allow us to set
    // arbitrary HTTP headers, and this header is the only one where we have
    // the ability to set it to arbitrary values. Thus, we use it to pass auth
    // and session tokens from client to server as the second/third values in
    // the list.
    //
    // The reason why these tokens are set as the second/third values is that,
    // when Sec-WebSocket-Protocol is set, many clients expect the server to
    // respond with a selected subprotocol to use. We don't want that reply to
    // contain sensitive data, so we just hard-code it to "streamlit".
    const sessionTokens = await this.getSessionTokens()
    this.websocket = new WebSocket(uri, ["streamlit", ...sessionTokens])
    this.websocket.binaryType = "arraybuffer"

    this.setConnectionTimeout(uri)

    const localWebsocket = this.websocket
    const checkWebsocket = (): boolean => localWebsocket === this.websocket

    this.websocket.addEventListener("message", (event: MessageEvent) => {
      if (checkWebsocket()) {
        this.handleMessage(event.data).catch(reason => {
          const err = `Failed to process a Websocket message (${reason})`
          logError(LOG, err)
          this.stepFsm("FATAL_ERROR", err)
        })
      }
    })

    this.websocket.addEventListener("open", () => {
      if (checkWebsocket()) {
        logMessage(LOG, "WebSocket onopen")
        this.stepFsm("CONNECTION_SUCCEEDED")
      }
    })

    this.websocket.addEventListener("close", () => {
      if (checkWebsocket()) {
        logWarning(LOG, "WebSocket onclose")
        this.closeConnection()
        this.stepFsm("CONNECTION_CLOSED")
      }
    })

    this.websocket.addEventListener("error", () => {
      if (checkWebsocket()) {
        logError(LOG, "WebSocket onerror")
        this.closeConnection()
        this.stepFsm("CONNECTION_ERROR")
      }
    })
  }

  private setConnectionTimeout(uri: string): void {
    if (notNullOrUndefined(this.wsConnectionTimeoutId)) {
      // This should never happen. We set the timeout ID to null in both FSM
      // nodes that lead to this one.
      throw new Error("WS timeout is already set")
    }

    const localWebsocket = this.websocket

    this.wsConnectionTimeoutId = window.setTimeout(() => {
      if (localWebsocket !== this.websocket) {
        return
      }

      if (isNullOrUndefined(this.wsConnectionTimeoutId)) {
        // Sometimes the clearTimeout doesn't work. No idea why :-/
        logWarning(LOG, "Timeout fired after cancellation")
        return
      }

      if (isNullOrUndefined(this.websocket)) {
        // This should never happen! The only place we call
        // setConnectionTimeout() should be immediately before setting
        // this.websocket.
        this.closeConnection()
        this.stepFsm("FATAL_ERROR", "Null Websocket in setConnectionTimeout")
        return
      }

      if (this.websocket.readyState === 0 /* CONNECTING */) {
        logMessage(LOG, `${uri} timed out`)
        this.closeConnection()
        this.stepFsm("CONNECTION_TIMED_OUT")
      }
    }, WEBSOCKET_TIMEOUT_MS)
    logMessage(LOG, `Set WS timeout ${this.wsConnectionTimeoutId}`)
  }

  private closeConnection(): void {
    // Need to make sure the websocket is closed in the same function that
    // cancels the connection timer. Otherwise, due to javascript's concurrency
    // model, when the onclose event fires it can get handled in between the
    // two functions, causing two events to be sent to the FSM: a
    // CONNECTION_TIMED_OUT and a CONNECTION_ERROR.

    if (this.websocket) {
      this.websocket.close()
      this.websocket = undefined
    }

    if (notNullOrUndefined(this.wsConnectionTimeoutId)) {
      logMessage(LOG, `Clearing WS timeout ${this.wsConnectionTimeoutId}`)
      window.clearTimeout(this.wsConnectionTimeoutId)
      this.wsConnectionTimeoutId = undefined
    }
  }

  /**
   * Encodes the message with the outgoingMessageType and sends it over the
   * wire.
   */
  public sendMessage(obj: IBackMsg): void {
    if (!this.websocket) {
      return
    }

    const msg = BackMsg.create(obj)
    const buffer = BackMsg.encode(msg).finish()
    this.websocket.send(buffer)
  }

  /**
   * Called when our script has finished running. Calls through
   * to the ForwardMsgCache, to handle cached entry expiry.
   */
  public incrementMessageCacheRunCount(maxMessageAge: number): void {
    this.cache.incrementRunCount(maxMessageAge)
  }

  private async handleMessage(data: ArrayBuffer): Promise<void> {
    // Assign this message an index.
    const messageIndex = this.nextMessageIndex
    this.nextMessageIndex += 1

    PerformanceEvents.record({ name: "BeginHandleMessage", messageIndex })

    const encodedMsg = new Uint8Array(data)
    const msg = ForwardMsg.decode(encodedMsg)

    PerformanceEvents.record({
      name: "DecodedMessage",
      messageIndex,
      messageType: msg.type,
      len: data.byteLength,
    })

    this.messageQueue[messageIndex] = await this.cache.processMessagePayload(
      msg,
      encodedMsg
    )

    PerformanceEvents.record({ name: "GotCachedPayload", messageIndex })

    // Dispatch any pending messages in the queue. This may *not* result
    // in our just-decoded message being dispatched: if there are other
    // messages that were received earlier than this one but are being
    // downloaded, our message won't be sent until they're done.
    while (this.lastDispatchedMessageIndex + 1 in this.messageQueue) {
      const dispatchMessageIndex = this.lastDispatchedMessageIndex + 1
      this.args.onMessage(this.messageQueue[dispatchMessageIndex])
      PerformanceEvents.record({
        name: "DispatchedMessage",
        messageIndex: dispatchMessageIndex,
        messageType: this.messageQueue[dispatchMessageIndex].type,
      })
      delete this.messageQueue[dispatchMessageIndex]
      this.lastDispatchedMessageIndex = dispatchMessageIndex
    }
  }
}

export const StyledBashCode = styled.code(({ theme }) => ({
  fontFamily: theme.genericFonts.codeFont,
  fontSize: theme.fontSizes.sm,
  "&::before": {
    content: '"$"',
    // eslint-disable-next-line streamlit-custom/no-hardcoded-theme-values
    marginRight: "1ex",
  },
}))

/**
 * Attempts to connect to the URIs in uriList (in round-robin fashion) and
 * retries forever until one of the URIs responds with 'ok'.
 * Returns a promise with the index of the URI that worked.
 */
export function doInitPings(
  uriPartsList: BaseUriParts[],
  minimumTimeoutMs: number,
  maximumTimeoutMs: number,
  retryCallback: OnRetry,
  onHostConfigResp: (resp: IHostConfigResponse) => void
): Promise<number> {
  const resolver = new Resolver<number>()
  let totalTries = 0
  let uriNumber = 0

  // Hoist the connect() declaration.
  let connect = (): void => {}

  const retryImmediately = (): void => {
    uriNumber++
    if (uriNumber >= uriPartsList.length) {
      uriNumber = 0
    }

    connect()
  }

  const retry = (errorNode: React.ReactNode): void => {
    // Adjust retry time by +- 20% to spread out load
    const jitter = Math.random() * 0.4 - 0.2
    // Exponential backoff to reduce load from health pings when experiencing
    // persistent failure. Starts at minimumTimeoutMs.
    const timeoutMs =
      totalTries === 1
        ? minimumTimeoutMs
        : minimumTimeoutMs * 2 ** (totalTries - 1) * (1 + jitter)
    const retryTimeout = Math.min(maximumTimeoutMs, timeoutMs)

    retryCallback(totalTries, errorNode, retryTimeout)

    window.setTimeout(retryImmediately, retryTimeout)
  }

  const retryWhenTheresNoResponse = (): void => {
    const uriParts = uriPartsList[uriNumber]
    const uri = new URL(buildHttpUri(uriParts, ""))

    if (uri.hostname === "localhost") {
      const markdownMessage = `
Is Streamlit still running? If you accidentally stopped Streamlit, just restart it in your terminal:

\`\`\`bash
streamlit run yourscript.py
\`\`\`
      `
      retry(<StreamlitMarkdown source={markdownMessage} allowHTML={false} />)
    } else {
      retry("Connection failed with status 0.")
    }
  }

  const retryWhenIsForbidden = (): void => {
    retry(
      <Fragment>
        <p>Cannot connect to Streamlit (HTTP status: 403).</p>
        <p>
          If you are trying to access a Streamlit app running on another
          server, this could be due to the app's{" "}
          <a href={CORS_ERROR_MESSAGE_DOCUMENTATION_LINK}>CORS</a> settings.
        </p>
      </Fragment>
    )
  }

  connect = () => {
    const uriParts = uriPartsList[uriNumber]
    const healthzUri = buildHttpUri(uriParts, SERVER_PING_PATH)
    const hostConfigUri = buildHttpUri(uriParts, HOST_CONFIG_PATH)

    logMessage(LOG, `Attempting to connect to ${healthzUri}.`)

    if (uriNumber === 0) {
      totalTries++
    }

    // We fire off requests to the server's healthz and host-config
    // endpoints in parallel to avoid having to wait on too many sequential
    // round trip network requests before we can try to establish a WebSocket
    // connection. Technically, it would have been possible to implement a
    // single "get server health and origins whitelist" endpoint, but we chose
    // not to do so as it's semantically cleaner to not give the healthcheck
    // endpoint additional responsibilities.
    Promise.all([
      axios.get(healthzUri, { timeout: PING_TIMEOUT_MS }),
      axios.get(hostConfigUri, { timeout: PING_TIMEOUT_MS }),
    ])
      .then(([_, hostConfigResp]) => {
        onHostConfigResp(hostConfigResp.data)
        resolver.resolve(uriNumber)
      })
      .catch(error => {
        if (error.code === "ECONNABORTED") {
          return retry("Connection timed out.")
        }

        if (error.response) {
          // The request was made and the server responded with a status code
          // that falls out of the range of 2xx

          const { data, status } = error.response

          if (status === /* NO RESPONSE */ 0) {
            return retryWhenTheresNoResponse()
          }
          if (status === 403) {
            return retryWhenIsForbidden()
          }
          return retry(
            `Connection failed with status ${status}, ` +
              `and response "${data}".`
          )
        }
        if (error.request) {
          // The request was made but no response was received
          // `error.request` is an instance of XMLHttpRequest in the browser and an instance of
          // http.ClientRequest in node.js
          return retryWhenTheresNoResponse()
        }
        // Something happened in setting up the request that triggered an Error
        return retry(error.message)
      })
  }

  connect()

  return resolver.promise
}


================================================
File: /frontend/app/src/hocs/withScreencast/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./withScreencast"


================================================
File: /frontend/app/src/hocs/withScreencast/withScreencast.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { PureComponent, ReactElement } from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib"

import withScreencast, { ScreenCastHOC, Steps } from "./withScreencast"

vi.mock("@streamlit/app/src/util/ScreenCastRecorder")

interface TestProps {
  screenCast: ScreenCastHOC
  testOverride?: Steps

  /**
   * A property that's not related to the withScreencast wrapper.
   * We test that the wrapper passes unrelated props to its wrapped component.
   */
  unrelatedProp: string
}

class TestComponent extends PureComponent<TestProps> {
  public render = (): ReactElement => (
    <>
      <div>{this.props.unrelatedProp}</div>
      <div>{this.props.screenCast ? "Screencast" : "Undefined"}</div>
    </>
  )
}

const WrappedTestComponent = withScreencast(TestComponent)

describe("withScreencast HOC", () => {
  it("renders without crashing", () => {
    render(<WrappedTestComponent unrelatedProp={"mockLabel"} />)
    expect(screen.getByTestId("stScreencast")).toBeInTheDocument()
  })

  it("wrapped component should have screenCast prop", () => {
    render(<WrappedTestComponent unrelatedProp={"mockLabel"} />)
    expect(screen.getByText("Screencast")).toBeInTheDocument()
  })

  it("passes other props to wrapped component", () => {
    render(<WrappedTestComponent unrelatedProp={"mockLabel"} />)
    expect(screen.getByText("mockLabel")).toBeInTheDocument()
  })

  it("defines displayName", () => {
    render(<WrappedTestComponent unrelatedProp={"mockLabel"} />)
    expect(WrappedTestComponent.displayName).toBe(
      "withScreencast(TestComponent)"
    )
  })

  describe("Steps", () => {
    it("shows a configuration dialog before start recording", () => {
      render(
        <WrappedTestComponent
          unrelatedProp={"mockLabel"}
          testOverride={"SETUP"}
        />
      )
      expect(screen.getByTestId("stScreencastInstruction")).toBeInTheDocument()
    })

    it("shows a countdown after setup", () => {
      render(
        <WrappedTestComponent
          unrelatedProp={"mockLabel"}
          testOverride={"COUNTDOWN"}
        />
      )
      expect(screen.getByTestId("stCountdown")).toBeInTheDocument()
    })

    it("shows an unsupported dialog when it's an unsupported browser", () => {
      render(
        <WrappedTestComponent
          unrelatedProp={"mockLabel"}
          testOverride={"UNSUPPORTED"}
        />
      )
      expect(
        screen.getByTestId("stUnsupportedBrowserDialog")
      ).toBeInTheDocument()
    })
  })
})


================================================
File: /frontend/app/src/hocs/withScreencast/withScreencast.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ComponentType, PureComponent, ReactNode } from "react"

import hoistNonReactStatics from "hoist-non-react-statics"

import { isNullOrUndefined, logWarning } from "@streamlit/lib"
import ScreenCastRecorder from "@streamlit/app/src/util/ScreenCastRecorder"
import {
  ScreencastDialog,
  UnsupportedBrowserDialog,
  VideoRecordedDialog,
} from "@streamlit/app/src/hocs/withScreencast/components"
import Countdown from "@streamlit/app/src/components/Countdown"

export type Steps =
  | "UNSUPPORTED"
  | "OFF"
  | "SETUP"
  | "COUNTDOWN"
  | "RECORDING"
  | "PREVIEW_FILE"

interface WithScreenCastState {
  fileName: string
  recordAudio: boolean
  outputBlob?: Blob
  currentState: Steps
}

export interface ScreenCastHOC {
  currentState: Steps
  toggleRecordAudio: () => void
  startRecording: (fileName: string) => void
  stopRecording: () => void
}

interface InjectedProps {
  screenCast: ScreenCastHOC
  testOverride?: Steps
}

type WrappedProps<P extends InjectedProps> = Omit<P, "screenCast">

function withScreencast<P extends InjectedProps>(
  WrappedComponent: ComponentType<React.PropsWithChildren<P>>
): ComponentType<React.PropsWithChildren<WrappedProps<P>>> {
  class ComponentWithScreencast extends PureComponent<
    WrappedProps<P>,
    WithScreenCastState
  > {
    public static readonly displayName = `withScreencast(${
      WrappedComponent.displayName || WrappedComponent.name
    })`

    private recorder?: ScreenCastRecorder | null

    state = {
      fileName: "streamlit-screencast",
      recordAudio: false,
      currentState: this.props.testOverride || ("OFF" as Steps),
    }

    private toggleRecordAudio = (): void => {
      const { recordAudio } = this.state
      this.setState({ recordAudio: !recordAudio })
    }

    private showDialog = (fileName: string): void => {
      const { currentState } = this.state

      if (!ScreenCastRecorder.isSupportedBrowser()) {
        this.setState({ currentState: "UNSUPPORTED" })
      } else if (currentState === "OFF") {
        this.setState({
          fileName,
          currentState: "SETUP",
        })
      } else {
        this.stopRecording().catch(err =>
          logWarning(`withScreencast.stopRecording threw an error: ${err}`)
        )
      }
    }

    public startRecording = async (): Promise<any> => {
      const { recordAudio } = this.state

      this.recorder = new ScreenCastRecorder({
        recordAudio,
        onErrorOrStop: () => this.stopRecording(),
      })

      try {
        await this.recorder.initialize()
      } catch (e) {
        logWarning(`ScreenCastRecorder.initialize error: ${e}`)
        this.setState({ currentState: "UNSUPPORTED" })
        return
      }

      this.setState({ currentState: "COUNTDOWN" })
    }

    private stopRecording = async (): Promise<any> => {
      let outputBlob
      const { currentState } = this.state

      // We should do nothing if the user try to stop recording when it is not started
      if (currentState === "OFF" || isNullOrUndefined(this.recorder)) {
        return
      }

      if (currentState === "COUNTDOWN") {
        this.setState({
          currentState: "OFF",
        })
      }

      if (currentState === "RECORDING") {
        if (this.recorder.getState() === "inactive") {
          this.setState({
            currentState: "OFF",
          })
        } else {
          outputBlob = await this.recorder.stop()
          this.setState({
            outputBlob,
            currentState: "PREVIEW_FILE",
          })
        }
      }
    }

    private onCountdownEnd = async (): Promise<any> => {
      if (isNullOrUndefined(this.recorder)) {
        // Should never happen.
        throw new Error("Countdown finished but recorder is null")
      }

      const hasStarted = this.recorder.start()

      if (hasStarted) {
        this.setState({
          currentState: "RECORDING",
        })
      } else {
        this.stopRecording().catch(err =>
          logWarning(`withScreencast.stopRecording threw an error: ${err}`)
        )
      }
    }

    private getScreenCastProps = (): ScreenCastHOC => ({
      currentState: this.state.currentState,
      toggleRecordAudio: this.toggleRecordAudio,
      startRecording: this.showDialog,
      stopRecording: this.stopRecording,
    })

    private closeDialog = (): void => {
      this.setState({
        currentState: "OFF",
      })
    }

    public render = (): ReactNode => {
      const {
        outputBlob,
        fileName,
        recordAudio,
        currentState,
      }: WithScreenCastState = this.state

      return (
        <div className="withScreencast" data-testid="stScreencast">
          <WrappedComponent
            {...(this.props as P)}
            screenCast={this.getScreenCastProps()}
          />

          {currentState === "UNSUPPORTED" && (
            <UnsupportedBrowserDialog onClose={this.closeDialog} />
          )}

          {currentState === "SETUP" && (
            <ScreencastDialog
              recordAudio={recordAudio}
              onClose={this.closeDialog}
              startRecording={this.startRecording}
              toggleRecordAudio={this.toggleRecordAudio}
            />
          )}

          {currentState === "COUNTDOWN" && (
            <Countdown countdown={3} endCallback={this.onCountdownEnd} />
          )}

          {currentState === "PREVIEW_FILE" && outputBlob && (
            <VideoRecordedDialog
              onClose={this.closeDialog}
              videoBlob={outputBlob}
              fileName={fileName}
            />
          )}
        </div>
      )
    }
  }

  // Static methods must be copied over
  // https://en.reactjs.org/docs/higher-order-components.html#static-methods-must-be-copied-over
  return hoistNonReactStatics(ComponentWithScreencast, WrappedComponent)
}

export default withScreencast


================================================
File: /frontend/app/src/hocs/withScreencast/components/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Dialogs
export { default as ScreencastDialog } from "./ScreencastDialog/ScreencastDialog"
export { default as VideoRecordedDialog } from "./VideoRecordedDialog/VideoRecordedDialog"
export { default as UnsupportedBrowserDialog } from "./UnsupportedBrowserDialog/UnsupportedBrowserDialog"


================================================
File: /frontend/app/src/hocs/withScreencast/components/ScreencastDialog/ScreencastDialog.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { BaseProvider, LightTheme } from "baseui"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib"

import ScreencastDialog, { Props } from "./ScreencastDialog"

const getProps = (props: Partial<Props> = {}): Props => ({
  onClose: vi.fn(),
  startRecording: vi.fn(),
  toggleRecordAudio: vi.fn(),
  recordAudio: false,
  ...props,
})

describe("ScreencastDialog", () => {
  const props = getProps()

  it("renders without crashing", () => {
    render(
      <BaseProvider theme={LightTheme}>
        <ScreencastDialog {...props} />
      </BaseProvider>
    )
    expect(screen.getByRole("dialog")).toBeInTheDocument()
  })

  it("should render a header", () => {
    render(
      <BaseProvider theme={LightTheme}>
        <ScreencastDialog {...props} />
      </BaseProvider>
    )
    expect(screen.getByText("Record a screencast")).toBeInTheDocument()
  })

  describe("Modal body", () => {
    it("should have a record audio option to be selected", async () => {
      const user = userEvent.setup()
      render(
        <BaseProvider theme={LightTheme}>
          <ScreencastDialog {...props} />
        </BaseProvider>
      )
      expect(
        screen.getByTestId("stScreencastAudioCheckbox")
      ).toHaveTextContent("Also record audio")
      const audioCheckbox = screen.getByRole("checkbox")
      await user.click(audioCheckbox)
      expect(audioCheckbox).toBeChecked()
      expect(props.toggleRecordAudio).toHaveBeenCalled()
    })

    it("should have the stop recording explanation message", () => {
      render(
        <BaseProvider theme={LightTheme}>
          <ScreencastDialog {...props} />
        </BaseProvider>
      )
      const instruction = screen.getByTestId("stScreencastInstruction")
      expect(instruction).toHaveTextContent(
        "Press Esc any time to stop recording."
      )
    })
  })

  describe("Modal footer", () => {
    it("should have an start button", async () => {
      const user = userEvent.setup()
      render(
        <BaseProvider theme={LightTheme}>
          <ScreencastDialog {...props} />
        </BaseProvider>
      )
      const startButton = screen.getByText("Start recording!")
      expect(startButton).toBeInTheDocument()
      await user.click(startButton)
      expect(props.startRecording).toHaveBeenCalled()
      expect(props.onClose).toHaveBeenCalled()
    })
  })
})


================================================
File: /frontend/app/src/hocs/withScreencast/components/ScreencastDialog/ScreencastDialog.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ChangeEvent, useCallback, useState } from "react"

import {
  BaseButtonKind,
  Modal,
  ModalBody,
  ModalButton,
  ModalFooter,
  ModalHeader,
  StreamlitMarkdown,
} from "@streamlit/lib"

import { StyledInstruction, StyledRecordAudioLabel } from "./styled-components"

export interface Props {
  /** Callback to close the dialog */
  onClose: () => void
  toggleRecordAudio: () => void
  recordAudio: boolean
  startRecording: () => void
}

const ScreencastDialog: React.FC<Props> = ({
  onClose,
  toggleRecordAudio,
  recordAudio: initialRecordAudio,
  startRecording,
}) => {
  const [recordAudio, setRecordAudio] = useState(initialRecordAudio)

  const handleRecordAudioCheckbox = useCallback(
    (e: ChangeEvent<HTMLInputElement>): void => {
      const { checked } = e.target
      if (checked !== recordAudio) {
        setRecordAudio(checked)
        toggleRecordAudio()
      }
    },
    [recordAudio, toggleRecordAudio]
  )

  const handleStartButton = useCallback((): void => {
    startRecording()
    onClose()
  }, [startRecording, onClose])

  return (
    <Modal isOpen onClose={onClose}>
      <ModalHeader>Record a screencast</ModalHeader>
      <ModalBody>
        <p>
          This will record a video with the contents of your screen, so you can
          easily share what you're seeing with others.
        </p>
        <p>
          <StyledRecordAudioLabel data-testid="stScreencastAudioCheckbox">
            <input
              type="checkbox"
              name="recordAudio"
              checked={recordAudio}
              onChange={handleRecordAudioCheckbox}
            />{" "}
            Also record audio
          </StyledRecordAudioLabel>
        </p>
        <StyledInstruction data-testid="stScreencastInstruction">
          <StreamlitMarkdown
            source="Press `Esc` any time to stop recording."
            allowHTML={false}
          />
        </StyledInstruction>
      </ModalBody>
      <ModalFooter>
        <ModalButton
          kind={BaseButtonKind.SECONDARY}
          onClick={handleStartButton}
        >
          Start recording!
        </ModalButton>
      </ModalFooter>
    </Modal>
  )
}

export default ScreencastDialog


================================================
File: /frontend/app/src/hocs/withScreencast/components/ScreencastDialog/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./ScreencastDialog"


================================================
File: /frontend/app/src/hocs/withScreencast/components/ScreencastDialog/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledRecordAudioLabel = styled.label({
  margin: 0,
})

export const StyledInstruction = styled.p({
  margin: 0,
})


================================================
File: /frontend/app/src/hocs/withScreencast/components/UnsupportedBrowserDialog/UnsupportedBrowserDialog.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { BaseProvider, LightTheme } from "baseui"
import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib"

import UnsupportedBrowserDialog from "./UnsupportedBrowserDialog"

describe("UnsupportedBrowserDialog", () => {
  it("renders without crashing", () => {
    render(
      <BaseProvider theme={LightTheme}>
        <UnsupportedBrowserDialog onClose={() => {}} />
      </BaseProvider>
    )

    expect(screen.getByTestId("stDialog")).toBeInTheDocument()
    expect(
      screen.getByTestId("stUnsupportedBrowserDialog")
    ).toBeInTheDocument()
  })

  it("should render a header", () => {
    const onClose = vi.fn()
    render(
      <BaseProvider theme={LightTheme}>
        <UnsupportedBrowserDialog onClose={onClose} />
      </BaseProvider>
    )

    expect(
      screen.getByTestId("stUnsupportedBrowserDialog")
    ).toBeInTheDocument()
    expect(screen.getByText("Record a screencast")).toBeInTheDocument()
  })

  it("should render a body with the correct message", () => {
    render(
      <BaseProvider theme={LightTheme}>
        <UnsupportedBrowserDialog onClose={() => {}} />
      </BaseProvider>
    )
    expect(
      screen.getByTestId("stUnsupportedBrowserDialog")
    ).toBeInTheDocument()
    expect(screen.getByText("👾")).toBeInTheDocument()
    expect(
      screen.getByText(
        "Due to limitations with some browsers, this feature is only supported on recent desktop versions of Chrome, Firefox, and Edge."
      )
    ).toBeInTheDocument()
  })
})


================================================
File: /frontend/app/src/hocs/withScreencast/components/UnsupportedBrowserDialog/UnsupportedBrowserDialog.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { memo } from "react"

import { Modal, ModalBody, ModalHeader } from "@streamlit/lib"

import {
  StyledScreenCastWarningDialog,
  StyledUnsupportedScreenCastExplanation,
  StyledUnsupportedScreenCastIcon,
} from "./styled-components"

export interface Props {
  /** Callback to close the dialog */
  onClose: () => void
}

const UnsupportedBrowserDialog: React.FC<Props> = ({ onClose }) => {
  return (
    <Modal isOpen onClose={onClose}>
      <ModalHeader>Record a screencast</ModalHeader>
      <ModalBody>
        <StyledScreenCastWarningDialog data-testid="stUnsupportedBrowserDialog">
          <StyledUnsupportedScreenCastIcon>
            <span role="img" aria-label="Alien Monster">
              👾
            </span>
          </StyledUnsupportedScreenCastIcon>
          <StyledUnsupportedScreenCastExplanation>
            Due to limitations with some browsers, this feature is only
            supported on recent desktop versions of Chrome, Firefox, and Edge.
          </StyledUnsupportedScreenCastExplanation>
        </StyledScreenCastWarningDialog>
      </ModalBody>
    </Modal>
  )
}

export default memo(UnsupportedBrowserDialog)


================================================
File: /frontend/app/src/hocs/withScreencast/components/UnsupportedBrowserDialog/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./UnsupportedBrowserDialog"


================================================
File: /frontend/app/src/hocs/withScreencast/components/UnsupportedBrowserDialog/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledScreenCastWarningDialog = styled.div({
  display: "flex",
})

export const StyledUnsupportedScreenCastIcon = styled.div(({ theme }) => ({
  display: "flex",
  alignItems: "center",
  justifyItems: "center",
  marginRight: theme.spacing.twoXL,
  marginLeft: theme.spacing.sm,
  fontSize: theme.fontSizes.fourXL,
}))

export const StyledUnsupportedScreenCastExplanation = styled.p(
  ({ theme }) => ({
    margin: theme.spacing.none,
  })
)


================================================
File: /frontend/app/src/hocs/withScreencast/components/VideoRecordedDialog/VideoRecordedDialog.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { BaseProvider, LightTheme } from "baseui"
import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib"

import VideoRecordedDialog, { Props } from "./VideoRecordedDialog"

URL.createObjectURL = vi.fn()

const getProps = (props: Partial<Props> = {}): Props => ({
  fileName: "test",
  onClose: vi.fn(),
  videoBlob: new Blob(),
  ...props,
})

describe("VideoRecordedDialog", () => {
  const props = getProps()

  it("renders without crashing", () => {
    render(
      <BaseProvider theme={LightTheme}>
        <VideoRecordedDialog {...props} />
      </BaseProvider>
    )
    expect(screen.getByTestId("stDialog")).toBeInTheDocument()
    expect(screen.getByTestId("stVideoRecordedDialog")).toBeInTheDocument()
  })

  it("should render a header", () => {
    render(
      <BaseProvider theme={LightTheme}>
        <VideoRecordedDialog {...props} />
      </BaseProvider>
    )
    expect(screen.getByText("Next steps")).toHaveStyle("font-weight: 600")
  })

  it("should render a video", () => {
    render(
      <BaseProvider theme={LightTheme}>
        <VideoRecordedDialog {...props} />
      </BaseProvider>
    )
    expect(screen.getByTestId("stVideoRecordedDialog")).toBeInTheDocument()
    expect(screen.getByRole("link")).toHaveAttribute(
      "href",
      "https://www.webmproject.org/"
    )
    expect(URL.createObjectURL).toHaveBeenCalled()
  })

  it("should render a download button", async () => {
    const user = userEvent.setup()
    render(
      <BaseProvider theme={LightTheme}>
        <VideoRecordedDialog {...props} />
      </BaseProvider>
    )
    const downloadButton = screen.getByRole("button", {
      name: "Save video to disk",
    })

    expect(downloadButton).toBeInTheDocument()
    await user.click(downloadButton)
    expect(props.onClose).toHaveBeenCalled()
  })
})


================================================
File: /frontend/app/src/hocs/withScreencast/components/VideoRecordedDialog/VideoRecordedDialog.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FunctionComponent } from "react"

import {
  BaseButton,
  BaseButtonKind,
  Modal,
  ModalBody,
  ModalHeader,
} from "@streamlit/lib"

import {
  StyledDialogContainer,
  StyledDownloadButtonContainer,
  StyledFirstColumn,
  StyledRow,
  StyledSecondColumn,
  StyledVideo,
  StyledVideoFormatInstructions,
} from "./styled-components"

export interface Props {
  /** Callback to close the dialog */
  onClose: () => void
  videoBlob: Blob

  fileName: string
}
const VideoRecordedDialog: FunctionComponent<
  React.PropsWithChildren<Props>
> = ({ onClose, videoBlob, fileName }) => {
  const videoSource = URL.createObjectURL(videoBlob)
  const handleDownloadClick: () => void = () => {
    // Downloads are only done on links, so create a hidden one and click it
    // for the user.
    const link = document.createElement("a")
    link.setAttribute("href", videoSource)
    link.setAttribute("download", `${fileName}.webm`)
    link.click()

    onClose()
  }

  return (
    <Modal
      isOpen
      onClose={onClose}
      overrides={{
        Dialog: {
          style: {
            width: "80vw",
          },
        },
      }}
    >
      <ModalHeader>Next steps</ModalHeader>
      <ModalBody>
        <StyledDialogContainer data-testid="stVideoRecordedDialog">
          <StyledRow>
            <StyledFirstColumn>Step 1</StyledFirstColumn>
            <StyledSecondColumn>
              <p>Preview your video below:</p>
              <StyledVideo src={videoSource} controls />
            </StyledSecondColumn>
          </StyledRow>

          <StyledRow>
            <StyledFirstColumn>Step 2</StyledFirstColumn>
            <StyledSecondColumn>
              <StyledDownloadButtonContainer>
                <BaseButton
                  kind={BaseButtonKind.SECONDARY}
                  onClick={handleDownloadClick}
                >
                  Save video to disk
                </BaseButton>
              </StyledDownloadButtonContainer>
              <StyledVideoFormatInstructions>
                This video is encoded in the{" "}
                <a href="https://www.webmproject.org/">WebM format</a>, which
                is only supported by newer video players. You can also play it
                by dragging the file directly into your browser.
              </StyledVideoFormatInstructions>
            </StyledSecondColumn>
          </StyledRow>

          <StyledRow>
            <StyledFirstColumn>Step 3</StyledFirstColumn>
            <StyledSecondColumn>
              Share your video with the world on Twitter, LinkedIn, YouTube, or
              just plain email!{" "}
              <span role="img" aria-label="Happy">
                😀
              </span>
            </StyledSecondColumn>
          </StyledRow>
        </StyledDialogContainer>
      </ModalBody>
    </Modal>
  )
}

export default VideoRecordedDialog


================================================
File: /frontend/app/src/hocs/withScreencast/components/VideoRecordedDialog/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./VideoRecordedDialog"


================================================
File: /frontend/app/src/hocs/withScreencast/components/VideoRecordedDialog/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledVideo = styled.video(({ theme }) => ({
  width: theme.sizes.full,
  borderRadius: theme.radii.md,
}))

export const StyledDialogContainer = styled.div(({ theme }) => ({
  display: "flex",
  flexDirection: "column",
  width: theme.sizes.full,
}))

export const StyledRow = styled.div(({ theme }) => ({
  display: "flex",
  flexDirection: "row",
  paddingTop: theme.spacing.md,
  paddingBottom: theme.spacing.md,
}))

export const StyledFirstColumn = styled.div(({ theme }) => ({
  paddingRight: theme.spacing.lg,
  textAlign: "right",
  color: theme.colors.gray,
  fontWeight: theme.fontWeights.bold,
  width: "6em",
}))

export const StyledSecondColumn = styled.div(({ theme }) => ({
  flex: 1,
  paddingRight: theme.spacing.lg,
  marginRight: "6em",
  [`@media (max-width: ${theme.breakpoints.sm})`]: {
    marginRight: theme.spacing.none,
  },
}))

export const StyledVideoFormatInstructions = styled.p(({ theme }) => ({
  marginTop: theme.spacing.sm,
  marginBottom: theme.spacing.none,
  fontSize: theme.fontSizes.sm,
}))

export const StyledDownloadButtonContainer = styled.div(({ theme }) => ({
  marginTop: theme.spacing.twoXS,
}))


================================================
File: /frontend/app/src/util/AppNavigation.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-disable @typescript-eslint/no-non-null-assertion */

import {
  AppPage,
  HostCommunicationManager,
  Navigation,
  NewSession,
  PageConfig,
  PageNotFound,
  PagesChanged,
} from "@streamlit/lib"

import {
  AppNavigation,
  PageNotFoundCallback,
  PageUrlUpdateCallback,
  SetIconCallback,
} from "./AppNavigation"

vi.mock("@streamlit/lib/src/hostComm/HostCommunicationManager", async () => {
  const actualModule = await vi.importActual<any>(
    "@streamlit/lib/src/hostComm/HostCommunicationManager"
  )

  const MockedClass = vi.fn().mockImplementation((...props) => {
    const hostCommunicationMgr = new actualModule.default(...props)
    vi.spyOn(hostCommunicationMgr, "sendMessageToHost")
    return hostCommunicationMgr
  })

  return {
    __esModule: true,
    ...actualModule,
    default: MockedClass,
  }
})

function generateNewSession(changes = {}): NewSession {
  return new NewSession({
    name: "scriptName",
    config: {
      gatherUsageStats: false,
      maxCachedMessageAge: 0,
      mapboxToken: "mapboxToken",
      allowRunOnSave: false,
      hideSidebarNav: false,
      hideTopBar: false,
    },
    customTheme: {
      primaryColor: "red",
      fontFaces: [],
    },
    initialize: {
      userInfo: {
        installationId: "installationId",
        installationIdV3: "installationIdV3",
      },
      environmentInfo: {
        streamlitVersion: "streamlitVersion",
        pythonVersion: "pythonVersion",
      },
      sessionStatus: {
        runOnSave: false,
        scriptIsRunning: false,
      },
      sessionId: "sessionId",
      isHello: false,
    },
    appPages: [
      {
        pageScriptHash: "page_script_hash",
        pageName: "streamlit app",
        urlPathname: "streamlit_app",
      },
    ],
    pageScriptHash: "page_script_hash",
    mainScriptHash: "main_script_hash",
    mainScriptPath: "path/to/file.py",
    scriptRunId: "script_run_id",
    fragmentIdsThisRun: [],
    ...changes,
  })
}

describe("AppNavigation", () => {
  let hostCommunicationMgr: HostCommunicationManager
  let onUpdatePageUrl: PageUrlUpdateCallback
  let onPageNotFound: PageNotFoundCallback
  let onPageIconChange: SetIconCallback
  let appNavigation: AppNavigation

  beforeEach(() => {
    hostCommunicationMgr = new HostCommunicationManager({
      sendRerunBackMsg: () => {},
      closeModal: () => {},
      stopScript: () => {},
      rerunScript: () => {},
      clearCache: () => {},
      sendAppHeartbeat: () => {},
      setInputsDisabled: () => {},
      themeChanged: () => {},
      pageChanged: () => {},
      isOwnerChanged: () => {},
      hostMenuItemsChanged: () => {},
      hostToolbarItemsChanged: () => {},
      hostHideSidebarNavChanged: () => {},
      sidebarChevronDownshiftChanged: () => {},
      pageLinkBaseUrlChanged: () => {},
      queryParamsChanged: () => {},
      deployedAppMetadataChanged: () => {},
      restartWebsocketConnection: () => {},
      terminateWebsocketConnection: () => {},
    })
    onUpdatePageUrl = vi.fn()
    onPageNotFound = vi.fn()
    onPageIconChange = vi.fn()
    appNavigation = new AppNavigation(
      hostCommunicationMgr,
      onUpdatePageUrl,
      onPageNotFound,
      onPageIconChange
    )
  })

  describe("MPA v1", () => {
    it("sets appPages on new session", () => {
      const maybeState = appNavigation.handleNewSession(generateNewSession())
      expect(maybeState).not.toBeUndefined()

      const [newState] = maybeState!
      expect(newState.appPages).toEqual([
        {
          pageScriptHash: "page_script_hash",
          pageName: "streamlit app",
          urlPathname: "streamlit_app",
        },
      ])
    })

    it("sets currentPageScriptHash on new session", () => {
      const maybeState = appNavigation.handleNewSession(generateNewSession())
      expect(maybeState).not.toBeUndefined()

      const [newState] = maybeState!
      expect(newState.currentPageScriptHash).toEqual("page_script_hash")
    })

    it("calls host communication on new session", () => {
      const maybeState = appNavigation.handleNewSession(generateNewSession({}))
      expect(maybeState).not.toBeUndefined()

      const callback = maybeState![1]

      callback()
      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
        type: "SET_APP_PAGES",
        appPages: [
          {
            pageScriptHash: "page_script_hash",
            pageName: "streamlit app",
            urlPathname: "streamlit_app",
          },
        ],
      })

      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
        type: "SET_CURRENT_PAGE_NAME",
        currentPageName: "",
        currentPageScriptHash: "page_script_hash",
      })
    })

    it("calls onUpdatePageUrl with the right information", () => {
      appNavigation.handleNewSession(generateNewSession())
      expect(onUpdatePageUrl).toHaveBeenCalledWith(
        "streamlit_app",
        "streamlit_app",
        true
      )
    })

    it("sets appPages on pages changed", () => {
      const maybeState = appNavigation.handlePagesChanged(
        new PagesChanged({
          appPages: [
            {
              pageScriptHash: "other_page_script_hash",
              pageName: "foo bar",
              urlPathname: "foo_bar",
            },
          ],
        })
      )
      expect(maybeState).not.toBeUndefined()

      const [newState] = maybeState!
      expect(newState.appPages).toEqual([
        {
          pageScriptHash: "other_page_script_hash",
          pageName: "foo bar",
          urlPathname: "foo_bar",
        },
      ])
    })

    it("calls host communication on pages changed", () => {
      const maybeState = appNavigation.handlePagesChanged(
        new PagesChanged({
          appPages: [
            {
              pageScriptHash: "other_page_script_hash",
              pageName: "foo bar",
              urlPathname: "foo_bar",
            },
          ],
        })
      )
      expect(maybeState).not.toBeUndefined()

      const callback = maybeState![1]

      callback()
      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
        type: "SET_APP_PAGES",
        appPages: [
          {
            pageScriptHash: "other_page_script_hash",
            pageName: "foo bar",
            urlPathname: "foo_bar",
          },
        ],
      })
    })

    it("sets currentPageScriptHash on page not found", () => {
      // Initialize navigation from the new session proto
      appNavigation.handleNewSession(generateNewSession())
      const maybeState = appNavigation.handlePageNotFound(
        new PageNotFound({ pageName: "foo" })
      )
      expect(maybeState).not.toBeUndefined()

      const [newState] = maybeState!
      expect(newState.currentPageScriptHash).toEqual("page_script_hash")
    })

    it("calls host communication on page not found", () => {
      // Initialize navigation from the new session proto
      appNavigation.handleNewSession(generateNewSession())
      const maybeState = appNavigation.handlePageNotFound(
        new PageNotFound({ pageName: "foo" })
      )
      expect(maybeState).not.toBeUndefined()

      const callback = maybeState![1]

      callback()
      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
        type: "SET_CURRENT_PAGE_NAME",
        currentPageName: "",
        currentPageScriptHash: "page_script_hash",
      })
    })

    it("calls onPageNotFound when page not found", () => {
      // Initialize navigation from the new session proto
      appNavigation.handleNewSession(generateNewSession())
      appNavigation.handlePageNotFound(new PageNotFound({ pageName: "foo" }))
      expect(onPageNotFound).toHaveBeenCalledWith("foo")
    })

    it("finds url by path when path is valid", () => {
      // Initialize navigation from the new session proto
      appNavigation.handleNewSession(generateNewSession())
      const page = appNavigation.findPageByUrlPath("/streamlit_app")

      expect(page!.pageScriptHash).toEqual("page_script_hash")
      expect(page!.pageName).toEqual("streamlit app")
    })

    it("returns default url by path when path is invalid", () => {
      // Initialize navigation from the new session proto
      appNavigation.handleNewSession(generateNewSession())
      const page = appNavigation.findPageByUrlPath("foo")

      expect(page!.pageScriptHash).toEqual("page_script_hash")
      expect(page!.pageName).toEqual("streamlit app")
    })
  })

  describe("MPA v2", () => {
    beforeEach(() => {
      // Switch to V2
      const navigation = new Navigation({
        sections: ["section1", "section2"],
        appPages: [
          new AppPage({
            pageName: "streamlit_app",
            pageScriptHash: "page_script_hash",
            isDefault: true,
            sectionHeader: "section1",
          }),
          new AppPage({
            pageName: "streamlit_app2",
            pageScriptHash: "page_script_hash2",
            isDefault: false,
            sectionHeader: "section2",
          }),
        ],
        position: Navigation.Position.SIDEBAR,
        pageScriptHash: "page_script_hash",
        expanded: false,
      })
      appNavigation.handleNavigation(navigation)
    })

    it("continues to set hideSidebarNav on new session", () => {
      const cleanAppNavigation = new AppNavigation(
        hostCommunicationMgr,
        onUpdatePageUrl,
        onPageNotFound,
        onPageIconChange
      )

      cleanAppNavigation.handleNavigation(
        new Navigation({
          sections: ["section1", "section2"],
          appPages: [
            new AppPage({
              pageName: "streamlit_app",
              pageScriptHash: "page_script_hash",
              isDefault: true,
              sectionHeader: "section1",
            }),
            new AppPage({
              pageName: "streamlit_app2",
              pageScriptHash: "page_script_hash2",
              isDefault: false,
              sectionHeader: "section2",
            }),
          ],
          position: Navigation.Position.HIDDEN,
          pageScriptHash: "page_script_hash",
          expanded: false,
        })
      )

      const maybeState = cleanAppNavigation.handleNewSession(
        generateNewSession()
      )
      expect(maybeState).not.toBeUndefined()

      const [newState] = maybeState!
      expect(newState).toEqual({
        hideSidebarNav: true,
      })
    })

    it("does not set anything on on pages changed", () => {
      const maybeState = appNavigation.handlePagesChanged(
        new PagesChanged({
          appPages: [
            {
              pageScriptHash: "other_page_script_hash",
              pageName: "foo bar",
              urlPathname: "foo_bar",
            },
          ],
        })
      )
      expect(maybeState).toBeUndefined()
    })

    it("sets currentPageScriptHash on page not found", () => {
      // Initialize navigation from the new session proto
      appNavigation.handleNewSession(generateNewSession())
      const maybeState = appNavigation.handlePageNotFound(
        new PageNotFound({ pageName: "" })
      )
      expect(maybeState).not.toBeUndefined()

      const [newState] = maybeState!
      expect(newState.currentPageScriptHash).toEqual("main_script_hash")
    })

    it("calls host communication on page not found", () => {
      // Initialize navigation from the new session proto
      appNavigation.handleNewSession(generateNewSession())
      const maybeState = appNavigation.handlePageNotFound(
        new PageNotFound({ pageName: "" })
      )
      expect(maybeState).not.toBeUndefined()

      const callback = maybeState![1]

      callback()
      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
        type: "SET_CURRENT_PAGE_NAME",
        currentPageName: "",
        currentPageScriptHash: "main_script_hash",
      })
    })

    it("calls onPageNotFound when page not found", () => {
      // Initialize navigation from the new session proto
      appNavigation.handleNewSession(generateNewSession())
      appNavigation.handlePageNotFound(new PageNotFound({ pageName: "" }))
      expect(onPageNotFound).toHaveBeenCalledWith("")
    })

    it("calls onUpdatePageUrl with the right information", () => {
      const navigation = new Navigation({
        sections: ["section1", "section2"],
        appPages: [
          new AppPage({
            pageName: "streamlit app",
            pageScriptHash: "page_script_hash",
            isDefault: true,
            urlPathname: "streamlit_app",
          }),
          new AppPage({
            pageName: "streamlit app2",
            pageScriptHash: "page_script_hash2",
            isDefault: false,
            urlPathname: "streamlit_app2",
          }),
        ],
        position: Navigation.Position.HIDDEN,
        pageScriptHash: "page_script_hash2",
        expanded: false,
      })
      appNavigation.handleNavigation(navigation)
      expect(onUpdatePageUrl).toHaveBeenCalledWith(
        "streamlit_app",
        "streamlit_app2",
        false
      )
    })

    it("finds url by path when path is valid", () => {
      const navigation = new Navigation({
        sections: ["section1", "section2"],
        appPages: [
          new AppPage({
            pageName: "streamlit app",
            pageScriptHash: "page_script_hash",
            isDefault: true,
            urlPathname: "streamlit_app",
          }),
          new AppPage({
            pageName: "streamlit app2",
            pageScriptHash: "page_script_hash2",
            isDefault: false,
            urlPathname: "streamlit_app2",
          }),
        ],
        position: Navigation.Position.HIDDEN,
        pageScriptHash: "page_script_hash",
        expanded: false,
      })
      appNavigation.handleNavigation(navigation)
      const page = appNavigation.findPageByUrlPath("/streamlit_app2")

      expect(page!.pageScriptHash).toEqual("page_script_hash2")
      expect(page!.pageName).toEqual("streamlit app2")
    })

    it("returns default url by path when path is invalid", () => {
      const navigation = new Navigation({
        sections: ["section1", "section2"],
        appPages: [
          new AppPage({
            pageName: "streamlit app",
            pageScriptHash: "page_script_hash",
            isDefault: true,
            sectionHeader: "section1",
            urlPathname: "streamlit_app",
          }),
          new AppPage({
            pageName: "streamlit app2",
            pageScriptHash: "page_script_hash2",
            isDefault: false,
            sectionHeader: "section2",
            urlPathname: "streamlit_app2",
          }),
        ],
        position: Navigation.Position.HIDDEN,
        pageScriptHash: "page_script_hash",
        expanded: false,
      })
      appNavigation.handleNavigation(navigation)
      const page = appNavigation.findPageByUrlPath("foo")

      expect(page!.pageScriptHash).toEqual("page_script_hash")
      expect(page!.pageName).toEqual("streamlit app")
    })

    it("sets navigation state to hidden on navigation", () => {
      const appPages = [
        new AppPage({
          pageName: "streamlit_app",
          pageScriptHash: "page_script_hash",
          isDefault: true,
          sectionHeader: "section1",
        }),
        new AppPage({
          pageName: "streamlit_app2",
          pageScriptHash: "page_script_hash2",
          isDefault: false,
          sectionHeader: "section2",
        }),
      ]
      const navigation = new Navigation({
        sections: ["section1", "section2"],
        appPages,
        position: Navigation.Position.HIDDEN,
        pageScriptHash: "page_script_hash",
        expanded: false,
      })
      const maybeState = appNavigation.handleNavigation(navigation)
      expect(maybeState).not.toBeUndefined()

      const [newState] = maybeState!
      expect(newState).toEqual({
        appPages,
        hideSidebarNav: true,
        expandSidebarNav: false,
        currentPageScriptHash: "page_script_hash",
        navSections: ["section1", "section2"],
      })
    })

    it("sets navigation state to expanded on navigation", () => {
      const appPages = [
        new AppPage({
          pageName: "streamlit_app",
          pageScriptHash: "page_script_hash",
          isDefault: true,
          sectionHeader: "section1",
        }),
        new AppPage({
          pageName: "streamlit_app2",
          pageScriptHash: "page_script_hash2",
          isDefault: false,
          sectionHeader: "section2",
        }),
      ]
      const navigation = new Navigation({
        sections: ["section1", "section2"],
        appPages,
        position: Navigation.Position.SIDEBAR,
        pageScriptHash: "page_script_hash",
        expanded: true,
      })
      const maybeState = appNavigation.handleNavigation(navigation)
      expect(maybeState).not.toBeUndefined()

      const [newState] = maybeState!
      expect(newState).toEqual({
        appPages,
        hideSidebarNav: false,
        expandSidebarNav: true,
        currentPageScriptHash: "page_script_hash",
        navSections: ["section1", "section2"],
      })
    })

    it("calls host communication on navigation", () => {
      const appPages = [
        new AppPage({
          pageName: "streamlit_app",
          pageScriptHash: "page_script_hash",
          isDefault: true,
          sectionHeader: "section1",
          icon: "icon1",
        }),
        new AppPage({
          pageName: "streamlit_app2",
          pageScriptHash: "page_script_hash2",
          isDefault: false,
          sectionHeader: "section2",
          icon: "icon2",
        }),
      ]
      const navigation = new Navigation({
        sections: ["section1", "section2"],
        appPages,
        position: Navigation.Position.HIDDEN,
        pageScriptHash: "page_script_hash",
        expanded: false,
      })
      const maybeState = appNavigation.handleNavigation(navigation)
      expect(maybeState).not.toBeUndefined()

      const callback = maybeState![1]
      callback()

      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
        type: "SET_PAGE_TITLE",
        title: "streamlit_app",
      })

      expect(onPageIconChange).toBeCalled()

      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
        type: "SET_APP_PAGES",
        appPages,
      })

      expect(hostCommunicationMgr.sendMessageToHost).toHaveBeenCalledWith({
        type: "SET_CURRENT_PAGE_NAME",
        currentPageName: "",
        currentPageScriptHash: "page_script_hash",
      })
    })

    it("does not set the icon if set page config sets title or icon", () => {
      // Clear the mock calls to avoid any confusion from setup
      hostCommunicationMgr.sendMessageToHost.mockClear()
      appNavigation.handlePageConfigChanged(
        new PageConfig({
          title: "foo",
          favicon: "bar",
        })
      )

      const navigation = new Navigation({
        sections: ["section1", "section2"],
        appPages: [
          new AppPage({
            pageName: "streamlit app",
            pageScriptHash: "page_script_hash",
            isDefault: true,
            sectionHeader: "section1",
            urlPathname: "streamlit_app",
            icon: "icon1",
          }),
          new AppPage({
            pageName: "streamlit app2",
            pageScriptHash: "page_script_hash2",
            isDefault: false,
            sectionHeader: "section2",
            urlPathname: "streamlit_app2",
            icon: "icon2",
          }),
        ],
        position: Navigation.Position.HIDDEN,
        pageScriptHash: "page_script_hash",
        expanded: false,
      })
      appNavigation.handleNavigation(navigation)
      const hostCommCalls = hostCommunicationMgr.sendMessageToHost.mock.calls

      expect(
        hostCommCalls.some(call => call[0].type === "SET_PAGE_TITLE")
      ).toBe(false)
      expect(onPageIconChange).not.toBeCalled()
    })
  })
})


================================================
File: /frontend/app/src/util/AppNavigation.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  AppRoot,
  BlockNode,
  HostCommunicationManager,
  IAppPage,
  Navigation,
  NewSession,
  PageConfig,
  PageNotFound,
  PagesChanged,
} from "@streamlit/lib"

interface AppNavigationState {
  expandSidebarNav: boolean
  hideSidebarNav: boolean
  appPages: IAppPage[]
  currentPageScriptHash: string
  navSections: string[]
}

export type MaybeStateUpdate =
  | [Partial<AppNavigationState>, () => void]
  | undefined
export type PageUrlUpdateCallback = (
  mainPageName: string,
  newPageName: string,
  isViewingMainPage: boolean
) => void
export type PageNotFoundCallback = (pageName?: string) => void
export type SetIconCallback = (icon: string) => void

function getTitle(pageName: string): string {
  if (!pageName) {
    return "Streamlit"
  }

  return pageName
}

export class StrategyV1 {
  private appPages: IAppPage[]

  private currentPageScriptHash: string | null

  private hideSidebarNav: boolean | null

  private readonly appNav: AppNavigation

  constructor(appNav: AppNavigation) {
    this.appNav = appNav
    this.appPages = []
    this.currentPageScriptHash = null
    this.hideSidebarNav = null
  }

  handleNewSession(newSession: NewSession): MaybeStateUpdate {
    this.appPages = newSession.appPages
    this.currentPageScriptHash = newSession.pageScriptHash
    this.hideSidebarNav = newSession.config?.hideSidebarNav ?? false

    // mainPage must be a string as we're guaranteed at this point that
    // newSessionProto.appPages is nonempty and has a truthy pageName.
    // Otherwise, we'd either have no main script or a nameless main script,
    // neither of which can happen.
    const mainPage = this.appPages[0] as IAppPage
    const mainPageName = mainPage.urlPathname ?? ""
    // We're similarly guaranteed that newPageName will be found / truthy
    // here.
    const newPageName =
      this.appPages.find(
        page => page.pageScriptHash === this.currentPageScriptHash
      )?.urlPathname ?? ""

    const isViewingMainPage =
      mainPage.pageScriptHash === this.currentPageScriptHash
    this.appNav.onUpdatePageUrl(mainPageName, newPageName, isViewingMainPage)

    // Set the title to its default value
    document.title = getTitle(newPageName ?? "")

    return [
      {
        hideSidebarNav: this.hideSidebarNav,
        appPages: this.appPages,
        currentPageScriptHash: this.currentPageScriptHash,
      },
      () => {
        this.appNav.hostCommunicationMgr.sendMessageToHost({
          type: "SET_APP_PAGES",
          appPages: this.appPages,
        })

        this.appNav.hostCommunicationMgr.sendMessageToHost({
          type: "SET_CURRENT_PAGE_NAME",
          currentPageName: isViewingMainPage ? "" : newPageName,
          currentPageScriptHash: this.currentPageScriptHash as string,
        })
      },
    ]
  }

  handlePagesChanged(pagesChangedMsg: PagesChanged): MaybeStateUpdate {
    const { appPages } = pagesChangedMsg
    return [
      { appPages },
      () => {
        this.appNav.hostCommunicationMgr.sendMessageToHost({
          type: "SET_APP_PAGES",
          appPages,
        })
      },
    ]
  }

  handlePageNotFound(pageNotFound: PageNotFound): MaybeStateUpdate {
    const { pageName } = pageNotFound
    this.appNav.onPageNotFound(pageName)
    const currentPageScriptHash = this.appPages[0]?.pageScriptHash ?? ""
    this.currentPageScriptHash = currentPageScriptHash

    return [
      { currentPageScriptHash },
      () => {
        this.appNav.hostCommunicationMgr.sendMessageToHost({
          type: "SET_CURRENT_PAGE_NAME",
          currentPageName: "",
          currentPageScriptHash,
        })
      },
    ]
  }

  handleNavigation(_navigationMsg: Navigation): MaybeStateUpdate {
    // This message does not apply to V1
    return undefined
  }

  findPageByUrlPath(pathname: string): IAppPage | null {
    if (this.appPages.length === 0) {
      return null
    }

    return (
      this.appPages.find(appPage =>
        pathname.endsWith("/" + appPage.urlPathname)
      ) ?? this.appPages[0]
    )
  }

  clearPageElements(
    elements: AppRoot,
    mainScriptHash: string,
    sidebarElements: BlockNode | undefined
  ): AppRoot {
    return AppRoot.empty(mainScriptHash, false, sidebarElements, elements.logo)
  }
}

export class StrategyV2 {
  readonly appNav: AppNavigation

  mainScriptHash: string | null

  appPages: IAppPage[]

  mainPage: IAppPage | null

  hideSidebarNav: boolean | null

  constructor(appNav: AppNavigation) {
    this.appNav = appNav
    this.mainScriptHash = null
    this.appPages = []
    this.mainPage = null
    this.hideSidebarNav = null
  }

  handleNewSession(newSession: NewSession): MaybeStateUpdate {
    this.mainScriptHash = newSession.mainScriptHash
    // Initialize to the config value if provided
    if (this.hideSidebarNav === null) {
      this.hideSidebarNav = newSession.config?.hideSidebarNav ?? null
    }

    // We do not know the page name, so use an empty string version
    document.title = getTitle("")

    return [{ hideSidebarNav: this.hideSidebarNav ?? false }, () => {}]
  }

  handlePagesChanged(_pagesChangedMsg: PagesChanged): MaybeStateUpdate {
    // This message does not apply to V2
    return undefined
  }

  handlePageNotFound(pageNotFound: PageNotFound): MaybeStateUpdate {
    const { pageName } = pageNotFound
    this.appNav.onPageNotFound(pageName)

    return [
      { currentPageScriptHash: this.mainScriptHash ?? "" },
      () => {
        this.appNav.hostCommunicationMgr.sendMessageToHost({
          type: "SET_CURRENT_PAGE_NAME",
          currentPageName: "",
          currentPageScriptHash: this.mainScriptHash ?? "",
        })
      },
    ]
  }

  handleNavigation(navigationMsg: Navigation): MaybeStateUpdate {
    const { sections, position, appPages } = navigationMsg

    this.appPages = appPages
    this.hideSidebarNav = position === Navigation.Position.HIDDEN

    const currentPageScriptHash = navigationMsg.pageScriptHash
    const currentPage = appPages.find(
      p => p.pageScriptHash === currentPageScriptHash
    ) as IAppPage
    const mainPage = appPages.find(p => p.isDefault) as IAppPage
    this.mainPage = mainPage
    const currentPageName = currentPage.urlPathname as string

    if (!this.appNav.isPageTitleSet) {
      const title = getTitle(currentPage.pageName as string)
      document.title = title
      this.appNav.hostCommunicationMgr.sendMessageToHost({
        type: "SET_PAGE_TITLE",
        title: currentPage.pageName ?? "",
      })
    }

    if (!this.appNav.isPageIconSet && currentPage.icon) {
      this.appNav.onPageIconChange(currentPage.icon)
    }

    this.appNav.onUpdatePageUrl(
      mainPage.urlPathname ?? "",
      currentPageName,
      currentPage.isDefault ?? false
    )

    return [
      {
        appPages,
        navSections: sections,
        hideSidebarNav: this.hideSidebarNav,
        expandSidebarNav: navigationMsg.expanded,
        currentPageScriptHash,
      },
      () => {
        this.appNav.hostCommunicationMgr.sendMessageToHost({
          type: "SET_APP_PAGES",
          appPages,
        })

        this.appNav.hostCommunicationMgr.sendMessageToHost({
          type: "SET_CURRENT_PAGE_NAME",
          // Make sure we don't send the official page name for the main page
          // This command is used to update the URL in the url bar, so the main page
          // should not have a page name in the URL.
          currentPageName: currentPage.isDefault ? "" : currentPageName,
          currentPageScriptHash,
        })
      },
    ]
  }

  findPageByUrlPath(pathname: string): IAppPage | null {
    return (
      this.appPages.find(appPage =>
        // The page name is embedded at the end of the URL path, and if not, we are in the main page.
        // See https://github.com/streamlit/streamlit/blob/1.19.0/frontend/src/App.tsx#L740
        pathname.endsWith("/" + appPage.urlPathname)
      ) ?? this.mainPage
    )
  }

  clearPageElements(
    elements: AppRoot,
    mainScriptHash: string,
    _sidebarElements: BlockNode | undefined
  ): AppRoot {
    return elements.filterMainScriptElements(mainScriptHash)
  }
}

export class AppNavigation {
  readonly hostCommunicationMgr: HostCommunicationManager

  readonly onUpdatePageUrl: PageUrlUpdateCallback

  readonly onPageNotFound: PageNotFoundCallback

  readonly onPageIconChange: SetIconCallback

  isPageTitleSet: boolean

  isPageIconSet: boolean

  strategy: StrategyV1 | StrategyV2

  constructor(
    hostCommunicationMgr: HostCommunicationManager,
    onUpdatePageUrl: PageUrlUpdateCallback,
    onPageNotFound: PageNotFoundCallback,
    onPageIconChange: SetIconCallback
  ) {
    this.hostCommunicationMgr = hostCommunicationMgr
    this.onUpdatePageUrl = onUpdatePageUrl
    this.onPageNotFound = onPageNotFound
    this.onPageIconChange = onPageIconChange
    this.isPageIconSet = false
    this.isPageTitleSet = false

    // Start with the V1 strategy as it will apply to V0 as well
    this.strategy = new StrategyV1(this)
  }

  handleNewSession(newSession: NewSession): MaybeStateUpdate {
    this.isPageTitleSet = false
    this.isPageIconSet = false

    return this.strategy.handleNewSession(newSession)
  }

  handleNavigation(navigationMsg: Navigation): MaybeStateUpdate {
    // Navigation call (through st.navigation) indicates we are using
    // MPA v2. We can change strategy here. It will set the state properly
    if (this.strategy instanceof StrategyV1) {
      this.strategy = new StrategyV2(this)
    }

    return this.strategy.handleNavigation(navigationMsg)
  }

  handlePagesChanged(pagesChangedMsg: PagesChanged): MaybeStateUpdate {
    return this.strategy.handlePagesChanged(pagesChangedMsg)
  }

  handlePageNotFound(pageNotFound: PageNotFound): MaybeStateUpdate {
    return this.strategy.handlePageNotFound(pageNotFound)
  }

  findPageByUrlPath(pathname: string): IAppPage | null {
    return this.strategy.findPageByUrlPath(pathname)
  }

  handlePageConfigChanged(pageConfig: PageConfig): void {
    this.isPageIconSet = Boolean(pageConfig.favicon)
    this.isPageTitleSet = Boolean(pageConfig.title)
  }

  clearPageElements(
    elements: AppRoot,
    mainScriptHash: string,
    sidebarElements: BlockNode | undefined
  ): AppRoot {
    return this.strategy.clearPageElements(
      elements,
      mainScriptHash,
      sidebarElements
    )
  }
}


================================================
File: /frontend/app/src/util/ScreenCastRecorder.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { logWarning, notNullOrUndefined } from "@streamlit/lib"

const BLOB_TYPE = "video/webm"

interface ScreenCastRecorderOptions {
  recordAudio: boolean
  onErrorOrStop: () => void
}

class ScreenCastRecorder {
  private readonly recordAudio: boolean

  private inputStream: MediaStream | null

  private recordedChunks: Blob[]

  private mediaRecorder: MediaRecorder | null

  private onErrorOrStopCallback: () => void

  /** True if the current browser likely supports screencasts. */
  public static isSupportedBrowser(): boolean {
    try {
      return (
        notNullOrUndefined(navigator.mediaDevices) &&
        notNullOrUndefined(navigator.mediaDevices.getUserMedia) &&
        notNullOrUndefined(navigator.mediaDevices.getDisplayMedia) &&
        MediaRecorder.isTypeSupported(BLOB_TYPE)
      )
    } catch (e) {
      // In the event of an error, assume it won't support screencasts
      return false
    }
  }

  constructor({ recordAudio, onErrorOrStop }: ScreenCastRecorderOptions) {
    this.recordAudio = recordAudio
    this.onErrorOrStopCallback = onErrorOrStop

    this.inputStream = null
    this.recordedChunks = []

    this.mediaRecorder = null
  }

  /**
   * This asynchronous method will initialize the screen recording object asking
   * for permissions to the user which are needed to start recording.
   */
  public async initialize(): Promise<void> {
    const desktopStream = await navigator.mediaDevices.getDisplayMedia({
      video: true,
    })

    let tracks = desktopStream.getTracks()

    if (this.recordAudio) {
      const voiceStream = await navigator.mediaDevices.getUserMedia({
        video: false,
        audio: true,
      })
      tracks = tracks.concat(voiceStream.getAudioTracks())
    }

    this.recordedChunks = []

    this.inputStream = new MediaStream(tracks)

    this.mediaRecorder = new MediaRecorder(this.inputStream, {
      mimeType: BLOB_TYPE,
    })

    this.mediaRecorder.ondataavailable = e => this.recordedChunks.push(e.data)
  }

  public getState(): string {
    if (this.mediaRecorder) {
      return this.mediaRecorder.state
    }

    return "inactive"
  }

  /**
   * This method will start the screen recording if the user has granted permissions
   * and the mediaRecorder has been initialized
   *
   * @returns {boolean}
   */
  public start(): boolean {
    if (!this.mediaRecorder) {
      logWarning(`ScreenCastRecorder.start: mediaRecorder is null`)
      return false
    }

    const logRecorderError = (e: any): void => {
      logWarning(`mediaRecorder.start threw an error: ${e}`)
    }

    this.mediaRecorder.onerror = (e: any): void => {
      logRecorderError(e)
      this.onErrorOrStopCallback()
    }

    this.mediaRecorder.onstop = (): void => this.onErrorOrStopCallback()

    try {
      this.mediaRecorder.start()
    } catch (e) {
      logRecorderError(e)
      return false
    }

    return true
  }

  /**
   * This method will stop recording and then return the generated Blob
   *
   * @returns {(Promise|undefined)}
   *  A Promise which will return the generated Blob
   *  Undefined if the MediaRecorder could not initialize
   */
  public stop(): Promise<Blob> | undefined {
    if (!this.mediaRecorder) {
      return undefined
    }

    let resolver: (value?: unknown) => void

    const promise = new Promise(r => {
      resolver = r
    })

    this.mediaRecorder.onstop = () => resolver()
    this.mediaRecorder.stop()

    if (this.inputStream) {
      this.inputStream.getTracks().forEach(s => s.stop())
      this.inputStream = null
    }

    return promise.then(() => this.buildOutputBlob())
  }

  private buildOutputBlob(): Blob {
    return new Blob(this.recordedChunks, { type: BLOB_TYPE })
  }
}

export default ScreenCastRecorder


================================================
File: /frontend/app/src/util/getBrowserInfo.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { MockInstance } from "vitest"

import getBrowserInfo from "./getBrowserInfo"

describe("getBrowserInfo", () => {
  let userAgentSpy: MockInstance

  const mockUserAgent = (userAgentString: string): void => {
    userAgentSpy = vi
      .spyOn(window.navigator, "userAgent", "get")
      .mockReturnValue(userAgentString)
  }

  afterEach(() => {
    userAgentSpy.mockRestore()
  })

  it("should detect Opera browser on Windows", () => {
    mockUserAgent(
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36 OPR/77.0.4054.254"
    )

    const result = getBrowserInfo()
    expect(result).toEqual({
      browserName: "Opera",
      browserVersion: "77.0.4054.254",
      deviceType: "desktop",
      os: "Windows",
    })
  })

  it("should detect Brave browser on macOS", () => {
    mockUserAgent(
      "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.107 Safari/537.36 Brave/92.0.4515.107"
    )

    const result = getBrowserInfo()
    expect(result).toEqual({
      browserName: "Brave",
      browserVersion: "92.0.4515.107",
      deviceType: "desktop",
      os: "Mac OS",
    })
  })

  it("should detect QQ Browser on Android", () => {
    mockUserAgent(
      "Mozilla/5.0 (Linux; U; Android 10; en-US; V2023A Build/QP1A.190711.020) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Mobile Safari/537.36 MQQBrowser/13.4 Mobile"
    )

    const result = getBrowserInfo()
    expect(result).toEqual({
      browserName: "QQBrowser",
      browserVersion: "13.4",
      deviceType: "mobile",
      os: "Android",
    })
  })
