        if m:
            return m.group("version")


# Commands that don't result in rendered elements in the frontend
NON_ELEMENT_COMMANDS: set[str] = {
    "Page",
    "cache",
    "cache_data",
    "cache_resource",
    "connection",
    "context",
    "experimental_fragment",
    "experimental_get_query_params",
    "experimental_set_query_params",
    "experimental_user",
    "fragment",
    "get_option",
    "login",
    "logout",
    "navigation",
    "query_params",
    "rerun",
    "secrets",
    "session_state",
    "set_option",
    "set_page_config",
    "sidebar",
    "stop",
    "switch_page",
}

# Element commands that are exposed on the DeltaGenerator
# and on the top-level Streamlit namespace.
# We extract them from the element mocks.
ELEMENT_COMMANDS: set[str] = {
    command for command, _ in WIDGET_ELEMENTS + NON_WIDGET_ELEMENTS + CONTAINER_ELEMENTS
}


class StreamlitTest(unittest.TestCase):
    """Test Streamlit.__init__.py."""

    def test_streamlit_version(self):
        """Test streamlit.__version__."""
        self.assertEqual(__version__, get_version())

    def test_get_option(self):
        """Test streamlit.get_option."""
        # This is set in lib/tests/conftest.py to False
        self.assertFalse(st.get_option("browser.gatherUsageStats"))

    def test_matplotlib_uses_agg(self):
        """Test that Streamlit uses the 'Agg' backend for matplotlib."""
        ORIG_PLATFORM = sys.platform

        for platform in ["darwin", "linux2"]:
            sys.platform = platform

            self.assertEqual(matplotlib.get_backend().lower(), "agg")
            self.assertEqual(os.environ.get("MPLBACKEND").lower(), "agg")

            # Force matplotlib to use a different backend
            matplotlib.use("pdf", force=True)
            self.assertEqual(matplotlib.get_backend().lower(), "pdf")

            # Reset the backend to 'Agg'
            matplotlib.use("agg", force=True)
            self.assertEqual(matplotlib.get_backend().lower(), "agg")
        sys.platform = ORIG_PLATFORM

    def test_ensure_completeness_element_mocks(self):
        """Test that we have mocked all elements in the public API.

        The full public API should be covered by:
        - element_mocks.WIDGET_ELEMENTS
        - element_mocks.NON_WIDGET_ELEMENTS
        - element_mocks.CONTAINER_ELEMENTS
        - NON_ELEMENT_COMMANDS
        """
        api = {
            k
            for k, v in st.__dict__.items()
            if not k.startswith("_") and not isinstance(v, type(st))
        }

        mocked_elements = {
            element
            for element, _ in WIDGET_ELEMENTS + NON_WIDGET_ELEMENTS + CONTAINER_ELEMENTS
        }
        mocked_elements.update(NON_ELEMENT_COMMANDS)
        assert api == mocked_elements, (
            "There are new public commands that might be needed to be added to element "
            "mocks or NON_ELEMENT_COMMANDS. Please add it to the correct list of "
            "mocked elements or NON_ELEMENT_COMMANDS."
        )

    def test_public_api(self):
        """Test that we don't accidentally remove (or add) symbols
        to the public `st` API.
        """
        api = {
            k
            for k, v in st.__dict__.items()
            if not k.startswith("_") and not isinstance(v, type(st))
        }
        self.assertEqual(api, ELEMENT_COMMANDS.union(NON_ELEMENT_COMMANDS))

    def test_pydoc(self):
        """Test that we can run pydoc on the streamlit package"""
        cwd = os.getcwd()
        try:
            os.chdir(tempfile.mkdtemp())
            # Run the script as a separate process to make sure that
            # the currently loaded modules do not affect the test result.
            output = subprocess.check_output(
                [sys.executable, "-m", "pydoc", "streamlit"]
            ).decode()
            self.assertIn("Help on package streamlit:", output)
        finally:
            os.chdir(cwd)


================================================
File: /lib/tests/streamlit/string_util_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import unittest

from parameterized import parameterized

from streamlit import string_util
from streamlit.errors import StreamlitAPIException


class StringUtilTest(unittest.TestCase):
    @parameterized.expand(
        [
            ("", False),
            ("A", False),
            ("%", False),
            ("ðŸ˜ƒ", True),
            ("ðŸ‘¨â€ðŸ‘¨â€ðŸ‘§â€ðŸ‘¦", True),
            ("ðŸ˜ƒðŸ˜ƒ", False),
            ("ðŸ˜ƒX", False),
            ("XðŸ˜ƒ", False),
            ("ï¸ðŸš¨", True),
            ("ï¸â›”ï¸", True),
            ("ï¸ðŸ‘ðŸ½", True),
        ]
    )
    def test_is_emoji(self, text: str, expected: bool):
        """Test streamlit.string_util.is_emoji."""
        self.assertEqual(string_util.is_emoji(text), expected)

    @parameterized.expand(
        [
            ("", ("", "")),
            ("A", ("", "A")),
            ("%", ("", "%")),
            ("ðŸ˜ƒ", ("ðŸ˜ƒ", "")),
            ("ðŸ˜ƒ page name", ("ðŸ˜ƒ", "page name")),
            ("ðŸ˜ƒ-page name", ("ðŸ˜ƒ", "page name")),
            ("ðŸ˜ƒ_page name", ("ðŸ˜ƒ", "page name")),
            ("ðŸ˜ƒ _- page name", ("ðŸ˜ƒ", "page name")),
            # Test that multi-character emoji are fully extracted.
            ("ðŸ‘¨â€ðŸ‘¨â€ðŸ‘§â€ðŸ‘¦_page name", ("ðŸ‘¨â€ðŸ‘¨â€ðŸ‘§â€ðŸ‘¦", "page name")),
            ("ðŸ˜ƒðŸ˜ƒ", ("ðŸ˜ƒ", "ðŸ˜ƒ")),
            ("1ï¸âƒ£X", ("1ï¸âƒ£", "X")),
            ("XðŸ˜ƒ", ("", "XðŸ˜ƒ")),
            # Test that certain non-emoji unicode characters don't get
            # incorrectly detected as emoji.
            ("ä½•_is_this", ("", "ä½•_is_this")),
        ]
    )
    def test_extract_leading_emoji(self, text, expected):
        self.assertEqual(string_util.extract_leading_emoji(text), expected)

    @parameterized.expand(
        [
            ("A", False),
            ("hello", False),
            ("1_foo", False),
            ("1.foo", False),
            ("1-foo", False),
            ("foo bar", False),
            ("foo.bar", False),
            ("foo&bar", False),
            ("", False),
            ("a ðŸ˜ƒbc", True),
            ("XðŸ˜ƒ", True),
            ("%", True),
            ("ðŸ˜ƒ", True),
            ("ðŸ˜ƒ page name", True),
            ("ðŸ‘¨â€ðŸ‘¨â€ðŸ‘§â€ðŸ‘¦_page name", True),
            ("ä½•_is_this", True),
        ]
    )
    def test_contains_special_chars(self, text: str, expected: bool):
        self.assertEqual(string_util._contains_special_chars(text), expected)

    def test_simplify_number(self):
        """Test streamlit.string_util.simplify_number."""

        self.assertEqual(string_util.simplify_number(100), "100")

        self.assertEqual(string_util.simplify_number(10000), "10k")

        self.assertEqual(string_util.simplify_number(1000000), "1m")

        self.assertEqual(string_util.simplify_number(1000000000), "1b")

        self.assertEqual(string_util.simplify_number(1000000000000), "1t")

    @parameterized.expand(
        [
            ("", "`", 0),
            ("`", "`", 1),
            ("a", "`", 0),
            ("``", "`", 2),
            ("aba", "a", 1),
            ("a``a", "`", 2),
            ("```abc```", "`", 3),
            ("a`b``c```d", "`", 3),
            ("``````", "`", 6),
            (
                "a`b`c`d`e",
                "`",
                1,
            ),
            ("a``b```c````d", "`", 4),
            ("no backticks here", "`", 0),
        ]
    )
    def test_max_char_sequence(self, text, char, expected):
        self.assertEqual(string_util.max_char_sequence(text, char), expected)

    @parameterized.expand(
        [
            ":material/cabin:",
            ":material/add_circle:",
            ":material/add_a_photo:",
        ]
    )
    def test_validate_material_icons_success(self, icon_string: str):
        """Test that validate_material_icons not raises exception on correct icons."""
        string_util.validate_material_icon(icon_string)

    @parameterized.expand(
        [
            ":material/cabBbin:",
            ":material-outlined/add_circle:",
            ":material:add_a_photo:",
        ]
    )
    def test_validate_material_icons_raises_exception(self, icon_name):
        """Test that validate_material_icons raises exception on incorrect icons."""
        with self.assertRaises(StreamlitAPIException) as e:
            string_util.validate_material_icon(icon_name)

        self.assertIn("not a valid Material icon.", str(e.exception))


================================================
File: /lib/tests/streamlit/temporary_directory_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import os
import unittest

from testfixtures import tempdir

from streamlit.temporary_directory import TemporaryDirectory


class TemporaryFileTest(unittest.TestCase):
    """Test temp directory context manager."""

    @tempdir()
    def test_temp_directory(self, dir):
        """Test that the directory only exists inside the context."""
        with TemporaryDirectory(dir=dir.path) as temp_fname:
            self.assertTrue(os.path.exists(temp_fname))
        self.assertFalse(os.path.exists(temp_fname))


================================================
File: /lib/tests/streamlit/time_util_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import math
from datetime import date, timedelta
from typing import Any

import pytest
from parameterized import parameterized

from streamlit.errors import StreamlitBadTimeStringError
from streamlit.time_util import adjust_years, time_to_seconds

TIME_STRING_TO_SECONDS_PARAMS = [
    ("float", 3.5, 3.5),
    ("timedelta", timedelta(minutes=3), 60 * 3),
    ("str 1 arg", "1d", 24 * 60 * 60),
    ("str 2 args", "1d23h", 24 * 60 * 60 + 23 * 60 * 60),
    (
        "complex str 3 args",
        "1 day 23hr 45minutes",
        24 * 60 * 60 + 23 * 60 * 60 + 45 * 60,
    ),
    ("str 2 args with float", "1.5d23.5h", 1.5 * 24 * 60 * 60 + 23.5 * 60 * 60),
]


@parameterized.expand(
    [
        # Test adding one year to a regular date:
        (date(2021, 1, 1), 1, date(2022, 1, 1)),
        # Test adding one year to a leap day, resulting in a non-leap year (Feb 28):
        (date(2020, 2, 29), 1, date(2021, 2, 28)),
        # Test subtracting one year from a leap day, adjusting to the previous year's Feb 28.
        (date(2020, 2, 29), -1, date(2019, 2, 28)),
        # Non-leap year, regular date
        (date(2021, 3, 15), 1, date(2022, 3, 15)),
        # Leap year to leap year:
        (date(2020, 2, 29), 4, date(2024, 2, 29)),
        # Subtracting years from a non-leap year date
        (date(2019, 3, 15), -1, date(2018, 3, 15)),
        # Adding 100 years, including a century leap year:
        (date(1920, 4, 10), 100, date(2020, 4, 10)),
        # End of year date
        (date(2019, 12, 31), 1, date(2020, 12, 31)),
    ]
)
def test_adjust_years(input_date: date, years: int, expected_date: date):
    """Test that `adjust_years` correctly` adjusts the year of a date."""
    assert adjust_years(input_date, years) == expected_date


@parameterized.expand(
    [
        *TIME_STRING_TO_SECONDS_PARAMS,
        ("None", None, math.inf),
    ]
)
def test_time_to_seconds_coerced(_, input_value: Any, expected_seconds: float):
    """Test the various types of input that time_to_seconds accepts."""
    assert expected_seconds == time_to_seconds(input_value)


@parameterized.expand(
    [
        *TIME_STRING_TO_SECONDS_PARAMS,
        ("None", None, None),
    ]
)
def test_time_to_seconds_not_coerced(_, input_value: Any, expected_seconds: float):
    """Test the various types of input that time_to_seconds accepts."""
    assert expected_seconds == time_to_seconds(input_value, coerce_none_to_inf=False)


def test_time_str_exception():
    """Test that a badly-formatted time string raises an exception."""
    with pytest.raises(StreamlitBadTimeStringError):
        time_to_seconds("")

    with pytest.raises(StreamlitBadTimeStringError):
        time_to_seconds("1 flecond")


================================================
File: /lib/tests/streamlit/toast_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""toast unit tests."""

from __future__ import annotations

import streamlit as st
from streamlit.errors import StreamlitAPIException
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class ToastTest(DeltaGeneratorTestCase):
    def test_just_text(self):
        """Test that it can be called with just text."""
        st.toast("toast text")

        c = self.get_delta_from_queue().new_element.toast
        self.assertEqual(c.body, "toast text")
        self.assertEqual(c.icon, "")

    def test_no_text(self):
        """Test that an error is raised if no text is provided."""
        with self.assertRaises(StreamlitAPIException) as e:
            st.toast("")
        self.assertEqual(
            str(e.exception),
            "Toast body cannot be blank - please provide a message.",
        )

    def test_valid_icon(self):
        """Test that it can be called passing a valid emoji as icon."""
        st.toast("toast text", icon="ðŸ¦„")

        c = self.get_delta_from_queue().new_element.toast
        self.assertEqual(c.body, "toast text")
        self.assertEqual(c.icon, "ðŸ¦„")

    def test_invalid_icon(self):
        """Test that an error is raised if an invalid icon is provided."""
        with self.assertRaises(StreamlitAPIException) as e:
            st.toast("toast text", icon="invalid")
        self.assertEqual(
            str(e.exception),
            'The value "invalid" is not a valid emoji. Shortcodes are not allowed, please use a single character instead.',
        )


================================================
File: /lib/tests/streamlit/type_util_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import unittest
from collections import namedtuple
from typing import Any
from unittest.mock import patch

import numpy as np
import pandas as pd
import plotly.graph_objs as go
import pytest
from parameterized import parameterized

from streamlit import type_util
from streamlit.delta_generator import DeltaGenerator
from streamlit.errors import StreamlitAPIException
from streamlit.runtime.context import StreamlitCookies, StreamlitHeaders
from streamlit.runtime.secrets import Secrets
from streamlit.runtime.state import QueryParamsProxy, SessionStateProxy
from streamlit.user_info import UserInfoProxy


class TypeUtilTest(unittest.TestCase):
    def test_list_is_plotly_chart(self):
        trace0 = go.Scatter(x=[1, 2, 3, 4], y=[10, 15, 13, 17])
        trace1 = go.Scatter(x=[1, 2, 3, 4], y=[16, 5, 11, 9])
        data = [trace0, trace1]

        res = type_util.is_plotly_chart(data)
        self.assertTrue(res)

    def test_data_dict_is_plotly_chart(self):
        trace0 = go.Scatter(x=[1, 2, 3, 4], y=[10, 15, 13, 17])
        trace1 = go.Scatter(x=[1, 2, 3, 4], y=[16, 5, 11, 9])
        d = {"data": [trace0, trace1]}

        res = type_util.is_plotly_chart(d)
        self.assertTrue(res)

    def test_dirty_data_dict_is_not_plotly_chart(self):
        trace0 = go.Scatter(x=[1, 2, 3, 4], y=[10, 15, 13, 17])
        trace1 = go.Scatter(x=[1, 2, 3, 4], y=[16, 5, 11, 9])
        d = {"data": [trace0, trace1], "foo": "bar"}  # Illegal property!

        res = type_util.is_plotly_chart(d)
        self.assertFalse(res)

    def test_layout_dict_is_not_plotly_chart(self):
        d = {
            # Missing a component with a graph object!
            "layout": {"width": 1000}
        }

        res = type_util.is_plotly_chart(d)
        self.assertFalse(res)

    def test_fig_is_plotly_chart(self):
        trace1 = go.Scatter(x=[1, 2, 3, 4], y=[16, 5, 11, 9])

        # Plotly 3.7 needs to read the config file at /home/.plotly when
        # creating an image. So let's mock that part of the Figure creation:
        with patch("plotly.offline.offline._get_jconfig") as mock:
            mock.return_value = {}
            fig = go.Figure(data=[trace1])

        res = type_util.is_plotly_chart(fig)
        self.assertTrue(res)

    def test_is_namedtuple(self):
        Boy = namedtuple("Boy", ("name", "age"))  # noqa: PYI024
        John = Boy("John", "29")

        res = type_util.is_namedtuple(John)
        self.assertTrue(res)

    @pytest.mark.require_integration
    def test_is_pydantic_model(self):
        from pydantic import BaseModel

        class OtherObject:
            foo: int
            bar: str

        class BarModel(BaseModel):
            foo: int
            bar: str

        self.assertTrue(type_util.is_pydantic_model(BarModel(foo=1, bar="test")))
        self.assertFalse(type_util.is_pydantic_model(BarModel))
        self.assertFalse(type_util.is_pydantic_model(OtherObject))

    def test_to_bytes(self):
        bytes_obj = b"some bytes"
        self.assertTrue(type_util.is_bytes_like(bytes_obj))
        self.assertIsInstance(type_util.to_bytes(bytes_obj), bytes)

        bytearray_obj = bytearray("a bytearray string", "utf-8")
        self.assertTrue(type_util.is_bytes_like(bytearray_obj))
        self.assertIsInstance(type_util.to_bytes(bytearray_obj), bytes)

        string_obj = "a normal string"
        self.assertFalse(type_util.is_bytes_like(string_obj))
        with self.assertRaises(RuntimeError):
            type_util.to_bytes(string_obj)  # type: ignore

    @parameterized.expand(
        [
            ([1, 2, 3],),
            (["foo", "bar", "baz"],),
            (np.array([1, 2, 3, 4]),),
            (pd.Series([1, 2, 3]),),
        ]
    )
    def test_check_python_comparable(self, sequence):
        """Test that `check_python_comparable` not raises exception
        when elements of sequence returns bool when compared."""

        # Just check that it should not raise any exception
        type_util.check_python_comparable(sequence)

    @parameterized.expand(
        [
            (np.array([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]), "ndarray"),
            ([pd.Series([1, 2, 3]), pd.Series([4, 5, 6])], "Series"),
        ]
    )
    def test_check_python_comparable_exception(self, sequence, type_str):
        """Test that `check_python_comparable` raises an exception if ndarray."""
        with pytest.raises(StreamlitAPIException) as exception_message:
            type_util.check_python_comparable(sequence)
        self.assertEqual(
            (
                "Invalid option type provided. Options must be comparable, returning a "
                f"boolean when used with *==*. \n\nGot **{type_str}**, which cannot be "
                "compared. Refactor your code to use elements of comparable types as "
                "options, e.g. use indices instead."
            ),
            str(exception_message.value),
        )

    def test_has_callable_attr(self):
        class TestClass:
            def __init__(self) -> None:
                self.also_not_callable = "I am not callable"

            def callable_attr(self):
                pass

            @property
            def not_callable_attr(self):
                return "I am a property"

        assert type_util.has_callable_attr(TestClass, "callable_attr") is True
        assert type_util.has_callable_attr(TestClass, "not_callable_attr") is False
        assert type_util.has_callable_attr(TestClass, "also_not_callable") is False
        assert type_util.has_callable_attr(TestClass, "not_a_real_attr") is False

        assert type_util.has_callable_attr(DeltaGenerator(), "foo") is False

    @parameterized.expand(
        [
            ({"key": "value"}, False),
            (Secrets(), True),
            (QueryParamsProxy(), True),
            (SessionStateProxy(), True),
            (StreamlitCookies({}), True),
            (StreamlitHeaders({}), True),
            (UserInfoProxy(), True),
        ]
    )
    def test_is_custom_dict(self, dict_obj: Any, is_custom_dict: bool):
        """Test that `is_custom_dict` returns True for all Streamlit custom dicts."""
        assert type_util.is_custom_dict(dict_obj) is is_custom_dict

    def test_is_delta_generator(self):
        """Test that `is_delta_generator` returns True for DeltaGenerator."""

        assert type_util.is_delta_generator(DeltaGenerator()) is True
        assert type_util.is_delta_generator("not a DeltaGenerator") is False

    def test_async_generator_to_sync(self):
        """Test that `async_generator_to_sync` converts an async generator to a sync
        generator."""

        async def async_gen():
            yield "hello "
            yield "world "
            yield "!"

        sync_gen = type_util.async_generator_to_sync(async_gen())
        assert "".join(sync_gen) == "hello world !"


================================================
File: /lib/tests/streamlit/url_util_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import unittest
from typing import Any

from parameterized import parameterized

from streamlit import url_util

GITHUB_URLS = [
    (
        "https://github.com/aritropaul/streamlit/blob/b72adbcf00c91775db14e739e2ea33d6df9079c3/lib/streamlit/cli.py",
        "https://github.com/aritropaul/streamlit/raw/b72adbcf00c91775db14e739e2ea33d6df9079c3/lib/streamlit/cli.py",
    ),
    (
        "https://github.com/streamlit/streamlit/blob/develop/e2e_playwright/st_video.py",
        "https://github.com/streamlit/streamlit/raw/develop/e2e_playwright/st_video.py",
    ),
    (
        "https://github.com/text2gene/text2gene/blob/master/sbin/clinvar.hgvs_citations.sql",
        "https://github.com/text2gene/text2gene/raw/master/sbin/clinvar.hgvs_citations.sql",
    ),
    (
        "https://github.com/mekarpeles/math.mx/blob/master/README.md",
        "https://github.com/mekarpeles/math.mx/raw/master/README.md",
    ),
]

GIST_URLS = [
    (
        "https://gist.github.com/nthmost/b521b80fbd834e67b3f5e271e9548232",
        "https://gist.github.com/nthmost/b521b80fbd834e67b3f5e271e9548232/raw",
    ),
    (
        "https://gist.github.com/scottyallen/1888e058261fc21f184f6be192bbe131",
        "https://gist.github.com/scottyallen/1888e058261fc21f184f6be192bbe131/raw",
    ),
    (
        "https://gist.github.com/tvst/faf057abbedaccaa70b48216a1866cdd",
        "https://gist.github.com/tvst/faf057abbedaccaa70b48216a1866cdd/raw",
    ),
]

INVALID_URLS = [
    "blah",
    "google.com",
    "http://homestarrunner.com",
    "https://somethinglikegithub.com/withablob",
    "gist.github.com/nothing",
    "https://raw.githubusercontent.com/streamlit/streamlit/develop/e2e_playwright/st_video.py",
    "streamlit.io/raw/blob",
]


class GitHubUrlTest(unittest.TestCase):
    def test_github_url_is_replaced(self):
        for target, processed in GITHUB_URLS:
            assert url_util.process_gitblob_url(target) == processed

    def test_gist_url_is_replaced(self):
        for target, processed in GIST_URLS:
            assert url_util.process_gitblob_url(target) == processed

    def test_nonmatching_url_is_not_replaced(self):
        for url in INVALID_URLS:
            assert url == url_util.process_gitblob_url(url)


class UrlUtilTest(unittest.TestCase):
    @parameterized.expand(
        [
            # Valid URLs:
            ("http://www.cwi.nl:80/%7Eguido/Python.html", True),
            ("https://stackoverflow.com", True),
            ("mailto:test@example.com", True),
            ("data:image/svg+xml;base64,PHN2ZyB4aHcvMjAwMC9zdmci", True),
            ("data:application/pdf;base64,PHN2ZyB4aHcvMjAwMC9zdmci", True),
            ("http://127.0.0.1", True),  # IP as domain
            ("https://[::1]", True),  # IPv6 address in URL
            # Invalid URLs:
            ("/data/Python.html", False),
            ("www.streamlit.io", False),  # Missing scheme
            (532, False),
            ("dkakasdkjdjakdjadjfalskdjfalk", False),
            ("mailto:", False),
            ("ftp://example.com/resource", False),  # Unsupported scheme
            ("https:///path/to/resource", False),  # Missing netloc
        ]
    )
    def test_is_url(self, url: Any, expected_value: bool):
        """Test the is_url utility function."""
        self.assertEqual(
            url_util.is_url(url, ("http", "https", "data", "mailto")), expected_value
        )

    @parameterized.expand(
        [
            ("http://example.com", ("http",), True),
            ("mailto:test@example.com", ("http", "https"), False),
            ("mailto:test@example.com", ("http", "mailto"), True),
            ("https://example.com", ("http",), False),
            ("https://example.com", ("https",), True),
            ("data:image/png;base64,abc123", ("data",), True),
            ("data:image/png;base64,abc123", ("http", "https", "mailto"), False),
            ("https://example.com", ("http", "https", "mailto"), True),
            ("http://example.com", None, True),  # None schema == use default
            ("https://example.com", None, True),  # None schema == use default
            ("data:image/png;base64,abc123", None, False),  # None schema == use default
            ("mailto:test@example.com", None, False),  # None schema == use default
        ]
    )
    def test_is_url_limits_schema(
        self,
        url: str,
        allowed_schemas: tuple[url_util.UrlSchema, ...] | None,
        expected_value: bool,
    ):
        """Test that is_ur applies the allowed schema parameter."""

        if allowed_schemas is None:
            self.assertEqual(url_util.is_url(url), expected_value)
        else:
            self.assertEqual(url_util.is_url(url, allowed_schemas), expected_value)


================================================
File: /lib/tests/streamlit/user_info_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import base64
import json
import threading
from unittest.mock import MagicMock, patch

from parameterized import parameterized

import streamlit as st
from streamlit.errors import StreamlitAPIException, StreamlitAuthError
from streamlit.runtime.forward_msg_queue import ForwardMsgQueue
from streamlit.runtime.fragment import MemoryFragmentStorage
from streamlit.runtime.pages_manager import PagesManager
from streamlit.runtime.scriptrunner import (
    ScriptRunContext,
    add_script_run_ctx,
    get_script_run_ctx,
)
from streamlit.runtime.state import SafeSessionState, SessionState
from tests.delta_generator_test_case import DeltaGeneratorTestCase

SECRETS_MOCK = {
    "redirect_uri": "http://localhost:8501/oauth2callback",
    "cookie_secret": "test_cookie_secret",
    "google": {
        "client_id": "CLIENT_ID",
        "client_secret": "CLIENT_SECRET",
        "server_metadata_url": "https://accounts.google.com/.well-known/openid-configuration",
    },
    "microsoft": {
        "client_id": "CLIENT_ID",
        "client_secret": "CLIENT_SECRET",
        "server_metadata_url": "https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration",
    },
    "auth0": {
        "client_id": "CLIENT_ID",
        "client_secret": "CLIENT_SECRET",
        "server_metadata_url": "https://YOUR_DOMAIN/.well-known/openid-configuration",
    },
}


class UserInfoProxyTest(DeltaGeneratorTestCase):
    """Test UserInfoProxy."""

    def test_user_email_attr(self):
        """Test that `st.user.email` returns user info from ScriptRunContext"""
        self.assertEqual(st.experimental_user.email, "test@example.com")

    def test_user_email_key(self):
        self.assertEqual(st.experimental_user["email"], "test@example.com")

    def test_user_non_existing_attr(self):
        """Test that an error is raised when called non existed attr."""
        with self.assertRaises(AttributeError):
            st.write(st.experimental_user.attribute)

    def test_user_non_existing_key(self):
        """Test that an error is raised when called non existed key."""
        with self.assertRaises(KeyError):
            st.write(st.experimental_user["key"])

    def test_user_cannot_be_modified_existing_key(self):
        """
        Test that an error is raised when try to assign new value to existing key.
        """
        with self.assertRaises(StreamlitAPIException) as e:
            st.experimental_user["email"] = "NEW_VALUE"

        self.assertEqual(str(e.exception), "st.experimental_user cannot be modified")

    def test_user_cannot_be_modified_new_key(self):
        """
        Test that an error is raised when try to assign new value to new key.
        """
        with self.assertRaises(StreamlitAPIException) as e:
            st.experimental_user["foo"] = "bar"

        self.assertEqual(str(e.exception), "st.experimental_user cannot be modified")

    def test_user_cannot_be_modified_existing_attr(self):
        """
        Test that an error is raised when try to assign new value to existing attr.
        """
        with self.assertRaises(StreamlitAPIException) as e:
            st.experimental_user.email = "bar"

        self.assertEqual(str(e.exception), "st.experimental_user cannot be modified")

    def test_user_cannot_be_modified_new_attr(self):
        """
        Test that an error is raised when try to assign new value to new attr.
        """
        with self.assertRaises(StreamlitAPIException) as e:
            st.experimental_user.foo = "bar"

        self.assertEqual(str(e.exception), "st.experimental_user cannot be modified")

    def test_user_len(self):
        self.assertEqual(len(st.experimental_user), 1)

    def test_st_user_reads_from_context_(self):
        """Test that st.user reads information from current ScriptRunContext
        And after ScriptRunContext changed, it returns new email
        """
        orig_report_ctx = get_script_run_ctx()

        forward_msg_queue = ForwardMsgQueue()

        try:
            add_script_run_ctx(
                threading.current_thread(),
                ScriptRunContext(
                    session_id="test session id",
                    _enqueue=forward_msg_queue.enqueue,
                    query_string="",
                    session_state=SafeSessionState(SessionState(), lambda: None),
                    uploaded_file_mgr=None,
                    main_script_path="",
                    user_info={"email": "something@else.com"},
                    fragment_storage=MemoryFragmentStorage(),
                    pages_manager=PagesManager(""),
                ),
            )

            self.assertEqual(st.experimental_user.email, "something@else.com")
        except Exception as e:
            raise e
        finally:
            add_script_run_ctx(threading.current_thread(), orig_report_ctx)


@patch(
    "streamlit.auth_util.secrets_singleton",
    MagicMock(
        load_if_toml_exists=MagicMock(return_value=True),
        get=MagicMock(return_value=SECRETS_MOCK),
    ),
)
class UserInfoAuthTest(DeltaGeneratorTestCase):
    """Test UserInfoProxy Auth functionality."""

    @parameterized.expand(["google", "microsoft", "auth0"])
    def test_user_login(self, provider):
        """Test that st.login sends correct proto message."""
        st.login(provider)

        c = self.get_message_from_queue().auth_redirect

        assert c.url.startswith("/auth/login?provider=")

        jwt_token = c.url.split("=")[1]
        raw_payload = jwt_token.split(".")[1]
        parsed_payload = json.loads(base64.b64decode(raw_payload + "==="))

        assert parsed_payload["provider"] == provider

    def test_user_login_with_invalid_provider(self):
        """Test that st.login raise exception for invalid provider."""
        with self.assertRaises(StreamlitAuthError) as ex:
            st.login("invalid_provider")

        assert (
            "Authentication credentials in `.streamlit/secrets.toml` are missing for the "
            'authentication provider "invalid_provider". Please check your configuration.'
        ) == str(ex.exception)

    def test_user_login_redirect_uri_missing(self):
        """Tests that an error is raised if the redirect uri is missing"""
        with patch(
            "streamlit.auth_util.secrets_singleton",
            MagicMock(
                load_if_toml_exists=MagicMock(return_value=True),
                get=MagicMock(return_value={"google": {}}),
            ),
        ):
            with self.assertRaises(StreamlitAuthError) as ex:
                st.login("google")

            assert """Authentication credentials in `.streamlit/secrets.toml` are missing the
            "redirect_uri" key. Please check your configuration.""" == str(ex.exception)

    def test_user_login_cookie_secret_missing(self):
        """Tests that an error is raised if the cookie secret is missing in secrets.toml"""
        with patch(
            "streamlit.auth_util.secrets_singleton",
            MagicMock(
                load_if_toml_exists=MagicMock(return_value=True),
                get=MagicMock(
                    return_value={
                        "redirect_uri": "http://localhost:8501/oauth2callback",
                        "google": {},
                    }
                ),
            ),
        ):
            with self.assertRaises(StreamlitAuthError) as ex:
                st.login("google")

            assert """Authentication credentials in `.streamlit/secrets.toml` are missing the
            "cookie_secret" key. Please check your configuration.""" == str(
                ex.exception
            )

    def test_user_login_required_fields_missing(self):
        """Tests that an error is raised if the required fields are missing"""
        with patch(
            "streamlit.auth_util.secrets_singleton",
            MagicMock(
                load_if_toml_exists=MagicMock(return_value=True),
                get=MagicMock(
                    return_value={
                        "redirect_uri": "http://localhost:8501/oauth2callback",
                        "cookie_secret": "test_cookie_secret",
                        "google": {},
                    }
                ),
            ),
        ):
            with self.assertRaises(StreamlitAuthError) as ex:
                st.login("google")

            assert (
                "Authentication credentials in `.streamlit/secrets.toml` for the "
                'authentication provider "google" are missing the following keys: '
                "['client_id', 'client_secret', 'server_metadata_url']. Please check your "
                "configuration."
            ) == str(ex.exception)

    def test_user_logout(self):
        """Test that st.logout sends correct proto message."""
        st.logout()

        c = self.get_message_from_queue().auth_redirect

        assert c.url.startswith("/auth/logout")


================================================
File: /lib/tests/streamlit/util_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import random
import unittest

from streamlit import util


class UtilTest(unittest.TestCase):
    """Test Streamlit utility functions."""

    def test_memoization(self):
        """Test that util.memoize works."""

        def non_memoized_func():
            return random.randint(0, 1000000)

        yes_memoized_func = util.memoize(non_memoized_func)
        assert non_memoized_func() != non_memoized_func()
        assert yes_memoized_func() == yes_memoized_func()

    def test_functools_wraps(self):
        """Test wrap for functools.wraps"""

        import streamlit as st

        @st.cache_data
        def f():
            return True

        assert hasattr(f, "__wrapped__")

    def test_calc_md5_can_handle_bytes_and_strings(self):
        assert util.calc_md5("eventually bytes") == util.calc_md5(b"eventually bytes")


================================================
File: /lib/tests/streamlit/write_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Streamlit Unit test."""

from __future__ import annotations

import dataclasses
import time
import unittest
from collections import namedtuple
from typing import Any
from unittest.mock import MagicMock, Mock, PropertyMock, call, mock_open, patch

import numpy as np
import pandas as pd
from parameterized import parameterized
from PIL import Image

import streamlit as st
from streamlit import type_util
from streamlit.elements import write
from streamlit.error_util import handle_uncaught_app_exception
from streamlit.errors import StreamlitAPIException
from streamlit.runtime.state import QueryParamsProxy, SessionStateProxy
from tests.streamlit.data_test_cases import (
    SHARED_TEST_CASES,
    CaseMetadata,
)
from tests.streamlit.runtime.secrets_test import MOCK_TOML


class StreamlitWriteTest(unittest.TestCase):
    """Test st.write.

    Unit tests for https://docs.streamlit.io/develop/api-reference/write-magic/st.write

    Because we're going to test st.markdown, st.pyplot, st.altair_chart
    later on, we don't have to test it in st.write In st.write, all we're
    trying to check is that the right st.* method gets called
    """

    def test_repr_html(self):
        """Test st.write with an object that defines _repr_html_."""

        class FakeHTMLable:
            def _repr_html_(self):
                return "<strong>hello world</strong>"

        with patch("streamlit.delta_generator.DeltaGenerator.help") as p:
            fake = FakeHTMLable()
            st.write(fake)

            p.assert_called_once_with(fake)

    def test_repr_html_allowing_html(self):
        """Test st.write with an object that defines _repr_html_ and allows
        unsafe HTML explicitly."""

        class FakeHTMLable:
            def _repr_html_(self):
                return "<strong>hello world</strong>"

        with patch("streamlit.delta_generator.DeltaGenerator.html") as p:
            st.write(FakeHTMLable(), unsafe_allow_html=True)

            p.assert_called_once_with("<strong>hello world</strong>")

    def test_repr_html_no_html_tags_in_string(self):
        """Test st.write with an object that defines _repr_html_ but does not have any
        html tags in the returned string, when unsafe_allow_html=False. In that case,
        we should just honor unsafe_allow_html even though the output of _repr_html_
        actually doesn't have HTML. (The reason we're testing for this is because this
        is a behavior change)
        """

        class FakeHTMLable:
            def _repr_html_(self):
                return "hello **world**"

        with patch("streamlit.delta_generator.DeltaGenerator.html") as p1, patch(
            "streamlit.delta_generator.DeltaGenerator.help"
        ) as p2:
            obj = FakeHTMLable()
            st.write(obj)

            p1.assert_not_called()
            p2.assert_called_once_with(obj)

    def test_repr_html_not_callable(self):
        """Test st.write with an object that defines _repr_html_ but is not callable"""

        class FakeHTMLable:
            _repr_html_ = "hello **world**"

        with patch("streamlit.delta_generator.DeltaGenerator.help") as p:
            fake = FakeHTMLable()
            st.write(fake)

            p.assert_called_once_with(fake)

    def test_string(self):
        """Test st.write with a string."""
        with patch("streamlit.delta_generator.DeltaGenerator.markdown") as p:
            st.write("some string")

            p.assert_called_once()

        with patch("streamlit.delta_generator.DeltaGenerator.markdown") as p:
            st.write("more", "strings", "to", "pass")

            p.assert_called_once_with("more strings to pass", unsafe_allow_html=False)

    def test_exception_type(self):
        """Test st.write with exception."""
        with patch("streamlit.delta_generator.DeltaGenerator.exception") as p:
            st.write(Exception("some exception"))

            p.assert_called_once()

    def test_help(self):
        """Test st.write with help types."""
        # Test module
        with patch("streamlit.delta_generator.DeltaGenerator.help") as p:
            st.write(np)

            p.assert_called_once()

        # Test function
        with patch("streamlit.delta_generator.DeltaGenerator.help") as p:
            st.write(st.set_option)

            p.assert_called_once()

    @patch("streamlit.type_util.is_type")
    def test_altair_chart(self, is_type):
        """Test st.write with altair_chart."""
        is_type.side_effect = make_is_type_mock(type_util._ALTAIR_RE)

        class FakeChart:
            pass

        with patch("streamlit.delta_generator.DeltaGenerator.altair_chart") as p:
            st.write(FakeChart())

            p.assert_called_once()

    @patch("streamlit.type_util.is_type")
    def test_pyplot(self, is_type):
        """Test st.write with matplotlib."""
        is_type.side_effect = make_is_type_mock("matplotlib.figure.Figure")

        class FakePyplot:
            pass

        with patch("streamlit.delta_generator.DeltaGenerator.pyplot") as p:
            st.write(FakePyplot())

            p.assert_called_once()

    @parameterized.expand(
        SHARED_TEST_CASES,
    )
    def test_input_data(
        self,
        name: str,
        input_data: Any,
        metadata: CaseMetadata,
    ):
        """Test st.write with various input data and check that it uses
        the expected command."""
        with patch(
            f"streamlit.delta_generator.DeltaGenerator.{metadata.expected_write_command}"
        ) as p:
            st.write(input_data)

            p.assert_called_once()

    def test_plotly(self):
        import plotly.graph_objs as go

        """Test st.write with plotly object."""
        with patch("streamlit.delta_generator.DeltaGenerator.plotly_chart") as p:
            st.write([go.Scatter(x=[1, 2], y=[10, 20])])

            p.assert_called_once()

    def test_pil_image(self):
        """Test st.write with PIL image objects."""
        with patch("streamlit.delta_generator.DeltaGenerator.image") as p:
            st.write(Image.new("L", (10, 10), "black"))

            p.assert_called_once()

    def test_generator(self):
        """Test st.write with generator function."""

        def gen_function():
            yield "hello"
            yield "world"

        # Should support it as a generator function
        with patch("streamlit.delta_generator.DeltaGenerator.write_stream") as p:
            st.write(gen_function)

            p.assert_called_once()

        # Should support it as a generator function call
        with patch("streamlit.delta_generator.DeltaGenerator.write_stream") as p:
            st.write(gen_function())

            p.assert_called_once()

    def test_async_generator(self):
        """Test st.write with async generator function."""

        async def async_gen_function():
            yield "hello"
            yield "world"

        # Should support it as a generator function
        with patch("streamlit.delta_generator.DeltaGenerator.write_stream") as p:
            st.write(async_gen_function)

            p.assert_called_once()

        with patch("streamlit.delta_generator.DeltaGenerator.write_stream") as p:
            st.write(async_gen_function())

            p.assert_called_once()

    @patch("streamlit.type_util.is_type")
    def test_openai_stream(self, is_type):
        """Test st.write with openai.Stream."""
        is_type.side_effect = make_is_type_mock("openai.Stream")

        class FakeOpenaiStream:
            pass

        with patch("streamlit.delta_generator.DeltaGenerator.write_stream") as p:
            st.write(FakeOpenaiStream())

            p.assert_called_once()

    def test_namedtuple(self):
        """Test st.write with list."""
        with patch("streamlit.delta_generator.DeltaGenerator.json") as p:
            Boy = namedtuple("Boy", ("name", "age"))  # noqa: PYI024
            John = Boy("John", 29)
            st.write(John)

            p.assert_called_once()

    def test_session_state(self):
        """Test st.write with st.session_state."""
        with patch("streamlit.delta_generator.DeltaGenerator.json") as p:
            st.write(SessionStateProxy())

            p.assert_called_once()

    def test_query_params(self):
        """Test st.write with st.query_params."""
        with patch("streamlit.delta_generator.DeltaGenerator.json") as p:
            st.write(QueryParamsProxy())

            p.assert_called_once()

    def test_delta_generator_input(self):
        """Test st.write with DeltaGenerator as input uses st.help."""
        with patch("streamlit.delta_generator.DeltaGenerator.help") as p:
            st.write(st.container())

            p.assert_called_once()

    @patch("builtins.open", new_callable=mock_open, read_data=MOCK_TOML)
    def test_streamlit_secrets(self, *mocks):
        """Test st.write with st.secrets."""
        with patch("streamlit.delta_generator.DeltaGenerator.json") as p:
            st.write(st.secrets)

            p.assert_called_once()

    @patch("streamlit.delta_generator.DeltaGenerator.markdown")
    @patch("streamlit.delta_generator.DeltaGenerator.json")
    def test_dict_and_string(self, mock_json, mock_markdown):
        """Test st.write with dict."""
        manager = Mock()
        manager.attach_mock(mock_json, "json")
        manager.attach_mock(mock_markdown, "markdown")

        st.write("here is a dict", {"a": 1, "b": 2}, " and that is all")

        expected_calls = [
            call.markdown("here is a dict", unsafe_allow_html=False),
            call.json({"a": 1, "b": 2}),
            call.markdown(" and that is all", unsafe_allow_html=False),
        ]
        self.assertEqual(manager.mock_calls, expected_calls)

    def test_default_object(self):
        """Test st.write with default clause ie some object."""

        class SomeObject:
            def __str__(self):
                return "1 * 2 - 3 = 4 `ok` !"

        with patch("streamlit.delta_generator.DeltaGenerator.markdown") as p:
            st.write(SomeObject())

            p.assert_called_once_with(
                "``1 * 2 - 3 = 4 `ok` !``", unsafe_allow_html=False
            )

    def test_default_object_multiline(self):
        """Test st.write with default clause ie some object with multiline string."""

        class SomeObject:
            def __str__(self):
                return "1 * 2\n - 3\n ``` = \n````\n4 `ok` !"

        with patch("streamlit.delta_generator.DeltaGenerator.markdown") as p:
            st.write(SomeObject())

            p.assert_called_once_with(
                "`````\n1 * 2\n - 3\n ``` = \n````\n4 `ok` !\n`````",
                unsafe_allow_html=False,
            )

    def test_class(self):
        """Test st.write with a class."""

        class SomeClass:
            pass

        with patch("streamlit.delta_generator.DeltaGenerator.help") as p:
            st.write(SomeClass)

            p.assert_called_once_with(SomeClass)

        with patch("streamlit.delta_generator.DeltaGenerator.help") as p:
            empty_df = pd.DataFrame()
            st.write(type(empty_df))

            p.assert_called_once_with(type(empty_df))

    def test_obj_instance(self):
        """Test st.write with an object instance that doesn't know how to str()."""

        class SomeClass:
            pass

        my_instance = SomeClass()

        with patch("streamlit.delta_generator.DeltaGenerator.help") as p:
            st.write(my_instance)

            p.assert_called_once_with(my_instance)

    def test_dataclass_instance(self):
        """Test st.write with a dataclass instance."""

        @dataclasses.dataclass
        class SomeClass:
            pass

        my_instance = SomeClass()

        with patch("streamlit.delta_generator.DeltaGenerator.help") as p:
            st.write(my_instance)

            p.assert_called_once_with(my_instance)

    # We use "looks like a memory address" as a test inside st.write, so here we're
    # checking that that logic isn't broken.
    def test_str_looking_like_mem_address(self):
        """Test calling st.write on a string that looks like a memory address."""

        with patch("streamlit.delta_generator.DeltaGenerator.markdown") as p:
            st.write("<__main__.MyObj object at 0x13d2d0bb0>")

            p.assert_called_once()

    def test_exception(self):
        """Test st.write that raises an exception."""
        # We patch streamlit.exception to observe it, but we also make sure
        # it's still called (via side_effect). This ensures that it's called
        # with the proper arguments.
        with patch("streamlit.delta_generator.DeltaGenerator.markdown") as m, patch(
            "streamlit.delta_generator.DeltaGenerator.exception",
            side_effect=handle_uncaught_app_exception,
        ):
            m.side_effect = Exception("some exception")

            with self.assertRaises(Exception):  # noqa: B017
                st.write("some text")

    def test_unknown_arguments(self):
        """Test st.write that raises an exception."""
        with self.assertLogs(write._LOGGER) as logs:
            st.write("some text", unknown_keyword_arg=123)

        self.assertIn(
            'Invalid arguments were passed to "st.write" function.', logs.records[0].msg
        )

    def test_spinner(self):
        """Test st.spinner."""
        # TODO(armando): Test that the message is actually passed to
        # message.warning
        with patch("streamlit.delta_generator.DeltaGenerator.empty") as e:
            with st.spinner("some message"):
                time.sleep(0.15)
            e.assert_called_once_with()

    def test_sidebar(self):
        """Test st.write in the sidebar."""
        with patch("streamlit.delta_generator.DeltaGenerator.markdown") as m, patch(
            "streamlit.delta_generator.DeltaGenerator.help"
        ) as h:
            st.sidebar.write("markdown", st.help)

            m.assert_called_once()
            h.assert_called_once()

    def test_empty(self):
        """Test st.write from a specific element."""
        placeholder = st.empty()

        with patch("streamlit.delta_generator.DeltaGenerator.markdown") as p:
            placeholder.write("One argument is okay...")

            p.assert_called_once()

        with self.assertRaises(StreamlitAPIException):
            # Also override dg._is_top_level for this test.
            with patch.object(
                st.delta_generator.DeltaGenerator,
                "_is_top_level",
                new_callable=PropertyMock,
            ) as top_level:
                top_level.return_value = False

                placeholder.write("But", "multiple", "args", "should", "fail")


class StreamlitStreamTest(unittest.TestCase):
    """Test st.write_stream."""

    @patch("streamlit.type_util.is_type")
    def test_with_openai_chunk(self, is_type):
        """Test st.write_stream with openai Chunks."""

        is_type.side_effect = make_is_type_mock(type_util._OPENAI_CHUNK_RE)

        # Create a mock for ChatCompletionChunk
        mock_chunk = MagicMock()

        def openai_stream():
            mock_chunk.choices = []
            yield mock_chunk  # should also support empty chunks
            mock_chunk.choices = [MagicMock()]
            mock_chunk.choices[0].delta.content = "Hello "
            yield mock_chunk
            mock_chunk.choices[0].delta.content = "World"
            yield mock_chunk

        stream_return = st.write_stream(openai_stream)
        self.assertEqual(stream_return, "Hello World")

    def test_with_generator_text(self):
        """Test st.write_stream with generator text content."""

        def test_stream():
            yield "Hello "
            yield "World"

        stream_return = st.write_stream(test_stream)
        self.assertEqual(stream_return, "Hello World")

    def test_with_async_generator_text(self):
        """Test st.write_stream with async generator text content."""

        async def test_stream():
            yield "Hello "
            yield "World"

        stream_return = st.write_stream(test_stream)
        self.assertEqual(stream_return, "Hello World")

        stream_return = st.write_stream(test_stream())
        self.assertEqual(stream_return, "Hello World")

    def test_with_empty_chunks(self):
        """Test st.write_stream with generator that returns empty chunks."""

        def test_stream():
            yield ""
            yield ""

        stream_return = st.write_stream(test_stream)
        self.assertEqual(stream_return, "")

    def test_with_empty_stream(self):
        """Test st.write_stream with generator that returns empty chunks."""

        def test_stream():
            if False:
                yield "Hello"

        stream_return = st.write_stream(test_stream)
        self.assertEqual(stream_return, "")

    def test_with_wrong_input(self):
        """Test st.write_stream with string or dataframe input generates exception."""

        with self.assertRaises(StreamlitAPIException):
            st.write_stream("Hello World")

        with self.assertRaises(StreamlitAPIException):
            st.write_stream(pd.DataFrame([[1, 2], [3, 4]]))

    def test_with_generator_misc(self):
        """Test st.write_stream with generator with different content."""

        def test_stream():
            yield "This is "
            yield "a dataframe:"
            yield pd.DataFrame([[1, 2], [3, 4]])
            yield "Text under dataframe"

        with patch("streamlit.delta_generator.DeltaGenerator.dataframe") as p_dataframe:
            stream_return = st.write_stream(test_stream)
            p_dataframe.assert_called_once()
            self.assertEqual(
                str(stream_return),
                str(
                    [
                        "This is a dataframe:",
                        pd.DataFrame([[1, 2], [3, 4]]),
                        "Text under dataframe",
                    ]
                ),
            )

    def test_with_list_output(self):
        """Test st.write_stream with a list."""

        data = [
            "This is ",
            "a dataframe:",
            pd.DataFrame([[1, 2], [3, 4]]),
            "Text under dataframe",
        ]

        with patch("streamlit.delta_generator.DeltaGenerator.dataframe") as p_dataframe:
            stream_return = st.write_stream(data)
            p_dataframe.assert_called_once()
            self.assertEqual(
                str(stream_return),
                str(
                    [
                        "This is a dataframe:",
                        pd.DataFrame([[1, 2], [3, 4]]),
                        "Text under dataframe",
                    ]
                ),
            )


def make_is_type_mock(true_type_matchers):
    """Return a function that mocks is_type.

    When you do this:
    mock_is_type.side_effect = make_is_type_mock("foo.bar.Baz")

    ...then when you call mock_is_type(my_type, "foo.bar.Baz") it will return
    True (and False otherwise).

    You can also pass in a tuple.
    """
    if type(true_type_matchers) is not tuple:
        true_type_matchers = (true_type_matchers,)

    def new_is_type(obj, type_matchers):
        if type(type_matchers) is not tuple:
            type_matchers = (type_matchers,)

        for type_matcher in type_matchers:
            if type_matcher in true_type_matchers:
                return True
        return False

    return new_is_type


================================================
File: /lib/tests/streamlit/commands/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/commands/execution_control_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import unittest
from unittest.mock import MagicMock, patch

import pytest

from streamlit.commands.execution_control import _new_fragment_id_queue, rerun
from streamlit.errors import StreamlitAPIException
from streamlit.runtime.scriptrunner import RerunData


class NewFragmentIdQueueTest(unittest.TestCase):
    def test_returns_empty_list_if_scope_is_app(self):
        assert _new_fragment_id_queue(None, scope="app") == []

    def test_raises_exception_if_no_fragment_id_queue(self):
        ctx = MagicMock()
        ctx.fragment_ids_this_run = []

        with pytest.raises(StreamlitAPIException):
            _new_fragment_id_queue(ctx, scope="fragment")

    def test_asserts_if_curr_id_not_in_queue(self):
        ctx = MagicMock()
        ctx.fragment_ids_this_run = ["some_fragment_id"]
        ctx.current_fragment_id = "some_other_fragment_id"

        with pytest.raises(AssertionError):
            _new_fragment_id_queue(ctx, scope="fragment")

    def test_drops_items_in_queue_until_curr_id(self):
        ctx = MagicMock()
        ctx.fragment_ids_this_run = [
            "id1",
            "id2",
            "id3",
            "curr_id",
            "id4",
            "id5",
        ]
        ctx.current_fragment_id = "curr_id"

        assert _new_fragment_id_queue(ctx, scope="fragment") == [
            "curr_id",
            "id4",
            "id5",
        ]


@patch("streamlit.commands.execution_control.get_script_run_ctx")
def test_st_rerun_is_fragment_scoped_rerun_flag_False(patched_get_script_run_ctx):
    ctx = MagicMock()
    patched_get_script_run_ctx.return_value = ctx

    rerun(scope="app")

    ctx.script_requests.request_rerun.assert_called_with(
        RerunData(
            query_string=ctx.query_string,
            page_script_hash=ctx.page_script_hash,
            fragment_id_queue=[],
            is_fragment_scoped_rerun=False,
        )
    )


@patch(
    "streamlit.commands.execution_control._new_fragment_id_queue",
    MagicMock(return_value=["some_fragment_ids"]),
)
@patch("streamlit.commands.execution_control.get_script_run_ctx")
def test_st_rerun_is_fragment_scoped_rerun_flag_True(patched_get_script_run_ctx):
    ctx = MagicMock()
    patched_get_script_run_ctx.return_value = ctx

    rerun(scope="fragment")

    ctx.script_requests.request_rerun.assert_called_with(
        RerunData(
            query_string=ctx.query_string,
            page_script_hash=ctx.page_script_hash,
            fragment_id_queue=["some_fragment_ids"],
            is_fragment_scoped_rerun=True,
        )
    )


def test_st_rerun_invalid_scope_throws_error():
    with pytest.raises(StreamlitAPIException):
        rerun(scope="foo")


================================================
File: /lib/tests/streamlit/commands/experimental_query_params_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from parameterized import parameterized

import streamlit as st
from streamlit.commands.experimental_query_params import (
    _exclude_keys_in_dict,
    _extract_key_query_params,
)
from streamlit.errors import StreamlitAPIException
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class QueryParamsAPITest(DeltaGeneratorTestCase):
    """Test Query params commands APIs."""

    def test_set_query_params_sends_protobuf_message(self):
        """Test valid st.set_query_params sends protobuf message."""
        st.experimental_set_query_params(x="a")
        message = self.get_message_from_queue(0)
        self.assertEqual(message.page_info_changed.query_string, "x=a")

    def test_set_query_params_exceptions(self):
        """Test invalid st.set_query_params raises exceptions."""
        with self.assertRaises(StreamlitAPIException):
            st.experimental_set_query_params(embed="True")
        with self.assertRaises(StreamlitAPIException):
            st.experimental_set_query_params(embed_options="show_colored_line")

    def test_get_query_params_after_set_query_params(self):
        """Test valid st.set_query_params sends protobuf message."""
        p_set = dict(x=["a"])
        st.experimental_set_query_params(**p_set)
        p_get = st.experimental_get_query_params()
        self.assertEqual(p_get, p_set)

    def test_set_query_params_empty_str(self):
        empty_str_params = dict(x=[""])
        st.experimental_set_query_params(**empty_str_params)
        params_get = st.experimental_get_query_params()
        self.assertEqual(params_get, empty_str_params)

    @parameterized.expand(
        [
            ({"x": ["a"]}, ["x"], {}),
            ({"a": ["a1", "a2"], "b": ["b1", "b2"]}, ["a"], {"b": ["b1", "b2"]}),
            ({"c": ["c1", "c2"]}, "no_existing_key", {"c": ["c1", "c2"]}),
            (
                {
                    "embed": ["true"],
                    "embed_options": ["show_padding", "show_colored_line"],
                },
                ["embed", "embed_options"],
                {},
            ),
            (
                {"EMBED": ["TRUE"], "EMBED_OPTIONS": ["DISABLE_SCROLLING"]},
                ["embed", "embed_options"],
                {},
            ),
        ]
    )
    def test_exclude_keys_in_dict(
        self,
        d: dict[str, list[str]],
        keys_to_drop: list[str],
        result: dict[str, list[str]],
    ):
        assert _exclude_keys_in_dict(d, keys_to_drop) == result

    @parameterized.expand(
        [
            ({"x": ["a"]}, "x", {"a"}),
            ({"a": ["a1"], "b": ["b1", "b2"]}, "a", {"a1"}),
            ({"c": ["c1", "c2"]}, "no_existing_key", set()),
            (
                {
                    "embed": ["true"],
                    "embed_options": ["show_padding", "show_colored_line"],
                },
                "embed",
                {"true"},
            ),
            (
                {"EMBED": ["TRUE"], "EMBED_OPTIONS": ["DISABLE_SCROLLING"]},
                "embed_options",
                {"disable_scrolling"},
            ),
        ]
    )
    def test_extract_key_query_params(
        self, query_params: dict[str, list[str]], param_key: str, result: set[str]
    ):
        assert _extract_key_query_params(query_params, param_key) == result


================================================
File: /lib/tests/streamlit/commands/logo_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pathlib

import pytest
from PIL import Image

import streamlit as st
from streamlit.errors import StreamlitAPIException
from streamlit.runtime.memory_media_file_storage import get_extension_for_mimetype
from streamlit.web.server.server import MEDIA_ENDPOINT
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class LogoTest(DeltaGeneratorTestCase):
    """Test st.logo"""

    def test_image(self):
        """Test that it can be called with image param only."""
        streamlit = Image.open(
            str(pathlib.Path(__file__).parent / "full-streamlit.png")
        )
        st.logo(streamlit)

        c = self.get_message_from_queue().logo
        self.assertTrue(c.image.startswith(MEDIA_ENDPOINT))
        self.assertTrue(c.image.endswith(get_extension_for_mimetype("image/png")))
        self.assertEqual(c.link, "")
        self.assertEqual(c.icon_image, "")
        self.assertEqual(c.size, "medium")

    def test_image_and_link(self):
        """Test that it can be called with image & link."""
        streamlit = Image.open(
            str(pathlib.Path(__file__).parent / "full-streamlit.png")
        )
        st.logo(streamlit, link="http://www.example.com")

        c = self.get_message_from_queue().logo
        self.assertTrue(c.image.startswith(MEDIA_ENDPOINT))
        self.assertTrue(c.image.endswith(get_extension_for_mimetype("image/png")))
        self.assertEqual(c.link, "http://www.example.com")
        self.assertEqual(c.icon_image, "")
        self.assertEqual(c.size, "medium")

    def test_invalid_link(self):
        """Test that it can be only be called with a valid link."""
        streamlit = Image.open(
            str(pathlib.Path(__file__).parent / "full-streamlit.png")
        )
        with pytest.raises(StreamlitAPIException):
            st.logo(streamlit, link="www.example.com")

    def test_with_icon_image(self):
        """Test that it can be called with image & link."""
        streamlit = Image.open(
            str(pathlib.Path(__file__).parent / "full-streamlit.png")
        )
        collapsed = Image.open(
            str(pathlib.Path(__file__).parent / "small-streamlit.png")
        )

        st.logo(streamlit, link="https://www.example.com", icon_image=collapsed)

        png_extension = get_extension_for_mimetype("image/png")

        c = self.get_message_from_queue().logo
        self.assertTrue(c.image.startswith(MEDIA_ENDPOINT))
        self.assertTrue(c.image.endswith(png_extension))
        self.assertEqual(c.link, "https://www.example.com")
        self.assertTrue(c.icon_image.startswith(MEDIA_ENDPOINT))
        self.assertTrue(c.icon_image.endswith(png_extension))
        self.assertEqual(c.size, "medium")

    def test_small_image_size(self):
        """Test that it can be called with small image size."""
        streamlit = Image.open(
            str(pathlib.Path(__file__).parent / "full-streamlit.png")
        )
        st.logo(streamlit, size="small")

        c = self.get_message_from_queue().logo
        self.assertTrue(c.image.startswith(MEDIA_ENDPOINT))
        self.assertTrue(c.image.endswith(get_extension_for_mimetype("image/png")))
        self.assertEqual(c.link, "")
        self.assertEqual(c.icon_image, "")
        self.assertEqual(c.size, "small")

    def test_large_image_size(self):
        """Test that it can be called with large image size."""
        streamlit = Image.open(
            str(pathlib.Path(__file__).parent / "full-streamlit.png")
        )
        st.logo(streamlit, size="large")

        c = self.get_message_from_queue().logo
        self.assertTrue(c.image.startswith(MEDIA_ENDPOINT))
        self.assertTrue(c.image.endswith(get_extension_for_mimetype("image/png")))
        self.assertEqual(c.link, "")
        self.assertEqual(c.icon_image, "")
        self.assertEqual(c.size, "large")

    def test_invalid_image_size(self):
        """Test that it can be only be called with a valid image size."""
        streamlit = Image.open(
            str(pathlib.Path(__file__).parent / "full-streamlit.png")
        )
        with pytest.raises(StreamlitAPIException):
            st.logo(streamlit, size="corgi")


================================================
File: /lib/tests/streamlit/commands/navigation_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from pathlib import Path
from unittest.mock import MagicMock, patch

import pytest

import streamlit as st
from streamlit.errors import StreamlitAPIException
from streamlit.proto.Navigation_pb2 import Navigation as NavigationProto
from tests.delta_generator_test_case import DeltaGeneratorTestCase
from tests.testutil import patch_config_options


@patch("pathlib.Path.is_file", MagicMock(return_value=True))
class NavigationTest(DeltaGeneratorTestCase):
    """Test st.navigation"""

    def test_no_pages(self):
        """Test that an error is thrown with no pages"""
        with pytest.raises(StreamlitAPIException):
            st.navigation([])

    def test_single_page(self):
        """Test that a single page is returned"""
        single_page = st.Page("page1.py")
        page = st.navigation([single_page])
        assert page == single_page

    def test_single_page_with_path(self):
        """Test that a single page is returned with a Path object"""
        single_page = st.Page(Path("page1.py"))
        page = st.navigation([single_page])
        assert page == single_page

    def test_first_page_is_default(self):
        """Test that the first page is returned if there are multiple pages and no default"""
        single_page = st.Page("page1.py")
        page = st.navigation([single_page, st.Page("page2.py"), st.Page("page3.py")])
        assert page == single_page
        assert page._default

    def test_default_page_returned_if_specified(self):
        """Test that the first page is returned if there are multiple pages and no default"""
        default_page = st.Page("page3.py", default=True)
        page = st.navigation([st.Page("page1.py"), st.Page("page2.py"), default_page])
        assert page == default_page
        assert page._default

    def test_multiple_defaults_raises_APIException(self):
        """Test that an error is thrown if multiple defaults are specified"""
        with pytest.raises(StreamlitAPIException):
            st.navigation(
                [st.Page("page1.py", default=True), st.Page("page2.py", default=True)]
            )

    def test_same_url_paths_raises_APIException(self):
        """Test that an error is thrown if same url_paths are specified"""
        with pytest.raises(StreamlitAPIException):
            st.navigation(
                [
                    st.Page("page1.py", url_path="foo"),
                    st.Page("page2.py", url_path="foo"),
                ]
            )

    def test_same_inferred_url_paths_raises_APIException(self):
        """Test that an error is thrown if the same inferred url_paths are specified"""
        with pytest.raises(StreamlitAPIException):
            st.navigation(
                [
                    st.Page("page1.py", url_path="foo"),
                    st.Page("foo.py"),
                ]
            )

    def test_page_found_by_hash(self):
        found_page = st.Page("page2.py")
        self.script_run_ctx.pages_manager.set_script_intent(found_page._script_hash, "")
        page = st.navigation([st.Page("page1.py"), found_page, st.Page("page3.py")])
        assert page == found_page

    def test_page_found_by_name(self):
        found_page = st.Page("page2.py")
        self.script_run_ctx.pages_manager.set_script_intent("", "page2")
        page = st.navigation([st.Page("page1.py"), found_page, st.Page("page3.py")])
        assert page == found_page
        assert self.script_run_ctx.page_script_hash == found_page._script_hash

    def test_page_not_found_by_name(self):
        default_page = st.Page("page1.py")
        self.script_run_ctx.pages_manager.set_script_intent("", "bad_page")
        page = st.navigation([default_page, st.Page("page2.py"), st.Page("page3.py")])

        c = self.get_message_from_queue(-2)
        assert c.HasField("page_not_found")
        assert page == default_page
        assert self.script_run_ctx.page_script_hash == default_page._script_hash

    def test_page_not_found_by_hash_returns_default(self):
        default_page = st.Page("page1.py")
        self.script_run_ctx.pages_manager.set_script_intent("bad_hash", "")
        page = st.navigation([default_page, st.Page("page2.py"), st.Page("page3.py")])
        assert page == default_page
        assert self.script_run_ctx.page_script_hash == default_page._script_hash

    def test_navigation_message(self):
        st.navigation(
            {
                "Section 1": [st.Page("page1.py")],
                "Section 2": [st.Page("page2.py"), st.Page("page3.py")],
            }
        )

        c = self.get_message_from_queue().navigation
        assert len(c.app_pages) == 3
        assert c.app_pages[0].section_header == "Section 1"
        assert c.app_pages[1].section_header == "Section 2"
        assert c.app_pages[2].section_header == "Section 2"
        assert c.app_pages[0].is_default
        assert not c.app_pages[1].is_default
        assert not c.app_pages[2].is_default
        assert c.position == NavigationProto.Position.SIDEBAR
        assert not c.expanded
        assert c.sections == ["Section 1", "Section 2"]

    def test_navigation_message_with_position(self):
        st.navigation(
            [st.Page("page1.py"), st.Page("page2.py"), st.Page("page3.py")],
            position="hidden",
        )

        c = self.get_message_from_queue().navigation
        assert len(c.app_pages) == 3
        assert c.app_pages[0].section_header == ""
        assert c.app_pages[1].section_header == ""
        assert c.app_pages[2].section_header == ""
        assert c.app_pages[0].is_default
        assert not c.app_pages[1].is_default
        assert not c.app_pages[2].is_default
        assert c.position == NavigationProto.Position.HIDDEN
        assert not c.expanded
        assert c.sections == [""]

    @patch_config_options({"client.showSidebarNavigation": False})
    def test_navigation_message_with_sidebar_nav_config(self):
        st.navigation(
            [st.Page("page1.py"), st.Page("page2.py"), st.Page("page3.py")],
        )

        c = self.get_message_from_queue().navigation
        assert len(c.app_pages) == 3
        assert c.app_pages[0].section_header == ""
        assert c.app_pages[1].section_header == ""
        assert c.app_pages[2].section_header == ""
        assert c.app_pages[0].is_default
        assert not c.app_pages[1].is_default
        assert not c.app_pages[2].is_default
        assert c.position == NavigationProto.Position.HIDDEN
        assert not c.expanded
        assert c.sections == [""]

    def test_navigation_message_with_expanded(self):
        st.navigation(
            [st.Page("page1.py"), st.Page("page2.py"), st.Page("page3.py")],
            expanded=True,
        )

        c = self.get_message_from_queue().navigation
        assert len(c.app_pages) == 3
        assert c.app_pages[0].section_header == ""
        assert c.app_pages[1].section_header == ""
        assert c.app_pages[2].section_header == ""
        assert c.app_pages[0].is_default
        assert not c.app_pages[1].is_default
        assert not c.app_pages[2].is_default
        assert c.position == NavigationProto.Position.SIDEBAR
        assert c.expanded
        assert c.sections == [""]


================================================
File: /lib/tests/streamlit/commands/page_config_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from unittest import mock

from parameterized import param, parameterized

import streamlit as st
from streamlit.commands.page_config import (
    ENG_EMOJIS,
    RANDOM_EMOJIS,
    PageIcon,
    _lower_clean_dict_keys,
)
from streamlit.errors import (
    StreamlitAPIException,
    StreamlitInvalidSidebarStateError,
    StreamlitInvalidURLError,
)
from streamlit.proto.PageConfig_pb2 import PageConfig as PageConfigProto
from streamlit.string_util import is_emoji
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class PageConfigTest(DeltaGeneratorTestCase):
    def test_set_page_config_title(self):
        st.set_page_config(page_title="Hello")
        c = self.get_message_from_queue().page_config_changed
        self.assertEqual(c.title, "Hello")

    @parameterized.expand(["ðŸ¦ˆ", ":shark:", "https://foo.com/image.png"])
    def test_set_page_config_icon_strings(self, icon_string: str):
        """page_config icons can be emojis, emoji shortcodes, and image URLs."""
        st.set_page_config(page_icon=icon_string)
        c = self.get_message_from_queue().page_config_changed
        self.assertEqual(c.favicon, icon_string)

    def test_set_page_config_icon_random(self):
        """If page_icon == "random", we choose a random emoji."""
        st.set_page_config(page_icon="random")
        c = self.get_message_from_queue().page_config_changed
        self.assertIn(c.favicon, set(RANDOM_EMOJIS + ENG_EMOJIS))
        self.assertTrue(is_emoji(c.favicon))

    def test_set_page_config_icon_invalid_string(self):
        """If set_page_config is passed a garbage icon string, we just pass it
        through without an error (even though nothing will be displayed).
        """
        st.set_page_config(page_icon="st.balloons")
        c = self.get_message_from_queue().page_config_changed
        self.assertEqual(c.favicon, "st.balloons")

    @parameterized.expand([param(b"123"), param("file/on/disk.png")])
    def test_set_page_config_icon_calls_image_to_url(self, icon: PageIcon):
        """For all other page_config icon inputs, we just call image_to_url."""
        with mock.patch(
            "streamlit.commands.page_config.image_to_url",
            return_value="https://mock.url",
        ):
            st.set_page_config(page_icon=icon)
            c = self.get_message_from_queue().page_config_changed
            self.assertEqual(c.favicon, "https://mock.url")

    def test_set_page_config_layout_wide(self):
        st.set_page_config(layout="wide")
        c = self.get_message_from_queue().page_config_changed
        self.assertEqual(c.layout, PageConfigProto.WIDE)

    def test_set_page_config_layout_centered(self):
        st.set_page_config(layout="centered")
        c = self.get_message_from_queue().page_config_changed
        self.assertEqual(c.layout, PageConfigProto.CENTERED)

    def test_set_page_config_layout_invalid(self):
        with self.assertRaises(StreamlitAPIException):
            st.set_page_config(layout="invalid")

    def test_set_page_config_sidebar_auto(self):
        st.set_page_config(initial_sidebar_state="auto")
        c = self.get_message_from_queue().page_config_changed
        self.assertEqual(c.initial_sidebar_state, PageConfigProto.AUTO)

    def test_set_page_config_sidebar_expanded(self):
        st.set_page_config(initial_sidebar_state="expanded")
        c = self.get_message_from_queue().page_config_changed
        self.assertEqual(c.initial_sidebar_state, PageConfigProto.EXPANDED)

    def test_set_page_config_sidebar_collapsed(self):
        st.set_page_config(initial_sidebar_state="collapsed")
        c = self.get_message_from_queue().page_config_changed
        self.assertEqual(c.initial_sidebar_state, PageConfigProto.COLLAPSED)

    def test_set_page_config_sidebar_invalid(self):
        with self.assertRaises(StreamlitInvalidSidebarStateError):
            st.set_page_config(initial_sidebar_state="INVALID")

    def test_set_page_config_menu_items_about(self):
        menu_items = {" about": "*This is an about. This accepts markdown.*"}
        st.set_page_config(menu_items=menu_items)
        c = self.get_message_from_queue().page_config_changed.menu_items
        self.assertEqual(
            c.about_section_md, "*This is an about. This accepts markdown.*"
        )

    def test_set_page_config_menu_items_bug_and_help(self):
        menu_items = {
            "report a bug": "https://report_a_bug.com",
            "GET HELP": "https://get_help.com",
        }
        st.set_page_config(menu_items=menu_items)
        c = self.get_message_from_queue().page_config_changed.menu_items
        self.assertFalse(c.hide_report_a_bug)
        self.assertFalse(c.hide_get_help)
        self.assertEqual(c.about_section_md, "")
        self.assertEqual(c.report_a_bug_url, "https://report_a_bug.com")
        self.assertEqual(c.get_help_url, "https://get_help.com")

    def test_set_page_config_menu_items_empty_string(self):
        with self.assertRaises(StreamlitInvalidURLError):
            menu_items = {"report a bug": "", "GET HELP": "", "about": ""}
            st.set_page_config(menu_items=menu_items)

    def test_set_page_config_menu_items_none(self):
        menu_items = {"report a bug": None, "GET HELP": None, "about": None}
        st.set_page_config(menu_items=menu_items)
        c = self.get_message_from_queue().page_config_changed.menu_items
        self.assertTrue(c.hide_report_a_bug)
        self.assertTrue(c.hide_get_help)
        self.assertEqual(c.about_section_md, "")

    def test_set_page_config_menu_items_invalid(self):
        with self.assertRaises(StreamlitAPIException) as e:
            menu_items = {"invalid": "fdsa"}
            st.set_page_config(menu_items=menu_items)
        self.assertEqual(
            str(e.exception),
            'We only accept the keys: `"Get help"`, `"Report a bug"`, and `"About"` '
            '(`"invalid"` is not a valid key.)',
        )

    def test_set_page_config_menu_items_empty_dict(self):
        st.set_page_config(menu_items={})
        c = self.get_message_from_queue().page_config_changed.menu_items
        self.assertEqual(c.about_section_md, "")

    @parameterized.expand(
        [
            ({}, {}),
            (
                {
                    "HELLO_1": 4,
                    "Hello_2": "world",
                    "hElLo_3": 5.5,
                    "": "",
                },
                {"hello_1": 4, "hello_2": "world", "hello_3": 5.5, "": ""},
            ),
        ]
    )
    def test_lower_clean_dict_keys(self, input_dict, answer_dict):
        return_dict = _lower_clean_dict_keys(input_dict)
        assert return_dict == answer_dict


================================================
File: /lib/tests/streamlit/component_test_data/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from streamlit.components.v1 import declare_component

component = declare_component("foo", url="http://not.a.url")


================================================
File: /lib/tests/streamlit/component_test_data/outer_module.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from streamlit.components.v1 import declare_component

component = declare_component("foo", url="http://not.a.url")


================================================
File: /lib/tests/streamlit/component_test_data/nested/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/component_test_data/nested/inner_module.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from streamlit.components.v1 import declare_component

component = declare_component("foo", url="http://not.a.url")


================================================
File: /lib/tests/streamlit/connections/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/connections/base_connection_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import unittest
from unittest.mock import PropertyMock, mock_open, patch

import pytest

import streamlit as st
from streamlit.connections import BaseConnection
from streamlit.runtime.secrets import AttrDict

MOCK_TOML = """
[connections.my_mock_connection]
foo="bar"
"""


class MockRawConnection:
    def some_raw_connection_method(self):
        return "some raw connection method"


class MockConnection(BaseConnection[str]):
    def _connect(self, **kwargs) -> str:
        return MockRawConnection()

    def some_method(self):
        return "some method"


class BaseConnectionDefaultMethodTests(unittest.TestCase):
    def setUp(self) -> None:
        # st.secrets modifies os.environ, so we save it here and
        # restore in tearDown.
        self._prev_environ = dict(os.environ)

    def tearDown(self) -> None:
        os.environ.clear()
        os.environ.update(self._prev_environ)
        st.secrets._reset()

    def test_instance_set_to_connect_return_value(self):
        assert isinstance(
            MockConnection("my_mock_connection")._instance, MockRawConnection
        )

    def test_getattr_works_with_methods_on_connection(self):
        assert MockConnection("my_mock_connection").some_method() == "some method"

    def test_getattr_friendly_error_message(self):
        with pytest.raises(AttributeError) as e:
            MockConnection("my_mock_connection").some_raw_connection_method()

        assert (
            str(e.value)
            == "`some_raw_connection_method` doesn't exist here, but you can call `._instance.some_raw_connection_method` instead"
        )
        assert (
            MockConnection("my_mock_connection")._instance.some_raw_connection_method()
            == "some raw connection method"
        )

    def test_getattr_totally_nonexistent_attr(self):
        with pytest.raises(AttributeError) as e:
            MockConnection("my_mock_connection").totally_nonexistent_method()

        assert (
            str(e.value)
            == "'MockConnection' object has no attribute 'totally_nonexistent_method'"
        )

    @patch("builtins.open", new_callable=mock_open, read_data=MOCK_TOML)
    def test_secrets_property(self, _):
        conn = MockConnection("my_mock_connection")
        assert conn._secrets.foo == "bar"

    @patch("builtins.open", new_callable=mock_open, read_data=MOCK_TOML)
    def test_secrets_property_no_matching_section(self, _):
        conn = MockConnection("nonexistent")
        assert conn._secrets == {}

    def test_secrets_property_no_secrets(self):
        conn = MockConnection("my_mock_connection")
        assert conn._secrets == {}

    def test_instance_prop_caches_raw_instance(self):
        conn = MockConnection("my_mock_connection")
        conn._raw_instance = "some other value"

        assert conn._instance == "some other value"

    def test_instance_prop_reinitializes_if_reset(self):
        conn = MockConnection("my_mock_connection")
        conn._raw_instance = None

        assert isinstance(conn._instance, MockRawConnection)

    def test_on_secrets_changed_when_nothing_changed(self):
        conn = MockConnection("my_mock_connection")

        # conn.reset() shouldn't be called because secrets haven't changed since conn
        # was constructed.
        with patch(
            "streamlit.connections.base_connection.BaseConnection.reset"
        ) as patched_reset:
            conn._on_secrets_changed("unused_arg")
            patched_reset.assert_not_called()

    def test_on_secrets_changed(self):
        conn = MockConnection("my_mock_connection")

        with patch(
            "streamlit.connections.base_connection.BaseConnection.reset"
        ) as patched_reset, patch(
            "streamlit.connections.base_connection.BaseConnection._secrets",
            PropertyMock(return_value=AttrDict({"mock_connection": {"new": "secret"}})),
        ):
            conn._on_secrets_changed("unused_arg")
            patched_reset.assert_called_once()

    # Test this here rather than in write_test.py because the MockConnection object
    # is defined here. Seems cleaner.
    def test_st_write(self):
        conn = MockConnection("my_mock_connection")

        with patch("streamlit.delta_generator.DeltaGenerator.help") as p:
            st.write(conn)

            p.assert_called_once_with(conn)


================================================
File: /lib/tests/streamlit/connections/snowflake_connection_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import threading
import unittest
from unittest.mock import MagicMock, PropertyMock, patch

import pytest

import streamlit as st
from streamlit.connections import SnowflakeConnection
from streamlit.errors import StreamlitAPIException
from streamlit.runtime.scriptrunner import add_script_run_ctx
from streamlit.runtime.secrets import AttrDict
from tests.testutil import create_mock_script_run_ctx


@pytest.mark.require_integration
class SnowflakeConnectionTest(unittest.TestCase):
    def tearDown(self) -> None:
        st.cache_data.clear()

    @patch(
        "snowflake.snowpark.context.get_active_session",
    )
    @patch(
        "streamlit.connections.snowflake_connection.running_in_sis",
        MagicMock(return_value=True),
    )
    def test_uses_active_session_if_in_sis(self, patched_get_active_session):
        active_session_mock = MagicMock()
        active_session_mock.connection = "some active session"
        patched_get_active_session.return_value = active_session_mock

        conn = SnowflakeConnection("my_snowflake_connection")
        assert conn._instance == "some active session"

    @patch(
        "streamlit.connections.snowflake_connection.SnowflakeConnection._secrets",
        PropertyMock(
            return_value=AttrDict({"account": "some_val_1", "some_key": "some_val_2"})
        ),
    )
    @patch("snowflake.connector.connect")
    def test_uses_streamlit_secrets_if_available(self, patched_connect):
        SnowflakeConnection("my_snowflake_connection")
        patched_connect.assert_called_once_with(
            account="some_val_1", some_key="some_val_2"
        )

    @patch("snowflake.connector.connect")
    def test_uses_config_manager_if_available(self, patched_connect):
        SnowflakeConnection("snowflake", some_kwarg="some_value")

        patched_connect.assert_called_once_with(
            connection_name="default", some_kwarg="some_value"
        )

    @patch("snowflake.connector.connection")
    @patch("snowflake.connector.connect")
    def test_falls_back_to_using_kwargs_last(self, patched_connect, patched_connection):
        delattr(patched_connection, "CONFIG_MANAGER")

        SnowflakeConnection("snowflake", account="account", some_kwarg="some_value")
        patched_connect.assert_called_once_with(
            account="account", some_kwarg="some_value"
        )

    def test_throws_friendly_error_if_no_config_set(self):
        with pytest.raises(StreamlitAPIException) as e:
            SnowflakeConnection("snowflake")

        assert "Missing Snowflake connection configuration." in str(e.value)

    @patch(
        "streamlit.connections.snowflake_connection.SnowflakeConnection._connect",
        MagicMock(),
    )
    def test_query_caches_value(self):
        # Caching functions rely on an active script run ctx
        add_script_run_ctx(threading.current_thread(), create_mock_script_run_ctx())

        mock_cursor = MagicMock()
        mock_cursor.fetch_pandas_all = MagicMock(return_value="i am a dataframe")
        conn = SnowflakeConnection("my_snowflake_connection")
        conn._instance.cursor.return_value = mock_cursor

        assert conn.query("SELECT 1;") == "i am a dataframe"
        assert conn.query("SELECT 1;") == "i am a dataframe"

        conn._instance.cursor.assert_called_once()
        mock_cursor.execute.assert_called_once_with("SELECT 1;", params=None)

    @patch(
        "streamlit.connections.snowflake_connection.SnowflakeConnection._connect",
        MagicMock(),
    )
    def test_does_not_reset_cache_when_ttl_changes(self):
        # Caching functions rely on an active script run ctx
        add_script_run_ctx(threading.current_thread(), create_mock_script_run_ctx())

        mock_cursor = MagicMock()
        mock_cursor.fetch_pandas_all = MagicMock(return_value="i am a dataframe")
        conn = SnowflakeConnection("my_snowflake_connection")
        conn._instance.cursor.return_value = mock_cursor

        conn.query("SELECT 1;", ttl=10)
        conn.query("SELECT 2;", ttl=20)
        conn.query("SELECT 1;", ttl=10)
        conn.query("SELECT 2;", ttl=20)

        assert conn._instance.cursor.call_count == 2
        assert mock_cursor.execute.call_count == 2

    @patch(
        "streamlit.connections.snowflake_connection.SnowflakeConnection._connect",
        MagicMock(),
    )
    def test_scopes_caches_by_connection_name(self):
        # Caching functions rely on an active script run ctx
        add_script_run_ctx(threading.current_thread(), create_mock_script_run_ctx())
        mock_cursor = MagicMock()
        mock_cursor.fetch_pandas_all = MagicMock(return_value="i am a dataframe")

        conn1 = SnowflakeConnection("my_snowflake_connection1")
        conn1._instance.cursor.return_value = mock_cursor
        conn2 = SnowflakeConnection("my_snowflake_connection2")
        conn2._instance.cursor.return_value = mock_cursor

        conn1.query("SELECT 1;")
        conn1.query("SELECT 1;")
        conn2.query("SELECT 1;")
        conn2.query("SELECT 1;")

        assert conn1._instance.cursor is conn2._instance.cursor
        assert conn1._instance.cursor.call_count == 2
        assert mock_cursor.execute.call_count == 2

    @patch(
        "streamlit.connections.snowflake_connection.SnowflakeConnection._connect",
        MagicMock(),
    )
    def test_retry_behavior(self):
        from snowflake.connector.errors import ProgrammingError
        from snowflake.connector.network import MASTER_TOKEN_EXPIRED_GS_CODE

        mock_cursor = MagicMock()
        mock_cursor.fetch_pandas_all = MagicMock(
            side_effect=ProgrammingError(
                "oh noes :(", errno=int(MASTER_TOKEN_EXPIRED_GS_CODE)
            )
        )

        conn = SnowflakeConnection("my_snowflake_connection")
        conn._instance.cursor.return_value = mock_cursor

        with patch.object(conn, "reset", wraps=conn.reset) as wrapped_reset:
            with pytest.raises(ProgrammingError):
                conn.query("SELECT 1;")

            # Our connection should have been reset after each failed attempt to call
            # query.
            assert wrapped_reset.call_count == 3

        # conn._connect should have been called three times: once in the initial
        # connection, then once each after the second and third attempts to call
        # query.
        assert conn._connect.call_count == 3

    @patch(
        "streamlit.connections.snowflake_connection.SnowflakeConnection._connect",
        MagicMock(),
    )
    def test_retry_fails_fast_for_programming_errors_with_wrong_code(self):
        from snowflake.connector.errors import ProgrammingError

        mock_cursor = MagicMock()
        mock_cursor.fetch_pandas_all = MagicMock(
            side_effect=ProgrammingError("oh noes :(", errno=42)
        )

        conn = SnowflakeConnection("my_snowflake_connection")
        conn._instance.cursor.return_value = mock_cursor

        with pytest.raises(ProgrammingError):
            conn.query("SELECT 1;")

        # conn._connect should have just been called once when first creating the
        # connection.
        assert conn._connect.call_count == 1

    @patch(
        "streamlit.connections.snowflake_connection.SnowflakeConnection._connect",
        MagicMock(),
    )
    def test_retry_fails_fast_for_general_snowflake_errors(self):
        from snowflake.connector.errors import Error as SnowflakeError

        mock_cursor = MagicMock()
        mock_cursor.fetch_pandas_all = MagicMock(
            side_effect=SnowflakeError("oh noes :(")
        )

        conn = SnowflakeConnection("my_snowflake_connection")
        conn._instance.cursor.return_value = mock_cursor

        with pytest.raises(SnowflakeError):
            conn.query("SELECT 1;")

        # conn._connect should have just been called once when first creating the
        # connection.
        assert conn._connect.call_count == 1

    @patch(
        "streamlit.connections.snowflake_connection.SnowflakeConnection._connect",
        MagicMock(),
    )
    def test_retry_fails_fast_for_other_errors(self):
        mock_cursor = MagicMock()
        mock_cursor.fetch_pandas_all = MagicMock(side_effect=Exception("oh noes :("))

        conn = SnowflakeConnection("my_snowflake_connection")
        conn._instance.cursor.return_value = mock_cursor

        with pytest.raises(Exception):  # noqa: B017
            conn.query("SELECT 1;")

        # conn._connect should have just been called once when first creating the
        # connection.
        assert conn._connect.call_count == 1


================================================
File: /lib/tests/streamlit/connections/snowpark_connection_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import threading
import unittest
from unittest.mock import MagicMock, PropertyMock, patch

import pytest

import streamlit as st
from streamlit.connections import SnowparkConnection
from streamlit.errors import StreamlitAPIException
from streamlit.runtime.scriptrunner import add_script_run_ctx
from streamlit.runtime.secrets import AttrDict
from tests.testutil import create_mock_script_run_ctx


@pytest.mark.require_integration
class SnowparkConnectionTest(unittest.TestCase):
    def tearDown(self) -> None:
        st.cache_data.clear()

    @patch(
        "snowflake.snowpark.context.get_active_session",
        MagicMock(return_value="some active session"),
    )
    @patch(
        "streamlit.connections.snowpark_connection.running_in_sis",
        MagicMock(return_value=True),
    )
    def test_uses_active_session_if_in_sis(self):
        conn = SnowparkConnection("my_snowpark_connection")
        assert conn._instance == "some active session"

    @patch(
        "streamlit.connections.snowpark_connection.load_from_snowsql_config_file",
        MagicMock(
            return_value={"account": "some_val_1", "password": "i get overwritten"}
        ),
    )
    @patch(
        "streamlit.connections.snowpark_connection.SnowparkConnection._secrets",
        PropertyMock(
            return_value=AttrDict(
                {"user": "some_val_2", "some_key": "i get overwritten"}
            )
        ),
    )
    @patch("snowflake.snowpark.session.Session")
    def test_merges_params_from_all_config_sources(self, patched_session):
        SnowparkConnection(
            "my_snowpark_connection", some_key="some_val_3", password="hunter2"
        )

        patched_session.builder.configs.assert_called_with(
            {
                "account": "some_val_1",
                "user": "some_val_2",
                "some_key": "some_val_3",
                "password": "hunter2",
            }
        )

    def test_error_if_no_conn_params(self):
        with pytest.raises(StreamlitAPIException) as e:
            SnowparkConnection("my_snowpark_connection")
        assert "Missing Snowpark connection configuration." in str(e.value)

    def test_error_if_missing_required_conn_params(self):
        with pytest.raises(StreamlitAPIException) as e:
            SnowparkConnection("my_snowpark_connection", user="my_user")
        assert "Missing Snowpark connection param: account" == str(e.value)

    @patch(
        "streamlit.connections.snowpark_connection.SnowparkConnection._connect",
        MagicMock(),
    )
    def test_query_caches_value(self):
        # Caching functions rely on an active script run ctx
        add_script_run_ctx(threading.current_thread(), create_mock_script_run_ctx())

        mock_sql_return = MagicMock()
        mock_sql_return.to_pandas = MagicMock(return_value="i am a dataframe")

        conn = SnowparkConnection("my_snowpark_connection")
        conn._instance.sql.return_value = mock_sql_return

        assert conn.query("SELECT 1;") == "i am a dataframe"
        assert conn.query("SELECT 1;") == "i am a dataframe"
        conn._instance.sql.assert_called_once()

    @patch(
        "streamlit.connections.snowpark_connection.SnowparkConnection._connect",
        MagicMock(),
    )
    def test_does_not_reset_cache_when_ttl_changes(self):
        # Caching functions rely on an active script run ctx
        add_script_run_ctx(threading.current_thread(), create_mock_script_run_ctx())

        mock_sql_return = MagicMock()
        mock_sql_return.to_pandas = MagicMock(return_value="i am a dataframe")
        conn = SnowparkConnection("my_snowpark_connection")
        conn._instance.sql.return_value = mock_sql_return

        conn.query("SELECT 1;", ttl=10)
        conn.query("SELECT 2;", ttl=20)
        conn.query("SELECT 1;", ttl=10)
        conn.query("SELECT 2;", ttl=20)

        assert conn._instance.sql.call_count == 2

    @patch(
        "streamlit.connections.snowpark_connection.SnowparkConnection._connect",
        MagicMock(),
    )
    def test_scopes_caches_by_connection_name(self):
        # Caching functions rely on an active script run ctx
        add_script_run_ctx(threading.current_thread(), create_mock_script_run_ctx())
        mock_sql_return = MagicMock()
        mock_sql_return.to_pandas = MagicMock(return_value="i am a dataframe")

        conn1 = SnowparkConnection("my_snowpark_connection1")
        conn1._instance.sql.return_value = mock_sql_return
        conn2 = SnowparkConnection("my_snowpark_connection2")
        conn2._instance.sql.return_value = mock_sql_return

        conn1.query("SELECT 1;")
        conn1.query("SELECT 1;")
        conn2.query("SELECT 1;")
        conn2.query("SELECT 1;")

        assert conn1._instance.sql is conn2._instance.sql
        assert conn1._instance.sql.call_count == 2

    @patch(
        "streamlit.connections.snowpark_connection.SnowparkConnection._connect",
        MagicMock(),
    )
    def test_retry_behavior(self):
        from snowflake.snowpark.exceptions import SnowparkServerException

        mock_sql_return = MagicMock()
        mock_sql_return.to_pandas = MagicMock(
            side_effect=SnowparkServerException("oh noes :(")
        )

        conn = SnowparkConnection("my_snowpark_connection")
        conn._instance.sql.return_value = mock_sql_return

        with patch.object(conn, "reset", wraps=conn.reset) as wrapped_reset:
            with pytest.raises(SnowparkServerException):
                conn.query("SELECT 1;")

            # Our connection should have been reset after each failed attempt to call
            # query.
            assert wrapped_reset.call_count == 3

        # conn._connect should have been called three times: once in the initial
        # connection, then once each after the second and third attempts to call
        # query.
        assert conn._connect.call_count == 3

    @patch(
        "streamlit.connections.snowpark_connection.SnowparkConnection._connect",
        MagicMock(),
    )
    def test_retry_fails_fast_for_most_errors(self):
        mock_sql_return = MagicMock()
        mock_sql_return.to_pandas = MagicMock(side_effect=Exception("oh noes :("))

        conn = SnowparkConnection("my_snowpark_connection")
        conn._instance.sql.return_value = mock_sql_return

        with pytest.raises(Exception):  # noqa: B017
            conn.query("SELECT 1;")

        # conn._connect should have just been called once when first creating the
        # connection.
        assert conn._connect.call_count == 1


================================================
File: /lib/tests/streamlit/connections/sql_connection_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import threading
import unittest
from copy import deepcopy
from unittest.mock import MagicMock, PropertyMock, patch

import pytest
from parameterized import parameterized

import streamlit as st
from streamlit.connections import SQLConnection
from streamlit.errors import StreamlitAPIException
from streamlit.runtime.scriptrunner import add_script_run_ctx
from streamlit.runtime.secrets import AttrDict
from tests.testutil import create_mock_script_run_ctx

DB_SECRETS = {
    "dialect": "postgres",
    "driver": "psycopg2",
    "username": "AzureDiamond",
    "password": "hunter2",
    "host": "localhost",
    "port": "5432",
    "database": "postgres",
}


@pytest.mark.require_integration
class SQLConnectionTest(unittest.TestCase):
    def tearDown(self) -> None:
        st.cache_data.clear()

    @patch("sqlalchemy.engine.make_url", MagicMock(return_value="some_sql_conn_string"))
    @patch(
        "streamlit.connections.sql_connection.SQLConnection._secrets",
        PropertyMock(return_value=AttrDict({"url": "some_sql_conn_string"})),
    )
    @patch("sqlalchemy.create_engine")
    def test_url_set_explicitly_in_secrets(self, patched_create_engine):
        SQLConnection("my_sql_connection")

        patched_create_engine.assert_called_once_with("some_sql_conn_string")

    @patch(
        "streamlit.connections.sql_connection.SQLConnection._secrets",
        PropertyMock(return_value=AttrDict(DB_SECRETS)),
    )
    @patch("sqlalchemy.create_engine")
    def test_url_constructed_from_secrets_params(self, patched_create_engine):
        SQLConnection("my_sql_connection")

        patched_create_engine.assert_called_once()
        args, _ = patched_create_engine.call_args_list[0]
        assert (
            str(args[0])
            == "postgres+psycopg2://AzureDiamond:hunter2@localhost:5432/postgres"
        )

    @patch(
        "streamlit.connections.sql_connection.SQLConnection._secrets",
        PropertyMock(return_value=AttrDict(DB_SECRETS)),
    )
    @patch("sqlalchemy.create_engine")
    def test_kwargs_overwrite_secrets_values(self, patched_create_engine):
        SQLConnection(
            "my_sql_connection",
            port=2345,
            username="DnomaidEruza",
            query={"charset": "utf8mb4"},
        )

        patched_create_engine.assert_called_once()
        args, _ = patched_create_engine.call_args_list[0]
        assert (
            str(args[0])
            == "postgres+psycopg2://DnomaidEruza:hunter2@localhost:2345/postgres?charset=utf8mb4"
        )

    def test_error_if_no_config(self):
        with patch(
            "streamlit.connections.sql_connection.SQLConnection._secrets",
            PropertyMock(return_value=AttrDict({})),
        ):
            with pytest.raises(StreamlitAPIException) as e:
                SQLConnection("my_sql_connection")

            assert "Missing SQL DB connection configuration." in str(e.value)

    @parameterized.expand([("dialect",), ("username",), ("host",)])
    def test_error_if_missing_required_param(self, missing_param):
        secrets = deepcopy(DB_SECRETS)
        del secrets[missing_param]

        with patch(
            "streamlit.connections.sql_connection.SQLConnection._secrets",
            PropertyMock(return_value=AttrDict(secrets)),
        ):
            with pytest.raises(StreamlitAPIException) as e:
                SQLConnection("my_sql_connection")

            assert str(e.value) == f"Missing SQL DB connection param: {missing_param}"

    @patch(
        "streamlit.connections.sql_connection.SQLConnection._secrets",
        PropertyMock(
            return_value=AttrDict(
                {
                    **DB_SECRETS,
                    "create_engine_kwargs": {"foo": "bar", "baz": "i get overwritten"},
                }
            )
        ),
    )
    @patch("sqlalchemy.create_engine")
    def test_create_engine_kwargs_secrets_section(self, patched_create_engine):
        SQLConnection("my_sql_connection", baz="qux")

        patched_create_engine.assert_called_once()
        _, kwargs = patched_create_engine.call_args_list[0]

        assert kwargs == {"foo": "bar", "baz": "qux"}

    @patch("streamlit.connections.sql_connection.SQLConnection._connect", MagicMock())
    @patch("pandas.read_sql")
    def test_query_caches_value(self, patched_read_sql):
        # Caching functions rely on an active script run ctx
        add_script_run_ctx(threading.current_thread(), create_mock_script_run_ctx())
        patched_read_sql.return_value = "i am a dataframe"

        conn = SQLConnection("my_sql_connection")

        assert conn.query("SELECT 1;") == "i am a dataframe"
        assert conn.query("SELECT 1;") == "i am a dataframe"
        patched_read_sql.assert_called_once()

    @patch("streamlit.connections.sql_connection.SQLConnection._connect", MagicMock())
    @patch("pandas.read_sql")
    def test_does_not_reset_cache_when_ttl_changes(self, patched_read_sql):
        # Caching functions rely on an active script run ctx
        add_script_run_ctx(threading.current_thread(), create_mock_script_run_ctx())
        patched_read_sql.return_value = "i am a dataframe"

        conn = SQLConnection("my_sql_connection")

        conn.query("SELECT 1;", ttl=10)
        conn.query("SELECT 2;", ttl=20)
        conn.query("SELECT 1;", ttl=10)
        conn.query("SELECT 2;", ttl=20)

        assert patched_read_sql.call_count == 2

    @patch("streamlit.connections.sql_connection.SQLConnection._connect", MagicMock())
    @patch("pandas.read_sql")
    def test_scopes_caches_by_connection_name(self, patched_read_sql):
        # Caching functions rely on an active script run ctx
        add_script_run_ctx(threading.current_thread(), create_mock_script_run_ctx())
        patched_read_sql.return_value = "i am a dataframe"

        conn1 = SQLConnection("my_sql_connection1")
        conn2 = SQLConnection("my_sql_connection2")

        conn1.query("SELECT 1;")
        conn1.query("SELECT 1;")
        conn2.query("SELECT 1;")
        conn2.query("SELECT 1;")

        assert patched_read_sql.call_count == 2

    @patch("streamlit.connections.sql_connection.SQLConnection._connect", MagicMock())
    @patch("pandas.read_sql")
    def test_retry_behavior(self, patched_read_sql):
        from sqlalchemy.exc import DatabaseError, InternalError, OperationalError

        for error_class in [DatabaseError, InternalError, OperationalError]:
            patched_read_sql.side_effect = error_class("kaboom", params=None, orig=None)

            conn = SQLConnection("my_sql_connection")

            with patch.object(conn, "reset", wraps=conn.reset) as wrapped_reset:
                with pytest.raises(error_class):
                    conn.query("SELECT 1;")

                # Our connection should have been reset after each failed attempt to call
                # query.
                assert wrapped_reset.call_count == 3

            # conn._connect should have been called three times: once in the initial
            # connection, then once each after the second and third attempts to call
            # query.
            assert conn._connect.call_count == 3
            conn._connect.reset_mock()

    @patch("streamlit.connections.sql_connection.SQLConnection._connect", MagicMock())
    @patch("pandas.read_sql")
    def test_retry_behavior_fails_fast_for_most_errors(self, patched_read_sql):
        patched_read_sql.side_effect = Exception("kaboom")

        conn = SQLConnection("my_sql_connection")

        with pytest.raises(Exception):  # noqa: B017
            conn.query("SELECT 1;")

        # conn._connect should have just been called once when first creating the
        # connection.
        assert conn._connect.call_count == 1
        conn._connect.reset_mock()


================================================
File: /lib/tests/streamlit/connections/util_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import unittest
from unittest.mock import MagicMock, mock_open, patch

import pytest

from streamlit.connections.util import (
    extract_from_dict,
    load_from_snowsql_config_file,
    running_in_sis,
)


class ConnectionUtilTest(unittest.TestCase):
    def test_extract_from_dict(self):
        d = {"k1": "v1", "k2": "v2", "k3": "v3", "k4": "v4"}

        extracted = extract_from_dict(
            ["k1", "k2", "nonexistent_key"],
            d,
        )

        assert extracted == {"k1": "v1", "k2": "v2"}
        assert d == {"k3": "v3", "k4": "v4"}

    def test_not_running_in_sis(self):
        assert not running_in_sis()

    @pytest.mark.require_integration
    @patch(
        "snowflake.snowpark._internal.utils.is_in_stored_procedure",
        MagicMock(return_value=True),
    )
    def test_running_in_sis(self):
        assert running_in_sis()

    @pytest.mark.require_integration
    @patch(
        "snowflake.snowpark._internal.utils.is_in_stored_procedure",
        MagicMock(side_effect=ModuleNotFoundError("oh no")),
    )
    def test_running_in_sis_module_not_found_error(self):
        assert not running_in_sis()

    def test_load_from_snowsql_config_file_no_file(self):
        assert load_from_snowsql_config_file("my_snowpark_connection") == {}

    @patch(
        "streamlit.connections.util.os.path.exists",
        MagicMock(return_value=True),
    )
    def test_load_from_snowsql_config_file_no_section(self):
        with patch("builtins.open", new_callable=mock_open, read_data=""):
            assert load_from_snowsql_config_file("my_snowpark_connection") == {}

    @patch(
        "streamlit.connections.util.os.path.exists",
        MagicMock(return_value=True),
    )
    def test_load_from_snowsql_config_file_named_section(self):
        config_data = """
[connections.my_snowpark_connection]
accountname = "hello"
dbname = notPostgres

[connections]
accountname = "i get overwritten"
schemaname = public
"""
        with patch("builtins.open", new_callable=mock_open, read_data=config_data):
            assert load_from_snowsql_config_file("my_snowpark_connection") == {
                "account": "hello",
                "database": "notPostgres",
            }

    @patch(
        "streamlit.connections.util.os.path.exists",
        MagicMock(return_value=True),
    )
    def test_load_from_snowsql_config_file_default_section(self):
        config_data = """
[connections]
accountname = "not overwritten"
schemaname = public
"""
        with patch("builtins.open", new_callable=mock_open, read_data=config_data):
            assert load_from_snowsql_config_file("my_snowpark_connection") == {
                "account": "not overwritten",
                "schema": "public",
            }


================================================
File: /lib/tests/streamlit/data_mocks/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/data_mocks/dask_mocks.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import pandas as pd


class DataFrame:
    """This is dummy DataFrame class, which imitates dask.dataframe.core.DataFrame class
    for testing purposes. We use this to make sure that our code does a special handling
    if it detects a Dask DataFrame.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "dask.dataframe.core"

    def __init__(self, data: pd.DataFrame):
        self._data: pd.DataFrame = data

    def head(self, n: int, compute: bool) -> pd.DataFrame:
        """Returns the top n element of a mock version of Dask DataFrame."""
        return self._data.head(n)


class Series:
    """This is dummy Series class, which imitates dask.dataframe.core.Series class
    for testing purposes. We use this to make sure that our code does a special handling
    if it detects a Dask Series.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "dask.dataframe.core"

    def __init__(self, data: pd.Series):
        self._data: pd.Series = data

    def head(self, n: int, compute: bool) -> pd.Series:
        """Returns the top n element of a mock version of Dask Series."""
        return self._data.head(n)


class Index:
    """This is dummy Index class, which imitates dask.dataframe.core.Index class
    for testing purposes. We use this to make sure that our code does a special handling
    if it detects a Dask Index.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "dask.dataframe.core"

    def __init__(self, data: pd.Index):
        self._data: pd.Index = data

    def head(self, n: int, compute: bool) -> pd.Index:
        """Returns the top n element of a mock version of Dask Index."""
        return self._data[:n]


================================================
File: /lib/tests/streamlit/data_mocks/modin_mocks.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import pandas as pd


class DataFrame:
    """This is dummy DataFrame class, which imitates modin.pandas.dataframe.DataFrame class
    for testing purposes. We use this to make sure that our code does a special handling
    if it detects a modin dataframe.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "modin.pandas.dataframe"

    def __init__(self, data: pd.DataFrame):
        self._data: pd.DataFrame = data

    def _to_pandas(self) -> pd.DataFrame:
        return self._data

    def head(self, n: int) -> DataFrame:
        """Returns the top n element of a mock version of Modin DataFrame."""
        return DataFrame(self._data.head(n))


class Series:
    """This is dummy Series class, which imitates modin.pandas.series.Series class
    for testing purposes. We use this to make sure that our code does a special handling
    if it detects a modin Series.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "modin.pandas.series"

    def __init__(self, data: pd.Series):
        self._data: pd.Series = data

    def _to_pandas(self) -> pd.Series:
        return self._data

    def head(self, n: int) -> Series:
        """Returns the top n element of a mock version of Modin Series."""
        return Series(self._data.head(n))


================================================
File: /lib/tests/streamlit/data_mocks/pyspark_connect_mocks.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import pandas as pd


class DataFrame:
    """This is dummy DataFrame class, which imitates pyspark.sql.connect.dataframe.DataFrame class
    for testing purposes. We use this to make sure that our code does a special handling
    if it detects a pyspark connect dataframe.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "pyspark.sql.connect.dataframe"

    def __init__(self, data: pd.DataFrame):
        self._data: pd.DataFrame = data

    def limit(self, n: int) -> DataFrame:
        """Returns the top n element of a mock version of pyspark dataframe"""
        return DataFrame(self._data.head(n))

    def toPandas(self) -> pd.DataFrame:
        return self._data


================================================
File: /lib/tests/streamlit/data_mocks/pyspark_mocks.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import pandas as pd


class DataFrame:
    """This is dummy DataFrame class, which imitates pyspark.sql.dataframe.DataFrame class
    for testing purposes. We use this to make sure that our code does a special handling
    if it detects a pyspark dataframe.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "pyspark.sql.dataframe"

    def __init__(self, data: pd.DataFrame):
        self._data: pd.DataFrame = data

    def limit(self, n: int) -> DataFrame:
        """Returns the top n element of a mock version of pyspark dataframe"""
        return DataFrame(self._data.head(n))

    def toPandas(self) -> pd.DataFrame:
        return self._data


================================================
File: /lib/tests/streamlit/data_mocks/ray_mocks.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import pandas as pd


class Dataset:
    """This is dummy Dataset class, which imitates ray.data.dataset.Dataset class
    for testing purposes. We use this to make sure that our code does a special handling
    if it detects a Ray Datasets.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "ray.data.dataset"

    def __init__(self, data: pd.DataFrame):
        self._data: pd.DataFrame = data

    def to_pandas(self) -> pd.DataFrame:
        return self._data

    def limit(self, n: int) -> Dataset:
        """Returns the top n element of a mock version of Ray Dataset."""
        return Dataset(self._data.head(n))


class MaterializedDataset:
    """This is dummy MaterializedDataset class, which imitates
    ray.data.dataset.MaterializedDataset class for testing purposes. We use this to
    make sure that our code does a special handling if it detects a
    Ray MaterializedDataset.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "ray.data.dataset"

    def __init__(self, data: pd.DataFrame):
        self._data: pd.DataFrame = data

    def to_pandas(self) -> pd.DataFrame:
        return self._data

    def limit(self, n: int) -> MaterializedDataset:
        """Returns the top n element of a mock version of Ray MaterializedDataset."""
        return MaterializedDataset(self._data.head(n))


================================================
File: /lib/tests/streamlit/data_mocks/snowpandas_mocks.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING

if TYPE_CHECKING:
    import pandas as pd


class DataFrame:
    """This is dummy DataFrame class, which imitates
    snowflake.snowpark.modin.pandas.dataframe.DataFrame class for testing purposes.
    We use this to make sure that our code does a special handling
    if it detects a Snowpark Pandas Dataframe.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "snowflake.snowpark.modin.pandas.dataframe"

    def __init__(self, data: pd.DataFrame):
        self._data: pd.DataFrame = data

    def to_pandas(self) -> pd.DataFrame:
        return self._data

    def head(self, n: int) -> DataFrame:
        """Returns the top n element of a mock version of Snowpark Pandas DataFrame"""
        return DataFrame(self[:n])

    def __getitem__(self, key: slice | int) -> DataFrame:
        # Allow slicing and integer indexing
        return DataFrame(self._data[key])


class Series:
    """This is dummy Series class, which imitates
    snowflake.snowpark.modin.pandas.series.Series class for testing purposes.
    We use this to make sure that our code does a special handling
    if it detects a Snowpark Pandas Series.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "snowflake.snowpark.modin.pandas.series"

    def __init__(self, data: pd.Series):
        self._data: pd.Series = data

    def to_pandas(self) -> pd.Series:
        return self._data

    def head(self, n: int) -> Series:
        """Returns the top n element of a mock version of Snowpark Pandas Series"""
        return Series(self[:n])

    def __getitem__(self, key: slice | int) -> Series:
        # Allow slicing and integer indexing
        return Series(self._data[key])


class Index:
    """This is dummy Index class, which imitates
    snowflake.snowpark.modin.plugin.extensions.index.Index class for testing purposes.
    We use this to make sure that our code does a special handling
    if it detects a Snowpark Pandas Index.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "snowflake.snowpark.modin.plugin.extensions.index"

    def __init__(self, data: pd.Index):
        self._data: pd.Index = data

    def to_pandas(self) -> pd.Index:
        return self._data

    def head(self, n: int) -> Index:
        """Returns the top n element of a mock version of Snowpark Pandas Series"""
        return Index(self[:n])

    def __getitem__(self, key: slice | int) -> Index:
        # Allow slicing and integer indexing
        return Index(self._data[key])


================================================
File: /lib/tests/streamlit/data_mocks/snowpark_mocks.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, Any

if TYPE_CHECKING:
    import pandas as pd


class DataFrame:
    """This is dummy DataFrame class, which imitates
    nowflake.snowpark.dataframe.DataFrame class for testing purposes.
    We use this to make sure that our code does a special handling
    if it detects a Snowpark Dataframe.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "snowflake.snowpark.dataframe"

    def __init__(self, data: pd.DataFrame):
        self._data: pd.DataFrame = data

    def to_pandas(self) -> pd.DataFrame:
        return self._data

    def limit(self, n: int) -> DataFrame:
        """Returns the top n element of a mock version of Snowpark Dataframe"""
        return DataFrame(self._data.head(n))


class Table:
    """This is dummy Table class, which imitates
    nowflake.snowpark.table.Table class for testing purposes.
    We use this to make sure that our code does a special handling
    if it detects a Snowpark Table.

    This allows testing of the functionality without having the library installed,
    but it won't capture changes in the API of the library. This requires
    integration tests.
    """

    __module__ = "snowflake.snowpark.table"

    def __init__(self, data: pd.Series):
        self._data: pd.Series = data

    def to_pandas(self) -> pd.DataFrame:
        return self._data

    def limit(self, n: int) -> Table:
        """Returns the top n element of a mock version of Snowpark Table"""
        return Table(self._data.head(n))


class Row:
    """This is dummy Row class,
    which imitates snowflake.snowpark.row.Row class
    for testing purposes."""

    __module__ = "snowflake.snowpark.row"

    def __init__(self, row_data: dict[str, Any]):
        self._row_data: dict[str, Any] = row_data

    def as_dict(self) -> dict[str, Any]:
        return self._row_data


================================================
File: /lib/tests/streamlit/echo_test_data/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Test data for echo_test.py"""


================================================
File: /lib/tests/streamlit/echo_test_data/multiline_param_echo.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

with st.echo(
    code_location="above",
):
    a = 123

b = 456


================================================
File: /lib/tests/streamlit/echo_test_data/root_level_echo.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

with st.echo():
    a = 123

b = 456


================================================
File: /lib/tests/streamlit/elements/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /lib/tests/streamlit/elements/alert_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from parameterized import parameterized

import streamlit as st
from streamlit.errors import StreamlitAPIException
from streamlit.proto.Alert_pb2 import Alert
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class AlertAPITest(DeltaGeneratorTestCase):
    """Test ability to marshall Alert proto."""

    @parameterized.expand([(st.error,), (st.warning,), (st.info,), (st.success,)])
    def test_st_alert_exceptions(self, alert_func):
        """Test that alert functions throw an exception when a non-emoji is given as an icon."""
        with self.assertRaises(StreamlitAPIException):
            alert_func("some alert", icon="hello world")


class StErrorAPITest(DeltaGeneratorTestCase):
    """Test ability to marshall Alert proto."""

    def test_st_error(self):
        """Test st.error."""
        st.error("some error")

        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.alert.body, "some error")
        self.assertEqual(el.alert.format, Alert.ERROR)

    def test_st_error_with_icon(self):
        """Test st.error with icon."""
        st.error("some error", icon="ðŸ˜±")

        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.alert.body, "some error")
        self.assertEqual(el.alert.icon, "ðŸ˜±")
        self.assertEqual(el.alert.format, Alert.ERROR)


class StInfoAPITest(DeltaGeneratorTestCase):
    """Test ability to marshall Alert proto."""

    def test_st_info(self):
        """Test st.info."""
        st.info("some info")

        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.alert.body, "some info")
        self.assertEqual(el.alert.format, Alert.INFO)

    def test_st_info_with_icon(self):
        """Test st.info with icon."""
        st.info("some info", icon="ðŸ‘‰ðŸ»")

        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.alert.body, "some info")
        self.assertEqual(el.alert.icon, "ðŸ‘‰ðŸ»")
        self.assertEqual(el.alert.format, Alert.INFO)


class StSuccessAPITest(DeltaGeneratorTestCase):
    """Test ability to marshall Alert proto."""

    def test_st_success(self):
        """Test st.success."""
        st.success("some success")

        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.alert.body, "some success")
        self.assertEqual(el.alert.format, Alert.SUCCESS)

    def test_st_success_with_icon(self):
        """Test st.success with icon."""
        st.success("some success", icon="âœ…")

        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.alert.body, "some success")
        self.assertEqual(el.alert.icon, "âœ…")
        self.assertEqual(el.alert.format, Alert.SUCCESS)


class StWarningAPITest(DeltaGeneratorTestCase):
    """Test ability to marshall Alert proto."""

    def test_st_warning(self):
        """Test st.warning."""
        st.warning("some warning")

        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.alert.body, "some warning")
        self.assertEqual(el.alert.format, Alert.WARNING)

    def test_st_warning_with_icon(self):
        """Test st.warning with icon."""
        st.warning("some warning", icon="âš ï¸")

        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.alert.body, "some warning")
        self.assertEqual(el.alert.icon, "âš ï¸")
        self.assertEqual(el.alert.format, Alert.WARNING)


================================================
File: /lib/tests/streamlit/elements/arrow_add_rows_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Unit test of dg.add_rows()."""

import pandas as pd
from parameterized import parameterized

import streamlit as st
from streamlit.dataframe_util import convert_arrow_bytes_to_pandas_df
from tests.delta_generator_test_case import DeltaGeneratorTestCase

DATAFRAME = pd.DataFrame({"a": [10], "b": [20], "c": [30]})
NEW_ROWS = pd.DataFrame({"a": [11, 12, 13], "b": [21, 22, 23], "c": [31, 32, 33]})

DATAFRAME2 = pd.DataFrame({"a": [10], "b": [20], "c": [30], "d": [40]})
NEW_ROWS2 = pd.DataFrame(
    {"a": [11, 12, 13], "b": [21, 22, 23], "c": [31, 32, 33], "d": [41, 42, 43]}
)

ST_CHART_ARGS = [
    st.area_chart,
    st.bar_chart,
    st.line_chart,
    st.scatter_chart,
]


class DeltaGeneratorAddRowsTest(DeltaGeneratorTestCase):
    """Test dg.add_rows."""

    @parameterized.expand(ST_CHART_ARGS)
    def test_charts_with_implict_x_and_y(self, chart_command):
        expected = pd.DataFrame(
            {
                "index--p5bJXXpQgvPz6yvQMFiy": [1, 2, 3, 1, 2, 3, 1, 2, 3],
                "color--p5bJXXpQgvPz6yvQMFiy": [
                    "a",
                    "a",
                    "a",
                    "b",
                    "b",
                    "b",
                    "c",
                    "c",
                    "c",
                ],
                "value--p5bJXXpQgvPz6yvQMFiy": [11, 12, 13, 21, 22, 23, 31, 32, 33],
            }
        )

        element = chart_command(DATAFRAME)
        element.add_rows(NEW_ROWS)

        proto = convert_arrow_bytes_to_pandas_df(
            self.get_delta_from_queue().arrow_add_rows.data.data
        )

        pd.testing.assert_frame_equal(proto, expected)

    @parameterized.expand(ST_CHART_ARGS)
    def test_charts_with_explicit_x_and_y(self, chart_command):
        expected = pd.DataFrame(
            {
                "b": [21, 22, 23],
                "c": [31, 32, 33],
            }
        )
        expected.index = pd.RangeIndex(1, 4)

        element = chart_command(DATAFRAME, x="b", y="c")
        element.add_rows(NEW_ROWS)

        proto = convert_arrow_bytes_to_pandas_df(
            self.get_delta_from_queue().arrow_add_rows.data.data
        )

        pd.testing.assert_frame_equal(proto, expected)

    @parameterized.expand(ST_CHART_ARGS)
    def test_charts_with_implict_x_and_explicit_y(self, chart_command):
        expected = pd.DataFrame(
            {
                "index--p5bJXXpQgvPz6yvQMFiy": [1, 2, 3],
                "b": [21, 22, 23],
            }
        )

        element = chart_command(DATAFRAME, y="b")
        element.add_rows(NEW_ROWS)

        proto = convert_arrow_bytes_to_pandas_df(
            self.get_delta_from_queue().arrow_add_rows.data.data
        )

        pd.testing.assert_frame_equal(proto, expected)

    @parameterized.expand(ST_CHART_ARGS)
    def test_charts_with_explicit_x_and_implicit_y(self, chart_command):
        expected = pd.DataFrame(
            {
                "b": [21, 22, 23, 21, 22, 23],
                "color--p5bJXXpQgvPz6yvQMFiy": ["a", "a", "a", "c", "c", "c"],
                "value--p5bJXXpQgvPz6yvQMFiy": [11, 12, 13, 31, 32, 33],
            }
        )

        element = chart_command(DATAFRAME, x="b")
        element.add_rows(NEW_ROWS)

        proto = convert_arrow_bytes_to_pandas_df(
            self.get_delta_from_queue().arrow_add_rows.data.data
        )

        pd.testing.assert_frame_equal(proto, expected)

    @parameterized.expand(ST_CHART_ARGS)
    def test_charts_with_explicit_x_and_y_sequence(self, chart_command):
        expected = pd.DataFrame(
            {
                "b": [21, 22, 23, 21, 22, 23],
                "color--p5bJXXpQgvPz6yvQMFiy": ["a", "a", "a", "c", "c", "c"],
                "value--p5bJXXpQgvPz6yvQMFiy": [11, 12, 13, 31, 32, 33],
            }
        )

        element = chart_command(DATAFRAME, x="b", y=["a", "c"])
        element.add_rows(NEW_ROWS)

        proto = convert_arrow_bytes_to_pandas_df(
            self.get_delta_from_queue().arrow_add_rows.data.data
        )

        pd.testing.assert_frame_equal(proto, expected)

    @parameterized.expand(ST_CHART_ARGS)
    def test_charts_with_explicit_x_and_y_sequence_and_static_color(
        self, chart_command
    ):
        expected = pd.DataFrame(
            {
                "b": [21, 22, 23, 21, 22, 23],
                "color--p5bJXXpQgvPz6yvQMFiy": ["a", "a", "a", "c", "c", "c"],
                "value--p5bJXXpQgvPz6yvQMFiy": [11, 12, 13, 31, 32, 33],
            }
        )

        element = chart_command(DATAFRAME, x="b", y=["a", "c"], color=["#f00", "#0f0"])
        element.add_rows(NEW_ROWS)

        proto = convert_arrow_bytes_to_pandas_df(
            self.get_delta_from_queue().arrow_add_rows.data.data
        )

        pd.testing.assert_frame_equal(proto, expected)

    def test_charts_with_explicit_x_and_y_sequence_and_size_set(self):
        expected = pd.DataFrame(
            {
                "b": [21, 22, 23, 21, 22, 23],
                "d": [41, 42, 43, 41, 42, 43],
                "color--p5bJXXpQgvPz6yvQMFiy": ["a", "a", "a", "c", "c", "c"],
                "value--p5bJXXpQgvPz6yvQMFiy": [11, 12, 13, 31, 32, 33],
            }
        )

        element = st.scatter_chart(DATAFRAME2, x="b", y=["a", "c"], size="d")
        element.add_rows(NEW_ROWS2)

        proto = convert_arrow_bytes_to_pandas_df(
            self.get_delta_from_queue().arrow_add_rows.data.data
        )

        pd.testing.assert_frame_equal(proto, expected)

    @parameterized.expand(ST_CHART_ARGS)
    def test_charts_with_fewer_args_than_cols(self, chart_command):
        expected = pd.DataFrame(
            {
                "b": [21, 22, 23],
                "a": [11, 12, 13],
            }
        )
        expected.index = pd.RangeIndex(start=1, stop=4, step=1)

        element = chart_command(DATAFRAME, x="b", y="a")
        element.add_rows(NEW_ROWS)

        proto = convert_arrow_bytes_to_pandas_df(
            self.get_delta_from_queue().arrow_add_rows.data.data
        )

        pd.testing.assert_frame_equal(proto, expected)


================================================
File: /lib/tests/streamlit/elements/arrow_dataframe_dimensions_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Arrow Dataframe dimension parameters test."""

import pandas as pd

import streamlit as st
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class ArrowDataFrameDimensionsTest(DeltaGeneratorTestCase):
    """Test the metadata in the serialized delta message for the different
    dimension specifier options.
    """

    def test_no_dimensions(self):
        """When no dimension parameters are passed"""
        self._do_test(lambda fn, df: fn(df), 0, 0)

    def test_with_dimensions(self):
        """When dimension parameter are passed"""
        self._do_test(lambda fn, df: fn(df, 10, 20), 10, 20)

    def test_with_height_only(self):
        """When only height parameter is passed"""
        self._do_test(lambda fn, df: fn(df, height=20), 0, 20)

    def test_with_width_only(self):
        """When only width parameter is passed"""
        self._do_test(lambda fn, df: fn(df, width=20), 20, 0)

    def _do_test(self, fn, expectedWidth, expectedHeight):
        df = pd.DataFrame({"A": [1, 2, 3, 4, 5]})

        fn(st.dataframe, df)
        arrow_data_frame = self.get_delta_from_queue().new_element.arrow_data_frame
        self.assertEqual(arrow_data_frame.width, expectedWidth)
        self.assertEqual(arrow_data_frame.height, expectedHeight)

    def _get_metadata(self):
        """Returns the metadata for the most recent element in the
        DeltaGenerator queue
        """
        return self.forward_msg_queue._queue[-1].metadata


================================================
File: /lib/tests/streamlit/elements/arrow_dataframe_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Arrow DataFrame tests."""

import json
from typing import Any
from unittest.mock import MagicMock, patch

import numpy as np
import pandas as pd
from pandas.io.formats.style_render import StylerRenderer as Styler
from parameterized import parameterized

import streamlit as st
from streamlit.dataframe_util import (
    convert_arrow_bytes_to_pandas_df,
)
from streamlit.elements.lib.column_config_utils import INDEX_IDENTIFIER
from streamlit.errors import StreamlitAPIException
from tests.delta_generator_test_case import DeltaGeneratorTestCase
from tests.streamlit.data_test_cases import SHARED_TEST_CASES, CaseMetadata


def mock_data_frame():
    return pd.DataFrame(
        index=[[0, 1], ["i1", "i2"]],
        columns=[[2, 3, 4], ["c1", "c2", "c3"]],
        data=np.arange(0, 6, 1).reshape(2, 3),
    )


class ArrowDataFrameProtoTest(DeltaGeneratorTestCase):
    """Test ability to marshall arrow protos."""

    def test_dataframe_data(self):
        df = mock_data_frame()
        st.dataframe(df)

        proto = self.get_delta_from_queue().new_element.arrow_data_frame
        pd.testing.assert_frame_equal(convert_arrow_bytes_to_pandas_df(proto.data), df)

    def test_column_order_parameter(self):
        """Test that it can be called with column_order."""
        st.dataframe(pd.DataFrame(), column_order=["a", "b"])

        proto = self.get_delta_from_queue().new_element.arrow_data_frame
        self.assertEqual(proto.column_order, ["a", "b"])

    def test_empty_column_order_parameter(self):
        """Test that an empty column_order is correctly added."""
        st.dataframe(pd.DataFrame(), column_order=[])

        proto = self.get_delta_from_queue().new_element.arrow_data_frame
        self.assertEqual(proto.column_order, [])

    @parameterized.expand(SHARED_TEST_CASES)
    def test_with_compatible_data(
        self,
        name: str,
        input_data: Any,
        metadata: CaseMetadata,
    ):
        """Test that it can be called with compatible data."""
        st.dataframe(input_data)

        proto = self.get_delta_from_queue().new_element.arrow_data_frame
        reconstructed_df = convert_arrow_bytes_to_pandas_df(proto.data)
        self.assertEqual(reconstructed_df.shape[0], metadata.expected_rows)
        self.assertEqual(reconstructed_df.shape[1], metadata.expected_cols)

    def test_hide_index_true(self):
        """Test that it can be called with hide_index=True param."""
        data_df = pd.DataFrame(
            {
                "a": pd.Series([1, 2]),
                "b": pd.Series(["foo", "bar"]),
            }
        )

        st.dataframe(data_df, hide_index=True)

        proto = self.get_delta_from_queue().new_element.arrow_data_frame
        self.assertEqual(
            proto.columns,
            json.dumps({INDEX_IDENTIFIER: {"hidden": True}}),
        )

    def test_hide_index_false(self):
        """Test that it can be called with hide_index=False param."""
        data_df = pd.DataFrame(
            {
                "a": pd.Series([1, 2]),
                "b": pd.Series(["foo", "bar"]),
            }
        )

        st.dataframe(data_df, hide_index=False)

        proto = self.get_delta_from_queue().new_element.arrow_data_frame
        self.assertEqual(
            proto.columns,
            json.dumps({INDEX_IDENTIFIER: {"hidden": False}}),
        )

    def test_uuid(self):
        df = mock_data_frame()
        styler = df.style
        styler.set_uuid("FAKE_UUID")
        st.dataframe(styler)

        proto = self.get_delta_from_queue().new_element.arrow_data_frame
        self.assertEqual(proto.styler.uuid, "FAKE_UUID")

    def test_caption(self):
        df = mock_data_frame()
        styler = df.style
        styler.set_caption("FAKE_CAPTION")
        st.dataframe(styler)

        proto = self.get_delta_from_queue().new_element.arrow_data_frame
        self.assertEqual(proto.styler.caption, "FAKE_CAPTION")

    def test_cell_styles(self):
        df = mock_data_frame()
        styler = df.style
        # NOTE: If UUID is not set - a random UUID will be generated.
        styler.set_uuid("FAKE_UUID")
        styler.highlight_max(axis=None)
        st.dataframe(styler)

        proto = self.get_delta_from_queue().new_element.arrow_data_frame
        self.assertEqual(
            proto.styler.styles, "#T_FAKE_UUIDrow1_col2 { background-color: yellow }"
        )

    def test_display_values(self):
        df = pd.DataFrame(
            [[1, 2, 3], [4, 5, 6]],
        )
        styler = df.style.format("{:.2%}")
        st.dataframe(styler)

        expected = pd.DataFrame(
            [["100.00%", "200.00%", "300.00%"], ["400.00%", "500.00%", "600.00%"]],
        )

        proto = self.get_delta_from_queue().new_element.arrow_data_frame
        pd.testing.assert_frame_equal(
            convert_arrow_bytes_to_pandas_df(proto.styler.display_values), expected
        )

    def test_throw_exception_if_data_exceeds_styler_config(self):
        """Test that an exception is thrown if the dataframe exceeds the styler.render.max_elements config."""
        pd.set_option("styler.render.max_elements", 5000)
        # big example with default styler.render.max_elements
        df = pd.DataFrame(list(range(5001)))
        with self.assertRaises(StreamlitAPIException):
            st.dataframe(df.style.format("{:03d}"))
        pd.reset_option("styler.render.max_elements")

    @patch.object(Styler, "_translate")
    def test_styler_translate_gets_called(self, mock_styler_translate):
        """Tests that `styler._translate` is called with correct arguments."""
        df = mock_data_frame()
        styler = df.style.set_uuid("FAKE_UUID")

        st.dataframe(styler)
        mock_styler_translate.assert_called_once_with(False, False)

    def test_dataframe_uses_convert_anything_to_df(self):
        """Test that st.altair_chart uses convert_anything_to_df to convert input data."""
        df = pd.DataFrame([["A", "B", "C", "D"], [28, 55, 43, 91]], index=["a", "b"]).T

        with patch(
            "streamlit.dataframe_util.convert_anything_to_pandas_df"
        ) as convert_anything_to_df:
            convert_anything_to_df.return_value = df

            st.dataframe(df)
            convert_anything_to_df.assert_called_once()

    def test_dataframe_on_select_initial_returns(self):
        """Test st.dataframe returns an empty selection as initial result."""

        df = pd.DataFrame([[1, 2], [3, 4]], columns=["col1", "col2"])
        selection = st.dataframe(df, on_select="rerun", key="selectable_df")

        self.assertEqual(selection.selection.rows, [])
        self.assertEqual(selection.selection.columns, [])

        # Check that the selection state is added to the session state:
        self.assertEqual(st.session_state.selectable_df.selection.rows, [])
        self.assertEqual(st.session_state.selectable_df.selection.columns, [])

    def test_dataframe_with_invalid_on_select(self):
        """Test that an exception is thrown if the on_select parameter is invalid."""
        df = pd.DataFrame([[1, 2], [3, 4]], columns=["col1", "col2"])
        with self.assertRaises(StreamlitAPIException):
            st.dataframe(df, on_select="invalid")

    @patch("streamlit.runtime.Runtime.exists", MagicMock(return_value=True))
    def test_inside_form_on_select_rerun(self):
        """Test that form id is marshalled correctly inside of a form."""

        df = pd.DataFrame([[1, 2], [3, 4]], columns=["col1", "col2"])

        with st.form("form"):
            st.dataframe(df, on_select="rerun")

        # 2 elements will be created: form block, dataframe
        self.assertEqual(len(self.get_all_deltas_from_queue()), 2)

        form_proto = self.get_delta_from_queue(0).add_block
        plotly_proto = self.get_delta_from_queue(1).new_element.arrow_data_frame
        self.assertEqual(plotly_proto.form_id, form_proto.form.form_id)

    @patch("streamlit.runtime.Runtime.exists", MagicMock(return_value=True))
    def test_selectable_df_disallows_callbacks_inside_form(self):
        """Test that an exception is thrown if a callback is defined with a
        selectable dataframe inside a form."""

        df = pd.DataFrame([[1, 2], [3, 4]], columns=["col1", "col2"])

        with self.assertRaises(StreamlitAPIException):
            with st.form("form"):
                st.dataframe(df, on_select=lambda: None)

    def test_selectable_df_throws_exception_with_modified_sessions_state(self):
        """Test that an exception is thrown if the session state is modified."""
        df = pd.DataFrame([[1, 2], [3, 4]], columns=["col1", "col2"])
        st.session_state.selectable_df = {
            "selection": {"rows": [1], "columns": ["col1"]},
        }
        with self.assertRaises(StreamlitAPIException):
            st.dataframe(df, on_select="rerun", key="selectable_df")

    def test_shows_cached_widget_replay_warning(self):
        """Test that a warning is shown when selections are activated and
        it is used inside a cached function."""
        df = pd.DataFrame([[1, 2], [3, 4]], columns=["col1", "col2"])
        st.cache_data(lambda: st.dataframe(df, on_select="rerun"))()

        # The widget itself is still created, so we need to go back one element more:
        el = self.get_delta_from_queue(-2).new_element.exception
        self.assertEqual(el.type, "CachedWidgetWarning")
        self.assertTrue(el.is_warning)

    @parameterized.expand(
        [
            ("rerun", [1]),
            ("ignore", []),
            (lambda: None, [1]),
        ]
    )
    def test_dataframe_valid_on_select(self, on_select, proto_value):
        """Test that the on_select parameter is parsed correctly."""

        df = pd.DataFrame([[1, 2], [3, 4]], columns=["col1", "col2"])
        st.dataframe(df, on_select=on_select)

        el = self.get_delta_from_queue().new_element.arrow_data_frame
        self.assertEqual(el.selection_mode, proto_value)

    @parameterized.expand(
        [
            (("multi-row", "multi-column"), [1, 3]),
            ({"single-row", "single-column"}, [0, 2]),
            ({"single-row", "multi-column"}, [0, 3]),
            (("multi-row", "single-column"), [1, 2]),
            ("single-row", [0]),
            ("multi-column", [3]),
        ]
    )
    def test_selection_mode_parsing(self, input_modes, expected_modes):
        """Test that the selection_mode parameter is parsed correctly."""

        df = pd.DataFrame([[1, 2], [3, 4]], columns=["col1", "col2"])
        st.dataframe(df, on_select="rerun", selection_mode=input_modes)

        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.arrow_data_frame.selection_mode, expected_modes)

    def test_selection_mode_parsing_invalid(self):
        """Test that an exception is thrown if the selection_mode parameter is invalid."""
        df = pd.DataFrame([[1, 2], [3, 4]], columns=["col1", "col2"])

        # Should throw an exception of the selection mode is parsed wrongly
        with self.assertRaises(
            StreamlitAPIException,
            msg="Should show exception if an unknown selection mode is selected",
        ):
            st.dataframe(
                df, on_select="rerun", selection_mode=["invalid", "single-row"]
            )

        with self.assertRaises(
            StreamlitAPIException,
            msg="Should show exception if single & multi row mode is selected",
        ):
            st.dataframe(
                df, on_select="rerun", selection_mode=["single-row", "multi-row"]
            )

        with self.assertRaises(
            StreamlitAPIException,
            msg="Should show exception if single & multi column mode is selected",
        ):
            st.dataframe(
                df, on_select="rerun", selection_mode=["single-column", "multi-column"]
            )

        # If selections are deactivated, the selection mode list should be empty
        # even if the selection_mode parameter is set.
        st.dataframe(
            df, on_select="ignore", selection_mode=["single-row", "multi-column"]
        )
        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.plotly_chart.selection_mode, [])


class StArrowTableAPITest(DeltaGeneratorTestCase):
    """Test Public Streamlit Public APIs."""

    def test_table(self):
        """Test st.table."""
        from streamlit.dataframe_util import convert_arrow_bytes_to_pandas_df

        df = pd.DataFrame([[1, 2], [3, 4]], columns=["col1", "col2"])

        st.table(df)

        proto = self.get_delta_from_queue().new_element.arrow_table
        pd.testing.assert_frame_equal(convert_arrow_bytes_to_pandas_df(proto.data), df)


================================================
File: /lib/tests/streamlit/elements/arrow_table_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Arrow marshalling unit tests."""

from unittest.mock import patch

import numpy as np
import pandas as pd
import pyarrow as pa

import streamlit as st
from streamlit.dataframe_util import (
    convert_arrow_bytes_to_pandas_df,
    convert_arrow_table_to_arrow_bytes,
)
from tests.delta_generator_test_case import DeltaGeneratorTestCase


def mock_data_frame():
    return pd.DataFrame(
        index=[[0, 1], ["i1", "i2"]],
        columns=[[2, 3, 4], ["c1", "c2", "c3"]],
        data=np.arange(0, 6, 1).reshape(2, 3),
    )


class ArrowTest(DeltaGeneratorTestCase):
    """Test ability to marshall arrow protos."""

    def test_dataframe_data(self):
        df = mock_data_frame()
        st.table(df)

        proto = self.get_delta_from_queue().new_element.arrow_table
        pd.testing.assert_frame_equal(convert_arrow_bytes_to_pandas_df(proto.data), df)

    def test_pyarrow_table_data(self):
        df = mock_data_frame()
        table = pa.Table.from_pandas(df)
        st.table(table)

        proto = self.get_delta_from_queue().new_element.arrow_table
        self.assertEqual(proto.data, convert_arrow_table_to_arrow_bytes(table))

    def test_uuid(self):
        df = mock_data_frame()
        styler = df.style
        styler.set_uuid("FAKE_UUID")
        st.table(styler)

        proto = self.get_delta_from_queue().new_element.arrow_table
        self.assertEqual(proto.styler.uuid, "FAKE_UUID")

    def test_caption(self):
        df = mock_data_frame()
        styler = df.style
        styler.set_caption("FAKE_CAPTION")
        st.table(styler)

        proto = self.get_delta_from_queue().new_element.arrow_table
        self.assertEqual(proto.styler.caption, "FAKE_CAPTION")

    def test_table_styles(self):
        df = mock_data_frame()
        styler = df.style
        # NOTE: If UUID is not set - a random UUID will be generated.
        styler.set_uuid("FAKE_UUID")
        styler.set_table_styles(
            [{"selector": ".blank", "props": [("background-color", "red")]}]
        )
        st.table(styler)

        proto = self.get_delta_from_queue().new_element.arrow_table
        self.assertEqual(
            proto.styler.styles, "#T_FAKE_UUID .blank { background-color: red }"
        )

    def test_cell_styles(self):
        df = mock_data_frame()
        styler = df.style
        # NOTE: If UUID is not set - a random UUID will be generated.
        styler.set_uuid("FAKE_UUID")
        styler.highlight_max(axis=None)
        st.table(styler)

        proto = self.get_delta_from_queue().new_element.arrow_table
        self.assertEqual(
            proto.styler.styles, "#T_FAKE_UUIDrow1_col2 { background-color: yellow }"
        )

    def test_display_values(self):
        df = pd.DataFrame(
            [[1, 2, 3], [4, 5, 6]],
        )
        styler = df.style.format("{:.2%}")
        st.table(styler)

        expected = pd.DataFrame(
            [["100.00%", "200.00%", "300.00%"], ["400.00%", "500.00%", "600.00%"]],
        )

        proto = self.get_delta_from_queue().new_element.arrow_table
        pd.testing.assert_frame_equal(
            convert_arrow_bytes_to_pandas_df(proto.styler.display_values), expected
        )

    def test_table_uses_convert_anything_to_df(self):
        """Test that st.table uses convert_anything_to_df to convert input data."""
        df = mock_data_frame()

        with patch(
            "streamlit.dataframe_util.convert_anything_to_pandas_df"
        ) as convert_anything_to_df:
            convert_anything_to_df.return_value = df

            st.table(df)
            convert_anything_to_df.assert_called_once()


================================================
File: /lib/tests/streamlit/elements/audio_input_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""experimental_audio_input unit test."""

from parameterized import parameterized

import streamlit as st
from streamlit.errors import StreamlitAPIException
from streamlit.proto.LabelVisibilityMessage_pb2 import LabelVisibilityMessage
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class AudioInputTest(DeltaGeneratorTestCase):
    def test_just_label(self):
        """Test that it can be called with no other values."""
        st.experimental_audio_input("the label")

        c = self.get_delta_from_queue().new_element.audio_input
        self.assertEqual(c.label, "the label")
        self.assertEqual(
            c.label_visibility.value,
            LabelVisibilityMessage.LabelVisibilityOptions.VISIBLE,
        )

    @parameterized.expand(
        [
            ("visible", LabelVisibilityMessage.LabelVisibilityOptions.VISIBLE),
            ("hidden", LabelVisibilityMessage.LabelVisibilityOptions.HIDDEN),
            ("collapsed", LabelVisibilityMessage.LabelVisibilityOptions.COLLAPSED),
        ]
    )
    def test_label_visibility(self, label_visibility_value, proto_value):
        """Test that it can be called with label_visibility parameter."""
        st.experimental_audio_input(
            "the label", label_visibility=label_visibility_value
        )

        c = self.get_delta_from_queue().new_element.audio_input
        self.assertEqual(c.label_visibility.value, proto_value)

    def test_label_visibility_wrong_value(self):
        with self.assertRaises(StreamlitAPIException) as e:
            st.experimental_audio_input("the label", label_visibility="wrong_value")

        self.assertEqual(
            str(e.exception),
            "Unsupported label_visibility option 'wrong_value'. Valid values are "
            "'visible', 'hidden' or 'collapsed'.",
        )


================================================
File: /lib/tests/streamlit/elements/audio_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""st.audio unit tests"""

import os
from io import BytesIO

import numpy as np
import pytest
from parameterized import parameterized

import streamlit as st
from streamlit.elements.media import (
    _maybe_convert_to_wav_bytes,
    _parse_start_time_end_time,
)
from streamlit.errors import StreamlitAPIException
from streamlit.proto.Alert_pb2 import Alert as AlertProto
from streamlit.runtime.media_file_storage import MediaFileStorageError
from streamlit.runtime.memory_media_file_storage import _calculate_file_id
from streamlit.web.server.server import MEDIA_ENDPOINT
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class AudioTest(DeltaGeneratorTestCase):
    def test_st_audio_from_bytes(self):
        """Test st.audio using fake audio bytes."""

        # Fake audio data: expect the resultant mimetype to be audio default.
        fake_audio_data = b"\x11\x22\x33\x44\x55\x66"

        st.audio(fake_audio_data)

        el = self.get_delta_from_queue().new_element

        # locate resultant file in InMemoryFileManager and test its properties.
        file_id = _calculate_file_id(fake_audio_data, "audio/wav")
        media_file = self.media_file_storage.get_file(file_id)
        self.assertIsNotNone(media_file)
        self.assertEqual(media_file.mimetype, "audio/wav")
        self.assertEqual(self.media_file_storage.get_url(file_id), el.audio.url)

    @parameterized.expand(
        [
            ([],),  # empty arr
            ([1, 2, 3, 4],),  # 1d array
            ([[34, 15], [78, 98], [23, 78]],),  # 2d numpy array
        ]
    )
    def test_st_audio_valid_numpy_array(self, arr):
        """Test st.audio using fake audio from empty, 1d, 2d numpy array."""

        sample_rate = 44100

        # Fake audio data: expect the resultant mimetype to be audio default.
        fake_audio_np_array = np.array(arr)

        st.audio(fake_audio_np_array, sample_rate=sample_rate)
        computed_bytes = _maybe_convert_to_wav_bytes(
            fake_audio_np_array, sample_rate=sample_rate
        )

        el = self.get_delta_from_queue().new_element

        # locate resultant file in InMemoryFileManager and test its properties.
        file_id = _calculate_file_id(computed_bytes, "audio/wav")
        media_file = self.media_file_storage.get_file(file_id)
        self.assertIsNotNone(media_file)
        self.assertEqual(media_file.mimetype, "audio/wav")
        self.assertEqual(self.media_file_storage.get_url(file_id), el.audio.url)
        self.assertEqual(media_file.content, computed_bytes)

    @parameterized.expand(
        [
            (
                np.linspace(1, 10, num=300).reshape((10, 10, 3)),  # 3d numpy array
                3,
                "Numpy array audio input must be a 1D or 2D array.",
            ),
            (
                np.linspace(1, 10, num=300).reshape((10, 2, 5, 3)),  # 4d numpy array
                4,
                "Numpy array audio input must be a 1D or 2D array.",
            ),
            (
                np.empty((2, 0, 0, 0)),  # 4d empty numpy array
                4,
                "Numpy array audio input must be a 1D or 2D array.",
            ),
        ]
    )
    def test_st_audio_invalid_numpy_array(self, np_arr, expected_shape, exception_text):
        """Test st.audio using invalid numpy array."""

        sample_rate = 44100
        self.assertEqual(len(np_arr.shape), expected_shape)

        with self.assertRaises(StreamlitAPIException) as e:
            st.audio(np_arr, sample_rate=sample_rate)

        self.assertEqual(str(e.exception), exception_text)

    def test_st_audio_missing_sample_rate_numpy_arr(self):
        """Test st.audio raises exception when sample_rate missing in case of valid
        numpy array."""

        valid_np_array = np.array([1, 2, 3, 4, 5])

        with self.assertRaises(StreamlitAPIException) as e:
            st.audio(valid_np_array)

        self.assertEqual(
            str(e.exception),
            "`sample_rate` must be specified when `data` is a numpy array.",
        )

    def test_st_audio_sample_rate_raises_warning(self):
        """Test st.audio raises streamlit warning when sample_rate parameter provided,
        but data is not a numpy array."""

        fake_audio_data = b"\x11\x22\x33\x44\x55\x66"
        sample_rate = 44100

        st.audio(fake_audio_data, sample_rate=sample_rate)

        c = self.get_delta_from_queue(-2).new_element.alert
        self.assertEqual(c.format, AlertProto.WARNING)
        self.assertEqual(
            c.body,
            "Warning: `sample_rate` will be ignored since data is not a numpy array.",
        )

    def test_maybe_convert_to_wave_numpy_arr_empty(self):
        """Test _maybe_convert_to_wave_bytes works correctly with empty numpy array."""
        sample_rate = 44100
        fake_audio_np_array = np.array([])

        computed_bytes = _maybe_convert_to_wav_bytes(
            fake_audio_np_array, sample_rate=sample_rate
        )

        self.assertEqual(
            computed_bytes,
            b"RIFF$\x00\x00\x00WAVEfmt \x10\x00\x00\x00\x01\x00\x01\x00D\xac\x00\x00"
            b"\x88X\x01\x00\x02\x00\x10\x00data\x00\x00\x00\x00",
        )

    def test_maybe_convert_to_wave_numpy_arr_mono(self):
        """Test _maybe_convert_to_wave_bytes works correctly with 1d numpy array."""
        sample_rate = 7
        fake_audio_np_array = np.array([1, 9])

        computed_bytes = _maybe_convert_to_wav_bytes(
            fake_audio_np_array, sample_rate=sample_rate
        )

        self.assertEqual(
            computed_bytes,
            b"RIFF(\x00\x00\x00WAVEfmt \x10\x00\x00\x00\x01\x00\x01\x00\x07\x00\x00"
            b"\x00\x0e\x00\x00\x00\x02\x00\x10\x00data\x04\x00\x00\x008\x0e\xff\x7f",
        )

    def test_maybe_convert_to_wave_numpy_arr_stereo(self):
        """Test _maybe_convert_to_wave_bytes works correctly with 2d numpy array."""
        sample_rate = 44100
        left_channel = np.array([1, 9])
        right_channel = np.array([6, 1])

        fake_audio_np_array = np.array([left_channel, right_channel])

        computed_bytes = _maybe_convert_to_wav_bytes(
            fake_audio_np_array, sample_rate=sample_rate
        )

        self.assertEqual(
            computed_bytes,
            b"RIFF,\x00\x00\x00WAVEfmt \x10\x00\x00\x00\x01\x00\x02\x00D\xac\x00\x00"
            b"\x10\xb1\x02\x00\x04\x00\x10\x00data\x08\x00\x00\x008\x0eTU\xff\x7f8\x0e",
        )

    def test_maybe_convert_to_wave_bytes_with_sample_rate(self):
        """Test _maybe_convert_to_wave_bytes works correctly with bytes."""

        fake_audio_data_bytes = b"\x11\x22\x33\x44\x55\x66"
        sample_rate = 44100

        computed_bytes = _maybe_convert_to_wav_bytes(
            fake_audio_data_bytes, sample_rate=sample_rate
        )

        self.assertEqual(computed_bytes, fake_audio_data_bytes)

    def test_maybe_convert_to_wave_bytes_without_sample_rate(self):
        """Test _maybe_convert_to_wave_bytes works correctly when sample_rate
        is None."""

        np_arr = np.array([0, 1, 2, 3])
        computed_bytes = _maybe_convert_to_wav_bytes(np_arr, sample_rate=None)
        self.assertTrue(computed_bytes is np_arr)

    @pytest.mark.require_integration
    def test_st_audio_from_file(self):
        """Test st.audio using generated data in a file-like object."""
        from scipy.io import wavfile

        sample_rate = 44100
        frequency = 440
        length = 5

        # Produces a 5 second Audio-File
        t = np.linspace(0, length, sample_rate * length)
        # Has frequency of 440Hz
        y = np.sin(frequency * 2 * np.pi * t)

        wavfile.write("test.wav", sample_rate, y)

        with open("test.wav", "rb") as f:
            st.audio(f)

        el = self.get_delta_from_queue().new_element
        self.assertTrue(".wav" in el.audio.url)

        os.remove("test.wav")

    def test_st_audio_from_url(self):
        """We can pass a URL directly to st.audio."""
        # Test using a URL instead of data
        some_url = "https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3"
        st.audio(some_url)

        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.audio.url, some_url)

    def test_st_audio_raises_on_bad_filename(self):
        """A non-URL string is assumed to be a filename. A file we can't
        open will result in an error.
        """
        with self.assertRaises(MediaFileStorageError):
            st.audio("not/a/real/file")

    def test_st_audio_from_none(self):
        """st.audio(None) is not an error."""
        st.audio(None)
        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.audio.url, "")

    def test_st_audio_other_inputs(self):
        """Test that our other data types don't result in an error."""
        st.audio(b"bytes_data")
        st.audio(b"str_data")
        st.audio(BytesIO(b"bytesio_data"))
        st.audio(np.array([0, 1, 2, 3]), sample_rate=44100)

    def test_st_audio_options(self):
        """Test st.audio with options."""
        fake_audio_data = b"\x11\x22\x33\x44\x55\x66"
        st.audio(
            fake_audio_data,
            format="audio/mp3",
            start_time=10,
            end_time=21,
            loop=True,
            autoplay=True,
        )

        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.audio.start_time, 10)
        self.assertEqual(el.audio.end_time, 21)
        self.assertTrue(el.audio.loop)
        self.assertTrue(el.audio.autoplay)
        self.assertTrue(el.audio.url.startswith(MEDIA_ENDPOINT))
        self.assertTrue(_calculate_file_id(fake_audio_data, "audio/mp3"), el.audio.url)

    def test_st_audio_just_data(self):
        """Test st.audio with just data specified."""
        fake_audio_data = b"\x11\x22\x33\x44\x55\x66"
        st.audio(fake_audio_data)

        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.audio.start_time, 0)
        self.assertEqual(el.audio.end_time, 0)
        self.assertFalse(el.audio.loop)
        self.assertFalse(el.audio.autoplay)
        self.assertTrue(el.audio.url.startswith(MEDIA_ENDPOINT))
        self.assertTrue(_calculate_file_id(fake_audio_data, "audio/wav"), el.audio.url)

    @parameterized.expand(
        [
            ("1s", None, (1, None)),
            ("1m", None, (60, None)),
            ("1m2s", None, (62, None)),
            (0, "1m", (0, 60)),
            ("1h2m3s", None, (3723, None)),
            ("1m2s", "1m10s", (62, 70)),
            ("10 seconds", "15 seconds", (10, 15)),
            ("3 minutes 10 seconds", "3 minutes 20 seconds", (190, 200)),
        ]
    )
    def test_parse_start_time_end_time_success(
        self, input_start_time, input_end_time, expected_value
    ):
        """Test that _parse_start_time_end_time works correctly."""
        self.assertEqual(
            _parse_start_time_end_time(input_start_time, input_end_time),
            expected_value,
        )

    @parameterized.expand(
        [
            ("INVALID_VALUE", None, "Failed to convert 'start_time' to a timedelta"),
            (5, "INVALID_VALUE", "Failed to convert 'end_time' to a timedelta"),
        ]
    )
    def test_parse_start_time_end_time_fail(self, start_time, end_time, exception_text):
        """Test that _parse_start_time_end_time works with correct exception text."""

        with self.assertRaises(StreamlitAPIException) as e:
            _parse_start_time_end_time(start_time, end_time)

        self.assertIn(exception_text, str(e.exception))
        self.assertIn("INVALID_VALUE", str(e.exception))


================================================
File: /lib/tests/streamlit/elements/balllons_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Balloons unit test."""

import streamlit as st
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class BallonsTest(DeltaGeneratorTestCase):
    """Test ability to marshall balloons protos."""

    def test_st_balloons(self):
        """Test st.balloons."""
        st.balloons()
        el = self.get_delta_from_queue().new_element
        self.assertEqual(el.balloons.show, True)


================================================
File: /lib/tests/streamlit/elements/bokeh_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Bokeh unit test."""

import unittest
from unittest.mock import patch

import numpy as np

import streamlit as st
from streamlit.errors import StreamlitAPIException
from streamlit.type_util import is_version_less_than
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class BokehTest(DeltaGeneratorTestCase):
    """Test ability to marshall bokeh_chart protos."""

    @unittest.skipIf(
        is_version_less_than(np.__version__, "2.0.0") is False,
        "This test only runs if numpy is < 2.0.0. The bokeh version supported "
        "by Streamlit is not compatible with numpy 2.x.",
    )
    def test_figure(self):
        """Test that it can be called with figure."""

        from bokeh.plotting import figure

        plot = figure()
        plot.line([1], [1])
        st.bokeh_chart(plot)

        c = self.get_delta_from_queue().new_element.bokeh_chart
        self.assertEqual(hasattr(c, "figure"), True)

    @unittest.skipIf(
        is_version_less_than(np.__version__, "2.0.0") is False,
        "This test only runs if numpy is < 2.0.0. The bokeh version supported "
        "by Streamlit is not compatible with numpy 2.x.",
    )
    def test_bokeh_version_failure(self):
        from bokeh.plotting import figure

        with patch("bokeh.__version__", return_value="2.4.0"):
            plot = figure()
            with self.assertRaises(StreamlitAPIException):
                st.bokeh_chart(plot)


================================================
File: /lib/tests/streamlit/elements/button_group_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""button_group unit test."""

from __future__ import annotations

from typing import Any, Callable, Literal
from unittest.mock import MagicMock, patch

import numpy as np
import pandas as pd
import pytest
from parameterized import parameterized

import streamlit as st
from streamlit.elements.widgets.button_group import (
    _FACES_ICONS,
    _SELECTED_STAR_ICON,
    _STAR_ICON,
    _THUMB_ICONS,
    ButtonGroupMixin,
    SelectionMode,
    SingleOrMultiSelectSerde,
    SingleSelectSerde,
    get_mapped_options,
)
from streamlit.errors import StreamlitAPIException
from streamlit.proto.ButtonGroup_pb2 import ButtonGroup as ButtonGroupProto
from streamlit.proto.LabelVisibilityMessage_pb2 import LabelVisibilityMessage
from streamlit.runtime.state.session_state import get_script_run_ctx
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class TestGetMappedOptions:
    def test_thumbs(self):
        options, options_indices = get_mapped_options("thumbs")

        assert len(options) == 2
        assert len(options_indices) == 2

        for index, option in enumerate(options):
            assert option.content_icon == _THUMB_ICONS[index]

        # ensure order of thumbs
        assert "down" in options[1].content_icon
        assert options_indices[0] == 1
        assert "up" in options[0].content_icon
        assert options_indices[1] == 0

    def test_faces(self):
        options, options_indices = get_mapped_options("faces")

        assert len(options) == 5
        assert len(options_indices) == 5

        for index, option in enumerate(options):
            assert option.content_icon == _FACES_ICONS[index]
            assert option.selected_content_icon == ""
            assert options_indices[index] == index

        # ensure order of faces
        assert "sad" in options[0].content_icon
        assert "very_satisfied" in options[4].content_icon

    def test_stars(self):
        options, options_indices = get_mapped_options("stars")

        assert len(options) == 5
        assert len(options_indices) == 5

        for index, option in enumerate(options):
            assert option.content_icon == _STAR_ICON
            assert option.selected_content_icon == _SELECTED_STAR_ICON
            assert options_indices[index] == index


class TestSingleSelectSerde:
    def test_serialize(self):
        option_indices = [5, 6, 7]
        serde = SingleSelectSerde[int](option_indices)
        res = serde.serialize(6)
        assert res == [1]

    def test_serialize_raise_option_does_not_exist(self):
        option_indices = [5, 6, 7]
        serde = SingleSelectSerde[int](option_indices)

        with pytest.raises(StreamlitAPIException):
            serde.serialize(8)

    def test_deserialize(self):
        option_indices = [5, 6, 7]
        serde = SingleSelectSerde[int](option_indices)
        res = serde.deserialize([1], "")
        assert res == 6

    def test_deserialize_with_default_value(self):
        option_indices = [5, 6, 7]
        serde = SingleSelectSerde[int](option_indices, default_value=[2])
        res = serde.deserialize(None, "")
        assert res == 7

    def test_deserialize_raise_indexerror(self):
        option_indices = [5, 6, 7]
        serde = SingleSelectSerde[int](option_indices)

        with pytest.raises(IndexError):
            serde.deserialize([3], "")


class TestSingleOrMultiSelectSerde:
    @parameterized.expand([("single",), ("multi",)])
    def test_serialize(self, selection_mode: SelectionMode):
        option_indices = [5, 6, 7]
        serde = SingleOrMultiSelectSerde[int](option_indices, [], selection_mode)
        res = serde.serialize(6)
        assert res == [1]

    @parameterized.expand([("single",), ("multi",)])
    def test_serialize_raise_option_does_not_exist(self, selection_mode: SelectionMode):
        option_indices = [5, 6, 7]
        serde = SingleOrMultiSelectSerde[int](option_indices, [], selection_mode)

        with pytest.raises(StreamlitAPIException):
            serde.serialize(8)

    @parameterized.expand([("single", 6), ("multi", [6])])
    def test_deserialize(
        self, selection_mode: SelectionMode, expected: int | list[int]
    ):
        option_indices = [5, 6, 7]
        serde = SingleOrMultiSelectSerde[int](option_indices, [], selection_mode)
        res = serde.deserialize([1], "")
        assert res == expected

    @parameterized.expand([("single", 7), ("multi", [7])])
    def test_deserialize_with_default_value(
        self, selection_mode: SelectionMode, expected: list[int] | int
    ):
        option_indices = [5, 6, 7]
        serde = SingleOrMultiSelectSerde[int](option_indices, [2], selection_mode)
        res = serde.deserialize(None, "")
        assert res == expected

    @parameterized.expand([("single",), ("multi",)])
    def test_deserialize_raise_indexerror(self, selection_mode: SelectionMode):
        option_indices = [5, 6, 7]
        serde = SingleOrMultiSelectSerde[int](option_indices, [], selection_mode)

        with pytest.raises(IndexError):
            serde.deserialize([3], "")


class TestFeedbackCommand(DeltaGeneratorTestCase):
    """Tests that are specific for the feedback command."""

    @parameterized.expand(
        [
            ("thumbs", list(_THUMB_ICONS)),
            ("faces", list(_FACES_ICONS)),
            ("stars", list([_STAR_ICON] * 5)),
        ]
    )
    def test_call_feedback_with_all_options(
        self, option: Literal["thumbs", "faces", "stars"], expected_icons: list[str]
    ):
        st.feedback(option)

        delta = self.get_delta_from_queue().new_element.button_group
        assert delta.default == []
        assert [option.content_icon for option in delta.options] == expected_icons

    def test_invalid_option_literal(self):
        with pytest.raises(StreamlitAPIException) as e:
            st.feedback("foo")
        assert (
            "The options argument to st.feedback must be one of "
            "['thumbs', 'faces', 'stars']. The argument passed was 'foo'."
        ) == str(e.value)

    @parameterized.expand([(0,), (1,)])
    def test_widget_state_changed_via_session_state(self, session_state_index: int):
        st.session_state.feedback_command_key = session_state_index
        val = st.feedback("thumbs", key="feedback_command_key")
        assert val == session_state_index


def get_command_matrix(
    test_args: list[Any], with_st_feedback: bool = False
) -> list[tuple[Any]]:
    """Return a test matrix for the different button group commands and the
    passed arguments.

    If the test args is a list like [("foo", ("a", "b")), ("bar", ("c", "d"))],
    this function returns following test matrix:
    [
        (st.pills, "foo", ("a", "b")),
        (st.pills, "bar", ("c", "d")),
        (st.segmented_control, "foo", ("a", "b")),
        (st.segmented_control, "bar", ("c", "d")),
        (_interal_button_group, "foo", ("a", "b")),
        (_interal_button_group, "bar", ("c", "d")),
    ]

    The pills, segmented_control, and _internal_button_group are wrapped in a lambda to pass default
    arguments that are not shared between them.
    """
    matrix = []

    commands: list[Callable[..., Any]] = [
        lambda *args, **kwargs: st.pills("label", *args, **kwargs),
        lambda *args, **kwargs: st.segmented_control("label", *args, **kwargs),
        lambda *args, **kwargs: ButtonGroupMixin._internal_button_group(
            st._main, *args, **kwargs
        ),
    ]
    if with_st_feedback:
        commands.append(lambda *args, **kwargs: st.feedback(*args, **kwargs))

    for command in commands:
        if command is None:
            continue
        if len(test_args) == 0:
            matrix.append((command,))
            continue

        for args in test_args:
            matrix.append((command, *args))
    return matrix


# TODO: Some tests are very similar to the ones in multi_test.py -> maybe we can refactor them and share even more
class ButtonGroupCommandTests(DeltaGeneratorTestCase):
    @parameterized.expand(
        [
            (
                st.feedback,
                ("thumbs",),
                None,
                [":material/thumb_up:", ":material/thumb_down:"],
                "content_icon",
                ButtonGroupProto.Style.BORDERLESS,
                False,
            ),
            (
                st.pills,
                ("label", ["a", "b", "c"]),
                {"help": "Test help param"},
                ["a", "b", "c"],
                "content",
                ButtonGroupProto.Style.PILLS,
                True,
            ),
            (
                lambda *args, **kwargs: ButtonGroupMixin._internal_button_group(
                    st._main, *args, **kwargs
                ),
                (["a", "b", "c"],),
                None,
                ["a", "b", "c"],
                "content",
                ButtonGroupProto.Style.SEGMENTED_CONTROL,
                False,
            ),
        ]
    )
    def test_proto_population(
        self,
        command: Callable[..., None],
        command_args: tuple[Any, ...],
        command_kwargs: dict[str, Any] | None,
        expected_options: list[str],
        option_field: str,
        style: ButtonGroupProto.Style,
        test_label: bool,
    ):
        if command_kwargs is None:
            command_kwargs = {}
        command(*command_args, **command_kwargs)

        delta = self.get_delta_from_queue().new_element.button_group
        assert [
            getattr(option, option_field) for option in delta.options
        ] == expected_options
        assert delta.default == []
        assert delta.click_mode == ButtonGroupProto.ClickMode.SINGLE_SELECT
        assert delta.disabled is False
        assert delta.form_id == ""
        assert (
            delta.selection_visualization
            == ButtonGroupProto.SelectionVisualization.ONLY_SELECTED
        )
        assert delta.style == style

        if test_label:
            assert delta.label == command_args[0]
        assert (
            delta.label_visibility.value
            is LabelVisibilityMessage.LabelVisibilityOptions.VISIBLE
        )

    @parameterized.expand(
        get_command_matrix([("string_key",), (0,), (None,)], with_st_feedback=True)
    )
    def test_key_types(self, comand: Callable[..., None], key: str | int | None):
        """Test that the key argument can be passed as expected."""

        # use options that is compatible with all commands including st.feedback
        comand("thumbs", key=key)

        delta = self.get_delta_from_queue().new_element.button_group
        assert delta.id.endswith(f"-{str(key)}")

    @parameterized.expand(
        [
            (st.feedback, ("thumbs",)),
            (st.pills, ("label", ["a", "b", "c"])),
            (st.pills, ("label", ["a", "b", "c"]), {"default": "b"}, "b"),
            (
                lambda *args, **kwargs: ButtonGroupMixin._internal_button_group(
                    st._main, *args, **kwargs
                ),
                (["a", "b", "c"],),
                {"default": "b"},
                "b",
            ),
            (
                st.pills,
                ("label", ["a", "b", "c"]),
                {"default": "b", "selection_mode": "multi"},
                ["b"],
            ),
            (
                lambda *args, **kwargs: ButtonGroupMixin._internal_button_group(
                    st._main, *args, **kwargs
                ),
                (["a", "b", "c"],),
                {"default": "b", "selection_mode": "multi"},
                ["b"],
            ),
        ]
    )
    def test_default_return_value(
        self,
        command: Callable[..., None],
        command_args: tuple[Any, ...],
        command_kwargs: dict | None = None,
        expected_default: str | None = None,
    ):
        if command_kwargs is None:
            command_kwargs = {}
        res = command(*command_args, **command_kwargs)
        assert res == expected_default

    @parameterized.expand(
        [
            (st.feedback, ("thumbs",)),
            (st.pills, ("label", ["a", "b", "c"])),
        ]
    )
    def test_disabled(self, command: Callable, command_args: tuple[Any, ...]):
        command(*command_args, disabled=True)

        delta = self.get_delta_from_queue().new_element.button_group
        assert delta.disabled is True

    @parameterized.expand(
        get_command_matrix(
            [
                ((),),
                ([],),
                (np.array([]),),
                (pd.Series(np.array([])),),
                (set(),),
            ]
        )
    )
    def test_no_options(self, command: Callable[..., None], options: Any):
        """Test that it handles no options."""
        command(options)

        c = self.get_delta_from_queue().new_element.button_group
        assert c.default[:] == []
        assert [option.content for option in c.options] == []

    @parameterized.expand(
        get_command_matrix(
            [
                (("m", "f"), ["m", "f"]),
                (["male", "female"], ["male", "female"]),
                (np.array(["m", "f"]), ["m", "f"]),
                (pd.Series(np.array(["male", "female"])), ["male", "female"]),
                (pd.DataFrame({"options": ["male", "female"]}), ["male", "female"]),
                (
                    pd.DataFrame(
                        data=[[1, 4, 7], [2, 5, 8], [3, 6, 9]], columns=["a", "b", "c"]
                    ).columns,
                    ["a", "b", "c"],
                ),
            ]
        )
    )
    def test_various_option_types(
        self,
        command: Callable[..., None],
        options: Any,
        proto_options: list[str],
    ):
        """Test that it supports different types of options."""
        command(options)

        c = self.get_delta_from_queue().new_element.button_group
        assert c.default[:] == []
        assert [option.content for option in c.options] == proto_options

    @parameterized.expand(
        get_command_matrix(
            [
                (
                    pd.Series(np.array(["green", "blue", "red", "yellow", "brown"])),
                    ["yellow"],
                    ["green", "blue", "red", "yellow", "brown"],
                    [3],
                ),
                (
                    np.array(["green", "blue", "red", "yellow", "brown"]),
                    ["green", "red"],
                    ["green", "blue", "red", "yellow", "brown"],
                    [0, 2],
                ),
                (
                    ("green", "blue", "red", "yellow", "brown"),
                    ["blue"],
                    ["green", "blue", "red", "yellow", "brown"],
                    [1],
                ),
                (
                    ["green", "blue", "red", "yellow", "brown"],
                    ["brown"],
                    ["green", "blue", "red", "yellow", "brown"],
                    [4],
                ),
                (
                    pd.DataFrame({"col1": ["male", "female"], "col2": ["15", "10"]}),
                    ["male", "female"],
                    ["male", "female"],
                    [0, 1],
                ),
            ]
        )
    )
    def test_various_option_types_with_defaults(
        self,
        command: Callable[..., None],
        options: Any,
        defaults: Any,
        proto_options: list[str],
        expected_defaults: list[int],
    ):
        """Test that it supports different types of options and works with defaults."""
        command(options, default=defaults, selection_mode="multi")

        c = self.get_delta_from_queue().new_element.button_group
        assert [option.content for option in c.options] == proto_options
        assert c.default[:] == expected_defaults

    @parameterized.expand(
        get_command_matrix(
            [
                (("Tea", "Water"), [1, 2]),
                # the lambda returns a generator that needs to be fresh
                # for every test run:
                (lambda: (i for i in ("Tea", "Water")), [1, 2]),
                (np.array(["Coffee", "Tea"]), [0, 1]),
                (pd.Series(np.array(["Coffee", "Tea"])), [0, 1]),
                ("Coffee", [0]),
            ]
        )
    )
    def test_default_types(
        self, command: Callable[..., None], defaults: Any, expected: list[Any]
    ):
        if callable(defaults):
            defaults = defaults()

        command(["Coffee", "Tea", "Water"], default=defaults, selection_mode="multi")

        c = self.get_delta_from_queue().new_element.button_group
        assert c.default[:] == expected
        assert [option.content for option in c.options] == ["Coffee", "Tea", "Water"]

    @parameterized.expand(
        get_command_matrix([(None, []), ([], []), (["Tea", "Water"], [1, 2])])
    )
    def test_defaults_for_multi(
        self, command: Callable[..., None], defaults: Any, expected: list[Any]
    ):
        """Test that valid default can be passed as expected."""
        command(
            ["Coffee", "Tea", "Water"],
            default=defaults,
            selection_mode="multi",
        )
        c = self.get_delta_from_queue().new_element.button_group
        assert c.default[:] == expected
        assert [option.content for option in c.options] == ["Coffee", "Tea", "Water"]

    @parameterized.expand(
        get_command_matrix([(None, []), ([], []), (["Tea"], [1]), ("Coffee", [0])])
    )
    def test_default_for_singleselect(
        self, command: Callable[..., None], defaults: Any, expected: list[Any]
    ):
        """Test that valid default can be passed as expected and that the default can be
        a list or single value."""
        command(
            ["Coffee", "Tea", "Water"],
            default=defaults,
            selection_mode="single",
        )
        c = self.get_delta_from_queue().new_element.button_group
        assert c.default[:] == expected
        assert [option.content for option in c.options] == ["Coffee", "Tea", "Water"]

    @parameterized.expand(get_command_matrix([]))
    def test_default_for_single_select_must_be_single_value(
        self, command: Callable[..., None]
    ):
        """Test that passing multiple values as default for single select raises an
        exception."""
        with pytest.raises(StreamlitAPIException) as exception:
            command(
                ["Coffee", "Tea", "Water"],
                default=["Coffee", "Tea"],
                selection_mode="single",
            )
        assert (
            str(exception.value)
            == "The default argument to `st.pills` must be a single value when "
            "`selection_mode='single'`."
        )

    @parameterized.expand(
        get_command_matrix(
            [
                (["Tea", "Vodka", None], StreamlitAPIException),
                ([1, 2], StreamlitAPIException),
            ]
        )
    )
    def test_invalid_defaults(
        self, command: Callable[..., None], defaults: list, expected: type[Exception]
    ):
        """Test that invalid default trigger the expected exception."""
        with pytest.raises(expected):
            command(["Coffee", "Tea", "Water"], default=defaults)

    @parameterized.expand(
        get_command_matrix(
            [([":material/thumb_up:", ":material/thumb_down:", "foo", 0],)]
        )
    )
    def test_format_func_is_applied(
        self,
        command: Callable[..., None],
        options: list[str],
    ):
        """Test that format_func is applied to the options; since we add '!' its not a
        valid icon anymore."""
        command(options, format_func=lambda x: f"{x}!")
        c = self.get_delta_from_queue().new_element.button_group
        for index, option in enumerate(options):
            assert c.options[index].content == f"{option}!"

    @parameterized.expand(
        [
            (st.feedback, ("thumbs",)),
            (st.pills, ("label", ["a", "b", "c"])),
        ]
    )
    def test_on_change_is_registered(
        self,
        command: Callable[..., None],
        command_args: tuple[str, ...],
    ):
        command(*command_args, on_change=lambda x: x)

        ctx = get_script_run_ctx()
        assert ctx is not None
        session_state = ctx.session_state._state
        widget_id = session_state.get_widget_states()[0].id
        metadata = session_state._new_widget_state.widget_metadata.get(widget_id)
        assert metadata is not None
        assert metadata.callback is not None

    @parameterized.expand(get_command_matrix([]))
    def test_option_starting_with_icon(self, command: Callable[..., None]):
        command(
            [
                "â˜• Coffee",
                "ðŸµ Tea",
                ":material/zoom_in: Water",
                "Earth",
                ":material/zoom_out:",
            ]
        )

        c = self.get_delta_from_queue().new_element.button_group
        assert c.default == []
        assert [option.content for option in c.options] == [
            "Coffee",
            "Tea",
            "Water",
            "Earth",
            "",
        ]
        assert [option.content_icon for option in c.options] == [
            "â˜•",
            "ðŸµ",
            ":material/zoom_in:",
            "",
            ":material/zoom_out:",
        ]

    @parameterized.expand(
        get_command_matrix(
            [
                ("no-icon Coffee",),
                ("",),
                (":material/foo: Water",),
                (":material/thumb_up Tea",),
            ]
        )
    )
    def test_invalid_icons_are_not_set_to_content_icon_field(
        self, command: Callable[..., None], option: str
    ):
        command([option])

        proto = self.get_delta_from_queue().new_element.button_group
        for proto_option in proto.options:
            assert proto_option.content_icon == ""
            assert proto_option.content == option

    @parameterized.expand(get_command_matrix([], with_st_feedback=True))
    def test_outside_form(self, command: Callable[..., None]):
        """Test that form id is marshalled correctly outside of a form."""
        # pass an option that is valid for st.feedback and also the other button_group
        # commands
        command("thumbs")

        proto = self.get_delta_from_queue().new_element.button_group
        assert proto.form_id == ""

    @parameterized.expand(get_command_matrix([], with_st_feedback=True))
    @patch("streamlit.runtime.Runtime.exists", MagicMock(return_value=True))
    def test_inside_form(self, command: Callable[..., None]):
        """Test that form id is marshalled correctly inside of a form."""

        with st.form("form"):
            # pass an option that is valid for st.feedback and also the other button_group
            # commands
            command("thumbs")

        # 2 elements will be created: form block, widget
        assert len(self.get_all_deltas_from_queue()) == 2

        form_proto = self.get_delta_from_queue(0).add_block
        proto = self.get_delta_from_queue(1).new_element.button_group
        assert proto.form_id == form_proto.form.form_id

    @parameterized.expand(get_command_matrix([]))
    def test_inside_column(self, command: Callable[..., None]):
        """Test that button group commands work correctly inside of a column."""

        col1, _ = st.columns(2)

        with col1:
            command(["bar", "baz"])
        all_deltas = self.get_all_deltas_from_queue()

        # 4 elements will be created: 1 horizontal block, 2 columns, 1 widget
        assert len(all_deltas) == 4
        proto = self.get_delta_from_queue().new_element.button_group

        assert proto.default == []
        assert [option.content for option in proto.options] == ["bar", "baz"]

    def test_inside_column_feedback(self):
        """Test that st.feedback works correctly inside of a column."""

        col1, _ = st.columns(2)

        with col1:
            st.feedback("thumbs")
        all_deltas = self.get_all_deltas_from_queue()

        # 4 elements will be created: 1 horizontal block, 2 columns, 1 widget
        assert len(all_deltas) == 4
        proto = self.get_delta_from_queue().new_element.button_group

        assert proto.default == []
        assert [option.content_icon for option in proto.options] == [
            ":material/thumb_up:",
            ":material/thumb_down:",
        ]

    @parameterized.expand(get_command_matrix([]))
    def test_default_string(self, command: Callable[..., None]):
        """Test if works when the default value is not a list."""
        arg_options = ["some str", 123, None, {}]
        proto_options = ["some str", "123", "None", "{}"]

        command(
            arg_options,
            default="some str",
        )

        c = self.get_delta_from_queue().new_element.button_group
        assert c.default[:] == [0]
        assert [option.content for option in c.options] == proto_options

    @parameterized.expand(get_command_matrix([]))
    def test_invalid_selection_mode(self, command: Callable[..., None]):
        """Test that passing an invalid selection_mode raises an exception."""
        with pytest.raises(StreamlitAPIException) as exception:
            command(["a", "b"], selection_mode="foo")
        assert (
            "The selection_mode argument must be one of ['single', 'multi']. "
            "The argument passed was 'foo'." == str(exception.value)
        )

    @parameterized.expand(get_command_matrix([]))
    def test_widget_state_changed_via_session_state_for_single_select(
        self, command: Callable[..., None]
    ):
        st.session_state.command_key = "stars"
        val = command(["thumbs", "stars"], key="command_key")
        assert val == "stars"

    @parameterized.expand(get_command_matrix([]))
    def test_widget_state_changed_via_session_state_for_multi_select(
        self, command: Callable[..., None]
    ):
        st.session_state.command_key = ["stars"]
        val = command(["thumbs", "stars"], key="command_key", selection_mode="multi")
        assert val == ["stars"]

    def test_invalid_style(self):
        """Test internal button_group command does not accept invalid style."""

        with pytest.raises(StreamlitAPIException) as exception:
            ButtonGroupMixin._internal_button_group(
                st._main, ["a", "b", "c"], style="foo"
            )
        assert (
            "The style argument must be one of ['borderless', 'pills', 'segmented_control']. "
            "The argument passed was 'foo'." == str(exception.value)
        )


================================================
File: /lib/tests/streamlit/elements/button_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""button unit test."""

from parameterized import parameterized

import streamlit as st
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class ButtonTest(DeltaGeneratorTestCase):
    """Test ability to marshall button protos."""

    def test_button(self):
        """Test that it can be called."""
        st.button("the label")

        c = self.get_delta_from_queue().new_element.button
        self.assertEqual(c.label, "the label")
        self.assertEqual(c.default, False)
        self.assertEqual(c.form_id, "")
        self.assertEqual(c.type, "secondary")
        self.assertEqual(c.is_form_submitter, False)
        self.assertEqual(c.disabled, False)

    @parameterized.expand(["primary", "secondary", "tertiary"])
    def test_type(self, type):
        """Test that it can be called with type param."""
        st.button("the label", type=type)

        c = self.get_delta_from_queue().new_element.button
        self.assertEqual(c.type, type)

    def test_emoji_icon(self):
        """Test that it can be called with emoji icon."""
        st.button("the label", icon="âš¡")

        c = self.get_delta_from_queue().new_element.button
        self.assertEqual(c.icon, "âš¡")

    def test_material_icon(self):
        """Test that it can be called with material icon."""
        st.button("the label", icon=":material/thumb_up:")

        c = self.get_delta_from_queue().new_element.button
        self.assertEqual(c.icon, ":material/thumb_up:")

    def test_just_disabled(self):
        """Test that it can be called with disabled param."""
        st.button("the label", disabled=True)

        c = self.get_delta_from_queue().new_element.button
        self.assertEqual(c.disabled, True)

    def test_use_container_width_can_be_set_to_true(self):
        """Test use_container_width can be set to true."""
        st.button("the label", use_container_width=True)

        c = self.get_delta_from_queue().new_element.button
        self.assertEqual(c.use_container_width, True)

    def test_use_container_width_is_false_by_default(self):
        """Test use_container_width is false by default."""
        st.button("the label")

        c = self.get_delta_from_queue().new_element.button
        self.assertEqual(c.use_container_width, False)

    def test_cached_widget_replay_warning(self):
        """Test that a warning is shown when this widget is used inside a cached function."""
        st.cache_data(lambda: st.button("the label"))()

        # The widget itself is still created, so we need to go back one element more:
        el = self.get_delta_from_queue(-2).new_element.exception
        self.assertEqual(el.type, "CachedWidgetWarning")
        self.assertTrue(el.is_warning)


================================================
File: /lib/tests/streamlit/elements/cache_spinner_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Unit tests for cache's show_spinner option."""

import streamlit as st
from tests.delta_generator_test_case import DeltaGeneratorTestCase


@st.cache_data(show_spinner=False)
def function_without_spinner():
    return 3


@st.cache_data(show_spinner=True)
def function_with_spinner():
    return 3


class CacheSpinnerTest(DeltaGeneratorTestCase):
    """
    We test the ability to turn on and off the spinner with the show_spinner
    option by inspecting the report queue.
    """

    def test_with_spinner(self):
        """If the show_spinner flag is set, there should be one element in the
        report queue.
        """
        function_with_spinner()
        self.assertFalse(self.forward_msg_queue.is_empty())

    def test_without_spinner(self):
        """If the show_spinner flag is not set, the report queue should be
        empty.
        """
        function_without_spinner()
        self.assertTrue(self.forward_msg_queue.is_empty())


================================================
File: /lib/tests/streamlit/elements/camera_input_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""camera_input unit test."""

from parameterized import parameterized

import streamlit as st
from streamlit.errors import StreamlitAPIException
from streamlit.proto.LabelVisibilityMessage_pb2 import LabelVisibilityMessage
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class CameraInputTest(DeltaGeneratorTestCase):
    def test_just_label(self):
        """Test that it can be called with no other values."""
        st.camera_input("the label")

        c = self.get_delta_from_queue().new_element.camera_input
        self.assertEqual(c.label, "the label")
        self.assertEqual(
            c.label_visibility.value,
            LabelVisibilityMessage.LabelVisibilityOptions.VISIBLE,
        )

    def test_help_tooltip(self):
        """Test that it can be called with help parameter."""
        st.camera_input("the label", help="help_label")

        c = self.get_delta_from_queue().new_element.camera_input
        self.assertEqual(c.help, "help_label")

    @parameterized.expand(
        [
            ("visible", LabelVisibilityMessage.LabelVisibilityOptions.VISIBLE),
            ("hidden", LabelVisibilityMessage.LabelVisibilityOptions.HIDDEN),
            ("collapsed", LabelVisibilityMessage.LabelVisibilityOptions.COLLAPSED),
        ]
    )
    def test_label_visibility(self, label_visibility_value, proto_value):
        """Test that it can be called with label_visibility parameter."""
        st.camera_input("the label", label_visibility=label_visibility_value)

        c = self.get_delta_from_queue().new_element.camera_input
        self.assertEqual(c.label_visibility.value, proto_value)

    def test_label_visibility_wrong_value(self):
        with self.assertRaises(StreamlitAPIException) as e:
            st.camera_input("the label", label_visibility="wrong_value")
        self.assertEqual(
            str(e.exception),
            "Unsupported label_visibility option 'wrong_value'. Valid values are "
            "'visible', 'hidden' or 'collapsed'.",
        )

    def test_cached_widget_replay_warning(self):
        """Test that a warning is shown when this widget is used inside a cached function."""
        st.cache_data(lambda: st.camera_input("the label"))()

        # The widget itself is still created, so we need to go back one element more:
        el = self.get_delta_from_queue(-2).new_element.exception
        self.assertEqual(el.type, "CachedWidgetWarning")
        self.assertTrue(el.is_warning)


================================================
File: /lib/tests/streamlit/elements/chat_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""chat input and message unit tests."""

import pytest
from parameterized import parameterized

import streamlit as st
from streamlit.errors import (
    StreamlitAPIException,
    StreamlitValueAssignmentNotAllowedError,
)
from streamlit.proto.Block_pb2 import Block as BlockProto
from streamlit.proto.RootContainer_pb2 import RootContainer as RootContainerProto
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class ChatTest(DeltaGeneratorTestCase):
    """Test ability to marshall ChatInput and ChatMessage protos."""

    def test_label_required(self):
        """Test that label is required"""
        with self.assertRaises(TypeError):
            st.chat_message()

    def test_nesting_is_disallowed(self):
        """Test that it is not allowed to be nested."""
        with self.assertRaises(StreamlitAPIException):
            with st.chat_message("user"):
                with st.chat_message("assistant"):
                    st.write("hello")

    def test_user_message(self):
        """Test that the user message is correct."""
        message = st.chat_message("user")

        with message:
            pass

        message_block = self.get_delta_from_queue()

        self.assertEqual(message_block.add_block.chat_message.name, "user")
        self.assertEqual(message_block.add_block.chat_message.avatar, "user")
        self.assertEqual(
            message_block.add_block.chat_message.avatar_type,
            BlockProto.ChatMessage.AvatarType.ICON,
        )

    def test_assistant_message(self):
        """Test that the assistant message is correct."""
        message = st.chat_message("assistant")

        with message:
            pass

        message_block = self.get_delta_from_queue()

        self.assertEqual(message_block.add_block.chat_message.name, "assistant")
        self.assertEqual(message_block.add_block.chat_message.avatar, "assistant")
        self.assertEqual(
            message_block.add_block.chat_message.avatar_type,
            BlockProto.ChatMessage.AvatarType.ICON,
        )

    def test_ai_message(self):
        """Test that the ai preset is mapped to assistant avatar."""
        message = st.chat_message("ai")

        with message:
            pass

        message_block = self.get_delta_from_queue()

        self.assertEqual(message_block.add_block.chat_message.name, "ai")
        self.assertEqual(message_block.add_block.chat_message.avatar, "assistant")
        self.assertEqual(
            message_block.add_block.chat_message.avatar_type,
            BlockProto.ChatMessage.AvatarType.ICON,
        )

    def test_human_message(self):
        """Test that the human preset is mapped to user avatar."""
        message = st.chat_message("human")

        with message:
            pass

        message_block = self.get_delta_from_queue()

        self.assertEqual(message_block.add_block.chat_message.name, "human")
        self.assertEqual(message_block.add_block.chat_message.avatar, "user")
        self.assertEqual(
            message_block.add_block.chat_message.avatar_type,
            BlockProto.ChatMessage.AvatarType.ICON,
        )

    def test_emoji_avatar(self):
        """Test that it is possible to set an emoji as avatar."""

        message = st.chat_message("user", avatar="ðŸ‘‹")

        with message:
            pass

        message_block = self.get_delta_from_queue()

        self.assertEqual(message_block.add_block.chat_message.name, "user")
        self.assertEqual(message_block.add_block.chat_message.avatar, "ðŸ‘‹")
        self.assertEqual(
            message_block.add_block.chat_message.avatar_type,
            BlockProto.ChatMessage.AvatarType.EMOJI,
        )

    def test_image_avatar(self):
        """Test that it is possible to set an image as avatar."""

        message = st.chat_message(
            "cat",
            avatar="https://static.streamlit.io/examples/cat.jpg",
        )

        with message:
            pass

        message_block = self.get_delta_from_queue()
        self.assertEqual(message_block.add_block.chat_message.name, "cat")
        self.assertEqual(
            message_block.add_block.chat_message.avatar,
            "https://static.streamlit.io/examples/cat.jpg",
        )
        self.assertEqual(
            message_block.add_block.chat_message.avatar_type,
            BlockProto.ChatMessage.AvatarType.IMAGE,
        )

    def test_throws_invalid_avatar_exception(self):
        """Test that chat_message throws an StreamlitAPIException on invalid avatar input."""
        with pytest.raises(StreamlitAPIException):
            st.chat_message("user", avatar="FOOO")

    def test_chat_input(self):
        """Test that it can be called."""
        st.chat_input("Placeholder")

        c = self.get_delta_from_queue().new_element.chat_input
        self.assertEqual(c.placeholder, "Placeholder")
        self.assertEqual(c.default, "")
        self.assertEqual(c.value, "")
        self.assertEqual(c.set_value, False)
        self.assertEqual(c.max_chars, 0)
        self.assertEqual(c.disabled, False)

    def test_chat_input_disabled(self):
        """Test that it sets disabled correctly."""
        st.chat_input("Placeholder", disabled=True)

        c = self.get_delta_from_queue().new_element.chat_input
        self.assertEqual(c.placeholder, "Placeholder")
        self.assertEqual(c.default, "")
        self.assertEqual(c.value, "")
        self.assertEqual(c.set_value, False)
        self.assertEqual(c.max_chars, 0)
        self.assertEqual(c.disabled, True)

    def test_chat_input_max_chars(self):
        """Test that it sets max chars correctly."""
        st.chat_input("Placeholder", max_chars=100)

        c = self.get_delta_from_queue().new_element.chat_input
        self.assertEqual(c.placeholder, "Placeholder")
        self.assertEqual(c.default, "")
        self.assertEqual(c.value, "")
        self.assertEqual(c.set_value, False)
        self.assertEqual(c.max_chars, 100)
        self.assertEqual(c.disabled, False)

    def test_chat_not_allowed_in_form(self):
        """Test that it disallows being called in a form."""
        with pytest.raises(StreamlitAPIException) as exception_message:
            st.form("Form Key").chat_input("Placeholder")

        self.assertEqual(
            str(exception_message.value),
            "`st.chat_input()` can't be used in a `st.form()`.",
        )

    @parameterized.expand(
        [
            lambda: st.columns(2)[0],
            lambda: st.tabs(["Tab1", "Tab2"])[0],
            lambda: st.expander("Expand Me"),
            lambda: st.chat_message("user"),
            lambda: st.sidebar,
            lambda: st.container(),
        ]
    )
    def test_chat_selects_inline_postion(self, container_call):
        """Test that it selects inline position when nested in any of layout containers."""
        container_call().chat_input("Placeholder")

        self.assertNotEqual(
            self.get_message_from_queue().metadata.delta_path[0],
            RootContainerProto.BOTTOM,
        )

    @parameterized.expand(
        [
            lambda: st,
            lambda: st._main,
        ]
    )
    def test_chat_selects_bottom_position(self, container_call):
        """Test that it selects bottom position when called in the main dg."""
        container_call().chat_input("Placeholder")

        self.assertEqual(
            self.get_message_from_queue().metadata.delta_path[0],
            RootContainerProto.BOTTOM,
        )

    def test_session_state_rules(self):
        """Test that it disallows being called in containers (using with syntax)."""
        with self.assertRaises(StreamlitValueAssignmentNotAllowedError):
            st.session_state.my_key = "Foo"
            st.chat_input("Placeholder", key="my_key")

    def test_chat_input_cached_widget_replay_warning(self):
        """Test that a warning is shown when this widget is used inside a cached function."""
        st.cache_data(lambda: st.chat_input("the label"))()

        # The widget itself is still created, so we need to go back one element more:
        el = self.get_delta_from_queue(-2).new_element.exception
        self.assertEqual(el.type, "CachedWidgetWarning")
        self.assertTrue(el.is_warning)


================================================
File: /lib/tests/streamlit/elements/checkbox_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""checkbox unit tests."""

from unittest.mock import MagicMock, patch

from parameterized import parameterized

import streamlit as st
from streamlit.elements.lib.policies import _LOGGER
from streamlit.errors import StreamlitAPIException
from streamlit.proto.Checkbox_pb2 import Checkbox as CheckboxProto
from streamlit.proto.LabelVisibilityMessage_pb2 import LabelVisibilityMessage
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class SomeObj:
    pass


class CheckboxTest(DeltaGeneratorTestCase):
    """Test ability to marshall checkbox protos."""

    def test_just_label(self):
        """Test that it can be called with no value."""
        st.checkbox("the label")

        c = self.get_delta_from_queue().new_element.checkbox
        self.assertEqual(c.label, "the label")
        self.assertEqual(c.default, False)
        self.assertEqual(c.disabled, False)
        self.assertEqual(
            c.label_visibility.value,
            LabelVisibilityMessage.LabelVisibilityOptions.VISIBLE,
        )
        self.assertEqual(c.type, CheckboxProto.StyleType.DEFAULT)

    def test_just_disabled(self):
        """Test that it can be called with disabled param."""
        st.checkbox("the label", disabled=True)

        c = self.get_delta_from_queue(0).new_element.checkbox
        self.assertEqual(c.disabled, True)

    @parameterized.expand(
        [
            ("some str", True),
            (123, True),
            (0, False),
            (None, False),
            ({}, False),
            (SomeObj(), True),
        ]
    )
    def test_value_types(self, arg_value, proto_value):
        """Test that it supports different types of values."""
        st.checkbox("the label", arg_value)

        c = self.get_delta_from_queue().new_element.checkbox
        self.assertEqual(c.label, "the label")
        self.assertEqual(c.default, proto_value)

    def test_outside_form(self):
        """Test that form id is marshalled correctly outside of a form."""

        st.checkbox("foo")

        proto = self.get_delta_from_queue().new_element.checkbox
        self.assertEqual(proto.form_id, "")

    @patch("streamlit.runtime.Runtime.exists", MagicMock(return_value=True))
    def test_inside_form(self):
        """Test that form id is marshalled correctly inside of a form."""

        with st.form("form"):
            st.checkbox("foo")

        # 2 elements will be created: a block and a checkbox
        self.assertEqual(len(self.get_all_deltas_from_queue()), 2)

        form_proto = self.get_delta_from_queue(0).add_block.form
        checkbox_proto = self.get_delta_from_queue(1).new_element.checkbox
        self.assertEqual(checkbox_proto.form_id, form_proto.form_id)

    def test_checkbox_help_dedents(self):
        """Test that the checkbox help properly dedents in order to avoid code blocks"""
        st.checkbox(
            "Checkbox label",
            value=True,
            help="""\
hello
 world
""",
        )
        c = self.get_delta_from_queue(0).new_element.checkbox
        self.assertEqual(c.label, "Checkbox label")
        self.assertEqual(c.default, True)
        self.assertEqual(c.help, "hello\n world\n")

    @parameterized.expand(
        [
            ("visible", LabelVisibilityMessage.LabelVisibilityOptions.VISIBLE),
            ("hidden", LabelVisibilityMessage.LabelVisibilityOptions.HIDDEN),
            ("collapsed", LabelVisibilityMessage.LabelVisibilityOptions.COLLAPSED),
        ]
    )
    def test_label_visibility(self, label_visibility_value, proto_value):
        """Test that it can be called with label_visibility param."""
        st.checkbox("the label", label_visibility=label_visibility_value)

        c = self.get_delta_from_queue().new_element.checkbox
        self.assertEqual(c.label, "the label")
        self.assertEqual(c.label_visibility.value, proto_value)

    def test_label_visibility_wrong_value(self):
        with self.assertRaises(StreamlitAPIException) as e:
            st.checkbox("the label", label_visibility="wrong_value")
        self.assertEqual(
            str(e.exception),
            "Unsupported label_visibility option 'wrong_value'. Valid values are "
            "'visible', 'hidden' or 'collapsed'.",
        )

    def test_empty_label_warning(self):
        """Test that a warning is logged if st.checkbox was called with empty label."""

        with self.assertLogs(_LOGGER) as logs:
            st.checkbox(label="")

        self.assertIn(
            "`label` got an empty value. This is discouraged for accessibility reasons",
            logs.records[0].msg,
        )

    def test_toggle_widget(self):
        """Test that the usage of `st.toggle` uses the correct checkbox proto config."""
        st.toggle("the label")

        c = self.get_delta_from_queue().new_element.checkbox
        self.assertEqual(c.label, "the label")
        self.assertEqual(c.default, False)
        self.assertEqual(c.disabled, False)
        self.assertEqual(
            c.label_visibility.value,
            LabelVisibilityMessage.LabelVisibilityOptions.VISIBLE,
        )
        self.assertEqual(c.type, CheckboxProto.StyleType.TOGGLE)

    def test_checkbox_shows_cached_widget_replay_warning(self):
        """Test that a warning is shown when this widget is used inside a cached function."""
        st.cache_data(lambda: st.checkbox("the label"))()

        # The widget itself is still created, so we need to go back one element more:
        el = self.get_delta_from_queue(-2).new_element.exception
        self.assertEqual(el.type, "CachedWidgetWarning")
        self.assertTrue(el.is_warning)

    def test_toggle_shows_cached_widget_replay_warning(self):
        """Test that a warning is shown when this widget is used inside a cached function."""
        st.cache_data(lambda: st.toggle("the label"))()

        # The widget itself is still created, so we need to go back one element more:
        el = self.get_delta_from_queue(-2).new_element.exception
        self.assertEqual(el.type, "CachedWidgetWarning")
        self.assertTrue(el.is_warning)


================================================
File: /lib/tests/streamlit/elements/code_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class CodeElement(DeltaGeneratorTestCase):
    """Test ability to marshall code protos."""

    def test_st_code_default(self):
        """Test st.code() with default language (python)."""
        code = "print('Hello, %s!' % 'Streamlit')"

        st.code(code)
        element = self.get_delta_from_queue().new_element

        self.assertEqual(element.code.code_text, code)
        self.assertEqual(element.code.show_line_numbers, False)
        self.assertEqual(element.code.wrap_lines, False)
        self.assertEqual(element.code.language, "python")

    def test_st_code_python(self):
        """Test st.code with python language."""
        code = "print('My string = %d' % my_value)"
        st.code(code, language="python")

        element = self.get_delta_from_queue().new_element
        self.assertEqual(element.code.code_text, code)
        self.assertEqual(element.code.show_line_numbers, False)
        self.assertEqual(element.code.wrap_lines, False)
        self.assertEqual(element.code.language, "python")

    def test_st_code_none(self):
        """Test st.code with None language."""
        code = "print('My string = %d' % my_value)"
        st.code(code, language=None)

        element = self.get_delta_from_queue().new_element
        self.assertEqual(element.code.code_text, code)
        self.assertEqual(element.code.show_line_numbers, False)
        self.assertEqual(element.code.wrap_lines, False)
        self.assertEqual(element.code.language, "plaintext")

    def test_st_code_none_with_line_numbers(self):
        """Test st.code with None language and line numbers."""
        code = "print('My string = %d' % my_value)"
        st.code(code, language=None, line_numbers=True)

        element = self.get_delta_from_queue().new_element
        self.assertEqual(element.code.code_text, code)
        self.assertEqual(element.code.show_line_numbers, True)
        self.assertEqual(element.code.wrap_lines, False)
        self.assertEqual(element.code.language, "plaintext")

    def test_st_code_python_with_line_numbers(self):
        """Test st.code with Python language and line numbers."""
        code = "print('My string = %d' % my_value)"
        st.code(code, language="python", line_numbers=True)

        element = self.get_delta_from_queue().new_element
        self.assertEqual(element.code.code_text, code)
        self.assertEqual(element.code.show_line_numbers, True)
        self.assertEqual(element.code.wrap_lines, False)
        self.assertEqual(element.code.language, "python")

    def test_st_code_with_wrap_true(self):
        """Test st.code with wrap_lines=True."""
        code = "print('My string = %d' % my_value)"
        st.code(code, wrap_lines=True)

        element = self.get_delta_from_queue().new_element
        self.assertEqual(element.code.code_text, code)
        self.assertEqual(element.code.show_line_numbers, False)
        self.assertEqual(element.code.wrap_lines, True)
        self.assertEqual(element.code.language, "python")

    def test_st_code_with_wrap_false(self):
        """Test st.code with wrap_lines=False."""
        code = "print('My string = %d' % my_value)"
        st.code(code, wrap_lines=False)

        element = self.get_delta_from_queue().new_element
        self.assertEqual(element.code.code_text, code)
        self.assertEqual(element.code.show_line_numbers, False)
        self.assertEqual(element.code.wrap_lines, False)
        self.assertEqual(element.code.language, "python")


================================================
File: /lib/tests/streamlit/elements/color_picker_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""color_picker unit test."""

from unittest.mock import MagicMock, patch

import pytest
from parameterized import parameterized

import streamlit as st
from streamlit.errors import StreamlitAPIException
from streamlit.proto.LabelVisibilityMessage_pb2 import LabelVisibilityMessage
from tests.delta_generator_test_case import DeltaGeneratorTestCase


class ColorPickerTest(DeltaGeneratorTestCase):
    def test_just_label(self):
        """Test that it can be called with no value."""
        st.color_picker("the label")

        c = self.get_delta_from_queue().new_element.color_picker
        self.assertEqual(c.label, "the label")
        self.assertEqual(
            c.label_visibility.value,
            LabelVisibilityMessage.LabelVisibilityOptions.VISIBLE,
        )
        self.assertEqual(c.default, "#000000")
        self.assertEqual(c.disabled, False)

    def test_just_disabled(self):
        """Test that it can be called with disabled param."""
        st.color_picker("the label", disabled=True)

        c = self.get_delta_from_queue().new_element.color_picker
        self.assertEqual(c.disabled, True)

    @parameterized.expand([("#333333", "#333333"), ("#333", "#333"), (None, "#000000")])
    def test_value_types(self, arg_value, proto_value):
        """Test that it supports different types of values."""
        st.color_picker("the label", arg_value)

        c = self.get_delta_from_queue().new_element.color_picker
        self.assertEqual(c.label, "the label")
        self.assertEqual(c.default, proto_value)

    def test_invalid_value_type_error(self):
        """Tests that when the value type is invalid, an exception is generated"""
        with pytest.raises(StreamlitAPIException):
            st.color_picker("the label", 1234567)

    def test_invalid_string(self):
        """Tests that when the string doesn't match regex, an exception is generated"""
        with pytest.raises(StreamlitAPIException):
            st.color_picker("the label", "#invalid-string")

    def test_outside_form(self):
        """Test that form id is marshalled correctly outside of a form."""

        st.color_picker("foo")

        proto = self.get_delta_from_queue().new_element.color_picker
        self.assertEqual(proto.form_id, "")

    @patch("streamlit.runtime.Runtime.exists", MagicMock(return_value=True))
    def test_inside_form(self):
        """Test that form id is marshalled correctly inside of a form."""

        with st.form("form"):
            st.color_picker("foo")

        # 2 elements will be created: form block, widget
        self.assertEqual(len(self.get_all_deltas_from_queue()), 2)

        form_proto = self.get_delta_from_queue(0).add_block
        color_picker_proto = self.get_delta_from_queue(1).new_element.color_picker
        self.assertEqual(color_picker_proto.form_id, form_proto.form.form_id)

    @parameterized.expand(
        [
            ("visible", LabelVisibilityMessage.LabelVisibilityOptions.VISIBLE),
            ("hidden", LabelVisibilityMessage.LabelVisibilityOptions.HIDDEN),
            ("collapsed", LabelVisibilityMessage.LabelVisibilityOptions.COLLAPSED),
        ]
    )
    def test_label_visibility(self, label_visibility_value, proto_value):
        """Test that it can be called with label_visibility param."""
        st.color_picker("the label", label_visibility=label_visibility_value)

        c = self.get_delta_from_queue().new_element.color_picker
        self.assertEqual(c.label, "the label")
        self.assertEqual(c.label_visibility.value, proto_value)

    def test_label_visibility_wrong_value(self):
        with self.assertRaises(StreamlitAPIException) as e:
            st.color_picker("the label", label_visibility="wrong_value")
        self.assertEqual(
            str(e.exception),
            "Unsupported label_visibility option 'wrong_value'. Valid values are "
            "'visible', 'hidden' or 'collapsed'.",
        )

    def test_shows_cached_widget_replay_warning(self):
        """Test that a warning is shown when this widget is used inside a cached function."""
        st.cache_data(lambda: st.color_picker("the label"))()

        # The widget itself is still created, so we need to go back one element more:
        el = self.get_delta_from_queue(-2).new_element.exception
        self.assertEqual(el.type, "CachedWidgetWarning")
        self.assertTrue(el.is_warning)


================================================
File: /lib/tests/streamlit/elements/data_editor_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""data_editor unit test."""

from __future__ import annotations

import datetime
import json
import unittest
from decimal import Decimal
from typing import Any, Mapping
from unittest.mock import MagicMock, patch

import numpy as np
import pandas as pd
import pyarrow as pa
from parameterized import parameterized

import streamlit as st
from streamlit.dataframe_util import (
    DataFormat,
    convert_arrow_bytes_to_pandas_df,
    is_pandas_version_less_than,
)
from streamlit.elements.lib.column_config_utils import (
    INDEX_IDENTIFIER,
    ColumnDataKind,
    determine_dataframe_schema,
)
from streamlit.elements.widgets.data_editor import (
    _apply_cell_edits,
    _apply_dataframe_edits,
    _apply_row_additions,
    _apply_row_deletions,
    _check_column_names,
    _check_type_compatibilities,
    _parse_value,
)
from streamlit.errors import StreamlitAPIException
from streamlit.proto.Arrow_pb2 import Arrow as ArrowProto
from tests.delta_generator_test_case import DeltaGeneratorTestCase
from tests.streamlit.data_test_cases import SHARED_TEST_CASES, CaseMetadata


def _get_arrow_schema(df: pd.DataFrame) -> pa.Schema:
    """Get the Arrow schema for a DataFrame."""
    return pa.Table.from_pandas(df).schema


class DataEditorUtilTest(unittest.TestCase):
    @parameterized.expand(
        [
            (None, ColumnDataKind.STRING, None),
            ("hello", ColumnDataKind.STRING, "hello"),
            (123, ColumnDataKind.STRING, "123"),
            (123.1234, ColumnDataKind.STRING, "123.1234"),
            (None, ColumnDataKind.INTEGER, None),
            ("123", ColumnDataKind.INTEGER, 123),
            (123, ColumnDataKind.INTEGER, 123),
            (123.1234, ColumnDataKind.INTEGER, 123),
            (None, ColumnDataKind.FLOAT, None),
            ("123.45", ColumnDataKind.FLOAT, 123.45),
            (123.45, ColumnDataKind.FLOAT, 123.45),
            (123, ColumnDataKind.FLOAT, 123),
            (None, ColumnDataKind.BOOLEAN, None),
            (True, ColumnDataKind.BOOLEAN, True),
            ("true", ColumnDataKind.BOOLEAN, True),
            (None, ColumnDataKind.DATETIME, None),
            (
                "2021-01-01T10:20:30",
                ColumnDataKind.DATETIME,
                pd.Timestamp(
                    "2021-01-01T10:20:30",
                ),
            ),
            (
                "2021-01-01",
                ColumnDataKind.DATETIME,
                pd.Timestamp("2021-01-01T00:00:00"),
            ),
            (
                "2021-01-01T10:20:30Z",
                ColumnDataKind.DATETIME,
                pd.Timestamp("2021-01-01T10:20:30Z"),
            ),
            (
                "2021-01-01T10:20:30.123456",
                ColumnDataKind.DATETIME,
                pd.Timestamp("2021-01-01T10:20:30.123456"),
            ),
            (
                "2021-01-01T10:20:30.123456Z",
                ColumnDataKind.DATETIME,
                pd.Timestamp("2021-01-01T10:20:30.123456Z"),
            ),
            (None, ColumnDataKind.TIME, None),
            ("10:20:30", ColumnDataKind.TIME, datetime.time(10, 20, 30)),
            ("10:20:30.123456", ColumnDataKind.TIME, datetime.time(10, 20, 30, 123456)),
            (
                "2021-01-01T10:20:30.123456Z",
                ColumnDataKind.TIME,
                datetime.time(10, 20, 30, 123456),
            ),
            (
                "1970-01-01T10:20:30.123456Z",
                ColumnDataKind.TIME,
                datetime.time(10, 20, 30, 123456),
            ),
            (None, ColumnDataKind.DATE, None),
            ("2021-01-01", ColumnDataKind.DATE, datetime.date(2021, 1, 1)),
            (
                "2021-01-01T10:20:30.123456Z",
                ColumnDataKind.DATE,
                datetime.date(2021, 1, 1),
            ),
            (
                100000,
                ColumnDataKind.TIMEDELTA,
                pd.Timedelta(100000),
            ),
        ]
    )
    def test_parse_value(
        self,
        value: str | int | float | bool | None,
        column_data_kind: ColumnDataKind,
        expected: Any,
    ):
        """Test that _parse_value parses the input to the correct type."""
        result = _parse_value(value, column_data_kind)
        self.assertEqual(result, expected)

    def test_apply_cell_edits(self):
        """Test applying cell edits to a DataFrame."""
        df = pd.DataFrame(
            {
                "col1": [1, 2, 3],
                "col2": ["a", "b", "c"],
                "col3": [True, False, True],
                "col4": [
                    datetime.datetime.now(),
                    datetime.datetime.now(),
                    datetime.datetime.now(),
                ],
                "col5": [
                    Decimal("1.1"),
                    Decimal("-12.3456"),
                    Decimal("123456"),
                ],
            }
        )

        edited_rows: Mapping[int, Mapping[str, str | int | float | bool | None]] = {
            0: {
                "col1": 10,
                "col2": "foo",
                "col3": False,
                "col4": "2020-03-20T14:28:23",
                "col5": "2.3",
            },
            1: {"col2": None},
        }

        _apply_cell_edits(
            df, edited_rows, determine_dataframe_schema(df, _get_arrow_schema(df))
        )

        self.assertEqual(df.iat[0, 0], 10)
        self.assertEqual(df.iat[0, 1], "foo")
        self.assertEqual(df.iat[1, 1], None)
        self.assertEqual(df.iat[0, 2], False)
        self.assertEqual(df.iat[0, 3], pd.Timestamp("2020-03-20T14:28:23"))
        self.assertEqual(df.iat[0, 4], Decimal("2.3"))

    def test_apply_row_additions(self):
        """Test applying row additions to a DataFrame."""
        df = pd.DataFrame(
            {
                "col1": [1, 2, 3],
                "col2": ["a", "b", "c"],
                "col3": [True, False, True],
                "col4": [
                    datetime.datetime.now(),
                    datetime.datetime.now(),
                    datetime.datetime.now(),
                ],
            }
        )

        added_rows: list[dict[str, Any]] = [
            {"col1": 10, "col2": "foo", "col3": False, "col4": "2020-03-20T14:28:23"},
            {"col1": 11, "col2": "bar", "col3": True, "col4": "2023-03-20T14:28:23"},
        ]

        _apply_row_additions(
            df, added_rows, determine_dataframe_schema(df, _get_arrow_schema(df))
        )

        self.assertEqual(len(df), 5)

    def test_apply_row_deletions(self):
        """Test applying row deletions to a DataFrame."""
        df = pd.DataFrame(
            {
                "col1": [1, 2, 3],
                "col2": ["a", "b", "c"],
                "col3": [True, False, True],
            }
        )

        deleted_rows: list[int] = [0, 2]

        _apply_row_deletions(df, deleted_rows)

        self.assertEqual(len(df), 1, f"Only one row should be left, but has {len(df)}.")
        self.assertEqual(df.iloc[0].to_list(), [2, "b", False])

    def test_apply_dataframe_edits(self):
        """Test applying edits to a DataFrame."""
        df = pd.DataFrame(
            {
                "col1": [1, 2, 3],
                "col2": ["a", "b", "c"],
                "col3": [True, False, True],
            }
        )

        deleted_rows: list[int] = [0, 2]
