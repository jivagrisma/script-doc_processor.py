def test_fragment_exception_disappears_when_rerun(app: Page):
    """Unselecting the checkbox should hide the exception message.
    If this does not work, the reason might be that the exception is
    written in the main app's delta path and a fragment rerun does not
    remove the element.
    """
    fragment_1_text, fragment_2_text = _get_uuids(app)
    wait_for_app_run(app)
    assert fragment_1_text is not None
    assert fragment_2_text is not None
    assert fragment_1_text != fragment_2_text

    # show exception
    _get_fragment_checkbox(app).click()
    expect(app.get_by_test_id("stException")).to_have_count(1)

    # ensure that the fragment texts are still visible
    fragment_1_text, fragment_2_text = _get_uuids(app)
    wait_for_app_run(app)
    assert fragment_1_text is not None
    assert fragment_2_text is not None
    assert fragment_1_text != fragment_2_text

    # hide exception
    _get_fragment_checkbox(app).click()
    expect(app.get_by_test_id("stException")).to_have_count(0)


def test_fragment_exception_during_full_app_run(app: Page):
    fragment_1_text, fragment_2_text = _get_uuids(app)
    wait_for_app_run(app)
    assert fragment_1_text is not None
    assert fragment_2_text is not None
    assert fragment_1_text != fragment_2_text

    _get_app_raise_exception_checkbox(app).click()
    wait_for_app_run(app)
    fragment_1_text, fragment_2_text = _get_uuids(app, expected_markdown_count=1)
    expect(app.get_by_test_id("stException")).to_have_count(1)
    # the second fragment did not run, so _get_uuids has returned
    # the text for the first fragment twice
    assert fragment_1_text == fragment_2_text


================================================
File: /e2e_playwright/st_fragment_queue.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time

import streamlit as st


@st.fragment
def my_fragment1():
    st.button("rerun fragment 1")
    time.sleep(3)
    st.write("fragment 1 done!")


@st.fragment
def my_fragment2():
    if st.button("rerun fragment 2"):
        st.write("ran fragment 2")
    st.write("fragment 2 done!")


@st.fragment
def my_fragment3():
    st.button("rerun fragment 3")
    st.write("fragment 3 done!")


with st.container(border=True):
    my_fragment1()
with st.container(border=True):
    my_fragment2()
with st.container(border=True):
    my_fragment3()


================================================
File: /e2e_playwright/st_fragment_queue_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import wait_for_app_run
from e2e_playwright.shared.app_utils import get_button, get_markdown


def test_fragment_queue(app: Page):
    # Sanity check:
    expect(app.get_by_test_id("stMarkdown")).to_have_count(3)
    get_markdown(app, "fragment 1 done!")
    get_markdown(app, "fragment 2 done!")
    get_markdown(app, "fragment 3 done!")

    # Quickly click all 3 buttons on the page without waiting for the app to finish
    # between each click.
    for b in [
        get_button(app, "rerun fragment 1"),
        get_button(app, "rerun fragment 2"),
        get_button(app, "rerun fragment 3"),
    ]:
        b.click()
    wait_for_app_run(app)

    # Verify that the second button click wasn't dropped by checking that
    # "ran fragment 2" was indeed printed.
    expect(app.get_by_test_id("stMarkdown")).to_have_count(4)
    get_markdown(app, "fragment 1 done!")
    get_markdown(app, "ran fragment 2")
    get_markdown(app, "fragment 2 done!")
    get_markdown(app, "fragment 3 done!")


================================================
File: /e2e_playwright/st_fragment_run_every.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from uuid import uuid4

import streamlit as st


@st.fragment(run_every=1.0)
def my_auto_updating_fragment():
    st.write(f"uuid in fragment: {uuid4()}")


my_auto_updating_fragment()


================================================
File: /e2e_playwright/st_fragment_run_every_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect


def test_fragment_runs_at_interval(app: Page):
    fragment_text = app.get_by_test_id("stMarkdown").first.text_content()

    # Verify that the fragment text updates a few times.
    for _ in range(3):
        expect(app.get_by_test_id("stMarkdown").first).not_to_have_text(fragment_text)
        fragment_text = app.get_by_test_id("stMarkdown").first.text_content()


================================================
File: /e2e_playwright/st_fragments_nested.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from uuid import uuid4

import streamlit as st

if "counter" not in st.session_state:
    st.session_state.counter = -1


@st.fragment
def outer_fragment():
    st.session_state.counter += 1
    with st.container(border=True):
        st.write(f"outer fragment: {uuid4()}")
        st.button("rerun outer fragment")
        inner_fragment()


@st.fragment
def inner_fragment():
    with st.container(border=True):
        st.write(f"inner fragment: {uuid4()}")
        st.button("rerun inner fragment1")

        # show inner-fragment counter message only if counter is between 1 and 3
        if 1 <= st.session_state.counter < 3:
            st.write(f"Counter has value {st.session_state.counter}")

        inner_fragment2()


@st.fragment
def inner_fragment2():
    with st.container(border=True):
        st.write(f"inner fragment2: {uuid4()}")
        st.button("rerun inner fragment2")


st.write(f"outside all fragments: {uuid4()}")
st.button("rerun whole app")
outer_fragment()


================================================
File: /e2e_playwright/st_fragments_nested_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import Final

from playwright.sync_api import Locator, Page, expect

from e2e_playwright.shared.app_utils import click_button

COUNTER_TEXT_START: Final = "Counter has value"
DEFAULT_NUMBER_MARKDOWN_ELEMENTS: Final = 4


def _get_uuids(
    app: Page, markdown_count: int = DEFAULT_NUMBER_MARKDOWN_ELEMENTS
) -> tuple[str, str, str, str]:
    expect(app.get_by_test_id("stMarkdown")).to_have_count(markdown_count)

    outside_fragment_text = (
        app.get_by_test_id("stMarkdown")
        .filter(has_text="outside all fragments:")
        .text_content()
        or ""
    )
    outer_fragment_text = (
        app.get_by_test_id("stMarkdown")
        .filter(has_text="outer fragment:")
        .text_content()
        or ""
    )
    inner_fragment_text = (
        app.get_by_test_id("stMarkdown")
        .filter(has_text="inner fragment:")
        .text_content()
        or ""
    )
    inner_fragment2_text = (
        app.get_by_test_id("stMarkdown")
        .filter(has_text="inner fragment2:")
        .text_content()
        or ""
    )

    return (
        outside_fragment_text,
        outer_fragment_text,
        inner_fragment_text,
        inner_fragment2_text,
    )


def _rerun_outer_fragment(app: Page):
    click_button(app, "rerun outer fragment")


def _rerun_inner_fragment(app: Page):
    click_button(app, "rerun inner fragment1")


def _rerun_inner_fragment2(app: Page):
    click_button(app, "rerun inner fragment2")


def _get_inner_fragment_counter_text(app: Page) -> Locator:
    return app.get_by_test_id("stMarkdown").filter(has_text=COUNTER_TEXT_START)


def test_full_app_rerun(app: Page):
    (
        outside_fragment_text,
        outer_fragment_text,
        inner_fragment_text,
        inner_fragment2_text,
    ) = _get_uuids(app)

    click_button(app, "rerun whole app")

    # The full app reran, so all of the UUIDs in the app should have changed.
    expect(app.get_by_test_id("stMarkdown").first).not_to_have_text(
        outside_fragment_text
    )
    expect(app.get_by_test_id("stMarkdown").nth(1)).not_to_have_text(
        outer_fragment_text
    )
    expect(app.get_by_test_id("stMarkdown").nth(2)).not_to_have_text(
        inner_fragment_text
    )
    expect(app.get_by_test_id("stMarkdown").last).not_to_have_text(inner_fragment2_text)


def test_outer_fragment_rerun(app: Page):
    (
        outside_fragment_text,
        outer_fragment_text,
        inner_fragment_text,
        inner_fragment2_text,
    ) = _get_uuids(app)

    _rerun_outer_fragment(app)

    # We reran the outer fragment, so the UUID outside of the fragments should stay
    # constant, but the nested fragments' UUIDs should have changed.
    expect(app.get_by_test_id("stMarkdown").first).to_have_text(outside_fragment_text)
    expect(app.get_by_test_id("stMarkdown").nth(1)).not_to_have_text(
        outer_fragment_text
    )
    expect(app.get_by_test_id("stMarkdown").nth(2)).not_to_have_text(
        inner_fragment_text
    )
    expect(app.get_by_test_id("stMarkdown").last).not_to_have_text(inner_fragment2_text)


def test_inner_fragment_rerun(app: Page):
    (
        outside_fragment_text,
        outer_fragment_text,
        inner_fragment_text,
        inner_fragment2_text,
    ) = _get_uuids(app)

    _rerun_inner_fragment(app)

    # We reran the inner fragment directly nested in the outer fragment. This UUID and
    # UUID of the inner fragment's nested fragment (inner_fragment2) should've changed.
    expect(app.get_by_test_id("stMarkdown").first).to_have_text(outside_fragment_text)
    expect(app.get_by_test_id("stMarkdown").nth(1)).to_have_text(outer_fragment_text)
    expect(app.get_by_test_id("stMarkdown").nth(2)).not_to_have_text(
        inner_fragment_text
    )
    expect(app.get_by_test_id("stMarkdown").last).not_to_have_text(inner_fragment2_text)


def test_inner_fragment2_rerun(app: Page):
    (
        outside_fragment_text,
        outer_fragment_text,
        inner_fragment_text,
        inner_fragment2_text,
    ) = _get_uuids(app)

    _rerun_inner_fragment2(app)

    # We reran the inner-most nested fragment. Only that corresponding UUID should have
    # changed.
    expect(app.get_by_test_id("stMarkdown").first).to_have_text(outside_fragment_text)
    expect(app.get_by_test_id("stMarkdown").nth(1)).to_have_text(outer_fragment_text)
    expect(app.get_by_test_id("stMarkdown").nth(2)).to_have_text(inner_fragment_text)
    expect(app.get_by_test_id("stMarkdown").last).not_to_have_text(inner_fragment2_text)


def test_outer_fragment_rerun_clears_stale_widgets_in_inner_fragment(app: Page):
    expect(_get_inner_fragment_counter_text(app)).to_have_count(0)

    max_bound: Final = 2
    for i in range(0, max_bound):
        _rerun_outer_fragment(app)
        # the inner text is rendered now
        counter_text = _get_inner_fragment_counter_text(app)
        expect(counter_text).to_have_count(1)
        expect(counter_text).to_have_text(f"{COUNTER_TEXT_START} {i + 1}")

    # rerunning inner fragment should not change the inner fragment text
    number_markdown_elements: Final = DEFAULT_NUMBER_MARKDOWN_ELEMENTS + 1
    _, _, previous_inner_fragment_text, _ = _get_uuids(app, number_markdown_elements)
    for _ in range(0, 10):
        _rerun_inner_fragment(app)
        # ensure that the inner fragment indeed runs
        _, _, inner_fragment_text, _ = _get_uuids(app, number_markdown_elements)
        assert previous_inner_fragment_text != inner_fragment_text
        # the inner text stays the same
        counter_text = _get_inner_fragment_counter_text(app)
        expect(counter_text).to_have_count(1)
        expect(counter_text).to_have_text(f"{COUNTER_TEXT_START} {max_bound}")
        previous_inner_fragment_text = inner_fragment_text

    # rerunning outer fragment should increase the counter above the max_bound value
    # and clear the inner fragment text
    _rerun_outer_fragment(app)
    expect(_get_inner_fragment_counter_text(app)).to_have_count(0)


================================================
File: /e2e_playwright/st_graphviz_chart.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import graphviz

import streamlit as st

# basic graph
hello = graphviz.Digraph("Hello World")
hello.edge("Hello", "World")

# styled graph
styled = graphviz.Graph("G", filename="g_c_n.gv")
styled.attr(bgcolor="purple:pink", label="agraph", fontcolor="white")

with styled.subgraph(name="cluster1") as c:
    c.attr(
        fillcolor="blue:cyan",
        label="acluster",
        fontcolor="white",
        style="filled",
        gradientangle="270",
    )
    c.attr(
        "node", shape="box", fillcolor="red:yellow", style="filled", gradientangle="90"
    )
    c.node("anode")

# complex graph
engine = st.sidebar.radio(
    "Select engine",
    ["dot", "neato", "twopi", "circo", "fdp", "osage", "patchwork"],
)
st.sidebar.write(engine)
finite = graphviz.Digraph("finite_state_machine", filename="fsm.gv", engine=engine)
finite.attr(rankdir="LR", size="8,5")

finite.attr("node", shape="doublecircle")
finite.node("LR_0")
finite.node("LR_3")
finite.node("LR_4")
finite.node("LR_8")

finite.attr("node", shape="circle")
finite.edge("LR_0", "LR_2", label="SS(B)")
finite.edge("LR_0", "LR_1", label="SS(S)")
finite.edge("LR_1", "LR_3", label="S($end)")
finite.edge("LR_2", "LR_6", label="SS(b)")
finite.edge("LR_2", "LR_5", label="SS(a)")
finite.edge("LR_2", "LR_4", label="S(A)")
finite.edge("LR_5", "LR_7", label="S(b)")
finite.edge("LR_5", "LR_5", label="S(a)")
finite.edge("LR_6", "LR_6", label="S(b)")
finite.edge("LR_6", "LR_5", label="S(a)")
finite.edge("LR_7", "LR_8", label="S(b)")
finite.edge("LR_7", "LR_5", label="S(a)")
finite.edge("LR_8", "LR_6", label="S(b)")
finite.edge("LR_8", "LR_5", label="S(a)")

# draw graphs
st.graphviz_chart(hello)

st.graphviz_chart(styled)

st.graphviz_chart(finite)

# draw graphs in columns

left_graph = graphviz.Digraph("Left")
left_graph.edge("Left", "Graph")

right_graph = graphviz.Digraph("Right")
right_graph.edge("Right", "Graph")

col1, col2 = st.columns([1, 1])

with col1:
    st.graphviz_chart(left_graph)

with col2:
    st.graphviz_chart(right_graph)


dot_code = """
digraph Dot {
  A -> {B, C, D} -> {F}
}
"""
st.graphviz_chart(dot_code)


horizontal_flow_chart = """
digraph Dot {
  rankdir=LR;
  A -> B -> C -> D -> {F}
}
"""
st.graphviz_chart(horizontal_flow_chart, use_container_width=True)


================================================
File: /e2e_playwright/st_graphviz_chart_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run, wait_until
from e2e_playwright.shared.app_utils import check_top_level_class, get_radio_button


def get_first_graph_svg(app: Page):
    return app.get_by_test_id("stGraphVizChart").nth(0).locator("svg")


def click_fullscreen(app: Page):
    fullscreen_button = app.get_by_role("button", name="Fullscreen").nth(0)
    expect(fullscreen_button).to_be_visible()
    fullscreen_button.click()
    # Wait for the animation to finish
    app.wait_for_timeout(1000)


def test_initial_setup(app: Page):
    """Initial setup: ensure charts are loaded."""
    expect(
        app.get_by_test_id("stGraphVizChart").locator("svg > g > title")
    ).to_have_count(7)


def test_shows_left_and_right_graph(app: Page):
    """Test if it shows left and right graph."""

    expect(app.locator(".stGraphVizChart > svg > g > title").nth(3)).to_have_text(
        "Left"
    )
    expect(app.locator(".stGraphVizChart > svg > g > title").nth(4)).to_have_text(
        "Right"
    )


def test_first_graph_dimensions(app: Page):
    """Test the dimensions of the first graph."""

    first_graph_svg = get_first_graph_svg(app)
    expect(first_graph_svg).to_have_attribute("width", "79pt")
    expect(first_graph_svg).to_have_attribute("height", "116pt")


def test_first_graph_fullscreen(app: Page, assert_snapshot: ImageCompareFunction):
    """Test if the first graph shows in fullscreen."""
    first_graph_svg = get_first_graph_svg(app)
    expect(first_graph_svg).to_have_attribute("width", "79pt")
    first_graph_svg.hover()

    # Enter fullscreen
    click_fullscreen(app)

    # The width and height unset on the element on fullscreen
    expect(first_graph_svg).not_to_have_attribute("width", "79pt")
    expect(first_graph_svg).not_to_have_attribute("height", "116pt")

    def check_dimensions():
        svg_dimensions = first_graph_svg.bounding_box()
        return svg_dimensions["width"] == 1256 and svg_dimensions["height"] == 662

    wait_until(app, check_dimensions)

    assert_snapshot(first_graph_svg, name="st_graphviz-fullscreen")


def test_first_graph_after_exit_fullscreen(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test if the first graph has correct size after exiting fullscreen."""

    first_graph_svg = get_first_graph_svg(app)
    expect(first_graph_svg).to_have_attribute("width", "79pt")
    first_graph_svg.hover()

    # Enter and exit fullscreen
    click_fullscreen(app)
    # in fullscreen mode, the width attribute is removed. Wait for this to
    # avoid flakiness.
    expect(first_graph_svg).not_to_have_attribute("width", "79pt")
    click_fullscreen(app)

    expect(first_graph_svg).to_have_attribute("width", "79pt")
    expect(first_graph_svg).to_have_attribute("height", "116pt")
    assert_snapshot(first_graph_svg, name="st_graphviz-after_exit_fullscreen")


def test_renders_with_specified_engines(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test if it renders with specified engines."""

    engines = ["dot", "neato", "twopi", "circo", "fdp", "osage", "patchwork"]
    radio_group = app.get_by_test_id("stRadio")
    radios = radio_group.get_by_role("radio")
    expect(radios).to_have_count(len(engines))

    for engine in engines:
        get_radio_button(radio_group, engine).click(force=True)
        wait_for_app_run(app)
        expect(app.get_by_test_id("stMarkdown").nth(0)).to_have_text(engine)

        assert_snapshot(
            app.get_by_test_id("stGraphVizChart").nth(2).locator("svg"),
            name=f"st_graphviz_chart_engine-{engine}",
        )


def test_dot_string(app: Page, assert_snapshot: ImageCompareFunction):
    """Test if it renders charts when input is a string (dot language)."""

    title = app.locator(".stGraphVizChart > svg > g > title").nth(5)
    expect(title).to_have_text("Dot")

    assert_snapshot(
        app.get_by_test_id("stGraphVizChart").nth(5).locator("svg"),
        name="st_graphviz-chart_dot_string",
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stGraphVizChart")


def test_use_container_width_true(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that it renders correctly with use_container_width=True."""
    assert_snapshot(
        app.get_by_test_id("stGraphVizChart").nth(6).locator("svg"),
        name="st_graphviz_chart_use_container_width_true",
    )


================================================
File: /e2e_playwright/st_heading.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.title(":material/info: This title is awesome!")
st.title("This title is awesome too!", help="Some help tooltip", anchor="awesome-title")
st.title("`Code` - Title with hidden Anchor", anchor=False)
st.title("a [link](#test)")
# Foreign language titles and anchors
st.title("日本語タイトル")
st.title("その他の邦題", anchor="アンカー")

st.header(":material/info: This header is awesome!")
st.header("This header is awesome too!", anchor="awesome-header")
st.header("This header with hidden anchor is awesome tooooo!", anchor=False)
st.header("header with help", help="Some help tooltip")
st.header(
    "header with help and hidden anchor",
    help="Some help tooltip",
    anchor=False,
)

st.subheader(":material/info: This subheader is awesome!")
st.subheader("This subheader is awesome too!", anchor="awesome-subheader")
st.subheader("`Code` - Subheader without Anchor")
st.subheader(
    """`Code` - Subheader with Anchor [test_link](href)""",
    anchor="subheader",
)
st.subheader("Subheader with hidden Anchor", anchor=False)
st.subheader("Subheader with help", help="Some help tooltip")
st.subheader(
    "Subheader with help and hidden anchor", help="Some help tooltip", anchor=False
)

# Test dividers
colors = ["blue", "gray", "green", "grey", "orange", "rainbow", "red", "violet"]
lorem_ipsum_text = "Lorem ipsum dolor sit amet, consectetur adipiscing elit"
# Headers with specified color
for color in colors:
    st.header(f"{color.capitalize()} Header Divider:", divider=color)
    st.write(lorem_ipsum_text)
# Subheaders with specified color
for color in colors:
    st.subheader(f"{color.capitalize()} Subheader Divider:", divider=color)
    st.write(lorem_ipsum_text)

# Empty subheader to test correct anchor behavior:
st.subheader("")


================================================
File: /e2e_playwright/st_heading_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

import pytest
from playwright.sync_api import Locator, Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_loaded
from e2e_playwright.shared.app_utils import check_top_level_class, expect_help_tooltip


def _get_title_elements(app: Page) -> Locator:
    """Title elements are rendered as h1 elements"""
    return app.get_by_test_id("stHeading").locator("h1")


def _get_header_elements(app: Page) -> Locator:
    """Header elements are rendered as h2 elements"""
    return app.get_by_test_id("stHeading").locator("h2")


def _get_subheader_elements(app: Page) -> Locator:
    """Subheader elements are rendered as h3 elements"""
    return app.get_by_test_id("stHeading").locator("h3")


_header_divider_filter_text = re.compile(r"[a-zA-Z]+ Header Divider:")
_subheader_divider_filter_text = re.compile(r"[a-zA-Z]+ Subheader Divider:")


def test_correct_number_and_content_of_title_elements(app: Page):
    """Test that correct number of st.title (=> h1) exist with the right content"""
    titles = _get_title_elements(app)
    expect(titles).to_have_count(6)

    expect(titles.nth(0)).to_have_text("info This title is awesome!")
    expect(titles.nth(1)).to_have_text("This title is awesome too!")
    expect(titles.nth(2)).to_have_text("Code - Title with hidden Anchor")
    expect(titles.nth(3)).to_have_text("a link")
    expect(titles.nth(4)).to_have_text("日本語タイトル")
    expect(titles.nth(5)).to_have_text("その他の邦題")


def test_correct_number_and_content_of_header_elements(app: Page):
    """Test that correct number of st.header (=> h2) exist with the right content"""
    headers = _get_header_elements(app).filter(has_not_text=_header_divider_filter_text)
    expect(headers).to_have_count(5)

    expect(headers.nth(0)).to_have_text("info This header is awesome!")
    expect(headers.nth(1)).to_have_text("This header is awesome too!")
    expect(headers.nth(2)).to_have_text(
        "This header with hidden anchor is awesome tooooo!"
    )


def test_correct_number_and_content_of_subheader_elements(app: Page):
    """Test that correct number of st.subheader (=> h3) exist with the right content"""
    subheaders = _get_subheader_elements(app).filter(
        has_not_text=_subheader_divider_filter_text
    )
    expect(subheaders).to_have_count(8)

    expect(subheaders.nth(0)).to_have_text("info This subheader is awesome!")
    expect(subheaders.nth(1)).to_have_text("This subheader is awesome too!")
    expect(subheaders.nth(2)).to_have_text("Code - Subheader without Anchor")
    expect(subheaders.nth(3)).to_have_text("Code - Subheader with Anchor test_link")
    expect(subheaders.nth(4)).to_have_text("Subheader with hidden Anchor")


def test_display_titles_with_anchors(app: Page):
    titles = _get_title_elements(app)

    expect(titles.nth(0)).to_have_id("info-this-title-is-awesome")
    expect(titles.nth(1)).to_have_id("awesome-title")
    expect(titles.nth(2)).to_have_id("code-title-with-hidden-anchor")
    expect(titles.nth(3)).to_have_id("a-link")
    # the id is generated based on the title
    expect(titles.nth(4)).to_have_id("d3b04b7a")
    expect(titles.nth(5)).to_have_id("アンカー")


def test_display_headers_with_anchors_and_style_icons(app: Page):
    headers = _get_header_elements(app)

    first_header = headers.nth(0)
    expect(first_header).to_have_id("info-this-header-is-awesome")
    expect(first_header.locator("svg")).to_be_attached()
    expect(first_header.locator("a")).to_have_attribute(
        "href", "#info-this-header-is-awesome"
    )

    second_header = headers.nth(1)
    expect(second_header).to_have_id("awesome-header")
    expect(second_header.locator("svg")).to_be_attached()
    expect(second_header.locator("a")).to_have_attribute("href", "#awesome-header")

    third_header = headers.nth(2)
    expect(third_header).to_have_id("this-header-with-hidden-anchor-is-awesome-tooooo")
    expect(third_header.locator("svg")).not_to_be_attached()


def test_display_subheaders_with_anchors_and_style_icons(app: Page):
    headers = _get_subheader_elements(app)

    first_header = headers.nth(0)
    expect(first_header).to_have_id("info-this-subheader-is-awesome")
    expect(first_header.locator("svg")).to_be_attached()
    expect(first_header.locator("a")).to_have_attribute(
        "href", "#info-this-subheader-is-awesome"
    )

    second_header = headers.nth(1)
    expect(second_header).to_have_id("awesome-subheader")
    expect(second_header.locator("svg")).to_be_attached()
    expect(second_header.locator("a")).to_have_attribute("href", "#awesome-subheader")

    third_header = headers.nth(4)
    expect(third_header).to_have_id("subheader-with-hidden-anchor")
    expect(third_header.locator("svg")).not_to_be_attached()


def test_clicking_on_anchor_changes_url(app: Page):
    import re

    headers = _get_header_elements(app)
    first_header = headers.nth(0)
    first_header.hover()
    link = first_header.locator("a")
    expect(link).to_have_attribute("href", "#info-this-header-is-awesome")
    link.click()
    expect(app).to_have_url(re.compile(".*#info-this-header-is-awesome"))


def test_headers_snapshot_match(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    headers = _get_header_elements(themed_app)

    assert_snapshot(headers.nth(0), name="st_header-simple")
    assert_snapshot(headers.nth(3), name="st_header-with_help")


def test_headers_hovered_snapshot_match(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    headers = _get_header_elements(themed_app)
    header = headers.nth(0)
    link_container = header.get_by_test_id("stHeaderActionElements").locator("a")
    expect(link_container).to_have_css("visibility", "hidden")
    header.hover()
    expect(link_container).to_have_css("visibility", "visible")
    assert_snapshot(header, name="st_header-hover_with_visible_anchor")

    header = headers.nth(3)
    link_container = header.get_by_test_id("stHeaderActionElements").locator("a")
    expect(link_container).to_have_css("visibility", "hidden")
    header.hover()
    expect(link_container).to_have_css("visibility", "visible")
    assert_snapshot(header, name="st_header-hover_with_help_and_anchor")

    header = headers.nth(4)
    link_container = header.get_by_test_id("stHeaderActionElements").locator("a")
    expect(link_container).not_to_be_attached()
    assert_snapshot(header, name="st_header-hover_with_help_and_hidden_anchor")


def test_subheaders_snapshot_match(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    headers = _get_subheader_elements(themed_app)

    assert_snapshot(headers.nth(0), name="st_subheader-simple")
    assert_snapshot(headers.nth(5), name="st_subheader-with_code_and_help")


def test_subheaders_hovered_snapshot_match(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    headers = _get_subheader_elements(themed_app)
    header = headers.nth(0)
    link_container = header.get_by_test_id("stHeaderActionElements").locator("a")
    expect(link_container).to_have_css("visibility", "hidden")
    header.hover()
    expect(link_container).to_have_css("visibility", "visible")
    assert_snapshot(header, name="st_subheader-hover_with_visible_anchor")

    header = headers.nth(5)
    link_container = header.get_by_test_id("stHeaderActionElements").locator("a")
    expect(link_container).to_have_css("visibility", "hidden")
    header.hover()
    expect(link_container).to_have_css("visibility", "visible")
    assert_snapshot(header, name="st_subheader-hover_with_help_and_anchor")

    header = headers.nth(6)
    link_container = header.get_by_test_id("stHeaderActionElements").locator("a")
    expect(link_container).not_to_be_attached()
    assert_snapshot(header, name="st_subheader-hover_with_help_and_hidden_anchor")


def test_links_are_rendered_correctly_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    wait_for_app_loaded(themed_app)
    link = themed_app.get_by_text("a link")
    link.scroll_into_view_if_needed()
    expect(link).to_have_count(1)
    expect(link).to_be_visible()
    assert_snapshot(link, name="st_header-title_with_link")


_number_of_colors = 8


@pytest.mark.parametrize("color_index", range(_number_of_colors))
def test_header_divider_snapshot(
    app: Page, assert_snapshot: ImageCompareFunction, color_index: int
):
    """Test that st.header renders correctly with dividers."""
    header_divider_elements = _get_header_elements(app).filter(
        has_text=_header_divider_filter_text
    )
    expect(header_divider_elements).to_have_count(_number_of_colors)
    header_divider_element = header_divider_elements.nth(color_index)
    header_divider_element.scroll_into_view_if_needed()
    assert_snapshot(
        header_divider_element,
        name=f"st_header-divider_{color_index}",
    )


@pytest.mark.parametrize("color_index", range(_number_of_colors))
def test_subheader_divider_snapshot(
    app: Page, assert_snapshot: ImageCompareFunction, color_index: int
):
    """Test that st.subheader renders correctly with dividers."""
    subheader_divider_elements = _get_subheader_elements(app).filter(
        has_text=_subheader_divider_filter_text
    )
    expect(subheader_divider_elements).to_have_count(_number_of_colors)
    subheader_divider_element = subheader_divider_elements.nth(color_index)
    subheader_divider_element.scroll_into_view_if_needed()
    assert_snapshot(
        subheader_divider_element,
        name=f"st_subheader-divider_{color_index}",
    )


def test_help_tooltip_works(app: Page):
    """Test that the help tooltip is displayed on hover."""
    header_with_help = _get_header_elements(app).nth(3)

    tooltip_text = "Some help tooltip"
    expect_help_tooltip(app, header_with_help, tooltip_text)

    subheader_with_help = _get_subheader_elements(app).nth(5)
    expect_help_tooltip(app, subheader_with_help, tooltip_text)

    title_with_help = _get_title_elements(app).nth(1)
    expect_help_tooltip(app, title_with_help, tooltip_text)


def test_not_scrolled_on_empty_anchor_tag(app: Page):
    """Test that the page is not scrolled when the page contains an empty
    header/anchor tag and no window hash."""

    # Check if the page is still scrolled to the top
    # after one second timeout.
    app.wait_for_timeout(1000)
    scroll_position = app.evaluate("window.scrollY")
    # Usage of assert is fine here since we just need to verify that
    # this is still scrolled to top, no need to wait for this to happen.
    assert scroll_position == 0


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stHeading")


================================================
File: /e2e_playwright/st_help.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit.elements.doc_string import _get_scriptrunner_frame

if _get_scriptrunner_frame() is None:
    st.warning(
        """
        You're running this script in an `exec` context, so the `foo` part
        of `st.help(foo)` will not appear inside the displayed `st.help` element.
        """
    )


# Testing case where there are no docs.
class FooWithNoDocs:
    my_static_var_1 = 123


st.container(key="help_no_docs").help(FooWithNoDocs)

# Testing case where there are no members.
st.container(key="help_globals").help(globals)


# Test case where there the docs need to scroll
class FooWithLongDocs:
    """My docstring.

    This is a very long one! You probably need to scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll.

    Scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll.

    Scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll.

    Scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll.

    Scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll,
    scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll, scroll.
    """

    def __init__(self):
        self.my_var_1 = 123


f = FooWithLongDocs()

st.container(key="help_long_docs").help(f)


class FooWithMixedDocs:
    """My docstring."""

    def __init__(self):
        self.my_var_1 = 123

    def my_func_1(self, a, b=False):
        "Func with doc."

    def my_func_2(self):
        # Func without doc.
        pass


st.container(key="help_mixed_docs").help(FooWithMixedDocs())


================================================
File: /e2e_playwright/st_help_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from playwright.sync_api import Locator, Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class, get_element_by_key


def _get_keyed_help_element(app: Page, key: str) -> Locator:
    """Get a help element in a keyed container."""
    element = get_element_by_key(app, key).get_by_test_id("stHelp").first
    expect(element).to_be_visible()
    element.scroll_into_view_if_needed()
    return element


def test_help_display(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.header renders correctly with dividers."""
    help_elements = app.get_by_test_id("stHelp")
    expect(help_elements).to_have_count(4)
    assert_snapshot(
        _get_keyed_help_element(app, "help_no_docs"),
        name="st_help-class_no_docs",
    )
    assert_snapshot(
        _get_keyed_help_element(app, "help_globals"),
        name="st_help-globals",
    )
    assert_snapshot(
        _get_keyed_help_element(app, "help_long_docs"),
        name="st_help-long_docs",
    )
    assert_snapshot(
        _get_keyed_help_element(app, "help_mixed_docs"),
        name="st_help-mixed_docs",
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stHelp")


================================================
File: /e2e_playwright/st_html.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from pathlib import Path

import streamlit as st

# Construct test assets path relative to this script file to
# allow its execution with different working directories.
TEST_ASSETS_DIR = Path(__file__).parent / "test_assets"

# Test that we can render HTML with in-line styles
st.html(
    """
    <div style="font-family: 'Comic Sans MS'; color: orange">
        This is a div with some inline styles.
    </div>
    """
)

# Test that script tags are sanitized
st.html(
    """
    <i> This is a i tag </i>
    <script>
        alert('BEWARE - the script tag is scripting');
    </script>
    <strong> This is a strong tag </strong>
    """
)

# Test that style tags are applied
st.html(
    """
    <style>
        #corgi {
            color:blue;
        }
    </style>
    <div id="corgi">This text should be blue</div>
    """
)

# Test that non-rendered HTML doesn't cause extra spacing
st.write("Before tag:")
st.html(
    """
    <style>
        #random {
            color:blue;
        }
    </style>
    """
)
st.write("After tag")

# Test that we can load HTML files from str paths
HTML_PATH = TEST_ASSETS_DIR / "test_div.html"
st.html(str(HTML_PATH))

# Test that we can load HTML files from Path objects
st.html(HTML_PATH)


================================================
File: /e2e_playwright/st_html_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class


def test_html_in_line_styles(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that html renders correctly using snapshot testing."""
    html_elements = themed_app.get_by_test_id("stHtml")
    expect(html_elements).to_have_count(6)
    first_html = html_elements.nth(0)

    expect(first_html).to_have_text("This is a div with some inline styles.")

    styled_div = first_html.locator("div")
    expect(styled_div).to_have_css("color", "rgb(255, 165, 0)")
    assert_snapshot(first_html, name="st_html-inline_styles")


def test_html_sanitization(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that html sanitizes script tags correctly."""
    html_elements = themed_app.get_by_test_id("stHtml")
    expect(html_elements).to_have_count(6)
    second_html = html_elements.nth(1)

    expect(second_html).to_contain_text("This is a i tag")
    expect(second_html).to_contain_text("This is a strong tag")
    expect(second_html.locator("script")).to_have_count(0)
    assert_snapshot(second_html, name="st_html-script_tags")


def test_html_style_tags(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that html style tags are applied correctly."""
    html_elements = themed_app.get_by_test_id("stHtml")
    expect(html_elements).to_have_count(6)
    third_html = html_elements.nth(2)

    expect(third_html).to_have_text("This text should be blue")
    expect(third_html.locator("div")).to_have_css("color", "rgb(0, 0, 255)")
    assert_snapshot(third_html, name="st_html-style_tags")


def test_html_style_tag_spacing(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that non-rendered html doesn't cause unnecessary spacing."""
    html_elements = themed_app.get_by_test_id("stHtml")
    expect(html_elements).to_have_count(6)

    assert_snapshot(
        themed_app.get_by_test_id("stVerticalBlock"), name="st_html-style_tag_spacing"
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stHtml")


def test_html_from_file_str(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that we can load HTML files from str paths."""
    html_elements = app.get_by_test_id("stHtml")
    expect(html_elements).to_have_count(6)
    assert_snapshot(html_elements.nth(4), name="st_html-file_str")


def test_html_from_file_path(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that we can load HTML files from Path objects."""
    html_elements = app.get_by_test_id("stHtml")
    expect(html_elements).to_have_count(6)
    assert_snapshot(html_elements.nth(5), name="st_html-file_path")


================================================
File: /e2e_playwright/st_image.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import io
from pathlib import Path
from typing import TYPE_CHECKING, Any

import numpy as np
from PIL import Image, ImageDraw

import streamlit as st

if TYPE_CHECKING:
    import numpy.typing as npt


# Construct test assets path relative to this script file to
# allow its execution with different working directories.
TEST_ASSETS_DIR = Path(__file__).parent / "test_assets"

img = np.repeat(0, 10000).reshape(100, 100)
img800 = np.repeat(0, 640000).reshape(800, 800)


st.header("Images from numpy arrays")

st.image(img, caption="Black Square as JPEG.", output_format="JPEG", width=100)

st.image(img, caption="Black Square as PNG.", output_format="PNG", width=100)

st.image(img, caption="Black Square with no output format specified.", width=100)

transparent_img: "npt.NDArray[Any]" = np.zeros((100, 100, 4), dtype=np.uint8)
st.image(transparent_img, caption="Transparent Black Square.", width=100)

st.header("GIF images")


def create_gif(size, frames=1):
    # Create grayscale image.
    im = Image.new("L", (size, size), "white")

    images = []

    # Make circle of a constant size with a number of frames, moving across the
    # principal diagonal of a 64x64 image. The GIF will not loop and stops
    # animating after frames x 100ms.
    for i in range(frames):
        frame = im.copy()
        draw = ImageDraw.Draw(frame)
        pos = (i, i)
        circle_size = size / 2
        draw.ellipse([pos, tuple(p + circle_size for p in pos)], "black")
        images.append(frame.copy())

    # Save the frames as an animated GIF
    data = io.BytesIO()
    images[0].save(
        data,
        format="GIF",
        save_all=True,
        append_images=images[1:],
        duration=1,
    )

    return data.getvalue()


gif = create_gif(64, frames=32)

st.image(gif, caption="Moving black circle.", width=100)
st.image(create_gif(64), caption="Black Circle as GIF.", width=100)
st.image(gif, caption="GIF as PNG.", output_format="PNG", width=100)

st.header("SVG images")

st.image(
    """<?xml version="1.0" encoding="utf-8"?>
    <!-- Generator: Adobe Illustrator 17.1.0, SVG Export Plug-In . SVG Version: 6.00 Build 0)  -->
    <!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
    <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="500" height="100">
    <text x="0" y="50">"I am prefixed with some meta tags</text>
    </svg>
""",
    caption="Text SVG with meta tags.",
)


st.image(
    """
<svg>
  <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
  Sorry, your browser does not support inline SVG.
</svg>
""",
    caption="Red Circle.",
)

SVG_RED_CIRCLE = """
<svg width="100" height="100" xmlns="http://www.w3.org/2000/svg">
  <circle cx="50" cy="50" r="40" stroke="black" stroke-width="3" fill="red" />
  Sorry, your browser does not support inline SVG.
</svg>
"""

st.image(SVG_RED_CIRCLE, caption="Red Circle with internal dimensions.")
st.image(SVG_RED_CIRCLE, width=300, caption="Red Circle with width 300.")


SVG_YELLOW_GREEN_RECTANGLE = """
<svg viewBox="{x} 0 100 90" xmlns="http://www.w3.org/2000/svg">
    <rect x="0" y="0" width="100" height="90" fill="yellow" />
    <rect x="100" y="0" width="100" height="90" fill="green" />
</svg>
"""

st.image(
    SVG_YELLOW_GREEN_RECTANGLE.format(x=50),
    width=100,
    caption="Yellow Green Rectangle with x 50.",
)
st.image(
    SVG_YELLOW_GREEN_RECTANGLE.format(x=50),
    width=300,
    caption="Yellow Green Rectangle with x 50 and width 300.",
)

st.image(
    SVG_YELLOW_GREEN_RECTANGLE.format(x=0),
    width=100,
    caption="Yellow Green Rectangle with x 0.",
)
st.image(
    SVG_YELLOW_GREEN_RECTANGLE.format(x=0),
    width=300,
    caption="Yellow Green Rectangle with x 0 and width 300.",
)

st.image(
    SVG_YELLOW_GREEN_RECTANGLE.format(x=100),
    width=100,
    caption="Yellow Green Rectangle with x 100.",
)
st.image(
    SVG_YELLOW_GREEN_RECTANGLE.format(x=100),
    width=300,
    caption="Yellow Green Rectangle with x 100 and width 300.",
)

st.header("Image from file (str and Path)")

CAT_IMAGE = TEST_ASSETS_DIR / "cat.jpg"
st.image(str(CAT_IMAGE), caption="Image from jpg file (str).", width=200)
st.image(CAT_IMAGE, caption="Image from jpg file (Path).", width=200)

st.header("channels parameter")

red_image = Image.new("RGB", (100, 100), color="red")
red_bgr_img = np.array(red_image)[..., ["BGR".index(s) for s in "RGB"]]
st.image(red_bgr_img, caption="BGR channel (red).", channels="BGR", width=100)
st.image(red_bgr_img, caption="RGB channel (blue).", channels="RGB", width=100)

st.header("use_column_width parameter (deprecated)")

col1, col2, col3, col4 = st.columns(4)
col1.image(img)  # 100 px
col1.image(img, use_column_width="auto")  # 100 px
col1.image(img, use_column_width="never")  # 100 px
col1.image(img, use_column_width=False)  # 100 px

col2.image(img, use_column_width="always")  # column width
col2.image(img, use_column_width=True)  # column width
col2.image(img800, use_column_width="auto")  # column width

st.header("List of images")

st.image(
    [
        Image.new("RGB", (64, 64), color="red"),
        Image.new("RGB", (64, 64), color="blue"),
        Image.new("RGB", (64, 64), color="green"),
    ],
    caption=[f"Image list {i}" for i in range(3)],
)

st.header("use_container_width parameter")


col5, col6, col7, col8 = st.columns(4)


# Full container width, since use_container_width is explicitly set to True
col5.image(img, use_container_width=True, width=50)
# Full container width
col5.image(img, use_container_width=True)
# Full container width, since 1000 would overflow the container
col5.image(
    img800,
    width=1000,
)

# Full container width, since 800 would overflow the container
col6.image(img800)
# Full container width, since 800 would overflow the container
col6.image(img800, use_container_width=True)
# Full container width, since 800 would overflow the container
col6.image(img800, use_container_width=False)


col7.image(img)  # 100 px
# 100 px since that is the width of the image, and it does not exceed the container width
col7.image(img, use_container_width=False)
# 50 px since the width parameter is given
col7.image(img, width=50)
# 50 px since the width parameter is given, and use_container_width is not True
col7.image(img, use_container_width=False, width=50)


st.image(
    [img, img, img, img, img],
    caption=[f"Overflow {i}" for i in range(5)],
    width=200,
)


================================================
File: /e2e_playwright/st_image_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class, get_image


def test_image_display(app: Page):
    first_image = get_image(app, "Black Square as JPEG.").locator("img")
    expect(first_image).to_have_css("height", "100px")
    expect(first_image).to_have_css("width", "100px")


def test_image_caption(app: Page):
    caption = (
        get_image(app, "Black Square as JPEG.").get_by_test_id("stImageCaption").first
    )
    expect(caption).to_contain_text("Black Square")
    expect(caption).to_have_css("width", "100px")


def test_image_and_caption_together(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    first_image = get_image(themed_app, "Black Square as JPEG.").get_by_test_id(
        "stImageContainer"
    )
    assert_snapshot(first_image, name="st_image-with_caption")


def test_image_formats(app: Page):
    expect(get_image(app, "Black Square as JPEG.").locator("img")).to_have_attribute(
        "src", re.compile(r"^.*\.jpg$")
    )
    expect(get_image(app, "Black Square as PNG.").locator("img")).to_have_attribute(
        "src", re.compile(r"^.*\.png$")
    )
    expect(
        get_image(app, "Black Square with no output format specified.").locator("img")
    ).to_have_attribute("src", re.compile(r"^.*\.jpg$"))
    expect(
        get_image(app, "Transparent Black Square.").locator("img")
    ).to_have_attribute("src", re.compile(r"^.*\.png$"))

    expect(
        get_image(app, "Image from jpg file (str).").locator("img")
    ).to_have_attribute("src", re.compile(r"^.*\.jpg$"))

    expect(
        get_image(app, "Image from jpg file (Path).").locator("img")
    ).to_have_attribute("src", re.compile(r"^.*\.jpg$"))

    # GIF:
    expect(get_image(app, "Black Circle as GIF.").locator("img")).to_have_attribute(
        "src", re.compile(r"^.*\.gif$")
    )
    expect(get_image(app, "GIF as PNG.").locator("img")).to_have_attribute(
        "src", re.compile(r"^.*\.png$")
    )


def test_use_column_width_parameter(app: Page, assert_snapshot: ImageCompareFunction):
    columns_container = app.get_by_test_id("stHorizontalBlock").first
    columns_container.scroll_into_view_if_needed()
    assert_snapshot(columns_container, name="st_image-use_column_width")

    expect(app.get_by_test_id("stMainBlockContainer")).to_contain_text(
        "The use_column_width parameter has been deprecated and will be removed in a future release. Please utilize the use_container_width parameter instead."
    )


def test_st_image_use_container_width_parameter(
    app: Page, assert_snapshot: ImageCompareFunction
):
    columns_container = app.get_by_test_id("stHorizontalBlock").nth(1)
    columns_container.scroll_into_view_if_needed()
    assert_snapshot(columns_container, name="st_image-use_container_width")


def test_fullscreen_button_exists(app: Page):
    """Test that element has the fullscreen button."""
    expect(app.get_by_role("button", name="Fullscreen").first).to_be_attached()


def test_image_from_file_str(app: Page, assert_snapshot: ImageCompareFunction):
    image = get_image(app, "Image from jpg file (str).").locator("img")
    expect(image).to_have_css("width", "200px")
    expect(image).to_have_attribute("src", re.compile(r"^.*\.jpg$"))
    assert_snapshot(image, name="st_image-image_from_file_str")


def test_image_from_file_path(app: Page, assert_snapshot: ImageCompareFunction):
    image = get_image(app, "Image from jpg file (Path).").locator("img")
    expect(image).to_have_css("width", "200px")
    expect(image).to_have_attribute("src", re.compile(r"^.*\.jpg$"))
    assert_snapshot(image, name="st_image-image_from_file_path")


def test_gif_image(app: Page, assert_snapshot: ImageCompareFunction):
    gif_image = get_image(app, "Black Circle as GIF.").locator("img")
    expect(gif_image).to_have_css("height", "100px")
    expect(gif_image).to_have_css("width", "100px")
    expect(gif_image).to_have_attribute("src", re.compile(r"^.*\.gif$"))

    assert_snapshot(gif_image, name="st_image-gif_image")


def test_svg_images(app: Page, assert_snapshot: ImageCompareFunction):
    # Test "Text SVG with meta tags"
    meta_tag_svg = get_image(app, "Text SVG with meta tags.").locator("img")
    expect(meta_tag_svg).to_have_css("max-width", "100%")
    assert_snapshot(meta_tag_svg, name="st_image-svg_with_meta_tags")

    # TODO(lukasmasuch): This svg does not correctly work in Safari and Firefox
    # Test "Red Circle"
    # red_circle = get_image(app, "Red Circle.").locator("img")
    # expect(red_circle).to_have_css("max-width", "100%")
    # assert_snapshot(red_circle, name="st_image-svg_red_circle")

    # Test "Red Circle with internal dimensions"
    red_circle_internal_dim = get_image(
        app, "Red Circle with internal dimensions."
    ).locator("img")
    expect(red_circle_internal_dim).to_have_css("max-width", "100%")
    assert_snapshot(
        red_circle_internal_dim, name="st_image-svg_red_circle_internal_dim"
    )

    # Test "Red Circle with width 300"
    red_circle_300 = get_image(app, "Red Circle with width 300.").locator("img")
    expect(red_circle_300).to_have_css("width", "300px")
    assert_snapshot(red_circle_300, name="st_image-svg_red_circle_300")

    # Test Yellow Green Rectangle variations
    ygr_50 = get_image(app, "Yellow Green Rectangle with x 50.").locator("img")
    expect(ygr_50).to_have_css("width", "100px")
    assert_snapshot(ygr_50, name="st_image-svg_yellow_green_rectangle_50")

    ygr_50_300 = get_image(
        app, "Yellow Green Rectangle with x 50 and width 300."
    ).locator("img")
    expect(ygr_50_300).to_have_css("width", "300px")
    assert_snapshot(ygr_50_300, name="st_image-svg_yellow_green_rectangle_50_300")

    # Test yellow rectangle (respects viewbox)
    ygr_0 = get_image(app, "Yellow Green Rectangle with x 0.").locator("img")
    expect(ygr_0).to_have_css("width", "100px")
    assert_snapshot(ygr_0, name="st_image-svg_yellow_green_rectangle_0")

    ygr_0_300 = get_image(
        app, "Yellow Green Rectangle with x 0 and width 300."
    ).locator("img")
    expect(ygr_0_300).to_have_css("width", "300px")
    assert_snapshot(ygr_0_300, name="st_image-svg_yellow_green_rectangle_0_300")

    ygr_100 = get_image(app, "Yellow Green Rectangle with x 100.").locator("img")
    expect(ygr_100).to_have_css("width", "100px")
    assert_snapshot(ygr_100, name="st_image-svg_yellow_green_rectangle_100")

    ygr_100_300 = get_image(
        app, "Yellow Green Rectangle with x 100 and width 300."
    ).locator("img")
    expect(ygr_100_300).to_have_css("width", "300px")
    assert_snapshot(ygr_100_300, name="st_image-svg_yellow_green_rectangle_100_300")


def test_channels_parameter(app: Page, assert_snapshot: ImageCompareFunction):
    bgr_image = get_image(app, "BGR channel (red).").locator("img")
    assert_snapshot(bgr_image, name="st_image-channels_bgr_red")

    rgb_image = get_image(app, "RGB channel (blue).").locator("img")
    assert_snapshot(rgb_image, name="st_image-channels_rgb_blue")


def test_image_list(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.image can display a list of images."""
    image_list = get_image(app, "Image list")
    assert_snapshot(image_list, name="st_image-image_list")


def test_image_list_overflow(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.image can display a list of images."""
    image_list = get_image(app, "Overflow")
    assert_snapshot(image_list, name="st_image-image_list_overflow")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stImage")


================================================
File: /e2e_playwright/st_json.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.subheader("Simple dict:")
st.json({"foo": "bar"})

st.subheader("Collapsed")
st.json({"foo": "bar"}, expanded=False)

st.subheader("Keep whitespaces:")
st.json({"Hello     World": "Foo    Bar"})

st.subheader("Complex dict:")
st.json(
    {
        "array": [1, 2],
        "boolean": True,
        "null": None,
        "integer": 123,
        "float": 123.45,
        "object": {"a": "b", "c": "d"},
        "string": "Hello World",
    }
)

st.subheader("Simple List:")
st.json(["a", "b"])

st.subheader("Empty dict:")
st.json({})

st.subheader("Expand to depth of 2:")
st.json(
    {
        "level1": {
            "level2": {"level3": {"a": "b"}},
            "c": "d",
            "list": [{"list_item": "value"}],
        },
        "string": "Hello World",
    },
    expanded=2,
)

st.subheader("Keeps container bounds:")

col1, col2 = st.container(key="container_with_json").columns(2)

with col1.container(border=True):
    st.json(
        {
            "foo": "a" * 100,
            "bar": "this is a very long string that will not fit in the column and will cause it to wrap",
        }
    )


================================================
File: /e2e_playwright/st_json_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class, get_element_by_key


def test_st_json_displays_correctly(app: Page, assert_snapshot: ImageCompareFunction):
    """Test st.json renders the data correctly."""
    json_elements = app.get_by_test_id("stJson")
    expect(json_elements).to_have_count(8)

    assert_snapshot(json_elements.nth(0), name="st_json-simple_dict")
    assert_snapshot(json_elements.nth(1), name="st_json-collapsed")
    assert_snapshot(json_elements.nth(2), name="st_json-with_white_spaces")
    # The complex dict is screenshot tested in the themed test below
    assert_snapshot(json_elements.nth(4), name="st_json-simple_list")
    assert_snapshot(json_elements.nth(5), name="st_json-empty_dict")
    assert_snapshot(json_elements.nth(6), name="st_json-expanded_2")
    # The container bounds test is screenshot tested in another test below


def test_st_json_keeps_container_bounds(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test st.json keeps the container bounds."""
    container_with_json = get_element_by_key(app, "container_with_json")
    expect(container_with_json.get_by_test_id("stJson")).to_have_count(1)
    assert_snapshot(container_with_json, name="st_json-keep_bounds")


def test_st_json_displays_correctly_when_themed(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test st.json uses renders the data correctly with different themes."""
    json_elements = themed_app.get_by_test_id("stJson")
    assert_snapshot(json_elements.nth(3), name="st_json-complex_dict")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stJson")


def test_shows_copy_icon(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that the copy icon is shown by hovering over the element."""
    json_element = themed_app.get_by_test_id("stJson").first
    expect(json_element).to_be_visible()
    json_element.hover()

    assert_snapshot(json_element, name="st_json-copy_icon_on_hover")


================================================
File: /e2e_playwright/st_line_chart.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from datetime import date

import numpy as np
import pandas as pd

import streamlit as st

np.random.seed(0)


data = np.random.randn(20, 3)
df = pd.DataFrame(data, columns=["a", "b", "c"])

# st.area/bar/line_chart all use Altair/Vega-Lite under the hood.
# By default, Vega-Lite displays time values in the browser's local
# time zone, but data is sent down to the browser as UTC. This means
# Times need to be set correctly to the users timezone.
utc_df = pd.DataFrame(
    {
        "index": [
            date(2019, 8, 9),
            date(2019, 8, 10),
            date(2019, 8, 11),
            date(2019, 8, 12),
        ],
        "numbers": [10, 50, 30, 40],
    }
)

utc_df.set_index("index", inplace=True)

# Dataframe to test the color parameter support:
N = 100

color_df = pd.DataFrame(
    {
        # Using a negative range so certain kinds of bugs are more visible.
        "a": -np.arange(N),
        "b": np.random.rand(N) * 10,
        "c": np.random.rand(N) * 10,
        "d": np.random.randn(N) * 30,
        "e": ["bird" if x % 2 else "airplane" for x in range(N)],
    }
)

st.header("Line Chart")

st.line_chart()
st.line_chart(df)
st.line_chart(df, x="a")
st.line_chart(df, y="a")
st.line_chart(df, y=["a", "b"])
st.line_chart(df, x="a", y="b", height=500, width=300, use_container_width=False)
st.line_chart(df, x="b", y="a")
st.line_chart(df, x="a", y=["b", "c"])
st.line_chart(utc_df)
st.line_chart(color_df, x="a", y="b", color="e")
st.line_chart(df, x_label="X Axis Label", y_label="Y Axis Label")


================================================
File: /e2e_playwright/st_line_chart_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction

TOTAL_LINE_CHARTS = 11


def test_line_chart_rendering(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.line_chart renders correctly via snapshot testing."""
    line_chart_elements = app.get_by_test_id("stVegaLiteChart")
    expect(line_chart_elements).to_have_count(TOTAL_LINE_CHARTS)

    # Also make sure that all canvas objects are rendered:
    expect(line_chart_elements.locator("canvas")).to_have_count(TOTAL_LINE_CHARTS)

    for i, element in enumerate(line_chart_elements.all()):
        assert_snapshot(element, name=f"st_line_chart-{i}")


def test_themed_line_chart_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.line_chart renders with different theming."""
    line_chart_elements = themed_app.get_by_test_id("stVegaLiteChart")
    expect(line_chart_elements).to_have_count(TOTAL_LINE_CHARTS)

    # Also make sure that all canvas objects are rendered:
    expect(line_chart_elements.locator("canvas")).to_have_count(TOTAL_LINE_CHARTS)

    # Only test a single chart per built-in chart type:
    assert_snapshot(line_chart_elements.nth(1), name="st_line_chart_themed")


def test_multi_line_hover(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that hovering on a st.line_chart shows chart markers on all lines and
    a tooltip."""

    multi_line_chart = app.get_by_test_id("stVegaLiteChart").nth(1)
    expect(multi_line_chart).to_be_visible()

    multi_line_chart.scroll_into_view_if_needed()
    multi_line_chart.locator("canvas").hover(position={"x": 100, "y": 100}, force=True)

    expect(app.locator("#vg-tooltip-element")).to_be_visible()

    assert_snapshot(multi_line_chart, name="st_line_chart-multi_line_hover")


def test_single_line_hover(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that hovering on a st.line_chart shows chart markers and a tooltip."""

    single_line_chart = app.get_by_test_id("stVegaLiteChart").nth(3)
    expect(single_line_chart).to_be_visible()

    single_line_chart.scroll_into_view_if_needed()
    single_line_chart.locator("canvas").hover(position={"x": 100, "y": 100}, force=True)

    expect(app.locator("#vg-tooltip-element")).to_be_visible()
    assert_snapshot(single_line_chart, name="st_line_chart-single_line_hover")


================================================
File: /e2e_playwright/st_link_button.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.link_button("Default Link", url="https://streamlit.io")

st.link_button("Disabled Link", url="https://streamlit.io", disabled=True)

st.link_button("Primary Link", url="https://streamlit.io", type="primary")

st.link_button(
    "primary disabled",
    url="https://streamlit.io",
    type="primary",
    disabled=True,
)

st.link_button(
    "Container **full width** *markdown*",
    "https://streamlit.io",
    use_container_width=True,
    help="help text",
)

st.link_button(
    "Container **full width** *markdown* ~~primary~~",
    "https://streamlit.io",
    type="primary",
    use_container_width=True,
    help="help text here",
)

st.link_button(
    "Link Button with emoji icon",
    "https://streamlit.io",
    icon="🎈",
)

st.link_button(
    "Link Button with Material icon",
    "https://streamlit.io",
    icon=":material/bolt:",
)

st.link_button("Tertiary link button", url="https://streamlit.io", type="tertiary")

st.link_button(
    "Disabled tertiary link",
    url="https://streamlit.io",
    type="tertiary",
    disabled=True,
)

st.link_button(
    "Tertiary link - container width",
    url="https://streamlit.io",
    type="tertiary",
    use_container_width=True,
)


================================================
File: /e2e_playwright/st_link_button_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class

LINK_BUTTON_ELEMENTS = 11


def test_link_button_display(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.link_button renders correctly."""
    link_elements = themed_app.get_by_test_id("stLinkButton")
    expect(link_elements).to_have_count(LINK_BUTTON_ELEMENTS)

    assert_snapshot(link_elements.nth(0), name="st_link_button-default")
    assert_snapshot(link_elements.nth(1), name="st_link_button-disabled")
    assert_snapshot(link_elements.nth(2), name="st_link_button-primary")
    assert_snapshot(link_elements.nth(3), name="st_link_button-primary_disabled")
    assert_snapshot(link_elements.nth(4), name="st_link_button-container_width")
    assert_snapshot(link_elements.nth(5), name="st_link_button-primary_container_width")
    assert_snapshot(link_elements.nth(6), name="st_link_button-emoji_icon")
    assert_snapshot(link_elements.nth(7), name="st_link_button-material_icon")
    assert_snapshot(link_elements.nth(8), name="st_link_button-tertiary")
    assert_snapshot(link_elements.nth(9), name="st_link_button-tertiary_disabled")
    assert_snapshot(
        link_elements.nth(10), name="st_link_button-tertiary_container_width"
    )


def test_link_button_hover(themed_app: Page, assert_snapshot: ImageCompareFunction):
    link_elements = themed_app.get_by_test_id("stLinkButton")
    expect(link_elements).to_have_count(LINK_BUTTON_ELEMENTS)

    default_link_button = themed_app.get_by_test_id("stLinkButton").nth(0)
    themed_app.get_by_text("Default Link").hover()
    assert_snapshot(default_link_button, name="st_link_button-default_hover")

    primary_link_button = themed_app.get_by_test_id("stLinkButton").nth(2)
    themed_app.get_by_text("Primary Link").hover()
    assert_snapshot(primary_link_button, name="st_link_button-primary_hover")

    tertiary_link_button = themed_app.get_by_test_id("stLinkButton").nth(8)
    themed_app.get_by_text("Tertiary link button").hover()
    assert_snapshot(tertiary_link_button, name="st_link_button-tertiary_hover")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stLinkButton")


================================================
File: /e2e_playwright/st_magic.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""File docstring. Should not be printed."""

import asyncio
import contextlib

async_loop = asyncio.new_event_loop()

# Standalone statements should be printed
"no block"

a = "printed"
"This should be", a

# Standalone statements within blocks should be printed

if True:
    "IF"

if False:
    pass
elif True:
    "ELIF"

if False:
    pass
else:
    "ELSE"


for _ in range(1):
    "FOR"

while True:
    "WHILE"
    break


@contextlib.contextmanager
def context_mgr():
    try:
        yield
    finally:
        pass


with context_mgr():
    "WITH"

try:
    "TRY"
except:
    raise

try:
    raise RuntimeError("shenanigans!")
except RuntimeError:
    "EXCEPT"

try:
    pass
finally:
    "FINALLY"


def func(value):
    value


func("FUNCTION")


async def async_func(value):
    value


async_loop.run_until_complete(async_func("ASYNC FUNCTION"))


async def async_for():
    async def async_iter():
        yield

    async for _ in async_iter():
        "ASYNC FOR"


async_loop.run_until_complete(async_for())


async def async_with():
    @contextlib.asynccontextmanager
    async def async_context_mgr():
        try:
            yield
        finally:
            pass

    async with async_context_mgr():
        "ASYNC WITH"


async_loop.run_until_complete(async_with())

# Docstrings should never be printed


def docstrings():
    """Docstring. Should not be printed."""

    def nested():
        """Multiline docstring.
        Should not be printed."""
        pass

    class Foo:
        """Class docstring. Should not be printed."""

        pass

    nested()


docstrings()


def my_func():
    """my_func: this help block should be printed."""
    pass


my_func


class MyClass:
    """MyClass: this help block should be printed."""

    def __init__(self):
        """This should not be printed."""


MyClass


my_instance = MyClass()
my_instance


================================================
File: /e2e_playwright/st_magic_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from playwright.sync_api import Page, expect


def test_magic_shows_correct_text(app: Page):
    expected = [
        "no block",
        "This should be printed",
        "IF",
        "ELIF",
        "ELSE",
        "FOR",
        "WHILE",
        "WITH",
        "TRY",
        "EXCEPT",
        "FINALLY",
        "FUNCTION",
        "ASYNC FUNCTION",
        "ASYNC FOR",
        "ASYNC WITH",
    ]
    for i in range(len(expected)):
        expect(app.get_by_test_id("stMarkdown").nth(i)).to_have_text(expected[i])


================================================
File: /e2e_playwright/st_map.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import Any, cast

import numpy as np
import pandas as pd

import streamlit as st

"""
### Empty map
"""

st.map()


"""
### Simple map
"""

# Cast is needed due to mypy not understanding the outcome of dividing
# an array by a list of numbers.
np.random.seed(0)
coords: "np.typing.NDArray[np.float64]" = cast(
    Any,
    np.random.randn(1000, 2) / [50, 50],
) + [37.76, -122.4]
simple_map_df = pd.DataFrame(coords, columns=["lat", "lon"])

st.map(simple_map_df)


"""
### Simple map with zoom
"""

st.map(simple_map_df, zoom=8)


"""
### Map with color and size layers
"""

df = pd.DataFrame(
    {
        "xlat": [38.8762997, 38.8742997, 38.9025842],
        "xlon": [-77.0037, -77.0057, -77.0556545],
        "color": ["#f00", "#f0f", "#00f"],
        "size": [1000, 500, 300],
    }
)

st.map(
    df,
    latitude="xlat",
    longitude="xlon",
    color="color",
    size="size",
    use_container_width=False,
)


"""
### Simple map with defined width and height
"""

st.map(simple_map_df, width=200, height=250, use_container_width=False)


================================================
File: /e2e_playwright/st_map_ensure_no_stale_maps.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import numpy as np
import pandas as pd

import streamlit as st

st.write(f"Streamlit version = {st.__version__}")

df1 = pd.DataFrame(
    np.random.randn(10, 2) / [50, 50] + [37.76, -122.4], columns=["lat", "lon"]
)

df2 = pd.DataFrame(
    np.random.randn(10, 2) / [50, 50] + [-37.76, 122.4], columns=["lat", "lon"]
)

option = st.selectbox("which dataframe to use?", ("1", "2"))

st.write("You selected:", option)

df = df1 if option == "1" else df2

st.map(df)
st.write(df)

st.write("df1")
st.map(df1)

st.write("2")
st.map(df2)


================================================
File: /e2e_playwright/st_map_ensure_no_stale_maps_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect


def test_st_map_has_no_stale_elements(
    themed_app: Page,
):
    maps = themed_app.get_by_test_id("stDeckGlJsonChart")
    expect(maps).to_have_count(3)

    selectbox = themed_app.get_by_test_id("stSelectbox").first
    selectbox.locator("input").first.click()
    selection_dropdown = themed_app.locator('[data-baseweb="popover"]').first
    selection_dropdown.locator("li").nth(1).click()

    expect(maps).to_have_count(3)

    selectbox.locator("input").first.click()
    selection_dropdown = themed_app.locator('[data-baseweb="popover"]').first
    selection_dropdown.locator("li").nth(0).click()

    expect(maps).to_have_count(3)


================================================
File: /e2e_playwright/st_map_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class
from e2e_playwright.shared.toolbar_utils import (
    assert_fullscreen_toolbar_button_interactions,
)

MAP_ELEMENT_COUNT = 5


# Firefox seems to be failing but can't reproduce locally and video produces an empty page for firefox
@pytest.mark.skip_browser("firefox")
def test_st_map_has_consistent_visuals(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    maps = themed_app.get_by_test_id("stDeckGlJsonChart")
    expect(maps).to_have_count(MAP_ELEMENT_COUNT, timeout=15000)

    # The map assets can take more time to load, add an extra timeout
    # to prevent flakiness.
    themed_app.wait_for_timeout(10000)

    # The pydeck tests are a lot flakier than need be so increase the pixel threshold
    assert_snapshot(
        maps.nth(0),
        name="st_map-empty",
        pixel_threshold=1.0,
    )

    assert_snapshot(
        maps.nth(0).locator(".mapboxgl-ctrl-group").nth(0),
        name="st_map-zoom_controls",
    )

    # Hover on the zoom out button
    maps.nth(0).locator(".mapboxgl-ctrl-zoom-out").hover()
    assert_snapshot(
        maps.nth(0).locator(".mapboxgl-ctrl-group").nth(0),
        name="st_map-zoom_out_hover",
    )

    # The pydeck tests are a lot flakier than need be so increase the pixel threshold
    assert_snapshot(
        maps.nth(1).locator("canvas").nth(1),
        name="st_map-simple_map",
        pixel_threshold=1.0,
    )

    # The pydeck tests are a lot flakier than need be so increase the pixel threshold
    assert_snapshot(
        maps.nth(2).locator("canvas").nth(1),
        name="st_map-simple_map_with_zoom",
        pixel_threshold=1.0,
    )

    # The pydeck tests are a lot flakier than need be so increase the pixel threshold
    assert_snapshot(
        maps.nth(3).locator("canvas").nth(1),
        name="st_map-map_with_color_and_size_layers",
        pixel_threshold=1.0,
    )

    # The pydeck tests are a lot flakier than need be so increase the pixel threshold
    assert_snapshot(
        maps.nth(4),
        name="st_map-width_and_height",
        pixel_threshold=1.0,
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    # Wait for map to be loaded:
    expect(app.get_by_test_id("stDeckGlJsonChart")).to_have_count(
        MAP_ELEMENT_COUNT, timeout=15000
    )

    check_top_level_class(app, "stDeckGlJsonChart")


# Firefox seems to be failing but can't reproduce locally and video produces an empty page for firefox
@pytest.mark.skip_browser("firefox")
def test_st_map_clicking_on_fullscreen_toolbar_button(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that clicking on fullscreen toolbar button expands the map into fullscreen."""

    expect(app.get_by_test_id("stDeckGlJsonChart")).to_have_count(
        MAP_ELEMENT_COUNT, timeout=15000
    )
    # The map assets can take more time to load, add an extra timeout
    # to prevent flakiness.
    app.wait_for_timeout(10000)

    assert_fullscreen_toolbar_button_interactions(
        app,
        assert_snapshot=assert_snapshot,
        widget_test_id="stDeckGlJsonChart",
        filename_prefix="st_map",
        # The pydeck tests are a lot flakier than need be so increase the pixel threshold
        pixel_threshold=1.0,
    )


================================================
File: /e2e_playwright/st_markdown.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

# keep the sidebar collapsed by default to prevent render flakiness
st.set_page_config(initial_sidebar_state="collapsed")

st.markdown(
    "This **markdown** is awesome! :sunglasses:", help="This is a help tooltip!"
)

st.markdown("This <b>HTML tag</b> is escaped!")

st.markdown("This <b>HTML tag</b> is not escaped!", unsafe_allow_html=True)

st.markdown("[text]")

st.markdown("[link](href)")

st.markdown("[][]")

st.markdown(
    """
| Col1      | Col2        |
| --------- | ----------- |
| Some      | Data        |
"""
)

st.markdown(":blue-background[**Bold text within blue background**]")
st.markdown(":red-background[*Italic text within red background*]")
st.markdown(":rainbow-background[[Link](http://example.com) within rainbow background]")
st.markdown(
    ":green-background[LaTeX math within green background: $ax^2 + bx + c = 0$]"
)


# Headers in markdown tests (originally from the typography-test suite).

with st.container():
    st.markdown("# some really long header " + " ".join(["lol"] * 10))
    st.markdown(
        """
| Col1      | Col2        | Col3        | Col4        |
| --------- | ----------- | ----------- | ----------- |
| Some      | Data        | Data        | Data        |
"""
    )


def draw_header_test(join_output):
    strings = [
        "# Header header1",
        "## Header header2",
        "### Header header3",
        "#### Header header4",
        "##### Header header5",
        "###### Header header6",
        "Quisque vel blandit mi. Fusce dignissim leo purus, in imperdiet lectus suscipit nec.",
    ]

    if join_output:
        st.markdown("\n\n".join(strings))
    else:
        for string in strings:
            st.markdown(string)


draw_header_test(True)

with st.sidebar:
    st.text_input("This is a label", key="1")
    draw_header_test(True)

"---"

with st.container():
    st.text("Headers in single st.markdown command")
    draw_header_test(True)

"---"

with st.container():
    st.text("Headers in multiple st.markdown command")
    draw_header_test(False)

"---"

with st.container():
    st.text("Headers in columns")

    a, b = st.columns(2)

    with a:
        draw_header_test(True)

    with b:
        draw_header_test(False)

"---"

with st.container():
    st.text("Headers in columns with other elements above")

    a, b = st.columns(2)

    with a:
        st.text("This is some text")
        draw_header_test(True)

    with b:
        st.text("This is some text")
        with st.container():
            draw_header_test(False)

"---"

with st.container():
    st.text("Headers in column beside widget")

    a, b = st.columns(2)

    with a:
        st.write("# Header header")
        st.write("## Header header")

    with b:
        st.text_input("This is a label", key="2")

"---"

with st.container():
    st.text("Headers with bold syntax")

    strings = [
        "# Bold **header1**",
        "## Bold **header2**",
        "### Bold **header3**",
        "#### Bold **header4**",
        "##### Bold **header5**",
        "###### Bold **header6**",
    ]
    for string in strings:
        st.markdown(string)

"---"

with st.container(key="latex_elements"):
    st.latex(r"\LaTeX")

    st.latex(
        r"""
        a + ar + a r^2 + a r^3 + \cdots + a r^{n-1} =
        \sum_{k=0}^{n-1} ar^k =
        a \left(\frac{1-r^{n}}{1-r}\right)
        """,
        help="This is example tooltip displayed on latex.",
    )

    try:
        import sympy

        a, b = sympy.symbols("a b")
        out = a + b
    except Exception:
        out = "a + b"

    st.latex(out)


st.markdown(
    "Images in markdown should stay inside the container width:\n\n![image](./app/static/streamlit-logo.png)"
)

st.container(key="mixed_markdown").markdown(
    r"""
Many different `markdown formats` in one block:

Inline math with $\KaTeX$

$$
ax^2 + bx + c = 0
$$

> This is a blockquote

### :material/home: :streamlit: Some header

| Col1      | Col2        |
| --------- | ----------- |
| Some      | :material/description: :streamlit: Data        |

- :blue[blue], :green[green], :red[red], :violet[violet], :orange[orange], :gray[gray], :grey[grey], :rainbow[rainbow], :primary[primary]
- :blue-background[blue], :green-background[green], :red-background[red], :violet-background[violet], :orange-background[orange], :gray-background[gray], :grey-background[grey], :primary-background[primary], :rainbow-background[rainbow]
- :material/chevron_right: Markdown can contain material icons :red[:material/local_fire_department:] :green-background[:material/celebration: Yay]
- :streamlit: Markdown can contain the Streamlit logo
- <- -> <-> -- >= <= ~= https://example.com-> `code <- -> <-> -- >= <= ~=` $a <- -> <-> -- >= <= ~= b$


:blue-background[**Bold text within blue background**], :red-background[*Italic text within red background*]
:rainbow-background[[Link](http://example.com) within rainbow background], :green-background[LaTeX math within green background: $ax^2 + bx + c = 0$]

:violet-background[This is a repeating multiline string that wraps within purple background. This is a repeating multiline string that wraps within purple background.]
"""
)


================================================
File: /e2e_playwright/st_markdown_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Locator, Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    expand_sidebar,
    expect_help_tooltip,
    get_element_by_key,
    get_markdown,
    wait_for_all_images_to_be_loaded,
)


def test_different_markdown_elements_in_one_block_displayed(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the block containing a mixture of different markdown elements is
    displayed correctly."""

    mixed_markdown_element = (
        get_element_by_key(themed_app, "mixed_markdown")
        .get_by_test_id("stMarkdown")
        .first
    )

    expect(mixed_markdown_element).to_be_visible()
    mixed_markdown_element.scroll_into_view_if_needed()

    assert_snapshot(
        mixed_markdown_element,
        name="st_markdown-many_elements_in_one_block",
        image_threshold=0.001,
    )


def test_displays_individual_markdowns(app: Page):
    """Verifies the correct text content of markdown elements."""

    # get markdown elements in main app view, not sidebar
    markdown_elements = app.get_by_test_id("stMain").get_by_test_id("stMarkdown")

    # Assert the text content of each markdown element
    text = [
        "This markdown is awesome! 😎",
        "This <b>HTML tag</b> is escaped!",
        "This HTML tag is not escaped!",
        "[text]",
        "link",
        "[][]",
        "Col1Col2SomeData",
        "Bold text within blue background",
        "Italic text within red background",
        "Link within rainbow background",
        "LaTeX math within green background: ax2+bx+c=0ax^2 + bx + c = 0ax2+bx+c=0",
    ]

    for i in range(len(text)):
        expect(markdown_elements.nth(i)).to_have_text(text[i])

    # Check that the style contains the correct background color
    blue_background = markdown_elements.nth(7).locator("span").first
    red_background = markdown_elements.nth(8).locator("span").first
    rainbow_background = markdown_elements.nth(9).locator("span").first
    green_background = markdown_elements.nth(10).locator("span").first

    expect(blue_background).to_have_css("background-color", "rgba(28, 131, 225, 0.1)")
    expect(red_background).to_have_css("background-color", "rgba(255, 43, 43, 0.1)")
    expect(rainbow_background).to_have_css(
        "background-image",
        "linear-gradient(to right, rgba(255, 43, 43, 0.1), rgba(255, 227, 18, 0.1), rgba(255, 227, 18, 0.1), rgba(33, 195, 84, 0.1), rgba(28, 131, 225, 0.1), rgba(128, 61, 245, 0.1), rgba(88, 63, 132, 0.1))",
    )
    expect(green_background).to_have_css("background-color", "rgba(33, 195, 84, 0.1)")

    # Additional checks for specific elements like links
    expect(markdown_elements.nth(3).locator("a")).to_have_count(0)
    expect(markdown_elements.nth(4).locator("a")).to_have_attribute("href", "href")


# Headers in markdown tests


def test_markdown_displays_long_headers_above_other_elements(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Displays long headers above other elements in the markdown block"""

    long_header = (
        app.get_by_test_id("stVerticalBlock").get_by_test_id("stVerticalBlock").nth(0)
    )

    assert_snapshot(long_header, name="st_markdown-header_long_above_markdown_table")


def _get_container_of_text(app: Page, text: str) -> Locator:
    """Get the parent container in which the passed text is located.
    The tests are written in a way that the text and the headers are put
    into the same container.
    """

    # take the 2nd match because the first would be the most outer block
    return (
        app.get_by_test_id("stVerticalBlock")
        .filter(has=app.get_by_text(text, exact=True))
        .nth(1)
    )


def test_header_attributes(app: Page):
    # Test that headers with ids exist
    h1 = app.locator("h1#header-header1")
    h2 = app.locator("h2#header-header2")
    h3 = app.locator("h3#header-header3")
    h4 = app.locator("h4#header-header4")
    h5 = app.locator("h5#header-header5")
    h6 = app.locator("h6#header-header6")

    expect(h1).to_have_count(7)
    expect(h2).to_have_count(7)
    expect(h3).to_have_count(7)
    expect(h4).to_have_count(7)
    expect(h5).to_have_count(7)
    expect(h6).to_have_count(7)


def test_match_snapshot_for_headers_in_sidebar(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that headers in sidebar are rendered correctly."""
    sidebar = expand_sidebar(app)
    assert_snapshot(sidebar, name="st_markdown-headers_in_sidebar")


def test_match_snapshot_for_headers_in_single_markdown_command(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that snapshot of headers joined in a single string and written in a single
    st.markdown command is correct."""
    container = _get_container_of_text(app, "Headers in single st.markdown command")
    assert_snapshot(container, name="st_markdown-headers_joined_in_single_command")


def test_match_snapshot_for_headers_in_multiple_markdown_commands(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that snapshot of headers written in multiple st.markdown commands is correct"""
    container = _get_container_of_text(app, "Headers in multiple st.markdown command")
    assert_snapshot(container, name="st_markdown-headers_via_multiple_commands")


def test_match_snapshot_for_columns(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that the st.markdown columns snapshot is correct."""
    container = _get_container_of_text(app, "Headers in columns")
    assert_snapshot(container, name="st_markdown-headers_in_columns")


def test_match_snapshot_for_columns_with_elements_above(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the st.markdown columns with elements above snapshot is correct."""
    container = _get_container_of_text(
        app, "Headers in columns with other elements above"
    )
    assert_snapshot(container, name="st_markdown-headers_in_labeled_columns")


def test_match_snapshot_for_column_beside_widget(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the st.markdown columns beside widget snapshot is correct."""
    container = _get_container_of_text(app, "Headers in column beside widget")
    assert_snapshot(container, name="st_markdown-headers_beside_widget")


def test_match_snapshot_for_headers_bold_text(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the headers with bold markdown syntex is correct."""
    container = _get_container_of_text(app, "Headers with bold syntax")
    assert_snapshot(container, name="st_markdown-headers_bold_syntax")

    # H1 defaults to extra bold
    h1 = app.locator("h1#bold-header1")
    expect(h1.locator("strong").first).to_have_css("font-weight", "700")

    header_ids = [
        "h2#bold-header2",
        "h3#bold-header3",
        "h4#bold-header4",
        "h5#bold-header5",
        "h6#bold-header6",
    ]
    for header_id in header_ids:
        header = app.locator(header_id)
        expect(header.locator("strong").first).to_have_css("font-weight", "600")


def test_help_tooltip_works(app: Page):
    """Test that the help tooltip is displayed on hover."""
    # Get the first element in the main view:
    markdown_with_help = (
        app.get_by_test_id("stMain").get_by_test_id("stMarkdown").nth(0)
    )
    expect_help_tooltip(app, markdown_with_help, "This is a help tooltip!")


def test_latex_elements(themed_app: Page, assert_snapshot: ImageCompareFunction):
    latex_elements = get_element_by_key(themed_app, "latex_elements").get_by_test_id(
        "stMarkdown"
    )
    expect(latex_elements).to_have_count(3)

    assert_snapshot(latex_elements.nth(0), name="st_latex-latex")
    expect(latex_elements.nth(0)).to_contain_text("LATE​X")

    assert_snapshot(latex_elements.nth(1), name="st_latex-formula")

    expect(latex_elements.nth(2)).to_contain_text("a + b")
    assert_snapshot(latex_elements.nth(2), name="st_latex-sympy")


def test_large_image_in_markdown(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that large images in markdown are displayed correctly with max width 100%."""
    markdown_element = get_markdown(
        app, "Images in markdown should stay inside the container width"
    )
    image_element = markdown_element.locator("img")

    image_element.scroll_into_view_if_needed()
    expect(image_element).to_be_visible()
    expect(image_element).to_have_css("max-width", "100%")
    # Wait for the image to load:
    wait_for_all_images_to_be_loaded(app)
    assert_snapshot(markdown_element, name="st_markdown-with_large_image")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stMarkdown")


================================================
File: /e2e_playwright/st_metric.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

col1, col2, col3 = st.columns(3)

with col1:
    st.metric("User growth", 123, 123, "normal")
with col2:
    st.metric("S&P 500", -4.56, -50)
with col3:
    st.metric("Apples I've eaten", "23k", " -20", "off")

with col1:
    st.metric("Test 3", -4.56, 1.23, label_visibility="visible")
with col2:
    st.metric("Test 4", -4.56, 1.23, label_visibility="hidden")
with col3:
    st.metric("Test 5", -4.56, 1.23, label_visibility="collapsed")

st.metric(
    "User growth and a relatively long title", 123, help="testing help without a column"
)

st.metric("label title", None, None, help="testing help without a column")

col1, col2, col3, col4, col5, col6, col7, col8 = st.columns(8)

with col1:
    st.metric(
        label="Example metric",
        help="Something should feel right",
        value=150.59,
        delta="Very high",
    )

st.metric("Test 9", -4.56, 1.23, help="Test help with code `select * from table`")

st.metric("Test 10", -4.56, 1.23, border=True, help="Test help text")


================================================
File: /e2e_playwright/st_metric_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class, expect_help_tooltip


def test_first_metric_in_first_row(app: Page):
    expect(app.get_by_test_id("stMetricLabel").nth(0)).to_have_text("User growth")
    expect(app.get_by_test_id("stMetricValue").nth(0)).to_have_text(" 123 ")
    expect(app.get_by_test_id("stMetricDelta").nth(0)).to_have_text(" 123 ")


def test_second_metric_in_first_row(app: Page):
    expect(app.get_by_test_id("stMetricLabel").nth(2)).to_have_text("S&P 500")
    expect(app.get_by_test_id("stMetricValue").nth(2)).to_have_text(" -4.56 ")
    expect(app.get_by_test_id("stMetricDelta").nth(2)).to_have_text(" -50 ")


def test_third_metric_in_first_row(app: Page):
    expect(app.get_by_test_id("stMetricLabel").nth(4)).to_have_text("Apples I've eaten")
    expect(app.get_by_test_id("stMetricValue").nth(4)).to_have_text(" 23k ")
    expect(app.get_by_test_id("stMetricDelta").nth(4)).to_have_text(" -20 ")


def test_green_up_arrow_render(themed_app: Page, assert_snapshot: ImageCompareFunction):
    assert_snapshot(
        themed_app.get_by_test_id("stMetric").nth(0),
        name="st_metric-green",
    )


def test_red_down_arrow_render(themed_app: Page, assert_snapshot: ImageCompareFunction):
    assert_snapshot(
        themed_app.get_by_test_id("stMetric").nth(2),
        name="st_metric-red",
    )


def test_gray_down_arrow_render(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    assert_snapshot(
        themed_app.get_by_test_id("stMetric").nth(4),
        name="st_metric-gray",
    )


def test_help_shows_up_without_columns(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    assert_snapshot(
        themed_app.get_by_test_id("stMetric").nth(6),
        name="st_metric-with_help",
    )


def test_none_results_in_dash_in_value(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    assert_snapshot(
        themed_app.get_by_test_id("stMetric").nth(7),
        name="st_metric-with_none_value",
    )


def test_border(themed_app: Page, assert_snapshot: ImageCompareFunction):
    assert_snapshot(
        themed_app.get_by_test_id("stMetric").nth(10),
        name="st_metric-border",
    )


def test_label_visibility_set_to_hidden(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    expect(themed_app.get_by_test_id("stMetricLabel").nth(3)).to_have_text("Test 4")
    assert_snapshot(
        themed_app.get_by_test_id("stMetric").nth(3),
        name="st_metric-label_hidden",
    )


def test_label_visibility_set_to_collapse(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    expect(themed_app.get_by_test_id("stMetricLabel").nth(5)).to_have_text("Test 5")
    assert_snapshot(
        themed_app.get_by_test_id("stMetric").nth(5),
        name="st_metric-label_collapse",
    )


def test_ellipses_and_help_shows_up_properly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    metric_element = themed_app.get_by_test_id("stMetric").nth(8)
    expect_help_tooltip(themed_app, metric_element, "Something should feel right")
    assert_snapshot(
        metric_element,
        name="st_metric-help_and_ellipses",
    )


def test_code_in_help_shows_up_properly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    metric_element = themed_app.get_by_test_id("stMetric").nth(9)
    hover_target = metric_element.get_by_test_id("stTooltipHoverTarget")
    tooltip_content = themed_app.get_by_test_id("stTooltipContent")

    expect(hover_target).to_be_visible()
    hover_target.hover()
    expect(tooltip_content).to_have_text("Test help with code select * from table")

    assert_snapshot(
        tooltip_content,
        name="st_metric-code_in_help",
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stMetric")


================================================
File: /e2e_playwright/st_multiselect.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import Any

import streamlit as st
from streamlit import runtime


def set_multiselect_9_to_have_bad_state():
    if "multiselect 9" in st.session_state:
        st.session_state["multiselect 9"] = ["male", "female"]


options = ("male", "female")

i1 = st.multiselect(
    "multiselect 1", options, placeholder="Please select", help="Help text"
)
st.text(f"value 1: {i1}")

i2 = st.multiselect("multiselect 2", options, format_func=lambda x: x.capitalize())
st.text(f"value 2: {i2}")

i3: list[Any] = st.multiselect("multiselect 3", [])
st.text(f"value 3: {i3}")

i4 = st.multiselect("multiselect 4", ["coffee", "tea", "water"], ["tea", "water"])
st.text(f"value 4: {i4}")

i5 = st.multiselect(
    "multiselect 5",
    [
        f"{x} I am a ridiculously long string to have in a multiselect, so perhaps I should just not wrap and go to the next line."
        for x in range(5)
    ],
)
st.text(f"value 5: {i5}")

i6 = st.multiselect("multiselect 6", options, disabled=True)
st.text(f"value 6: {i6}")

i7 = st.multiselect("Hidden label", options, label_visibility="hidden")
st.text(f"value 7: {i7}")

i8 = st.multiselect("Collapsed label", options, label_visibility="collapsed")
st.text(f"value 8: {i8}")

set_multiselect_9 = st.checkbox(
    "set_multiselect_9", on_change=set_multiselect_9_to_have_bad_state
)

i9 = st.multiselect("multiselect 9", options, max_selections=1, key="multiselect 9")
st.text(f"value 9: {i9}")

with st.form("my_max_selections_ms_in_form"):
    i10 = st.multiselect(
        "multiselect 10", options, max_selections=1, key="multiselect 10"
    )
    st.text(f"value 10: {i10}")
    submitted = st.form_submit_button("Submit")

if runtime.exists():

    def on_change():
        st.session_state.multiselect_changed = True

    st.multiselect("multiselect 11", options, key="multiselect11", on_change=on_change)
    st.text(f"value 11: {st.session_state.multiselect11}")
    st.text(f"multiselect changed: {'multiselect_changed' in st.session_state}")

multiple_cols = st.columns(5)
i12 = multiple_cols[0].multiselect(
    "multiselect 12", ["A long option"], default="A long option"
)
st.text(f"value 12: {i12}")


================================================
File: /e2e_playwright/st_multiselect_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_checkbox,
    expect_help_tooltip,
    get_element_by_key,
)


def select_for_kth_multiselect(
    page: Page, option_text: str, k: int, close_after_selecting: bool
) -> None:
    """Select an option from a multiselect widget.

    Parameters
    ----------
    page : Page
        The playwright page to use.
    option_text : str
        The text of the option to select.
    k : int
        The index of the multiselect widget to select from.
    close_after_selecting : bool
        Whether to close the dropdown after selecting the option.
    """

    multiselect_elem = page.get_by_test_id("stMultiSelect").nth(k)
    multiselect_elem.locator("input").click()
    page.locator("li").filter(has_text=option_text).first.click()
    if close_after_selecting:
        page.keyboard.press("Escape")
    wait_for_app_run(page)


def del_from_kth_multiselect(page: Page, option_text: str, k: int):
    """Delete an option from a multiselect widget.

    Parameters
    ----------
    page : Page
        The playwright page to use.
    option_text : str
        The text of the option to delete.
    k : int
        The index of the multiselect widget to delete from.
    """
    multiselect_elem = page.get_by_test_id("stMultiSelect").nth(k)
    multiselect_elem.locator(
        f'span[data-baseweb="tag"] span[title="{option_text}"] + span[role="presentation"]'
    ).first.click()


def test_multiselect_on_load(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Should show widgets correctly when loaded."""
    multiselect_elements = themed_app.get_by_test_id("stMultiSelect")
    expect(multiselect_elements).to_have_count(12)
    for idx, el in enumerate(multiselect_elements.all()):
        assert_snapshot(el, name="st_multiselect-" + str(idx))


def test_help_tooltip_works(app: Page):
    element_with_help = app.get_by_test_id("stMultiSelect").nth(0)
    expect_help_tooltip(app, element_with_help, "Help text")


def test_multiselect_initial_value(app: Page):
    """Should show the correct initial values."""
    text_elements = app.get_by_test_id("stText")
    expect(text_elements).to_have_count(13)

    expected = [
        "value 1: []",
        "value 2: []",
        "value 3: []",
        "value 4: ['tea', 'water']",
        "value 5: []",
        "value 6: []",
        "value 7: []",
        "value 8: []",
        "value 9: []",
        "value 10: []",
        "value 11: []",
        "multiselect changed: False",
        "value 12: ['A long option']",
    ]

    for text_element, expected_text in zip(text_elements.all(), expected):
        expect(text_element).to_have_text(expected_text, use_inner_text=True)


def test_multiselect_clear_all(app: Page):
    """Should clear all options when clicking clear all."""
    select_for_kth_multiselect(app, "Female", 1, True)
    app.locator('.stMultiSelect [role="button"][aria-label="Clear all"]').first.click()
    expect(app.get_by_test_id("stText").nth(1)).to_have_text("value 2: []")


def test_multiselect_show_values_in_dropdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Screenshot test to check that values are shown in dropdown."""
    multiselect_elem = app.get_by_test_id("stMultiSelect").nth(0)
    multiselect_elem.locator("input").click()
    wait_for_app_run(app)
    dropdown_elements = app.locator("li")
    expect(dropdown_elements).to_have_count(2)
    assert_snapshot(dropdown_elements.nth(0), name="st_multiselect-dropdown_0")
    assert_snapshot(dropdown_elements.nth(1), name="st_multiselect-dropdown_1")


def test_multiselect_long_values_in_dropdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Should show long values correctly (with ellipses) in the dropdown menu."""
    multiselect_elem = app.get_by_test_id("stMultiSelect").nth(4)
    multiselect_elem.locator("input").click()
    wait_for_app_run(app)
    dropdown_elems = app.locator("li").all()
    for idx, el in enumerate(dropdown_elems):
        assert_snapshot(el, name="st_multiselect-dropdown_long_label_" + str(idx))


def test_multiselect_long_values_in_narrow_column(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Should show long values correctly (with ellipses) when in narrow column widths."""
    multiselect_elem = app.get_by_test_id("stMultiSelect").nth(11)
    wait_for_app_run(app)
    # Wait for list items to be loaded in
    app.locator("li").all()
    assert_snapshot(multiselect_elem, name="st_multiselect-dropdown_narrow_column")


def test_multiselect_register_callback(app: Page):
    """Should call the callback when an option is selected."""
    app.get_by_test_id("stMultiSelect").nth(10).locator("input").click()
    app.locator("li").first.click()
    expect(app.get_by_test_id("stText").nth(10)).to_have_text("value 11: ['male']")
    expect(app.get_by_test_id("stText").nth(11)).to_have_text(
        "multiselect changed: True"
    )


def test_multiselect_max_selections_form(app: Page):
    """Should apply max selections when used in form."""
    select_for_kth_multiselect(app, "male", 8, False)
    expect(app.locator("li")).to_have_text(
        "You can only select up to 1 option. Remove an option first.",
        use_inner_text=True,
    )


def test_multiselect_max_selections_1(app: Page):
    """Should show the correct text when maxSelections is reached and closing after selecting."""
    select_for_kth_multiselect(app, "male", 9, True)
    app.get_by_test_id("stMultiSelect").nth(9).click()
    expect(app.locator("li")).to_have_text(
        "You can only select up to 1 option. Remove an option first.",
        use_inner_text=True,
    )


def test_multiselect_max_selections_2(app: Page):
    """Should show the correct text when maxSelections is reached and not closing after selecting."""
    select_for_kth_multiselect(app, "male", 9, False)
    expect(app.locator("li")).to_have_text(
        "You can only select up to 1 option. Remove an option first.",
        use_inner_text=True,
    )


def test_multiselect_valid_options(app: Page):
    """Should allow selections when there are valid options."""
    expect(app.get_by_test_id("stMultiSelect").first).to_have_text(
        "multiselect 1\n\nPlease select", use_inner_text=True
    )


def test_multiselect_no_valid_options(app: Page):
    """Should show that their are no options."""
    expect(app.get_by_test_id("stMultiSelect").nth(2)).to_have_text(
        "multiselect 3\n\nNo options to select.", use_inner_text=True
    )


def test_multiselect_single_selection(app: Page, assert_snapshot: ImageCompareFunction):
    """Should allow selections."""
    select_for_kth_multiselect(app, "Female", 1, True)
    expect(app.get_by_test_id("stMultiSelect").locator("span").nth(1)).to_have_text(
        "Female", use_inner_text=True
    )
    assert_snapshot(
        app.get_by_test_id("stMultiSelect").nth(1), name="st_multiselect-selection"
    )
    expect(app.get_by_test_id("stText").nth(1)).to_have_text(
        "value 2: ['female']", use_inner_text=True
    )


def test_multiselect_deselect_option(app: Page):
    """Should deselect an option when deselecting it."""
    select_for_kth_multiselect(app, "Female", 1, True)
    select_for_kth_multiselect(app, "Male", 1, True)
    del_from_kth_multiselect(app, "Female", 1)
    expect(app.get_by_test_id("stText").nth(1)).to_have_text("value 2: ['male']")


def test_multiselect_option_over_max_selections(app: Page):
    """Should show an error when more than max_selections got selected."""
    click_checkbox(app, "set_multiselect_9")
    expect(app.get_by_test_id("stException")).to_contain_text(
        "Multiselect has 2 options selected but max_selections is set to 1"
    )


def test_multiselect_double_selection(app: Page):
    """Should allow multiple selections."""
    select_for_kth_multiselect(app, "Female", 1, True)
    select_for_kth_multiselect(app, "Male", 1, True)
    expect(app.get_by_test_id("stText").nth(1)).to_have_text(
        "value 2: ['female', 'male']"
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stMultiSelect")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "multiselect 9")).to_be_visible()


================================================
File: /e2e_playwright/st_number_input.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit import runtime

v1 = st.number_input("number input 1 (default)", help="Help text")
st.write("number input 1 (default) - value: ", v1)

v2 = st.number_input("number input 2 (value=1)", value=1)
st.write("number input 2 (value=1) - value: ", v2)

v3 = st.number_input("number input 3 (min & max)", 1, 10)
st.write("number input 3 (min & max) - value: ", v3)

v4 = st.number_input("number input 4 (step=2)", step=2)
st.write("number input 4 (step=2) - value: ", v4)

v5 = st.number_input("number input 5 (max=10)", max_value=10)
st.write("number input 5 (max=10) - value: ", v5)

v6 = st.number_input("number input 6 (disabled=True)", disabled=True)
st.write("number input 6 (disabled=True) - value: ", v6)

v7 = st.number_input("number input 7 (label=hidden)", label_visibility="hidden")
st.write("number input 7 (label=hidden) - value: ", v7)

v8 = st.number_input("number input 8 (label=collapsed)", label_visibility="collapsed")
st.write("number input 8 (label=collapsed) - value: ", v8)

if runtime.exists():

    def on_change():
        st.session_state.number_input_changed = True

    st.number_input(
        "number input 9 (on_change)", key="number_input_9", on_change=on_change
    )
    st.write("number input 9 (on_change) - value: ", st.session_state.number_input_9)
    st.write(
        "number input 9 (on_change) - changed:",
        st.session_state.get("number_input_changed") is True,
    )

[col1, col2, col3, col4, col5, col6] = st.columns(6)

with col1:
    v10 = st.number_input("number input 10 (small width)", max_value=10)
    st.write("number input 10 (small width) - value: ", v10)

v11 = st.number_input(
    "number input 11 (value=None)", value=None, placeholder="Type a number..."
)
st.write("number input 11 (value=None) - value: ", v11)

if "number_input_12" not in st.session_state:
    st.session_state["number_input_12"] = 10

v12 = st.number_input(
    "number input 12 (value from state & min=1)",
    value=None,
    min_value=1,
    key="number_input_12",
)
st.write("number input 12 (value from state & min=1) - value: ", v12)


================================================
File: /e2e_playwright/st_number_input_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    expect_help_tooltip,
    get_element_by_key,
)


def test_number_input_widget_display(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.number_input renders correctly."""
    number_input_elements = themed_app.get_by_test_id("stNumberInput")
    expect(number_input_elements).to_have_count(12)

    assert_snapshot(number_input_elements.nth(0), name="st_number_input-default")
    assert_snapshot(number_input_elements.nth(1), name="st_number_input-value_1")
    assert_snapshot(number_input_elements.nth(2), name="st_number_input-min_max")
    assert_snapshot(number_input_elements.nth(3), name="st_number_input-step_2")
    assert_snapshot(number_input_elements.nth(4), name="st_number_input-max_10")
    assert_snapshot(number_input_elements.nth(5), name="st_number_input-disabled_true")
    assert_snapshot(number_input_elements.nth(6), name="st_number_input-label_hidden")
    assert_snapshot(
        number_input_elements.nth(7), name="st_number_input-label_collapsed"
    )
    assert_snapshot(number_input_elements.nth(8), name="st_number_input-on_change")
    assert_snapshot(number_input_elements.nth(9), name="st_number_input-small_width")
    assert_snapshot(number_input_elements.nth(10), name="st_number_input-value_none")
    assert_snapshot(
        number_input_elements.nth(11), name="st_number_input-value_none_min_1"
    )


def test_help_tooltip_works(app: Page):
    expect_help_tooltip(app, app.get_by_test_id("stNumberInput").nth(0), "Help text")


def test_number_input_has_correct_default_values(app: Page):
    """Test that st.number_input has the correct initial values."""
    markdown_elements = app.get_by_test_id("stMarkdown")
    expect(markdown_elements).to_have_count(13)

    expected = [
        "number input 1 (default) - value: 0.0",
        "number input 2 (value=1) - value: 1",
        "number input 3 (min & max) - value: 1",
        "number input 4 (step=2) - value: 0",
        "number input 5 (max=10) - value: 0",
        "number input 6 (disabled=True) - value: 0.0",
        "number input 7 (label=hidden) - value: 0.0",
        "number input 8 (label=collapsed) - value: 0.0",
        "number input 9 (on_change) - value: 0.0",
        "number input 9 (on_change) - changed: False",
        "number input 10 (small width) - value: 0",
        "number input 11 (value=None) - value: None",
        "number input 12 (value from state & min=1) - value: 10",
    ]

    for markdown_element, expected_text in zip(markdown_elements.all(), expected):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_number_input_shows_instructions_when_dirty(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.number_input shows the instructions correctly when dirty."""
    first_number_input = app.get_by_test_id("stNumberInput").first
    first_number_input.locator("input").fill("10")

    assert_snapshot(first_number_input, name="st_number_input-input_instructions")


def test_number_input_updates_value_correctly_on_enter(app: Page):
    """Test that st.number_input updates the value correctly on enter."""
    first_number_input_field = (
        app.get_by_test_id("stNumberInput").nth(0).locator("input")
    )
    first_number_input_field.fill("10")
    first_number_input_field.press("Enter")

    expect(app.get_by_test_id("stMarkdown").nth(0)).to_have_text(
        "number input 1 (default) - value: 10.0", use_inner_text=True
    )


def test_number_input_has_correct_value_on_increment_click(app: Page):
    """Test that st.number_input has the correct value on increment click."""
    number_input_up_buttons = app.get_by_test_id("stNumberInput").get_by_test_id(
        "stNumberInputStepUp"
    )
    expect(number_input_up_buttons).to_have_count(11)
    for i, button in enumerate(number_input_up_buttons.all()):
        if i not in [5, 9]:
            button.click()
            wait_for_app_run(app)

    markdown_elements = app.get_by_test_id("stMarkdown")

    expected = [
        "number input 1 (default) - value: 0.01",
        "number input 2 (value=1) - value: 2",
        "number input 3 (min & max) - value: 2",
        "number input 4 (step=2) - value: 2",
        "number input 5 (max=10) - value: 1",
        "number input 6 (disabled=True) - value: 0.0",
        "number input 7 (label=hidden) - value: 0.01",
        "number input 8 (label=collapsed) - value: 0.01",
        "number input 9 (on_change) - value: 0.01",
        "number input 9 (on_change) - changed: True",
        "number input 10 (small width) - value: 0",
        "number input 11 (value=None) - value: None",
        "number input 12 (value from state & min=1) - value: 11",
    ]

    for markdown_element, expected_text in zip(markdown_elements.all(), expected):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_number_input_has_correct_value_on_arrow_up(app: Page):
    """Test that st.number_input has the correct value on arrow up."""
    first_number_input_field = (
        app.get_by_test_id("stNumberInput").nth(0).locator("input")
    )
    first_number_input_field.press("ArrowUp")

    expect(app.get_by_test_id("stMarkdown").nth(0)).to_have_text(
        "number input 1 (default) - value: 0.01", use_inner_text=True
    )


def test_number_input_has_correct_value_on_blur(app: Page):
    """Test that st.number_input has the correct value on blur."""

    first_number_input_field = (
        app.get_by_test_id("stNumberInput").nth(0).locator("input")
    )
    first_number_input_field.focus()
    first_number_input_field.fill("10")
    first_number_input_field.blur()

    expect(app.get_by_test_id("stMarkdown").nth(0)).to_have_text(
        "number input 1 (default) - value: 10.0", use_inner_text=True
    )


def test_empty_number_input_behaves_correctly(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.number_input behaves correctly when empty."""
    # Enter 10 in the first empty input:
    empty_number_input = app.get_by_test_id("stNumberInput").nth(10)
    empty_number_input_field = empty_number_input.locator("input").first
    empty_number_input_field.fill("10")
    empty_number_input_field.press("Enter")

    expect(app.get_by_test_id("stMarkdown").nth(11)).to_have_text(
        "number input 11 (value=None) - value: 10.0", use_inner_text=True
    )

    assert_snapshot(empty_number_input, name="st_number_input-clearable_input")

    # Press escape to clear value:
    empty_number_input.focus()
    empty_number_input.press("Escape")
    empty_number_input.press("Enter")

    # Should be empty again:
    expect(app.get_by_test_id("stMarkdown").nth(11)).to_have_text(
        "number input 11 (value=None) - value: None", use_inner_text=True
    )

    # Check with second empty input, this one should be integer since the min_value was
    # set to an integer:
    empty_number_input_with_min = (
        app.get_by_test_id("stNumberInput").nth(11).locator("input").first
    )
    empty_number_input_with_min.fill("15")
    empty_number_input_with_min.press("Enter")

    expect(app.get_by_test_id("stMarkdown").nth(12)).to_have_text(
        "number input 12 (value from state & min=1) - value: 15", use_inner_text=True
    )


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "number_input_9")).to_be_visible()


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stNumberInput")


================================================
File: /e2e_playwright/st_pills.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time

import streamlit as st

st.header("Pills - standard")

if st.checkbox("Set default values", value=False):
    st.session_state.default_pills = ["🧰 General widgets", "📊 Charts", "🧊 3D"]
else:
    st.session_state.default_pills = []

default = st.session_state.default_pills

pills_options = [
    "🧰 General widgets",
    "📊 Charts",
    "🌇 Images",
    "🎥 Video",
    "📝 Text",
    "🗺️ Maps & geospatial",
    "🧮 Dataframes & tables",
    "🧬 Molecules & genes",
    "🪢 Graphs",
    "🧊 3D",
    "✏️ Code & editors",
    "📃 Page navigation",
    "🔐 Authentication",
    "🎨 Style & layout",
    "🛠️ Developer tools",
    "🏗️ App builders",
    "🔌 Integrations with other tools",
    "📦 Collections of components",
    "📦 Very very long text" * 20,  # pill with very long text
]
selection = st.pills(
    "Select some options",
    pills_options,
    key="pills",
    selection_mode="multi",
    default=default,
    help="This is for choosing options",
)
st.write(f"Multi selection: {selection}")


st.header("Pills - starting with icons")
option_to_icon_map = {
    0: ":material/add:",
    1: ":material/zoom_in:",
    2: ":material/zoom_out:",
    3: ":material/zoom_out_map:",
}
selection = st.pills(
    "Select a single option",
    options=[0, 1, 2, 3],
    format_func=lambda option: option_to_icon_map[option],
    key="icon_only_pills",
    selection_mode="single",
)
st.write(f"Single selection: {selection}")


st.header("Pills - on_change callback")
st.pills(
    "Elements (label collapsed)",
    ["Water", "Fire", "Earth", "Air"],
    key="pills_on_change",
    on_change=lambda: st.write(
        f"on_change selection: {st.session_state.pills_on_change}"
    ),
    label_visibility="collapsed",
)


st.header("Pills - disabled")
selection = st.pills(
    "Elements",
    ["Water", "Fire", "Earth", "Air"],
    key="pills_disabled",
    disabled=True,
)
st.write("pills-disabled:", str(selection))


st.header("Pills in form")
with st.form(key="my_form", clear_on_submit=True):
    selection = st.pills(
        "Elements  (label hidden)",
        ["Water", "Fire", "Earth", "Air"],
        key="pills_in_form",
        label_visibility="hidden",
    )
    st.form_submit_button("Submit")

st.write(
    "pills-in-form:",
    str(st.session_state.pills_in_form)
    if "pills_in_form" in st.session_state
    else None,
)

st.header("Pills in fragment")


@st.experimental_fragment()
def test_fragment():
    selection = st.pills(
        "Elements", ["Water", "Fire", "Earth", "Air"], key="pills_in_fragment"
    )
    st.write("pills-in-fragment:", str(selection))


test_fragment()


st.header("Pills - unmount")
if st.button("Create some elements to unmount component"):
    for _ in range(3):
        # The sleep here is needed, because it won't unmount the
        # component if this is too fast.
        time.sleep(1)
        st.write("Another element")

selection = st.pills(
    "Elements", ["Water", "Fire", "Earth", "Air"], key="pills_after_sleep"
)
st.write("pills-after-sleep:", str(selection))


if "runs" not in st.session_state:
    st.session_state.runs = 0
st.session_state.runs += 1
st.write("Runs:", st.session_state.runs)


================================================
File: /e2e_playwright/st_pills_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from playwright.sync_api import Locator, Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_button,
    click_checkbox,
    click_form_button,
    expect_help_tooltip,
    expect_markdown,
    get_element_by_key,
)


def get_button_group(app: Page, index: int) -> Locator:
    return app.get_by_test_id("stButtonGroup").nth(index)


def get_pill_button(locator: Locator, text: str) -> Locator:
    return locator.get_by_test_id(re.compile("stBaseButton-pills(Active)?")).filter(
        has_text=text
    )


def test_click_multiple_pills_and_take_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test multiselect pills and take a screenshot.

    Click on same pill multiple times to test unselect.
    """

    pills = get_button_group(themed_app, 0)
    get_pill_button(pills, "📝").click()
    wait_for_app_run(themed_app)
    # click on second element to test multiselect
    get_pill_button(pills, "🪢").click()
    wait_for_app_run(themed_app)
    expect_markdown(themed_app, "Multi selection: ['📝 Text', '🪢 Graphs']")

    # click on same element to test unselect
    get_pill_button(pills, "🪢").click()
    wait_for_app_run(themed_app)
    expect_markdown(themed_app, "Multi selection: ['📝 Text']")

    # click on same element and take screenshot of multiple selected pills
    get_pill_button(pills, "🪢").click()
    # take away hover focus of button
    themed_app.get_by_test_id("stApp").click(position={"x": 0, "y": 0})
    wait_for_app_run(themed_app)
    expect_markdown(themed_app, "Multi selection: ['📝 Text', '🪢 Graphs']")

    assert_snapshot(pills, name="st_pills-multiselect")


def test_click_single_icon_pill_and_take_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test icon only pills (via format_func) and take a screenshot.

    Click on same element to test unselect.
    Click on two different elements to validate single select.
    """

    pills = get_button_group(themed_app, 1)

    # the icon's span element has the respective text
    # (e.g. :material/zoom_out_map: -> zoom_out_map)
    get_pill_button(pills, "zoom_out_map").click()
    expect_markdown(themed_app, "Single selection: 3")

    # test unselect in single-select mode
    get_pill_button(pills, "zoom_out_map").click()
    expect_markdown(themed_app, "Single selection: None")

    get_pill_button(pills, "zoom_in").click()
    # take away hover focus of button
    themed_app.get_by_test_id("stApp").click(position={"x": 0, "y": 0})
    wait_for_app_run(themed_app)
    expect_markdown(themed_app, "Single selection: 1")

    assert_snapshot(pills, name="st_pills-singleselect_icon_only")


def test_pills_are_disabled_and_take_screenshot(
    app: Page, assert_snapshot: ImageCompareFunction
):
    pills = get_button_group(app, 3)
    for pill in pills.locator("button").all():
        expect(pill).to_have_js_property("disabled", True)
    selected_pill = get_pill_button(pills, "Air")
    selected_pill.click(force=True)
    wait_for_app_run(app)
    expect(selected_pill).not_to_have_css(
        "color", re.compile("rgb\\(\\d+, \\d+, \\d+\\)")
    )
    expect_markdown(app, "pills-disabled: None")
    assert_snapshot(pills, name="st_pills-disabled")


def test_pass_default_selections(app: Page):
    """Test that passed defaults are rendered correctly."""
    expect_markdown(app, "Multi selection: []")

    click_checkbox(app, "Set default values")
    expect_markdown(
        app, "Multi selection: ['🧰 General widgets', '📊 Charts', '🧊 3D']"
    )

    click_checkbox(app, "Set default values")
    expect_markdown(app, "Multi selection: []")


def test_selection_via_on_change_callback(app: Page):
    """Test that the on_change callback is triggered when a pill is clicked."""
    pills = get_button_group(app, 2)
    get_pill_button(pills, "Air").click()
    wait_for_app_run(app)
    expect_markdown(app, "on_change selection: Air")


def test_pills_work_in_forms(app: Page):
    expect_markdown(app, "pills-in-form: None")
    pills = get_button_group(app, 4)
    get_pill_button(pills, "Air").click()
    click_form_button(app, "Submit")
    wait_for_app_run(app)
    expect_markdown(app, "pills-in-form: Air")


def test_pills_work_with_fragments(app: Page):
    expect_markdown(app, "pills-in-fragment: None")
    pills = get_button_group(app, 5)
    get_pill_button(pills, "Air").click()
    wait_for_app_run(app)
    expect_markdown(app, "pills-in-fragment: Air")
    expect(app.get_by_text("Runs: 1")).to_be_visible()


def test_pills_remount_keep_value(app: Page):
    expect_markdown(app, "pills-after-sleep: None")
    pills = get_button_group(app, 6)
    selected_pill = get_pill_button(pills, "Air")
    selected_pill.click()
    wait_for_app_run(app)
    expect_markdown(app, "pills-after-sleep: Air")
    click_button(app, "Create some elements to unmount component")
    expect_markdown(app, "pills-after-sleep: Air")


def test_help_tooltip_works(app: Page):
    expect_help_tooltip(app, get_button_group(app, 0), "This is for choosing options")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stButtonGroup")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "pills")).to_be_visible()


def test_pills_with_labels(app: Page):
    """Test that labels are rendered correctly."""

    # visible label
    visible_label = app.get_by_test_id("stWidgetLabel").filter(
        has_text="Select some options"
    )
    expect(visible_label).to_be_visible()

    # collapsed label
    markdown_el = app.get_by_test_id("stWidgetLabel").filter(
        has_text="Elements (label collapsed)"
    )
    expect(markdown_el).to_be_attached()
    expect(markdown_el).not_to_be_visible()
    expect(markdown_el).to_have_css("display", "none")

    # hidden label
    markdown_el = app.get_by_test_id("stWidgetLabel").filter(
        has_text="Elements (label hidden)"
    )
    expect(markdown_el).to_be_attached()
    expect(markdown_el).not_to_be_visible()
    expect(markdown_el).to_have_css("display", "flex")
    expect(markdown_el).to_have_css("visibility", "hidden")


================================================
File: /e2e_playwright/st_plotly_chart.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from datetime import datetime

import numpy as np
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots

import streamlit as st

# Explicitly seed the RNG for deterministic results
np.random.seed(0)

df_bubble = px.data.gapminder()
fig_bubble = px.scatter(
    df_bubble.query("year==2007"),
    x="gdpPercap",
    y="lifeExp",
    size="pop",
    color="continent",
    hover_name="country",
    log_x=True,
    size_max=60,
)

# tests no streamlit theme plot
st.plotly_chart(fig_bubble, theme=None)

# Bubble Chart
# Tests Discrete coloring with streamlit theme
# uses container width when use_container_width flag is True
fig_bubble.update_layout(height=300, width=300)
st.plotly_chart(
    fig_bubble,
    use_container_width=True,
    theme="streamlit",
    # Also test custom toolbar modification:
    config={"modeBarButtonsToRemove": ["zoom"], "modeBarButtonsToAdd": ["drawline"]},
)

# Candlestick Chart
open_data_candlestick = [33.0, 33.3, 33.5, 33.0, 34.1]
high_data_candlestick = [33.1, 33.3, 33.6, 33.2, 34.8]
low_data_candlestick = [32.7, 32.7, 32.8, 32.6, 32.8]
close_data_candlestick = [33.0, 32.9, 33.3, 33.1, 33.1]
dates_candlestick = [
    datetime(year=2013, month=10, day=10),
    datetime(year=2013, month=11, day=10),
    datetime(year=2013, month=12, day=10),
    datetime(year=2014, month=1, day=10),
    datetime(year=2014, month=2, day=10),
]
fig_candlestick = go.Figure(
    data=[
        go.Candlestick(
            x=dates_candlestick,
            open=open_data_candlestick,
            high=high_data_candlestick,
            low=low_data_candlestick,
            close=close_data_candlestick,
        )
    ]
)
st.plotly_chart(fig_candlestick, theme="streamlit")

# Tests sunburst charts and color parameter using streamlit colors
df = px.data.tips()
fig_sunburst = px.sunburst(
    df, path=["sex", "day", "time"], values="total_bill", color="day"
)
st.plotly_chart(fig_sunburst, theme="streamlit")

# Contour Plot and Heatmap
fig = make_subplots(
    rows=2, cols=2, subplot_titles=("connectgaps = False", "connectgaps = True")
)
z = [
    [None, None, None, 12, 13, 14, 15, 16],
    [None, 1, None, 11, None, None, None, 17],
    [None, 2, 6, 7, None, None, None, 18],
    [None, 3, None, 8, None, None, None, 19],
    [5, 4, 10, 9, None, None, None, 20],
    [None, None, None, 27, None, None, None, 21],
    [None, None, None, 26, 25, 24, 23, 22],
]

fig.add_trace(go.Contour(z=z, showscale=False), 1, 1)
fig.add_trace(go.Contour(z=z, showscale=False, connectgaps=True), 1, 2)
fig.add_trace(go.Heatmap(z=z, showscale=False, zsmooth="best"), 2, 1)
fig.add_trace(go.Heatmap(z=z, showscale=False, connectgaps=True, zsmooth="best"), 2, 2)

fig["layout"]["yaxis1"].update(title="Contour map")
fig["layout"]["yaxis3"].update(title="Heatmap")

st.plotly_chart(fig, theme="streamlit")

# Waterfall Chart
fig_waterfall = go.Figure(
    go.Waterfall(
        name="20",
        orientation="v",
        measure=["relative", "relative", "total", "relative", "relative", "total"],
        x=[
            "Sales",
            "Consulting",
            "Net revenue",
            "Purchases",
            "Other expenses",
            "Profit before tax",
        ],
        textposition="outside",
        text=["+60", "+80", "", "-40", "-20", "Total"],
        y=[60, 80, 0, -40, -20, 0],
        connector={"line": {"color": "rgb(63, 63, 63)"}},
    )
)

fig_waterfall.update_layout(
    title="Profit and loss statement 2018", height=300, width=300, showlegend=True
)
# uses figure height and width when use_container_width is False
st.plotly_chart(fig_waterfall, use_container_width=False, theme="streamlit")

# Ternary Chart
df = px.data.election()
fig_ternary = px.scatter_ternary(df, a="Joly", b="Coderre", c="Bergeron")

st.plotly_chart(fig_ternary, theme="streamlit")

# Table Plot
fig_table = go.Figure(
    data=[
        go.Table(
            header={"values": ["A Scores", "B Scores"]},
            cells={"values": [[100, 90, 80, 90], [95, 85, 75, 95]]},
        )
    ]
)
st.plotly_chart(fig_table, theme="streamlit")

# Continuous Customization Chart with plotly.go graph
fig_contour = go.Figure(
    data=go.Contour(
        z=[
            [10, 10.625, 12.5, 15.625, 20],
            [5.625, 6.25, 8.125, 11.25, 15.625],
            [2.5, 3.125, 5.0, 8.125, 12.5],
            [0.625, 1.25, 3.125, 6.25, 10.625],
            [0, 0.625, 2.5, 5.625, 10],
        ],
        colorscale="Electric",
    )
)
st.plotly_chart(fig_contour, theme="streamlit")

# Discrete Customization Chart
df = px.data.wind()
fig = px.scatter_polar(
    df,
    r="frequency",
    theta="direction",
    color="strength",
    symbol="strength",
    size="frequency",
    color_discrete_sequence=px.colors.sequential.Plasma_r,
)
st.plotly_chart(fig, theme="streamlit")

# Layout Customization Chart
fig = go.Figure(
    go.Sunburst(
        labels=[
            "Eve",
            "Cain",
            "Seth",
            "Enos",
            "Noam",
            "Abel",
            "Awan",
            "Enoch",
            "Azura",
        ],
        parents=["", "Eve", "Eve", "Seth", "Seth", "Eve", "Eve", "Awan", "Eve"],
        values=[65, 14, 12, 10, 2, 6, 6, 4, 4],
        branchvalues="total",
    )
)
fig.update_layout(margin={"t": 10, "l": 100, "r": 100, "b": 110})
st.plotly_chart(fig, theme="streamlit")

# Separate template Customization Chart
df = px.data.gapminder().query("country == 'Canada'")
fig = px.bar(
    df,
    x="year",
    y="pop",
    hover_data=["lifeExp", "gdpPercap"],
    color="lifeExp",
    template="plotly",
    labels={"pop": "population of Canada"},
    height=400,
)

st.plotly_chart(fig, theme="streamlit")

# Histogram chart
df = px.data.tips()

fig = px.density_heatmap(df, x="total_bill", y="tip")
st.plotly_chart(fig, theme="streamlit")

df = pd.read_csv(
    "https://raw.githubusercontent.com/plotly/datasets/master/finance-charts-apple.csv"
)

fig = px.line(
    df, x="Date", y="AAPL.High", title="Time Series with Range Slider and Selectors"
)

fig.update_xaxes(
    rangeslider_visible=True,
    rangeselector={
        "buttons": [
            {"count": 1, "label": "1m", "step": "month", "stepmode": "backward"},
            {"count": 6, "label": "6m", "step": "month", "stepmode": "backward"},
            {"count": 1, "label": "YTD", "step": "year", "stepmode": "todate"},
            {"count": 1, "label": "1y", "step": "year", "stepmode": "backward"},
            {"step": "all"},
        ]
    },
)
fig.update_layout(height=300, width=600)
fig.update_layout(
    font_family="Courier New",
    font_color="blue",
    title_font_family="Times New Roman",
    title_font_color="red",
    legend_title_font_color="green",
    title_font_size=30,
)
st.plotly_chart(fig, theme="streamlit")

data = pd.DataFrame((100, 120, 104, 102, 203, 102), columns=["some_col"])

fig = px.line(data, height=100, width=300)
fig.update_xaxes(visible=False, fixedrange=True)
fig.update_yaxes(visible=False, fixedrange=True)
fig.update_layout(annotations=[], overwrite=True)
fig.update_layout(showlegend=False, margin={"t": 10, "l": 10, "b": 10, "r": 10})

# uses figure height and width when use_container_width is False
st.plotly_chart(fig, use_container_width=False, theme=None)

# uses container width when use_container_width flag is True
st.plotly_chart(fig, use_container_width=True, theme=None)


================================================
File: /e2e_playwright/st_plotly_chart_select.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import time

import numpy as np
import plotly.express as px

import streamlit as st

# Explicitly seed the RNG for deterministic results
np.random.seed(0)

df_bubble = px.data.gapminder()
fig_bubble = px.scatter(
    df_bubble.query("year==2007"),
    x="gdpPercap",
    y="lifeExp",
    size="pop",
    color="continent",
    hover_name="country",
    log_x=True,
    size_max=60,
)
st.header("Bubble Chart with Box Select")
st.plotly_chart(fig_bubble, on_select="rerun", key="bubble_chart", selection_mode="box")
if (
    st.session_state.get("bubble_chart")
    and len(st.session_state.bubble_chart.selection["points"]) > 0
):
    st.write("The original df data selected:")
    points = st.session_state.bubble_chart.selection["points"]
    # Extract x and y values directly into lists
    x_values = [point["x"] for point in points]
    y_values = [point["y"] for point in points]

    # Use these lists to filter the DataFrame
    filtered_df = df_bubble[
        df_bubble["gdpPercap"].isin(x_values) & df_bubble["lifeExp"].isin(y_values)
    ]
    st.dataframe(filtered_df)
else:
    st.write("Nothing is selected")

st.header("Line Chart with Lasso select")
df = px.data.gapminder().query("continent=='Oceania'")
fig_linechart = px.line(df, x="year", y="lifeExp", color="country", markers=True)
st.plotly_chart(
    fig_linechart, on_select="rerun", key="line_chart", selection_mode=["lasso"]
)
if (
    st.session_state.get("line_chart")
    and len(st.session_state.line_chart.selection["points"]) > 0
):
    st.write("The original df data selected:")
    points = st.session_state.line_chart.selection["points"]
    # Extract x and y values directly into lists
    x_values = [point["x"] for point in points]
    y_values = [point["y"] for point in points]

    # Use these lists to filter the DataFrame
    filtered_df = df[df["year"].isin(x_values) & df["lifeExp"].isin(y_values)]
    st.dataframe(filtered_df)
else:
    st.write("Nothing is selected")

st.header("Bar Chart with Points Selection")
data_canada = px.data.gapminder().query("country == 'Canada'")
fig_bar = px.bar(data_canada, x="year", y="pop")
event_data = st.plotly_chart(
    fig_bar, on_select="rerun", key="bar_chart", selection_mode=["points"]
)
if len(event_data.selection["points"]) > 0:
    st.write("The original df data selected:")
    points = st.session_state.bar_chart.selection["points"]
    # Extract x and y values directly into lists
    x_values = [point["x"] for point in points]
    y_values = [point["y"] for point in points]

    # Use these lists to filter the DataFrame
    filtered_df = data_canada[
        data_canada["year"].isin(x_values) & data_canada["pop"].isin(y_values)
    ]
    st.write(f"Selected points: {len(filtered_df)}")
else:
    st.write("Nothing is selected")


st.header("Box Selections for a Stacked Bar Chart")
wide_df = px.data.medals_wide()
fig = px.bar(
    wide_df, x="nation", y=["gold", "silver", "bronze"], title="Wide-Form Input"
)
event_data = st.plotly_chart(
    fig, on_select="rerun", key="StackedBar_chart", selection_mode=["box", "lasso"]
)
if len(event_data.selection["points"]) > 0:
    st.write("Countries and their medal data that were selected:")
    points = st.session_state.StackedBar_chart.selection["points"]
    # Extract x and y values directly into lists
    x_values = [point["x"] for point in points]

    # Use these lists to filter the DataFrame
    filtered_df = wide_df[wide_df["nation"].isin(x_values)]
    st.dataframe(filtered_df)
else:
    st.write("Nothing is selected")

st.header("Lasso selections on Histograms with a callback")
df = px.data.tips()
fig = px.histogram(df, x="total_bill")


def histogram_callback():
    if len(st.session_state.histogram_chart.selection["points"]) > 0:
        st.write("Callback triggered")
        points = list(st.session_state.histogram_chart.selection["points"])
        st.dataframe(points)


st.plotly_chart(
    fig, on_select=histogram_callback, key="histogram_chart", selection_mode="lasso"
)

if st.button("Create some elements to unmount component"):
    for _ in range(3):
        # The sleep here is needed, because it won't unmount the
        # component if this is too fast.
        time.sleep(1)
        st.write("Another element")

df = px.data.iris()  # iris is a pandas DataFrame
fig = px.scatter(df, x="sepal_width", y="sepal_length")
event_data = st.plotly_chart(
    fig, on_select="rerun", key="bubble_chart_2", selection_mode=("box", "lasso")
)

if len(event_data.selection["points"]) > 0:
    st.dataframe(event_data.selection["points"])

st.header("Bubble Chart with Points & Box Select")
event_data = st.plotly_chart(
    fig_bubble, on_select="rerun", selection_mode=("points", "box")
)
if len(event_data.selection.points) > 0:
    points = event_data.selection.points
    # Extract x and y values directly into lists
    x_values = [point["x"] for point in points]
    y_values = [point["y"] for point in points]

    # Use these lists to filter the DataFrame
    filtered_df = df_bubble[
        df_bubble["gdpPercap"].isin(x_values) & df_bubble["lifeExp"].isin(y_values)
    ]
    st.write(f"Selected points: {len(filtered_df)}")
else:
    st.write("Nothing is selected")


================================================
File: /e2e_playwright/st_plotly_chart_select_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_button,
    get_element_by_key,
)


def test_box_select_on_scatter_chart_displays_a_df(app: Page):
    chart = app.get_by_test_id("stPlotlyChart").nth(0)
    expect(chart).to_be_visible()
    chart.hover()
    app.mouse.down()
    app.mouse.move(50, 50)
    app.mouse.down()
    app.mouse.move(150, 150)
    app.mouse.up()
    wait_for_app_run(app)

    expect(app.get_by_test_id("stDataFrame")).to_have_count(1)


def test_lasso_select_on_line_chart_displays_a_df(app: Page):
    chart = app.get_by_test_id("stPlotlyChart").nth(1)
    chart.scroll_into_view_if_needed()
    expect(chart).to_be_visible()
    chart.hover()
    app.mouse.down()
    app.mouse.move(350, 350)
    app.mouse.move(375, 375)
    app.mouse.move(400, 400)
    app.mouse.move(435, 500)
    app.mouse.up()
    wait_for_app_run(app)

    expect(app.get_by_test_id("stDataFrame")).to_have_count(1)


# This test could be flaky because https://github.com/plotly/plotly.js/issues/6898
# Only run on chromium.
@pytest.mark.flaky(reruns=3)
@pytest.mark.only_browser("chromium")
def test_click_on_bar_chart_displays_a_df_and_double_click_resets_properly(
    app: Page, assert_snapshot: ImageCompareFunction
):
    chart = app.get_by_test_id("stPlotlyChart").nth(2)
    chart.scroll_into_view_if_needed()
    expect(chart).to_be_visible()
    chart.hover()
    app.mouse.down()
    app.mouse.up()
    wait_for_app_run(app, wait_delay=3000)
    expect(app.get_by_text("Selected points: 1")).to_be_attached()

    # Hover chart to show toolbar:
    chart.hover()
    assert_snapshot(chart, name="st_plotly_chart-single_select")

    app.keyboard.down("Shift")
    app.mouse.move(445, 375)
    app.mouse.down()
    app.mouse.up()
    wait_for_app_run(app, wait_delay=3000)

    # Hover chart to show toolbar:
    chart.hover()
    assert_snapshot(chart, name="st_plotly_chart-double_select")
    expect(app.get_by_text("Selected points: 2")).to_be_attached()

    chart.scroll_into_view_if_needed()
    # Hover to position the cursor for a more reliable double click
    chart.hover()
    app.mouse.dblclick(400, 400)
    wait_for_app_run(app, 3000)
    expect(app.get_by_test_id("stDataFrame")).to_have_count(0)
    chart.scroll_into_view_if_needed()
    # Hover chart to show toolbar:
    chart.hover()
    assert_snapshot(chart, name="st_plotly_chart-bar_chart_reset")


def test_box_select_on_stacked_bar_chart_displays_a_df(app: Page):
    chart = app.get_by_test_id("stPlotlyChart").nth(3)
    chart.scroll_into_view_if_needed()
    expect(chart).to_be_visible()
    chart.hover()
    app.mouse.down()
    app.mouse.move(50, 50)
    app.mouse.down()
    app.mouse.move(150, 150)
    app.mouse.up()
    wait_for_app_run(app)
    expect(app.get_by_test_id("stDataFrame")).to_have_count(1)


@pytest.mark.skip_browser("webkit")  # Flaky on WebKit, but manually tested
def test_lasso_select_on_histogram_chart_displays_a_df_and_resets_when_double_clicked(
    app: Page, assert_snapshot: ImageCompareFunction
):
    chart = app.get_by_test_id("stPlotlyChart").nth(4)
    chart.scroll_into_view_if_needed()
    expect(chart).to_be_visible()
    chart.hover()
    app.mouse.down()
    app.mouse.move(350, 350)
    app.mouse.move(375, 375)
    app.mouse.move(400, 400)
    app.mouse.move(435, 500)
    app.mouse.up()
    wait_for_app_run(app, 3000)

    # Check if the callback was triggered
    expect(app.get_by_text("Callback triggered")).to_be_attached()
    expect(app.get_by_test_id("stDataFrame")).to_have_count(1)
    chart.scroll_into_view_if_needed()
    # Hover to position the cursor for a more reliable double click
    chart.hover()
    chart.dblclick(position={"x": 100, "y": 100})
    wait_for_app_run(app, 3000)

    expect(app.get_by_text("Callback triggered")).not_to_be_attached()
    expect(app.get_by_test_id("stDataFrame")).to_have_count(0)

    chart.scroll_into_view_if_needed()

    # Hover chart to show toolbar:
    chart.hover()
    assert_snapshot(chart, name="st_plotly_chart-reset")


def test_double_click_select_mode_doesnt_reset_zoom(
    app: Page, assert_snapshot: ImageCompareFunction
):
    chart = app.get_by_test_id("stPlotlyChart").nth(0)
    expect(chart).to_be_visible()
    chart.hover()
    app.mouse.down()
    app.mouse.move(50, 50)
    app.mouse.down()
    app.mouse.move(150, 150)
    app.mouse.up()
    wait_for_app_run(app)
    expect(app.get_by_test_id("stDataFrame")).to_have_count(1)

    app.locator('[data-title="Zoom in"]').nth(0).click()
    app.mouse.dblclick(350, 350)
    wait_for_app_run(app, 3000)

    chart.scroll_into_view_if_needed()
    # Hover chart to show toolbar:
    chart.hover()
    assert_snapshot(chart, name="st_plotly_chart-zoomed_in_reset")


def test_double_click_pan_mode_resets_zoom_and_doesnt_rerun(
    app: Page, assert_snapshot: ImageCompareFunction
):
    chart = app.get_by_test_id("stPlotlyChart").nth(0)
    expect(chart).to_be_visible()
    chart.hover()
    app.mouse.down()
    app.mouse.move(50, 50)
    app.mouse.down()
    app.mouse.move(150, 150)
    app.mouse.up()
    wait_for_app_run(app)
    expect(app.get_by_test_id("stDataFrame")).to_have_count(1)

    app.locator('[data-title="Pan"]').nth(0).click()
    app.mouse.down()
    app.mouse.move(450, 450)
    app.mouse.move(350, 350)
    app.mouse.up()

    # Hover chart to show toolbar:
    chart.hover()
    assert_snapshot(chart, name="st_plotly_chart-panned")

    # Hover to position the cursor for a more reliable double click
    chart.hover()
    app.mouse.dblclick(675, 400)
    wait_for_app_run(app, 3000)

    # Hover chart to show toolbar:
    chart.hover()
    assert_snapshot(chart, name="st_plotly_chart-panned_reset")


def test_selection_state_remains_after_unmounting(
    app: Page, assert_snapshot: ImageCompareFunction
):
    chart = app.get_by_test_id("stPlotlyChart").nth(5)
    expect(chart).to_be_visible()
    chart.scroll_into_view_if_needed()
    chart.hover()
    app.mouse.down()
    app.mouse.move(350, 350)
    app.mouse.move(450, 450)
    app.mouse.up()
    wait_for_app_run(app)

    click_button(app, "Create some elements to unmount component")
    # wait for the "Another element" texts to appear on the screen before
    # getting the chart element to make sure that the chart is the new one
    # and not the old one which is going to be replaced and can lead to a
    # "Element not in DOM" error when trying to take the snapshot.
    added_elements = app.get_by_text("Another element")
    # for each added element, we sleep 1 second, so let's add some more seconds to the
    # timeout
    expect(added_elements).to_have_count(3, timeout=8000)

    chart = app.get_by_test_id("stPlotlyChart").nth(5)
    expect(chart).to_be_visible()
    # Hover chart to show toolbar:
    chart.hover()
    assert_snapshot(chart, name="st_plotly_chart-unmounted_still_has_selection")


def test_supports_points_and_box_if_activated(app: Page):
    chart = app.get_by_test_id("stPlotlyChart").nth(6)
    chart.scroll_into_view_if_needed()
    expect(chart).to_be_visible()
    chart.hover()
    app.mouse.down()
    app.mouse.up()
    wait_for_app_run(app)
    expect(app.get_by_text("Selected points: 1")).to_be_attached()

    chart.locator('[data-title="Box Select"]').nth(0).click()
    chart.hover()
    app.mouse.down()
    app.mouse.move(50, 50)
    app.mouse.down()
    app.mouse.move(150, 150)
    app.mouse.up()
    wait_for_app_run(app)
    expect(app.get_by_text("Selected points: 25")).to_be_attached()


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stPlotlyChart")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "line_chart")).to_be_visible()


================================================
File: /e2e_playwright/st_plotly_chart_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class


# Only do chromium as this can create a lot of screenshots
# there should be no differences between chrome and safari and firefox
@pytest.mark.only_browser("chromium")
def test_plotly_has_consistent_visuals(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    snapshot_names = [
        "st_plotly_chart-none_theme",
        "st_plotly_chart-streamlit_theme_use_container_width",
        "st_plotly_chart-candlestick_streamlit_theme",
        "st_plotly_chart-sunburst_custom_color",
        "st_plotly_chart-contour_heatmap_together",
        "st_plotly_chart-waterfall_chart_custom_height_and_width",
        "st_plotly_chart-ternary_chart",
        "st_plotly_chart-table_plot",
        "st_plotly_chart-electric_colorscale",
        "st_plotly_chart-discrete_sequence",
        "st_plotly_chart-layout_customization",
        "st_plotly_chart-template_customization",
        "st_plotly_chart-histogram_chart",
    ]
    expect(themed_app.get_by_test_id("stPlotlyChart")).to_have_count(16)
    for i, name in enumerate(snapshot_names):
        assert_snapshot(
            themed_app.get_by_test_id("stPlotlyChart").nth(i),
            name=name,
        )


def test_plotly_has_correct_visuals(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    snapshot_names = [
        "st_plotly_chart-line_chart_specific_height_width",
        "st_plotly_chart-use_container_width_false_and_specified_height",
        "st_plotly_chart-none_theme_and_use_container_width",
    ]
    plotly_indices = [13, 14, 15]
    for i, name in enumerate(snapshot_names):
        assert_snapshot(
            themed_app.get_by_test_id("stPlotlyChart").nth(plotly_indices[i]),
            name=name,
        )


def test_plotly_use_container_width_false_fullscreen(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    index = 14
    themed_app.get_by_test_id("stPlotlyChart").nth(index).hover()
    fullscreen_button = themed_app.locator('[data-title="Fullscreen"]').nth(index)
    fullscreen_button.hover()
    fullscreen_button.click()
    assert_snapshot(
        themed_app.get_by_test_id("stPlotlyChart").nth(index),
        name="st_plotly_chart-container_width_false_fullscreen",
    )

    fullscreen_button = themed_app.locator('[data-title="Close fullscreen"]').nth(0)
    fullscreen_button.hover()
    fullscreen_button.click()
    assert_snapshot(
        themed_app.get_by_test_id("stPlotlyChart").nth(index),
        name="st_plotly_chart-container_width_false_exited_fullscreen",
    )


def test_plotly_use_container_width_true_fullscreen(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    index = 15
    themed_app.get_by_test_id("stPlotlyChart").nth(index).hover()
    fullscreen_button = themed_app.locator('[data-title="Fullscreen"]').nth(index)
    fullscreen_button.hover()
    fullscreen_button.click()
    assert_snapshot(
        themed_app.get_by_test_id("stPlotlyChart").nth(index),
        name="st_plotly_chart-container_width_true_fullscreen",
    )

    fullscreen_button = themed_app.locator('[data-title="Close fullscreen"]').nth(0)
    fullscreen_button.hover()
    fullscreen_button.click()
    assert_snapshot(
        themed_app.get_by_test_id("stPlotlyChart").nth(index),
        name="st_plotly_chart-container_width_true_exited_fullscreen",
    )


def test_allows_custom_toolbar_modifications(
    app: Page, assert_snapshot: ImageCompareFunction
):
    chart_element = app.get_by_test_id("stPlotlyChart").nth(1)
    chart_element.hover()
    assert_snapshot(
        chart_element,
        name="st_plotly_chart-toolbar_customization",
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stPlotlyChart")


================================================
File: /e2e_playwright/st_popover.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import numpy as np
import pandas as pd

import streamlit as st

# Create random dataframe:
np.random.seed(0)
df = pd.DataFrame(np.random.randn(50, 5), columns=["a", "b", "c", "d", "e"])

st.popover("popover 1 (empty)")

with st.popover("popover 2 (use_container_width)", use_container_width=True):
    st.markdown("Hello")

with st.popover(
    "popover 3 (with widgets)",
):
    st.markdown("Hello World 👋")
    text = st.text_input("Text input")
    col1, col2, col3 = st.columns(3)
    col1.text_input("Column 1")
    col2.text_input("Column 2")
    col3.text_input("Column 3")
    st.selectbox("Selectbox", ["a", "b", "c"])

with st.popover("popover 4 (with dataframe)", help="help text"):
    st.markdown("Popover with dataframe")
    st.dataframe(df, use_container_width=True)
    st.image(np.repeat(0, 100).reshape(10, 10))

with st.sidebar.popover("popover 5 (in sidebar)"):
    st.markdown("Popover in sidebar with dataframe")
    st.dataframe(df, use_container_width=True)

with st.popover("popover 6 (disabled)", disabled=True):
    st.markdown("Hello World 👋")

with st.popover("popover 7 (emoji)", icon="🦄"):
    st.markdown("Hello unicorn")

with st.popover("popover 8 (material icon)", icon=":material/thumb_up:"):
    st.markdown("Hello thumb up")

with st.expander("Output"):
    st.markdown(text)


================================================
File: /e2e_playwright/st_popover_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import check_top_level_class


def test_popover_button_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the popover buttons are correctly rendered via screenshot matching."""
    popover_elements = themed_app.get_by_test_id("stPopover")
    expect(popover_elements).to_have_count(8)

    assert_snapshot(popover_elements.nth(0), name="st_popover-sidebar")
    assert_snapshot(popover_elements.nth(1), name="st_popover-empty")
    assert_snapshot(popover_elements.nth(2), name="st_popover-use_container_width")
    assert_snapshot(popover_elements.nth(3), name="st_popover-normal")
    # Popover button 4 is almost the same as 3, so we don't need to test it
    assert_snapshot(popover_elements.nth(5), name="st_popover-disabled")
    assert_snapshot(popover_elements.nth(6), name="st_popover-emoji_icon")
    assert_snapshot(popover_elements.nth(7), name="st_popover-material_icon")


def test_popover_container_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the popover container is correctly rendered via screenshot matching."""
    # Get the widgets popover container:
    popover_element = themed_app.get_by_test_id("stPopover").nth(3)
    # Click the button to open it:
    popover_element.locator("button").click()

    # Check that it is open:
    popover_container = themed_app.get_by_test_id("stPopoverBody")
    expect(popover_container).to_be_visible()
    expect(popover_container.get_by_test_id("stMarkdown")).to_have_text(
        "Hello World 👋"
    )

    # Click somewhere outside the close popover container:
    themed_app.get_by_test_id("stApp").click(position={"x": 0, "y": 0})
    expect(popover_container).not_to_be_visible()

    # Click the button to open it:
    popover_element.locator("button").click()

    popover_container = themed_app.get_by_test_id("stPopoverBody")
    expect(popover_container).to_be_visible()
    expect(popover_container.get_by_test_id("stMarkdown")).to_have_text(
        "Hello World 👋"
    )
    expect(popover_container.get_by_test_id("stTextInput")).to_have_count(4)

    assert_snapshot(popover_container, name="st_popover-container")


def test_popover_with_use_container_width(app: Page):
    """Test that the popover container is correctly stretched to the button width
    if `use_container_width=True`."""
    # Get the stretched popover container:
    popover_element = app.get_by_test_id("stPopover").nth(2)
    # Click the button to open it:
    popover_element.locator("button").click()

    # Check that it is open:
    popover_container = app.get_by_test_id("stPopoverBody")
    expect(popover_container).to_be_visible()
    expect(popover_container.get_by_test_id("stMarkdown")).to_have_text("Hello")
    # Check that the min width is stretched to the full container width:
    expect(popover_container).to_have_css("min-width", "704px")


def test_applying_changes_from_popover_container(app: Page):
    """Test that changes made in the popover container are applied correctly."""
    # Get the widgets popover container:
    popover_element = app.get_by_test_id("stPopover").nth(3)
    # Click the button to open it:
    popover_element.locator("button").click()

    # Check that it is open:
    popover_container = app.get_by_test_id("stPopoverBody")
    expect(popover_container).to_be_visible()
    expect(popover_container.get_by_test_id("stMarkdown")).to_have_text(
        "Hello World 👋"
    )

    # Fill in the text:
    text_input_element = popover_container.get_by_test_id("stTextInput").nth(0)
    text_input_element.locator("input").first.fill("Input text in popover")
    wait_for_app_run(app)

    # Click somewhere outside the close popover container:
    app.get_by_test_id("stApp").click(position={"x": 0, "y": 0})
    expect(popover_container).not_to_be_visible()

    # Click the button to open it:
    popover_element.locator("button").click()

    popover_container = app.get_by_test_id("stPopoverBody")
    expect(popover_container).to_be_visible()

    # Write a text into a text input
    text_input_element = popover_container.get_by_test_id("stTextInput").nth(0)
    text_input_element.locator("input").first.fill("Input text in popover")
    wait_for_app_run(app)

    # Check that it is still open after rerun:
    expect(popover_container).to_be_visible()
    expect(popover_container.get_by_test_id("stMarkdown")).to_have_text(
        "Hello World 👋"
    )

    # Click somewhere outside the close popover container
    app.get_by_test_id("stApp").click(position={"x": 0, "y": 0})
    expect(popover_container).not_to_be_visible()

    # The main app should render this text:
    expect(app.get_by_test_id("stExpander").get_by_test_id("stMarkdown")).to_have_text(
        "Input text in popover"
    )


def test_fullscreen_mode_is_disabled_in_popover(app: Page):
    """Test that the fullscreen mode is disabled within a popover container."""
    # Get the fullscreen elements popover container:
    popover_element = app.get_by_test_id("stPopover").nth(4)
    # Click the button to open it:
    popover_element.get_by_test_id("stPopoverButton").first.click()

    popover_container = app.get_by_test_id("stPopoverBody")
    expect(popover_container).to_be_visible()

    # Check dataframe toolbar:
    dataframe_element = popover_container.get_by_test_id("stDataFrame").nth(0)
    expect(dataframe_element).to_be_visible()
    dataframe_toolbar = dataframe_element.get_by_test_id("stElementToolbar")
    # Hover over dataframe
    dataframe_element.hover()
    # Should only have  two buttons, search + download CSV
    expect(dataframe_toolbar.get_by_test_id("stElementToolbarButton")).to_have_count(2)


def test_show_tooltip_on_hover(app: Page):
    """Test that the tooltip is shown when hovering over a popover button."""
    popover_button = (
        app.get_by_test_id("stPopover").nth(4).get_by_test_id("stPopoverButton").first
    )
    # Click the button to open it:
    popover_button.hover()

    expect(app.get_by_test_id("stTooltipContent")).to_have_text("help text")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stPopover")


================================================
File: /e2e_playwright/st_progress.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.progress(50)

st.progress(30, text="This is very long and boring text. " * 6)
st.progress(
    0.5,
    text=(
        "Please be patient :clock1:. **bold text**. $$ x = 1 + 2 $$, :blue[Blue text]"
    ),
)


================================================
File: /e2e_playwright/st_progress_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class


def test_progress_renders_properly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    progress_bars = themed_app.get_by_test_id("stProgress")
    expect(progress_bars.get_by_role("progressbar").nth(0)).to_have_attribute(
        "aria-valuenow", "50"
    )
    for i in range(len(progress_bars.all())):
        assert_snapshot(
            themed_app.get_by_test_id("stProgress").nth(i), name=f"st_progress-{i}"
        )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stProgress")


================================================
File: /e2e_playwright/st_pydeck_chart.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import math
from typing import Any, cast

import numpy as np
import pandas as pd
import pydeck as pdk

import streamlit as st

# Empty chart.

st.pydeck_chart()

# Basic chart.

np.random.seed(12345)

df = pd.DataFrame(
    cast(Any, np.random.randn(1000, 2) / [50, 50]) + [37.76, -122.4],
    columns=["lat", "lon"],
)

st.pydeck_chart(
    pdk.Deck(
        map_style="mapbox://styles/mapbox/light-v9",
        initial_view_state=pdk.ViewState(
            latitude=37.76,
            longitude=-122.4,
            zoom=11,
            pitch=50,
        ),
        layers=[
            pdk.Layer(
                "HexagonLayer",
                data=df,
                get_position="[lon, lat]",
                radius=200,
                elevation_scale=4,
                elevation_range=[0, 1000],
                pickable=True,
                extruded=True,
            ),
            pdk.Layer(
                "ScatterplotLayer",
                data=df,
                get_position="[lon, lat]",
                get_color="[200, 30, 0, 160]",
                get_radius=200,
            ),
        ],
    )
)

# Chart w/ invalid JSON - issue #5799.
data = pd.DataFrame({"lng": [-109.037673], "lat": [36.994672], "weight": [math.nan]})
layer = pdk.Layer(
    "ScatterplotLayer", data=data, get_position=["lng", "lat"], radius_min_pixels=4
)
deck = pdk.Deck(
    layers=[layer],
    map_style=pdk.map_styles.CARTO_LIGHT,
    tooltip={"text": "weight: {weight}"},
)
st.pydeck_chart(deck, use_container_width=True)

H3_HEX_DATA = [
    {"hex": "88283082b9fffff", "count": 10},
    {"hex": "88283082d7fffff", "count": 50},
    {"hex": "88283082a9fffff", "count": 100},
]
df = pd.DataFrame(H3_HEX_DATA)

st.pydeck_chart(
    pdk.Deck(
        map_style="mapbox://styles/mapbox/outdoors-v12",
        tooltip={"text": "Count: {count}"},
        initial_view_state=pdk.ViewState(
            latitude=37.7749295, longitude=-122.4194155, zoom=12, bearing=0, pitch=30
        ),
        layers=[
            pdk.Layer(
                "H3HexagonLayer",
                df,
                pickable=True,
                stroked=True,
                filled=True,
                get_hexagon="hex",
                get_fill_color="[0, 255, 0]",
                get_line_color=[255, 255, 255],
                line_width_min_pixels=2,
            ),
        ],
    )
)

st.pydeck_chart(
    pdk.Deck(
        initial_view_state=pdk.ViewState(
            latitude=37.76,
            longitude=-122.4,
            zoom=11,
            pitch=50,
        ),
        layers=[
            pdk.Layer(
                "HexagonLayer",
                data=df,
                get_position="[lon, lat]",
                radius=200,
                elevation_scale=4,
                elevation_range=[0, 1000],
                pickable=True,
                extruded=True,
            ),
            pdk.Layer(
                "ScatterplotLayer",
                data=df,
                get_position="[lon, lat]",
                get_color="[200, 30, 0, 160]",
                get_radius=200,
            ),
        ],
    )
)

st.pydeck_chart(
    pdk.Deck(
        map_style="mapbox://styles/mapbox/outdoors-v12",
        initial_view_state=pdk.ViewState(
            latitude=37.7749295, longitude=-122.4194155, zoom=12, bearing=0, pitch=30
        ),
        layers=[
            pdk.Layer(
                "H3HexagonLayer",
                df,
                pickable=True,
                stroked=True,
                filled=True,
                get_hexagon="hex",
                get_fill_color="[0, 255, 0]",
                get_line_color=[255, 255, 255],
                line_width_min_pixels=2,
            ),
        ],
    ),
    width=200,
    height=250,
    use_container_width=False,
)


================================================
File: /e2e_playwright/st_pydeck_chart_select.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from __future__ import annotations

import time
from io import StringIO
from typing import Literal

import pandas as pd
import pydeck as pdk

import streamlit as st
from shared.pydeck_utils import get_pydeck_chart

st.header("PyDeck Chart")

if st.button("Create some elements to unmount component"):
    for _ in range(3):
        # The sleep here is needed, because it won't unmount the
        # component if this is too fast.
        time.sleep(1)
        st.write("Another element")

selection_mode: Literal["single-object", "multi-object"] = st.selectbox(
    "Map Selection Mode",
    ["single-object", "multi-object"],
)

event_data = get_pydeck_chart("managed_map", selection_mode)

st.write(
    "session_state.managed_map:",
    str(st.session_state.get("managed_map") or ""),
)
st.write("managed_map selection:", str(event_data))


st.divider()
st.header("PyDeck Chart with Callback")


def on_selection():
    st.write(
        "PyDeck selection callback:",
        str(st.session_state.selection_callback),
    )


selection = get_pydeck_chart(
    "selection_callback", selection_mode="single-object", on_select=on_selection
)


st.divider()
st.header("PyDeck Chart in Form")

with st.form(key="my_form", clear_on_submit=True):
    selection = get_pydeck_chart("selection_in_form", selection_mode="single-object")
    st.form_submit_button("Submit")

st.write("PyDeck-in-form selection:", str(selection))
if "selection_in_form" in st.session_state:
    st.write(
        "PyDeck-in-form selection in session state:",
        str(st.session_state.selection_in_form),
    )


st.divider()
st.header("PyDeck Chart in Fragment")


@st.fragment
def test_fragment():
    selection = get_pydeck_chart("selection_in_fragment", "single-object")
    st.write("PyDeck-in-fragment selection:", str(selection))


test_fragment()

if "runs" not in st.session_state:
    st.session_state.runs = 0
st.session_state.runs += 1
st.write("Runs:", st.session_state.runs)

st.divider()
st.header("Scatterplot")


CITY_CSV = """
"City","State","Lat","Long","Size"
"Denver","Colorado",39.7391667,-104.984167,"30000"
"Hartford","Connecticut",41.767,-72.677,"100000"
"Juneau","Alaska",58.301935,-134.419740,"10000"
"Little Rock","Arkansas",34.736009,-92.331122,"50000"
"Phoenix","Arizona",33.448457,-112.073844,"200000"
"Sacramento","California",38.555605,-121.468926,"150000"
"""

csv_file_like = StringIO(CITY_CSV)


cities = pd.read_csv(
    csv_file_like,
    header=0,
    names=[
        "City",
        "State",
        "Lat",
        "Long",
        "Size",
    ],
)


st.pydeck_chart(
    pdk.Deck(
        pdk.Layer(
            "ScatterplotLayer",
            data=cities,
            id="cities",
            get_position=["Long", "Lat"],
            get_color="[255, 75, 75, 127]",
            pickable=True,
            get_radius="Size",
        ),
        initial_view_state=pdk.ViewState(
            latitude=cities.Lat.mean(),
            longitude=cities.Long.mean(),
            controller=True,
            zoom=3,
            pitch=50,
        ),
        tooltip={"text": "{City}, Size: {Size}"},
    ),
    on_select="rerun",
    selection_mode="single-object",
)


================================================
File: /e2e_playwright/st_pydeck_chart_select_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from typing import Literal

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import (
    ImageCompareFunction,
    wait_for_app_run,
)
from e2e_playwright.shared.app_utils import (
    click_button,
    click_form_button,
    expect_prefixed_markdown,
)
from e2e_playwright.shared.pydeck_utils import (
    get_click_handling_div,
    wait_for_chart,
)

# The pydeck tests are a lot flakier than need be so increase the pixel threshold
PIXEL_THRESHOLD = 1.0

EMPTY_SELECTION = "{'selection': {'indices': {}, 'objects': {}}}"


def _set_selection_mode(app: Page, mode: Literal["single-object", "multi-object"]):
    app.get_by_test_id("stSelectbox").nth(0).locator("input").click()
    selection_dropdown = app.locator('[data-baseweb="popover"]').first
    selection_dropdown.locator("li").nth(1 if mode == "multi-object" else 0).click()

    wait_for_app_run(app, wait_delay=5000)


# A note on browser testing strategy. We are only testing on Chromium because:
#   - Firefox seems to be failing but can't reproduce locally and video from CI
#     produces an empty element for PyDeck
#   - Webkit is too slow on CI, leading to flaky tests
#
# Getting coverage in Chromium is sufficient for now since the underlying logic
# is the same and we are not testing for browser-specific behavior.
#
# Additionally, even the deck.gl docs caution against visual tests since it
# renders to a canvas element:
# https://github.com/visgl/deck.gl/blob/master/docs/developer-guide/testing.md


@pytest.mark.only_browser("chromium")
def test_pydeck_chart_multiselect_interactions_and_return_values(app: Page):
    """
    Test single selection, multi selection, and deselection all function
    properly and return the expected values in both session_state and as a
    return of st.pydeck.
    """
    _set_selection_mode(app, "multi-object")
    wait_for_chart(app)

    click_handling_div = get_click_handling_div(app, nth=0)
    markdown_prefix_session_state = "session_state.managed_map:"
    markdown_prefix = "managed_map selection:"

    # Assert we haven't yet written anything out for the debugging state
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        EMPTY_SELECTION,
    )
    expect_prefixed_markdown(
        app,
        markdown_prefix_session_state,
        EMPTY_SELECTION,
    )

    # Click on the hex that has count: 10
    click_handling_div.click(position={"x": 344, "y": 201})

    first_point_selection = "{'selection': {'indices': {'MyHexLayer': [0]}, 'objects': {'MyHexLayer': [{'count': 10, 'hex': '88283082b9fffff'}]}}}"
    # Assert the values returned are correct for the point we selected
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        first_point_selection,
    )
    expect_prefixed_markdown(
        app,
        markdown_prefix_session_state,
        first_point_selection,
    )

    # Multiselect and click the hex that has count: 100
    click_handling_div.click(position={"x": 417, "y": 229})

    second_point_selection = "{'selection': {'indices': {'MyHexLayer': [0, 2]}, 'objects': {'MyHexLayer': [{'count': 10, 'hex': '88283082b9fffff'}, {'count': 100, 'hex': '88283082a9fffff'}]}}}"
    # Now we assert that the values include the new point we selected as well as
    # the previous one
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        second_point_selection,
    )
    expect_prefixed_markdown(
        app,
        markdown_prefix_session_state,
        second_point_selection,
    )

    # Deselect everything by clicking away from an object in a layer
    click_handling_div.click(position={"x": 0, "y": 0})

    # Assert that we have deselected everything
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        EMPTY_SELECTION,
    )
    expect_prefixed_markdown(
        app,
        markdown_prefix_session_state,
        EMPTY_SELECTION,
    )


@pytest.mark.only_browser("chromium")
def test_pydeck_chart_single_select_interactions_and_return_values(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """
    Test single selection and deselection all function properly and return the
    expected values in both session_state and as a return of st.pydeck.
    """
    _set_selection_mode(app, "single-object")
    wait_for_chart(app)

    click_handling_div = get_click_handling_div(app, nth=0)
    markdown_prefix_session_state = "session_state.managed_map:"
    markdown_prefix = "managed_map selection:"

    # Click on the hex that has count: 10
    click_handling_div.click(position={"x": 344, "y": 201})
    point_selection = "{'selection': {'indices': {'MyHexLayer': [0]}, 'objects': {'MyHexLayer': [{'count': 10, 'hex': '88283082b9fffff'}]}}}"
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        point_selection,
    )
    expect_prefixed_markdown(
        app,
        markdown_prefix_session_state,
        point_selection,
    )

    # Click the hex that has count: 100
    click_handling_div.click(position={"x": 417, "y": 229})

    point_selection = "{'selection': {'indices': {'MyHexLayer': [2]}, 'objects': {'MyHexLayer': [{'count': 100, 'hex': '88283082a9fffff'}]}}}"
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        point_selection,
    )
    expect_prefixed_markdown(
        app,
        markdown_prefix_session_state,
        point_selection,
    )

    # Click on the hex that has count: 10
    click_handling_div.click(position={"x": 344, "y": 201})
    point_selection = "{'selection': {'indices': {'MyHexLayer': [0]}, 'objects': {'MyHexLayer': [{'count': 10, 'hex': '88283082b9fffff'}]}}}"
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        point_selection,
    )
    expect_prefixed_markdown(
        app,
        markdown_prefix_session_state,
        point_selection,
    )

    # Deselect everything by clicking away from an object in a layer
    click_handling_div.click(position={"x": 0, "y": 0})

    # Assert that we have deselected everything
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        EMPTY_SELECTION,
    )
    expect_prefixed_markdown(
        app,
        markdown_prefix_session_state,
        EMPTY_SELECTION,
    )

    # Scatterplot checks
    click_handling_div = get_click_handling_div(app, nth=4)
    click_handling_div.scroll_into_view_if_needed()

    # Click on the scatterplot point with the biggest size
    click_handling_div.click(position={"x": 279, "y": 331})

    wait_for_app_run(app, wait_delay=5000)

    # Assert that we have deselected everything
    assert_snapshot(
        click_handling_div,
        name="st_pydeck_chart_select-scatterplot-single-selection",
        pixel_threshold=PIXEL_THRESHOLD,
    )


@pytest.mark.only_browser("chromium")
def test_pydeck_chart_multiselect_has_consistent_visuals(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """
    Test that no selection, single selection, multi selection, and deselection
    all look visually correct.
    """
    _set_selection_mode(app, "multi-object")
    wait_for_chart(app)

    click_handling_div = get_click_handling_div(app, nth=0)

    assert_snapshot(
        click_handling_div,
        name="st_pydeck_chart_select-no-selections",
        pixel_threshold=PIXEL_THRESHOLD,
    )

    # Click on the hex that has count: 10
    click_handling_div.click(position={"x": 344, "y": 201})

    wait_for_app_run(app, wait_delay=5000)

    assert_snapshot(
        click_handling_div,
        name="st_pydeck_chart_select-single-selection",
        pixel_threshold=PIXEL_THRESHOLD,
    )

    # Multiselect and click the hex that has count: 100
    click_handling_div.click(position={"x": 417, "y": 229})

    wait_for_app_run(app, wait_delay=5000)

    assert_snapshot(
        click_handling_div,
        name="st_pydeck_chart_select-multi-selection",
        pixel_threshold=PIXEL_THRESHOLD,
    )

    # Deselect everything by clicking away from an object in a layer
    click_handling_div.click(position={"x": 0, "y": 0})

    wait_for_app_run(app, wait_delay=5000)

    # Assert that we have deselected everything
    assert_snapshot(
        click_handling_div,
        name="st_pydeck_chart_select-deselected",
        pixel_threshold=PIXEL_THRESHOLD,
    )


@pytest.mark.only_browser("chromium")
def test_pydeck_chart_selection_state_remains_after_unmounting(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """
    Test that no selection, single selection, multi selection, and deselection
    all look visually correct.
    """
    _set_selection_mode(app, "multi-object")
    wait_for_chart(app)

    click_handling_div = get_click_handling_div(app, nth=0)

    # Click on the hex that has count: 10
    click_handling_div.click(position={"x": 344, "y": 201})

    wait_for_app_run(app, wait_delay=5000)

    # Multiselect and click the hex that has count: 100
    click_handling_div.click(position={"x": 417, "y": 229})

    wait_for_app_run(app, wait_delay=5000)

    click_button(app, "Create some elements to unmount component")
    wait_for_app_run(app, wait_delay=5000)

    wait_for_chart(app)

    assert_snapshot(
        click_handling_div,
        name="st_pydeck_chart_selection_state_remains_after_unmounting",
    )


@pytest.mark.only_browser("chromium")
def test_pydeck_chart_selection_callback(app: Page):
    """
    Test the callback functionality of a PyDeck chart.
    """
    wait_for_chart(app)

    click_handling_div = get_click_handling_div(app, nth=1)

    markdown_prefix = "PyDeck selection callback:"

    # Assert we haven't yet written anything out for the debugging state
    expect(app.get_by_text(markdown_prefix)).to_have_count(0)

    # Click on the hex that has count: 10
    click_handling_div.click(position={"x": 344, "y": 201})

    # Assert that the debug values are written out since we clicked on the map
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        "{'selection': {'indices': {'MyHexLayer': [0]}, 'objects': {'MyHexLayer': [{'count': 10, 'hex': '88283082b9fffff'}]}}}",
    )


@pytest.mark.only_browser("chromium")
def test_pydeck_chart_selection_in_form(app: Page):
    """
    Test the selection functionality of a PyDeck chart within a form.
    """
    wait_for_chart(app)

    click_handling_div = get_click_handling_div(app, nth=2)

    # Assert we haven't yet written anything out for the debugging state
    markdown_prefix = "PyDeck-in-form selection:"
    markdown_prefix_session_state = "PyDeck-in-form selection in session state:"

    # Click on the hex that has count: 10
    click_handling_div.click(position={"x": 326, "y": 208})

    wait_for_app_run(app)

    empty_selection = "{'selection': {'indices': {}, 'objects': {}}}"
    # Nothing should be shown yet because we did not submit the form
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        empty_selection,
    )
    expect_prefixed_markdown(
        app,
        markdown_prefix_session_state,
        empty_selection,
    )

    # submit the form. The selection uses a debounce of 200ms; if we click too
    # early, the state is not updated correctly and we submit the old,
    # unselected values
    app.wait_for_timeout(210)

    click_form_button(app, "Submit")

    expected_selection = "{'selection': {'indices': {'MyHexLayer': [0]}, 'objects': {'MyHexLayer': [{'count': 10, 'hex': '88283082b9fffff'}]}}}"

    expect_prefixed_markdown(app, markdown_prefix, expected_selection)
    expect_prefixed_markdown(app, markdown_prefix_session_state, expected_selection)
    expect(app.get_by_test_id("stForm")).not_to_contain_text("Error")


@pytest.mark.only_browser("chromium")
def test_pydeck_chart_selection_in_fragment(app: Page):
    """
    Test the selection functionality of a PyDeck chart within a fragment.
    """
    wait_for_chart(app)

    click_handling_div = get_click_handling_div(app, nth=3)

    # Check that the main script has run once (the initial run)
    expect(app.get_by_text("Runs: 1")).to_be_visible()

    # Assert we haven't yet written anything out for the debugging state
    markdown_prefix = "PyDeck-in-fragment selection:"

    # Nothing should be shown yet because we did do anything yet
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        "{'selection': {'indices': {}, 'objects': {}}}",
    )

    # Click on the hex that has count: 10
    click_handling_div.click(position={"x": 344, "y": 201})

    # Assert that the debug values are written out since we clicked on the map
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        "{'selection': {'indices': {'MyHexLayer': [0]}, 'objects': {'MyHexLayer': [{'count': 10, 'hex': '88283082b9fffff'}]}}}",
    )

    # Check that the main script has not re-run
    expect(app.get_by_text("Runs: 1")).to_be_visible()


================================================
File: /e2e_playwright/st_pydeck_chart_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import check_top_level_class
from e2e_playwright.shared.toolbar_utils import (
    assert_fullscreen_toolbar_button_interactions,
)


# Firefox seems to be failing but can't reproduce locally and video produces an empty page for firefox
@pytest.mark.skip_browser("firefox")
def test_pydeck_chart_has_consistent_visuals(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    # The pydeck chart takes a while to load so check that
    # it gets attached with an increased timeout.
    pydeck_charts = themed_app.get_by_test_id("stDeckGlJsonChart")
    expect(pydeck_charts).to_have_count(6, timeout=15000)

    # The map assets can take more time to load, add an extra timeout
    # to prevent flakiness.
    themed_app.wait_for_timeout(10000)

    # The pydeck tests are a lot flakier than need be so increase the pixel threshold
    assert_snapshot(
        pydeck_charts.nth(0),
        name="st_pydeck_chart-empty",
        pixel_threshold=1.0,
    )

    # The pydeck tests are a lot flakier than need be so increase the pixel threshold
    assert_snapshot(
        pydeck_charts.nth(1).locator("canvas").nth(0),
        name="st_pydeck_chart-san_francisco_overridden_light_theme",
        pixel_threshold=1.0,
    )

    # The pydeck tests are a lot flakier than need be so increase the pixel threshold
    assert_snapshot(
        pydeck_charts.nth(2).locator("canvas").nth(1),
        name="st_pydeck_chart-continents",
        pixel_threshold=1.0,
    )

    # The pydeck tests are a lot flakier than need be so increase the pixel threshold
    assert_snapshot(
        pydeck_charts.nth(3).locator("canvas").nth(1),
        name="st_pydeck_chart-geo_layers",
        pixel_threshold=1.0,
    )

    # The pydeck tests are a lot flakier than need be so increase the pixel threshold
    assert_snapshot(
        pydeck_charts.nth(4).locator("canvas").nth(1),
        name="st_pydeck_chart-no_overridden_theme",
        pixel_threshold=1.0,
    )

    # The pydeck tests are a lot flakier than need be so increase the pixel threshold
    assert_snapshot(
        pydeck_charts.nth(5).locator("canvas").nth(1),
        name="st_pydeck_chart-custom_width_height",
        pixel_threshold=1.0,
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    # The pydeck chart takes a while to load so check that
    # it gets attached with an increased timeout.
    pydeck_charts = app.get_by_test_id("stDeckGlJsonChart")
    expect(pydeck_charts.first).to_be_attached(timeout=15000)

    check_top_level_class(app, "stDeckGlJsonChart")


# Firefox seems to be failing but can't reproduce locally and video produces an empty page for firefox
@pytest.mark.skip_browser("firefox")
def test_st_pydeck_clicking_on_fullscreen_toolbar_button(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that clicking on fullscreen toolbar button expands the map into fullscreen."""

    # wait for mapbox to load
    wait_for_app_run(app, 15000)

    assert_fullscreen_toolbar_button_interactions(
        app,
        assert_snapshot=assert_snapshot,
        widget_test_id="stDeckGlJsonChart",
        filename_prefix="st_pydeck_chart",
        # The pydeck tests are a lot flakier than need be so increase the pixel threshold
        pixel_threshold=1.0,
    )


================================================
File: /e2e_playwright/st_pyplot.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import textwrap

import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns
from matplotlib import pyplot

import streamlit as st

np.random.seed(0)


st.write("Normal figure:")
data = np.random.normal(1, 1, size=100)
fig, ax = plt.subplots()
ax.hist(data, bins=20)
st.pyplot(fig)

st.write("Resized figure:")
# Resize plot. It is now 4 times smaller than the default value.
fig.set_size_inches(6.4 / 4, 4.8 / 4)
st.pyplot(fig)

st.write("Resized figure with `use_container_width=True`:")
st.pyplot(fig, use_container_width=True)

st.write("Resized figure with `use_container_width=False`:")
st.pyplot(fig, use_container_width=False)

st.write("Advanced Seaborn figure:")
# Generate data
data_points = 100
xData: "np.typing.NDArray[np.float64]" = (np.random.randn(data_points, 1) * 30) + 30
yData: "np.typing.NDArray[np.float64]" = np.random.randn(data_points, 1) * 30
data: "np.typing.NDArray[np.float64]" = np.random.randn(data_points, 2)

# Generate plot
fig, ax = plt.subplots(figsize=(4.5, 4.5))
sns.set_context(rc={"font.size": 10})
p = sns.regplot(x=xData, y=yData, data=data, ci=None, ax=ax, color="grey")

p.set_title("An Extremely and Really Really Long Long Long Title", fontweight="bold")
p.set_xlabel("Very long long x label")
p.set_ylabel("Very long long y label")

p.set_ylim(-30, 30)
plot_text = textwrap.dedent(
    """
    some_var_1 = 'Some label 1'
    some_var_2 = 'Some label 2'
"""
)

txt = ax.text(0.90, 0.10, plot_text, transform=ax.transAxes)
sns.despine()

st.pyplot(fig)

st.write("Advanced Seaborn figure using kwargs (low dpi):")

kwargs = {
    "dpi": 50,  # We use a low dpi to show a stark difference to the figure above.
    "bbox_extra_artists": (txt,),
    "bbox_inches": "tight",
    "format": "png",  # Required for some Matplotlib backends.
}

# We need to set clear_figure=True, otherwise the global object
# test below would not work.
st.pyplot(fig, clear_figure=True, **kwargs)

st.write("Figure using deprecated global object:")
plot = pyplot.plot(data)
st.pyplot()
pyplot.clf()

fig, ax = plt.subplots()
st.pyplot(fig)


================================================
File: /e2e_playwright/st_pyplot_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class, expect_warning


def test_displays_a_pyplot_figures(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that all pyplot figures are displayed correctly via screenshot matching."""

    # pyplot graph assertion
    expect(themed_app.get_by_test_id("stImage").last.locator("img")).to_have_attribute(
        "src", re.compile("localhost*")
    )

    pyplot_elements = themed_app.get_by_test_id("stImage").locator("img")
    expect(pyplot_elements).to_have_count(8)

    assert_snapshot(pyplot_elements.nth(0), name="st_pyplot-normal_figure")
    assert_snapshot(pyplot_elements.nth(1), name="st_pyplot-resized_figure")
    assert_snapshot(pyplot_elements.nth(2), name="st_pyplot-container_width_true")
    assert_snapshot(pyplot_elements.nth(3), name="st_pyplot-container_width_false")
    assert_snapshot(pyplot_elements.nth(4), name="st_pyplot-seaborn")
    assert_snapshot(pyplot_elements.nth(5), name="st_pyplot-seaborn_using_kwargs")

    # Snapshot testing the global object is flaky. But we anyways want to remove this,
    # functionality so we can just comment it out for now.
    # assert_snapshot(pyplot_elements.nth(6), name="st_pyplot-global_figure")


def test_shows_deprecation_warning(app: Page):
    """Test that the deprecation warning is displayed correctly."""
    expect_warning(app, "without providing a figure argument has been deprecated")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stImage")


================================================
File: /e2e_playwright/st_query_params.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.markdown(str(st.query_params))


================================================
File: /e2e_playwright/st_query_params_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import pytest
from playwright.sync_api import Page, expect

test_dicts = [{"x": "y"}, {"x": "y", "a": "b"}, {"x": ["y", "1", "2.34"]}, {"x": ""}]


@pytest.mark.parametrize("app_with_query_params", test_dicts, indirect=True)
def test_app_with_query_params(app_with_query_params: Page):
    page, test_dict = app_with_query_params
    expect(page.get_by_test_id("stMarkdownContainer")).to_have_text(str(test_dict))


================================================
File: /e2e_playwright/st_radio.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pandas as pd

import streamlit as st
from streamlit import runtime

options = ("female", "male")
markdown_options = (
    "**bold text**",
    "*italics text*",
    "~strikethrough text~",
    "shortcode: :blush:",
    # link should not work in radio options
    "[link text](www.example.com)",
    "`code text`",
    ":red[red] :blue[blue] :green[green] :violet[violet] :orange[orange]",
)

v1 = st.radio("radio 1 (default)", options)
st.write("value 1:", v1)

v2 = st.radio(
    "radio 2 (Formatted options)",
    options,
    1,
    format_func=lambda x: x.capitalize(),
)
st.write("value 2:", v2)

v3 = st.radio("radio 3 (no options)", [])
st.write("value 3:", v3)

v4 = st.radio("radio 4 (disabled)", options, disabled=True)
st.write("value 4:", v4)

v5 = st.radio("radio 5 (horizontal)", options, horizontal=True)
st.write("value 5:", v5)

v6 = st.radio("radio 6 (options from dataframe)", pd.DataFrame({"foo": list(options)}))
st.write("value 6:", v6)

v7 = st.radio("radio 7 (hidden label)", options, label_visibility="hidden")
st.write("value 7:", v7)

v8 = st.radio("radio 8 (collapsed label)", options, label_visibility="collapsed")
st.write("value 8:", v8)

v9 = st.radio("radio 9 (markdown options)", options=markdown_options)
st.write("value 9:", v9)

v10 = st.radio(
    "radio 10 (with captions)",
    ["A", "B", "C", "D", "E", "F", "G"],
    captions=markdown_options,
)
st.write("value 10:", v10)

v11 = st.radio(
    "radio 11 (horizontal, captions)",
    ["yes", "maybe", "no"],
    captions=["Opt in", "", "Opt out"],
    horizontal=True,
)
st.write("value 11:", v11)

if runtime.exists():

    def on_change():
        st.session_state.radio_changed = True
        st.text("Radio widget callback triggered")

    st.radio(
        "radio 12 (with callback, help)",
        options,
        1,
        key="radio12",
        on_change=on_change,
        help="help text",
    )
    st.write("value 12:", st.session_state.radio12)
    st.write("radio changed:", st.session_state.get("radio_changed") is True)
    # Reset to False:
    st.session_state.radio_changed = False

v13 = st.radio("radio 13 (empty selection)", options, index=None)
st.write("value 13:", v13)


================================================
File: /e2e_playwright/st_radio_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    expect_help_tooltip,
    get_element_by_key,
)


def test_radio_widget_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the radio widgets are correctly rendered via screenshot matching."""
    radio_widgets = themed_app.get_by_test_id("stRadio")
    expect(radio_widgets).to_have_count(13)

    assert_snapshot(radio_widgets.nth(0), name="st_radio-default")
    assert_snapshot(radio_widgets.nth(1), name="st_radio-formatted_options")
    assert_snapshot(radio_widgets.nth(2), name="st_radio-no_options")
    assert_snapshot(radio_widgets.nth(3), name="st_radio-disabled")
    assert_snapshot(radio_widgets.nth(4), name="st_radio-horizontal")
    assert_snapshot(radio_widgets.nth(5), name="st_radio-dataframe_options")
    assert_snapshot(radio_widgets.nth(6), name="st_radio-hidden_label")
    assert_snapshot(radio_widgets.nth(7), name="st_radio-collapsed_label")
    assert_snapshot(radio_widgets.nth(8), name="st_radio-markdown_options")
    assert_snapshot(radio_widgets.nth(9), name="st_radio-captions")
    assert_snapshot(radio_widgets.nth(10), name="st_radio-horizontal_captions")
    assert_snapshot(radio_widgets.nth(11), name="st_radio-callback_help")
    assert_snapshot(radio_widgets.nth(12), name="st_radio-empty_selection")


def test_help_tooltip_works(app: Page):
    element_with_help = app.get_by_test_id("stRadio").nth(11)
    expect_help_tooltip(app, element_with_help, "help text")


def test_radio_has_correct_default_values(app: Page):
    """Test that st.radio returns the correct initial values."""
    markdown_elements = app.get_by_test_id("stMarkdown")
    expect(markdown_elements).to_have_count(14)

    expected = [
        "value 1: female",
        "value 2: male",
        "value 3: None",
        "value 4: female",
        "value 5: female",
        "value 6: female",
        "value 7: female",
        "value 8: female",
        "value 9: bold text",
        "value 10: A",
        "value 11: yes",
        "value 12: male",
        "radio changed: False",
        "value 13: None",
    ]

    for markdown_element, expected_text in zip(markdown_elements.all(), expected):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_set_value_correctly_when_click(app: Page):
    """Test that st.radio returns the correct values when the selection is changed."""
    for index, element in enumerate(app.get_by_test_id("stRadio").all()):
        if index not in [2, 3]:  # skip disabled and no-options widget
            element.locator('label[data-baseweb="radio"]').nth(1).click(force=True)
            wait_for_app_run(app)

    expected = [
        "value 1: male",
        "value 2: male",
        "value 3: None",
        "value 4: female",
        "value 5: male",
        "value 6: male",
        "value 7: male",
        "value 8: male",
        "value 9: italics text",
        "value 10: B",
        "value 11: maybe",
        "value 12: male",
        "radio changed: False",
        "value 13: male",
    ]

    for markdown_element, expected_text in zip(
        app.get_by_test_id("stMarkdown").all(), expected
    ):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_calls_callback_on_change(app: Page):
    """Test that it correctly calls the callback on change."""
    radio_widget = app.get_by_test_id("stRadio").nth(11)

    radio_widget.locator('label[data-baseweb="radio"]').first.click(force=True)
    wait_for_app_run(app)

    expect(app.get_by_test_id("stMarkdown").nth(11)).to_have_text(
        "value 12: female",
        use_inner_text=True,
    )
    expect(app.get_by_test_id("stMarkdown").nth(12)).to_have_text(
        "radio changed: True",
        use_inner_text=True,
    )

    # Change different date input to trigger delta path change
    first_date_input_field = app.get_by_test_id("stRadio").first
    first_date_input_field.locator('label[data-baseweb="radio"]').last.click(force=True)
    wait_for_app_run(app)

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "value 1: male", use_inner_text=True
    )

    # Test if value is still correct after delta path change
    expect(app.get_by_test_id("stMarkdown").nth(11)).to_have_text(
        "value 12: female",
        use_inner_text=True,
    )
    expect(app.get_by_test_id("stMarkdown").nth(12)).to_have_text(
        "radio changed: False",
        use_inner_text=True,
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stRadio")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "radio12")).to_be_visible()


================================================
File: /e2e_playwright/st_rerun.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time

import streamlit as st

if "count" not in st.session_state:
    st.session_state.count = 0
    st.session_state.fragment_count = 0


@st.fragment
def my_fragment():
    if st.button("rerun whole app (from fragment)"):
        st.rerun(scope="app")

    if st.button("rerun fragment"):
        st.session_state.fragment_count += 1
        st.rerun(scope="fragment")

    st.write(f"fragment run count: {st.session_state.fragment_count}")

    if st.session_state.fragment_count % 5 != 0:
        st.session_state.fragment_count += 1
        st.rerun(scope="fragment")


@st.fragment
def fragment_with_rerun_in_try_block():
    try:
        if st.button("rerun try_fragment"):
            st.rerun()
    except Exception as e:
        st.write(f"Caught exception: {e}")


st.session_state.count += 1

if st.session_state.count < 4:
    st.rerun()

if st.session_state.count >= 4:
    st.text("Being able to rerun a session is awesome!")


s = st.selectbox(
    "i should retain my state",
    ["a", "b", "c"],
    index=None,
)
st.write(f"selectbox selection: {s}")

my_fragment()
fragment_with_rerun_in_try_block()

# have elements in the main app after fragments to ensure that the main app elements are
#  not cleared when rerunning fragments
st.write(f"app run count: {st.session_state.count}")

if "foo" not in st.session_state:
    st.write("Setting state")
    st.session_state["foo"] = "bar"

if st.button("#8599 - Bug"):
    # Allow for forward message queue to flush button element
    time.sleep(1)

    del st.session_state["foo"]
    st.rerun()


================================================
File: /e2e_playwright/st_rerun_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import wait_for_app_run
from e2e_playwright.shared.app_utils import click_button, expect_markdown


def _expect_initial_reruns_finished(app: Page):
    expect(app.get_by_test_id("stText")).to_have_text(
        "Being able to rerun a session is awesome!"
    )


def _expect_initial_reruns_count_text(app: Page):
    expect_markdown(app, "app run count: 4")


def test_st_rerun_restarts_the_session_when_invoked(app: Page):
    _expect_initial_reruns_finished(app)


def test_fragment_scoped_st_rerun(app: Page):
    expect(app.get_by_test_id("stText")).to_have_text(
        "Being able to rerun a session is awesome!"
    )

    # perform multiple clicks to make sure that the fragment rerun works as expected
    # and the main app content is still rendered
    for i in range(1, 10):
        click_button(app, "rerun fragment")
        expect(app.get_by_test_id("stMarkdown").nth(1)).to_have_text(
            f"fragment run count: {i * 5}"
        )
        _expect_initial_reruns_count_text(app)

    # the main apps rerun count should not have been incremented
    _expect_initial_reruns_count_text(app)


def test_rerun_works_in_try_except_block(app: Page):
    _expect_initial_reruns_finished(app)
    _expect_initial_reruns_count_text(app)

    click_button(app, "rerun try_fragment")
    # the rerun in the try-block worked as expected, so the session_state count
    # incremented
    expect_markdown(app, "app run count: 5")


def test_state_retained_on_app_scoped_rerun(app: Page):
    # Sanity check 1
    expect_markdown(app, "selectbox selection: None")

    # Click on the selectbox and select the first option.
    app.get_by_test_id("stSelectbox").first.locator("input").click()
    selection_dropdown = app.locator('[data-baseweb="popover"]').first
    selection_dropdown.locator("li").first.click()
    wait_for_app_run(app)

    # Sanity check 2
    expect_markdown(app, "selectbox selection: a")

    # Rerun the fragment and verify that the selectbox kept its state
    click_button(app, "rerun whole app (from fragment)")
    expect_markdown(app, "selectbox selection: a")


# From GitHub issue #8599
def test_clears_stale_elements_correctly(app: Page):
    click_button(app, "#8599 - Bug")

    expect(app.get_by_text("#8599 - Bug")).to_have_count(1)


================================================
File: /e2e_playwright/st_scatter_chart.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from datetime import date

import numpy as np
import pandas as pd

import streamlit as st

np.random.seed(0)


data = np.random.randn(20, 3)
df = pd.DataFrame(data, columns=["a", "b", "c"])

# st.area/bar/line_chart all use Altair/Vega-Lite under the hood.
# By default, Vega-Lite displays time values in the browser's local
# time zone, but data is sent down to the browser as UTC. This means
# Times need to be set correctly to the users timezone.
utc_df = pd.DataFrame(
    {
        "index": [
            date(2019, 8, 9),
            date(2019, 8, 10),
            date(2019, 8, 11),
            date(2019, 8, 12),
        ],
        "numbers": [10, 50, 30, 40],
    }
)

utc_df.set_index("index", inplace=True)

# Dataframe to test the color parameter support:
N = 100

color_df = pd.DataFrame(
    {
        # Using a negative range so certain kinds of bugs are more visible.
        "a": -np.arange(N),
        "b": np.random.rand(N) * 10,
        "c": np.random.rand(N) * 10,
        "d": np.random.randn(N) * 30,
        "e": ["bird" if x % 2 else "airplane" for x in range(N)],
    }
)

st.header("Scatter Chart")

st.scatter_chart()
st.scatter_chart(df)
st.scatter_chart(df, x="a")
st.scatter_chart(df, y="a")
st.scatter_chart(df, y=["a", "b"])
st.scatter_chart(df, x="a", y="b", height=500, width=300, use_container_width=False)
st.scatter_chart(df, x="b", y="a")
st.scatter_chart(df, x="a", y=["b", "c"])
st.scatter_chart(utc_df)
st.scatter_chart(color_df, x="a", y="b", color="e")
# Additional tests for size parameter (only for scatter_chart)
st.scatter_chart(color_df, x="a", y="b", size="d", color="e")
st.scatter_chart(color_df, x="a", y="b", size="d", color="c")
st.scatter_chart(df, x_label="X Axis Label", y_label="Y Axis Label")


================================================
File: /e2e_playwright/st_scatter_chart_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class

TOTAL_SCATTER_CHARTS = 13


def test_scatter_chart_rendering(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.scatter_chart renders correctly via snapshot testing."""
    scatter_chart_elements = app.get_by_test_id("stVegaLiteChart")
    expect(scatter_chart_elements).to_have_count(TOTAL_SCATTER_CHARTS)

    # Also make sure that all canvas objects are rendered:
    expect(scatter_chart_elements.locator("canvas")).to_have_count(TOTAL_SCATTER_CHARTS)

    for i, element in enumerate(scatter_chart_elements.all()):
        assert_snapshot(element, name=f"st_scatter_chart-{i}")


def test_themed_scatter_chart_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.scatter_chart renders with different theming."""
    scatter_chart_elements = themed_app.get_by_test_id("stVegaLiteChart")
    expect(scatter_chart_elements).to_have_count(TOTAL_SCATTER_CHARTS)

    # Also make sure that all canvas objects are rendered:
    expect(scatter_chart_elements.locator("canvas")).to_have_count(TOTAL_SCATTER_CHARTS)

    # Only test a single chart per built-in chart type:
    assert_snapshot(scatter_chart_elements.nth(1), name="st_scatter_chart_themed")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stVegaLiteChart")


================================================
File: /e2e_playwright/st_secrets.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from pathlib import Path
from typing import Final

import streamlit as st
from streamlit import config, runtime

if runtime.exists():
    original_option = st.get_option("secrets.files")
    st.write("Secret: ", st.secrets["fake"]["FAKE_SECRET"])

    # We are hacking here, but we are setting the secrets file to a different file to determine if it works
    TEST_ASSETS_DIR: Final[Path] = Path(__file__).parent / "test_assets"
    ALT_SECRETS_FILE = TEST_ASSETS_DIR / "alt_secrets.toml"
    ALT_SECRETS_FILE2 = TEST_ASSETS_DIR / "alt_secrets2.toml"
    config.set_option("secrets.files", [str(ALT_SECRETS_FILE)])
    st.secrets._secrets = None

    st.write("Alt Secret: ", st.secrets["fake"]["FAKE_SECRET"])
    st.write("Alt Secret From File 2 visible: ", "other-fake" in st.secrets)

    config.set_option("secrets.files", [str(ALT_SECRETS_FILE), str(ALT_SECRETS_FILE2)])
    st.secrets._secrets = None

    st.write("Alt Secret (Multiple): ", st.secrets["fake"]["FAKE_SECRET"])
    st.write(
        "Alt Secret From File 2 (Multiple): ",
        st.secrets["other-fake"]["OTHER_FAKE_SECRET"],
    )

    # Reset the secrets file to the original to avoid affecting other tests
    config.set_option("secrets.files", original_option)
    st.secrets._secrets = None


================================================
File: /e2e_playwright/st_secrets_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect


def test_default_secrets_specified(app: Page):
    """Test that secrets can be accessed from the default secrets file."""

    expect(app.get_by_text("Secret: value")).to_be_attached()


def test_alternative_secrets_specified(app: Page):
    """Test that secrets can be accessed from a specific secrets file."""

    expect(app.get_by_text("Alt Secret: alt-value")).to_be_attached()
    expect(app.get_by_text("Alt Secret From File 2 visible: False")).to_be_attached()


def test_multiple_alternative_secrets_specified(app: Page):
    """Test that secrets can be accessed from multiple secrets file."""

    expect(app.get_by_text("Alt Secret (Multiple): alt-value")).to_be_attached()
    expect(
        app.get_by_text("Alt Secret From File 2 (Multiple): other-alt-value")
    ).to_be_attached()


================================================
File: /e2e_playwright/st_segmented_control.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import time

import streamlit as st

with st.sidebar:
    st.markdown(
        """
        - [Multi Select - Segmented Control](#multi-select-segmented-control)
        - [Single Select - Segmented Control](#single-select-segmented-control)
        - [Icon-only button group - Segmented Control](#icon-only-button-group-segmented-control)
        - [on_change callback - Segmented Control](#on-change-callback-segmented-control)
        - [Disabled - Segmented Control](#disabled-segmented-control)
        - [Segmented Control in form](#segmented-control-in-form)
        - [Segmented Control in fragment](#segmented-control-in-fragment)
        - [Unmounted - Segmented Control](#unmounted-segmented-control)
        """
    )

st.header("Multi Select - Segmented Control", anchor="multi-select-segmented-control")
if st.checkbox("Set default values", value=False):
    st.session_state.default_segmented_control_options = [
        "Foobar",
        "🧰 General widgets",
    ]
else:
    st.session_state.default_segmented_control_options = []

default = st.session_state.default_segmented_control_options

selection = st.segmented_control(
    "Select some options",
    [
        ":material/star: Hello there!",
        "Foobar",
        "Icon in the end: :material/rocket:",
        ":material/thumb_up: Hello again!",
