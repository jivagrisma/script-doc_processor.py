export const STREAMLIT_COMMUNITY_CLOUD_DOCS_URL =
  "https://docs.streamlit.io/deploy/streamlit-community-cloud/get-started"
export const STREAMLIT_DEPLOY_TUTORIAL_URL =
  "https://docs.streamlit.io/deploy/tutorials"

export const ENABLE_PERIPHERALS_DOCS_URL =
  "https://docs.streamlit.io/end-users/enable-peripherals"


================================================
File: /frontend/lib/src/components/core/IsDialogContext.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Context to indicate to child elements that they are rendered within a dialog.
 */

import React from "react"

export default React.createContext(false)


================================================
File: /frontend/lib/src/components/core/IsSidebarContext.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

export default React.createContext(false)


================================================
File: /frontend/lib/src/components/core/LibContext.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { baseTheme, ThemeConfig } from "@streamlit/lib/src/theme"

/**
 * The lib config contains various configurations that the host platform can
 * use to configure streamlit-lib frontend behavior. This should to be treated as part of the public
 * API, and changes need to be backwards-compatible meaning that an old host configuration
 * should still work with a new frontend versions.
 */
export type LibConfig = {
  /**
   * the mapbox token that can be configured by a platform
   */
  mapboxToken?: string

  /**
   * Whether to disable the full screen mode all elements / widgets.
   */
  disableFullscreenMode?: boolean

  enforceDownloadInNewTab?: boolean
}

export interface LibContextProps {
  /** True if the app is in full-screen mode. */
  isFullScreen: boolean

  /** Function that sets the `isFullScreen` property. */
  setFullScreen: (value: boolean) => void

  /**
   * Add a callback that will be called every time the app's script finishes
   * executing.
   */
  addScriptFinishedHandler: (func: () => void) => void

  /** Remove a previously-added scriptFinishedHandler callback. */
  removeScriptFinishedHandler: (func: () => void) => void

  /** The currently active app theme. */
  activeTheme: ThemeConfig

  /**
   * Set the app's active theme locally and send it the app's host (if any).
   * @see App.setAndSendTheme
   */
  setTheme: (theme: ThemeConfig) => void

  /** List of all available themes. */
  availableThemes: ThemeConfig[]

  /**
   * Call to add additional themes to the app.
   * @see ThemeCreatorDialog
   */
  addThemes: (themes: ThemeConfig[]) => void

  /**
   * Change the page in a multi-page app.
   * @see PageLink
   */
  onPageChange: (pageScriptHash: string) => void

  /**
   * The current page of a multi-page app.
   * @see PageLink
   */
  currentPageScriptHash: string

  /**
   * The lib-specific configuration from the apps host which is requested via the
   * _stcore/host-config endpoint.
   */
  libConfig: LibConfig

  /**
   * The IDs of the fragments that the current script run corresponds to. If the
   * current script run isn't due to a fragment, this field is falsy.
   */
  fragmentIdsThisRun: Array<string>

  /**
   * The current locale of the app. Defaults to the browser's locale.
   * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/language
   */
  locale: typeof window.navigator.language
}

export const LibContext = React.createContext<LibContextProps>({
  isFullScreen: false,
  setFullScreen: () => {},
  addScriptFinishedHandler: () => {},
  removeScriptFinishedHandler: () => {},
  activeTheme: baseTheme,
  setTheme: () => {},
  availableThemes: [],
  addThemes: () => {},
  onPageChange: () => {},
  currentPageScriptHash: "",
  libConfig: {},
  fragmentIdsThisRun: [],
  locale: window.navigator.language,
})


================================================
File: /frontend/lib/src/components/core/ThemeProvider.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, ReactNode } from "react"

import { ThemeProvider as BaseUIThemeProvider } from "baseui"
import { ThemeProvider as EmotionThemeProvider } from "@emotion/react"

import {
  BaseUILightTheme,
  baseuiLightTheme,
  EmotionTheme,
} from "@streamlit/lib/src/theme"

export interface ThemeProviderProps {
  theme: EmotionTheme
  baseuiTheme?: BaseUILightTheme
  children: ReactNode
}

function ThemeProvider({
  theme,
  baseuiTheme,
  children,
}: ThemeProviderProps): ReactElement {
  return (
    // Type error coming from BaseUI "property children doesn't exist"
    // @ts-expect-error
    <BaseUIThemeProvider theme={baseuiTheme || baseuiLightTheme}>
      <EmotionThemeProvider theme={theme}>{children}</EmotionThemeProvider>
    </BaseUIThemeProvider>
  )
}

export default ThemeProvider


================================================
File: /frontend/lib/src/components/core/Block/Block.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { screen } from "@testing-library/react"

import { Block as BlockProto } from "@streamlit/lib/src/proto"
import { render } from "@streamlit/lib/src/test_util"
import { BlockNode } from "@streamlit/lib/src/AppNode"
import { ScriptRunState } from "@streamlit/lib/src/ScriptRunState"

import VerticalBlock from "./Block"

const FAKE_SCRIPT_HASH = "fake_script_hash"
class ResizeObserver {
  observe(): void {}

  unobserve(): void {}

  disconnect(): void {}
}

function makeColumn(weight: number, children: BlockNode[] = []): BlockNode {
  return new BlockNode(
    FAKE_SCRIPT_HASH,
    children,
    new BlockProto({ allowEmpty: true, column: { weight } })
  )
}

function makeHorizontalBlock(numColumns: number): BlockNode {
  const weight = 1 / numColumns

  return new BlockNode(
    FAKE_SCRIPT_HASH,
    Array.from({ length: numColumns }, () => makeColumn(weight)),
    new BlockProto({ allowEmpty: true, horizontal: { gap: "small" } })
  )
}

function makeVerticalBlock(
  children: BlockNode[] = [],
  additionalProps: Partial<BlockProto> = {}
): BlockNode {
  return new BlockNode(
    FAKE_SCRIPT_HASH,
    children,
    new BlockProto({ allowEmpty: true, ...additionalProps })
  )
}

function makeVerticalBlockComponent(node: BlockNode): ReactElement {
  return (
    <VerticalBlock
      node={node}
      scriptRunId={""}
      scriptRunState={ScriptRunState.NOT_RUNNING}
      widgetsDisabled={false}
      // @ts-expect-error
      widgetMgr={undefined}
      // @ts-expect-error
      uploadClient={undefined}
      // @ts-expect-error
      componentRegistry={undefined}
      // @ts-expect-error
      formsData={undefined}
    />
  )
}

describe("Vertical Block Component", () => {
  window.ResizeObserver = ResizeObserver
  it("should render a horizontal block with empty columns", () => {
    const block: BlockNode = makeVerticalBlock([makeHorizontalBlock(4)])
    render(makeVerticalBlockComponent(block))

    expect(screen.getAllByTestId("stColumn")).toHaveLength(4)
    expect(
      screen.getAllByTestId("stVerticalBlockBorderWrapper")[0]
    ).not.toHaveStyle("overflow: auto")
  })

  it("should add the user-specified key as class", () => {
    const block: BlockNode = makeVerticalBlock([], {
      id: "$$ID-899e9b72e1539f21f8e82565d36609d0-first container",
    })
    render(makeVerticalBlockComponent(block))

    expect(screen.getByTestId("stVerticalBlock")).toBeVisible()
    expect(screen.getByTestId("stVerticalBlock")).toHaveClass(
      "st-key-first-container"
    )
  })

  it("should activate scrolling when height is set", () => {
    const block: BlockNode = makeVerticalBlock([makeHorizontalBlock(4)], {
      vertical: { height: 100 },
    })

    render(makeVerticalBlockComponent(block))

    expect(
      screen.getAllByTestId("stVerticalBlockBorderWrapper")[0]
    ).toHaveStyle("overflow: auto")
  })

  it("should show border when border is True", () => {
    const block: BlockNode = makeVerticalBlock([makeHorizontalBlock(4)], {
      vertical: { border: true },
    })

    render(makeVerticalBlockComponent(block))

    expect(
      screen.getAllByTestId("stVerticalBlockBorderWrapper")[0]
    ).toHaveStyle("border: 1px solid rgba(49, 51, 63, 0.2);")
  })
})


================================================
File: /frontend/lib/src/components/core/Block/Block.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  ReactElement,
  ReactNode,
  useContext,
  useEffect,
  useMemo,
  useRef,
} from "react"

import classNames from "classnames"
import { useTheme } from "@emotion/react"

import { LibContext } from "@streamlit/lib/src/components/core/LibContext"
import { Block as BlockProto } from "@streamlit/lib/src/proto"
import { AppNode, BlockNode, ElementNode } from "@streamlit/lib/src/AppNode"
import {
  getElementId,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"
import { Form } from "@streamlit/lib/src/components/widgets/Form"
import Tabs, { TabProps } from "@streamlit/lib/src/components/elements/Tabs"
import Popover from "@streamlit/lib/src/components/elements/Popover"
import ChatMessage from "@streamlit/lib/src/components/elements/ChatMessage"
import Dialog from "@streamlit/lib/src/components/elements/Dialog"
import Expander from "@streamlit/lib/src/components/elements/Expander"
import { useScrollToBottom } from "@streamlit/lib/src/hooks/useScrollToBottom"

import {
  assignDividerColor,
  BaseBlockProps,
  convertKeyToClassName,
  getKeyFromId,
  isComponentStale,
  shouldComponentBeEnabled,
} from "./utils"
import ElementNodeRenderer from "./ElementNodeRenderer"
import {
  StyledColumn,
  StyledHorizontalBlock,
  StyledVerticalBlock,
  StyledVerticalBlockBorderWrapper,
  StyledVerticalBlockBorderWrapperProps,
  StyledVerticalBlockWrapper,
} from "./styled-components"

export interface BlockPropsWithoutWidth extends BaseBlockProps {
  node: BlockNode
}

interface BlockPropsWithWidth extends BaseBlockProps {
  node: BlockNode
  width: number
}

// Render BlockNodes (i.e. container nodes).
const BlockNodeRenderer = (props: BlockPropsWithWidth): ReactElement => {
  const { node } = props
  const { fragmentIdsThisRun } = useContext(LibContext)

  if (node.isEmpty && !node.deltaBlock.allowEmpty) {
    return <></>
  }

  const enable = shouldComponentBeEnabled("", props.scriptRunState)
  const isStale = isComponentStale(
    enable,
    node,
    props.scriptRunState,
    props.scriptRunId,
    fragmentIdsThisRun
  )

  const childProps = { ...props, ...{ node } }

  const disableFullscreenMode =
    props.disableFullscreenMode ||
    notNullOrUndefined(node.deltaBlock.dialog) ||
    notNullOrUndefined(node.deltaBlock.popover)

  const child: ReactElement = (
    <LayoutBlock
      {...childProps}
      disableFullscreenMode={disableFullscreenMode}
    />
  )

  if (node.deltaBlock.dialog) {
    return (
      <Dialog
        element={node.deltaBlock.dialog as BlockProto.Dialog}
        deltaMsgReceivedAt={node.deltaMsgReceivedAt}
      >
        {child}
      </Dialog>
    )
  }

  if (node.deltaBlock.expandable) {
    return (
      <Expander
        empty={node.isEmpty}
        isStale={isStale}
        element={node.deltaBlock.expandable as BlockProto.Expandable}
      >
        {child}
      </Expander>
    )
  }

  if (node.deltaBlock.popover) {
    return (
      <Popover
        empty={node.isEmpty}
        element={node.deltaBlock.popover as BlockProto.Popover}
        width={props.width}
      >
        {child}
      </Popover>
    )
  }

  if (node.deltaBlock.type === "form") {
    const { formId, clearOnSubmit, enterToSubmit, border } = node.deltaBlock
      .form as BlockProto.Form
    const submitButtons = props.formsData.submitButtons.get(formId)
    const hasSubmitButton =
      submitButtons !== undefined && submitButtons.length > 0
    return (
      <Form
        formId={formId}
        clearOnSubmit={clearOnSubmit}
        enterToSubmit={enterToSubmit}
        width={props.width}
        hasSubmitButton={hasSubmitButton}
        scriptRunState={props.scriptRunState}
        widgetMgr={props.widgetMgr}
        border={border}
      >
        {child}
      </Form>
    )
  }

  if (node.deltaBlock.chatMessage) {
    return (
      <ChatMessage
        element={node.deltaBlock.chatMessage as BlockProto.ChatMessage}
        endpoints={props.endpoints}
      >
        {child}
      </ChatMessage>
    )
  }

  if (node.deltaBlock.column) {
    return (
      <StyledColumn
        weight={node.deltaBlock.column.weight ?? 0}
        gap={node.deltaBlock.column.gap ?? ""}
        verticalAlignment={
          node.deltaBlock.column.verticalAlignment ?? undefined
        }
        showBorder={node.deltaBlock.column.showBorder ?? false}
        className="stColumn"
        data-testid="stColumn"
      >
        {child}
      </StyledColumn>
    )
  }

  if (node.deltaBlock.tabContainer) {
    const renderTabContent = (
      mappedChildProps: JSX.IntrinsicAttributes & BlockPropsWithoutWidth
    ): ReactElement => {
      // avoid circular dependency where Tab uses VerticalBlock but VerticalBlock uses tabs
      // eslint-disable-next-line @typescript-eslint/no-use-before-define
      return <VerticalBlock {...mappedChildProps}></VerticalBlock>
    }
    const tabsProps: TabProps = { ...childProps, isStale, renderTabContent }
    return <Tabs {...tabsProps} />
  }

  return child
}

const ChildRenderer = (props: BlockPropsWithWidth): ReactElement => {
  const { libConfig } = useContext(LibContext)

  // Handle cycling of colors for dividers:
  assignDividerColor(props.node, useTheme())

  // Capture all the element ids to avoid rendering the same element twice
  const elementKeySet = new Set<string>()

  return (
    <>
      {props.node.children &&
        props.node.children.map((node: AppNode, index: number): ReactNode => {
          const disableFullscreenMode =
            libConfig.disableFullscreenMode || props.disableFullscreenMode

          // Base case: render a leaf node.
          if (node instanceof ElementNode) {
            // Put node in childProps instead of passing as a node={node} prop in React to
            // guarantee it doesn't get overwritten by {...childProps}.
            const childProps = {
              ...props,
              disableFullscreenMode,
              node: node as ElementNode,
            }

            const key = getElementId(node.element) || index.toString()
            // Avoid rendering the same element twice. We assume the first one is the one we want
            // because the page is rendered top to bottom, so a valid widget would be rendered
            // correctly and we assume the second one is therefore stale (or throw an error).
            // Also, our setIn logic pushes stale widgets down in the list of elements, so the
            // most recent one should always come first.
            if (elementKeySet.has(key)) {
              return null
            }

            elementKeySet.add(key)

            return <ElementNodeRenderer key={key} {...childProps} />
          }

          // Recursive case: render a block, which can contain other blocks
          // and elements.
          if (node instanceof BlockNode) {
            // Put node in childProps instead of passing as a node={node} prop in React to
            // guarantee it doesn't get overwritten by {...childProps}.
            const childProps = {
              ...props,
              disableFullscreenMode,
              node: node as BlockNode,
            }

            return <BlockNodeRenderer key={index} {...childProps} />
          }

          // We don't have any other node types!
          throw new Error(`Unrecognized AppNode: ${node}`)
        })}
    </>
  )
}

export interface ScrollToBottomVerticalBlockWrapperProps
  extends StyledVerticalBlockBorderWrapperProps {
  children: ReactNode
}

// A wrapper for Vertical Block that adds scrolling with pinned to bottom behavior.
function ScrollToBottomVerticalBlockWrapper(
  props: ScrollToBottomVerticalBlockWrapperProps
): ReactElement {
  const { border, height, children } = props
  const scrollContainerRef = useScrollToBottom()

  return (
    <StyledVerticalBlockBorderWrapper
      border={border}
      height={height}
      data-testid="stVerticalBlockBorderWrapper"
      data-test-scroll-behavior="scroll-to-bottom"
      ref={scrollContainerRef as React.RefObject<HTMLDivElement>}
    >
      {children}
    </StyledVerticalBlockBorderWrapper>
  )
}

// Currently, only VerticalBlocks will ever contain leaf elements. But this is only enforced on the
// Python side.
const VerticalBlock = (props: BlockPropsWithoutWidth): ReactElement => {
  const wrapperElement = useRef<HTMLDivElement>(null)
  const [width, setWidth] = React.useState(-1)

  const observer = useMemo(
    () =>
      new ResizeObserver(([entry]) => {
        // Since the setWidth will perform changes to the DOM,
        // we need wrap it in a requestAnimationFrame to avoid this error:
        // ResizeObserver loop completed with undelivered notifications.
        window.requestAnimationFrame(() => {
          // We need to determine the available width here to be able to set
          // an explicit width for the `StyledVerticalBlock`.

          // The width should never be set to 0 since it can cause
          // flickering effects.
          setWidth(entry.target.getBoundingClientRect().width || -1)
        })
      }),
    [setWidth]
  )

  const border = props.node.deltaBlock.vertical?.border ?? false
  const height = props.node.deltaBlock.vertical?.height || undefined

  const activateScrollToBottom =
    height &&
    props.node.children.find(node => {
      return (
        node instanceof BlockNode && node.deltaBlock.type === "chatMessage"
      )
    }) !== undefined

  useEffect(() => {
    if (wrapperElement.current) {
      observer.observe(wrapperElement.current)
    }
    return () => {
      observer.disconnect()
    }
    // We need to update the observer whenever the scrolling is activated or deactivated
    // Otherwise, it still tries to measure the width of the old wrapper element.
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    /* eslint-disable react-hooks/exhaustive-deps */
  }, [observer, activateScrollToBottom])

  // Decide which wrapper to use based on whether we need to activate scrolling to bottom
  // This is done for performance reasons, to prevent the usage of useScrollToBottom
  // if it is not needed.
  const VerticalBlockBorderWrapper = activateScrollToBottom
    ? ScrollToBottomVerticalBlockWrapper
    : StyledVerticalBlockBorderWrapper

  const propsWithNewWidth = {
    ...props,
    ...{ width },
  }
  // Extract the user-specified key from the block ID (if provided):
  const userKey = getKeyFromId(props.node.deltaBlock.id)

  // Widths of children autosizes to container width (and therefore window width).
  // StyledVerticalBlocks are the only things that calculate their own widths. They should never use
  // the width value coming from the parent via props.

  // To apply a border, we need to wrap the StyledVerticalBlockWrapper again, otherwise the width
  // calculation would not take the padding into consideration.
  return (
    <VerticalBlockBorderWrapper
      border={border}
      height={height}
      data-testid="stVerticalBlockBorderWrapper"
      data-test-scroll-behavior="normal"
    >
      <StyledVerticalBlockWrapper ref={wrapperElement}>
        <StyledVerticalBlock
          width={width}
          className={classNames(
            "stVerticalBlock",
            convertKeyToClassName(userKey)
          )}
          data-testid="stVerticalBlock"
        >
          <ChildRenderer {...propsWithNewWidth} />
        </StyledVerticalBlock>
      </StyledVerticalBlockWrapper>
    </VerticalBlockBorderWrapper>
  )
}

const HorizontalBlock = (props: BlockPropsWithWidth): ReactElement => {
  // Create a horizontal block as the parent for columns.
  // The children are always columns, but this is not checked. We just trust the Python side to
  // do the right thing, then we ask ChildRenderer to handle it.
  const gap = props.node.deltaBlock.horizontal?.gap ?? ""

  return (
    <StyledHorizontalBlock
      gap={gap}
      className="stHorizontalBlock"
      data-testid="stHorizontalBlock"
    >
      <ChildRenderer {...props} />
    </StyledHorizontalBlock>
  )
}

// A container block with one of two types of layouts: vertical and horizontal.
function LayoutBlock(props: BlockPropsWithWidth): ReactElement {
  if (props.node.deltaBlock.horizontal) {
    return <HorizontalBlock {...props} />
  }

  return <VerticalBlock {...props} />
}

export default VerticalBlock


================================================
File: /frontend/lib/src/components/core/Block/ElementNodeRenderer.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen, waitFor } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import {
  Balloons as BalloonsProto,
  ForwardMsgMetadata,
  Snow as SnowProto,
} from "@streamlit/lib/src/proto"
import { ElementNode } from "@streamlit/lib/src/AppNode"
import { ScriptRunState } from "@streamlit/lib/src/ScriptRunState"
import {
  createFormsData,
  WidgetStateManager,
} from "@streamlit/lib/src/WidgetStateManager"
import { FileUploadClient } from "@streamlit/lib/src/FileUploadClient"
import { ComponentRegistry } from "@streamlit/lib/src/components/widgets/CustomComponent"
import { mockEndpoints, mockSessionInfo } from "@streamlit/lib/src/mocks/mocks"

import ElementNodeRenderer, {
  ElementNodeRendererProps,
} from "./ElementNodeRenderer"

const FAKE_SCRIPT_HASH = "fake_script_hash"

function createBalloonNode(scriptRunId: string): ElementNode {
  const node = new ElementNode(
    new BalloonsProto({
      show: true,
    }),
    ForwardMsgMetadata.create({}),
    scriptRunId,
    FAKE_SCRIPT_HASH
  )
  node.element.type = "balloons"
  return node
}

function createSnowNode(scriptRunId: string): ElementNode {
  const node = new ElementNode(
    new SnowProto({
      show: true,
    }),
    ForwardMsgMetadata.create({}),
    scriptRunId,
    FAKE_SCRIPT_HASH
  )
  node.element.type = "snow"
  return node
}

function getProps(
  props: Partial<ElementNodeRendererProps> &
    Pick<ElementNodeRendererProps, "node" | "scriptRunId">
): ElementNodeRendererProps {
  const sessionInfo = mockSessionInfo()
  const endpoints = mockEndpoints()
  return {
    endpoints: endpoints,
    scriptRunState: ScriptRunState.RUNNING,
    widgetMgr: new WidgetStateManager({
      sendRerunBackMsg: vi.fn(),
      formsDataChanged: vi.fn(),
    }),
    widgetsDisabled: false,
    uploadClient: new FileUploadClient({
      sessionInfo: sessionInfo,
      endpoints,
      formsWithPendingRequestsChanged: () => {},
      requestFileURLs: vi.fn(),
    }),
    componentRegistry: new ComponentRegistry(endpoints),
    formsData: createFormsData(),
    width: 1000,
    ...props,
  }
}

describe("ElementNodeRenderer Block Component", () => {
  describe("render Balloons", () => {
    it("should NOT render a stale component", async () => {
      const scriptRunId = "SCRIPT_RUN_ID"
      const props = getProps({
        node: createBalloonNode(scriptRunId),
        scriptRunId: "NEW_SCRIPT_ID",
      })
      render(<ElementNodeRenderer {...props} />)

      await waitFor(() =>
        expect(screen.queryByTestId("stSkeleton")).toBeNull()
      )
      const elementNodeRenderer = screen.getByTestId("stElementContainer")
      expect(elementNodeRenderer).toBeInTheDocument()
      expect(elementNodeRenderer).toHaveClass("stElementContainer")
      // eslint-disable-next-line testing-library/no-node-access
      expect(elementNodeRenderer.children).toHaveLength(0)
    })

    it("should render a fresh component", async () => {
      const scriptRunId = "SCRIPT_RUN_ID"
      const props = getProps({
        node: createBalloonNode(scriptRunId),
        scriptRunId,
      })
      render(<ElementNodeRenderer {...props} />)

      await waitFor(() =>
        expect(screen.queryByTestId("stSkeleton")).toBeNull()
      )
      const elementNodeRenderer = screen.getByTestId("stElementContainer")
      expect(elementNodeRenderer).toBeInTheDocument()
      // eslint-disable-next-line testing-library/no-node-access
      const elementRendererChildren = elementNodeRenderer.children
      expect(elementRendererChildren).toHaveLength(1)
      expect(elementRendererChildren[0]).toHaveClass("stBalloons")
    })
  })

  describe("render Snow", () => {
    it("should NOT render a stale component", async () => {
      const scriptRunId = "SCRIPT_RUN_ID"
      const props = getProps({
        node: createSnowNode(scriptRunId),
        scriptRunId: "NEW_SCRIPT_ID",
      })
      render(<ElementNodeRenderer {...props} />)

      await waitFor(() =>
        expect(screen.queryByTestId("stSkeleton")).toBeNull()
      )
      const elementNodeRenderer = screen.getByTestId("stElementContainer")
      expect(elementNodeRenderer).toBeInTheDocument()
      // eslint-disable-next-line testing-library/no-node-access
      expect(elementNodeRenderer.children).toHaveLength(0)
    })

    it("should render a fresh component", async () => {
      const scriptRunId = "SCRIPT_RUN_ID"
      const props = getProps({
        node: createSnowNode(scriptRunId),
        scriptRunId,
      })
      render(<ElementNodeRenderer {...props} />)

      await waitFor(() =>
        expect(screen.queryByTestId("stSkeleton")).toBeNull()
      )
      const elementNodeRenderer = screen.getByTestId("stElementContainer")
      expect(elementNodeRenderer).toBeInTheDocument()
      // eslint-disable-next-line testing-library/no-node-access
      const elementRendererChildren = elementNodeRenderer.children
      expect(elementRendererChildren).toHaveLength(1)
      expect(elementRendererChildren[0]).toHaveClass("stSnow")
    })
  })
})


================================================
File: /frontend/lib/src/components/core/Block/ElementNodeRenderer.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, Suspense } from "react"

import debounceRender from "react-debounce-render"
import classNames from "classnames"

import {
  Alert as AlertProto,
  Arrow as ArrowProto,
  AudioInput as AudioInputProto,
  Audio as AudioProto,
  BokehChart as BokehChartProto,
  ButtonGroup as ButtonGroupProto,
  Button as ButtonProto,
  CameraInput as CameraInputProto,
  ChatInput as ChatInputProto,
  Checkbox as CheckboxProto,
  Code as CodeProto,
  ColorPicker as ColorPickerProto,
  ComponentInstance as ComponentInstanceProto,
  DateInput as DateInputProto,
  DeckGlJsonChart as DeckGlJsonChartProto,
  DocString as DocStringProto,
  DownloadButton as DownloadButtonProto,
  Exception as ExceptionProto,
  FileUploader as FileUploaderProto,
  GraphVizChart as GraphVizChartProto,
  Heading as HeadingProto,
  Html as HtmlProto,
  IFrame as IFrameProto,
  ImageList as ImageListProto,
  Json as JsonProto,
  LinkButton as LinkButtonProto,
  Markdown as MarkdownProto,
  Metric as MetricProto,
  MultiSelect as MultiSelectProto,
  NumberInput as NumberInputProto,
  PageLink as PageLinkProto,
  PlotlyChart as PlotlyChartProto,
  Progress as ProgressProto,
  Radio as RadioProto,
  Selectbox as SelectboxProto,
  Skeleton as SkeletonProto,
  Slider as SliderProto,
  Spinner as SpinnerProto,
  TextArea as TextAreaProto,
  TextInput as TextInputProto,
  Text as TextProto,
  TimeInput as TimeInputProto,
  Toast as ToastProto,
  Video as VideoProto,
} from "@streamlit/lib/src/proto"
import { ElementNode } from "@streamlit/lib/src/AppNode"
import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
// Load (non-lazy) elements.
import AlertElement from "@streamlit/lib/src/components/elements/AlertElement"
import ArrowTable from "@streamlit/lib/src/components/elements/ArrowTable"
import DocString from "@streamlit/lib/src/components/elements/DocString"
import ErrorBoundary from "@streamlit/lib/src/components/shared/ErrorBoundary"
import ExceptionElement from "@streamlit/lib/src/components/elements/ExceptionElement"
import Json from "@streamlit/lib/src/components/elements/Json"
import Markdown from "@streamlit/lib/src/components/elements/Markdown"
import Metric from "@streamlit/lib/src/components/elements/Metric"
import { Skeleton } from "@streamlit/lib/src/components/elements/Skeleton"
import TextElement from "@streamlit/lib/src/components/elements/TextElement"
import { ComponentInstance } from "@streamlit/lib/src/components/widgets/CustomComponent"
import { VegaLiteChartElement } from "@streamlit/lib/src/components/elements/ArrowVegaLiteChart"
import { getAlertElementKind } from "@streamlit/lib/src/components/elements/AlertElement/AlertElement"
import Maybe from "@streamlit/lib/src/components/core/Maybe"
import { FormSubmitContent } from "@streamlit/lib/src/components/widgets/Form"
import Heading from "@streamlit/lib/src/components/shared/StreamlitMarkdown/Heading"
import { LibContext } from "@streamlit/lib/src/components/core/LibContext"
import { getElementId } from "@streamlit/lib/src/util/utils"

import {
  BaseBlockProps,
  convertKeyToClassName,
  getKeyFromId,
  isComponentStale,
  shouldComponentBeEnabled,
} from "./utils"
import { StyledElementContainer } from "./styled-components"

// Lazy-load elements.
const Audio = React.lazy(
  () => import("@streamlit/lib/src/components/elements/Audio")
)
const Balloons = React.lazy(
  () => import("@streamlit/lib/src/components/elements/Balloons")
)
const Snow = React.lazy(
  () => import("@streamlit/lib/src/components/elements/Snow")
)
const ArrowDataFrame = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/DataFrame")
)
const ArrowVegaLiteChart = React.lazy(
  () => import("@streamlit/lib/src/components/elements/ArrowVegaLiteChart")
)
const Toast = React.lazy(
  () => import("@streamlit/lib/src/components/elements/Toast")
)

// BokehChart render function is sluggish. If the component is not debounced,
// AutoSizer causes it to rerender multiple times for different widths
// when the sidebar is toggled, which significantly slows down the app.
const BokehChart = React.lazy(
  () => import("@streamlit/lib/src/components/elements/BokehChart")
)

// RTL ESLint triggers a false positive on this render function
// eslint-disable-next-line testing-library/render-result-naming-convention
const DebouncedBokehChart = debounceRender(BokehChart, 100)

const DeckGlJsonChart = React.lazy(
  () => import("@streamlit/lib/src/components/elements/DeckGlJsonChart")
)
const GraphVizChart = React.lazy(
  () => import("@streamlit/lib/src/components/elements/GraphVizChart")
)
const IFrame = React.lazy(
  () => import("@streamlit/lib/src/components/elements/IFrame")
)
const ImageList = React.lazy(
  () => import("@streamlit/lib/src/components/elements/ImageList")
)

const LinkButton = React.lazy(
  () => import("@streamlit/lib/src/components/elements/LinkButton")
)

const PageLink = React.lazy(
  () => import("@streamlit/lib/src/components/elements/PageLink")
)

const PlotlyChart = React.lazy(
  () => import("@streamlit/lib/src/components/elements/PlotlyChart")
)
const Video = React.lazy(
  () => import("@streamlit/lib/src/components/elements/Video")
)

// Lazy-load widgets.
const AudioInput = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/AudioInput")
)

const Button = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/Button")
)
const ButtonGroup = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/ButtonGroup")
)
const DownloadButton = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/DownloadButton")
)
const CameraInput = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/CameraInput")
)
const ChatInput = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/ChatInput")
)
const Checkbox = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/Checkbox")
)
const ColorPicker = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/ColorPicker")
)
const DateInput = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/DateInput")
)
const Html = React.lazy(
  () => import("@streamlit/lib/src/components/elements/Html")
)
const Multiselect = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/Multiselect")
)
const Progress = React.lazy(
  () => import("@streamlit/lib/src/components/elements/Progress")
)
const Spinner = React.lazy(
  () => import("@streamlit/lib/src/components/elements/Spinner")
)
const Radio = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/Radio")
)
const Selectbox = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/Selectbox")
)
const Slider = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/Slider")
)
const FileUploader = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/FileUploader")
)
const TextArea = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/TextArea")
)
const TextInput = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/TextInput")
)
const TimeInput = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/TimeInput")
)
const NumberInput = React.lazy(
  () => import("@streamlit/lib/src/components/widgets/NumberInput")
)
const StreamlitSyntaxHighlighter = React.lazy(
  () =>
    import(
      "@streamlit/lib/src/components/elements/CodeBlock/StreamlitSyntaxHighlighter"
    )
)

export interface ElementNodeRendererProps extends BaseBlockProps {
  node: ElementNode
  width: number
}

interface RawElementNodeRendererProps extends ElementNodeRendererProps {
  isStale: boolean
}

function hideIfStale(isStale: boolean, component: ReactElement): ReactElement {
  return isStale ? <></> : component
}

// Render ElementNodes (i.e. leaf nodes).
const RawElementNodeRenderer = (
  props: RawElementNodeRendererProps
): ReactElement => {
  const { node } = props

  if (!node) {
    throw new Error("ElementNode not found.")
  }

  const elementProps = {
    width: props.width,
    disableFullscreenMode: props.disableFullscreenMode,
  }

  const widgetProps = {
    ...elementProps,
    widgetMgr: props.widgetMgr,
    disabled: props.widgetsDisabled,
    fragmentId: node.fragmentId,
  }

  switch (node.element.type) {
    case "alert": {
      const alertProto = node.element.alert as AlertProto
      return (
        <AlertElement
          icon={alertProto.icon}
          body={alertProto.body}
          kind={getAlertElementKind(alertProto.format)}
          {...elementProps}
        />
      )
    }

    case "arrowTable":
      return (
        <ArrowTable element={node.quiverElement as Quiver} {...elementProps} />
      )

    case "audio":
      return (
        <Audio
          element={node.element.audio as AudioProto}
          endpoints={props.endpoints}
          {...elementProps}
          elementMgr={props.widgetMgr}
        />
      )

    case "balloons":
      return hideIfStale(
        props.isStale,
        <Balloons scriptRunId={props.scriptRunId} />
      )

    case "bokehChart":
      return (
        <DebouncedBokehChart
          element={node.element.bokehChart as BokehChartProto}
          {...elementProps}
        />
      )

    case "code": {
      const codeProto = node.element.code as CodeProto
      return (
        <StreamlitSyntaxHighlighter
          language={codeProto.language}
          showLineNumbers={codeProto.showLineNumbers}
          wrapLines={codeProto.wrapLines}
          height={codeProto.height}
        >
          {codeProto.codeText}
        </StreamlitSyntaxHighlighter>
      )
    }

    case "deckGlJsonChart":
      return (
        <DeckGlJsonChart
          element={node.element.deckGlJsonChart as DeckGlJsonChartProto}
          {...widgetProps}
        />
      )

    case "docString":
      return (
        <DocString
          element={node.element.docString as DocStringProto}
          {...elementProps}
        />
      )

    case "empty":
      return <div className="stEmpty" data-testid="stEmpty" />

    case "exception":
      return (
        <ExceptionElement
          element={node.element.exception as ExceptionProto}
          {...elementProps}
        />
      )

    case "graphvizChart":
      return (
        <GraphVizChart
          element={node.element.graphvizChart as GraphVizChartProto}
          {...elementProps}
        />
      )

    case "heading":
      return (
        <Heading
          element={node.element.heading as HeadingProto}
          {...elementProps}
        />
      )

    case "iframe":
      return (
        <IFrame
          element={node.element.iframe as IFrameProto}
          {...elementProps}
        />
      )

    case "imgs":
      return (
        <ImageList
          element={node.element.imgs as ImageListProto}
          endpoints={props.endpoints}
          {...elementProps}
        />
      )

    case "json":
      return (
        <Json element={node.element.json as JsonProto} {...elementProps} />
      )

    case "markdown":
      return (
        <Markdown
          element={node.element.markdown as MarkdownProto}
          {...elementProps}
        />
      )

    case "metric":
      return <Metric element={node.element.metric as MetricProto} />

    case "html":
      return (
        <Html element={node.element.html as HtmlProto} {...elementProps} />
      )

    case "pageLink": {
      const pageLinkProto = node.element.pageLink as PageLinkProto
      const isDisabled = widgetProps.disabled || pageLinkProto.disabled
      return (
        <PageLink
          element={pageLinkProto}
          disabled={isDisabled}
          {...elementProps}
        />
      )
    }

    case "progress":
      return (
        <Progress
          element={node.element.progress as ProgressProto}
          {...elementProps}
        />
      )

    case "skeleton": {
      return <Skeleton element={node.element.skeleton as SkeletonProto} />
    }

    case "snow":
      return hideIfStale(
        props.isStale,
        <Snow scriptRunId={props.scriptRunId} />
      )

    case "spinner":
      return (
        <Spinner
          element={node.element.spinner as SpinnerProto}
          {...elementProps}
        />
      )

    case "text":
      return (
        <TextElement
          element={node.element.text as TextProto}
          {...elementProps}
        />
      )

    case "video":
      return (
        <Video
          element={node.element.video as VideoProto}
          endpoints={props.endpoints}
          {...elementProps}
          elementMgr={props.widgetMgr}
        />
      )

    // Events:
    case "toast": {
      const toastProto = node.element.toast as ToastProto
      return (
        <Toast
          // React key needed so toasts triggered on re-run
          key={node.scriptRunId}
          body={toastProto.body}
          icon={toastProto.icon}
          {...elementProps}
        />
      )
    }

    // Widgets:
    case "arrowDataFrame": {
      const arrowProto = node.element.arrowDataFrame as ArrowProto
      widgetProps.disabled = widgetProps.disabled || arrowProto.disabled
      return (
        <ArrowDataFrame
          element={arrowProto}
          data={node.quiverElement as Quiver}
          // Arrow dataframe can be used as a widget (data_editor) or
          // an element (dataframe). We only want to set the key in case of
          // it being used as a widget. For the non-widget usage, the id will
          // be undefined.
          {...(arrowProto.id && {
            key: arrowProto.id,
          })}
          {...widgetProps}
        />
      )
    }

    case "arrowVegaLiteChart":
      const vegaLiteElement = node.vegaLiteChartElement as VegaLiteChartElement
      return (
        <ArrowVegaLiteChart
          element={vegaLiteElement}
          // Vega-lite chart can be used as a widget (when selections are activated) or
          // an element. We only want to set the key in case of it being used as a widget
          // since otherwise it might break some apps that show the same charts multiple times.
          // So we only compute an element ID if it's a widget, otherwise its an empty string.
          key={vegaLiteElement.id || undefined}
          {...widgetProps}
        />
      )

    case "audioInput": {
      const audioInputProto = node.element.audioInput as AudioInputProto
      widgetProps.disabled = widgetProps.disabled || audioInputProto.disabled

      return (
        <AudioInput
          key={audioInputProto.id}
          uploadClient={props.uploadClient}
          element={audioInputProto}
          {...widgetProps}
        ></AudioInput>
      )
    }

    case "button": {
      const buttonProto = node.element.button as ButtonProto
      widgetProps.disabled = widgetProps.disabled || buttonProto.disabled
      if (buttonProto.isFormSubmitter) {
        const { formId } = buttonProto
        const hasInProgressUpload =
          props.formsData.formsWithUploads.has(formId)
        return (
          <FormSubmitContent
            element={buttonProto}
            hasInProgressUpload={hasInProgressUpload}
            {...widgetProps}
          />
        )
      }
      return <Button element={buttonProto} {...widgetProps} />
    }

    case "buttonGroup": {
      const buttonGroupProto = node.element.buttonGroup as ButtonGroupProto
      widgetProps.disabled = widgetProps.disabled || buttonGroupProto.disabled
      return (
        <ButtonGroup
          key={buttonGroupProto.id}
          element={buttonGroupProto}
          {...widgetProps}
        />
      )
    }

    case "downloadButton": {
      const downloadButtonProto = node.element
        .downloadButton as DownloadButtonProto
      widgetProps.disabled =
        widgetProps.disabled || downloadButtonProto.disabled
      return (
        <DownloadButton
          endpoints={props.endpoints}
          key={downloadButtonProto.id}
          element={downloadButtonProto}
          {...widgetProps}
        />
      )
    }

    case "cameraInput": {
      const cameraInputProto = node.element.cameraInput as CameraInputProto
      widgetProps.disabled = widgetProps.disabled || cameraInputProto.disabled
      return (
        <CameraInput
          key={cameraInputProto.id}
          element={cameraInputProto}
          uploadClient={props.uploadClient}
          {...widgetProps}
        />
      )
    }

    case "chatInput": {
      const chatInputProto = node.element.chatInput as ChatInputProto
      widgetProps.disabled = widgetProps.disabled || chatInputProto.disabled
      return (
        <ChatInput
          key={chatInputProto.id}
          element={chatInputProto}
          {...widgetProps}
        />
      )
    }

    case "checkbox": {
      const checkboxProto = node.element.checkbox as CheckboxProto
      widgetProps.disabled = widgetProps.disabled || checkboxProto.disabled
      return (
        <Checkbox
          key={checkboxProto.id}
          element={checkboxProto}
          {...widgetProps}
        />
      )
    }

    case "colorPicker": {
      const colorPickerProto = node.element.colorPicker as ColorPickerProto
      widgetProps.disabled = widgetProps.disabled || colorPickerProto.disabled
      return (
        <ColorPicker
          key={colorPickerProto.id}
          element={colorPickerProto}
          {...widgetProps}
        />
      )
    }

    case "componentInstance":
      return (
        <ComponentInstance
          registry={props.componentRegistry}
          element={node.element.componentInstance as ComponentInstanceProto}
          {...widgetProps}
        />
      )

    case "dateInput": {
      const dateInputProto = node.element.dateInput as DateInputProto
      widgetProps.disabled = widgetProps.disabled || dateInputProto.disabled
      return (
        <DateInput
          key={dateInputProto.id}
          element={dateInputProto}
          {...widgetProps}
        />
      )
    }

    case "fileUploader": {
      const fileUploaderProto = node.element.fileUploader as FileUploaderProto
      widgetProps.disabled = widgetProps.disabled || fileUploaderProto.disabled
      return (
        <FileUploader
          key={fileUploaderProto.id}
          element={fileUploaderProto}
          uploadClient={props.uploadClient}
          {...widgetProps}
        />
      )
    }

    case "linkButton": {
      const linkButtonProto = node.element.linkButton as LinkButtonProto
      widgetProps.disabled = widgetProps.disabled || linkButtonProto.disabled
      return <LinkButton element={linkButtonProto} {...widgetProps} />
    }

    case "multiselect": {
      const multiSelectProto = node.element.multiselect as MultiSelectProto
      widgetProps.disabled = widgetProps.disabled || multiSelectProto.disabled
      return (
        <Multiselect
          key={multiSelectProto.id}
          element={multiSelectProto}
          {...widgetProps}
        />
      )
    }

    case "numberInput": {
      const numberInputProto = node.element.numberInput as NumberInputProto
      widgetProps.disabled = widgetProps.disabled || numberInputProto.disabled
      return (
        <NumberInput
          key={numberInputProto.id}
          element={numberInputProto}
          {...widgetProps}
        />
      )
    }

    case "plotlyChart": {
      const plotlyProto = node.element.plotlyChart as PlotlyChartProto
      return (
        <PlotlyChart
          key={plotlyProto.id}
          element={plotlyProto}
          {...widgetProps}
        />
      )
    }

    case "radio": {
      const radioProto = node.element.radio as RadioProto
      widgetProps.disabled = widgetProps.disabled || radioProto.disabled
      return (
        <Radio key={radioProto.id} element={radioProto} {...widgetProps} />
      )
    }

    case "selectbox": {
      const selectboxProto = node.element.selectbox as SelectboxProto
      widgetProps.disabled = widgetProps.disabled || selectboxProto.disabled
      return (
        <Selectbox
          key={selectboxProto.id}
          element={selectboxProto}
          {...widgetProps}
        />
      )
    }

    case "slider": {
      const sliderProto = node.element.slider as SliderProto
      widgetProps.disabled = widgetProps.disabled || sliderProto.disabled
      return (
        <Slider key={sliderProto.id} element={sliderProto} {...widgetProps} />
      )
    }

    case "textArea": {
      const textAreaProto = node.element.textArea as TextAreaProto
      widgetProps.disabled = widgetProps.disabled || textAreaProto.disabled
      return (
        <TextArea
          key={textAreaProto.id}
          element={textAreaProto}
          {...widgetProps}
        />
      )
    }

    case "textInput": {
      const textInputProto = node.element.textInput as TextInputProto
      widgetProps.disabled = widgetProps.disabled || textInputProto.disabled
      return (
        <TextInput
          key={textInputProto.id}
          element={textInputProto}
          {...widgetProps}
        />
      )
    }

    case "timeInput": {
      const timeInputProto = node.element.timeInput as TimeInputProto
      widgetProps.disabled = widgetProps.disabled || timeInputProto.disabled
      return (
        <TimeInput
          key={timeInputProto.id}
          element={timeInputProto}
          {...widgetProps}
        />
      )
    }

    default:
      throw new Error(`Unrecognized Element type ${node.element.type}`)
  }
}

// Render ElementNodes (i.e. leaf nodes) wrapped in error catchers and all sorts of other //
// utilities.
const ElementNodeRenderer = (
  props: ElementNodeRendererProps
): ReactElement => {
  const { isFullScreen, fragmentIdsThisRun } = React.useContext(LibContext)
  const { node, width } = props

  const elementType = node.element.type || ""
  const enable = shouldComponentBeEnabled(elementType, props.scriptRunState)
  const isStale = isComponentStale(
    enable,
    node,
    props.scriptRunState,
    props.scriptRunId,
    fragmentIdsThisRun
  )

  // Get the user key - if it was specified - and use it as CSS class name:
  const elementId = getElementId(node.element)
  const userKey = getKeyFromId(elementId)

  // TODO: If would be great if we could return an empty fragment if isHidden is true, to keep the
  // DOM clean. But this would require the keys passed to ElementNodeRenderer at Block.tsx to be a
  // stable hash of some sort.

  return (
    <Maybe enable={enable}>
      <StyledElementContainer
        className={classNames(
          "stElementContainer",
          "element-container",
          convertKeyToClassName(userKey)
        )}
        data-testid="stElementContainer"
        data-stale={isStale}
        // Applying stale opacity in fullscreen mode
        // causes the fullscreen overlay to be transparent.
        isStale={isStale && !isFullScreen}
        width={width}
        elementType={elementType}
      >
        <ErrorBoundary width={width}>
          <Suspense
            fallback={
              <Skeleton
                element={SkeletonProto.create({
                  style: SkeletonProto.SkeletonStyle.ELEMENT,
                })}
              />
            }
          >
            <RawElementNodeRenderer {...props} isStale={isStale} />
          </Suspense>
        </ErrorBoundary>
      </StyledElementContainer>
    </Maybe>
  )
}

export default ElementNodeRenderer


================================================
File: /frontend/lib/src/components/core/Block/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { BlockPropsWithoutWidth as BlockPropsWithoutWidthT } from "./Block"

export type BlockPropsWithoutWidth = BlockPropsWithoutWidthT
export { default } from "./Block"


================================================
File: /frontend/lib/src/components/core/Block/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import styled from "@emotion/styled"

import { StyledCheckbox } from "@streamlit/lib/src/components/widgets/Checkbox/styled-components"
import { Block as BlockProto } from "@streamlit/lib/src/proto"
import { EmotionTheme, STALE_STYLES } from "@streamlit/lib/src/theme"

function translateGapWidth(gap: string, theme: EmotionTheme): string {
  let gapWidth = theme.spacing.lg
  if (gap === "medium") {
    gapWidth = theme.spacing.threeXL
  } else if (gap === "large") {
    gapWidth = theme.spacing.fourXL
  }
  return gapWidth
}
export interface StyledHorizontalBlockProps {
  gap: string
}

export const StyledHorizontalBlock = styled.div<StyledHorizontalBlockProps>(
  ({ theme, gap }) => {
    const gapWidth = translateGapWidth(gap, theme)

    return {
      // While using flex for columns, padding is used for large screens and gap
      // for small ones. This can be adjusted once more information is passed.
      // More information and discussions can be found: Issue #2716, PR #2811
      display: "flex",
      flexWrap: "wrap",
      flexGrow: 1,
      alignItems: "stretch",
      gap: gapWidth,
    }
  }
)

export interface StyledElementContainerProps {
  isStale: boolean
  width: number
  elementType: string
}

const GLOBAL_ELEMENTS = ["balloons", "snow"]
export const StyledElementContainer = styled.div<StyledElementContainerProps>(
  ({ theme, isStale, width, elementType }) => ({
    width,
    // Allows to have absolutely-positioned nodes inside app elements, like
    // floating buttons.
    position: "relative",

    "@media print": {
      overflow: "visible",
    },

    ":is(.stHtml-empty)": {
      display: "none",
    },

    ":has(> .stCacheSpinner)": {
      height: theme.spacing.none,
      overflow: "visible",
      visibility: "visible",
      marginBottom: `-${theme.spacing.lg}`,
      zIndex: theme.zIndices.cacheSpinner,
    },

    ":has(> .stPageLink)": {
      marginTop: `-${theme.spacing.xs}`,
      marginBottom: `-${theme.spacing.xs}`,
    },

    ...(isStale && elementType !== "skeleton" && STALE_STYLES),
    ...(elementType === "empty"
      ? {
          // Use display: none for empty elements to avoid the flexbox gap.
          display: "none",
        }
      : {}),
    ...(GLOBAL_ELEMENTS.includes(elementType)
      ? {
          // Global elements are rendered in their delta position, but they
          // are not part of the flexbox layout. We apply a negative margin
          // to remove the flexbox gap. display: none does not work for these,
          // since they needs to be visible.
          marginBottom: `-${theme.spacing.lg}`,
        }
      : {}),
  })
)

interface StyledColumnProps {
  weight: number
  gap: string
  showBorder: boolean
  verticalAlignment?: BlockProto.Column.VerticalAlignment
}

export const StyledColumn = styled.div<StyledColumnProps>(
  ({ theme, weight, gap, showBorder, verticalAlignment }) => {
    const { VerticalAlignment } = BlockProto.Column
    const percentage = weight * 100
    const gapWidth = translateGapWidth(gap, theme)
    const width = `calc(${percentage}% - ${gapWidth})`

    return {
      // Calculate width based on percentage, but fill all available space,
      // e.g. if it overflows to next row.
      width,
      flex: `1 1 ${width}`,

      [`@media (max-width: ${theme.breakpoints.columns})`]: {
        minWidth: `calc(100% - ${theme.spacing.twoXL})`,
      },
      ...(verticalAlignment === VerticalAlignment.BOTTOM && {
        marginTop: "auto",
        // Add margin to the first checkbox/toggle within the column to align it
        // better with other input widgets.
        [`& ${StyledElementContainer}:last-of-type > ${StyledCheckbox}`]: {
          marginBottom: theme.spacing.sm,
        },
      }),
      ...(verticalAlignment === VerticalAlignment.TOP && {
        // Add margin to the first checkbox/toggle within the column to align it
        // better with other input widgets.
        [`& ${StyledElementContainer}:last-of-type > ${StyledCheckbox}`]: {
          marginTop: theme.spacing.sm,
        },
      }),
      ...(verticalAlignment === VerticalAlignment.CENTER && {
        marginTop: "auto",
        marginBottom: "auto",
      }),
      ...(showBorder && {
        border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
        borderRadius: theme.radii.default,
        padding: `calc(${theme.spacing.lg} - ${theme.sizes.borderWidth})`,
      }),
    }
  }
)

export interface StyledVerticalBlockProps {
  ref?: React.RefObject<any>
  width?: number
}

export const StyledVerticalBlock = styled.div<StyledVerticalBlockProps>(
  ({ width, theme }) => ({
    width,
    position: "relative", // Required for the automatic width computation.
    display: "flex",
    flex: 1,
    flexDirection: "column",
    gap: theme.spacing.lg,
  })
)

export const StyledVerticalBlockWrapper = styled.div<StyledVerticalBlockProps>(
  {
    display: "flex",
    flexDirection: "column",
    flex: 1,
  }
)

export interface StyledVerticalBlockBorderWrapperProps {
  border: boolean
  height?: number
}

export const StyledVerticalBlockBorderWrapper =
  styled.div<StyledVerticalBlockBorderWrapperProps>(
    ({ theme, border, height }) => ({
      ...(border && {
        border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
        borderRadius: theme.radii.default,
        padding: `calc(${theme.spacing.lg} - ${theme.sizes.borderWidth})`,
      }),
      ...(height && {
        height: `${height}px`,
        overflow: "auto",
      }),
    })
  )


================================================
File: /frontend/lib/src/components/core/Block/utils.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { ElementNode } from "@streamlit/lib/src/AppNode"
import { ScriptRunState } from "@streamlit/lib/src/ScriptRunState"

import { convertKeyToClassName, getKeyFromId, isElementStale } from "./utils"

describe("isElementStale", () => {
  const node = new ElementNode(
    // @ts-expect-error
    null,
    null,
    "myScriptRunId",
    "activeScriptHash",
    "myFragmentId"
  )

  it("returns true if scriptRunState is RERUN_REQUESTED", () => {
    expect(
      isElementStale(
        node,
        ScriptRunState.RERUN_REQUESTED,
        "someScriptRunId",
        []
      )
    ).toBe(true)
  })

  // When running in a fragment, the only elements that should be set to stale
  // are those belonging to the fragment that's currently running and only if the script run id is different.
  // If the script run id is the same, the element has just been updated and is not stale.
  it("if running and currentFragmentId is set, compares with node's fragmentId and scriptrunId", () => {
    expect(
      isElementStale(node, ScriptRunState.RUNNING, "myScriptRunId", [
        "myFragmentId",
      ])
    ).toBe(false)

    expect(
      isElementStale(node, ScriptRunState.RUNNING, "otherScriptRunId", [
        "myFragmentId",
      ])
    ).toBe(true)

    expect(
      isElementStale(node, ScriptRunState.RUNNING, "myScriptRunId", [
        "someFragmentId",
        "someOtherFragmentId",
      ])
    ).toBe(false)
  })

  // When not running in a fragment, all elements from script runs aside from
  // the current one should be set to stale.
  it("if running and currentFragmentId is not set, compares with node's scriptRunId", () => {
    expect(
      isElementStale(node, ScriptRunState.RUNNING, "someOtherScriptRunId", [])
    ).toBe(true)

    expect(
      isElementStale(node, ScriptRunState.RUNNING, "myScriptRunId", [])
    ).toBe(false)
  })

  it("returns false for all other script run states", () => {
    const states = [
      ScriptRunState.NOT_RUNNING,
      ScriptRunState.STOP_REQUESTED,
      ScriptRunState.COMPILATION_ERROR,
    ]
    states.forEach(s => {
      expect(isElementStale(node, s, "someOtherScriptRunId", [])).toBe(false)
    })
  })
})

describe("convertKeyToClassName", () => {
  const testCases = [
    { input: undefined, expected: "" },
    { input: null, expected: "" },
    { input: "", expected: "" },
    { input: "helloWorld", expected: "st-key-helloWorld" },
    { input: "hello world!", expected: "st-key-hello-world-" },
    { input: "123Start", expected: "st-key-123Start" },
    { input: "My_Class-Name", expected: "st-key-My_Class-Name" },
    {
      input: "invalid#characters$here",
      expected: "st-key-invalid-characters-here",
    },
    { input: "another$Test_case", expected: "st-key-another-Test_case" },
  ]

  test.each(testCases)(
    "converts $input to $expected",
    ({ input, expected }) => {
      expect(convertKeyToClassName(input)).toBe(expected)
    }
  )
})

describe("getKeyFromId", () => {
  const testCases = [
    {
      input: "",
      expected: undefined,
    },
    {
      input: undefined,
      expected: undefined,
    },
    {
      input: "$ID-899e9b72e1539f21f8e82565d36609d0-foo",
      expected: undefined,
    },
    {
      input: "$$ID-899e9b72e1539f21f8e82565d36609d0-None",
      expected: undefined,
    },
    {
      input: "$$ID-899e9b72e1539f21f8e82565d36609d0",
      expected: undefined,
    },
    { input: "helloWorld", expected: undefined },
    {
      input: "$$ID-899e9b72e1539f21f8e82565d36609d0-first container",
      expected: "first container",
    },
    {
      input: "$$ID-foo-bar",
      expected: "bar",
    },
    {
      input: "$$ID-899e9b72e1539f21f8e82565d36609d0-bar-baz",
      expected: "bar-baz",
    },
  ]

  test.each(testCases)(
    "extracts the key from $input",
    ({ input, expected }) => {
      expect(getKeyFromId(input)).toBe(expected)
    }
  )
})


================================================
File: /frontend/lib/src/components/core/Block/utils.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { AppNode, BlockNode } from "@streamlit/lib/src/AppNode"
import { ComponentRegistry } from "@streamlit/lib/src/components/widgets/CustomComponent"
import { FileUploadClient } from "@streamlit/lib/src/FileUploadClient"
import { ScriptRunState } from "@streamlit/lib/src/ScriptRunState"
import { StreamlitEndpoints } from "@streamlit/lib/src/StreamlitEndpoints"
import { EmotionTheme, getDividerColors } from "@streamlit/lib/src/theme"
import { isValidElementId } from "@streamlit/lib/src/util/utils"
import {
  FormsData,
  WidgetStateManager,
} from "@streamlit/lib/src/WidgetStateManager"

export function shouldComponentBeEnabled(
  elementType: string,
  scriptRunState: ScriptRunState
): boolean {
  return elementType !== "empty" || scriptRunState !== ScriptRunState.RUNNING
}

export function isElementStale(
  node: AppNode,
  scriptRunState: ScriptRunState,
  scriptRunId: string,
  fragmentIdsThisRun?: Array<string>
): boolean {
  if (scriptRunState === ScriptRunState.RERUN_REQUESTED) {
    // If a rerun was just requested, all of our current elements
    // are about to become stale.
    return true
  }

  if (scriptRunState === ScriptRunState.RUNNING) {
    if (fragmentIdsThisRun && fragmentIdsThisRun.length) {
      // if the fragmentId is set, we only want to mark elements as stale
      // that belong to the same fragmentId and have a different scriptRunId.
      // If they have the same scriptRunId, they were just updated.
      return Boolean(
        node.fragmentId &&
          fragmentIdsThisRun.includes(node.fragmentId) &&
          node.scriptRunId !== scriptRunId
      )
    }
    return node.scriptRunId !== scriptRunId
  }

  return false
}

export function isComponentStale(
  enable: boolean,
  node: AppNode,
  scriptRunState: ScriptRunState,
  scriptRunId: string,
  fragmentIdsThisRun?: Array<string>
): boolean {
  return (
    !enable ||
    isElementStale(node, scriptRunState, scriptRunId, fragmentIdsThisRun)
  )
}

export function assignDividerColor(
  node: BlockNode,
  theme: EmotionTheme
): void {
  // All available divider colors
  const allColorMap = getDividerColors(theme)
  const allColorKeys = Object.keys(allColorMap)

  // Limited colors for auto assignment
  const { blue, green, orange, red, violet } = allColorMap
  const autoColorMap = { blue, green, orange, red, violet }
  const autoColorKeys = Object.keys(autoColorMap)
  let dividerIndex = 0

  Array.from(node.getElements()).forEach(element => {
    const divider = element.heading?.divider
    if (element.type === "heading" && divider) {
      if (divider === "auto") {
        const colorKey = autoColorKeys[dividerIndex]
        // @ts-expect-error - heading.divider is not undefined at this point
        element.heading.divider = autoColorMap[colorKey]
        dividerIndex += 1
        if (dividerIndex === autoColorKeys.length) dividerIndex = 0
      } else if (allColorKeys.includes(divider)) {
        // @ts-expect-error
        element.heading.divider = allColorMap[divider]
      }
    }
  })
}
export interface BaseBlockProps {
  /**
   * The app's StreamlitEndpoints instance. Exposes non-websocket endpoint logic
   * used by various Streamlit elements.
   */
  endpoints: StreamlitEndpoints

  /**
   * The app's WidgetStateManager instance. Used by all widget elements to
   * store and retrieve widget state. When the user interacts with a widget,
   * the WidgetStateManager initiates the "rerun BackMsg" data flow to kick
   * off a script rerun.
   */
  widgetMgr: WidgetStateManager

  /**
   * The app's FileUploadClient instance. Used by the FileUploader component
   * to send files to the Streamlit backend.
   */
  uploadClient: FileUploadClient

  /**
   * The app's ComponentRegistry instance. Dispatches "Custom Component"
   * iframe messages to ComponentInstances.
   */
  componentRegistry: ComponentRegistry

  /**
   * The ID of the current "script run". When a Streamlit script is re-run
   * (usually as a result of the user interacting with a widget), the Streamlit
   * backend sends a new scriptRunId to the frontend. When the script run ends,
   * the frontend discards "stale" elements (that is, elements with a non-current
   * scriptRunId).
   */
  scriptRunId: string

  /**
   * The app's current ScriptRunState. This is used in combination with
   * scriptRunId to prune stale elements. It's also used by the app to
   * display the "running man" indicator when the app's script is being re-run.
   */
  scriptRunState: ScriptRunState

  /**
   * If true, all widgets will be disabled and the app will be non-interactive.
   * This is generally set when the frontend is disconnected from the backend.
   */
  widgetsDisabled: boolean

  /**
   * Data about all forms in the app. The WidgetStateManager creates its own
   * internal FormsData instance, and calls a callback (`formsDataChanged`)
   * when forms are updated. This FormsData instance should be updated
   * from that callback.
   */
  formsData: FormsData

  /**
   * If true , the element should not allow going into fullscreen. Right now we plan
   * to use it, for example, in Dialogs to prevent fullscreen issues.
   */
  disableFullscreenMode?: boolean
}

/**
 * Converts a user-specified key to a valid CSS class name.
 *
 * @param key - The key to convert.
 * @returns A valid CSS class name.
 */
export function convertKeyToClassName(key: string | undefined | null): string {
  if (!key) {
    return ""
  }
  const className = key.trim().replace(/[^a-zA-Z0-9_-]/g, "-")
  return "st-key-" + className
}

/**
 * Returns the user-specified key extracted from the element id, or undefined if the id does
 * not have a user-specified key.
 */
export function getKeyFromId(
  elementId: string | undefined | null
): string | undefined {
  if (!elementId || !isValidElementId(elementId)) {
    return undefined
  }

  // Split the elementId by hyphens
  const parts = elementId.split("-")
  // Extract all parts after the second hyphen
  const userKey = parts.slice(2).join("-")
  return userKey === "None" ? undefined : userKey
}


================================================
File: /frontend/lib/src/components/core/Maybe/Maybe.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC } from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import Maybe from "./Maybe"

interface OuterProps {
  name: string
  enable: boolean
}

interface InnerProps {
  name: string
}

let innerRenderCount = 0
const Inner: FC<InnerProps> = props => {
  // Side-effect: mutable variable for testing render counts
  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  innerRenderCount += 1
  return <div>{props.name}</div>
}

const Outer: FC<OuterProps> = props => (
  <Maybe enable={props.enable}>
    <Inner name={props.name} />
  </Maybe>
)

describe("The Maybe component", () => {
  beforeEach(() => {
    innerRenderCount = 0
  })

  describe("when enable is true", () => {
    it("should render when the props of an enclosing element update", () => {
      const { rerender } = render(<Outer name={"old again"} enable={true} />)

      expect(innerRenderCount).toBe(1)
      expect(screen.getByText("old again")).toBeVisible()

      rerender(<Outer name={"new name"} enable={true} />)

      expect(innerRenderCount).toBe(2)
      expect(screen.getByText("new name")).toBeVisible()
    })

    it("should update when a Maybe is first disabled", () => {
      const { rerender } = render(<Outer name={"old again"} enable={false} />)

      expect(innerRenderCount).toBe(1)
      expect(screen.getByText("old again")).toBeVisible()

      rerender(<Outer name={"new name"} enable={true} />)

      expect(innerRenderCount).toBe(2)
      // Because enable changes between renders, the inner component should be
      // rerendered.
      expect(screen.queryByText("new name")).toBeVisible()
    })
  })

  describe("when enable is false", () => {
    it("should not render children when disabled", () => {
      const { rerender } = render(<Outer name={"old again"} enable={false} />)

      expect(innerRenderCount).toBe(1)
      expect(screen.queryByText("old again")).toBeVisible()

      rerender(<Outer name={"new name"} enable={false} />)
      rerender(<Outer name={"new name"} enable={false} />)
      rerender(<Outer name={"new name"} enable={false} />)

      // Despite rerendering multiple times, the inner component should only
      // render once at the start.
      expect(innerRenderCount).toBe(1)
      expect(screen.queryByText("old again")).toBeVisible()
      expect(screen.queryByText("new name")).not.toBeInTheDocument()
    })
  })
})


================================================
File: /frontend/lib/src/components/core/Maybe/Maybe.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import React, { memo, PropsWithChildren } from "react"

interface MaybeProps
  extends PropsWithChildren<{
    enable: boolean
  }> {}

const Maybe: React.FC<MaybeProps> = memo(
  function Maybe({ children }) {
    return <>{children}</>
  },
  (prevProps, nextProps) => {
    // If either prevProps.enable OR nextProps.enable is true, we want to update
    // the component. In order to do so, we return false to indicate that props
    // are not the same. This ensures that we rerender in the case that an
    // Element is removed by replacing it with an empty one (so goes from
    // enabled->disabled).
    return !(prevProps.enable || nextProps.enable)
  }
)

export default Maybe


================================================
File: /frontend/lib/src/components/core/Maybe/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Maybe"


================================================
File: /frontend/lib/src/components/core/Portal/PortalContext.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import React from "react"

export const PortalContext = React.createContext<
  (() => HTMLElement | null) | null
>(null)


================================================
File: /frontend/lib/src/components/core/Portal/PortalProvider.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import React, { FC, PropsWithChildren, useCallback, useRef } from "react"

import { StyledDataFrameOverlay } from "@streamlit/lib/src/styled-components"

import { PortalContext } from "./PortalContext"

export const PortalProvider: FC<PropsWithChildren> = ({ children }) => {
  const ref = useRef<HTMLDivElement>(null)

  const getRefElement = useCallback(() => {
    return ref.current
  }, [])

  return (
    <PortalContext.Provider value={getRefElement}>
      {children}
      <StyledDataFrameOverlay data-testid="portal" id="portal" ref={ref} />
    </PortalContext.Provider>
  )
}


================================================
File: /frontend/lib/src/components/core/Portal/RenderInPortalIfExists.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, PropsWithChildren, useContext } from "react"

import { createPortal } from "react-dom"

import { PortalContext } from "./PortalContext"

export const RenderInPortalIfExists: FC<PropsWithChildren> = ({
  children,
}) => {
  const portalElement = useContext(PortalContext)?.()

  return portalElement ? (
    createPortal(children, portalElement)
  ) : (
    <>{children}</>
  )
}


================================================
File: /frontend/lib/src/components/elements/AlertElement/AlertElement.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { Kind } from "@streamlit/lib/src/components/shared/AlertContainer"
import { Alert as AlertProto } from "@streamlit/lib/src/proto"

import AlertElement, {
  AlertElementProps,
  getAlertElementKind,
} from "./AlertElement"

const getProps = (
  elementProps: Partial<AlertElementProps> = {}
): AlertElementProps => ({
  body: "Something happened!",
  kind: Kind.INFO,
  width: 100,
  ...elementProps,
})

describe("Alert element", () => {
  it("renders an ERROR box as expected", () => {
    const props = getProps({
      kind: getAlertElementKind(AlertProto.Format.ERROR),
      body: "#what in the world?",
    })
    render(<AlertElement {...props} />)
    const alertElement = screen.getByTestId("stAlert")
    expect(alertElement).toBeInTheDocument()
    expect(alertElement).toHaveClass("stAlert")

    expect(screen.getByTestId("stAlertContentError")).toBeInTheDocument()
    expect(screen.queryByTestId("stAlertDynamicIcon")).not.toBeInTheDocument()
    expect(screen.getByText("#what in the world?")).toBeInTheDocument()
  })

  it("renders a WARNING box as expected", () => {
    const props = getProps({
      kind: getAlertElementKind(AlertProto.Format.WARNING),
      body: "test",
    })
    render(<AlertElement {...props} />)
    expect(screen.getByTestId("stAlert")).toBeInTheDocument()
    expect(screen.getByTestId("stAlertContentWarning")).toBeInTheDocument()
    expect(screen.queryByTestId("stAlertDynamicIcon")).not.toBeInTheDocument()
    expect(screen.getByText("test")).toBeInTheDocument()
  })

  it("renders a SUCCESS box as expected", () => {
    const props = getProps({
      kind: getAlertElementKind(AlertProto.Format.SUCCESS),
      body: "But our princess was in another castle!",
    })
    render(<AlertElement {...props} />)
    expect(screen.getByTestId("stAlert")).toBeInTheDocument()
    expect(screen.getByTestId("stAlertContentSuccess")).toBeInTheDocument()
    expect(screen.queryByTestId("stAlertDynamicIcon")).not.toBeInTheDocument()
    expect(
      screen.getByText("But our princess was in another castle!")
    ).toBeInTheDocument()
  })

  it("renders an INFO box as expected", () => {
    const props = getProps({
      kind: getAlertElementKind(AlertProto.Format.INFO),
      body: "It's dangerous to go alone.",
    })
    render(<AlertElement {...props} />)
    expect(screen.getByTestId("stAlert")).toBeInTheDocument()
    expect(screen.getByTestId("stAlertContentInfo")).toBeInTheDocument()
    expect(screen.queryByTestId("stAlertDynamicIcon")).not.toBeInTheDocument()
    expect(screen.getByText("It's dangerous to go alone.")).toBeInTheDocument()
  })

  it("accepts an icon", () => {
    const props = getProps({
      kind: getAlertElementKind(AlertProto.Format.INFO),
      body: "It's dangerous to go alone.",
      icon: "👉🏻",
    })
    render(<AlertElement {...props} />)
    expect(screen.getByTestId("stAlert")).toBeInTheDocument()
    expect(screen.getByTestId("stAlertContentInfo")).toBeInTheDocument()
    expect(screen.getByTestId("stAlertDynamicIcon")).toHaveTextContent("👉🏻")
    expect(screen.getByText("It's dangerous to go alone.")).toBeInTheDocument()
  })
})

test("getAlertElementKind throws an error on invalid format", () => {
  expect(() => getAlertElementKind(AlertProto.Format.UNUSED)).toThrow(
    `Unexpected alert type: ${AlertProto.Format.UNUSED}`
  )
})


================================================
File: /frontend/lib/src/components/elements/AlertElement/AlertElement.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { useTheme } from "@emotion/react"

import { Alert as AlertProto } from "@streamlit/lib/src/proto"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"
import { DynamicIcon } from "@streamlit/lib/src/components/shared/Icon"
import AlertContainer, {
  Kind,
} from "@streamlit/lib/src/components/shared/AlertContainer"
import { EmotionTheme } from "@streamlit/lib/src/theme"

import { StyledAlertContent } from "./styled-components"

export function getAlertElementKind(format: AlertProto.Format): Kind {
  switch (format) {
    case AlertProto.Format.ERROR:
      return Kind.ERROR
    case AlertProto.Format.INFO:
      return Kind.INFO
    case AlertProto.Format.SUCCESS:
      return Kind.SUCCESS
    case AlertProto.Format.WARNING:
      return Kind.WARNING
    default:
      throw new Error(`Unexpected alert type: ${format}`)
  }
}

export interface AlertElementProps {
  body: string
  icon?: string
  kind: Kind
  width: number
}

/**
 * Display an (error|warning|info|success) box with a Markdown-formatted body.
 */
export default function AlertElement({
  icon,
  body,
  kind,
  width,
}: Readonly<AlertElementProps>): ReactElement {
  const theme: EmotionTheme = useTheme()
  const markdownWidth = {
    // Fix issue #6394 - Need to account for icon size (iconSizes.lg) + gap when icon present
    width: icon
      ? `calc(100% - (${theme.iconSizes.lg} + ${theme.spacing.sm}))`
      : "100%",
  }

  return (
    <div className="stAlert" data-testid="stAlert">
      <AlertContainer width={width} kind={kind}>
        <StyledAlertContent>
          {icon && (
            <DynamicIcon
              iconValue={icon}
              size="lg"
              testid="stAlertDynamicIcon"
            />
          )}

          <StreamlitMarkdown
            source={body}
            allowHTML={false}
            style={markdownWidth}
          />
        </StyledAlertContent>
      </AlertContainer>
    </div>
  )
}


================================================
File: /frontend/lib/src/components/elements/AlertElement/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./AlertElement"


================================================
File: /frontend/lib/src/components/elements/AlertElement/styled-components.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

import {
  StyledEmojiIcon,
  StyledIcon,
} from "@streamlit/lib/src/components/shared/Icon/styled-components"
import { StyledCodeBlock } from "@streamlit/lib/src/components/elements/CodeBlock/styled-components"
import { StyledMaterialIcon } from "@streamlit/lib/src/components/shared/Icon/Material/styled-components"

export const StyledAlertContent = styled.div(({ theme }) => ({
  display: "flex",
  gap: theme.spacing.sm,
  width: "100%",

  [`${StyledEmojiIcon}, ${StyledIcon}, ${StyledMaterialIcon}`]: {
    position: "relative",
    top: "2px",
  },

  [`${StyledCodeBlock} code`]: {
    paddingRight: theme.spacing.lg,
  },
}))


================================================
File: /frontend/lib/src/components/elements/ArrowTable/ArrowTable.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { EMPTY, UNICODE } from "@streamlit/lib/src/mocks/arrow"
import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"

import { ArrowTable, TableProps } from "./ArrowTable"

const getProps = (data: Uint8Array): TableProps => ({
  element: new Quiver({ data }),
})

describe("st._arrow_table", () => {
  it("renders without crashing", () => {
    const props = getProps(UNICODE)
    render(<ArrowTable {...props} />)
    const tableElement = screen.getByTestId("stTable")
    expect(tableElement).toBeInTheDocument()
    expect(tableElement).toHaveClass("stTable")

    expect(screen.getByTestId("stTableStyledTable")).toBeInTheDocument()
    expect(
      screen.queryByTestId("stTableStyledEmptyTableCell")
    ).not.toBeInTheDocument()
  })

  it("renders an empty row", () => {
    const props = getProps(EMPTY)
    render(<ArrowTable {...props} />)

    expect(screen.getByTestId("stTable")).toBeInTheDocument()
    expect(screen.getByTestId("stTableStyledTable")).toBeInTheDocument()
    expect(
      screen.getByTestId("stTableStyledEmptyTableCell")
    ).toBeInTheDocument()
  })
})


================================================
File: /frontend/lib/src/components/elements/ArrowTable/ArrowTable.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import range from "lodash/range"

import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import { format as formatArrowCell } from "@streamlit/lib/src/dataframes/arrowFormatUtils"
import { isNumericType } from "@streamlit/lib/src/dataframes/arrowTypeUtils"

import {
  StyledEmptyTableCell,
  StyledTable,
  StyledTableBorder,
  StyledTableCell,
  StyledTableCellHeader,
  StyledTableContainer,
} from "./styled-components"

export interface TableProps {
  element: Quiver
}

export function ArrowTable(props: Readonly<TableProps>): ReactElement {
  const table = props.element
  const { cssId, cssStyles, caption } = table.styler ?? {}
  const { numHeaderRows, numRows, numColumns } = table.dimensions
  const allRowIndices = range(numRows)
  const columnHeaderIndices = allRowIndices.slice(0, numHeaderRows)
  const dataRowIndices = allRowIndices.slice(numHeaderRows)

  return (
    <StyledTableContainer className="stTable" data-testid="stTable">
      {cssStyles && <style>{cssStyles}</style>}
      {/* Add an extra wrapper with the border. This makes sure the border shows around
      the entire table when scrolling horizontally. See also `styled-components.ts`. */}
      <StyledTableBorder>
        <StyledTable id={cssId} data-testid="stTableStyledTable">
          {columnHeaderIndices.length > 0 && (
            <thead>
              {columnHeaderIndices.map(rowIndex =>
                generateTableRow(table, rowIndex, numColumns)
              )}
            </thead>
          )}
          <tbody>
            {dataRowIndices.length === 0 ? (
              <tr>
                <StyledEmptyTableCell
                  data-testid="stTableStyledEmptyTableCell"
                  colSpan={numColumns || 1}
                >
                  empty
                </StyledEmptyTableCell>
              </tr>
            ) : (
              dataRowIndices.map(rowIndex =>
                generateTableRow(table, rowIndex, numColumns)
              )
            )}
          </tbody>
        </StyledTable>
      </StyledTableBorder>
      {/* One negative side effect of having the border on a wrapper is that we need
      to put the caption outside of <table>, so it shows up outside of the border. This
      is not great for accessibility. But I think it's fine because adding captions
      isn't a native feature (you can only do it via Pandas Styler's `set_caption`
      function) and I couldn't find a single example on GitHub that actually does this
      for `st.table`. We might want to revisit this if we add captions/labels as a
      native feature or do a pass on accessibility. */}
      {caption && <caption>{caption}</caption>}
    </StyledTableContainer>
  )
}

function generateTableRow(
  table: Quiver,
  rowIndex: number,
  columns: number
): ReactElement {
  return (
    <tr key={rowIndex}>
      {range(columns).map(columnIndex =>
        generateTableCell(table, rowIndex, columnIndex)
      )}
    </tr>
  )
}

function generateTableCell(
  table: Quiver,
  rowIndex: number,
  columnIndex: number
): ReactElement {
  const {
    type,
    cssId,
    cssClass,
    content,
    contentType,
    displayContent,
    field,
  } = table.getCell(rowIndex, columnIndex)

  const formattedContent =
    displayContent || formatArrowCell(content, contentType, field)

  const style: React.CSSProperties = {
    textAlign: isNumericType(contentType) ? "right" : "left",
  }

  switch (type) {
    case "blank": {
      return (
        <StyledTableCellHeader key={columnIndex} className={cssClass}>
          &nbsp;
        </StyledTableCellHeader>
      )
    }
    case "index": {
      return (
        <StyledTableCellHeader
          key={columnIndex}
          scope="row"
          id={cssId}
          className={cssClass}
        >
          {formattedContent}
        </StyledTableCellHeader>
      )
    }
    case "columns": {
      return (
        <StyledTableCellHeader
          key={columnIndex}
          scope="col"
          className={cssClass}
          style={style}
        >
          {formattedContent}
        </StyledTableCellHeader>
      )
    }
    case "data": {
      return (
        <StyledTableCell key={columnIndex} id={cssId} style={style}>
          {formattedContent}
        </StyledTableCell>
      )
    }
    default: {
      throw new Error(`Cannot parse type "${type}".`)
    }
  }
}

export default ArrowTable


================================================
File: /frontend/lib/src/components/elements/ArrowTable/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./ArrowTable"


================================================
File: /frontend/lib/src/components/elements/ArrowTable/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled, { CSSObject } from "@emotion/styled"

import { EmotionTheme } from "@streamlit/lib/src/theme"

export const StyledTableContainer = styled.div(({ theme }) => ({
  fontSize: theme.fontSizes.md,
  fontFamily: theme.genericFonts.bodyFont,
  lineHeight: theme.lineHeights.small,

  captionSide: "bottom",
  "& caption": {
    fontFamily: theme.genericFonts.bodyFont,
    fontSize: theme.fontSizes.sm,
    paddingTop: theme.spacing.sm,
    paddingBottom: 0,
    color: theme.colors.fadedText60,
    textAlign: "left",
    wordWrap: "break-word",
    display: "inline-block",
  },
}))

export const StyledTableBorder = styled.div(({ theme }) => ({
  // Add the enclosing border on an extra wrapper around the table. This ensures that
  // when the table scrolls horizontally on small windows, it still shows a border all
  // around the table and the table doesn't look cut off.
  border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColorLight}`,
  borderRadius: theme.radii.default,
  overflow: ["auto", "overlay"],
}))

export const StyledTable = styled.table(({ theme }) => ({
  width: theme.sizes.full,
  color: theme.colors.bodyText,

  borderSpacing: 0,
}))

const styleCellFunction = (theme: EmotionTheme): CSSObject => ({
  // Only have borders on the bottom and right of each cell. And remove the borders
  // of the last row and column to prevent double borders together with the enclosing
  // border from `StyledTableBorder`.
  borderBottom: `${theme.sizes.borderWidth} solid ${theme.colors.borderColorLight}`,
  "tbody tr:last-child &": {
    borderBottom: "none",
  },
  borderRight: `${theme.sizes.borderWidth} solid ${theme.colors.borderColorLight}`,
  "&:last-child": {
    borderRight: "none",
  },
  verticalAlign: "middle",
  padding: `${theme.spacing.twoXS} ${theme.spacing.xs}`,
  fontWeight: theme.fontWeights.normal,
})

export const StyledTableCell = styled.td(({ theme }) =>
  styleCellFunction(theme)
)
export const StyledTableCellHeader = styled.th(({ theme }) => ({
  ...styleCellFunction(theme),
  textAlign: "inherit",
  color: theme.colors.fadedText60,
}))

export const StyledEmptyTableCell = styled(StyledTableCell)(({ theme }) => ({
  color: theme.colors.darkGray,
  fontStyle: "italic",
  fontSize: theme.fontSizes.md,
  textAlign: "center",
}))


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/ArrowVegaLiteChart.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"

import ArrowVegaLiteChart, { Props } from "./ArrowVegaLiteChart"
import { VegaLiteChartElement } from "./arrowUtils"

const getProps = (
  elementProps: Partial<VegaLiteChartElement> = {},
  props: Partial<Props> = {}
): Props => ({
  element: {
    data: null,
    id: "1",
    useContainerWidth: false,
    datasets: [],
    selectionMode: [],
    formId: "",
    spec: JSON.stringify({
      data: {
        values: [
          { category: "A", group: "x", value: 0.1 },
          { category: "A", group: "y", value: 0.6 },
          { category: "A", group: "z", value: 0.9 },
          { category: "B", group: "x", value: 0.7 },
          { category: "B", group: "y", value: 0.2 },
          { category: "B", group: "z", value: 1.1 },
          { category: "C", group: "x", value: 0.6 },
          { category: "C", group: "y", value: 0.1 },
          { category: "C", group: "z", value: 0.2 },
        ],
      },
      mark: "bar",
      encoding: {
        x: { field: "category" },
        y: { field: "value", type: "quantitative" },
      },
    }),
    vegaLiteTheme: "streamlit",
    ...elementProps,
  },
  width: 0,
  widgetMgr: new WidgetStateManager({
    sendRerunBackMsg: vi.fn(),
    formsDataChanged: vi.fn(),
  }),
  ...props,
})

describe("ArrowVegaLiteChart", () => {
  it("renders without crashing", () => {
    render(<ArrowVegaLiteChart {...getProps()} />)
    const vegaLiteChart = screen.getByTestId("stVegaLiteChart")
    expect(vegaLiteChart).toBeInTheDocument()
    expect(vegaLiteChart).toHaveClass("stVegaLiteChart")
  })
})


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/ArrowVegaLiteChart.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, useEffect, useRef } from "react"

import { Global } from "@emotion/react"

import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import Toolbar, {
  StyledToolbarElementContainer,
} from "@streamlit/lib/src/components/shared/Toolbar"
import { ElementFullscreenContext } from "@streamlit/lib/src/components/shared/ElementFullscreen/ElementFullscreenContext"
import { useRequiredContext } from "@streamlit/lib/src/hooks/useRequiredContext"
import { withFullScreenWrapper } from "@streamlit/lib/src/components/shared/FullScreenWrapper"

import { VegaLiteChartElement } from "./arrowUtils"
import {
  StyledVegaLiteChartContainer,
  StyledVegaLiteChartTooltips,
} from "./styled-components"
import { useVegaElementPreprocessor } from "./useVegaElementPreprocessor"
import { useVegaEmbed } from "./useVegaEmbed"

export interface Props {
  element: VegaLiteChartElement
  width: number
  widgetMgr: WidgetStateManager
  fragmentId?: string
  disableFullscreenMode?: boolean
}

const ArrowVegaLiteChart: FC<Props> = ({
  disableFullscreenMode,
  element: inputElement,
  fragmentId,
  widgetMgr,
}) => {
  const {
    expanded: isFullScreen,
    width,
    height,
    expand,
    collapse,
  } = useRequiredContext(ElementFullscreenContext)
  const containerRef = useRef<HTMLDivElement | null>(null)

  // We preprocess the input vega element to do a two things:
  // 1. Update the spec to handle Streamlit specific configurations such as
  //    theming, container width, and full screen mode
  // 2. Stabilize some aspects of the input element to detect changes in the
  //    configuration of the chart since each element will always provide new references
  //    Note: We do not stabilize data/datasets as that is managed by the embed.
  const element = useVegaElementPreprocessor(inputElement)

  // This hook provides lifecycle functions for creating and removing the view.
  // It also will update the view if the data changes (and not the spec)
  const { createView, updateView, finalizeView } = useVegaEmbed(
    element,
    widgetMgr,
    fragmentId
  )

  const { data, datasets, spec } = element

  // Create the view once the container is ready and re-create
  // if the spec changes or the dimensions change.
  useEffect(() => {
    if (containerRef.current !== null) {
      createView(containerRef, spec)
    }

    return finalizeView
  }, [createView, finalizeView, spec, width, height])

  // The references to data and datasets will always change each rerun
  // because the forward message always produces new references, so
  // this function will run regularly to update the view.
  useEffect(() => {
    updateView(data, datasets)
  }, [data, datasets, updateView])

  // Create the container inside which Vega draws its content.
  // To style the Vega tooltip, we need to apply global styles since
  // the tooltip element is drawn outside of this component.
  return (
    <StyledToolbarElementContainer
      width={width}
      height={height}
      useContainerWidth={element.useContainerWidth}
    >
      <Toolbar
        target={StyledToolbarElementContainer}
        isFullScreen={isFullScreen}
        onExpand={expand}
        onCollapse={collapse}
        disableFullscreenMode={disableFullscreenMode}
      ></Toolbar>
      <Global styles={StyledVegaLiteChartTooltips} />
      <StyledVegaLiteChartContainer
        data-testid="stVegaLiteChart"
        className="stVegaLiteChart"
        useContainerWidth={element.useContainerWidth}
        isFullScreen={isFullScreen}
        ref={containerRef}
      />
    </StyledToolbarElementContainer>
  )
}

export default withFullScreenWrapper(ArrowVegaLiteChart)


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/CustomTheme.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import merge from "lodash/merge"
import mergeWith from "lodash/mergeWith"

import {
  convertRemToPx,
  EmotionTheme,
  getBlue80,
  getCategoricalColorsArray,
  getDivergingColorsArray,
  getGray30,
  getGray70,
  getSequentialColorsArray,
} from "@streamlit/lib/src/theme"

export function applyStreamlitTheme(config: any, theme: EmotionTheme): any {
  // This theming config contains multiple hard coded spacing values.
  // The reason is that we currently only have rem values in our spacing
  // definitions and vega lite requires numerical (pixel) values.

  const streamlitTheme = {
    font: theme.genericFonts.bodyFont,
    background: theme.colors.bgColor,
    fieldTitle: "verbal",
    autosize: { type: "fit", contains: "padding" },
    title: {
      align: "left",
      anchor: "start",
      color: theme.colors.headingColor,
      titleFontStyle: "normal",
      fontWeight: theme.fontWeights.bold,
      fontSize: theme.fontSizes.mdPx,
      orient: "top",
      offset: 26,
    },
    header: {
      titleFontWeight: theme.fontWeights.normal,
      titleFontSize: theme.fontSizes.mdPx,
      titleColor: getGray70(theme),
      titleFontStyle: "normal",
      labelFontSize: theme.fontSizes.twoSmPx,
      labelFontWeight: theme.fontWeights.normal,
      labelColor: getGray70(theme),
      labelFontStyle: "normal",
    },
    axis: {
      labelFontSize: theme.fontSizes.twoSmPx,
      labelFontWeight: theme.fontWeights.normal,
      labelColor: getGray70(theme),
      labelFontStyle: "normal",
      titleFontWeight: theme.fontWeights.normal,
      titleFontSize: theme.fontSizes.smPx,
      titleColor: getGray70(theme),
      titleFontStyle: "normal",
      ticks: false,
      gridColor: getGray30(theme),
      domain: false,
      domainWidth: 1,
      domainColor: getGray30(theme),
      labelFlush: true,
      labelFlushOffset: 1,
      labelBound: false,
      labelLimit: 100,
      titlePadding: convertRemToPx(theme.spacing.lg),
      labelPadding: convertRemToPx(theme.spacing.lg),
      labelSeparation: convertRemToPx(theme.spacing.twoXS),
      labelOverlap: true,
    },
    legend: {
      labelFontSize: theme.fontSizes.smPx,
      labelFontWeight: theme.fontWeights.normal,
      labelColor: getGray70(theme),
      titleFontSize: theme.fontSizes.smPx,
      titleFontWeight: theme.fontWeights.normal,
      titleFontStyle: "normal",
      titleColor: getGray70(theme),
      titlePadding: 5,
      labelPadding: convertRemToPx(theme.spacing.lg),
      columnPadding: convertRemToPx(theme.spacing.sm),
      rowPadding: convertRemToPx(theme.spacing.twoXS),
      // eslint-disable-next-line streamlit-custom/no-hardcoded-theme-values
      padding: 7,
      symbolStrokeWidth: 4,
    },
    range: {
      category: getCategoricalColorsArray(theme),
      diverging: getDivergingColorsArray(theme),
      ramp: getSequentialColorsArray(theme),
      heatmap: getSequentialColorsArray(theme),
    },
    view: {
      columns: 1,
      strokeWidth: 0,
      stroke: "transparent",
      continuousHeight: 350,
      continuousWidth: 400,
    },
    concat: {
      columns: 1,
    },
    facet: {
      columns: 1,
    },
    mark: {
      tooltip: true,
      color: getBlue80(theme),
    },
    bar: {
      binSpacing: convertRemToPx(theme.spacing.twoXS),
      discreteBandSize: { band: 0.85 },
    },
    axisDiscrete: {
      grid: false,
    },
    axisXPoint: {
      grid: false,
    },
    axisTemporal: {
      grid: false,
    },
    axisXBand: {
      grid: false,
    },
  }

  if (!config) {
    return streamlitTheme
  }

  // Fill in theme defaults where the user didn't specify config options.
  return mergeWith({}, streamlitTheme, config, (_, b) =>
    Array.isArray(b) ? b : undefined
  )
}

export function applyThemeDefaults(config: any, theme: EmotionTheme): any {
  const { colors, fontSizes, genericFonts } = theme
  const themeFonts = {
    labelFont: genericFonts.bodyFont,
    titleFont: genericFonts.bodyFont,
    labelFontSize: fontSizes.twoSmPx,
    titleFontSize: fontSizes.twoSmPx,
  }
  const themeDefaults = {
    background: colors.bgColor,
    axis: {
      labelColor: colors.bodyText,
      titleColor: colors.bodyText,
      gridColor: getGray30(theme),
      ...themeFonts,
    },
    legend: {
      labelColor: colors.bodyText,
      titleColor: colors.bodyText,
      ...themeFonts,
    },
    title: {
      color: colors.bodyText,
      subtitleColor: colors.bodyText,
      ...themeFonts,
    },
    header: {
      labelColor: colors.bodyText,
      titleColor: colors.bodyText,
      ...themeFonts,
    },
    view: {
      stroke: getGray30(theme),
      continuousHeight: 350,
      continuousWidth: 400,
    },
    mark: {
      tooltip: true,
    },
  }

  if (!config) {
    return themeDefaults
  }

  // Fill in theme defaults where the user didn't specify config options.
  return merge({}, themeDefaults, config)
}


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/arrowUtils.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  CATEGORICAL,
  DATE,
  DATETIME,
  DATETIMETZ,
  FLOAT64,
  INT64,
  RANGE,
  UINT64,
  UNICODE,
} from "@streamlit/lib/src/mocks/arrow"
import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"

import { getDataArray } from "./arrowUtils"

describe("Types of dataframe indexes as x axis", () => {
  describe("Supported", () => {
    test("datetimetz", () => {
      const mockElement = { data: DATETIMETZ }
      const q = new Quiver(mockElement)

      expect(getDataArray(q)).toEqual([
        {
          "(index)": 978220800000,
          "2000-12-31 00:00:00": new Date(
            "2020-01-02T05:00:00.000Z"
          ).valueOf(),
          "2001-12-31 00:00:00": new Date(
            "2020-10-20T05:00:00.000Z"
          ).valueOf(),
        },
        {
          "(index)": 1009756800000,
          "2000-12-31 00:00:00": new Date(
            "2020-01-02T05:00:00.000Z"
          ).valueOf(),
          "2001-12-31 00:00:00": new Date(
            "2020-10-20T05:00:00.000Z"
          ).valueOf(),
        },
      ])
    })

    test("date", () => {
      const mockElement = { data: DATE }
      const q = new Quiver(mockElement)

      expect(getDataArray(q)).toEqual([
        {
          "(index)": 978220800000,
          "2000-12-31 00:00:00": new Date("2020-01-02T00:00:00").valueOf(),
          "2001-12-31 00:00:00": new Date("2020-10-20T00:00:00").valueOf(),
        },
        {
          "(index)": 1009756800000,
          "2000-12-31 00:00:00": new Date("2020-01-02T00:00:00").valueOf(),
          "2001-12-31 00:00:00": new Date("2020-10-20T00:00:00").valueOf(),
        },
      ])
    })

    test("datetime", () => {
      const mockElement = { data: DATETIME }
      const q = new Quiver(mockElement)

      expect(getDataArray(q)).toEqual([
        {
          "(index)": 978220800000,
          "2000-12-31 00:00:00": new Date("2020-01-02T05:00:00").valueOf(),
          "2001-12-31 00:00:00": new Date("2020-10-20T05:00:00").valueOf(),
        },
        {
          "(index)": 1009756800000,
          "2000-12-31 00:00:00": new Date("2020-01-02T05:00:00").valueOf(),
          "2001-12-31 00:00:00": new Date("2020-10-20T05:00:00").valueOf(),
        },
      ])
    })

    test("float64", () => {
      const mockElement = { data: FLOAT64 }
      const q = new Quiver(mockElement)

      expect(getDataArray(q)).toEqual([
        { "(index)": 1.24, "1.24": 1.2, "2.35": 1.3 },
        { "(index)": 2.35, "1.24": 1.4, "2.35": 1.5 },
      ])
    })

    test("int64", () => {
      const mockElement = { data: INT64 }
      const q = new Quiver(mockElement)
      expect(getDataArray(q)).toEqual([
        {
          "(index)": 1,
          "1": 0,
          "2": 1,
        },
        {
          "(index)": 2,
          "1": 2,
          "2": 3,
        },
      ])
    })

    test("range", () => {
      const mockElement = { data: RANGE }
      const q = new Quiver(mockElement)

      expect(getDataArray(q)).toEqual([
        { "(index)": 0, "0": "foo", "1": "1" },
        { "(index)": 1, "0": "bar", "1": "2" },
      ])
    })

    test("uint64", () => {
      const mockElement = { data: UINT64 }
      const q = new Quiver(mockElement)
      expect(getDataArray(q)).toEqual([
        {
          "(index)": 1,
          "1": 1,
          "2": 2,
        },
        {
          "(index)": 2,
          "1": 3,
          "2": 4,
        },
      ])
    })
  })

  describe("Unsupported", () => {
    test("categorical", () => {
      const mockElement = { data: CATEGORICAL }
      const q = new Quiver(mockElement)
      expect(getDataArray(q)).toEqual([
        { c1: "foo", c2: 100 },
        { c1: "bar", c2: 200 },
      ])
    })

    test("unicode", () => {
      const mockElement = { data: UNICODE }
      const q = new Quiver(mockElement)

      expect(getDataArray(q)).toEqual([
        { c1: "foo", c2: "1" },
        { c1: "bar", c2: "2" },
      ])
    })
  })
})


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/arrowUtils.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  getTimezone,
  isDatetimeType,
  isDateType,
  isNumericType,
} from "@streamlit/lib/src/dataframes/arrowTypeUtils"
import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import { isNullOrUndefined } from "@streamlit/lib/src/util/utils"

const MagicFields = {
  DATAFRAME_INDEX: "(index)",
}

/** All of the data that makes up a VegaLite chart. */
export interface VegaLiteChartElement {
  /**
   * The dataframe that will be used as the chart's main data source, if
   * specified using Vega-Lite's inline API.
   *
   * This is mutually exclusive with WrappedNamedDataset - if `data` is non-null,
   * `datasets` will not be populated; if `datasets` is populated, then `data`
   * will be null.
   */
  data: Quiver | null

  /** The a JSON-formatted string with the Vega-Lite spec. */
  spec: string

  /**
   * Dataframes associated with this chart using Vega-Lite's datasets API,
   * if any.
   */
  datasets: WrappedNamedDataset[]

  /** If True, will overwrite the chart width spec to fit to container. */
  useContainerWidth: boolean

  /** override the properties with a theme. Currently, only "streamlit" or None are accepted. */
  vegaLiteTheme: string

  /** The widget ID. Only set if selections are activated. */
  id: string

  /** Named selection parameters that are activated to trigger reruns. */
  selectionMode: string[]

  /** The form ID if the chart has activated selections and is used within a form. */
  formId: string
}

/** A mapping of `ArrowNamedDataSet.proto`. */
export interface WrappedNamedDataset {
  /** The dataset's optional name. */
  name: string | null

  /** True if the name field (above) was manually set. */
  hasName: boolean

  /** The data itself, wrapped in a Quiver object. */
  data: Quiver
}

export function getInlineData(
  quiverData: Quiver | null
): { [field: string]: any }[] | null {
  if (!quiverData || quiverData.dimensions.numDataRows === 0) {
    return null
  }

  return getDataArray(quiverData)
}

export function getDataArrays(
  datasets: WrappedNamedDataset[]
): { [dataset: string]: any[] } | null {
  const datasetMapping = getDataSets(datasets)
  if (isNullOrUndefined(datasetMapping)) {
    return null
  }

  const datasetArrays: { [dataset: string]: any[] } = {}

  for (const [name, dataset] of Object.entries(datasetMapping)) {
    datasetArrays[name] = getDataArray(dataset)
  }

  return datasetArrays
}

export function getDataSets(
  datasets: WrappedNamedDataset[]
): { [dataset: string]: Quiver } | null {
  if (datasets?.length === 0) {
    return null
  }

  const datasetMapping: { [dataset: string]: Quiver } = {}

  datasets.forEach((x: WrappedNamedDataset) => {
    if (!x) {
      return
    }
    const name = x.hasName ? x.name : null
    datasetMapping[name as string] = x.data
  })

  return datasetMapping
}

/**
 * Retrieves an array of data from Quiver starting from a specified index.
 * Converts data values to a format compatible with VegaLite visualization.
 *
 * @param {Quiver} quiverData - The Quiver data object to extract data from.
 * @param {number} [startIndex=0] - The starting index for data extraction.
 * @returns {Array.<{ [field: string]: any }>} An array of data objects for visualization.
 */
export function getDataArray(
  quiverData: Quiver,
  startIndex = 0
): { [field: string]: any }[] {
  if (quiverData.dimensions.numDataRows === 0) {
    return []
  }

  const dataArr = []
  const { numDataRows, numDataColumns } = quiverData.dimensions

  // This currently only works with a single index column.
  // Supporting multiple index columns would require some
  // changes to this logic:
  const firstIndexColumnType = quiverData.columnTypes.index[0] ?? undefined
  const hasSupportedIndex =
    firstIndexColumnType &&
    (isNumericType(firstIndexColumnType) ||
      isDatetimeType(firstIndexColumnType) ||
      isDateType(firstIndexColumnType))

  for (let rowIndex = startIndex; rowIndex < numDataRows; rowIndex++) {
    const row: { [field: string]: any } = {}

    if (hasSupportedIndex) {
      const indexValue = quiverData.getIndexValue(rowIndex, 0)
      // VegaLite can't handle BigInts, so they have to be converted to Numbers first
      // Converting to numbers here might loses accuracy for numbers larger than the max safe integer.
      row[MagicFields.DATAFRAME_INDEX] =
        typeof indexValue === "bigint" ? Number(indexValue) : indexValue
    }

    for (let colIndex = 0; colIndex < numDataColumns; colIndex++) {
      const dataValue = quiverData.getDataValue(rowIndex, colIndex)
      const dataType = quiverData.columnTypes.data[colIndex]

      if (
        (dataValue instanceof Date || Number.isFinite(dataValue)) &&
        (isDatetimeType(dataType) || isDateType(dataType)) &&
        // Only convert dates without timezone information
        // to utc timezone
        !getTimezone(dataType)
      ) {
        // For dates that do not contain timezone information.
        // Vega JS assumes dates in the local timezone, so we need to convert
        // UTC date to be the same date in the local timezone.
        const offset = new Date(dataValue).getTimezoneOffset() * 60 * 1000 // minutes to milliseconds
        row[quiverData.columnNames[0][colIndex]] = dataValue.valueOf() + offset
      } else {
        // VegaLite can't handle BigInts, so they have to be converted to Numbers first.
        // Converting to numbers here might loses accuracy for numbers larger than the max safe integer.
        row[quiverData.columnNames[0][colIndex]] =
          typeof dataValue === "bigint" ? Number(dataValue) : dataValue
      }
    }
    dataArr.push(row)
  }

  return dataArr
}


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export type { VegaLiteChartElement, WrappedNamedDataset } from "./arrowUtils"

export { default } from "./ArrowVegaLiteChart"


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { CSSObject } from "@emotion/react"
import styled from "@emotion/styled"
import { transparentize } from "color2k"

import { EmotionTheme } from "@streamlit/lib/src/theme"

export const StyledVegaLiteChartTooltips = (
  theme: EmotionTheme
): CSSObject => ({
  "#vg-tooltip-element": {
    visibility: "hidden",
    position: "fixed",
    fontFamily: theme.genericFonts.bodyFont,
    color: theme.colors.bodyText,
    border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
    backgroundColor: transparentize(theme.colors.bgColor, 0.05),
    fontSize: theme.fontSizes.twoSm,
    boxShadow: "rgb(0 0 0 / 16%) 0px 1px 4px",
    maxWidth: theme.sizes.maxChartTooltipWidth,
    padding: `${theme.spacing.xs} ${theme.spacing.md}`,
    borderRadius: theme.radii.default,
    zIndex: theme.zIndices.vegaTooltips,

    "&.visible": {
      visibility: "visible",
    },

    h2: {
      marginTop: theme.spacing.none,
      marginBottom: theme.spacing.sm,
      fontSize: theme.fontSizes.sm,
    },

    td: {
      border: "none",
    },

    table: {
      borderSpacing: 0,

      tr: {
        border: "none",

        td: {
          overflow: "hidden",
          textOverflow: "ellipsis",
          paddingTop: theme.spacing.threeXS,
          paddingBottom: theme.spacing.threeXS,
        },

        "td.key": {
          // This should use a max of 40% of the available width (- padding):
          maxWidth: `calc((${theme.sizes.maxChartTooltipWidth} - 2 * ${theme.spacing.md}) * 0.4)`,
          textAlign: "right",
          color: theme.colors.fadedText60,
          whiteSpace: "nowrap",
          paddingRight: theme.spacing.twoXS,
        },

        "td.value": {
          // This should use a max of 60% of the available width (- padding):
          maxWidth: `calc((${theme.sizes.maxChartTooltipWidth} - 2 * ${theme.spacing.md}) * 0.6)`,
          textAlign: "left",
          // We are limiting the height of the value to a max of 5 lines via
          // the a webkit property that is supported by all major browsers:
          // https://caniuse.com/?search=-webkit-line-clamp
          display: "-webkit-box",
          WebkitLineClamp: "5",
          WebkitBoxOrient: "vertical",
          lineClamp: "5",
          wordWrap: "break-word",
        },
      },
    },
  },
})

interface StyledVegaLiteChartContainerProps {
  useContainerWidth: boolean
  isFullScreen: boolean
}

export const StyledVegaLiteChartContainer =
  styled.div<StyledVegaLiteChartContainerProps>(
    ({ theme, useContainerWidth, isFullScreen }) => ({
      width: useContainerWidth || isFullScreen ? "100%" : "auto",
      height: isFullScreen ? "100%" : "auto",
      // These styles come from VegaLite Library
      "&.vega-embed": {
        position: "relative",
        display: "inline-block",
        boxSizing: "border-box",

        "details:not([open]) > :not(summary)": {
          display: "none !important",
        },
        "details[open] summary": {
          opacity: 0.7,
        },
        "&:hover summary, .vega-embed:focus summary": {
          background: "transparent",
        },
        "&:hover summary, &:focus-within summary": {
          opacity: "1 !important",
          transition: "opacity 0.2s ease",
        },
        "&.has-actions": {
          paddingRight: 0,
        },
        ".vega-actions": {
          position: "absolute",
          display: "flex",
          flexDirection: "column",
          paddingBottom: theme.spacing.sm,
          paddingTop: theme.spacing.sm,
          zIndex: theme.zIndices.popupMenu,
          // Position under the menu button. The size of the menu button
          // iconSizes.md + padding (2 * spacing.xs)
          //+ some additional spacing (spacing.xs)
          top: `calc(${theme.iconSizes.md} + 2 * ${theme.spacing.xs} + ${theme.spacing.xs})`,
          right: 0,
          // Customize menu UI to look like the Streamlit menu:
          backgroundColor: theme.colors.bgColor,
          boxShadow: "rgb(0 0 0 / 16%) 0px 4px 16px",
          border: `${theme.sizes.borderWidth} solid ${theme.colors.fadedText10}`,
          animationDuration: "0.15s",
          animationName: "scale-in",
          animationTimingFunction: "cubic-bezier(0.2, 0, 0.13, 1.5)",
          textAlign: "left",
          borderRadius: theme.radii.default,
          a: {
            fontFamily: theme.genericFonts.bodyFont,
            fontWeight: theme.fontWeights.normal,
            fontSize: theme.fontSizes.md,
            margin: 0,
            padding: `${theme.spacing.twoXS} ${theme.spacing.twoXL}`,
            color: theme.colors.bodyText,
            whiteSpace: "nowrap",
            textDecoration: "none",
          },
          "a:hover, a:focus": {
            backgroundColor: theme.colors.secondaryBg,
            color: theme.colors.bodyText,
          },
          ":before": {
            content: "none",
          },
          ":after": {
            content: "none",
          },
        },
        "@keyframes scale-in": {
          from: {
            opacity: 0,
            transform: "scale(0.6)",
          },
          to: {
            opacity: 1,
            transform: "scale(1)",
          },
        },
        ".chart-wrapper": {
          "&.fit-x": {
            width: "100%",
          },
          "&.fit-y": {
            height: "100%",
          },
        },
        summary: {
          position: "absolute",
          top: 0,
          right: 0,
          opacity: 0,
          listStyle: "none",
          cursor: "pointer",
          display: "list-item",
          padding: theme.spacing.xs,
          // Fix weird floating button height issue in Vega Lite.
          height: "auto",
          // Fix floating button appearing above pop-ups.
          zIndex: theme.zIndices.menuButton,
          border: "none",
          boxShadow: "none",
          borderRadius: theme.radii.default,
          color: theme.colors.fadedText10,
          backgroundColor: "transparent",
          transition: "opacity 300ms 150ms,transform 300ms 150ms",
          lineHeight: 0,
          "&::-webkit-details-marker": {
            display: "none",
          },
          "&:active, &:focus-visible, &:hover": {
            border: "none",
            boxShadow: "none",
            color: theme.colors.bodyText,
            opacity: "1 !important",
            background: theme.colors.darkenedBgMix25,
          },
          svg: {
            width: theme.iconSizes.md,
            height: theme.iconSizes.md,
          },
        },
      },
    })
  )


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/useVegaElementPreprocessor.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { renderHook } from "@streamlit/lib/src/components/shared/ElementFullscreen/testUtils"

import { useVegaElementPreprocessor } from "./useVegaElementPreprocessor"
import { VegaLiteChartElement } from "./arrowUtils"

const getElement = (
  elementProps: Partial<VegaLiteChartElement> = {}
): VegaLiteChartElement => ({
  data: null,
  id: "1",
  useContainerWidth: false,
  datasets: [],
  selectionMode: [],
  formId: "",
  spec: JSON.stringify({
    data: {
      values: [
        { category: "A", group: "x", value: 0.1 },
        { category: "A", group: "y", value: 0.6 },
        { category: "A", group: "z", value: 0.9 },
        { category: "B", group: "x", value: 0.7 },
        { category: "B", group: "y", value: 0.2 },
        { category: "B", group: "z", value: 1.1 },
        { category: "C", group: "x", value: 0.6 },
        { category: "C", group: "y", value: 0.1 },
        { category: "C", group: "z", value: 0.2 },
      ],
    },
    mark: "bar",
    encoding: {
      x: { field: "category" },
      y: { field: "value", type: "quantitative" },
    },
  }),
  vegaLiteTheme: "streamlit",
  ...elementProps,
})

describe("useVegaElementPreprocessor", () => {
  it("renders the same selectionMode even if reference changes", () => {
    const { result, rerender } = renderHook(
      (element: VegaLiteChartElement) => useVegaElementPreprocessor(element),
      {
        initialProps: getElement({
          selectionMode: ["single"],
        }),
      }
    )

    const { selectionMode } = result.current

    rerender(
      getElement({
        selectionMode: ["single"],
      })
    )

    expect(result.current.selectionMode).toBe(selectionMode)
  })

  it("renders the same spec even if reference changes", () => {
    const { result, rerender } = renderHook(
      (element: VegaLiteChartElement) => useVegaElementPreprocessor(element),
      {
        initialProps: getElement(),
      }
    )

    const { spec } = result.current

    rerender(getElement())

    expect(result.current.spec).toBe(spec)
  })

  it("updates the spec if factors cause it to change (like sizing, theme, selection mode, and spec)", () => {
    const { result, rerender } = renderHook(
      (element: VegaLiteChartElement) => useVegaElementPreprocessor(element),
      {
        initialProps: getElement(),
      }
    )

    let { spec } = result.current
    const changes: Partial<VegaLiteChartElement>[] = [
      { useContainerWidth: true },
      { vegaLiteTheme: undefined },
      { selectionMode: ["single"] },
      { spec: "{}" },
    ]

    for (const change of changes) {
      rerender(getElement(change))

      expect(result.current.spec).not.toBe(spec)

      // Save the last spec to compare with the next one
      spec = result.current.spec
    }
  })
})


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/useVegaElementPreprocessor.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { useMemo } from "react"

import { useTheme } from "@emotion/react"

import { ElementFullscreenContext } from "@streamlit/lib/src/components/shared/ElementFullscreen/ElementFullscreenContext"
import { EmotionTheme } from "@streamlit/lib/src/theme"
import { isNullOrUndefined } from "@streamlit/lib/src/util/utils"
import { useRequiredContext } from "@streamlit/lib/src/hooks/useRequiredContext"

import { applyStreamlitTheme, applyThemeDefaults } from "./CustomTheme"
import { VegaLiteChartElement } from "./arrowUtils"

/**
 * Fix bug where Vega Lite was vertically-cropping the x-axis in some cases.
 */
const BOTTOM_PADDING = 20

/**
 * Prepares the vega-lite spec for selections by transforming the select parameters
 * to a full object specification and by automatically adding encodings (if missing)
 * to point selections.
 *
 * The changes are applied in-place to the spec object.
 *
 * @param spec The Vega-Lite specification of the chart.
 */
export function prepareSpecForSelections(spec: any): void {
  if ("params" in spec && "encoding" in spec) {
    spec.params.forEach((param: any) => {
      if (!("select" in param)) {
        // We are only interested in transforming select parameters.
        // Other parameters are skipped.
        return
      }

      if (["interval", "point"].includes(param.select)) {
        // The select object can be either a single string (short-hand) specifying
        // "interval" or "point" or an object that can contain additional
        // properties as defined here: https://vega.github.io/vega-lite/docs/selection.html
        // We convert the short-hand notation to the full object specification,
        // so that we can attach additional properties to this below.
        param.select = {
          type: param.select,
        }
      }

      if (!("type" in param.select)) {
        // The type property is required in the spec.
        // But we check anyways and skip all parameters that don't have it.
        return
      }

      if (
        param.select.type === "point" &&
        !("encodings" in param.select) &&
        isNullOrUndefined(param.select.encodings)
      ) {
        // If encodings are not specified by the user, we add all the encodings from
        // the chart to the selection parameter. This is required so that points
        // selections are correctly resolved to a PointSelection and not an IndexSelection:
        // https://github.com/altair-viz/altair/issues/3285#issuecomment-1858860696
        param.select.encodings = Object.keys(spec.encoding)
      }
    })
  }
}

const generateSpec = (
  inputSpec: string,
  useContainerWidth: boolean,
  vegaLiteTheme: string,
  selectionMode: string[],
  theme: EmotionTheme,
  isFullScreen: boolean,
  width: number,
  height?: number
): any => {
  const spec = JSON.parse(inputSpec)
  if (vegaLiteTheme === "streamlit") {
    spec.config = applyStreamlitTheme(spec.config, theme)
  } else if (spec.usermeta?.embedOptions?.theme === "streamlit") {
    spec.config = applyStreamlitTheme(spec.config, theme)
    // Remove the theme from the usermeta so it doesn't get picked up by vega embed.
    spec.usermeta.embedOptions.theme = undefined
  } else {
    // Apply minor theming improvements to work better with Streamlit
    spec.config = applyThemeDefaults(spec.config, theme)
  }

  if (isFullScreen) {
    spec.width = width
    spec.height = height

    if ("vconcat" in spec) {
      spec.vconcat.forEach((child: any) => {
        child.width = width
      })
    }
  } else if (useContainerWidth) {
    spec.width = width

    if ("vconcat" in spec) {
      spec.vconcat.forEach((child: any) => {
        child.width = width
      })
    }
  }

  if (!spec.padding) {
    spec.padding = {}
  }

  if (isNullOrUndefined(spec.padding.bottom)) {
    spec.padding.bottom = BOTTOM_PADDING
  }

  if (spec.datasets) {
    throw new Error("Datasets should not be passed as part of the spec")
  }

  if (selectionMode.length > 0) {
    prepareSpecForSelections(spec)
  }
  return spec
}

/**
 * Preprocesses the element to generate the VegaLite spec.
 * It stabilizes some of the references (e.g. selectionMode and spec)
 * and avoids further processing if unnecessary.
 */
export const useVegaElementPreprocessor = (
  element: VegaLiteChartElement
): VegaLiteChartElement => {
  const theme = useTheme()
  const {
    expanded: isFullScreen,
    width,
    height,
  } = useRequiredContext(ElementFullscreenContext)

  const {
    id,
    formId,
    spec: inputSpec,
    data,
    datasets,
    useContainerWidth,
    vegaLiteTheme,
    selectionMode: inputSelectionMode,
  } = element

  // Selection Mode is an array, so we want to update it only when the contents
  // change, not the reference itself (since each forward message would be a new
  // reference).
  const selectionMode = useMemo(() => {
    return inputSelectionMode as string[]
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [JSON.stringify(inputSelectionMode)])

  const spec = useMemo(
    () =>
      generateSpec(
        inputSpec,
        useContainerWidth,
        vegaLiteTheme,
        selectionMode,
        theme,
        isFullScreen,
        width,
        height
      ),
    [
      inputSpec,
      useContainerWidth,
      vegaLiteTheme,
      selectionMode,
      theme,
      isFullScreen,
      width,
      height,
    ]
  )

  return {
    id,
    formId,
    vegaLiteTheme,
    spec,
    selectionMode,
    data,
    datasets,
    useContainerWidth,
  }
}


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/useVegaEmbed.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { createRef } from "react"

import { act, renderHook } from "@testing-library/react-hooks"
import { View as VegaView } from "vega"
import embed from "vega-embed"
import { expressionInterpreter } from "vega-interpreter"
import { Mock, Mocked } from "vitest"

import { useFormClearHelper } from "@streamlit/lib/src/components/widgets/Form"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"

import { getDataArrays, getInlineData } from "./arrowUtils"
import { useVegaEmbed } from "./useVegaEmbed"
import { useVegaLiteSelections } from "./useVegaLiteSelections"

// Mock the "vega-embed" library:
vi.mock("vega-embed", () => ({
  __esModule: true,
  default: vi.fn(),
}))

// Mock "useVegaLiteSelections" so we can observe calls:
vi.mock("./useVegaLiteSelections", () => ({
  __esModule: true,
  useVegaLiteSelections: vi.fn(),
}))

// Mock "useFormClearHelper" to ensure it is called:
vi.mock("@streamlit/lib/src/components/widgets/Form", () => ({
  __esModule: true,
  useFormClearHelper: vi.fn(),
}))

// Utility mock for getDataArrays / getInlineData from arrowUtils:
vi.mock("./arrowUtils", async () => {
  // We'll only re-implement the named functions used in code.
  const actual = await vi.importActual<object>("./arrowUtils")
  return {
    __esModule: true,
    ...actual,
    getDataArrays: vi.fn(),
    getInlineData: vi.fn(),
  }
})

// We don't necessarily need to mock all `WidgetStateManager` methods, but let's do so:
const createMockWidgetMgr = (): Mocked<WidgetStateManager> =>
  ({
    getElementState: vi.fn(),
    setElementState: vi.fn(),
    getStringValue: vi.fn(),
    setStringValue: vi.fn(),
  } as unknown as Mocked<WidgetStateManager>)

// ------------------------------------------
// 2. The Tests
// ------------------------------------------

describe("useVegaEmbed hook", () => {
  let mockWidgetMgr: Mocked<WidgetStateManager>
  let mockVegaView: Mocked<VegaView>
  let mockEmbedReturn: {
    vgSpec: any
    view: Mocked<VegaView>
    finalize: () => void
  }

  beforeEach(() => {
    vi.resetAllMocks()

    mockWidgetMgr = createMockWidgetMgr()
    mockVegaView = {
      insert: vi.fn().mockReturnThis(),
      resize: vi.fn().mockReturnThis(),
      runAsync: vi.fn().mockResolvedValue(null),
      setState: vi.fn().mockReturnThis(),
      data: vi.fn().mockReturnThis(),
      remove: vi.fn().mockReturnThis(),
    } as unknown as Mocked<VegaView>

    // vega-embed returns { vgSpec, view, finalize }
    mockEmbedReturn = {
      vgSpec: { data: [{}] },
      view: mockVegaView,
      finalize: vi.fn(),
    }

    // By default, embed(...) resolves to our mockEmbedReturn
    ;(embed as unknown as Mock).mockResolvedValue(mockEmbedReturn)

    // Mock useVegaLiteSelections returns two callbacks:
    ;(useVegaLiteSelections as Mock).mockReturnValue({
      maybeConfigureSelections: vi
        .fn()
        .mockImplementation((view: any) => view),
      onFormCleared: vi.fn(),
    })

    // Default stubs:
    ;(useFormClearHelper as Mock).mockImplementation(() => {})
    ;(getDataArrays as Mock).mockReturnValue({})
    ;(getInlineData as Mock).mockReturnValue(null)
  })

  afterEach(() => {
    vi.clearAllMocks()
  })

  it("creates a new Vega view via embed, finalizes existing view, inserts data, and returns a VegaView", async () => {
    const containerRef = createRef<HTMLDivElement>()
    const chartElement = {
      id: "chartId",
      data: null,
      datasets: [],
    } as any

    // mount hook
    const { result } = renderHook(() =>
      useVegaEmbed(chartElement, mockWidgetMgr)
    )

    // Create a mock div to pass as containerRef
    const div = document.createElement("div")
    // @ts-expect-error We simulate a ref j
    containerRef.current = div

    // Act: call createView
    let returnedView: VegaView | null = null
    await act(async () => {
      returnedView = await result.current.createView(containerRef, {})
    })

    // 1) Existing view is finalized (nothing yet, so finalize no-op):
    expect(mockEmbedReturn.finalize).not.toHaveBeenCalled()

    // 2) embed(...) is called with containerRef.current and spec
    expect(embed).toHaveBeenCalledWith(
      div,
      {},
      {
        ast: true,
        expr: expressionInterpreter,
        tooltip: { disableDefaultStyle: true },
        defaultStyle: false,
        forceActionsMenu: true,
      }
    )

    // 3) the returned vegaView is stored
    expect(returnedView).toBe(mockVegaView)

    // 4) maybeConfigureSelections is called
    const useVegaLiteSelectionsMock = (useVegaLiteSelections as Mock).mock

    const { maybeConfigureSelections } =
      useVegaLiteSelectionsMock.results[0].value
    expect(maybeConfigureSelections).toHaveBeenCalledWith(mockVegaView)

    // 5) Insert data (getInlineData => null, so none inserted)
    expect(mockVegaView.insert).not.toHaveBeenCalled() // if getInlineData was null
    expect(mockVegaView.runAsync).toHaveBeenCalled() // runAsync

    // 6) Resizes the new vega view
    expect(mockVegaView.resize).toHaveBeenCalled()
    expect(mockVegaView.runAsync).toHaveBeenCalled()
  })

  it("finalizes old view if one exists before creating a new one", async () => {
    const containerRef = createRef<HTMLDivElement>()
    const chartElement = {
      id: "chartId",
      data: null,
      datasets: [],
    } as any

    // mount hook
    const { result } = renderHook(() =>
      useVegaEmbed(chartElement, mockWidgetMgr)
    )

    // Suppose we have an existing view in place, so let's do a first call:
    // We ensure finalize is set on the first creation
    {
      const div = document.createElement("div")
      // @ts-expect-error We want the ref to be set correctly
      containerRef.current = div

      await act(async () => {
        await result.current.createView(containerRef, {})
      })
    }
    // Now, embed.finalize hasn't been called yet because we just created it once
    expect(mockEmbedReturn.finalize).not.toHaveBeenCalled()

    // Now we do a second call to createView => it should finalize old view
    const secondDiv = document.createElement("div")
    // @ts-expect-error We want the ref to be set correctly
    containerRef.current = secondDiv

    await act(async () => {
      await result.current.createView(containerRef, {})
    })

    // The old finalize method is now called
    expect(mockEmbedReturn.finalize).toHaveBeenCalledTimes(1)
  })

  it("throws an error if containerRef is missing", async () => {
    const chartElement = {
      id: "chartId",
      data: null,
      datasets: [],
    } as any

    const { result } = renderHook(() =>
      useVegaEmbed(chartElement, mockWidgetMgr)
    )

    await expect(
      result.current.createView({ current: null }, {})
    ).rejects.toThrowError("Element missing.")

    expect(embed).not.toHaveBeenCalled()
  })

  it("finalizeView finalizes and clears references", async () => {
    const chartElement = {
      id: "chartId",
      data: null,
      datasets: [],
    } as any
    const { result } = renderHook(() =>
      useVegaEmbed(chartElement, mockWidgetMgr)
    )

    const containerRef = createRef<HTMLDivElement>()
    // @ts-expect-error We want the ref to be set correctly
    containerRef.current = document.createElement("div")

    // createView => embed => sets vegaFinalizer
    await act(async () => {
      await result.current.createView(containerRef, {})
    })

    // The finalize function is provided by vega-embed
    await act(async () => {
      result.current.finalizeView()
    })
    expect(mockEmbedReturn.finalize).toHaveBeenCalled()

    // The stored references are cleared (not easily tested directly,
    // but if we tried to re-finalize, finalize shouldn't be called again):
    await act(async () => {
      result.current.finalizeView()
    })
    // finalize is not called a second time
    expect(mockEmbedReturn.finalize).toHaveBeenCalledTimes(1)
  })

  it("updateView returns null if no vegaView is present", async () => {
    const chartElement = {
      id: "chartId",
      data: null,
      datasets: [],
    } as any
    const { result } = renderHook(() =>
      useVegaEmbed(chartElement, mockWidgetMgr)
    )

    let updatedView: VegaView | null = null
    await act(async () => {
      updatedView = await result.current.updateView(null, [])
    })
    expect(updatedView).toBeNull()
  })

  it("updateView updates data and datasets, then runs async", async () => {
    const chartElement = {
      id: "chartId",
      data: null,
      datasets: [],
    } as any

    const { result } = renderHook(() =>
      useVegaEmbed(chartElement, mockWidgetMgr)
    )

    const containerRef = createRef<HTMLDivElement>()
    // @ts-expect-error We want the ref to be set correctly
    containerRef.current = document.createElement("div")

    // createView => ensures vegaView isn't null
    await act(async () => {
      await result.current.createView(containerRef, {})
    })

    const quiverData = {
      data: { numRows: 5, numCols: 2 },
      dimensions: { dataRows: 5, dataCols: 2 },
      isEmpty: () => false,
      columnTypes: { index: ["int"], data: ["int"] },
    } as any

    await act(async () => {
      await result.current.updateView(quiverData, [])
    })

    // We can verify that it tried to update data sets in the vegaView
    // Because `updateData` calls `view.data` or `view.insert`
    expect(mockVegaView.insert).toHaveBeenCalledTimes(1)
    // 2 from createView, 1 from updateView -> .resize().runAsync()
    expect(mockVegaView.runAsync).toHaveBeenCalledTimes(3)
  })
})


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/useVegaEmbed.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { RefObject, useCallback, useEffect, useRef } from "react"

import { truthy, View as VegaView } from "vega"
import embed from "vega-embed"
import { expressionInterpreter } from "vega-interpreter"

import { useFormClearHelper } from "@streamlit/lib/src/components/widgets/Form"
import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import { logMessage } from "@streamlit/lib/src/util/log"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"

import {
  getDataArray,
  getDataArrays,
  getDataSets,
  getInlineData,
  VegaLiteChartElement,
  WrappedNamedDataset,
} from "./arrowUtils"
import { useVegaLiteSelections } from "./useVegaLiteSelections"

const DEFAULT_DATA_NAME = "source"

interface UseVegaEmbedOutput {
  createView: (
    containerRef: RefObject<HTMLDivElement>,
    spec: any
  ) => Promise<VegaView | null>
  updateView: (
    data: Quiver | null,
    datasets: WrappedNamedDataset[]
  ) => Promise<VegaView | null>
  finalizeView: () => void
}

/**
 * Hook that returns a set of lifecycle functions that can be used to create,
 * update, and remove a vega-lite chart into the DOM.
 *
 * @param inputElement The vega-lite chart element
 * @param widgetMgr The widget manager
 * @param fragmentId The fragment id of the element
 */
export function useVegaEmbed(
  inputElement: VegaLiteChartElement,
  widgetMgr: WidgetStateManager,
  fragmentId?: string
): UseVegaEmbedOutput {
  const vegaView = useRef<VegaView | null>(null)
  const vegaFinalizer = useRef<(() => void) | null>(null)
  const defaultDataName = useRef<string>(DEFAULT_DATA_NAME)
  const dataRef = useRef<Quiver | null>(null)
  const datasetsRef = useRef<WrappedNamedDataset[]>([])

  // Setup interactivity for the chart if it supports selections
  const { maybeConfigureSelections, onFormCleared } = useVegaLiteSelections(
    inputElement,
    widgetMgr,
    fragmentId
  )

  useFormClearHelper({ widgetMgr, element: inputElement, onFormCleared })

  const { data, datasets } = inputElement

  // Initialize the data and datasets refs with the current data and datasets
  // This is predominantly used to handle the case where we want to reference
  // these in createView before the first render.
  useEffect(() => {
    if (vegaView.current === null) {
      dataRef.current = data
      datasetsRef.current = datasets
    }
  }, [data, datasets])

  const finalizeView = useCallback(() => {
    if (vegaFinalizer.current) {
      vegaFinalizer.current()
    }

    vegaFinalizer.current = null
    vegaView.current = null
  }, [])

  const createView = useCallback(
    async (
      containerRef: RefObject<HTMLDivElement>,
      spec: any
    ): Promise<VegaView | null> => {
      if (containerRef.current === null) {
        throw new Error("Element missing.")
      }

      // Finalize the previous view so it can be garbage collected.
      finalizeView()

      const options = {
        // Adds interpreter support for Vega expressions that is compliant with CSP
        ast: true,
        expr: expressionInterpreter,

        // Disable default styles so that vega doesn't inject <style> tags in the
        // DOM. We set these styles manually for finer control over them and to
        // avoid inlining styles.
        tooltip: { disableDefaultStyle: true },
        defaultStyle: false,
        forceActionsMenu: true,
      }

      const { vgSpec, view, finalize } = await embed(
        containerRef.current,
        spec,
        options
      )

      vegaView.current = maybeConfigureSelections(view)

      vegaFinalizer.current = finalize

      // Load the initial set of data into the chart.
      const dataArrays = getDataArrays(datasetsRef.current)

      // Heuristic to determine the default dataset name.
      const datasetNames = dataArrays ? Object.keys(dataArrays) : []
      if (datasetNames.length === 1) {
        const [datasetName] = datasetNames
        defaultDataName.current = datasetName
      } else if (datasetNames.length === 0 && vgSpec.data) {
        defaultDataName.current = DEFAULT_DATA_NAME
      }

      const dataObj = getInlineData(dataRef.current as Quiver | null)
      if (dataObj) {
        vegaView.current.insert(defaultDataName.current, dataObj)
      }
      if (dataArrays) {
        for (const [name, data] of Object.entries(dataArrays)) {
          vegaView.current.insert(name, data)
        }
      }

      await vegaView.current.runAsync()

      // Fix bug where the "..." menu button overlaps with charts where width is
      // set to -1 on first load.
      await vegaView.current.resize().runAsync()

      return vegaView.current
    },
    [finalizeView, maybeConfigureSelections]
  )

  const updateData = useCallback(
    (
      view: VegaView,
      name: string,
      prevData: Quiver | null,
      data: Quiver | null
    ): void => {
      if (!data || data.dimensions.numDataRows === 0) {
        // The new data is empty, so we remove the dataset from the
        // chart view if the named dataset exists.
        try {
          view.remove(name, truthy)
        } finally {
          return
        }
      }

      if (!prevData || prevData.dimensions.numDataRows === 0) {
        // The previous data was empty, so we just insert the new data.
        view.insert(name, getDataArray(data))
        return
      }

      // Check if dataframes have same "shape" but the new one has more rows.
      if (data.hash !== prevData.hash) {
        // Clean the dataset and insert from scratch.
        view.data(name, getDataArray(data))
        logMessage(
          `Had to clear the ${name} dataset before inserting data through Vega view.`
        )
      }
    },
    []
  )

  const updateView = useCallback(
    async (
      inputData: Quiver | null,
      inputDatasets: WrappedNamedDataset[]
    ): Promise<VegaView | null> => {
      if (vegaView.current === null) {
        return null
      }

      // At this point the previous data should be updated
      const prevData = dataRef.current
      const prevDatasets = datasetsRef.current

      if (prevData || inputData) {
        updateData(
          vegaView.current,
          defaultDataName.current,
          prevData,
          inputData
        )
      }

      const prevDataSets = getDataSets(prevDatasets) ?? {}
      const dataSets = getDataSets(inputDatasets) ?? {}

      for (const [name, dataset] of Object.entries(dataSets)) {
        const datasetName = name || defaultDataName.current
        const prevDataset = prevDataSets[datasetName]

        updateData(vegaView.current, datasetName, prevDataset, dataset)
      }

      // Remove all datasets that are in the previous but not the current datasets.
      for (const name of Object.keys(prevDataSets)) {
        if (
          !dataSets.hasOwnProperty(name) &&
          name !== defaultDataName.current
        ) {
          updateData(vegaView.current, name, null, null)
        }
      }

      await vegaView.current?.resize().runAsync()

      dataRef.current = inputData
      datasetsRef.current = inputDatasets

      return vegaView.current
    },
    [updateData]
  )

  return { createView, updateView, finalizeView }
}


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/useVegaLiteSelections.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Mock, Mocked } from "vitest"
import { View as VegaView } from "vega"
import { act, renderHook } from "@testing-library/react-hooks"

import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import { debounce } from "@streamlit/lib/src/util/utils"

import { useVegaLiteSelections } from "./useVegaLiteSelections"
import { VegaLiteChartElement } from "./arrowUtils"

// Mock the debounce so we can control how/when it is invoked.
vi.mock("@streamlit/lib/src/util/utils", async () => ({
  // we will override the `debounce`
  ...(await vi.importActual("@streamlit/lib/src/util/utils")),
  debounce: vi.fn(),
}))

describe("useVegaLiteSelections", () => {
  // Use a mocked version of the WidgetStateManager
  let mockWidgetMgr: Mocked<WidgetStateManager>

  beforeEach(() => {
    vi.resetAllMocks()
    vi.useFakeTimers()

    mockWidgetMgr = {
      getElementState: vi.fn(),
      setElementState: vi.fn(),
      setStringValue: vi.fn(),
      getStringValue: vi.fn(),
      addFormClearedListener: vi.fn().mockReturnValue({ disconnect: vi.fn() }),
    } as unknown as Mocked<WidgetStateManager>

    const debouncedMock = debounce as Mock
    // By default, the mocked debounce simply calls its callback immediately.
    debouncedMock.mockImplementation((_delay: number, fn: any) => fn)
  })

  afterEach(() => {
    vi.clearAllTimers()
    vi.useRealTimers()
  })

  it("adds signal listeners for each selectionMode parameter", () => {
    const mockVegaView = {
      addSignalListener: vi.fn(),
      getState: vi.fn(),
    } as unknown as Mocked<VegaView>

    const selectionMode = ["param1", "param2"]
    const { result } = renderHook(() =>
      useVegaLiteSelections(
        {
          id: "chartId",
          formId: "formId",
          selectionMode,
        } as VegaLiteChartElement,
        mockWidgetMgr
      )
    )

    // Invoke the returned callback with our mock view
    act(() => {
      const { maybeConfigureSelections } = result.current
      maybeConfigureSelections(mockVegaView)
    })

    expect(mockVegaView.addSignalListener).toHaveBeenCalledTimes(
      selectionMode.length
    )
    selectionMode.forEach(param => {
      expect(mockVegaView.addSignalListener).toHaveBeenCalledWith(
        param,
        expect.any(Function)
      )
    })
  })

  it("stores the vega viewState in the widget manager on signal fire", () => {
    const mockVegaView = {
      addSignalListener: vi.fn(),
      getState: vi.fn(() => ({ some: "state" })),
    } as unknown as Mocked<VegaView>

    const selectionMode = ["param1"]
    const { result } = renderHook(() =>
      useVegaLiteSelections(
        {
          id: "chartId",
          formId: "formId",
          selectionMode,
        } as VegaLiteChartElement,
        mockWidgetMgr
      )
    )

    act(() => {
      const { maybeConfigureSelections } = result.current
      maybeConfigureSelections(mockVegaView)
    })

    // Retrieve the actual listener callback.
    // The first argument to addSignalListener is the param name,
    // the second argument is the callback function.
    const [[, listenerCallback]] = (mockVegaView.addSignalListener as Mock)
      .mock.calls

    // Simulate the signal callback
    const signalValue = { foo: "bar" }
    act(() => {
      listenerCallback("param1", signalValue)
    })

    // Expect setElementState to be called with the vegaView state
    expect(mockVegaView.getState).toHaveBeenCalled()
    expect(mockWidgetMgr.setElementState).toHaveBeenCalledWith(
      "chartId",
      "viewState",
      { some: "state" }
    )
  })

  it("updates widget state with processed selection on signal fire", () => {
    const mockVegaView = {
      addSignalListener: vi.fn(),
      getState: vi.fn(() => ({ some: "state" })),
    } as unknown as Mocked<VegaView>

    const selectionMode = ["param1"]
    const { result } = renderHook(() =>
      useVegaLiteSelections(
        {
          id: "chartId",
          formId: "formId",
          selectionMode,
        } as VegaLiteChartElement,
        mockWidgetMgr
      )
    )

    act(() => {
      const { maybeConfigureSelections } = result.current
      maybeConfigureSelections(mockVegaView)
    })

    const [[, listenerCallback]] = (mockVegaView.addSignalListener as Mock)
      .mock.calls

    const signalValue = {
      vlPoint: {
        or: [{ data: "A" }, { data: "B" }],
      },
    }

    // Suppose getStringValue returns an empty object initially
    mockWidgetMgr.getStringValue.mockReturnValueOnce("")

    act(() => {
      listenerCallback("param1", signalValue)
    })

    // The or array is assigned to the "param1" key
    expect(mockWidgetMgr.setStringValue).toHaveBeenCalledWith(
      { id: "chartId", formId: "formId" },
      JSON.stringify({
        selection: {
          param1: [{ data: "A" }, { data: "B" }],
        },
      }),
      { fromUi: true },
      undefined // fragmentId not passed in this test
    )
  })

  it("does not update widget state if the state hasn't changed", () => {
    const mockVegaView = {
      addSignalListener: vi.fn(),
      getState: vi.fn(() => ({ some: "state" })),
    } as unknown as Mocked<VegaView>

    const selectionMode = ["param1"]
    const { result } = renderHook(() =>
      useVegaLiteSelections(
        {
          id: "chartId",
          formId: "formId",
          selectionMode,
        } as VegaLiteChartElement,
        mockWidgetMgr
      )
    )

    act(() => {
      const { maybeConfigureSelections } = result.current
      maybeConfigureSelections(mockVegaView)
    })

    const [[, listenerCallback]] = (mockVegaView.addSignalListener as Mock)
      .mock.calls

    // The widget is already set to the same updated state
    const existingState = {
      selection: {
        param1: [{ data: "A" }, { data: "B" }],
      },
    }
    mockWidgetMgr.getStringValue.mockReturnValueOnce(
      JSON.stringify(existingState)
    )

    // Fire the signal with the same selection
    act(() => {
      listenerCallback("param1", {
        vlPoint: {
          or: [{ data: "A" }, { data: "B" }],
        },
      })
    })

    expect(mockWidgetMgr.setStringValue).not.toHaveBeenCalled()
  })

  it("resets selection state when form is cleared", () => {
    const selectionMode = ["param1", "param2"]
    const { result } = renderHook(() =>
      useVegaLiteSelections(
        {
          id: "chartId",
          formId: "formId",
          selectionMode,
        } as VegaLiteChartElement,
        mockWidgetMgr
      )
    )

    const { onFormCleared } = result.current

    // Assume current state is not empty
    const existingState = {
      selection: {
        param1: [{ data: "X" }],
        param2: [{ data: "Y" }],
      },
    }
    mockWidgetMgr.getStringValue.mockReturnValueOnce(
      JSON.stringify(existingState)
    )

    act(() => {
      onFormCleared()
    })

    // Expect empty selection state
    expect(mockWidgetMgr.setStringValue).toHaveBeenCalledWith(
      { id: "chartId", formId: "formId" },
      JSON.stringify({
        selection: {
          param1: {},
          param2: {},
        },
      }),
      { fromUi: true },
      undefined
    )
  })
})


================================================
File: /frontend/lib/src/components/elements/ArrowVegaLiteChart/useVegaLiteSelections.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { useCallback } from "react"

import { SignalValue, View as VegaView } from "vega"
import isEqual from "lodash/isEqual"

import {
  WidgetInfo,
  WidgetStateManager,
} from "@streamlit/lib/src/WidgetStateManager"
import { logWarning } from "@streamlit/lib/src/util/log"
import { debounce, notNullOrUndefined } from "@streamlit/lib/src/util/utils"

import { VegaLiteChartElement } from "./arrowUtils"

/**
 * Debounce time for triggering a widget state update
 * This prevents to rapid updates to the widget state.
 */
const DEBOUNCE_TIME_MS = 150

/** This is the state that is sent to the backend
 * This needs to be the same structure that is also defined
 * in the Python code.
 */
export interface VegaLiteState {
  selection: Record<string, any>
}

export interface UseVegaLiteSelectionsOutput {
  maybeConfigureSelections: (view: VegaView) => VegaView
  onFormCleared: () => void
}

/**
 * Hook that returns a function that can be used to configure the selection
 * events for a vega-lite chart.
 *
 * @param element The vega-lite chart element
 * @param widgetMgr The widget manager
 * @param fragmentId The fragment id of the element
 */
export const useVegaLiteSelections = (
  element: VegaLiteChartElement,
  widgetMgr: WidgetStateManager,
  fragmentId?: string
): UseVegaLiteSelectionsOutput => {
  const { id: chartId, formId, selectionMode } = element

  const maybeConfigureSelections = useCallback(
    (vegaView: VegaView): VegaView => {
      // Add listeners for all selection events. Find out more here:
      // https://vega.github.io/vega/docs/api/view/#view_addSignalListener
      selectionMode.forEach(param => {
        vegaView.addSignalListener(
          param,
          debounce(DEBOUNCE_TIME_MS, (name: string, value: SignalValue) => {
            // Store the current chart selection state with the widget manager so that it
            // can be used for restoring the state when the component unmounted and
            // created again. This can happen when elements are added before it within
            // the delta path. The viewState is only stored in the frontend, and not
            // synced to the backend.
            const viewState = vegaView.getState({
              // There are also `signals` data, but I believe its
              // not relevant for restoring the selection state.
              data: (name?: string, _operator?: any) => {
                // Vega lite stores the selection state in a <param name>_store parameter
                // under `data` that can be retrieved via the getState method.
                // https://vega.github.io/vega/docs/api/view/#view_getState
                return selectionMode.some(mode => `${mode}_store` === name)
              },
              // Don't include subcontext data since it will lead to exceptions
              // when loading the state.
              recurse: false,
            })

            if (notNullOrUndefined(viewState)) {
              widgetMgr.setElementState(chartId, "viewState", viewState)
            }

            // If selection encodings are correctly specified, vega-lite will return
            // a list of selected points within the vlPoint.or property:
            // https://github.com/vega/altair/blob/f1b4e2c84da2fba220022c8a285cc8280f824ed8/altair/utils/selection.py#L50
            // We want to just return this list of points instead of the entire object
            // since the other parts of the selection object are not useful.
            let processedSelection = value
            if ("vlPoint" in value && "or" in value.vlPoint) {
              processedSelection = value.vlPoint.or
            }

            const widgetInfo: WidgetInfo = { id: chartId, formId }

            // Get the current widget state
            const currentWidgetState = JSON.parse(
              widgetMgr.getStringValue(widgetInfo) || "{}"
            )

            // Update the component-internal selection state
            const updatedSelections = {
              selection: {
                ...(currentWidgetState?.selection || {}),
                [name]: processedSelection || {},
              } as VegaLiteState,
            }

            // Update the widget state if the selection state has changed
            // compared to the last update. This selection state will be synced
            // with the backend.
            if (!isEqual(currentWidgetState, updatedSelections)) {
              widgetMgr.setStringValue(
                widgetInfo,
                JSON.stringify(updatedSelections),
                {
                  fromUi: true,
                },
                fragmentId
              )
            }
          })
        )
      })

      // Try to load the previous state of the chart from the element state.
      // This is useful to restore the selection state when the component is re-mounted
      // or when its put into fullscreen mode.
      const viewState = widgetMgr.getElementState(chartId, "viewState")
      if (notNullOrUndefined(viewState)) {
        try {
          return vegaView.setState(viewState)
        } catch (e) {
          logWarning("Failed to restore view state", e)
        }
      }

      return vegaView
    },
    [chartId, selectionMode, widgetMgr, formId, fragmentId]
  )

  const onFormCleared = useCallback(() => {
    const emptySelectionState: VegaLiteState = {
      selection: {},
    }
    // Initialize all parameters defined in the selectionMode with an empty object.
    selectionMode.forEach(param => {
      emptySelectionState.selection[param] = {}
    })
    const widgetInfo = { id: chartId, formId }
    const currentWidgetStateStr = widgetMgr.getStringValue(widgetInfo)
    const currentWidgetState = currentWidgetStateStr
      ? JSON.parse(currentWidgetStateStr)
      : // If there wasn't any selection yet, the selection state
        // is assumed to be empty.
        emptySelectionState

    if (!isEqual(currentWidgetState, emptySelectionState)) {
      widgetMgr.setStringValue(
        widgetInfo,
        JSON.stringify(emptySelectionState),
        {
          fromUi: true,
        },
        fragmentId
      )
    }
  }, [chartId, formId, fragmentId, selectionMode, widgetMgr])

  return { maybeConfigureSelections, onFormCleared }
}


================================================
File: /frontend/lib/src/components/elements/Audio/Audio.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { Audio as AudioProto } from "@streamlit/lib/src/proto"
import { mockEndpoints } from "@streamlit/lib/src/mocks/mocks"
import { WidgetStateManager as ElementStateManager } from "@streamlit/lib/src/WidgetStateManager"

import Audio, { AudioProps } from "./Audio"

describe("Audio Element", () => {
  const buildMediaURL = vi.fn().mockReturnValue("https://mock.media.url")

  const mockSetElementState = vi.fn()
  const mockGetElementState = vi.fn()
  const elementMgrMock = {
    setElementState: mockSetElementState,
    getElementState: mockGetElementState,
    sendRerunBackMsg: vi.fn(),
    formsDataChanged: vi.fn(),
  }

  const getProps = (elementProps: Partial<AudioProto> = {}): AudioProps => ({
    element: AudioProto.create({
      startTime: 0,
      url: "/media/mockAudioFile.wav",
      ...elementProps,
    }),
    endpoints: mockEndpoints({ buildMediaURL: buildMediaURL }),
    width: 0,
    elementMgr: elementMgrMock as unknown as ElementStateManager,
  })

  it("renders without crashing", () => {
    render(<Audio {...getProps()} />)
    const audioElement = screen.getByTestId("stAudio")
    expect(audioElement).toBeInTheDocument()
    expect(audioElement).toHaveClass("stAudio")
  })

  it("has controls", () => {
    render(<Audio {...getProps()} />)
    expect(screen.getByTestId("stAudio")).toHaveAttribute("controls")
  })

  it("creates its `src` attribute using buildMediaURL", () => {
    render(<Audio {...getProps()} />)
    const audioElement = screen.getByTestId("stAudio")
    expect(buildMediaURL).toHaveBeenCalledWith("/media/mockAudioFile.wav")
    expect(audioElement).toHaveAttribute("src", "https://mock.media.url")
  })

  beforeEach(() => {
    vi.clearAllMocks()
    mockGetElementState.mockReturnValue(false) // By default, assume autoplay is not prevented
  })

  it("does not autoplay if preventAutoplay is set", () => {
    mockGetElementState.mockReturnValueOnce(true) // Autoplay should be prevented
    const props = getProps({ autoplay: true, id: "uniqueAudioId" })
    render(<Audio {...props} />)
    const audioElement = screen.getByTestId("stAudio")
    expect(audioElement).not.toHaveAttribute("autoPlay")
  })

  it("autoplays if preventAutoplay is not set and autoplay is true", () => {
    mockGetElementState.mockReturnValueOnce(false) // Autoplay is not prevented
    const props = getProps({ autoplay: true, id: "uniqueAudioId" })
    render(<Audio {...props} />)
    const audioElement = screen.getByTestId("stAudio")
    expect(audioElement).toHaveAttribute("autoPlay")
  })

  it("calls setElementState to prevent future autoplay on first autoplay", () => {
    mockGetElementState.mockReturnValueOnce(false) // Autoplay is not prevented initially
    const props = getProps({ autoplay: true, id: "uniqueAudioId" })
    render(<Audio {...props} />)
    expect(mockSetElementState).toHaveBeenCalledTimes(1)
    expect(mockSetElementState).toHaveBeenCalledWith(
      props.element.id,
      "preventAutoplay",
      true
    )
  })

  // Test to ensure that setElementState is not called again if autoplay is already prevented
  it("does not call setElementState again if autoplay is already prevented", () => {
    mockGetElementState.mockReturnValueOnce(true) // Autoplay is already prevented
    const props = getProps({ autoplay: true, id: "uniqueAudioId" })
    render(<Audio {...props} />)
    expect(mockSetElementState).not.toHaveBeenCalled()
  })

  it("updates time when the prop is changed", () => {
    const props = getProps({
      url: "http://localhost:80/media/sound.wav",
    })

    const { rerender } = render(<Audio {...props} />)
    let audioElement = screen.getByTestId("stAudio") as HTMLAudioElement

    expect(audioElement.currentTime).toBe(0)

    const newProps = getProps({ startTime: 10 })
    rerender(<Audio {...newProps} />)

    audioElement = screen.getByTestId("stAudio") as HTMLAudioElement

    expect(audioElement.currentTime).toBe(10)
  })
})


================================================
File: /frontend/lib/src/components/elements/Audio/Audio.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, useEffect, useMemo, useRef } from "react"

import { Audio as AudioProto } from "@streamlit/lib/src/proto"
import { StreamlitEndpoints } from "@streamlit/lib/src/StreamlitEndpoints"
import { WidgetStateManager as ElementStateManager } from "@streamlit/lib/src/WidgetStateManager"

export interface AudioProps {
  endpoints: StreamlitEndpoints
  width: number
  element: AudioProto
  elementMgr: ElementStateManager
}

export default function Audio({
  element,
  width,
  endpoints,
  elementMgr,
}: Readonly<AudioProps>): ReactElement {
  const audioRef = useRef<HTMLAudioElement>(null)

  const { startTime, endTime, loop, autoplay } = element

  const preventAutoplay = useMemo<boolean>(() => {
    if (!element.id) {
      // Elements without an ID should never autoplay
      return true
    }

    // Recover the state in case this component got unmounted
    // and mounted again for the same element.
    const preventAutoplay = elementMgr.getElementState(
      element.id,
      "preventAutoplay"
    )

    if (!preventAutoplay) {
      // Set the state to prevent autoplay in case there is an unmount + mount
      // for the same element.
      elementMgr.setElementState(element.id, "preventAutoplay", true)
    }
    return preventAutoplay ?? false
  }, [element.id, elementMgr])

  // Handle startTime changes
  useEffect(() => {
    if (audioRef.current) {
      audioRef.current.currentTime = startTime
    }
  }, [startTime])

  useEffect(() => {
    const audioNode = audioRef.current

    const setStartTime: () => void = () => {
      if (audioNode) {
        // setStartTime
        audioNode.currentTime = element.startTime
      }
    }

    if (audioNode) {
      audioNode.addEventListener("loadedmetadata", setStartTime)
    }

    return () => {
      if (audioNode) {
        audioNode.removeEventListener("loadedmetadata", setStartTime)
      }
    }
  }, [element])

  // Stop the audio at 'endTime' and handle loop
  useEffect(() => {
    const audioNode = audioRef.current
    if (!audioNode) {
      return
    }

    // Flag to avoid calling 'audioNode.pause()' multiple times
    let stoppedByEndTime = false

    const handleTimeUpdate = (): void => {
      if (endTime > 0 && audioNode.currentTime >= endTime) {
        if (loop) {
          // If loop is true and we reached 'endTime', reset to 'startTime'
          audioNode.currentTime = startTime || 0
          audioNode.play()
        } else if (!stoppedByEndTime) {
          stoppedByEndTime = true
          audioNode.pause()
        }
      }
    }

    if (endTime > 0) {
      audioNode.addEventListener("timeupdate", handleTimeUpdate)
    }

    return () => {
      if (audioNode && endTime > 0) {
        audioNode.removeEventListener("timeupdate", handleTimeUpdate)
      }
    }
  }, [endTime, loop, startTime])

  // Handle looping the audio
  useEffect(() => {
    const audioNode = audioRef.current
    if (!audioNode) {
      return
    }

    // Loop the audio when it has ended
    const handleAudioEnd = (): void => {
      if (loop) {
        audioNode.currentTime = startTime || 0 // Reset to startTime or to the start if not specified
        audioNode.play()
      }
    }

    audioNode.addEventListener("ended", handleAudioEnd)

    return () => {
      if (audioNode) {
        audioNode.removeEventListener("ended", handleAudioEnd)
      }
    }
  }, [loop, startTime])

  const uri = endpoints.buildMediaURL(element.url)

  return (
    <audio
      className="stAudio"
      data-testid="stAudio"
      ref={audioRef}
      controls
      autoPlay={autoplay && !preventAutoplay}
      src={uri}
      style={{ width }}
    />
  )
}


================================================
File: /frontend/lib/src/components/elements/Audio/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Audio"


================================================
File: /frontend/lib/src/components/elements/Balloons/Balloons.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import Balloons, { NUM_BALLOONS, Props } from "./Balloons"

const getProps = (): Props => ({
  scriptRunId: "51522269",
})

describe("Balloons element", () => {
  vi.useFakeTimers()

  beforeEach(() => {
    vi.clearAllMocks()
    vi.clearAllTimers()
  })

  it("renders without crashing", () => {
    const props = getProps()
    render(<Balloons {...props} />)

    const balloonElement = screen.getByTestId("stBalloons")
    expect(balloonElement).toBeInTheDocument()
    expect(balloonElement).toHaveClass("stBalloons")

    const balloonImages = screen.getAllByRole("img")
    expect(balloonImages.length).toBe(NUM_BALLOONS)

    balloonImages.forEach(node => {
      expect(node).toHaveAttribute("src")
    })
  })

  it("uses correct top-level class", () => {
    const props = getProps()
    render(<Balloons {...props} />)

    const balloonElement = screen.getByTestId("stBalloons")
    expect(balloonElement).toHaveClass("stBalloons")
  })
})


================================================
File: /frontend/lib/src/components/elements/Balloons/Balloons.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, memo } from "react"

/*
 * IMPORTANT: If you change the asset imports below, make sure they still work if Streamlit is
 * served from a subpath.
 */
import Balloon0 from "@streamlit/lib/src/assets/img/balloons/balloon-0.png"
import Balloon1 from "@streamlit/lib/src/assets/img/balloons/balloon-1.png"
import Balloon2 from "@streamlit/lib/src/assets/img/balloons/balloon-2.png"
import Balloon3 from "@streamlit/lib/src/assets/img/balloons/balloon-3.png"
import Balloon4 from "@streamlit/lib/src/assets/img/balloons/balloon-4.png"
import Balloon5 from "@streamlit/lib/src/assets/img/balloons/balloon-5.png"
import Particles from "@streamlit/lib/src/components/elements/Particles"
import { ParticleProps } from "@streamlit/lib/src/components/elements/Particles/Particles"
import { RenderInPortalIfExists } from "@streamlit/lib/src/components/core/Portal/RenderInPortalIfExists"

import { StyledBalloon } from "./styled-components"

export const NUM_BALLOONS = 30

const BALLOON_IMAGES: string[] = [
  Balloon0,
  Balloon1,
  Balloon2,
  Balloon3,
  Balloon4,
  Balloon5,
]

const NUM_BALLOON_TYPES = BALLOON_IMAGES.length

export interface Props {
  scriptRunId: string
}

const Balloon: FC<React.PropsWithChildren<ParticleProps>> = ({
  particleType,
}) => <StyledBalloon src={BALLOON_IMAGES[particleType]} />

const Balloons: FC<React.PropsWithChildren<Props>> = ({ scriptRunId }) => (
  // Keys should be unique each time, so React replaces the images in the DOM and their animations
  // actually rerun.
  <RenderInPortalIfExists>
    <Particles
      className="stBalloons"
      data-testid="stBalloons"
      scriptRunId={scriptRunId}
      numParticleTypes={NUM_BALLOON_TYPES}
      numParticles={NUM_BALLOONS}
      ParticleComponent={Balloon}
    />
  </RenderInPortalIfExists>
)

export default memo(Balloons)


================================================
File: /frontend/lib/src/components/elements/Balloons/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Props } from "./Balloons"

export type BalloonsProps = Props
export { default, NUM_BALLOONS } from "./Balloons"


================================================
File: /frontend/lib/src/components/elements/Balloons/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { keyframes } from "@emotion/react"
import styled from "@emotion/styled"

const IMAGE_HEIGHT = 300
const IMAGE_WIDTH = 121
const POS_MIN_VW = 20
const POS_MAX_VW = 80
const DELAY_MAX_MS = 1000

const moveUp = keyframes`
  from {
    transform: translateY(calc(100vh + ${IMAGE_HEIGHT}px));
  }

  to {
    transform: translateY(0);
  }
`

export const StyledBalloon = styled.img(({ theme }) => ({
  position: "fixed",
  top: `${-IMAGE_HEIGHT}px`,
  marginLeft: `${-IMAGE_WIDTH / 2}px`,
  zIndex: theme.zIndices.balloons,
  left: `${Math.random() * (POS_MAX_VW - POS_MIN_VW) + POS_MIN_VW}vw`,
  animationDelay: `${Math.random() * DELAY_MAX_MS}ms`,
  height: `${IMAGE_HEIGHT}px`,
  width: `${IMAGE_WIDTH}px`,
  pointerEvents: "none",

  animationDuration: "750ms",
  animationName: moveUp,
  animationTimingFunction: "ease-in",
  animationDirection: "normal",
  animationIterationCount: 1,
  opacity: 1,
}))


================================================
File: /frontend/lib/src/components/elements/BokehChart/BokehChart.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { BokehChart as BokehChartProto } from "@streamlit/lib/src/proto"
import Bokeh from "@streamlit/lib/src/vendor/bokeh/bokeh.esm"

import { BokehChart, BokehChartProps } from "./BokehChart"

vi.mock("@streamlit/lib/src/vendor/bokeh/bokeh.esm", () => ({
  // needed to parse correctly
  __esModule: true,
  default: {
    // the js source code has main.register_plugin so we need to mock it
    register_plugin: vi.fn(),
    // actual function that we need to mock and check
    embed: {
      embed_item: vi.fn(),
    },
  },
}))

const mockBokehEmbed = vi.mocked(Bokeh)

// Serialized BokehChart data for testing purposes
const MOCK_FIGURE = {
  target_id: null,
  root_id: "1088",
  doc: {
    roots: {
      references: [
        {
          attributes: {},
          id: "1113",
          type: "ResetTool",
        },
        {
          attributes: {
            data_source: { id: "1122", type: "ColumnDataSource" },
            glyph: { id: "1123", type: "Line" },
            hover_glyph: null,
            muted_glyph: null,
            nonselection_glyph: { id: "1124", type: "Line" },
            selection_glyph: null,
            view: { id: "1126", type: "CDSView" },
          },
          id: "1125",
          type: "GlyphRenderer",
        },
        { attributes: {}, id: "1114", type: "HelpTool" },
        {
          attributes: { callback: null },
          id: "1091",
          type: "DataRange1d",
        },
        {
          attributes: {
            line_alpha: 0.1,
            line_color: "#1f77b4",
            line_width: 2,
            x: { field: "x" },
            y: { field: "y" },
          },
          id: "1124",
          type: "Line",
        },
        { attributes: {}, id: "1097", type: "LinearScale" },
        {
          attributes: {
            axis_label: "x",
            formatter: { id: "1131", type: "BasicTickFormatter" },
            ticker: { id: "1100", type: "BasicTicker" },
          },
          id: "1099",
          type: "LinearAxis",
        },
        {
          attributes: {
            callback: null,
            data: { x: [1, 2, 3, 4, 5], y: [6, 7, 2, 4, 5] },
            selected: { id: "1140", type: "Selection" },
            selection_policy: { id: "1141", type: "UnionRenderers" },
          },
          id: "1122",
          type: "ColumnDataSource",
        },
        {
          attributes: { items: [{ id: "1134", type: "LegendItem" }] },
          id: "1133",
          type: "Legend",
        },
        {
          attributes: {
            active_drag: "auto",
            active_inspect: "auto",
            active_multi: null,
            active_scroll: "auto",
            active_tap: "auto",
            tools: [
              { id: "1109", type: "PanTool" },
              { id: "1110", type: "WheelZoomTool" },
              {
                id: "1111",
                type: "BoxZoomTool",
              },
              { id: "1112", type: "SaveTool" },
              { id: "1113", type: "ResetTool" },
              {
                id: "1114",
                type: "HelpTool",
              },
            ],
          },
          id: "1115",
          type: "Toolbar",
        },
        {
          attributes: {
            dimension: 1,
            ticker: { id: "1105", type: "BasicTicker" },
          },
          id: "1108",
          type: "Grid",
        },
        {
          attributes: {},
          id: "1131",
          type: "BasicTickFormatter",
        },
        {
          attributes: {
            below: [{ id: "1099", type: "LinearAxis" }],
            center: [
              { id: "1103", type: "Grid" },
              { id: "1108", type: "Grid" },
              {
                id: "1133",
                type: "Legend",
              },
            ],
            left: [{ id: "1104", type: "LinearAxis" }],
            renderers: [{ id: "1125", type: "GlyphRenderer" }],
            title: { id: "1089", type: "Title" },
            toolbar: { id: "1115", type: "Toolbar" },
            x_range: { id: "1091", type: "DataRange1d" },
            x_scale: { id: "1095", type: "LinearScale" },
            y_range: { id: "1093", type: "DataRange1d" },
            y_scale: { id: "1097", type: "LinearScale" },
          },
          id: "1088",
          subtype: "Figure",
          type: "Plot",
        },
        { attributes: {}, id: "1109", type: "PanTool" },
        {
          attributes: {},
          id: "1100",
          type: "BasicTicker",
        },
        {
          attributes: {},
          id: "1129",
          type: "BasicTickFormatter",
        },
        {
          attributes: {
            line_color: "#1f77b4",
            line_width: 2,
            x: { field: "x" },
            y: { field: "y" },
          },
          id: "1123",
          type: "Line",
        },
        { attributes: {}, id: "1140", type: "Selection" },
        {
          attributes: { text: "simple line example" },
          id: "1089",
          type: "Title",
        },
        { attributes: {}, id: "1110", type: "WheelZoomTool" },
        {
          attributes: {
            ticker: {
              id: "1100",
              type: "BasicTicker",
            },
          },
          id: "1103",
          type: "Grid",
        },
        {
          attributes: { source: { id: "1122", type: "ColumnDataSource" } },
          id: "1126",
          type: "CDSView",
        },
        { attributes: {}, id: "1141", type: "UnionRenderers" },
        {
          attributes: {
            overlay: {
              id: "1132",
              type: "BoxAnnotation",
            },
          },
          id: "1111",
          type: "BoxZoomTool",
        },
        { attributes: {}, id: "1112", type: "SaveTool" },
        {
          attributes: { callback: null },
          id: "1093",
          type: "DataRange1d",
        },
        { attributes: {}, id: "1105", type: "BasicTicker" },
        {
          attributes: {
            label: { value: "Trend" },
            renderers: [{ id: "1125", type: "GlyphRenderer" }],
          },
          id: "1134",
          type: "LegendItem",
        },
        { attributes: {}, id: "1095", type: "LinearScale" },
        {
          attributes: {
            axis_label: "y",
            formatter: { id: "1129", type: "BasicTickFormatter" },
            ticker: { id: "1105", type: "BasicTicker" },
          },
          id: "1104",
          type: "LinearAxis",
        },
        {
          attributes: {
            bottom_units: "screen",
            fill_alpha: { value: 0.5 },
            fill_color: { value: "lightgrey" },
            left_units: "screen",
            level: "overlay",
            line_alpha: { value: 1.0 },
            line_color: { value: "black" },
            line_dash: [4, 4],
            line_width: { value: 2 },
            render_mode: "css",
            right_units: "screen",
            top_units: "screen",
          },
          id: "1132",
          type: "BoxAnnotation",
        },
      ],
      root_ids: ["1088"],
    },
    title: "",
    version: "1.4.0",
  },
}

const getProps = (
  elementProps: Partial<BokehChartProto> = {}
): BokehChartProps => ({
  element: BokehChartProto.create({
    figure: JSON.stringify(MOCK_FIGURE),
    useContainerWidth: false,
    elementId: "1",
    ...elementProps,
  }),
  height: 400,
  width: 400,
})

expect.extend({
  toMatchBokehDimensions(data, width, height) {
    const plot =
      data && data.doc && data.doc.roots && data.doc.roots.references
        ? data.doc.roots.references.find((e: any) => e.type === "Plot")
        : undefined

    if (!plot) {
      return {
        message: () => `expected data to contain attributes`,
        pass: false,
      }
    }

    const pass =
      plot.attributes.plot_width === width &&
      plot.attributes.plot_height === height

    return {
      message: () =>
        `expected ${plot.attributes.plot_width}x${plot.attributes.plot_height} to be ${width}x${height}`,
      pass,
    }
  },
})

describe("BokehChart element", () => {
  // Avoid Warning: render(): Rendering components directly into document.body is discouraged.
  let div: HTMLDivElement
  beforeEach(() => {
    div = document.createElement("div")
    document.body.appendChild(div)
  })

  afterEach(() => {
    // @ts-expect-error
    mockBokehEmbed.embed.embed_item.mockClear() // clear so embed item calls don't add up
    document.body.removeChild(div)
  })

  it("renders without crashing", () => {
    const props = getProps()
    render(<BokehChart {...props} />)
    const bokehElement = screen.getByTestId("stBokehChart")
    expect(bokehElement).toBeInTheDocument()
    expect(bokehElement).toHaveClass("stBokehChart")
  })

  describe("Chart dimensions", () => {
    it("should use height if not useContainerWidth", () => {
      const props = getProps()
      render(<BokehChart {...props} />)
      expect(mockBokehEmbed.embed.embed_item).toHaveBeenCalledWith(
        // @ts-expect-error
        expect.toMatchBokehDimensions(400, 400),
        "bokeh-chart-1"
      )
    })

    it("should have width if useContainerWidth", () => {
      const props = {
        ...getProps({
          useContainerWidth: true,
        }),
        height: 0,
      }

      render(<BokehChart {...props} />)

      expect(mockBokehEmbed.embed.embed_item).toHaveBeenCalledWith(
        // @ts-expect-error
        expect.toMatchBokehDimensions(400),
        "bokeh-chart-1"
      )
    })
  })

  it("should re-render the chart when the component updates", () => {
    const props = getProps()
    const { rerender } = render(<BokehChart {...props} />)
    rerender(<BokehChart {...props} width={500} height={500} />)
    expect(mockBokehEmbed.embed.embed_item).toHaveBeenCalledTimes(2)
  })
})


================================================
File: /frontend/lib/src/components/elements/BokehChart/BokehChart.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, useCallback, useEffect } from "react"

import { BokehChart as BokehChartProto } from "@streamlit/lib/src/proto"
// We import Bokeh from a vendored source file, because it doesn't play well with Babel (https://github.com/bokeh/bokeh/issues/10658)
// Importing these files will cause global Bokeh to be mutated
// Consumers of this component will have to provide these js files
// bokeh.esm is renamed from bokeh-2.4.3.esm.min.js because addon bokeh scripts have hardcoded path to bokeh main script ("import main from “./bokeh.esm.js")
import Bokeh from "@streamlit/lib/src/vendor/bokeh/bokeh.esm"
import "@streamlit/lib/src/vendor/bokeh/bokeh-api-2.4.3.esm.min"
import "@streamlit/lib/src/vendor/bokeh/bokeh-gl-2.4.3.esm.min"
import "@streamlit/lib/src/vendor/bokeh/bokeh-mathjax-2.4.3.esm.min"
import "@streamlit/lib/src/vendor/bokeh/bokeh-tables-2.4.3.esm.min"
import "@streamlit/lib/src/vendor/bokeh/bokeh-widgets-2.4.3.esm.min"

export interface BokehChartProps {
  width: number
  element: BokehChartProto
  height?: number
}

interface Dimensions {
  chartWidth: number
  chartHeight: number
}

export function BokehChart({
  width,
  element,
  height,
}: Readonly<BokehChartProps>): ReactElement {
  const chartId = `bokeh-chart-${element.elementId}`

  const memoizedGetChartData = useCallback(() => {
    return JSON.parse(element.figure)
  }, [element])

  const getChartDimensions = useCallback(
    (plot: any): Dimensions => {
      // Default values
      let chartWidth: number = plot.attributes.plot_width
      let chartHeight: number = plot.attributes.plot_height

      // if is not fullscreen and useContainerWidth==false, we should use default values
      if (height) {
        chartWidth = width
        chartHeight = height
      } else if (element.useContainerWidth) {
        chartWidth = width
      }

      return { chartWidth, chartHeight }
    },
    [element.useContainerWidth, height, width]
  )

  const removeAllChildNodes = (element: Node): void => {
    while (element.lastChild) {
      element.lastChild.remove()
    }
  }

  const updateChart = (data: any): void => {
    const chart = document.getElementById(chartId)

    /**
     * When you create a bokeh chart in your python script, you can specify
     * the width: p = figure(title="simple line example", x_axis_label="x", y_axis_label="y", plot_width=200);
     * In that case, the json object will contains an attribute called
     * plot_width (or plot_heigth) inside the plot reference.
     * If that values are missing, we can set that values to make the chart responsive.
     */
    const plot =
      data && data.doc && data.doc.roots && data.doc.roots.references
        ? data.doc.roots.references.find((e: any) => e.type === "Plot")
        : undefined

    if (plot) {
      const { chartWidth, chartHeight } = getChartDimensions(plot)

      if (chartWidth > 0) {
        plot.attributes.plot_width = chartWidth
      }
      if (chartHeight > 0) {
        plot.attributes.plot_height = chartHeight
      }
    }

    if (chart !== null) {
      removeAllChildNodes(chart)
      // embed_item is actually an async function call, so a race condition
      // can occur if updateChart is called twice, leading to two Bokeh charts
      // to be embedded at the same time.
      Bokeh.embed.embed_item(data, chartId)
    }
  }

  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  const memoizedUpdateChart = useCallback(updateChart, [
    chartId,
    getChartDimensions,
  ])

  // We only want useEffect to run once per prop update, because of the embed_item
  // race condition mentioned per run. Thus we pass in all props and methods
  // into the useEffect dependency array.
  useEffect(() => {
    memoizedUpdateChart(memoizedGetChartData())
  }, [width, height, element, memoizedGetChartData, memoizedUpdateChart])

  return (
    <div id={chartId} className="stBokehChart" data-testid="stBokehChart" />
  )
}

export default BokehChart


================================================
File: /frontend/lib/src/components/elements/BokehChart/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./BokehChart"


================================================
File: /frontend/lib/src/components/elements/ChatMessage/ChatMessage.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { mockEndpoints } from "@streamlit/lib/src/mocks/mocks"
import { render } from "@streamlit/lib/src/test_util"
import { Block as BlockProto } from "@streamlit/lib/src/proto"

import ChatMessage, { ChatMessageProps } from "./ChatMessage"

const getProps = (
  elementProps: Partial<BlockProto.ChatMessage> = {}
): ChatMessageProps => ({
  element: BlockProto.ChatMessage.create({
    name: "user",
    avatarType: BlockProto.ChatMessage.AvatarType.ICON,
    avatar: "user",
    ...elementProps,
  }),
  endpoints: mockEndpoints({
    buildMediaURL: vi.fn().mockImplementation(url => url),
  }),
})

describe("ChatMessage", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<ChatMessage {...props} />)

    const chatMessage = screen.getByTestId("stChatMessage")
    expect(chatMessage).toBeInTheDocument()
    expect(chatMessage).toHaveClass("stChatMessage")
  })

  it("renders message children content", () => {
    const props = getProps()
    render(<ChatMessage {...props}>Hello, world!</ChatMessage>)
    expect(screen.getByLabelText("Chat message from user").textContent).toBe(
      "Hello, world!"
    )
  })

  it("renders with an emoji avatar", () => {
    const props = getProps({
      avatar: "😃",
      avatarType: BlockProto.ChatMessage.AvatarType.EMOJI,
    })
    render(<ChatMessage {...props} />)
    expect(screen.getByText("😃")).toBeTruthy()
  })

  it("renders with an image avatar", () => {
    const props = getProps({
      avatar: "http://example.com/avatar.jpg",
      avatarType: BlockProto.ChatMessage.AvatarType.IMAGE,
    })
    render(<ChatMessage {...props} />)
    const chatAvatar = screen.getByAltText("user avatar")
    expect(chatAvatar).toHaveAttribute("src", "http://example.com/avatar.jpg")
  })

  it("renders with a name label character as fallback", () => {
    const props = getProps({
      avatar: undefined,
      avatarType: undefined,
      name: "test",
    })
    render(<ChatMessage {...props} />)
    expect(screen.getByText("T")).toBeTruthy()
  })

  it("renders with a 'user' icon avatar", () => {
    const props = getProps({
      avatar: "user",
      avatarType: BlockProto.ChatMessage.AvatarType.ICON,
      name: "foo",
    })
    render(<ChatMessage {...props} />)

    const userAvatarIcon = screen.getByTestId("stChatMessageAvatarUser")
    expect(userAvatarIcon).toBeInTheDocument()
  })

  it("renders with a 'assistant' icon avatar", () => {
    const props = getProps({
      avatar: "assistant",
      avatarType: BlockProto.ChatMessage.AvatarType.ICON,
      name: "foo",
    })
    render(<ChatMessage {...props} />)

    const assistantAvatarIcon = screen.getByTestId(
      "stChatMessageAvatarAssistant"
    )
    expect(assistantAvatarIcon).toBeInTheDocument()
  })

  it("renders with a grey background when name is 'user'", () => {
    const props = getProps()
    render(<ChatMessage {...props} />)
    const chatMessage = screen.getByTestId("stChatMessage")
    expect(chatMessage).toHaveStyle(
      "background-color: rgba(240, 242, 246, 0.5)"
    )
  })

  it("sets an aria label on the chat message", () => {
    const props = getProps()
    render(<ChatMessage {...props} />)

    const chatMessageContent = screen.getByTestId("stChatMessageContent")
    expect(chatMessageContent.getAttribute("aria-label")).toEqual(
      "Chat message from user"
    )
  })
})


================================================
File: /frontend/lib/src/components/elements/ChatMessage/ChatMessage.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { useTheme } from "@emotion/react"
import { Face, SmartToy } from "@emotion-icons/material-outlined"

import { Block as BlockProto } from "@streamlit/lib/src/proto"
import Icon, { DynamicIcon } from "@streamlit/lib/src/components/shared/Icon"
import { EmotionTheme } from "@streamlit/lib/src/theme"
import { StreamlitEndpoints } from "@streamlit/lib/src/StreamlitEndpoints"

import {
  StyledAvatarBackground,
  StyledAvatarIcon,
  StyledAvatarImage,
  StyledChatMessageContainer,
  StyledMessageContent,
} from "./styled-components"

interface ChatMessageAvatarProps {
  name: string
  avatar?: string
  avatarType?: BlockProto.ChatMessage.AvatarType
  endpoints: StreamlitEndpoints
}

function ChatMessageAvatar(
  props: Readonly<ChatMessageAvatarProps>
): ReactElement {
  const { avatar, avatarType, name, endpoints } = props
  const theme: EmotionTheme = useTheme()

  if (avatar) {
    switch (avatarType) {
      case BlockProto.ChatMessage.AvatarType.IMAGE:
        return (
          <StyledAvatarImage
            src={endpoints.buildMediaURL(avatar)}
            alt={`${name} avatar`}
          />
        )
      case BlockProto.ChatMessage.AvatarType.EMOJI:
        return <StyledAvatarBackground>{avatar}</StyledAvatarBackground>
      case BlockProto.ChatMessage.AvatarType.ICON:
        if (avatar === "user") {
          return (
            <StyledAvatarIcon
              data-testid="stChatMessageAvatarUser"
              background={theme.colors.red60}
            >
              <Icon content={Face} size="lg" />
            </StyledAvatarIcon>
          )
        } else if (avatar === "assistant") {
          return (
            <StyledAvatarIcon
              data-testid="stChatMessageAvatarAssistant"
              background={theme.colors.orange60}
            >
              <Icon content={SmartToy} size="lg" />
            </StyledAvatarIcon>
          )
        } else if (avatar.startsWith(":material")) {
          return (
            <StyledAvatarBackground data-testid="stChatMessageAvatarCustom">
              <DynamicIcon
                size="lg"
                iconValue={avatar}
                color={theme.colors.bodyText}
              />
            </StyledAvatarBackground>
          )
        }
    }
  }

  // Fallback to first character of the name label if nothing else can be matched:
  return (
    <StyledAvatarBackground>
      {name ? name.charAt(0).toUpperCase() : "🧑‍💻"}
    </StyledAvatarBackground>
  )
}

export interface ChatMessageProps {
  endpoints: StreamlitEndpoints
  element: BlockProto.ChatMessage
}

const ChatMessage: React.FC<React.PropsWithChildren<ChatMessageProps>> = ({
  endpoints,
  element,
  children,
}): ReactElement => {
  const { avatar, avatarType, name } = element

  return (
    <StyledChatMessageContainer
      className="stChatMessage"
      data-testid="stChatMessage"
      background={["user", "human"].includes(name.toLowerCase())}
    >
      <ChatMessageAvatar
        name={name}
        avatar={avatar}
        avatarType={avatarType}
        endpoints={endpoints}
      />
      <StyledMessageContent
        data-testid="stChatMessageContent"
        aria-label={`Chat message from ${name}`}
      >
        {children}
      </StyledMessageContent>
    </StyledChatMessageContainer>
  )
}

export default ChatMessage


================================================
File: /frontend/lib/src/components/elements/ChatMessage/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./ChatMessage"


================================================
File: /frontend/lib/src/components/elements/ChatMessage/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"
import { transparentize } from "color2k"

import { hasLightBackgroundColor } from "@streamlit/lib/src/theme"

export interface StyledChatMessageContainerProps {
  background: boolean
}

export const StyledChatMessageContainer =
  styled.div<StyledChatMessageContainerProps>(({ theme, background }) => {
    const lightTheme = hasLightBackgroundColor(theme)
    return {
      display: "flex",
      alignItems: "flex-start",
      gap: theme.spacing.sm,
      padding: theme.spacing.lg,
      paddingRight: background ? theme.spacing.lg : 0,
      borderRadius: theme.radii.default,
      ...(background
        ? {
            backgroundColor: lightTheme
              ? transparentize(theme.colors.gray20, 0.5)
              : transparentize(theme.colors.gray90, 0.5),
          }
        : {}),
    }
  })

export const StyledMessageContent = styled.div(({ theme }) => ({
  color: theme.colors.bodyText,
  margin: "auto",
  flexGrow: 1,
  // Ensure the size of the message has an interpreted width as
  // the amount defined by flex layout and disregard its contents
  // they will handle their overflow.
  //
  // Unintuitively, setting the min width to 0 tells the browser
  // that it can shrink past the content's width to the desired size.
  // https://makandracards.com/makandra/66994-css-flex-and-min-width
  minWidth: 0,
}))

export const StyledAvatarBackground = styled.div(({ theme }) => {
  const lightTheme = hasLightBackgroundColor(theme)
  return {
    display: "flex",
    border: `${theme.sizes.borderWidth} solid ${
      lightTheme ? theme.colors.gray40 : theme.colors.gray85
    }`,
    backgroundColor: lightTheme ? theme.colors.white : theme.colors.gray100,
    color: lightTheme ? theme.colors.gray90 : theme.colors.white,
    lineHeight: theme.lineHeights.none,
    fontSize: theme.fontSizes.md,
    // Ensure the avatar always respects the width/height
    flexShrink: 0,
    width: theme.sizes.chatAvatarSize,
    height: theme.sizes.chatAvatarSize,
    borderRadius: theme.radii.default,
    alignItems: "center",
    justifyContent: "center",
  }
})

export interface StyledAvatarIconProps {
  background: string
}

export const StyledAvatarIcon = styled.div<StyledAvatarIconProps>(
  ({ theme, background }) => {
    const lightTheme = hasLightBackgroundColor(theme)
    return {
      display: "flex",
      width: theme.sizes.chatAvatarSize,
      height: theme.sizes.chatAvatarSize,
      // Ensure the avatar always respects the width/height
      flexShrink: 0,
      borderRadius: theme.radii.default,
      alignItems: "center",
      justifyContent: "center",
      backgroundColor: background,
      color: lightTheme ? theme.colors.white : theme.colors.gray100,
    }
  }
)

export const StyledAvatarImage = styled.img(({ theme }) => {
  return {
    width: theme.sizes.chatAvatarSize,
    height: theme.sizes.chatAvatarSize,
    // Ensure the avatar always respects the width/height
    flexShrink: 0,
    borderRadius: theme.radii.default,
    objectFit: "cover",
    display: "flex",
  }
})


================================================
File: /frontend/lib/src/components/elements/CodeBlock/CopyButton.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import Clipboard from "clipboard"

import { render } from "@streamlit/lib/src/test_util"

import CopyButton from "./CopyButton"

vi.mock("clipboard")

describe("CopyButton Element", () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })

  it("renders without crashing", () => {
    render(<CopyButton text="test" />)
    expect(screen.getByTestId("stCodeCopyButton")).toBeInTheDocument()
  })

  describe("attributes", () => {
    it("should have title", () => {
      render(<CopyButton text="test" />)
      expect(screen.getByTestId("stCodeCopyButton")).toHaveAttribute(
        "title",
        "Copy to clipboard"
      )
    })

    it("should have clipboard text", () => {
      render(<CopyButton text="test" />)
      expect(screen.getByTestId("stCodeCopyButton")).toHaveAttribute(
        "data-clipboard-text",
        "test"
      )
    })
  })

  describe("calling clipboard", () => {
    it("should be called on did mount", () => {
      render(<CopyButton text="test" />)

      expect(Clipboard).toHaveBeenCalled()
    })

    it("should be called on unmount", () => {
      const { unmount } = render(<CopyButton text="test" />)

      unmount()

      // @ts-expect-error
      const mockClipboard = Clipboard.mock.instances[0]
      const mockDestroy = mockClipboard.destroy

      expect(mockDestroy).toHaveBeenCalled()
    })
  })
})


================================================
File: /frontend/lib/src/components/elements/CodeBlock/CopyButton.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { useEffect, useRef } from "react"

import Clipboard from "clipboard"
import { Copy as CopyIcon } from "react-feather"
import { useTheme } from "@emotion/react"

import { EmotionTheme } from "@streamlit/lib/src/theme"

import { StyledCopyButton } from "./styled-components"

interface Props {
  text: string
}

const CopyButton: React.FC<Props> = ({ text }) => {
  const theme: EmotionTheme = useTheme()
  const buttonRef = useRef<HTMLButtonElement>(null)
  const clipboardRef = useRef<Clipboard | null>(null)

  useEffect(() => {
    const node = buttonRef.current

    if (node !== null) {
      clipboardRef.current = new Clipboard(node, {
        // Set the container so that copying also works in dialogs.
        // Otherwise, the copy event is swallowed somehow.
        container: node.parentElement ?? undefined,
      })
    }

    return () => {
      if (clipboardRef.current !== null) {
        clipboardRef.current.destroy()
      }
    }
  }, [])

  return (
    <StyledCopyButton
      data-testid="stCodeCopyButton"
      title="Copy to clipboard"
      ref={buttonRef}
      data-clipboard-text={text}
      style={{
        top: 0,
        right: 0,
      }}
    >
      <CopyIcon size={theme.iconSizes.base} />
    </StyledCopyButton>
  )
}

export default CopyButton


================================================
File: /frontend/lib/src/components/elements/CodeBlock/StreamlitSyntaxHighlighter.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { render } from "@streamlit/lib/src/test_util"

import StreamlitSyntaxHighlighter, {
  StreamlitSyntaxHighlighterProps,
