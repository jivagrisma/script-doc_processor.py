import React, { memo, ReactElement, useCallback } from "react"

import UIRadio from "@streamlit/lib/src/components/shared/Radio"
import { Radio as RadioProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  useBasicWidgetState,
  ValueWithSource,
} from "@streamlit/lib/src/hooks/useBasicWidgetState"
import { labelVisibilityProtoValueToEnum } from "@streamlit/lib/src/util/utils"

export interface Props {
  disabled: boolean
  element: RadioProto
  widgetMgr: WidgetStateManager
  width: number
  fragmentId?: string
}

type RadioValue = number | null | undefined

function Radio({
  disabled,
  element,
  widgetMgr,
  width,
  fragmentId,
}: Readonly<Props>): ReactElement {
  const [value, setValueWithSource] = useBasicWidgetState<
    RadioValue,
    RadioProto
  >({
    getStateFromWidgetMgr,
    getDefaultStateFromProto,
    getCurrStateFromProto,
    updateWidgetMgrState,
    element,
    widgetMgr,
    fragmentId,
  })

  const onChange = useCallback(
    (selectedIndex: number): void => {
      setValueWithSource({ value: selectedIndex, fromUi: true })
    },
    [setValueWithSource]
  )

  const { horizontal, options, captions, label, labelVisibility, help } =
    element

  return (
    <UIRadio
      label={label}
      onChange={onChange}
      options={options}
      captions={captions}
      width={width}
      disabled={disabled}
      horizontal={horizontal}
      labelVisibility={labelVisibilityProtoValueToEnum(labelVisibility?.value)}
      value={value ?? null}
      help={help}
    />
  )
}

function getStateFromWidgetMgr(
  widgetMgr: WidgetStateManager,
  element: RadioProto
): RadioValue {
  return widgetMgr.getIntValue(element)
}

function getDefaultStateFromProto(element: RadioProto): RadioValue {
  return element.default ?? null
}

function getCurrStateFromProto(element: RadioProto): RadioValue {
  return element.value ?? null
}

function updateWidgetMgrState(
  element: RadioProto,
  widgetMgr: WidgetStateManager,
  vws: ValueWithSource<RadioValue>,
  fragmentId?: string
): void {
  widgetMgr.setIntValue(
    element,
    vws.value ?? null,
    { fromUi: vws.fromUi },
    fragmentId
  )
}

export default memo(Radio)


================================================
File: /frontend/lib/src/components/widgets/Radio/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Radio"


================================================
File: /frontend/lib/src/components/widgets/Selectbox/Selectbox.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { act, fireEvent, screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import { Selectbox as SelectboxProto } from "@streamlit/lib/src/proto"
import * as Utils from "@streamlit/lib/src/theme/utils"
import { mockConvertRemToPx } from "@streamlit/lib/src/mocks/mocks"

import Selectbox, { Props } from "./Selectbox"

const getProps = (
  elementProps: Partial<SelectboxProto> = {},
  widgetProps: Partial<Props> = {}
): Props => ({
  element: SelectboxProto.create({
    id: "1",
    label: "Label",
    default: 0,
    options: ["a", "b", "c"],
    ...elementProps,
  }),
  width: 0,
  disabled: false,
  widgetMgr: new WidgetStateManager({
    sendRerunBackMsg: vi.fn(),
    formsDataChanged: vi.fn(),
  }),
  ...widgetProps,
})

const pickOption = (selectbox: HTMLElement, value: string): void => {
  // TODO: Utilize user-event instead of fireEvent
  // eslint-disable-next-line testing-library/prefer-user-event
  fireEvent.click(selectbox)
  const valueElement = screen.getByText(value)
  // TODO: Utilize user-event instead of fireEvent
  // eslint-disable-next-line testing-library/prefer-user-event
  fireEvent.click(valueElement)
}

describe("Selectbox widget", () => {
  afterEach(() => {
    vi.restoreAllMocks()
  })

  it("renders without crashing", () => {
    const props = getProps()
    render(<Selectbox {...props} />)
    const selectbox = screen.getByTestId("stSelectbox")
    expect(selectbox).toBeInTheDocument()
    expect(selectbox).toHaveClass("stSelectbox")
  })

  it("sets widget value on mount", () => {
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setIntValue")

    render(<Selectbox {...props} />)
    expect(props.widgetMgr.setIntValue).toHaveBeenCalledWith(
      props.element,
      props.element.default,
      { fromUi: false },
      undefined
    )
  })

  it("can pass fragmentId to setIntValue", () => {
    const props = getProps(undefined, { fragmentId: "myFragmentId" })
    vi.spyOn(props.widgetMgr, "setIntValue")

    render(<Selectbox {...props} />)
    expect(props.widgetMgr.setIntValue).toHaveBeenCalledWith(
      props.element,
      props.element.default,
      { fromUi: false },
      "myFragmentId"
    )
  })

  it("handles the onChange event", () => {
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setIntValue")
    vi.spyOn(Utils, "convertRemToPx").mockImplementation(mockConvertRemToPx)

    render(<Selectbox {...props} />)

    const selectbox = screen.getByRole("combobox")

    pickOption(selectbox, "b")

    expect(props.widgetMgr.setIntValue).toHaveBeenLastCalledWith(
      props.element,
      1,
      { fromUi: true },
      undefined
    )
    expect(screen.queryByText("a")).not.toBeInTheDocument()
    expect(screen.getByText("b")).toBeInTheDocument()
  })

  it("resets its value when form is cleared", () => {
    // Create a widget in a clearOnSubmit form
    const props = getProps({ formId: "form" })
    props.widgetMgr.setFormSubmitBehaviors("form", true)

    vi.spyOn(props.widgetMgr, "setIntValue")
    vi.spyOn(Utils, "convertRemToPx").mockImplementation(mockConvertRemToPx)

    render(<Selectbox {...props} />)

    const selectbox = screen.getByRole("combobox")
    pickOption(selectbox, "b")

    expect(props.widgetMgr.setIntValue).toHaveBeenLastCalledWith(
      props.element,
      1,
      { fromUi: true },
      undefined
    )

    // "Submit" the form
    act(() => {
      props.widgetMgr.submitForm("form", undefined)
    })

    // Our widget should be reset, and the widgetMgr should be updated
    expect(screen.getByText("a")).toBeInTheDocument()
    expect(screen.queryByText("b")).not.toBeInTheDocument()
    expect(props.widgetMgr.setIntValue).toHaveBeenLastCalledWith(
      props.element,
      props.element.default,
      {
        fromUi: true,
      },
      undefined
    )
  })
})


================================================
File: /frontend/lib/src/components/widgets/Selectbox/Selectbox.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, memo, useCallback } from "react"

import { Selectbox as SelectboxProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import UISelectbox from "@streamlit/lib/src/components/shared/Dropdown"
import {
  isNullOrUndefined,
  labelVisibilityProtoValueToEnum,
} from "@streamlit/lib/src/util/utils"
import {
  useBasicWidgetState,
  ValueWithSource,
} from "@streamlit/lib/src/hooks/useBasicWidgetState"

export interface Props {
  disabled: boolean
  element: SelectboxProto
  widgetMgr: WidgetStateManager
  width: number
  fragmentId?: string
}

/**
 * The value specified by the user via the UI. If the user didn't touch this
 * widget's UI, the default value is used.
 */
type SelectboxValue = number | null

const getStateFromWidgetMgr = (
  widgetMgr: WidgetStateManager,
  element: SelectboxProto
): SelectboxValue | undefined => {
  return widgetMgr.getIntValue(element)
}

const getDefaultStateFromProto = (element: SelectboxProto): SelectboxValue => {
  return element.default ?? null
}

const getCurrStateFromProto = (element: SelectboxProto): SelectboxValue => {
  return element.value ?? null
}

const updateWidgetMgrState = (
  element: SelectboxProto,
  widgetMgr: WidgetStateManager,
  valueWithSource: ValueWithSource<SelectboxValue>,
  fragmentId?: string
): void => {
  widgetMgr.setIntValue(
    element,
    valueWithSource.value,
    { fromUi: valueWithSource.fromUi },
    fragmentId
  )
}

const Selectbox: FC<Props> = ({
  disabled,
  element,
  widgetMgr,
  width,
  fragmentId,
}) => {
  const { options, help, label, labelVisibility, placeholder } = element

  const [value, setValueWithSource] = useBasicWidgetState<
    SelectboxValue,
    SelectboxProto
  >({
    getStateFromWidgetMgr,
    getDefaultStateFromProto,
    getCurrStateFromProto,
    updateWidgetMgrState,
    element,
    widgetMgr,
    fragmentId,
  })

  const onChange = useCallback(
    (value: SelectboxValue) => {
      setValueWithSource({ value, fromUi: true })
    },
    [setValueWithSource]
  )

  const clearable = isNullOrUndefined(element.default) && !disabled

  return (
    <UISelectbox
      label={label}
      labelVisibility={labelVisibilityProtoValueToEnum(labelVisibility?.value)}
      options={options}
      disabled={disabled}
      width={width}
      onChange={onChange}
      value={value}
      help={help}
      placeholder={placeholder}
      clearable={clearable}
    />
  )
}

export default memo(Selectbox)


================================================
File: /frontend/lib/src/components/widgets/Selectbox/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Selectbox"


================================================
File: /frontend/lib/src/components/widgets/Slider/Slider.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { act, fireEvent, screen } from "@testing-library/react"

import {
  LabelVisibilityMessage as LabelVisibilityMessageProto,
  Slider as SliderProto,
} from "@streamlit/lib/src/proto"
import { render } from "@streamlit/lib/src/test_util"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"

import { withTimezones } from "src/util/withTimezones"

import Slider, { Props } from "./Slider"

const getProps = (
  elementProps: Partial<SliderProto> = {},
  props: Partial<Props> = {}
): Props => ({
  element: SliderProto.create({
    id: "1",
    label: "Label",
    format: "%d",
    default: [5],
    min: 0,
    max: 10,
    step: 1,
    options: [],
    ...elementProps,
  }),
  width: 600,
  disabled: false,
  widgetMgr: new WidgetStateManager({
    sendRerunBackMsg: vi.fn(),
    formsDataChanged: vi.fn(),
  }),
  ...props,
})

const triggerChangeEvent = (
  element: Element,
  key: "ArrowLeft" | "ArrowRight"
): void => {
  fireEvent.focus(element)
  // TODO: Utilize user-event instead of fireEvent
  // eslint-disable-next-line testing-library/prefer-user-event
  fireEvent.keyDown(element, { key })
  // TODO: Utilize user-event instead of fireEvent
  // eslint-disable-next-line testing-library/prefer-user-event
  fireEvent.keyUp(element, { key })
}

describe("Slider widget", () => {
  vi.useFakeTimers()

  beforeEach(() => {
    vi.clearAllMocks()
    vi.clearAllTimers()
  })

  it("shows a label", () => {
    const props = getProps()
    render(<Slider {...props} />)

    const widgetLabel = screen.queryByText(`${props.element.label}`)
    expect(widgetLabel).toBeInTheDocument()
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when hidden", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.HIDDEN,
      },
    })
    render(<Slider {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle(
      "visibility: hidden"
    )
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when collapsed", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.COLLAPSED,
      },
    })
    render(<Slider {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle("display: none")
  })

  it("sets widget value on mount", () => {
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setDoubleArrayValue")

    render(<Slider {...props} />)

    // We need to do this as we are using a debounce when the widget value is set
    vi.runAllTimers()

    expect(props.widgetMgr.setDoubleArrayValue).toHaveBeenCalledWith(
      props.element,
      [5],
      { fromUi: false },
      undefined
    )
  })

  it("can pass fragmentId to setDoubleArrayValue", () => {
    const props = getProps(undefined, { fragmentId: "myFragmentId" })
    vi.spyOn(props.widgetMgr, "setDoubleArrayValue")

    render(<Slider {...props} />)

    // We need to do this as we are using a debounce when the widget value is set
    vi.runAllTimers()

    expect(props.widgetMgr.setDoubleArrayValue).toHaveBeenCalledWith(
      props.element,
      [5],
      { fromUi: false },
      "myFragmentId"
    )
  })

  it("renders tick bar with min and max", () => {
    const props = getProps()
    render(<Slider {...props} />)

    const min = screen.getByTestId("stSliderTickBarMin")
    const max = screen.getByTestId("stSliderTickBarMax")
    expect(min).toHaveTextContent("0")
    expect(max).toHaveTextContent("10")
  })

  describe("Single value", () => {
    it("renders without crashing", () => {
      const props = getProps()
      render(<Slider {...props} />)

      const slider = screen.getByTestId("stSlider")
      expect(slider).toBeInTheDocument()
      expect(slider).toHaveClass("stSlider")
    })

    it("displays a thumb value", () => {
      const props = getProps()
      render(<Slider {...props} />)

      expect(screen.getAllByTestId("stSliderThumbValue")).toHaveLength(1)
    })

    it("has the correct value", () => {
      const props = getProps()
      render(<Slider {...props} />)

      const slider = screen.getByRole("slider")
      expect(slider).toHaveAttribute(
        "aria-valuetext",
        `${props.element.default}`
      )
      expect(slider).toHaveAttribute("aria-valuemin", `${props.element.min}`)
      expect(slider).toHaveAttribute("aria-valuemax", `${props.element.max}`)
    })

    it("handles value changes", () => {
      const props = getProps()

      render(<Slider {...props} />)
      vi.spyOn(props.widgetMgr, "setDoubleArrayValue")

      const slider = screen.getByRole("slider")

      act(() => {
        triggerChangeEvent(slider, "ArrowRight")

        // We need to do this as we are using a debounce when the widget value is set
        vi.runAllTimers()
      })

      expect(props.widgetMgr.setDoubleArrayValue).toHaveBeenCalledWith(
        props.element,
        [6],
        { fromUi: true },
        undefined
      )

      expect(slider).toHaveAttribute("aria-valuenow", "6")
    })

    it("resets its value when form is cleared", () => {
      // Create a widget in a clearOnSubmit form
      const props = getProps({ formId: "form" })
      props.widgetMgr.setFormSubmitBehaviors("form", true)

      render(<Slider {...props} />)

      vi.spyOn(props.widgetMgr, "setDoubleArrayValue")

      const slider = screen.getByRole("slider")

      triggerChangeEvent(slider, "ArrowRight")

      act(() => {
        vi.runAllTimers()
      })

      expect(props.widgetMgr.setDoubleArrayValue).toHaveBeenLastCalledWith(
        props.element,
        [6],
        { fromUi: true },
        undefined
      )

      expect(slider).toHaveAttribute("aria-valuenow", "6")

      act(() => {
        // "Submit" the form
        props.widgetMgr.submitForm("form", undefined)
      })

      // Our widget should be reset, and the widgetMgr should be updated
      expect(props.widgetMgr.setDoubleArrayValue).toHaveBeenLastCalledWith(
        props.element,
        props.element.default,
        {
          fromUi: true,
        },
        undefined
      )

      expect(slider).toHaveAttribute("aria-valuenow", "5")
    })
  })

  describe("Range value", () => {
    it("renders without crashing", () => {
      const props = getProps({ default: [1, 9] })
      render(<Slider {...props} />)

      const sliders = screen.getAllByRole("slider")
      expect(sliders).toHaveLength(2)
    })

    it("displays 2 thumb values", () => {
      const props = getProps({ default: [1, 9] })
      render(<Slider {...props} />)

      expect(screen.getAllByTestId("stSliderThumbValue")).toHaveLength(2)
    })

    it("has the correct value", () => {
      const props = getProps({ default: [1, 9] })
      render(<Slider {...props} />)

      const sliders = screen.getAllByRole("slider")
      // First slider - max is the current value of second slider
      expect(sliders[0]).toHaveAttribute(
        "aria-valuetext",
        `${props.element.default[0]}`
      )
      expect(sliders[0]).toHaveAttribute(
        "aria-valuemin",
        `${props.element.min}`
      )
      expect(sliders[0]).toHaveAttribute(
        "aria-valuemax",
        `${props.element.default[1]}`
      )

      // Second slider - min is the current value of first slider
      expect(sliders[1]).toHaveAttribute(
        "aria-valuetext",
        `${props.element.default[1]}`
      )
      expect(sliders[1]).toHaveAttribute(
        "aria-valuemin",
        `${props.element.default[0]}`
      )
      expect(sliders[1]).toHaveAttribute(
        "aria-valuemax",
        `${props.element.max}`
      )
    })

    describe("value should be within bounds", () => {
      it("start > end", () => {
        const props = getProps({ default: [5, 5] })
        render(<Slider {...props} />)

        const firstSlider = screen.getAllByRole("slider")[0]
        triggerChangeEvent(firstSlider, "ArrowRight")

        expect(screen.getAllByRole("slider")[0]).toHaveAttribute(
          "aria-valuenow",
          "5"
        )
      })

      it("start < min", () => {
        const props = getProps({ default: [0, 10] })
        render(<Slider {...props} />)

        const firstSlider = screen.getAllByRole("slider")[0]
        triggerChangeEvent(firstSlider, "ArrowLeft")

        expect(firstSlider).toHaveAttribute("aria-valuenow", "0")
      })

      it("start > max", () => {
        const props = getProps({ default: [10] })
        render(<Slider {...props} />)

        const slider = screen.getByRole("slider")
        triggerChangeEvent(slider, "ArrowRight")

        expect(slider).toHaveAttribute("aria-valuenow", "10")
      })

      it("end < min", () => {
        const props = getProps({ default: [0] })
        render(<Slider {...props} />)

        const slider = screen.getByRole("slider")
        triggerChangeEvent(slider, "ArrowLeft")

        expect(slider).toHaveAttribute("aria-valuenow", "0")
      })

      it("end > max", () => {
        const props = getProps({ default: [0, 10] })
        render(<Slider {...props} />)

        const secondSlider = screen.getAllByRole("slider")[1]
        triggerChangeEvent(secondSlider, "ArrowRight")

        expect(secondSlider).toHaveAttribute("aria-valuenow", "10")
      })
    })

    it("handles value changes", () => {
      const props = getProps({ default: [1, 9] })

      render(<Slider {...props} />)
      vi.spyOn(props.widgetMgr, "setDoubleArrayValue")

      const sliders = screen.getAllByRole("slider")

      triggerChangeEvent(sliders[1], "ArrowRight")

      act(() => {
        // We need to do this as we are using a debounce when the widget value is set
        vi.runAllTimers()
      })

      expect(props.widgetMgr.setDoubleArrayValue).toHaveBeenCalledWith(
        props.element,
        [1, 10],
        {
          fromUi: true,
        },
        undefined
      )
      expect(sliders[0]).toHaveAttribute("aria-valuenow", "1")
      expect(sliders[1]).toHaveAttribute("aria-valuenow", "10")
    })
  })

  describe("Datetime slider", () => {
    withTimezones(() => {
      it("formats min and max as dates", () => {
        const DAYS_IN_MICROS = 24 * 60 * 60 * 1000 * 1000
        const WEEK_IN_MICROS = 7 * DAYS_IN_MICROS

        const props = getProps({
          // The default value should be divisible by step.
          // Otherwise, we get a warning from `react-range`.
          default: [0],
          min: 0,
          max: 4 * WEEK_IN_MICROS,
          step: DAYS_IN_MICROS,
          format: "YYYY-MM-DD",
          dataType: SliderProto.DataType.DATETIME,
        })
        render(<Slider {...props} />)

        const min = screen.getByTestId("stSliderTickBarMin")
        const max = screen.getByTestId("stSliderTickBarMax")

        expect(min).toHaveTextContent("1970-01-01")
        expect(max).toHaveTextContent("1970-01-29")
      })
    })
  })

  describe("Options prop", () => {
    it("renders without crashing", () => {
      const props = getProps({
        default: [1],
        min: 0,
        max: 6,
        format: "%s",
        options: [
          "red",
          "orange",
          "yellow",
          "green",
          "blue",
          "indigo",
          "violet",
        ],
      })
      render(<Slider {...props} />)

      expect(screen.getByRole("slider")).toBeDefined()
    })

    it("sets aria-valuetext correctly", () => {
      const props = getProps({
        default: [1],
        min: 0,
        max: 6,
        format: "%s",
        options: [
          "red",
          "orange",
          "yellow",
          "green",
          "blue",
          "indigo",
          "violet",
        ],
      })
      render(<Slider {...props} />)
      const slider = screen.getByRole("slider")
      expect(slider).toHaveAttribute("aria-valuetext", "orange")
    })

    it("updates aria-valuetext correctly", () => {
      const originalProps = {
        default: [1],
        min: 0,
        max: 6,
        format: "%s",
        options: [
          "red",
          "orange",
          "yellow",
          "green",
          "blue",
          "indigo",
          "violet",
        ],
      }
      const props = getProps(originalProps)
      render(<Slider {...props} />)

      const slider = screen.getByRole("slider")
      triggerChangeEvent(slider, "ArrowRight")

      act(() => {
        // We need to do this as we are using a debounce when the widget value is set
        vi.runAllTimers()
      })

      expect(slider).toHaveAttribute("aria-valuetext", "yellow")
    })

    it("sets aria-valuetext correctly for a range", () => {
      const props = getProps({
        default: [1, 4],
        min: 0,
        max: 6,
        format: "%s",
        options: [
          "red",
          "orange",
          "yellow",
          "green",
          "blue",
          "indigo",
          "violet",
        ],
      })
      render(<Slider {...props} />)
      const sliders = screen.getAllByRole("slider")
      expect(sliders[0]).toHaveAttribute("aria-valuetext", "orange")
      expect(sliders[1]).toHaveAttribute("aria-valuetext", "blue")
    })
  })
})


================================================
File: /frontend/lib/src/components/widgets/Slider/Slider.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  memo,
  ReactElement,
  useCallback,
  useEffect,
  useRef,
  useState,
} from "react"

import pick from "lodash/pick"
import { StyleProps, Slider as UISlider } from "baseui/slider"
import { useTheme } from "@emotion/react"
import { sprintf } from "sprintf-js"
import moment from "moment"

import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  useBasicWidgetState,
  ValueWithSource,
} from "@streamlit/lib/src/hooks/useBasicWidgetState"
import { Slider as SliderProto } from "@streamlit/lib/src/proto"
import {
  debounce,
  labelVisibilityProtoValueToEnum,
} from "@streamlit/lib/src/util/utils"
import {
  StyledWidgetLabelHelp,
  WidgetLabel,
} from "@streamlit/lib/src/components/widgets/BaseWidget"
import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"

import {
  StyledThumb,
  StyledThumbValue,
  StyledTickBar,
  StyledTickBarItem,
} from "./styled-components"

const DEBOUNCE_TIME_MS = 200

export interface Props {
  disabled: boolean
  element: SliderProto
  widgetMgr: WidgetStateManager
  width: number
  fragmentId?: string
}

function Slider({
  disabled,
  element,
  widgetMgr,
  width,
  fragmentId,
}: Props): ReactElement {
  const [value, setValueWithSource] = useBasicWidgetState<
    number[],
    SliderProto
  >({
    getStateFromWidgetMgr,
    getDefaultStateFromProto,
    getCurrStateFromProto,
    updateWidgetMgrState,
    element,
    widgetMgr,
    fragmentId,
  })

  // We tie the UI to `uiValue` rather than `value` because `value` only updates
  // every DEBOUNCE_TIME_MS. If we tied the UI to `value` then the UI would only
  // update every DEBOUNCE_TIME_MS as well. So this keeps the UI smooth.
  const [uiValue, setUiValue] = useState(value)

  const sliderRef = useRef<HTMLDivElement | null>(null)
  const [thumbRefs] = useState<
    React.MutableRefObject<HTMLDivElement | null>[]
  >([])
  const [thumbValueRefs] = useState<
    React.MutableRefObject<HTMLDivElement | null>[]
  >([])

  const { colors, fonts, fontSizes, spacing } = useTheme()
  const style = { width }

  const formattedValueArr = uiValue.map(v => formatValue(v, element))
  const formattedMinValue = formatValue(element.min, element)
  const formattedMaxValue = formatValue(element.max, element)
  const thumbAriaLabel = element.label

  // When resetting a form, `value` will change so we need to change `uiValue`
  // to match.
  useEffect(() => {
    setUiValue(value)
  }, [value])

  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const debouncedSetValueWithSource = useCallback(
    debounce(DEBOUNCE_TIME_MS, (value: number[]): void => {
      setValueWithSource({ value, fromUi: true })
    }) as (value: number[]) => void,
    []
  )

  const handleChange = useCallback(
    ({ value }: { value: number[] }): void => {
      setUiValue(value)
      debouncedSetValueWithSource(value)
    },
    [debouncedSetValueWithSource]
  )

  const renderTickBar = useCallback((): ReactElement => {
    return (
      <StyledTickBar data-testid="stSliderTickBar">
        <StyledTickBarItem
          disabled={disabled}
          data-testid="stSliderTickBarMin"
        >
          {formattedMinValue}
        </StyledTickBarItem>
        <StyledTickBarItem
          disabled={disabled}
          data-testid="stSliderTickBarMax"
        >
          {formattedMaxValue}
        </StyledTickBarItem>
      </StyledTickBar>
    )
  }, [formattedMinValue, formattedMaxValue, disabled])

  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  // eslint-disable-next-line react-hooks/exhaustive-deps
  const renderThumb = useCallback(
    React.forwardRef<HTMLDivElement, StyleProps>(function renderThumb(
      props: StyleProps,
      ref
    ): ReactElement {
      const { $thumbIndex } = props
      const thumbIndex = $thumbIndex || 0
      thumbRefs[thumbIndex] = ref as React.MutableRefObject<HTMLDivElement>
      thumbValueRefs[thumbIndex] ||= React.createRef<HTMLDivElement>()

      const passThrough = pick(props, [
        "role",
        "style",
        "aria-valuemax",
        "aria-valuemin",
        "aria-valuenow",
        "tabIndex",
        "onKeyUp",
        "onKeyDown",
        "onMouseEnter",
        "onMouseLeave",
        "draggable",
      ])

      const formattedValue = formattedValueArr[thumbIndex]

      return (
        <StyledThumb
          {...passThrough}
          disabled={props.$disabled === true}
          ref={thumbRefs[thumbIndex]}
          aria-valuetext={formattedValue}
          aria-label={thumbAriaLabel}
        >
          <StyledThumbValue
            data-testid="stSliderThumbValue"
            disabled={props.$disabled === true}
            ref={thumbValueRefs[thumbIndex]}
          >
            {formattedValue}
          </StyledThumbValue>
        </StyledThumb>
      )
    }),
    // Only run this on first render, to avoid losing the focus state.
    // Then, when the value written about the thumb needs to change, that
    // happens with the function below instead.
    []
  )

  useEffect(() => {
    // Update the numbers on the thumb via DOM manipulation to avoid a redraw,
    // which drops the widget's focus state.
    thumbValueRefs.map((ref, i) => {
      if (ref.current) {
        ref.current.innerText = formattedValueArr[i]
      }
    })

    thumbRefs.map((ref, i) => {
      if (ref.current) {
        ref.current.setAttribute("aria-valuetext", formattedValueArr[i])
      }
    })

    // If, after rendering, the thumb value's is outside the container (too
    // far left or too far right), bring it inside. Or if there are two
    // thumbs and their values overlap, fix that.
    const sliderDiv = sliderRef.current ?? null
    const thumb1Div = thumbRefs[0].current
    const thumb2Div = thumbRefs[1]?.current
    const thumb1ValueDiv = thumbValueRefs[0].current
    const thumb2ValueDiv = thumbValueRefs[1]?.current

    fixLabelPositions(
      sliderDiv,
      thumb1Div,
      thumb2Div,
      thumb1ValueDiv,
      thumb2ValueDiv
    )
  })

  const innerTrackStyle = useCallback(
    ({ $disabled }: StyleProps) => ({
      height: spacing.twoXS,
      ...($disabled ? { background: colors.darkenedBgMix25 } : {}),
    }),
    [colors, spacing]
  )

  return (
    <div
      ref={sliderRef}
      className="stSlider"
      data-testid="stSlider"
      style={style}
    >
      <WidgetLabel
        label={element.label}
        disabled={disabled}
        labelVisibility={labelVisibilityProtoValueToEnum(
          element.labelVisibility?.value
        )}
      >
        {element.help && (
          <StyledWidgetLabelHelp>
            <TooltipIcon
              content={element.help}
              placement={Placement.TOP_RIGHT}
            />
          </StyledWidgetLabelHelp>
        )}
      </WidgetLabel>
      <UISlider
        min={element.min}
        max={element.max}
        step={element.step}
        value={getValueAsArray(uiValue, element)}
        onChange={handleChange}
        disabled={disabled}
        overrides={{
          Thumb: renderThumb,
          Tick: {
            style: {
              fontFamily: fonts.monospace,
            },
          },
          Track: {
            style: {
              backgroundColor: "none !important",
              paddingBottom: spacing.none,
              paddingLeft: spacing.none,
              paddingRight: spacing.none,
              // Add additional padding to fit the thumb value
              // which uses a fontSizes.sm.
              paddingTop: `calc(${fontSizes.sm} * 1.35)`,
            },
          },
          InnerTrack: {
            style: innerTrackStyle,
          },
          TickBar: renderTickBar,
        }}
      />
    </div>
  )
}

function getStateFromWidgetMgr(
  widgetMgr: WidgetStateManager,
  element: SliderProto
): number[] | undefined {
  return widgetMgr.getDoubleArrayValue(element)
}

function getDefaultStateFromProto(element: SliderProto): number[] {
  return element.default
}

function getCurrStateFromProto(element: SliderProto): number[] {
  return element.value
}

function updateWidgetMgrState(
  element: SliderProto,
  widgetMgr: WidgetStateManager,
  vws: ValueWithSource<number[]>,
  fragmentId?: string
): void {
  widgetMgr.setDoubleArrayValue(
    element,
    vws.value,
    { fromUi: vws.fromUi },
    fragmentId
  )
}

function isDateTimeType(element: SliderProto): boolean {
  const { dataType } = element
  return (
    dataType === SliderProto.DataType.DATETIME ||
    dataType === SliderProto.DataType.DATE ||
    dataType === SliderProto.DataType.TIME
  )
}

function formatValue(value: number, element: SliderProto): string {
  const { format, options } = element
  if (isDateTimeType(element)) {
    // Python datetime uses microseconds, but JS & Moment uses milliseconds
    // The timestamp is always set to the UTC timezone, even so, the actual timezone
    // for this timestamp in the backend could be different.
    // However, the frontend component does not need to know about the actual timezone.
    return moment.utc(value / 1000).format(format)
  }

  if (options.length > 0) {
    return sprintf(format, options[value])
  }

  return sprintf(format, value)
}

/**
 * Return the value of the slider. This will either be an array with
 * one value (for a single value slider), or an array with two
 * values (for a range slider).
 */
function getValueAsArray(value: number[], element: SliderProto): number[] {
  const { min, max } = element
  let start = value[0]
  let end = value.length > 1 ? value[1] : value[0]
  // Adjust the value if it's out of bounds.
  if (start > end) {
    start = end
  }
  if (start < min) {
    start = min
  }
  if (start > max) {
    start = max
  }
  if (end < min) {
    end = min
  }
  if (end > max) {
    end = max
  }
  return value.length > 1 ? [start, end] : [start]
}

function fixLabelPositions(
  sliderDiv: HTMLDivElement | null,
  thumb1Div: HTMLDivElement | null,
  thumb2Div: HTMLDivElement | null,
  thumb1ValueDiv: HTMLDivElement | null,
  thumb2ValueDiv: HTMLDivElement | null
): void {
  if (!sliderDiv || !thumb1Div || !thumb1ValueDiv) {
    return
  }

  fixLabelOverflow(sliderDiv, thumb1Div, thumb1ValueDiv)

  if (thumb2Div && thumb2ValueDiv) {
    fixLabelOverflow(sliderDiv, thumb2Div, thumb2ValueDiv)

    // If two thumbs.
    fixLabelOverlap(
      sliderDiv,
      thumb1Div,
      thumb2Div,
      thumb1ValueDiv,
      thumb2ValueDiv
    )
  }
}

function fixLabelOverflow(
  slider: HTMLDivElement,
  thumb: HTMLDivElement,
  thumbValue: HTMLDivElement
): void {
  const sliderRect = slider.getBoundingClientRect()
  const thumbRect = thumb.getBoundingClientRect()
  const thumbValueRect = thumbValue.getBoundingClientRect()

  const thumbMidpoint = thumbRect.left + thumbRect.width / 2
  const thumbValueOverflowsLeft =
    thumbMidpoint - thumbValueRect.width / 2 < sliderRect.left
  const thumbValueOverflowsRight =
    thumbMidpoint + thumbValueRect.width / 2 > sliderRect.right

  thumbValue.style.left = thumbValueOverflowsLeft ? "0" : ""
  thumbValue.style.right = thumbValueOverflowsRight ? "0" : ""
}

/**
 * Goals:
 * - Keep the thumb values near their respective thumbs.
 * - Keep thumb values within the bounds of the slider.
 * - Avoid visual jank while moving the thumbs
 */
function fixLabelOverlap(
  sliderDiv: HTMLDivElement,
  thumb1Div: HTMLDivElement,
  thumb2Div: HTMLDivElement,
  thumb1ValueDiv: HTMLDivElement,
  thumb2ValueDiv: HTMLDivElement
): void {
  const labelGap = 24

  const sliderRect = sliderDiv.getBoundingClientRect()
  const thumb1Rect = thumb1Div.getBoundingClientRect()
  const thumb2Rect = thumb2Div.getBoundingClientRect()
  const thumb1ValueRect = thumb1ValueDiv.getBoundingClientRect()
  const thumb2ValueRect = thumb2ValueDiv.getBoundingClientRect()

  const sliderMidpoint = sliderRect.left + sliderRect.width / 2
  const thumb1MidPoint = thumb1Rect.left + thumb1Rect.width / 2
  const thumb2MidPoint = thumb2Rect.left + thumb2Rect.width / 2

  const centeredThumb1ValueFitsLeft =
    thumb1MidPoint - thumb1ValueRect.width / 2 >= sliderRect.left

  const centeredThumb2ValueFitsRight =
    thumb2MidPoint + thumb2ValueRect.width / 2 <= sliderRect.right

  const leftAlignedThumb1ValueFitsLeft =
    thumb1Rect.left - thumb1ValueRect.width >= sliderRect.left

  const rightAlignedThumb2ValueFitsRight =
    thumb2Rect.right + thumb2ValueRect.width <= sliderRect.right

  const thumb1ValueOverhang = centeredThumb1ValueFitsLeft
    ? thumb1ValueRect.width / 2
    : thumb1ValueRect.width

  const thumb2ValueOverhang = centeredThumb2ValueFitsRight
    ? thumb2ValueRect.width / 2
    : thumb2ValueRect.width

  const thumb1ValueInnerEdge = thumb1MidPoint + thumb1ValueOverhang
  const thumb2ValueInnerEdge = thumb2MidPoint - thumb2ValueOverhang
  const thumbsAreFarApart =
    thumb2ValueInnerEdge - thumb1ValueInnerEdge > labelGap

  // If thumbs are far apart, just handle each separately.
  //
  // 1. Center values on their thumbs, like this:
  //
  //        [thumb1Value]       [thumb1Value]
  // |--------[thumb1]-------------[thumb2]-------------------|
  //
  //
  // 2. If one of the thumbs is so close to the edge that centering would cause
  // the value to overflow past the edge, align the value away from the edge.
  // (This is the normal fixLabelOverflow() behavior)
  //
  // For example, let's say thumb1 moved to the left:
  //
  //     [thumb1Value]          [thumb2Value]
  // |---[thumb1]------------------[thumb2]-------------------|
  //
  //
  if (thumbsAreFarApart) {
    fixLabelOverflow(sliderDiv, thumb1Div, thumb1ValueDiv)
    fixLabelOverflow(sliderDiv, thumb2Div, thumb2ValueDiv)
    return
  }

  // If thumbs are close, try different things...

  // 3. If thumbs are so close that centering would cause values to
  // overlap, then place the values to the side of their thumbs, away from
  // the opposing thumbs:
  //
  // For example, if starting from case #1 above we moved thumb1 to the
  // right:
  //
  //      [thumb1Value]                    [thumb2Value]
  // |-----------------[thumb1]----[thumb2]-------------------|
  //
  // Note: round all values to not have weird decimal pixels (that make our Snapshot tests flaky)
  if (leftAlignedThumb1ValueFitsLeft && rightAlignedThumb2ValueFitsRight) {
    // Align value1 to the left of its thumb.
    thumb1ValueDiv.style.left = ""
    thumb1ValueDiv.style.right = `${Math.round(thumb1Rect.width)}px`

    // Align value2 to the right of its thumb.
    thumb2ValueDiv.style.left = `${Math.round(thumb2Rect.width)}px`
    thumb2ValueDiv.style.right = ""

    return
  }

  // 4. If one of the thumbs is so close to the edge that doing the outward
  // alignment from #3 would cause its value to overflow past the edge, then
  // try centering the value. And place the other thumb's value right next to
  // it, to avoid overlaps.
  //
  // For example, if we moved thumb1 and thumb2 to the left by the same
  // amount:
  //
  //    [thumb1Value][thumb2Value]
  // |----[thumb1]--[thumb2]----------------------------------|
  //
  //
  // 5. If one of the thumbs is so close to the edge that doing the center
  // alignment from #4 would cause its value to overflow past the edge, then
  // align it with its thumb, pointing inward. And, like in #4, place the
  // other thumb's value right next to it to avoid overlaps.
  //
  // For example, if we moved thumb1 to the left, and moved thumb2 even more:
  //
  //   [thumb1Value][thumb2Value]
  // |-[thumb1]--[thumb2]-------------------------------------|
  //

  const jointThumbsAreOnLeftHalf = thumb1MidPoint < sliderMidpoint

  if (jointThumbsAreOnLeftHalf) {
    fixLabelOverflow(sliderDiv, thumb1Div, thumb1ValueDiv)

    // Make thumb2Value appear to the right of thumb1Value.
    thumb2ValueDiv.style.left = `${Math.round(
      thumb1MidPoint + thumb1ValueOverhang + labelGap - thumb2MidPoint
    )}px`
    thumb2ValueDiv.style.right = ""
  } else {
    fixLabelOverflow(sliderDiv, thumb2Div, thumb2ValueDiv)

    // Make thumb1Value appear to the left of thumb2Value.
    thumb1ValueDiv.style.left = ""
    thumb1ValueDiv.style.right = `${-Math.round(
      thumb2MidPoint - thumb2ValueOverhang - labelGap - thumb1MidPoint
    )}px`
  }
}

export default memo(Slider)


================================================
File: /frontend/lib/src/components/widgets/Slider/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Slider"


================================================
File: /frontend/lib/src/components/widgets/Slider/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"
import { transparentize } from "color2k"

export interface StyledSliderProps {
  disabled: boolean
}

export const StyledThumb = styled.div<StyledSliderProps>(
  ({ disabled, theme }) => ({
    alignItems: "center",
    backgroundColor: disabled ? theme.colors.gray : theme.colors.primary,
    borderTopLeftRadius: "100%",
    borderTopRightRadius: "100%",
    borderBottomLeftRadius: "100%",
    borderBottomRightRadius: "100%",
    borderTopStyle: "none",
    borderBottomStyle: "none",
    borderRightStyle: "none",
    borderLeftStyle: "none",
    boxShadow: "none",
    display: "flex",
    justifyContent: "center",
    height: theme.sizes.sliderThumb,
    width: theme.sizes.sliderThumb,
    ":focus": {
      outline: "none",
    },
    ":focus-visible": {
      boxShadow: `0 0 0 0.2rem ${transparentize(theme.colors.primary, 0.5)}`,
    },
  })
)

export const StyledThumbValue = styled.div<StyledSliderProps>(
  ({ disabled, theme }) => ({
    fontFamily: theme.genericFonts.codeFont,
    fontSize: theme.fontSizes.sm,
    color: disabled ? theme.colors.gray : theme.colors.primary,
    top: "-1.6em",
    position: "absolute",
    whiteSpace: "nowrap",
    backgroundColor: theme.colors.transparent,
    lineHeight: theme.lineHeights.base,
    fontWeight: theme.fontWeights.normal,
    // If values are clickable, it's hard to move the right thumb when they're
    // very close. So make them unclickable:
    pointerEvents: "none",
  })
)

export const StyledTickBar = styled.div(({ theme }) => ({
  fontSize: theme.fontSizes.sm,
  paddingBottom: theme.spacing.none,
  paddingLeft: theme.spacing.none,
  paddingRight: theme.spacing.none,
  paddingTop: "0.65em",
  justifyContent: "space-between",
  alignItems: "center",
  display: "flex",
}))

export const StyledTickBarItem = styled.div<StyledSliderProps>(
  ({ disabled, theme }) => ({
    lineHeight: theme.lineHeights.base,
    fontWeight: theme.fontWeights.normal,
    fontFamily: theme.genericFonts.codeFont,
    color: disabled ? theme.colors.fadedText40 : "inherit",
  })
)


================================================
File: /frontend/lib/src/components/widgets/TextArea/TextArea.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import {
  LabelVisibilityMessage as LabelVisibilityMessageProto,
  TextArea as TextAreaProto,
} from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"

import TextArea, { Props } from "./TextArea"

const getProps = (
  elementProps: Partial<TextAreaProto> = {},
  widgetProps: Partial<Props> = {}
): Props => ({
  element: TextAreaProto.create({
    id: "1",
    label: "Label",
    default: "",
    placeholder: "Placeholder",
    ...elementProps,
  }),
  width: 300,
  disabled: false,
  widgetMgr: new WidgetStateManager({
    sendRerunBackMsg: vi.fn(),
    formsDataChanged: vi.fn(),
  }),

  ...widgetProps,
})

describe("TextArea widget", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<TextArea {...props} />)

    const textArea = screen.getByRole("textbox")
    expect(textArea).toBeInTheDocument()
  })

  it("sets widget value on mount", () => {
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TextArea {...props} />)

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledWith(
      props.element,
      props.element.default,
      { fromUi: false },
      undefined
    )
  })

  it("can pass fragmentId to setStringValue", () => {
    const props = getProps(undefined, { fragmentId: "myFragmentId" })
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TextArea {...props} />)

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledWith(
      props.element,
      props.element.default,
      { fromUi: false },
      "myFragmentId"
    )
  })

  it("has correct className and style", () => {
    const props = getProps()
    render(<TextArea {...props} />)
    const textArea = screen.getByTestId("stTextArea")

    expect(textArea).toHaveClass("stTextArea")
    expect(textArea).toHaveStyle(`width: ${props.width}px`)
  })

  it("renders a label", () => {
    const props = getProps()
    render(<TextArea {...props} />)

    const widgetLabel = screen.getByText(`${props.element.label}`)
    expect(widgetLabel).toBeInTheDocument()
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when hidden", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.HIDDEN,
      },
    })
    render(<TextArea {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle(
      "visibility: hidden"
    )
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when collapsed", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.COLLAPSED,
      },
    })
    render(<TextArea {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle("display: none")
  })

  it("has a default value", () => {
    const props = getProps()
    render(<TextArea {...props} />)

    const textArea = screen.getByRole("textbox")
    expect(textArea).toHaveValue(props.element.default)
  })

  it("renders a placeholder", () => {
    const props = getProps()
    render(<TextArea {...props} />)

    const textArea = screen.getByRole("textbox")
    expect(textArea).toHaveAttribute("placeholder", props.element.placeholder)
  })

  it("can be disabled", () => {
    const props = getProps({}, { disabled: true })
    render(<TextArea {...props} />)

    const textArea = screen.getByRole("textbox")
    expect(textArea).toBeDisabled()
  })

  it("sets widget value on blur", async () => {
    const user = userEvent.setup()
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TextArea {...props} />)

    const textArea = screen.getByRole("textbox")
    await user.type(textArea, "testing")
    // Blur the textarea
    await user.tab()

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledWith(
      props.element,
      "testing",
      {
        fromUi: true,
      },
      undefined
    )
  })

  it("sets widget value when ctrl+enter is pressed", async () => {
    const user = userEvent.setup()
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TextArea {...props} />)

    const textArea = screen.getByRole("textbox")
    await user.type(textArea, "testing")
    await user.keyboard("{Control>}{Enter}")

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledWith(
      props.element,
      "testing",
      {
        fromUi: true,
      },
      undefined
    )
  })

  it("limits the length if max_chars is passed", async () => {
    const user = userEvent.setup()
    const props = getProps({
      height: 500,
      maxChars: 10,
    })
    render(<TextArea {...props} />)

    const textArea = screen.getByRole("textbox")
    await user.type(textArea, "0123456789")
    expect(textArea).toHaveValue("0123456789")

    await user.type(textArea, "a")
    expect(textArea).toHaveValue("0123456789")
  })

  it("does not update widget value on text changes when outside of a form", async () => {
    const user = userEvent.setup()
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TextArea {...props} />)

    const textArea = screen.getByRole("textbox")
    await user.type(textArea, "TEST")

    // Check that the last call was in componentDidMount.
    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      props.element.default,
      {
        fromUi: false,
      },
      undefined
    )
  })

  it("hides Please enter to apply text when width is smaller than 180px", async () => {
    const user = userEvent.setup()
    const props = getProps({}, { width: 100 })
    render(<TextArea {...props} />)

    const textArea = screen.getByRole("textbox")
    await user.click(textArea)

    expect(screen.queryByTestId("InputInstructions")).not.toBeInTheDocument()
  })

  it("shows Please enter to apply text when width is bigger than 180px", async () => {
    const user = userEvent.setup()
    const props = getProps({}, { width: 190 })
    render(<TextArea {...props} />)

    const textArea = screen.getByRole("textbox")
    await user.click(textArea)

    expect(screen.getByTestId("InputInstructions")).toBeInTheDocument()
  })

  it("resets its value when form is cleared", async () => {
    const user = userEvent.setup()
    // Create a widget in a clearOnSubmit form
    const props = getProps({ formId: "form" })
    props.widgetMgr.setFormSubmitBehaviors("form", true)

    vi.spyOn(props.widgetMgr, "setStringValue")

    render(<TextArea {...props} />)

    // Change the widget value
    const textArea = screen.getByRole("textbox")
    await user.type(textArea, "TEST")
    expect(textArea).toHaveValue("TEST")

    // "Submit" the form
    props.widgetMgr.submitForm("form", undefined)

    // Our widget should be reset, and the widgetMgr should be updated
    expect(textArea).toHaveValue(props.element.default)
    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      props.element.default,
      {
        fromUi: true,
      },
      undefined
    )
  })

  it("shows Input Instructions on dirty state when not in form (by default)", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<TextArea {...props} />)

    // Trigger dirty state
    const textArea = screen.getByRole("textbox")
    await user.click(textArea)
    await user.keyboard("TEST")

    expect(screen.getByText("Press +Enter to apply")).toBeVisible()
  })

  it("shows Input Instructions if in form that allows submit on enter", async () => {
    const user = userEvent.setup()
    const props = getProps({ formId: "form" })
    vi.spyOn(props.widgetMgr, "allowFormEnterToSubmit").mockReturnValue(true)

    render(<TextArea {...props} />)

    // Trigger dirty state
    const textArea = screen.getByRole("textbox")
    await user.click(textArea)
    await user.keyboard("TEST")

    expect(screen.getByText("Press +Enter to submit form")).toBeVisible()
  })

  // For this scenario https://github.com/streamlit/streamlit/issues/7079
  it("shows Input Instructions if focused again in form that allows submit on enter", async () => {
    const user = userEvent.setup()
    const props = getProps({ formId: "form" })
    vi.spyOn(props.widgetMgr, "allowFormEnterToSubmit").mockReturnValue(true)

    render(<TextArea {...props} />)

    const textArea = screen.getByRole("textbox")
    await user.click(textArea)
    await user.keyboard("TEST")

    // Remove focus
    textArea.blur()
    expect(screen.queryByTestId("InputInstructions")).not.toBeInTheDocument()

    // Then focus again
    textArea.focus()
    expect(screen.getByText("Press +Enter to submit form")).toBeVisible()
  })

  it("hides Input Instructions if in form that doesn't allow submit on enter", async () => {
    const user = userEvent.setup()
    const props = getProps({ formId: "form" })
    vi.spyOn(props.widgetMgr, "allowFormEnterToSubmit").mockReturnValue(false)

    render(<TextArea {...props} />)

    // Trigger dirty state
    const textArea = screen.getByRole("textbox")
    await user.click(textArea)
    await user.keyboard("TEST")

    expect(screen.queryByTestId("InputInstructions")).toHaveTextContent("")
  })

  it("focuses input when clicking label", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<TextArea {...props} />)
    const textArea = screen.getByRole("textbox")
    expect(textArea).not.toHaveFocus()
    const label = screen.getByText(props.element.label)
    await user.click(label)
    expect(textArea).toHaveFocus()
  })

  describe("on mac", () => {
    Object.defineProperty(navigator, "platform", {
      value: "MacIntel",
      writable: true,
    })

    it("sets widget value when +enter is pressed", async () => {
      const user = userEvent.setup()
      const props = getProps()
      vi.spyOn(props.widgetMgr, "setStringValue")
      render(<TextArea {...props} />)
      const textArea = screen.getByRole("textbox")
      await user.type(textArea, "testing")
      await user.keyboard("{Meta>}{Enter}")

      expect(props.widgetMgr.setStringValue).toHaveBeenCalledWith(
        props.element,
        "testing",
        {
          fromUi: true,
        },
        undefined
      )
    })
  })

  it("ensures id doesn't change on rerender", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<TextArea {...props} />)

    const textAreaLabel1 = screen.getByTestId("stWidgetLabel")
    const forId1 = textAreaLabel1.getAttribute("for")

    // Make some change to cause a rerender
    const textArea = screen.getByRole("textbox")
    await user.type(textArea, "testing")
    textArea.blur()

    const textAreaLabel2 = screen.getByTestId("stWidgetLabel")
    const forId2 = textAreaLabel2.getAttribute("for")

    expect(forId2).toBe(forId1)
  })
})


================================================
File: /frontend/lib/src/components/widgets/TextArea/TextArea.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, memo, useCallback, useRef, useState } from "react"

import { Textarea as UITextArea } from "baseui/textarea"
import { useTheme } from "@emotion/react"
import uniqueId from "lodash/uniqueId"

import { TextArea as TextAreaProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import useUpdateUiValue from "@streamlit/lib/src/hooks/useUpdateUiValue"
import useSubmitFormViaEnterKey from "@streamlit/lib/src/hooks/useSubmitFormViaEnterKey"
import useOnInputChange from "@streamlit/lib/src/hooks/useOnInputChange"
import InputInstructions from "@streamlit/lib/src/components/shared/InputInstructions/InputInstructions"
import {
  StyledWidgetLabelHelp,
  WidgetLabel,
} from "@streamlit/lib/src/components/widgets/BaseWidget"
import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"
import {
  isInForm,
  labelVisibilityProtoValueToEnum,
} from "@streamlit/lib/src/util/utils"
import { EmotionTheme } from "@streamlit/lib/src/theme"
import {
  useBasicWidgetState,
  ValueWithSource,
} from "@streamlit/lib/src/hooks/useBasicWidgetState"

export interface Props {
  disabled: boolean
  element: TextAreaProto
  widgetMgr: WidgetStateManager
  width: number
  fragmentId?: string
}

type TextAreaValue = string | null

const getStateFromWidgetMgr = (
  widgetMgr: WidgetStateManager,
  element: TextAreaProto
): TextAreaValue | undefined => {
  return widgetMgr.getStringValue(element) ?? element.default ?? null
}

const getDefaultStateFromProto = (element: TextAreaProto): TextAreaValue => {
  return element.default ?? null
}

const getCurrStateFromProto = (element: TextAreaProto): TextAreaValue => {
  return element.value ?? null
}

const updateWidgetMgrState = (
  element: TextAreaProto,
  widgetMgr: WidgetStateManager,
  valueWithSource: ValueWithSource<TextAreaValue>,
  fragmentId?: string
): void => {
  widgetMgr.setStringValue(
    element,
    valueWithSource.value,
    { fromUi: valueWithSource.fromUi },
    fragmentId
  )
}

const TextArea: FC<Props> = ({
  disabled,
  element,
  widgetMgr,
  fragmentId,
  width,
}) => {
  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  const id = useRef(uniqueId("text_area_")).current

  /**
   * True if the user-specified state.value has not yet been synced to the WidgetStateManager.
   */
  const [dirty, setDirty] = useState(false)
  /**
   * Whether the area is currently focused.
   */
  const [focused, setFocused] = useState(false)

  /**
   * The value specified by the user via the UI. If the user didn't touch this
   * widget's UI, the default value is used.
   */
  const [uiValue, setUiValue] = useState<string | null>(
    getStateFromWidgetMgr(widgetMgr, element) ?? null
  )

  const onFormCleared = useCallback(() => {
    setUiValue(element.default ?? null)
    setDirty(true)
  }, [element])

  const [value, setValueWithSource] = useBasicWidgetState<
    TextAreaValue,
    TextAreaProto
  >({
    getStateFromWidgetMgr,
    getDefaultStateFromProto,
    getCurrStateFromProto,
    updateWidgetMgrState,
    element,
    widgetMgr,
    fragmentId,
    onFormCleared,
  })

  useUpdateUiValue(value, uiValue, setUiValue, dirty)

  const theme: EmotionTheme = useTheme()

  const commitWidgetValue = useCallback((): void => {
    setDirty(false)
    setValueWithSource({ value: uiValue, fromUi: true })
  }, [uiValue, setValueWithSource])

  const onBlur = useCallback(() => {
    if (dirty) {
      commitWidgetValue()
    }
    setFocused(false)
  }, [dirty, commitWidgetValue])

  const onFocus = useCallback(() => {
    setFocused(true)
  }, [])

  const onChange = useOnInputChange({
    formId: element.formId,
    maxChars: element.maxChars,
    setDirty,
    setUiValue,
    setValueWithSource,
  })

  const onKeyDown = useSubmitFormViaEnterKey(
    element.formId,
    commitWidgetValue,
    dirty,
    widgetMgr,
    fragmentId,
    true
  )

  const style = { width }
  const { height, placeholder, formId } = element

  // Show "Please enter" instructions if in a form & allowed, or not in form and state is dirty.
  const allowEnterToSubmit = isInForm({ formId })
    ? widgetMgr.allowFormEnterToSubmit(formId)
    : dirty

  // Hide input instructions for small widget sizes.
  const shouldShowInstructions =
    focused && width > theme.breakpoints.hideWidgetDetails

  return (
    <div className="stTextArea" data-testid="stTextArea" style={style}>
      <WidgetLabel
        label={element.label}
        disabled={disabled}
        labelVisibility={labelVisibilityProtoValueToEnum(
          element.labelVisibility?.value
        )}
        htmlFor={id}
      >
        {element.help && (
          <StyledWidgetLabelHelp>
            <TooltipIcon
              content={element.help}
              placement={Placement.TOP_RIGHT}
            />
          </StyledWidgetLabelHelp>
        )}
      </WidgetLabel>
      <UITextArea
        value={uiValue ?? ""}
        placeholder={placeholder}
        onBlur={onBlur}
        onFocus={onFocus}
        onChange={onChange}
        onKeyDown={onKeyDown}
        aria-label={element.label}
        disabled={disabled}
        id={id}
        overrides={{
          Input: {
            style: {
              lineHeight: theme.lineHeights.inputWidget,

              // The default height of the text area is calculated to perfectly fit 3 lines of text.
              height: height ? `${height}px` : "",
              minHeight: theme.sizes.largestElementHeight,
              resize: "vertical",
              "::placeholder": {
                opacity: "0.7",
              },
              // Baseweb requires long-hand props, short-hand leads to weird bugs & warnings.
              paddingRight: theme.spacing.lg,
              paddingLeft: theme.spacing.lg,
              paddingBottom: theme.spacing.lg,
              paddingTop: theme.spacing.lg,
            },
          },
          Root: {
            props: {
              "data-testid": "stTextAreaRootElement",
            },
            style: {
              // Baseweb requires long-hand props, short-hand leads to weird bugs & warnings.
              borderLeftWidth: theme.sizes.borderWidth,
              borderRightWidth: theme.sizes.borderWidth,
              borderTopWidth: theme.sizes.borderWidth,
              borderBottomWidth: theme.sizes.borderWidth,
            },
          },
        }}
      />
      {shouldShowInstructions && (
        <InputInstructions
          dirty={dirty}
          value={uiValue ?? ""}
          maxLength={element.maxChars}
          type={"multiline"}
          inForm={isInForm({ formId })}
          allowEnterToSubmit={allowEnterToSubmit}
        />
      )}
    </div>
  )
}

export default memo(TextArea)


================================================
File: /frontend/lib/src/components/widgets/TextArea/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./TextArea"


================================================
File: /frontend/lib/src/components/widgets/TextInput/TextInput.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { act, screen, within } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  LabelVisibilityMessage as LabelVisibilityMessageProto,
  TextInput as TextInputProto,
} from "@streamlit/lib/src/proto"

import TextInput, { Props } from "./TextInput"

const getProps = (
  elementProps: Partial<TextInputProto> = {},
  widgetProps: Partial<Props> = {}
): Props => ({
  element: TextInputProto.create({
    label: "Label",
    default: "",
    placeholder: "Placeholder",
    type: TextInputProto.Type.DEFAULT,
    ...elementProps,
  }),
  width: 300,
  disabled: false,
  widgetMgr: new WidgetStateManager({
    sendRerunBackMsg: vi.fn(),
    formsDataChanged: vi.fn(),
  }),
  ...widgetProps,
})

describe("TextInput widget", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<TextInput {...props} />)

    const textInput = screen.getByRole("textbox")
    expect(textInput).toBeInTheDocument()
  })

  it("shows a label", () => {
    const props = getProps()
    render(<TextInput {...props} />)

    const widgetLabel = screen.getByText(`${props.element.label}`)
    expect(widgetLabel).toBeInTheDocument()
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when hidden", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.HIDDEN,
      },
    })

    render(<TextInput {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle(
      "visibility: hidden"
    )
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when collapsed", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.COLLAPSED,
      },
    })
    render(<TextInput {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle("display: none")
  })

  it("shows a placeholder", () => {
    const props = getProps()
    render(<TextInput {...props} />)

    const textInput = screen.getByRole("textbox")
    expect(textInput).toHaveAttribute("placeholder", props.element.placeholder)
  })

  it("handles default text input type properly", () => {
    const defaultProps = getProps({ type: TextInputProto.Type.DEFAULT })
    render(<TextInput {...defaultProps} />)
    const textInput = screen.getByRole("textbox")
    expect(textInput).toHaveAttribute("type", "text")
    // Check that no show/hide button renders
    const textInputContainer = screen.getByTestId("stTextInputRootElement")
    const showButton = within(textInputContainer).queryByRole("button")
    expect(showButton).not.toBeInTheDocument()
  })

  it("handles password text input type properly", () => {
    const passwordProps = getProps({ type: TextInputProto.Type.PASSWORD })
    render(<TextInput {...passwordProps} />)
    const passwordTextInput = screen.getByPlaceholderText("Placeholder")
    expect(passwordTextInput).toHaveAttribute("type", "password")
    // Check for the show/hide button
    const textInputContainer = screen.getByTestId("stTextInputRootElement")
    const showButton = within(textInputContainer).getByRole("button")
    expect(showButton).toBeInTheDocument()
  })

  it("handles TextInputProto.autocomplete", () => {
    let props = getProps()
    const { unmount } = render(<TextInput {...props} />)
    const textInput = screen.getByRole("textbox")
    expect(textInput).toHaveAttribute("autoComplete", "")
    // unmount the initial component
    unmount()

    props = getProps({ autocomplete: "one-time-password" })
    render(<TextInput {...props} />)
    const autocompleteTextInput = screen.getByRole("textbox")
    expect(autocompleteTextInput).toHaveAttribute(
      "autoComplete",
      "one-time-password"
    )
  })

  it("sets widget value on mount", () => {
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TextInput {...props} />)

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledWith(
      props.element,
      props.element.default,
      { fromUi: false },
      undefined
    )
  })

  it("can pass fragmentId to setStringValue", () => {
    const props = getProps(undefined, { fragmentId: "myFragmentId" })
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TextInput {...props} />)

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledWith(
      props.element,
      props.element.default,
      { fromUi: false },
      "myFragmentId"
    )
  })

  it("has correct className and style", () => {
    const props = getProps()
    render(<TextInput {...props} />)
    const textInput = screen.getByTestId("stTextInput")

    expect(textInput).toHaveClass("stTextInput")
    expect(textInput).toHaveStyle(`width: ${props.width}px`)
  })

  it("can be disabled", () => {
    const props = getProps({}, { disabled: true })
    render(<TextInput {...props} />)
    const textInput = screen.getByRole("textbox")
    expect(textInput).toBeDisabled()
  })

  it("sets widget value on blur", async () => {
    const user = userEvent.setup()
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TextInput {...props} />)

    const textInput = screen.getByRole("textbox")
    await user.type(textInput, "testing")
    // Blur the input
    await user.tab()

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledWith(
      props.element,
      "testing",
      {
        fromUi: true,
      },
      undefined
    )
  })

  it("sets widget value when enter is pressed", async () => {
    const user = userEvent.setup()
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TextInput {...props} />)
    const textInput = screen.getByRole("textbox")

    // userEvent necessary to trigger onKeyPress
    // fireEvent only dispatches DOM events vs. simulating full interactions
    await user.click(textInput)
    await user.keyboard("testing{Enter}")

    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      "testing",
      {
        fromUi: true,
      },
      undefined
    )
  })

  it("does not sync widget value when value did not change", async () => {
    const user = userEvent.setup()
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TextInput {...props} />)
    const textInput = screen.getByRole("textbox")

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledTimes(1)

    // userEvent necessary to trigger onKeyPress
    // fireEvent only dispatches DOM events vs. simulating full interactions
    await user.click(textInput)
    await user.keyboard("testing{Enter}")

    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      "testing",
      {
        fromUi: true,
      },
      undefined
    )
    expect(props.widgetMgr.setStringValue).toHaveBeenCalledTimes(2)

    // losing focus after value changed triggers a server sync
    await user.click(textInput)
    await user.keyboard("moreTesting")
    // click somewhere to lose focus on the input
    await user.click(document.body)

    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      "testingmoreTesting",
      {
        fromUi: true,
      },
      undefined
    )
    expect(props.widgetMgr.setStringValue).toHaveBeenCalledTimes(3)

    // focusing and clicking enter again without changing the value does
    // not trigger a server-sync and, thus, no re-run
    await user.click(textInput)
    await user.keyboard("{enter}")
    expect(props.widgetMgr.setStringValue).toHaveBeenCalledTimes(3)

    // focusing and losing focus without changing the value does
    // not trigger a server-sync and, thus, no re-run
    await user.click(textInput)
    await user.click(document.body)
    expect(props.widgetMgr.setStringValue).toHaveBeenCalledTimes(3)
  })

  it("doesn't set widget value when not dirty", async () => {
    const user = userEvent.setup()
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TextInput {...props} />)

    const textInput = screen.getByRole("textbox")
    await user.keyboard("{Enter}")

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledTimes(1)

    textInput.blur()
    expect(props.widgetMgr.setStringValue).toHaveBeenCalledTimes(1)
  })

  it("limits input length if max_chars is passed", async () => {
    const user = userEvent.setup()
    const props = getProps({ maxChars: 10 })
    render(<TextInput {...props} />)

    const textInput = screen.getByRole("textbox")
    await user.type(textInput, "0123456789")
    expect(textInput).toHaveValue("0123456789")

    await user.type(textInput, "a")
    expect(textInput).toHaveValue("0123456789")
  })

  it("does update widget value on text changes when inside of a form", async () => {
    const user = userEvent.setup()
    const props = getProps({ formId: "formId" })
    const setStringValueSpy = vi.spyOn(props.widgetMgr, "setStringValue")
    vi.spyOn(props.widgetMgr, "allowFormEnterToSubmit").mockReturnValue(true)

    render(<TextInput {...props} />)

    const textInput = screen.getByRole("textbox")
    await user.type(textInput, "TEST")
    expect(textInput).toHaveValue("TEST")

    textInput.focus()
    expect(
      await screen.findByText("Press Enter to submit form")
    ).toBeInTheDocument()

    expect(setStringValueSpy).toHaveBeenCalledWith(
      props.element,
      "TEST",
      {
        fromUi: true,
      },
      undefined
    )
  })

  it("does not update widget value on text changes when outside of a form", async () => {
    const user = userEvent.setup()
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TextInput {...props} />)

    const textInput = screen.getByRole("textbox")
    await user.type(textInput, "TEST")
    expect(textInput).toHaveValue("TEST")

    textInput.focus()
    expect(await screen.findByText("Press Enter to apply")).toBeInTheDocument()

    // Check that the last call was in componentDidMount.
    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      props.element.default,
      {
        fromUi: false,
      },
      undefined
    )
  })

  it("resets its value when form is cleared", async () => {
    const user = userEvent.setup()
    // Create a widget in a clearOnSubmit form
    const props = getProps({ formId: "form" })
    props.widgetMgr.setFormSubmitBehaviors("form", true)

    vi.spyOn(props.widgetMgr, "setStringValue")

    render(<TextInput {...props} />)
    const textInput = screen.getByRole("textbox")
    // Change the widget value
    await user.type(textInput, "TEST")

    act(() => {
      // "Submit" the form
      props.widgetMgr.submitForm("form", undefined)
    })

    // Our widget should be reset, and the widgetMgr should be updated
    expect(textInput).toHaveValue(props.element.default)
    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      props.element.default,
      {
        fromUi: true,
      },
      undefined
    )
  })

  it("shows Input Instructions on dirty state by default", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<TextInput {...props} />)

    // Trigger dirty state
    const textInput = screen.getByRole("textbox")
    await user.click(textInput)
    await user.keyboard("TEST")

    expect(screen.getByText("Press Enter to apply")).toBeVisible()
  })

  it("shows Input Instructions if in form that allows submit on enter", async () => {
    const user = userEvent.setup()
    const props = getProps({ formId: "form" })
    vi.spyOn(props.widgetMgr, "allowFormEnterToSubmit").mockReturnValue(true)

    render(<TextInput {...props} />)

    // Trigger dirty state
    const textInput = screen.getByRole("textbox")
    await user.click(textInput)
    await user.keyboard("TEST")

    expect(screen.getByText("Press Enter to submit form")).toBeVisible()
  })

  // For this scenario https://github.com/streamlit/streamlit/issues/7079
  it("shows Input Instructions if focused again in form that allows submit on enter", async () => {
    const user = userEvent.setup()
    const props = getProps({ formId: "form" })
    vi.spyOn(props.widgetMgr, "allowFormEnterToSubmit").mockReturnValue(true)

    render(<TextInput {...props} />)

    const textInput = screen.getByRole("textbox")
    await user.type(textInput, "TEST")

    // Remove focus
    textInput.blur()
    expect(screen.queryByTestId("InputInstructions")).not.toBeInTheDocument()

    // Then focus again
    textInput.focus()
    expect(screen.getByText("Press Enter to submit form")).toBeVisible()
  })

  it("hides Input Instructions if in form that doesn't allow submit on enter", async () => {
    const user = userEvent.setup()
    const props = getProps({ formId: "form" })
    vi.spyOn(props.widgetMgr, "allowFormEnterToSubmit").mockReturnValue(false)

    render(<TextInput {...props} />)

    // Trigger dirty state
    const textInput = screen.getByRole("textbox")
    await user.type(textInput, "TEST")

    expect(screen.queryByTestId("InputInstructions")).toHaveTextContent("")
  })

  it("hides Please enter to apply text when width is smaller than 180px", async () => {
    const user = userEvent.setup()
    const props = getProps({}, { width: 100 })
    render(<TextInput {...props} />)

    // Focus on input
    const textInput = screen.getByRole("textbox")
    await user.click(textInput)

    expect(screen.queryByTestId("InputInstructions")).not.toBeInTheDocument()
  })

  it("shows Please enter to apply text when width is bigger than 180px", async () => {
    const user = userEvent.setup()
    const props = getProps({}, { width: 190 })
    render(<TextInput {...props} />)

    // Focus on input
    const textInput = screen.getByRole("textbox")
    await user.click(textInput)

    expect(screen.getByTestId("InputInstructions")).toBeInTheDocument()
  })

  it("focuses input when clicking label", async () => {
    const props = getProps()
    render(<TextInput {...props} />)
    const textInput = screen.getByRole("textbox")
    expect(textInput).not.toHaveFocus()
    const label = screen.getByText(props.element.label)
    const user = userEvent.setup()
    await user.click(label)
    expect(textInput).toHaveFocus()
  })

  it("ensures id doesn't change on rerender", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<TextInput {...props} />)

    const textInputLabel1 = screen.getByTestId("stWidgetLabel")
    const forId1 = textInputLabel1.getAttribute("for")

    // Make some change to cause a rerender
    const textInput = screen.getByRole("textbox")
    await user.type(textInput, "0123456789")
    expect(textInput).toHaveValue("0123456789")

    const textInputLabel2 = screen.getByTestId("stWidgetLabel")
    const forId2 = textInputLabel2.getAttribute("for")

    expect(forId2).toBe(forId1)
  })
})


================================================
File: /frontend/lib/src/components/widgets/TextInput/TextInput.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, useCallback, useState } from "react"

import uniqueId from "lodash/uniqueId"
import { Input as UIInput } from "baseui/input"
import { useTheme } from "@emotion/react"

import useOnInputChange from "@streamlit/lib/src/hooks/useOnInputChange"
import { TextInput as TextInputProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  useBasicWidgetState,
  ValueWithSource,
} from "@streamlit/lib/src/hooks/useBasicWidgetState"
import useUpdateUiValue from "@streamlit/lib/src/hooks/useUpdateUiValue"
import useSubmitFormViaEnterKey from "@streamlit/lib/src/hooks/useSubmitFormViaEnterKey"
import InputInstructions from "@streamlit/lib/src/components/shared/InputInstructions/InputInstructions"
import {
  StyledWidgetLabelHelp,
  WidgetLabel,
} from "@streamlit/lib/src/components/widgets/BaseWidget"
import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"
import {
  isInForm,
  labelVisibilityProtoValueToEnum,
} from "@streamlit/lib/src/util/utils"

import { StyledTextInput } from "./styled-components"

export interface Props {
  disabled: boolean
  element: TextInputProto
  widgetMgr: WidgetStateManager
  width: number
  fragmentId?: string
}

function TextInput({
  disabled,
  element,
  widgetMgr,
  width,
  fragmentId,
}: Props): ReactElement {
  /**
   * The value specified by the user via the UI. If the user didn't touch this
   * widget's UI, the default value is used.
   */
  const [uiValue, setUiValue] = useState<string | null>(
    getStateFromWidgetMgr(widgetMgr, element) ?? null
  )

  /**
   * True if the user-specified state.value has not yet been synced to the WidgetStateManager.
   */
  const [dirty, setDirty] = useState(false)

  const onFormCleared = useCallback(() => {
    setUiValue(element.default ?? null)
    setDirty(true)
  }, [element.default])

  const [value, setValueWithSource] = useBasicWidgetState<
    string | null,
    TextInputProto
  >({
    getStateFromWidgetMgr,
    getDefaultStateFromProto,
    getCurrStateFromProto,
    updateWidgetMgrState,
    element,
    widgetMgr,
    fragmentId,
    onFormCleared,
  })

  useUpdateUiValue(value, uiValue, setUiValue, dirty)

  /**
   * Whether the input is currently focused.
   */
  const [focused, setFocused] = useState(false)

  const theme = useTheme()
  const [id] = useState(() => uniqueId("text_input_"))
  const { placeholder, formId } = element

  const commitWidgetValue = useCallback((): void => {
    setDirty(false)
    setValueWithSource({ value: uiValue, fromUi: true })
  }, [uiValue, setValueWithSource])

  // Show "Please enter" instructions if in a form & allowed, or not in form and state is dirty.
  const allowEnterToSubmit = isInForm({ formId })
    ? widgetMgr.allowFormEnterToSubmit(formId)
    : dirty

  // Hide input instructions for small widget sizes.
  const shouldShowInstructions =
    focused && width > theme.breakpoints.hideWidgetDetails

  const onBlur = useCallback((): void => {
    if (dirty) {
      commitWidgetValue()
    }
    setFocused(false)
  }, [dirty, commitWidgetValue])

  const onFocus = useCallback((): void => {
    setFocused(true)
  }, [])

  const onChange = useOnInputChange({
    formId: element.formId,
    maxChars: element.maxChars,
    setDirty,
    setUiValue,
    setValueWithSource,
  })

  const onKeyPress = useSubmitFormViaEnterKey(
    element.formId,
    commitWidgetValue,
    dirty,
    widgetMgr,
    fragmentId
  )

  return (
    <StyledTextInput
      className="stTextInput"
      data-testid="stTextInput"
      width={width}
    >
      <WidgetLabel
        label={element.label}
        disabled={disabled}
        labelVisibility={labelVisibilityProtoValueToEnum(
          element.labelVisibility?.value
        )}
        htmlFor={id}
      >
        {element.help && (
          <StyledWidgetLabelHelp>
            <TooltipIcon
              content={element.help}
              placement={Placement.TOP_RIGHT}
            />
          </StyledWidgetLabelHelp>
        )}
      </WidgetLabel>
      <UIInput
        value={uiValue ?? ""}
        placeholder={placeholder}
        onBlur={onBlur}
        onFocus={onFocus}
        onChange={onChange}
        onKeyPress={onKeyPress}
        aria-label={element.label}
        disabled={disabled}
        id={id}
        type={getTypeString(element)}
        autoComplete={element.autocomplete}
        overrides={{
          Input: {
            style: {
              // Issue: https://github.com/streamlit/streamlit/issues/2495
              // The input won't shrink in Firefox,
              // unless the line below is provided.
              // See https://stackoverflow.com/a/33811151
              minWidth: 0,
              "::placeholder": {
                opacity: "0.7",
              },
              lineHeight: theme.lineHeights.inputWidget,
              // Baseweb requires long-hand props, short-hand leads to weird bugs & warnings.
              paddingRight: theme.spacing.sm,
              paddingLeft: theme.spacing.sm,
              paddingBottom: theme.spacing.sm,
              paddingTop: theme.spacing.sm,
            },
          },
          Root: {
            props: {
              "data-testid": "stTextInputRootElement",
            },
            style: {
              height: theme.sizes.minElementHeight,
              // Baseweb requires long-hand props, short-hand leads to weird bugs & warnings.
              borderLeftWidth: theme.sizes.borderWidth,
              borderRightWidth: theme.sizes.borderWidth,
              borderTopWidth: theme.sizes.borderWidth,
              borderBottomWidth: theme.sizes.borderWidth,
            },
          },
        }}
      />
      {shouldShowInstructions && (
        <InputInstructions
          dirty={dirty}
          value={uiValue ?? ""}
          maxLength={element.maxChars}
          inForm={isInForm({ formId: element.formId })}
          allowEnterToSubmit={allowEnterToSubmit}
        />
      )}
    </StyledTextInput>
  )
}

function getStateFromWidgetMgr(
  widgetMgr: WidgetStateManager,
  element: TextInputProto
): string | null {
  return widgetMgr.getStringValue(element) ?? null
}

function getDefaultStateFromProto(element: TextInputProto): string | null {
  return element.default ?? null
}

function getCurrStateFromProto(element: TextInputProto): string | null {
  return element.value ?? null
}

function updateWidgetMgrState(
  element: TextInputProto,
  widgetMgr: WidgetStateManager,
  vws: ValueWithSource<string | null>,
  fragmentId?: string
): void {
  widgetMgr.setStringValue(
    element,
    vws.value,
    { fromUi: vws.fromUi },
    fragmentId
  )
}

function getTypeString(element: TextInputProto): string {
  return element.type === TextInputProto.Type.PASSWORD ? "password" : "text"
}

export default TextInput


================================================
File: /frontend/lib/src/components/widgets/TextInput/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./TextInput"


================================================
File: /frontend/lib/src/components/widgets/TextInput/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export interface StyledTextInputProps {
  width: number
}

export const StyledTextInput = styled.div<StyledTextInputProps>(
  ({ width }) => ({
    position: "relative",
    width,
  })
)


================================================
File: /frontend/lib/src/components/widgets/TimeInput/TimeInput.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { act, screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  LabelVisibilityMessage as LabelVisibilityMessageProto,
  TimeInput as TimeInputProto,
} from "@streamlit/lib/src/proto"

import TimeInput, { Props } from "./TimeInput"

const getProps = (
  elementProps: Partial<TimeInputProto> = {},
  disabled = false
): Props => ({
  element: TimeInputProto.create({
    id: "123",
    label: "Label",
    default: "12:45",
    step: 900,
    ...elementProps,
  }),
  width: 0,
  disabled: disabled,
  widgetMgr: new WidgetStateManager({
    sendRerunBackMsg: vi.fn(),
    formsDataChanged: vi.fn(),
  }),
})

describe("TimeInput widget", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<TimeInput {...props} />)
    const timeDisplay = screen.getByTestId("stTimeInputTimeDisplay")

    expect(timeDisplay).toBeInTheDocument()
  })

  it("shows a label", () => {
    const props = getProps()
    render(<TimeInput {...props} />)
    const widgetLabel = screen.getByText(props.element.label)
    expect(widgetLabel).toBeInTheDocument()
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when hidden", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.HIDDEN,
      },
    })
    render(<TimeInput {...props} />)

    const widgetLabel = screen.getByTestId("stWidgetLabel")
    expect(widgetLabel).toHaveStyle("visibility: hidden")
    expect(widgetLabel).not.toBeVisible()
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when collapsed", () => {
    const props = getProps({
      labelVisibility: {
        value: LabelVisibilityMessageProto.LabelVisibilityOptions.COLLAPSED,
      },
    })
    render(<TimeInput {...props} />)

    const widgetLabel = screen.getByTestId("stWidgetLabel")
    expect(widgetLabel).toHaveStyle("display: none")
    expect(widgetLabel).not.toBeVisible()
  })

  it("sets widget value on mount", () => {
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TimeInput {...props} />)

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledWith(
      props.element,
      props.element.default,
      { fromUi: false },
      undefined
    )
  })

  it("can pass fragmentId to setStringValue", () => {
    const props = { ...getProps(), fragmentId: "myFragmentId" }
    vi.spyOn(props.widgetMgr, "setStringValue")
    render(<TimeInput {...props} />)

    expect(props.widgetMgr.setStringValue).toHaveBeenCalledWith(
      props.element,
      props.element.default,
      { fromUi: false },
      "myFragmentId"
    )
  })

  it("has correct className and style", () => {
    const props = getProps()
    render(<TimeInput {...props} />)

    const timeInput = screen.getByTestId("stTimeInput")
    expect(timeInput).toHaveClass("stTimeInput")
    expect(timeInput).toHaveStyle(`width: ${props.width}px`)
  })

  it("can be disabled", () => {
    const props = getProps({}, true)
    render(<TimeInput {...props} />)
    const widgetLabel = screen.getByTestId("stWidgetLabel")
    expect(widgetLabel).toHaveAttribute("disabled")

    const timeDisplay = screen.getByTestId("stTimeInputTimeDisplay")
    expect(timeDisplay).toHaveAttribute("disabled")
  })

  it("has the correct default value", () => {
    const props = getProps()
    render(<TimeInput {...props} />)

    const timeDisplay = screen.getByTestId("stTimeInputTimeDisplay")
    expect(timeDisplay).toHaveTextContent("12:45")
  })

  it("has a 24 format", () => {
    const props = getProps()
    render(<TimeInput {...props} />)

    // Finds the input node by aria-label
    const inputNode = screen.getByLabelText(
      "Selected 12:45. Select a time, 24-hour format."
    )
    expect(inputNode).toBeInTheDocument()
  })

  it("sets the widget value on change", async () => {
    const user = userEvent.setup()
    const props = getProps()
    vi.spyOn(props.widgetMgr, "setStringValue")

    render(<TimeInput {...props} />)
    // Div containing the selected time as a value prop and as text
    const timeDisplay = screen.getByTestId("stTimeInputTimeDisplay")

    // Change the widget value
    if (timeDisplay) {
      // Select the time input dropdown
      await user.click(timeDisplay)
      // Arrow up from 12:45 to 12:30 (since step in 15 min intervals)
      await user.keyboard("{ArrowUp}")
      // Hit enter to select the new time
      await user.keyboard("{Enter}")
    }

    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      "12:30",
      { fromUi: true },
      undefined
    )

    expect(timeDisplay).toHaveAttribute("value", "12:30")
    expect(timeDisplay).toHaveTextContent("12:30")
  })

  it("resets its value when form is cleared", async () => {
    const user = userEvent.setup()
    // Create a widget in a clearOnSubmit form
    const props = getProps({ formId: "form" })
    props.widgetMgr.setFormSubmitBehaviors("form", true)

    vi.spyOn(props.widgetMgr, "setStringValue")

    render(<TimeInput {...props} />)
    // Div containing the selected time as a value prop and as text
    const timeDisplay = screen.getByTestId("stTimeInputTimeDisplay")

    // Change the widget value
    if (timeDisplay) {
      // Select the time input dropdown
      await user.click(timeDisplay)
      // Arrow down twice from 12:45 to 13:15 (since step in 15 min intervals)
      await user.keyboard("{ArrowDown}{ArrowDown}")
      // Hit enter to select the new time
      await user.keyboard("{Enter}")
    }

    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      "13:15",
      { fromUi: true },
      undefined
    )

    expect(timeDisplay).toHaveAttribute("value", "13:15")
    expect(timeDisplay).toHaveTextContent("13:15")

    // "Submit" the form
    act(() => {
      props.widgetMgr.submitForm("form", undefined)
    })

    // Our widget should be reset, and the widgetMgr should be updated
    expect(props.widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      props.element,
      props.element.default,
      {
        fromUi: true,
      },
      undefined
    )

    expect(timeDisplay).toHaveAttribute("value", "12:45")
    expect(timeDisplay).toHaveTextContent("12:45")
  })
})


================================================
File: /frontend/lib/src/components/widgets/TimeInput/TimeInput.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { memo, ReactElement, useCallback } from "react"

import { TimePicker as UITimePicker } from "baseui/timepicker"
import { StyledClearIcon } from "baseui/input/styled-components"
import { ChevronDown } from "baseui/icon"
import { useTheme } from "@emotion/react"

import { TimeInput as TimeInputProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  useBasicWidgetState,
  ValueWithSource,
} from "@streamlit/lib/src/hooks/useBasicWidgetState"
import {
  StyledWidgetLabelHelp,
  WidgetLabel,
} from "@streamlit/lib/src/components/widgets/BaseWidget"
import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"
import {
  isNullOrUndefined,
  labelVisibilityProtoValueToEnum,
} from "@streamlit/lib/src/util/utils"

import { StyledClearIconContainer } from "./styled-components"

export interface Props {
  disabled: boolean
  element: TimeInputProto
  widgetMgr: WidgetStateManager
  width: number
  fragmentId?: string
}

function TimeInput({
  disabled,
  element,
  widgetMgr,
  width,
  fragmentId,
}: Props): ReactElement {
  const [value, setValueWithSource] = useBasicWidgetState<
    string | null,
    TimeInputProto
  >({
    getStateFromWidgetMgr,
    getDefaultStateFromProto,
    getCurrStateFromProto,
    updateWidgetMgrState,
    element,
    widgetMgr,
    fragmentId,
  })

  const clearable = isNullOrUndefined(element.default) && !disabled
  const style = { width }
  const theme = useTheme()

  const selectOverrides = {
    Select: {
      props: {
        disabled,

        overrides: {
          ControlContainer: {
            style: {
              height: theme.sizes.minElementHeight,
              // Baseweb requires long-hand props, short-hand leads to weird bugs & warnings.
              borderLeftWidth: theme.sizes.borderWidth,
              borderRightWidth: theme.sizes.borderWidth,
              borderTopWidth: theme.sizes.borderWidth,
              borderBottomWidth: theme.sizes.borderWidth,
            },
          },

          IconsContainer: {
            style: () => ({
              paddingRight: theme.spacing.sm,
            }),
          },

          ValueContainer: {
            style: () => ({
              lineHeight: theme.lineHeights.inputWidget,
              // Baseweb requires long-hand props, short-hand leads to weird bugs & warnings.
              paddingRight: theme.spacing.sm,
              paddingLeft: theme.spacing.sm,
              paddingBottom: theme.spacing.sm,
              paddingTop: theme.spacing.sm,
            }),
          },

          SingleValue: {
            props: {
              "data-testid": "stTimeInputTimeDisplay",
            },
          },

          Dropdown: {
            style: () => ({
              paddingTop: theme.spacing.none,
              paddingBottom: theme.spacing.none,
            }),
          },

          DropdownListItem: {
            style: () => ({
              paddingRight: theme.spacing.lg,
              paddingLeft: theme.spacing.lg,
              paddingTop: theme.spacing.sm,
              paddingBottom: theme.spacing.sm,
            }),
          },

          // Nudge the dropdown menu by 1px so the focus state doesn't get cut off
          Popover: {
            props: {
              overrides: {
                Body: {
                  style: () => ({
                    marginTop: theme.spacing.px,
                  }),
                },
              },
            },
          },
          SelectArrow: {
            component: ChevronDown,

            props: {
              overrides: {
                Svg: {
                  style: () => ({
                    width: theme.iconSizes.xl,
                    height: theme.iconSizes.xl,
                  }),
                },
              },
            },
          },
        },
      },
    },
  }

  const handleChange = useCallback(
    (newDate: Date | null): void => {
      const newValue: string | null =
        newDate === null ? null : dateToString(newDate)

      setValueWithSource({ value: newValue, fromUi: true })
    },
    [setValueWithSource]
  )

  const handleClear = useCallback((): void => {
    handleChange(null)
  }, [handleChange])

  return (
    <div className="stTimeInput" data-testid="stTimeInput" style={style}>
      <WidgetLabel
        label={element.label}
        disabled={disabled}
        labelVisibility={labelVisibilityProtoValueToEnum(
          element.labelVisibility?.value
        )}
      >
        {element.help && (
          <StyledWidgetLabelHelp>
            <TooltipIcon
              content={element.help}
              placement={Placement.TOP_RIGHT}
            />
          </StyledWidgetLabelHelp>
        )}
      </WidgetLabel>
      <UITimePicker
        format="24"
        step={element.step ? Number(element.step) : 900} // step in seconds, defaults to 900s (15 minutes)
        value={isNullOrUndefined(value) ? undefined : stringToDate(value)}
        onChange={handleChange}
        overrides={selectOverrides}
        nullable={clearable}
        creatable
        aria-label={element.label}
      />
      {clearable && !isNullOrUndefined(value) && (
        // The time picker doesn't have a built-in clearable functionality.
        // Therefore, we are adding the clear button here.
        <StyledClearIconContainer
          onClick={handleClear}
          data-testid="stTimeInputClearButton"
        >
          <StyledClearIcon
            overrides={{
              Svg: {
                style: {
                  color: theme.colors.darkGray,
                  // setting this width and height makes the clear-icon align with dropdown arrows of other input fields
                  padding: theme.spacing.threeXS,
                  height: theme.sizes.clearIconSize,
                  width: theme.sizes.clearIconSize,
                  ":hover": {
                    fill: theme.colors.bodyText,
                  },
                },
              },
            }}
            $isFocusVisible={false}
          />
        </StyledClearIconContainer>
      )}
    </div>
  )
}

function getStateFromWidgetMgr(
  widgetMgr: WidgetStateManager,
  element: TimeInputProto
): string | null {
  return widgetMgr.getStringValue(element) ?? null
}

function getDefaultStateFromProto(element: TimeInputProto): string | null {
  return element.default ?? null
}

function getCurrStateFromProto(element: TimeInputProto): string | null {
  return element.value ?? null
}

function updateWidgetMgrState(
  element: TimeInputProto,
  widgetMgr: WidgetStateManager,
  vws: ValueWithSource<string | null>,
  fragmentId?: string
): void {
  widgetMgr.setStringValue(
    element,
    vws.value,
    { fromUi: vws.fromUi },
    fragmentId
  )
}

function dateToString(value: Date): string {
  const hours = value.getHours().toString().padStart(2, "0")
  const minutes = value.getMinutes().toString().padStart(2, "0")

  return `${hours}:${minutes}`
}

function stringToDate(value: string | null): Date | null {
  if (value === null) {
    return null
  }
  const [hours, minutes] = value.split(":").map(Number)
  const date = new Date()

  date.setHours(hours)
  date.setMinutes(minutes)

  return date
}

export default memo(TimeInput)


================================================
File: /frontend/lib/src/components/widgets/TimeInput/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./TimeInput"


================================================
File: /frontend/lib/src/components/widgets/TimeInput/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledClearIconContainer = styled.div({
  position: "absolute",
  top: "50%",
  right: "2.05em",
})


================================================
File: /frontend/lib/src/dataframes/Quiver.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Field, Utf8 } from "apache-arrow"
import cloneDeep from "lodash/cloneDeep"

import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import {
  CATEGORICAL,
  CATEGORICAL_COLUMN,
  DATE,
  DIFFERENT_COLUMN_TYPES,
  DISPLAY_VALUES,
  EMPTY,
  FEWER_COLUMNS,
  FLOAT64,
  INT64,
  INTERVAL_DATETIME64,
  INTERVAL_FLOAT64,
  INTERVAL_INT64,
  INTERVAL_UINT64,
  MULTI,
  NAMED_INDEX,
  RANGE,
  STYLER,
  UINT64,
  UNICODE,
} from "@streamlit/lib/src/mocks/arrow"
import { arrayFromVector } from "@streamlit/lib/src/test_util"

describe("Quiver", () => {
  describe("Public methods", () => {
    describe("Without Styler", () => {
      const mockElement = { data: UNICODE }
      const q = new Quiver(mockElement)

      test("cssId", () => {
        expect(q.styler?.cssId).toBeUndefined()
      })

      test("cssStyles", () => {
        expect(q.styler?.cssStyles).toBeUndefined()
      })

      test("caption", () => {
        expect(q.styler?.caption).toBeUndefined()
      })

      test("dimensions", () => {
        expect(q.dimensions).toStrictEqual({
          numHeaderRows: 1,
          numIndexColumns: 1,
          numDataRows: 2,
          numDataColumns: 2,
          numRows: 3,
          numColumns: 3,
        })
      })

      test("indexNames", () => {
        const mockElement = { data: NAMED_INDEX }
        const q = new Quiver(mockElement)
        expect(q.indexNames).toStrictEqual(["INDEX"])
      })
    })

    describe("With Styler", () => {
      const mockElement = {
        data: STYLER,
        styler: {
          uuid: "FAKE_UUID",
          styles: "FAKE_CSS",
          displayValues: DISPLAY_VALUES,
          caption: "FAKE_CAPTION",
        },
      }
      const q = new Quiver(mockElement)

      test("cssId", () => {
        expect(q.styler?.cssId).toEqual("T_FAKE_UUID")
      })

      test("cssStyles", () => {
        expect(q.styler?.cssStyles).toEqual("FAKE_CSS")
      })

      test("caption", () => {
        expect(q.styler?.caption).toEqual("FAKE_CAPTION")
      })

      describe("getCategoricalOptions", () => {
        test("gets all categories for a categorical columns", () => {
          const mockElement = { data: CATEGORICAL_COLUMN }
          const q = new Quiver(mockElement)
          // "foo" and "bar" are the two categories available in this column
          expect(q.getCategoricalOptions(0)).toStrictEqual(["bar", "foo"])
        })

        test("returns undefined for a non-categorical column", () => {
          const mockElement = { data: CATEGORICAL_COLUMN }
          const q = new Quiver(mockElement)
          expect(q.getCategoricalOptions(1)).toStrictEqual(undefined)
        })
      })

      test("dimensions", () => {
        expect(q.dimensions).toStrictEqual({
          numHeaderRows: 1,
          numIndexColumns: 1,
          numDataRows: 2,
          numDataColumns: 2,
          numRows: 3,
          numColumns: 3,
        })
      })
    })

    describe("getCell", () => {
      const mockElement = { data: UNICODE }
      const q = new Quiver(mockElement)

      test("blank cell", () => {
        expect(q.getCell(0, 0)).toStrictEqual({
          type: "blank",
          cssClass: "blank",
          content: "",
        })
      })

      test("index cell", () => {
        expect(q.getCell(1, 0)).toStrictEqual({
          type: "index",
          cssClass: "row_heading level0 row0",
          cssId: undefined,
          content: "i1",
          field: new Field("__index_level_0__", new Utf8(), true, new Map([])),
          contentType: {
            pandas_type: "unicode",
            numpy_type: "object",
            meta: null,
          },
        })
      })

      test("columns cell", () => {
        expect(q.getCell(0, 1)).toStrictEqual({
          type: "columns",
          cssClass: "col_heading level0 col0",
          content: "c1",
          contentType: {
            pandas_type: "unicode",
            numpy_type: "object",
          },
        })
      })

      test("data cell", () => {
        expect(q.getCell(1, 2)).toStrictEqual({
          type: "data",
          cssClass: "data row0 col1",
          cssId: undefined,
          content: "1",
          contentType: {
            pandas_type: "unicode",
            numpy_type: "object",
            meta: null,
          },
          field: new Field("c2", new Utf8(), true, new Map([])),
          displayContent: undefined,
        })
      })

      it("throws an exception if row index is out of range", () => {
        expect(() => q.getCell(5, 0)).toThrow("Row index is out of range: 5")
      })

      it("throws an exception if column index is out of range", () => {
        expect(() => q.getCell(0, 5)).toThrow(
          "Column index is out of range: 5"
        )
      })
    })
  })

  describe("Display", () => {
    describe("Pandas index types", () => {
      test("categorical", () => {
        const mockElement = { data: CATEGORICAL }
        const q = new Quiver(mockElement)

        expect(arrayFromVector(q.indexData)).toEqual([["i1", "i2"]])
        expect(q.columnNames).toEqual([["c1", "c2"]])
        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "categorical",
              numpy_type: "int8",
              meta: {
                num_categories: 3,
                ordered: false,
              },
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("date", () => {
        const mockElement = { data: DATE }
        const q = new Quiver(mockElement)

        expect(arrayFromVector(q.indexData)).toEqual([
          [978220800000, 1009756800000],
        ])
        expect(q.columnNames).toEqual([
          ["2000-12-31 00:00:00", "2001-12-31 00:00:00"],
        ])

        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          [
            new Date("2020-01-02T00:00:00.000Z").getTime(),
            new Date("2020-10-20T00:00:00.000Z").getTime(),
          ],
          [
            new Date("2020-01-02T00:00:00.000Z").getTime(),
            new Date("2020-10-20T00:00:00.000Z").getTime(),
          ],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "datetime",
              numpy_type: "datetime64[ns]",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "date",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "date",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      test("float64", () => {
        const mockElement = { data: FLOAT64 }
        const q = new Quiver(mockElement)

        expect(arrayFromVector(q.indexData)).toEqual([[1.24, 2.35]])
        expect(q.columnNames).toEqual([["1.24", "2.35"]])
        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          [1.2, 1.3],
          [1.4, 1.5],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "float64",
              numpy_type: "float64",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "float64",
              numpy_type: "float64",
              meta: null,
            },
            {
              pandas_type: "float64",
              numpy_type: "float64",
              meta: null,
            },
          ],
        })
      })

      test("int64", () => {
        const mockElement = { data: INT64 }
        const q = new Quiver(mockElement)

        expect(arrayFromVector(q.indexData)).toEqual([[BigInt(1), BigInt(2)]])
        expect(q.columnNames).toEqual([["1", "2"]])
        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          [BigInt(0), BigInt(1)],
          [BigInt(2), BigInt(3)],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("interval datetime64[ns]", () => {
        const mockElement = { data: INTERVAL_DATETIME64 }
        const q = new Quiver(mockElement)

        expect(q.indexData.toString()).toEqual(
          '[{"left": 1483228800000, "right": 1483315200000},{"left": 1483315200000, "right": 1483401600000}]'
        )
        expect(q.columnNames).toEqual([
          ["(2017-01-01, 2017-01-02]", "(2017-01-02, 2017-01-03]"],
        ])
        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "object",
              numpy_type: "interval[datetime64[ns], right]",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("interval float64", () => {
        const mockElement = { data: INTERVAL_FLOAT64 }
        const q = new Quiver(mockElement)

        expect(q.indexData.toString()).toEqual(
          '[{"left": 0, "right": 1.5},{"left": 1.5, "right": 3}]'
        )
        expect(q.columnNames).toEqual([["(0.0, 1.5]", "(1.5, 3.0]"]])
        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "object",
              numpy_type: "interval[float64, right]",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("interval int64", () => {
        const mockElement = { data: INTERVAL_INT64 }
        const q = new Quiver(mockElement)

        expect(q.indexData.toString()).toEqual(
          '[{"left": 0, "right": 1},{"left": 1, "right": 2}]'
        )
        expect(q.columnNames).toEqual([["(0, 1]", "(1, 2]"]])
        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "object",
              numpy_type: "interval[int64, right]",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("interval uint64", () => {
        const mockElement = { data: INTERVAL_UINT64 }
        const q = new Quiver(mockElement)

        expect(q.indexData.toString()).toEqual(
          '[{"left": 0, "right": 1},{"left": 1, "right": 2}]'
        )
        expect(q.columnNames).toEqual([["(0, 1]", "(1, 2]"]])
        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "object",
              numpy_type: "interval[uint64, right]",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("range", () => {
        const mockElement = { data: RANGE }
        const q = new Quiver(mockElement)

        expect(arrayFromVector(q.indexData)).toEqual([[0, 1]])
        expect(q.columnNames).toEqual([["0", "1"]])
        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "range",
              numpy_type: "range",
              meta: {
                start: 0,
                step: 1,
                stop: 2,
                kind: "range",
                name: null,
              },
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      test("uint64", () => {
        const mockElement = { data: UINT64 }
        const q = new Quiver(mockElement)

        expect(arrayFromVector(q.indexData)).toEqual([[BigInt(1), BigInt(2)]])
        expect(q.columnNames).toEqual([["1", "2"]])
        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          [BigInt(1), BigInt(2)],
          [BigInt(3), BigInt(4)],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "uint64",
              numpy_type: "uint64",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("unicode", () => {
        const mockElement = { data: UNICODE }
        const q = new Quiver(mockElement)

        expect(arrayFromVector(q.indexData)).toEqual([["i1", "i2"]])
        expect(q.columnNames).toEqual([["c1", "c2"]])
        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })
    })

    describe("Special cases", () => {
      test("empty", () => {
        const mockElement = { data: EMPTY }
        const q = new Quiver(mockElement)

        expect(q.dimensions).toStrictEqual({
          numHeaderRows: 1,
          numIndexColumns: 1,
          numDataRows: 0,
          numDataColumns: 0,
          numRows: 1,
          numColumns: 1,
        })

        expect(arrayFromVector(q.indexData)).toEqual([])
        expect(q.columnNames).toEqual([])
        expect(q.data.toArray()).toEqual([])
        expect(q.columnTypes).toEqual({
          index: [{ pandas_type: "empty", numpy_type: "object", meta: null }],
          data: [],
        })
      })

      test("multi-index", () => {
        const mockElement = { data: MULTI }
        const q = new Quiver(mockElement)

        expect(arrayFromVector(q.indexData)).toEqual([
          [BigInt(1), BigInt(2)],
          ["red", "blue"],
        ])
        expect(q.columnNames).toEqual([
          ["1", "2"],
          ["red", "blue"],
        ])
        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      test("styler", () => {
        const mockElement = {
          data: STYLER,
          styler: {
            uuid: "FAKE_UUID",
            styles: "FAKE_CSS",
            caption: "FAKE_CAPTION",
            displayValues: DISPLAY_VALUES,
          },
        }
        const q = new Quiver(mockElement)

        expect(arrayFromVector(q.indexData)).toEqual([[0, 1]])
        expect(q.columnNames).toEqual([["0", "1"]])
        expect(q.data.toArray().map(a => a?.toArray())).toEqual([
          [BigInt(1), BigInt(2)],
          [BigInt(3), BigInt(4)],
        ])
        expect(q.columnTypes).toEqual({
          index: [
            {
              pandas_type: "range",
              numpy_type: "range",
              meta: {
                start: 0,
                step: 1,
                stop: 2,
                kind: "range",
                name: null,
              },
            },
          ],
          data: [
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
        // Check display values.
        expect(q.getCell(1, 1).displayContent).toEqual("1")
        expect(q.getCell(1, 2).displayContent).toEqual("2")
        expect(q.getCell(2, 1).displayContent).toEqual("3")
        expect(q.getCell(2, 2).displayContent).toEqual("4")
      })
    })
  })

  describe("Add rows", () => {
    describe("Pandas index types", () => {
      test("categorical", () => {
        const mockElement = { data: CATEGORICAL }
        const q = new Quiver(mockElement)

        const qq = q.addRows(q)

        expect(arrayFromVector(qq.indexData)).toEqual([
          ["i1", "i2", "i1", "i2"],
        ])
        expect(qq.columnNames).toEqual([["c1", "c2"]])
        expect(qq.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
        ])
        expect(qq.columnTypes).toEqual({
          index: [
            {
              pandas_type: "categorical",
              numpy_type: "int8",
              meta: {
                num_categories: 3,
                ordered: false,
              },
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("date", () => {
        const mockElement = { data: DATE }
        const q = new Quiver(mockElement)

        const qq = q.addRows(q)

        expect(arrayFromVector(qq.indexData)).toEqual([
          [978220800000, 1009756800000, 978220800000, 1009756800000],
        ])
        expect(qq.columnNames).toEqual([
          ["2000-12-31 00:00:00", "2001-12-31 00:00:00"],
        ])
        expect(qq.data.toArray().map(a => a?.toArray())).toEqual([
          [
            new Date("2020-01-02T00:00:00.000Z").getTime(),
            new Date("2020-10-20T00:00:00.000Z").getTime(),
          ],
          [
            new Date("2020-01-02T00:00:00.000Z").getTime(),
            new Date("2020-10-20T00:00:00.000Z").getTime(),
          ],
          [
            new Date("2020-01-02T00:00:00.000Z").getTime(),
            new Date("2020-10-20T00:00:00.000Z").getTime(),
          ],
          [
            new Date("2020-01-02T00:00:00.000Z").getTime(),
            new Date("2020-10-20T00:00:00.000Z").getTime(),
          ],
        ])
        expect(qq.columnTypes).toEqual({
          index: [
            {
              pandas_type: "datetime",
              numpy_type: "datetime64[ns]",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "date",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "date",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      test("float64", () => {
        const mockElement = { data: FLOAT64 }
        const q = new Quiver(mockElement)

        const qq = q.addRows(q)

        expect(arrayFromVector(qq.indexData)).toEqual([
          [1.24, 2.35, 1.24, 2.35],
        ])
        expect(qq.columnNames).toEqual([["1.24", "2.35"]])
        expect(qq.data.toArray().map(a => a?.toArray())).toEqual([
          [1.2, 1.3],
          [1.4, 1.5],
          [1.2, 1.3],
          [1.4, 1.5],
        ])
        expect(qq.columnTypes).toEqual({
          index: [
            {
              pandas_type: "float64",
              numpy_type: "float64",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "float64",
              numpy_type: "float64",
              meta: null,
            },
            {
              pandas_type: "float64",
              numpy_type: "float64",
              meta: null,
            },
          ],
        })
      })

      test("int64", () => {
        const mockElement = { data: INT64 }
        const q = new Quiver(mockElement)

        const qq = q.addRows(q)

        expect(arrayFromVector(qq.indexData)).toEqual([
          [BigInt(1), BigInt(2), BigInt(1), BigInt(2)],
        ])
        expect(qq.columnNames).toEqual([["1", "2"]])
        expect(qq.data.toArray().map(a => a?.toArray())).toEqual([
          [BigInt(0), BigInt(1)],
          [BigInt(2), BigInt(3)],
          [BigInt(0), BigInt(1)],
          [BigInt(2), BigInt(3)],
        ])
        expect(qq.columnTypes).toEqual({
          index: [
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("interval datetime64[ns]", () => {
        const mockElement = { data: INTERVAL_DATETIME64 }
        const q = new Quiver(mockElement)

        const qq = q.addRows(q)

        expect(qq.indexData.toString()).toEqual(
          '[{"left": 1483228800000, "right": 1483315200000},{"left": 1483315200000, "right": 1483401600000},{"left": 1483228800000, "right": 1483315200000},{"left": 1483315200000, "right": 1483401600000}]'
        )
        expect(qq.columnNames).toEqual([
          ["(2017-01-01, 2017-01-02]", "(2017-01-02, 2017-01-03]"],
        ])
        expect(qq.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
        ])
        expect(qq.columnTypes).toEqual({
          index: [
            {
              pandas_type: "object",
              numpy_type: "interval[datetime64[ns], right]",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("interval float64", () => {
        const mockElement = { data: INTERVAL_FLOAT64 }
        const q = new Quiver(mockElement)

        const qq = q.addRows(q)

        expect(qq.indexData.toString()).toEqual(
          '[{"left": 0, "right": 1.5},{"left": 1.5, "right": 3},{"left": 0, "right": 1.5},{"left": 1.5, "right": 3}]'
        )
        expect(qq.columnNames).toEqual([["(0.0, 1.5]", "(1.5, 3.0]"]])
        expect(qq.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
        ])
        expect(qq.columnTypes).toEqual({
          index: [
            {
              pandas_type: "object",
              numpy_type: "interval[float64, right]",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("interval int64", () => {
        const mockElement = { data: INTERVAL_INT64 }
        const q = new Quiver(mockElement)

        const qq = q.addRows(q)

        expect(qq.indexData.toString()).toEqual(
          '[{"left": 0, "right": 1},{"left": 1, "right": 2},{"left": 0, "right": 1},{"left": 1, "right": 2}]'
        )
        expect(qq.columnNames).toEqual([["(0, 1]", "(1, 2]"]])
        expect(qq.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
        ])
        expect(qq.columnTypes).toEqual({
          index: [
            {
              pandas_type: "object",
              numpy_type: "interval[int64, right]",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("interval uint64", () => {
        const mockElement = { data: INTERVAL_UINT64 }
        const q = new Quiver(mockElement)

        const qq = q.addRows(q)

        expect(qq.indexData.toString()).toEqual(
          '[{"left": 0, "right": 1},{"left": 1, "right": 2},{"left": 0, "right": 1},{"left": 1, "right": 2}]'
        )
        expect(qq.columnNames).toEqual([["(0, 1]", "(1, 2]"]])
        expect(qq.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
          ["foo", BigInt(100)],
          ["bar", BigInt(200)],
        ])
        expect(qq.columnTypes).toEqual({
          index: [
            {
              pandas_type: "object",
              numpy_type: "interval[uint64, right]",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("range", () => {
        const mockElement = { data: RANGE }
        const q = new Quiver(mockElement)

        const qq = q.addRows(q)

        expect(arrayFromVector(qq.indexData)).toEqual([[0, 1, 2, 3]])
        expect(qq.columnNames).toEqual([["0", "1"]])
        expect(qq.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", "1"],
          ["bar", "2"],
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(qq.columnTypes).toEqual({
          index: [
            {
              pandas_type: "range",
              numpy_type: "range",
              meta: {
                start: 0,
                step: 1,
                stop: 4,
                kind: "range",
                name: null,
              },
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      test("uint64", () => {
        const mockElement = { data: UINT64 }
        const q = new Quiver(mockElement)

        const qq = q.addRows(q)

        expect(arrayFromVector(qq.indexData)).toEqual([
          [BigInt(1), BigInt(2), BigInt(1), BigInt(2)],
        ])
        expect(qq.columnNames).toEqual([["1", "2"]])
        expect(qq.data.toArray().map(a => a?.toArray())).toEqual([
          [BigInt(1), BigInt(2)],
          [BigInt(3), BigInt(4)],
          [BigInt(1), BigInt(2)],
          [BigInt(3), BigInt(4)],
        ])
        expect(qq.columnTypes).toEqual({
          index: [
            {
              pandas_type: "uint64",
              numpy_type: "uint64",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
          ],
        })
      })

      test("unicode", () => {
        const mockElement = { data: UNICODE }
        const q = new Quiver(mockElement)

        const qq = q.addRows(q)

        expect(arrayFromVector(qq.indexData)).toEqual([
          ["i1", "i2", "i1", "i2"],
        ])
        expect(qq.columnNames).toEqual([["c1", "c2"]])
        expect(qq.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", "1"],
          ["bar", "2"],
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(qq.columnTypes).toEqual({
          index: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })
    })

    describe("Special cases", () => {
      it("does not mutate the original element", () => {
        const mockElement = { data: UNICODE }
        const q = new Quiver(mockElement)
        const qClone = cloneDeep(q)

        q.addRows(q)
        expect(q).toEqual(qClone)
      })

      test("multi-index", () => {
        const mockElement = { data: MULTI }
        const q = new Quiver(mockElement)

        const qq = q.addRows(q)

        expect(arrayFromVector(qq.indexData)).toEqual([
          [BigInt(1), BigInt(2), BigInt(1), BigInt(2)],
          ["red", "blue", "red", "blue"],
        ])
        expect(qq.columnNames).toEqual([
          ["1", "2"],
          ["red", "blue"],
        ])
        expect(qq.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", "1"],
          ["bar", "2"],
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(qq.columnTypes).toEqual({
          index: [
            {
              pandas_type: "int64",
              numpy_type: "int64",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      test("DataFrames with different column types", () => {
        const mockElement1 = { data: UNICODE }
        const mockElement2 = { data: DIFFERENT_COLUMN_TYPES }
        const q1 = new Quiver(mockElement1)
        const q2 = new Quiver(mockElement2)

        const q1q2 = q1.addRows(q2)

        expect(arrayFromVector(q1q2.indexData)).toEqual([
          ["i1", "i2", "i1", "i2"],
        ])
        expect(q1q2.columnNames).toEqual([["c1", "c2"]])
        expect(q1q2.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", "1"],
          ["bar", "2"],
          ["baz", "1"],
          ["qux", "2"],
        ])
        expect(q1q2.columnTypes).toEqual({
          index: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      it("shows df2 if df1 is empty", () => {
        const mockElement1 = { data: EMPTY }
        const mockElement2 = { data: UNICODE }
        const q1 = new Quiver(mockElement1)
        const q2 = new Quiver(mockElement2)

        const q1q2 = q1.addRows(q2)
        expect(q1q2).toEqual(q2)
      })

      it("shows df1 if df2 is empty", () => {
        const mockElement1 = { data: EMPTY }
        const mockElement2 = { data: UNICODE }
        const q1 = new Quiver(mockElement1)
        const q2 = new Quiver(mockElement2)

        const q2q1 = q2.addRows(q1)
        expect(q2q1).toEqual(q2)
      })

      it("shows an empty DataFrame if both df1 and df2 are empty", () => {
        const mockElement = { data: EMPTY }
        const q1 = new Quiver(mockElement)
        const q2 = new Quiver(mockElement)

        const q1q2 = q1.addRows(q2)
        expect(q1q2.dimensions.numDataRows).toBe(0)
      })

      it("uses df1 columns if df2 has more columns than df1", () => {
        const mockElement1 = { data: FEWER_COLUMNS }
        const mockElement2 = { data: UNICODE }
        const q1 = new Quiver(mockElement1)
        const q2 = new Quiver(mockElement2)

        const q1q2 = q1.addRows(q2)

        expect(arrayFromVector(q1q2.indexData)).toEqual([
          ["i1", "i2", "i1", "i2"],
        ])
        expect(q1q2.columnNames).toEqual([["c1"]])
        expect(q1q2.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo"],
          ["bar"],
          ["foo"],
          ["bar"],
        ])
        expect(q1q2.columnTypes).toEqual({
          index: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      it("throws an error if df1 has more columns than df2", () => {
        const mockElement1 = { data: UNICODE }
        const mockElement2 = { data: FEWER_COLUMNS }
        const q1 = new Quiver(mockElement1)
        const q2 = new Quiver(mockElement2)

        expect(() => q1.addRows(q2)).toThrowErrorMatchingSnapshot()
      })

      it("throws an error if one of the DataFrames has Styler", () => {
        const mockElement1 = {
          data: STYLER,
          styler: {
            uuid: "FAKE_UUID",
            styles: "FAKE_CSS",
            caption: "FAKE_CAPTION",
            displayValues: DISPLAY_VALUES,
          },
        }
        const mockElement2 = { data: UNICODE }
        const q1 = new Quiver(mockElement1)
        const q2 = new Quiver(mockElement2)

        expect(() => q1.addRows(q2)).toThrowErrorMatchingSnapshot()
        expect(() => q2.addRows(q1)).toThrowErrorMatchingSnapshot()
      })

      it("throws an error if DataFrames have different index types", () => {
        const mockElement1 = { data: UNICODE }
        const mockElement2 = { data: RANGE }
        const q1 = new Quiver(mockElement1)
        const q2 = new Quiver(mockElement2)

        expect(() => q1.addRows(q2)).toThrowErrorMatchingSnapshot()
      })

      it("throws an error if DataFrames have different data types", () => {
        const mockElement1 = { data: UNICODE }
        const mockElement2 = { data: INT64 }
        const q1 = new Quiver(mockElement1)
        const q2 = new Quiver(mockElement2)

        expect(() => q1.addRows(q2)).toThrowErrorMatchingSnapshot()
      })
    })
  })
})


================================================
File: /frontend/lib/src/dataframes/Quiver.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Private members use _.
/* eslint-disable no-underscore-dangle */

import { Dictionary, Field, Vector } from "apache-arrow"
import { immerable, produce } from "immer"

import { IArrow, Styler as StylerProto } from "@streamlit/lib/src/proto"
import { hashString, notNullOrUndefined } from "@streamlit/lib/src/util/utils"

import { concat } from "./arrowConcatUtils"
import {
  ColumnNames,
  Data,
  IndexData,
  PandasColumnTypes,
  parseArrowIpcBytes,
} from "./arrowParseUtils"
import {
  convertVectorToList,
  DataType,
  PandasColumnType,
} from "./arrowTypeUtils"

/**
 * Pandas Styler data from proto message.
 *
 * This is only present if the DataFrame was created based
 * on a Pandas Styler object.
 */
interface PandasStylerData {
  /** UUID from Styler. */
  uuid: string

  /** Optional user-specified caption. */
  caption?: string

  /** CSS styles from Styler. */
  cssStyles?: string

  /** CSS ID to use for the Table.
   *
   * Format ot the CSS ID: `T_${StylerUUID}`
   *
   * This id is used by styled tables and styled dataframes to associate
   * the Styler CSS with the styled data.
   */
  cssId?: string

  /**
   * Stringified versions of each cell in the DataFrame, in the
   * user-specified format.
   *
   * The display values table is expected to always have the same
   * dimensions as the actual data table.
   */
  displayValues: Quiver
}

/** Dimensions of the DataFrame. */
interface DataFrameDimensions {
  // The number of header rows (> 1 for multi-level headers)
  numHeaderRows: number
  // The number of index columns
  numIndexColumns: number
  // The number of data rows (excluding header rows)
  numDataRows: number
  // The number of data columns (excluding index columns)
  numDataColumns: number
  // The total number of rows (header rows + data rows)
  numRows: number
  // The total number of columns (index + data columns)
  numColumns: number
}

/**
 * There are 4 cell types:
 *  - blank, cells that are not part of index headers, column headers, or data
 *  - index, index header cells
 *  - columns, column header cells
 *  - data, data cells
 */
export enum DataFrameCellType {
  BLANK = "blank",
  INDEX = "index",
  COLUMNS = "columns",
  DATA = "data",
}

/** Data for a single cell in a DataFrame. */
export interface DataFrameCell {
  /** The cell's type (blank, index, columns, or data). */
  type: DataFrameCellType

  /** The cell's CSS id, if the DataFrame has Styler. */
  cssId?: string

  /** The cell's CSS class. */
  cssClass: string

  /** The cell's content. */
  content: DataType

  /** The cell's content type. */
  // For "blank" cells "contentType" is undefined.
  contentType?: PandasColumnType

  /** The cell's field. */
  field?: Field

  /**
   * The cell's formatted content string, if the DataFrame was created with a Styler.
   * If the DataFrame is unstyled, displayContent will be undefined, and display
   * code should apply a default formatting to the `content` value instead.
   */
  displayContent?: string
}

/**
 * Parses data from an Arrow table, and stores it in a row-major format
 * (which is more useful for our frontend display code than Arrow's columnar format).
 */
export class Quiver {
  /**
   * Plain objects (objects without a prototype), arrays, Maps and Sets are always drafted by Immer.
   * Every other object must use the immerable symbol to mark itself as compatible with Immer.
   * When one of these objects is mutated within a producer, its prototype is preserved between copies.
   * Source: https://immerjs.github.io/immer/complex-objects/
   */
  [immerable] = true

  /** Column names (matrix of column names to support multi-level headers). */
  private _columnNames: ColumnNames

  /** Column names of the index columns (there can be multiple index columns). */
  private _indexNames: string[]

  /** Cell values of the index columns (there can be multiple index columns). */
  private _indexData: IndexData

  /** Cell values of the data columns. */
  private _data: Data

  /** Definition for DataFrame's fields. */
  private _fields: Record<string, Field<any>>

  /** Types (from Pandas) for DataFrame's index and data columns. */
  private _columnTypes: PandasColumnTypes

  /** [optional] Pandas Styler data. This will be defined if the user styled the dataframe. */
  private readonly _styler?: PandasStylerData

  /** Number of bytes in the Arrow IPC bytes. */
  private _num_bytes: number

  constructor(element: IArrow) {
    const { indexData, columnNames, data, columnTypes, fields, indexNames } =
      parseArrowIpcBytes(element.data)

    // Load styler data (if provided):
    const styler = element.styler
      ? parseStyler(element.styler as StylerProto)
      : undefined

    // The assignment is done below to avoid partially populating the instance
    // if an error is thrown.
    this._indexData = indexData
    this._columnNames = columnNames
    this._data = data
    this._columnTypes = columnTypes
    this._fields = fields
    this._styler = styler
    this._indexNames = indexNames
    this._num_bytes = element.data?.length ?? 0
  }

  /** Cell values of the index columns (there can be multiple index columns). */
  public get indexData(): IndexData {
    return this._indexData
  }

  /** Column names of the index columns (there can be multiple index columns). */
  public get indexNames(): string[] {
    return this._indexNames
  }

  /** Column names of the data columns (there can be multiple data columns). */
  public get columnNames(): ColumnNames {
    return this._columnNames
  }

  /** Cell values of the data columns. */
  public get data(): Data {
    return this._data
  }

  /** Types (from Pandas) for the index and data columns. */
  public get columnTypes(): PandasColumnTypes {
    return this._columnTypes
  }

  public get styler(): PandasStylerData | undefined {
    return this._styler
  }

  /** Dimensions of the DataFrame. */
  public get dimensions(): DataFrameDimensions {
    const numIndexColumns =
      // TODO(lukasmasuch): Change default to 0?
      this._indexData.length || this.columnTypes.index.length || 1
    const numHeaderRows = this._columnNames.length || 1
    const numDataRows = this._data.numRows || 0
    const numDataColumns =
      this._data.numCols || this._columnNames?.[0]?.length || 0

    const numRows = numHeaderRows + numDataRows
    const numColumns = numIndexColumns + numDataColumns

    return {
      numHeaderRows,
      numIndexColumns,
      numDataRows,
      numDataColumns,
      numRows,
      numColumns,
    }
  }

  /**
   * A hash that identifies the underlying data.
   *
   * This hash is based on various descriptive information
   * but is not 100% guaranteed to be unique.
   */
  public get hash(): string {
    // Its important to calculate this at runtime
    // since some of the data can change when `add_rows` is
    // used.
    const valuesToHash = [
      this.dimensions.numColumns,
      this.dimensions.numDataColumns,
      this.dimensions.numDataRows,
      this.dimensions.numIndexColumns,
      this.dimensions.numHeaderRows,
      this.dimensions.numRows,
      this._num_bytes,
      this._columnNames,
    ]
    return hashString(valuesToHash.join("-"))
  }

  /** Return a single cell in the table. */
  public getCell(rowIndex: number, columnIndex: number): DataFrameCell {
    const { numHeaderRows, numIndexColumns, numRows, numColumns } =
      this.dimensions

    if (rowIndex < 0 || rowIndex >= numRows) {
      throw new Error(`Row index is out of range: ${rowIndex}`)
    }
    if (columnIndex < 0 || columnIndex >= numColumns) {
      throw new Error(`Column index is out of range: ${columnIndex}`)
    }

    const isBlankCell =
      rowIndex < numHeaderRows && columnIndex < numIndexColumns
    const isIndexCell =
      rowIndex >= numHeaderRows && columnIndex < numIndexColumns
    const isColumnsCell =
      rowIndex < numHeaderRows && columnIndex >= numIndexColumns

    if (isBlankCell) {
      // Blank cells include `blank`.
      const cssClass = ["blank"]
      if (columnIndex > 0) {
        cssClass.push(`level${rowIndex}`)
      }

      return {
        type: DataFrameCellType.BLANK,
        cssClass: cssClass.join(" "),
        content: "",
      }
    }

    if (isIndexCell) {
      const dataRowIndex = rowIndex - numHeaderRows

      const cssId = this._styler?.cssId
        ? `${this._styler.cssId}level${columnIndex}_row${dataRowIndex}`
        : undefined

      // Index label cells include:
      // - row_heading
      // - row<n> where n is the numeric position of the row
      // - level<k> where k is the level in a MultiIndex
      const cssClass = [
        `row_heading`,
        `level${columnIndex}`,
        `row${dataRowIndex}`,
      ].join(" ")

      const contentType = this._columnTypes.index[columnIndex]
      const content = this.getIndexValue(dataRowIndex, columnIndex)
      let field = this._fields[`__index_level_${String(columnIndex)}__`]
      if (field === undefined) {
        // If the index column has a name, we need to get it differently:
        field = this._fields[String(numColumns - numIndexColumns)]
      }
      return {
        type: DataFrameCellType.INDEX,
        cssId,
        cssClass,
        content,
        contentType,
        field,
      }
    }

    if (isColumnsCell) {
      const dataColumnIndex = columnIndex - numIndexColumns

      // Column label cells include:
      // - col_heading
      // - col<n> where n is the numeric position of the column
      // - level<k> where k is the level in a MultiIndex
      const cssClass = [
        `col_heading`,
        `level${rowIndex}`,
        `col${dataColumnIndex}`,
      ].join(" ")

      return {
        type: DataFrameCellType.COLUMNS,
        cssClass,
        content: this._columnNames[rowIndex][dataColumnIndex],
        // ArrowJS automatically converts "columns" cells to strings.
        // Keep ArrowJS structure for consistency.
        contentType: {
          pandas_type: "unicode",
          numpy_type: "object",
        },
      }
    }

    const dataRowIndex = rowIndex - numHeaderRows
    const dataColumnIndex = columnIndex - numIndexColumns

    const cssId = this._styler?.cssId
      ? `${this._styler.cssId}row${dataRowIndex}_col${dataColumnIndex}`
      : undefined

    // Data cells include `data`.
    const cssClass = [
      "data",
      `row${dataRowIndex}`,
      `col${dataColumnIndex}`,
    ].join(" ")

    const contentType = this._columnTypes.data[dataColumnIndex]
    const field = this._fields[String(dataColumnIndex)]
    const content = this.getDataValue(dataRowIndex, dataColumnIndex)
    const displayContent = this._styler?.displayValues
      ? (this._styler.displayValues.getCell(rowIndex, columnIndex)
          .content as string)
      : undefined

    return {
      type: DataFrameCellType.DATA,
      cssId,
      cssClass,
      content,
      contentType,
      displayContent,
      field,
    }
  }

  /** Get the raw value of an index cell. */
  public getIndexValue(rowIndex: number, columnIndex: number): any {
    const index = this._indexData[columnIndex]
    const value =
      index instanceof Vector ? index.get(rowIndex) : index[rowIndex]
    return value
  }

  /** Get the raw value of a data cell. */
  public getDataValue(rowIndex: number, columnIndex: number): any {
    return this._data.getChildAt(columnIndex)?.get(rowIndex)
  }

  /**
   * Returns the categorical options defined for a given data column.
   * Returns undefined if the column is not categorical.
   *
   * This function only works for non-index columns and expects the index at 0
   * for the first non-index data column.
   */
  public getCategoricalOptions(dataColumnIndex: number): string[] | undefined {
    const { numDataColumns: numDataColumns } = this.dimensions

    if (dataColumnIndex < 0 || dataColumnIndex >= numDataColumns) {
      throw new Error(`Column index is out of range: ${dataColumnIndex}`)
    }

    if (!(this._fields[String(dataColumnIndex)].type instanceof Dictionary)) {
      // This is not a categorical column
      return undefined
    }

    const categoricalDict =
      this._data.getChildAt(dataColumnIndex)?.data[0]?.dictionary

    return notNullOrUndefined(categoricalDict)
      ? convertVectorToList(categoricalDict)
      : undefined
  }

  /**
   * Add the contents of another table (data + indexes) to this table.
   * Extra columns will not be created.
   */
  public addRows(other: Quiver): Quiver {
    if (this._styler || other._styler) {
      throw new Error(`
Unsupported operation. \`add_rows()\` does not support Pandas Styler objects.

If you do not need the Styler's styles, try passing the \`.data\` attribute of
the Styler object instead to concatenate just the underlying dataframe.

For example:
\`\`\`
st.add_rows(my_styler.data)
\`\`\`
`)
    }

    // Don't do anything if the incoming DataFrame is empty.
    if (other.dimensions.numDataRows === 0) {
      return produce(this, (draft: Quiver) => draft)
    }

    // We need to handle this separately, as columns need to be reassigned.
    // We don't concatenate columns in the general case.
    if (this.dimensions.numDataRows === 0) {
      return produce(other, (draft: Quiver) => draft)
    }

    const {
      index: newIndex,
      data: newData,
      types: newTypes,
    } = concat(
      this._columnTypes,
      this._indexData,
      this._data,
      other._columnTypes,
      other._indexData,
      other._data
    )

    // If we get here, then we had no concatenation errors.
    return produce(this, (draft: Quiver) => {
      draft._indexData = newIndex
      draft._data = newData
      draft._columnTypes = newTypes
    })
  }
}

/** Parse Pandas styler information from proto. */
function parseStyler(pandasStyler: StylerProto): PandasStylerData {
  return {
    uuid: pandasStyler.uuid,
    caption: pandasStyler.caption,
    cssStyles: pandasStyler.styles,
    cssId: pandasStyler.uuid ? `T_${pandasStyler.uuid}` : undefined,
    // Recursively create a new Quiver instance for Styler's display values.
    // This values will be used for rendering the DataFrame, while the original values
    // will be used for sorting, etc.
    displayValues: new Quiver({ data: pandasStyler.displayValues }),
  }
}


================================================
File: /frontend/lib/src/dataframes/arrowConcatUtils.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Utility functions used to concatenate Arrow tables. This is used by
 * the add row functionality for dataframe, table & charts.
 */

import range from "lodash/range"
import zip from "lodash/zip"

import { Data, IndexData, PandasColumnTypes } from "./arrowParseUtils"
import {
  getTypeName,
  PandasColumnType,
  PandasRangeIndex,
  PandasRangeIndexType,
} from "./arrowTypeUtils"

/** True if both arrays contain the same data types in the same order.
 *
 * Dataframes to have the same types if all columns that exist in t1
 * also exist in t2 in the same order and with the same type. t2 can be larger
 * than t1 but not the other way around.
 */
function sameDataTypes(
  t1: PandasColumnType[],
  t2: PandasColumnType[]
): boolean {
  return t1.every(
    (type: PandasColumnType, index: number) =>
      type.pandas_type === t2[index]?.pandas_type
  )
}

/** True if both arrays contain the same index types in the same order.
 * If the arrays have different lengths, they are never the same
 */
function sameIndexTypes(
  t1: PandasColumnType[],
  t2: PandasColumnType[]
): boolean {
  // Make sure both indexes have same dimensions.
  if (t1.length !== t2.length) {
    return false
  }

  return t1.every(
    (type: PandasColumnType, index: number) =>
      index < t2.length && getTypeName(type) === getTypeName(t2[index])
  )
}

/** Concatenate the original DataFrame index with the given one. */
function concatIndexes(
  baseIndex: IndexData,
  baseIndexTypes: PandasColumnType[],
  appendIndex: IndexData,
  appendIndexTypes: PandasColumnType[]
): IndexData {
  // If one of the `index` arrays is empty, return the other one.
  // Otherwise, they will have different types and an error will be thrown.
  if (appendIndex.length === 0) {
    return baseIndex
  }
  if (baseIndex.length === 0) {
    return appendIndex
  }

  // Make sure indexes have same types.
  if (!sameIndexTypes(baseIndexTypes, appendIndexTypes)) {
    const receivedIndexTypes = appendIndexTypes.map(index =>
      getTypeName(index)
    )
    const expectedIndexTypes = baseIndexTypes.map(index => getTypeName(index))

    throw new Error(`
Unsupported operation. The data passed into \`add_rows()\` must have the same
index signature as the original data.

In this case, \`add_rows()\` received \`${JSON.stringify(receivedIndexTypes)}\`
but was expecting \`${JSON.stringify(expectedIndexTypes)}\`.
`)
  }

  if (baseIndexTypes.length === 0) {
    // This should never happen!
    throw new Error("There was an error while parsing index types.")
  }

  // NOTE: "range" index cannot be a part of a multi-index, i.e.
  // if the index type is "range", there will only be one element in the index array.
  if (baseIndexTypes[0].pandas_type === PandasRangeIndexType) {
    // Continue the sequence for a "range" index.
    // NOTE: The metadata of the original index will be used, i.e.
    // if both indexes are of type "range" and they have different
    // metadata (start, step, stop) values, the metadata of the given
    // index will be ignored.
    const { step, stop } = baseIndexTypes[0].meta as PandasRangeIndex
    appendIndex = [
      range(
        stop,
        // End is not inclusive
        stop + appendIndex[0].length * step,
        step
      ),
    ]
  }

  // Concatenate each index with its counterpart in the other table
  const zipped = zip(baseIndex, appendIndex)
  // @ts-expect-error We know the two indexes are of the same size
  return zipped.map(a => a[0].concat(a[1]))
}

/** Concatenate the original DataFrame data with the given one. */
function concatData(
  baseData: Data,
  baseDataType: PandasColumnType[],
  appendData: Data,
  appendDataType: PandasColumnType[]
): Data {
  // If one of the `data` arrays is empty, return the other one.
  // Otherwise, they will have different types and an error will be thrown.
  if (appendData.numCols === 0) {
    return baseData
  }
  if (baseData.numCols === 0) {
    return appendData
  }

  // Make sure `data` arrays have the same types.
  if (!sameDataTypes(baseDataType, appendDataType)) {
    const receivedDataTypes = appendDataType.map(t => t.pandas_type)
    const expectedDataTypes = baseDataType.map(t => t.pandas_type)

    throw new Error(`
Unsupported operation. The data passed into \`add_rows()\` must have the same
data signature as the original data.

In this case, \`add_rows()\` received \`${JSON.stringify(receivedDataTypes)}\`
but was expecting \`${JSON.stringify(expectedDataTypes)}\`.
`)
  }

  // Remove extra columns from the "append" DataFrame.
  // Columns from appendData are used by index without checking column names.
  const slicedAppendData = appendData.selectAt(range(0, baseData.numCols))
  return baseData.concat(slicedAppendData)
}

/** Concatenate index and data types. */
function concatTypes(
  baseTypes: PandasColumnTypes,
  appendTypes: PandasColumnTypes
): PandasColumnTypes {
  const index = concatIndexTypes(baseTypes.index, appendTypes.index)
  const data = concatDataTypes(baseTypes.data, appendTypes.data)
  return { index, data }
}

/** Concatenate index types. */
function concatIndexTypes(
  baseIndexTypes: PandasColumnType[],
  appendIndexTypes: PandasColumnType[]
): PandasColumnType[] {
  // If one of the `types` arrays is empty, return the other one.
  // Otherwise, an empty array will be returned.
  if (appendIndexTypes.length === 0) {
    return baseIndexTypes
  }
  if (baseIndexTypes.length === 0) {
    return appendIndexTypes
  }

  // Make sure indexes have same types.
  if (!sameIndexTypes(baseIndexTypes, appendIndexTypes)) {
    const receivedIndexTypes = appendIndexTypes.map(index =>
      getTypeName(index)
    )
    const expectedIndexTypes = baseIndexTypes.map(index => getTypeName(index))

    throw new Error(`
Unsupported operation. The data passed into \`add_rows()\` must have the same
index signature as the original data.

In this case, \`add_rows()\` received \`${JSON.stringify(receivedIndexTypes)}\`
but was expecting \`${JSON.stringify(expectedIndexTypes)}\`.
`)
  }

  // TL;DR This sets the new stop value.
  return baseIndexTypes.map(indexType => {
    // NOTE: "range" index cannot be a part of a multi-index, i.e.
    // if the index type is "range", there will only be one element in the index array.
    if (indexType.pandas_type === PandasRangeIndexType) {
      const { stop, step } = indexType.meta as PandasRangeIndex
      const {
        start: appendStart,
        stop: appendStop,
        step: appendStep,
      } = appendIndexTypes[0].meta as PandasRangeIndex
      const appendRangeIndexLength = (appendStop - appendStart) / appendStep
      const newStop = stop + appendRangeIndexLength * step
      return {
        ...indexType,
        meta: {
          ...indexType.meta,
          stop: newStop,
        },
      }
    }
    return indexType
  })
}

/** Concatenate types of data columns. */
function concatDataTypes(
  baseDataTypes: PandasColumnType[],
  appendDataTypes: PandasColumnType[]
): PandasColumnType[] {
  if (baseDataTypes.length === 0) {
    return appendDataTypes
  }

  return baseDataTypes
}

/** Concatenate the index, data, and types of parsed arrow tables. */
export function concat(
  baseTypes: PandasColumnTypes,
  baseIndex: IndexData,
  baseData: Data,
  appendTypes: PandasColumnTypes,
  appendIndex: IndexData,
  appendData: Data
): { index: IndexData; data: Data; types: PandasColumnTypes } {
  // Concatenate all data into temporary variables. If any of
  // these operations fail, an error will be thrown and we'll prematurely
  // exit the function.
  const index = concatIndexes(
    baseIndex,
    baseTypes.index,
    appendIndex,
    appendTypes.index
  )
  const data = concatData(
    baseData,
    baseTypes.data,
    appendData,
    appendTypes.data
  )
  const types = concatTypes(baseTypes, appendTypes)

  return { index, data, types }
}


================================================
File: /frontend/lib/src/dataframes/arrowFormatUtils.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Field, Timestamp, TimeUnit, vectorFromArray } from "apache-arrow"

import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import {
  DECIMAL,
  DICTIONARY,
  INT64,
  INTERVAL_DATETIME64,
  INTERVAL_FLOAT64,
  INTERVAL_INT64,
  INTERVAL_UINT64,
  PERIOD,
  TIMEDELTA,
  UINT64,
} from "@streamlit/lib/src/mocks/arrow"

import {
  convertTimeToDate,
  format,
  formatPeriodFromFreq,
} from "./arrowFormatUtils"

describe("format", () => {
  test("null", () => {
    expect(format(null)).toEqual("<NA>")
  })

  test("string", () => {
    expect(format("foo")).toEqual("foo")
  })

  test("boolean", () => {
    expect(format(true)).toEqual("true")
  })

  test("float64", () => {
    expect(
      format(1.25, {
        pandas_type: "float64",
        numpy_type: "float64",
      })
    ).toEqual("1.2500")
  })

  test("int64", () => {
    const mockElement = { data: INT64 }
    const q = new Quiver(mockElement)
    const { content } = q.getCell(1, 2)

    expect(
      format(content, {
        pandas_type: "int64",
        numpy_type: "int64",
      })
    ).toEqual("1")
  })

  test("uint64", () => {
    const mockElement = { data: UINT64 }
    const q = new Quiver(mockElement)
    const { content } = q.getCell(1, 2)

    expect(
      format(content, {
        pandas_type: "uint64",
        numpy_type: "uint64",
      })
    ).toEqual("2")
  })

  test("bytes", () => {
    expect(
      format(new Uint8Array([1, 2, 3]), {
        pandas_type: "bytes",
        numpy_type: "bytes",
      })
    ).toEqual("1,2,3")
  })

  test("date", () => {
    expect(
      format(new Date(Date.UTC(1970, 0, 1)), {
        pandas_type: "date",
        numpy_type: "object",
      })
    ).toEqual("1970-01-01")
  })

  test("datetime", () => {
    expect(
      format(
        0,
        {
          pandas_type: "datetime",
          numpy_type: "datetime64[ns]",
        },
        new Field("test", new Timestamp(TimeUnit.SECOND), true, null)
      )
    ).toEqual("1970-01-01 00:00:00")
  })

  test("datetimetz", () => {
    expect(
      format(
        0,
        {
          pandas_type: "datetimetz",
          numpy_type: "datetime64[ns]",
        },
        new Field(
          "test",
          new Timestamp(TimeUnit.SECOND, "Europe/Moscow"),
          true,
          null
        )
      )
    ).toEqual("1970-01-01 03:00:00+03:00")
  })

  test("datetimetz with offset", () => {
    expect(
      format(
        0,
        {
          pandas_type: "datetimetz",
          numpy_type: "datetime64[ns]",
        },
        new Field("test", new Timestamp(TimeUnit.SECOND, "+01:00"), true, null)
      )
    ).toEqual("1970-01-01 01:00:00+01:00")
  })

  test("interval datetime64[ns]", () => {
    const mockElement = { data: INTERVAL_DATETIME64 }
    const q = new Quiver(mockElement)
    const { content, contentType, field } = q.getCell(1, 0)

    expect(format(content, contentType, field)).toEqual(
      "(2017-01-01 00:00:00, 2017-01-02 00:00:00]"
    )
  })

  test("interval float64", () => {
    const mockElement = { data: INTERVAL_FLOAT64 }
    const q = new Quiver(mockElement)
    const { content, contentType, field } = q.getCell(1, 0)

    expect(format(content, contentType, field)).toEqual("(0.0000, 1.5000]")
  })

  test("interval int64", () => {
    const mockElement = { data: INTERVAL_INT64 }
    const q = new Quiver(mockElement)
    const { content, field } = q.getCell(1, 0)

    expect(
      format(
        content,
        {
          pandas_type: "object",
          numpy_type: "interval[int64, right]",
        },
        field
      )
    ).toEqual("(0, 1]")
  })

  test("interval uint64", () => {
    const mockElement = { data: INTERVAL_UINT64 }
    const q = new Quiver(mockElement)
    const { content, contentType, field } = q.getCell(1, 0)

    expect(format(content, contentType, field)).toEqual("(0, 1]")
  })

  test("decimal", () => {
    const mockElement = { data: DECIMAL }
    const q = new Quiver(mockElement)
    const cell1 = q.getCell(1, 1)
    expect(format(cell1.content, cell1.contentType, cell1.field)).toEqual(
      "1.1"
    )

    const cell2 = q.getCell(2, 1)
    expect(format(cell2.content, cell2.contentType, cell2.field)).toEqual(
      "10000"
    )

    const cell3 = q.getCell(1, 2)
    expect(format(cell3.content, cell3.contentType, cell3.field)).toEqual(
      "2.23"
    )

    const cell4 = q.getCell(2, 2)
    expect(format(cell4.content, cell4.contentType, cell4.field)).toEqual(
      "-0.1"
    )
  })

  test("timedelta", () => {
    const mockElement = { data: TIMEDELTA }
    const q = new Quiver(mockElement)
    const cell1 = q.getCell(1, 1)
    expect(format(cell1.content, cell1.contentType, cell1.field)).toEqual(
      "a few seconds"
    )

    const cell2 = q.getCell(2, 1)
    expect(format(cell2.content, cell2.contentType, cell2.field)).toEqual(
      "4 hours"
    )

    const cell3 = q.getCell(1, 2)
    expect(format(cell3.content, cell3.contentType, cell3.field)).toEqual(
      "20 days"
    )

    const cell4 = q.getCell(2, 2)
    expect(format(cell4.content, cell4.contentType, cell4.field)).toEqual(
      "2 hours"
    )
  })

  test("dictionary", () => {
    const mockElement = { data: DICTIONARY }
    const q = new Quiver(mockElement)
    const { content, contentType, field } = q.getCell(1, 1)
    expect(format(content, contentType, field)).toEqual(`{"a":1,"b":2}`)
  })

  test("period", () => {
    const mockElement = { data: PERIOD }
    const q = new Quiver(mockElement)
    const { numRows, numColumns } = q.dimensions
    const table: Record<string, string[]> = {}
    for (let columnIndex = 1; columnIndex < numColumns; columnIndex++) {
      const column = []
      for (let rowIndex = 0; rowIndex < numRows; rowIndex++) {
        const { content, contentType, field } = q.getCell(
          rowIndex,
          columnIndex
        )
        const cellValue = format(content, contentType, field)
        column.push(cellValue)
      }
      table[column[0]] = [column[1], column[2]]
    }

    expect(table).toEqual({
      A: ["2012", "1970"],
      M: ["2012-02", "1970-01"],
      Y: ["2012", "1970"],
      h: ["2012-02-14 00:00", "1970-01-01 00:00"],
      min: ["2012-02-14 00:00", "1970-01-01 00:00"],
      ms: ["2012-02-14 00:00:00.000", "1970-01-01 00:00:00.000"],
      s: ["2012-02-14 00:00:00", "1970-01-01 00:00:00"],
      L: ["2012-02-14 00:00:00.000", "1970-01-01 00:00:00.000"],
      S: ["2012-02-14 00:00:00", "1970-01-01 00:00:00"],
      T: ["2012-02-14 00:00", "1970-01-01 00:00"],
      H: ["2012-02-14 00:00", "1970-01-01 00:00"],
      D: ["2012-02-14", "1970-01-01"],
      W: ["2012-02-13/2012-02-19", "1969-12-29/1970-01-04"],
      "W-SUN": ["2012-02-13/2012-02-19", "1969-12-29/1970-01-04"],
      "W-MON": ["2012-02-14/2012-02-20", "1969-12-30/1970-01-05"],
      "W-TUE": ["2012-02-08/2012-02-14", "1969-12-31/1970-01-06"],
      "W-WED": ["2012-02-09/2012-02-15", "1970-01-01/1970-01-07"],
      "W-THU": ["2012-02-10/2012-02-16", "1969-12-26/1970-01-01"],
      "W-FRI": ["2012-02-11/2012-02-17", "1969-12-27/1970-01-02"],
      "W-SAT": ["2012-02-12/2012-02-18", "1969-12-28/1970-01-03"],
      Q: ["2012Q1", "1970Q1"],
      "Q-JAN": ["2013Q1", "1970Q4"],
      "Q-FEB": ["2012Q4", "1970Q4"],
      "Q-MAR": ["2012Q4", "1970Q4"],
      "Q-APR": ["2012Q4", "1970Q3"],
      "Q-MAY": ["2012Q3", "1970Q3"],
      "Q-JUN": ["2012Q3", "1970Q3"],
      "Q-JUL": ["2012Q3", "1970Q2"],
      "Q-AUG": ["2012Q2", "1970Q2"],
      "Q-SEP": ["2012Q2", "1970Q2"],
      "Q-OCT": ["2012Q2", "1970Q1"],
      "Q-NOV": ["2012Q1", "1970Q1"],
      "Q-DEC": ["2012Q1", "1970Q1"],
    })
  })

  test("list[unicode]", () => {
    expect(
      format(vectorFromArray(["foo", "bar", "baz"]), {
        pandas_type: "list[unicode]",
        numpy_type: "object",
      })
    ).toEqual('["foo","bar","baz"]')
  })
})

describe("formatPeriodFromFreq", () => {
  it.each([
    // Basic frequencies
    [1, "Y", "1971"],
    [1, "M", "1970-02"],
    [1, "D", "1970-01-02"],
    [1, "h", "1970-01-01 01:00"],
    [1, "min", "1970-01-01 00:01"],
    [1, "s", "1970-01-01 00:00:01"],
    [1, "ms", "1970-01-01 00:00:00.001"],
    // Weekly frequencies
    [1, "W-MON", "1969-12-30/1970-01-05"],
    [1, "W-TUE", "1969-12-31/1970-01-06"],
    [1, "W-WED", "1970-01-01/1970-01-07"],
    [1, "W-THU", "1970-01-02/1970-01-08"],
    [1, "W-FRI", "1970-01-03/1970-01-09"],
    [1, "W-SAT", "1970-01-04/1970-01-10"],
    [1, "W-SUN", "1969-12-29/1970-01-04"],
    // Invalid frequencies
    [1, "invalid", "1"],
  ])("formats %s with frequency %s to %s", (value, freq, expected) => {
    expect(formatPeriodFromFreq(value, freq as any)).toEqual(expected)
  })

  test("handles weekly frequency without parameter", () => {
    expect(() => formatPeriodFromFreq(1, "W")).toThrow(
      'Frequency "W" requires parameter'
    )
  })

  test("handles weekly frequency with invalid parameter", () => {
    expect(() => formatPeriodFromFreq(1, "W-INVALID")).toThrow(
      'Invalid value: INVALID. Supported values: ["SUN","MON","TUE","WED","THU","FRI","SAT"]'
    )
  })
})

describe("convertTimestampToDate", () => {
  test.each([
    // [timestamp, unit, expected date string]
    [1000, TimeUnit.SECOND, "1970-01-01T00:16:40.000Z"],
    [1000, TimeUnit.MILLISECOND, "1970-01-01T00:00:01.000Z"],
    [1000, TimeUnit.MICROSECOND, "1970-01-01T00:00:00.001Z"],
    [1000, TimeUnit.NANOSECOND, "1970-01-01T00:00:00.000Z"],
    // Test with BigInt values
    [BigInt(1000), TimeUnit.SECOND, "1970-01-01T00:16:40.000Z"],
    [BigInt(1000), TimeUnit.MILLISECOND, "1970-01-01T00:00:01.000Z"],
    // Test with undefined field (should default to SECOND)
    [1000, undefined, "1970-01-01T00:16:40.000Z"],
    // Test with large timestamps
    [1647356400, TimeUnit.SECOND, "2022-03-15T15:00:00.000Z"],
    [1647356400000, TimeUnit.MILLISECOND, "2022-03-15T15:00:00.000Z"],
  ])("converts time %s with unit %s to %s", (timestamp, unit, expected) => {
    const result = convertTimeToDate(
      timestamp,
      unit ? new Field("test", new Timestamp(unit), true, null) : undefined
    )
    expect(result.toISOString()).toBe(expected)
  })
})


================================================
File: /frontend/lib/src/dataframes/arrowFormatUtils.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Utility functions to format cell data from an arrow table to
 * a human-readable format.
 */

import {
  Field,
  Float,
  Struct,
  StructRow,
  Timestamp,
  TimeUnit,
  util,
} from "apache-arrow"
import trimEnd from "lodash/trimEnd"
import moment from "moment-timezone"
import numbro from "numbro"

import { logWarning } from "@streamlit/lib/src/util/log"
import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

import {
  DataType,
  isDatetimeType,
  isDateType,
  isDecimalType,
  isDurationType,
  isFloatType,
  isIntervalType,
  isListType,
  isObjectType,
  isPeriodType,
  isTimeType,
  PandasColumnType,
} from "./arrowTypeUtils"

/**
 * The frequency strings defined in pandas.
 * See: https://pandas.pydata.org/docs/user_guide/timeseries.html#period-aliases
 * Not supported: "N" (nanoseconds), "U" & "us" (microseconds), and "B" (business days).
 * Reason is that these types are not supported by moment.js, but also they are not
 * very commonly used in practice.
 */
type SupportedPandasOffsetType =
  // yearly frequency:
  | "A" // deprecated alias
  | "Y"
  // quarterly frequency:
  | "Q"
  // monthly frequency:
  | "M"
  // weekly frequency:
  | "W"
  // calendar day frequency:
  | "D"
  // hourly frequency:
  | "H" // deprecated alias
  | "h"
  // minutely frequency
  | "T" // deprecated alias
  | "min"
  // secondly frequency:
  | "S" // deprecated alias
  | "s"
  // milliseconds frequency:
  | "L" // deprecated alias
  | "ms"

type PandasPeriodFrequency =
  | SupportedPandasOffsetType
  | `${SupportedPandasOffsetType}-${string}`

const WEEKDAY_SHORT = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"]
const formatMs = (duration: number): string =>
  moment("19700101", "YYYYMMDD")
    .add(duration, "ms")
    .format("YYYY-MM-DD HH:mm:ss.SSS")

const formatSec = (duration: number): string =>
  moment("19700101", "YYYYMMDD")
    .add(duration, "s")
    .format("YYYY-MM-DD HH:mm:ss")

const formatMin = (duration: number): string =>
  moment("19700101", "YYYYMMDD").add(duration, "m").format("YYYY-MM-DD HH:mm")

const formatHours = (duration: number): string =>
  moment("19700101", "YYYYMMDD").add(duration, "h").format("YYYY-MM-DD HH:mm")

const formatDay = (duration: number): string =>
  moment("19700101", "YYYYMMDD").add(duration, "d").format("YYYY-MM-DD")

const formatMonth = (duration: number): string =>
  moment("19700101", "YYYYMMDD").add(duration, "M").format("YYYY-MM")

const formatYear = (duration: number): string =>
  moment("19700101", "YYYYMMDD").add(duration, "y").format("YYYY")

const formatWeeks = (duration: number, freqParam?: string): string => {
  if (!freqParam) {
    throw new Error('Frequency "W" requires parameter')
  }
  const dayIndex = WEEKDAY_SHORT.indexOf(freqParam)
  if (dayIndex < 0) {
    throw new Error(
      `Invalid value: ${freqParam}. Supported values: ${JSON.stringify(
        WEEKDAY_SHORT
      )}`
    )
  }
  const startDate = moment("19700101", "YYYYMMDD")
    .add(duration, "w")
    .day(dayIndex - 6)
    .format("YYYY-MM-DD")
  const endDate = moment("19700101", "YYYYMMDD")
    .add(duration, "w")
    .day(dayIndex)
    .format("YYYY-MM-DD")

  return `${startDate}/${endDate}`
}

const formatQuarter = (duration: number): string =>
  moment("19700101", "YYYYMMDD")
    .add(duration, "Q")
    .endOf("quarter")
    .format("YYYY[Q]Q")

/**
 * Formatters for the different pandas period frequencies.
 *
 * This is a mapping from the frequency strings to the function that formats the period.
 */
const PERIOD_TYPE_FORMATTERS: Record<
  SupportedPandasOffsetType,
  (duration: number, freqParam?: string) => string
> = {
  L: formatMs,
  ms: formatMs,
  S: formatSec,
  s: formatSec,
  T: formatMin,
  min: formatMin,
  H: formatHours,
  h: formatHours,
  D: formatDay,
  M: formatMonth,
  W: formatWeeks,
  Q: formatQuarter,
  Y: formatYear,
  A: formatYear,
}

/** Pandas interval extension data type. */
interface PandasInterval {
  left: number
  right: number
}

/**
 * Adjusts a time value to seconds based on the unit information in the field.
 *
 * The unit numbers are specified here:
 * https://github.com/apache/arrow/blob/3ab246f374c17a216d86edcfff7ff416b3cff803/js/src/enum.ts#L95
 *
 * @param timestamp The timestamp to convert.
 * @param unit The unit of the timestamp. 0 is seconds, 1 is milliseconds, 2 is microseconds, 3 is nanoseconds.
 * @returns The timestamp in seconds.
 */
function convertTimestampToSeconds(
  timestamp: number | bigint,
  unit: TimeUnit
): number {
  let unitAdjustment

  if (unit === TimeUnit.MILLISECOND) {
    // Milliseconds
    unitAdjustment = 1000
  } else if (unit === TimeUnit.MICROSECOND) {
    // Microseconds
    unitAdjustment = 1000 * 1000
  } else if (unit === TimeUnit.NANOSECOND) {
    // Nanoseconds
    unitAdjustment = 1000 * 1000 * 1000
  } else {
    // Interpret it as seconds as a fallback
    return Number(timestamp)
  }

  // Do the calculation based on bigints, if the value
  // is a bigint and not safe for usage as number.
  // This might lose some precision since it doesn't keep
  // fractional parts.
  if (
    typeof timestamp === "bigint" &&
    !Number.isSafeInteger(Number(timestamp))
  ) {
    return Number(timestamp / BigInt(unitAdjustment))
  }

  return Number(timestamp) / unitAdjustment
}

/**
 * Converts a UTC time value (timestamp) to a date object.
 *
 * @param timestamp The timestamp to convert.
 * @param field The field containing the unit information.
 * @returns The date object in UTC timezone.
 */
export function convertTimeToDate(
  timestamp: number | bigint,
  field?: Field
): Date {
  // Time values from arrow are not converted to a shared unit and
  // just return the raw arrow value. Therefore, we need to adjust
  // the value to seconds based on the unit information in the field.
  // https://github.com/apache/arrow/blob/9e08c57c0986531879aadf7942998d26a94a5d1b/js/src/visitor/get.ts#L193C7-L209
  const timeInSeconds = convertTimestampToSeconds(
    timestamp,
    // The default is SECOND because that is the default unit for time values in pandas.
    // Though we believe that actually always a unit is populated by arrow.
    field?.type?.unit ?? TimeUnit.SECOND
  )
  return moment.unix(timeInSeconds).utc().toDate()
}

/**
 * Formats a time value based on the unit information in the field.
 *
 * @param timestamp The time value to format.
 * @param field The field containing the unit information.
 * @returns The formatted time value.
 */
function formatTime(timestamp: number | bigint, field?: Field): string {
  const date = convertTimeToDate(timestamp, field)
  return moment(date)
    .utc()
    .format(date.getMilliseconds() === 0 ? "HH:mm:ss" : "HH:mm:ss.SSS")
}

function formatDate(date: number | Date): string {
  // Date values from arrow are already converted to a date object
  // or a timestamp in milliseconds even if the field unit belonging to the
  // passed date might have indicated a different unit.
  // Thats why we don't need the field information here (aka its not passed to the function)
  // and we don't need to apply any unit conversion.
  // https://github.com/apache/arrow/blob/9e08c57c0986531879aadf7942998d26a94a5d1b/js/src/visitor/get.ts#L167-L171

  const formatPattern = "YYYY-MM-DD"

  if (
    !(
      date instanceof Date ||
      (typeof date === "number" && Number.isFinite(date))
    )
  ) {
    logWarning(`Unsupported date value: ${date}`)
    return String(date)
  }

  return moment.utc(date).format(formatPattern)
}

/**
 * Format datetime value from Arrow to string.
 */
function formatDatetime(date: number | Date, field?: Field): string {
  // Datetime values from arrow are already converted to a date object
  // or a timestamp in milliseconds even if the field unit might indicate a
  // different unit.
  // https://github.com/apache/arrow/blob/9e08c57c0986531879aadf7942998d26a94a5d1b/js/src/visitor/get.ts#L174-L190

  if (
    !(
      date instanceof Date ||
      (typeof date === "number" && Number.isFinite(date))
    )
  ) {
    logWarning(`Unsupported datetime value: ${date}`)
    return String(date)
  }

  let datetime = moment.utc(date)

  const timezone = field?.type?.timezone
  if (timezone) {
    if (moment.tz.zone(timezone)) {
      // If timezone is a valid timezone name (e.g., "America/New_York")
      datetime = datetime.tz(timezone)
    } else {
      // If timezone is a UTC offset (e.g., "+0500")
      datetime = datetime.utcOffset(timezone)
    }

    return datetime.format("YYYY-MM-DD HH:mm:ssZ")
  }
  // Return the timestamp without timezone information
  return datetime.format("YYYY-MM-DD HH:mm:ss")
}

/**
 * Formats a duration value based on the unit information in the field.
 *
 * @param duration The duration value to format.
 * @param field The field containing the unit information.
 * @returns The formatted duration value.
 */
function formatDuration(duration: number | bigint, field?: Field): string {
  // unit: 0 is seconds, 1 is milliseconds, 2 is microseconds, 3 is nanoseconds.
  return moment
    .duration(
      convertTimestampToSeconds(
        duration,
        // The default is NANOSECOND because that is the default unit for duration in pandas.
        // Though we believe that actually always a unit is populated by arrow.
        field?.type?.unit ?? TimeUnit.NANOSECOND
      ),
      "seconds"
    )
    .humanize()
}

/**
 * Formats a decimal value with a given scale to a string.
 *
 * This code is partly based on: https://github.com/apache/arrow/issues/35745
 *
 * TODO: This is only a temporary workaround until ArrowJS can format decimals correctly.
 * This is tracked here:
 * https://github.com/apache/arrow/issues/37920
 * https://github.com/apache/arrow/issues/28804
 * https://github.com/apache/arrow/issues/35745
 */
function formatDecimal(value: Uint32Array, field?: Field): string {
  const scale = field?.type?.scale || 0

  // Format Uint32Array to a numerical string and pad it with zeros
  // So that it is exactly the length of the scale.
  let numString = util.bigNumToString(new util.BN(value)).padStart(scale, "0")

  // ArrowJS 13 correctly adds a minus sign for negative numbers.
  // but it doesn't handle th fractional part yet. So we can just return
  // the value if scale === 0, but we need to do some additional processing
  // for the fractional part if scale > 0.

  if (scale === 0) {
    return numString
  }

  let sign = ""
  if (numString.startsWith("-")) {
    // Check if number is negative, and if so remember the sign and remove it.
    // We will add it back later.
    sign = "-"
    numString = numString.slice(1)
  }
  // Extract the whole number part. If the number is < 1, it doesn't
  // have a whole number part, so we'll use "0" instead.
  // E.g for 123450 with scale 3, we'll get "123" as the whole part.
  const wholePart = numString.slice(0, -scale) || "0"
  // Extract the fractional part and remove trailing zeros.
  // E.g. for 123450 with scale 3, we'll get "45" as the fractional part.
  const decimalPart = trimEnd(numString.slice(-scale), "0") || ""
  // Combine the parts and add the sign.
  return `${sign}${wholePart}` + (decimalPart ? `.${decimalPart}` : "")
}

export function formatPeriodFromFreq(
  duration: number | bigint,
  freq: PandasPeriodFrequency
): string {
  const [freqName, freqParam] = freq.split("-", 2)
  const momentConverter =
    PERIOD_TYPE_FORMATTERS[freqName as SupportedPandasOffsetType]
  if (!momentConverter) {
    logWarning(`Unsupported period frequency: ${freq}`)
    return String(duration)
  }
  const durationNumber = Number(duration)
  if (!Number.isSafeInteger(durationNumber)) {
    logWarning(
      `Unsupported value: ${duration}. Supported values: [${Number.MIN_SAFE_INTEGER}-${Number.MAX_SAFE_INTEGER}]`
    )
    return String(duration)
  }
  return momentConverter(durationNumber, freqParam)
}

function formatPeriod(duration: number | bigint, field?: Field): string {
  // Serialization for pandas.Period is provided by Arrow extensions
  // https://github.com/pandas-dev/pandas/blob/70bb855cbbc75b52adcb127c84e0a35d2cd796a9/pandas/core/arrays/arrow/extension_types.py#L26
  if (isNullOrUndefined(field)) {
    logWarning("Field information is missing")
    return String(duration)
  }

  const extensionName = field.metadata.get("ARROW:extension:name")
  const extensionMetadata = field.metadata.get("ARROW:extension:metadata")

  if (
    isNullOrUndefined(extensionName) ||
    isNullOrUndefined(extensionMetadata)
  ) {
    logWarning("Arrow extension metadata is missing")
    return String(duration)
  }

  if (extensionName !== "pandas.period") {
    logWarning(`Unsupported extension name for period type: ${extensionName}`)
    return String(duration)
  }

  const parsedExtensionMetadata = JSON.parse(extensionMetadata as string)
  const { freq } = parsedExtensionMetadata
  return formatPeriodFromFreq(duration, freq)
}

/**
 * Formats nested arrays and other objects to a JSON string.
 *
 * @param object The value to format.
 * @param field The field metadata from arrow containing metadata about the column.
 * @returns The formatted JSON string.
 */
function formatObject(object: any, field?: Field): string {
  if (field?.type instanceof Struct) {
    // This type is used by python dictionary values

    return JSON.stringify(object, (_key, value) => {
      if (!notNullOrUndefined(value)) {
        // Workaround: Arrow JS adds all properties from all cells
        // as fields. When you convert to string, it will contain lots of fields with
        // null values. To mitigate this, we filter out null values.
        return undefined
      }
      if (typeof value === "bigint") {
        // JSON.stringify fails to serialize bigint values, therefore we have to
        // handle them manually.
        // TODO(lukasmasuch): Would it be better to serialize it to a string to
        // not lose precision?
        return Number(value)
      }
      return value
    })
  }

  // TODO(lukasmasuch): Investigate if we can unify this with the logic above.
  return JSON.stringify(object, (_key, value) =>
    typeof value === "bigint" ? Number(value) : value
  )
}

/**
 * Formats a float value to a string.
 *
 * @param num The float value to format.
 * @returns The formatted float value.
 */
function formatFloat(num: number): string {
  if (!Number.isFinite(num)) {
    return String(num)
  }

  return numbro(num).format("0,0.0000")
}

/**
 * Formats an interval value from arrow to string.
 */
function formatInterval(x: StructRow, field?: Field): string {
  // Serialization for pandas.Interval is provided by Arrow extensions
  // https://github.com/pandas-dev/pandas/blob/235d9009b571c21b353ab215e1e675b1924ae55c/
  // pandas/core/arrays/arrow/extension_types.py#L17
  const extensionName = field && field.metadata.get("ARROW:extension:name")
  if (extensionName && extensionName === "pandas.interval") {
    const extensionMetadata = JSON.parse(
      field.metadata.get("ARROW:extension:metadata") as string
    )
    const { subtype, closed } = extensionMetadata

    const interval = (x as StructRow).toJSON() as PandasInterval

    const leftBracket = closed === "both" || closed === "left" ? "[" : "("
    const rightBracket = closed === "both" || closed === "right" ? "]" : ")"

    const leftInterval = format(
      interval.left,
      {
        pandas_type: subtype,
        numpy_type: subtype,
      },
      (field.type as Struct)?.children?.[0]
    )
    const rightInterval = format(
      interval.right,
      {
        pandas_type: subtype,
        numpy_type: subtype,
      },
      (field.type as Struct)?.children?.[1]
    )

    return `${leftBracket + leftInterval}, ${rightInterval + rightBracket}`
  }
  return String(x)
}

/** Takes the cell data and type metadata from arrow and nicely formats it into a human-readable string.
 *
 * This is mostly a best-effort logic and should not throw exceptions in case of unknown values
 * or other issues. This makes it easier to use this method by consumers (table, dataframe) since
 * they would have to somehow deal with the exception on a cell level to not crash the full table or app.
 *
 * @param x The cell value.
 * @param pandasType The type metadata based on the pandas metadata embedded in the arrow table.
 * @param field The field metadata from arrow containing metadata about the column.
 * @returns The formatted cell value.
 */
export function format(
  x: DataType,
  pandasType?: PandasColumnType,
  field?: Field
): string {
  const extensionName = field && field.metadata.get("ARROW:extension:name")
  const fieldType = field?.type

  if (isNullOrUndefined(x)) {
    return "<NA>"
  }

  // date
  const isDate = x instanceof Date || Number.isFinite(x)
  if (isDate && isDateType(pandasType)) {
    return formatDate(x as Date | number)
  }

  // time
  if (typeof x === "bigint" && isTimeType(pandasType)) {
    return formatTime(Number(x), field)
  }

  // datetimetz, datetime, datetime64, datetime64[ns], etc.
  if (
    isDate &&
    (isDatetimeType(pandasType) || fieldType instanceof Timestamp)
  ) {
    return formatDatetime(x as Date | number, field)
  }

  if (isPeriodType(pandasType) || extensionName === "pandas.period") {
    return formatPeriod(x as bigint, field)
  }

  if (isIntervalType(pandasType) || extensionName === "pandas.interval") {
    return formatInterval(x as StructRow, field)
  }

  if (isDurationType(pandasType)) {
    return formatDuration(x as number | bigint, field)
  }

  if (isDecimalType(pandasType)) {
    return formatDecimal(x as Uint32Array, field)
  }

  if (
    (isFloatType(pandasType) || fieldType instanceof Float) &&
    Number.isFinite(x)
  ) {
    return formatFloat(x as number)
  }

  if (isObjectType(pandasType) || isListType(pandasType)) {
    return formatObject(x, field)
  }

  return String(x)
}


================================================
File: /frontend/lib/src/dataframes/arrowParseUtils.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Utility functions used by Quiver to parse arrow data from IPC bytes.
 */

import {
  Schema as ArrowSchema,
  Field,
  Null,
  Table,
  tableFromIPC,
  Vector,
} from "apache-arrow"
import range from "lodash/range"
import unzip from "lodash/unzip"

import { isNullOrUndefined } from "@streamlit/lib/src/util/utils"

import {
  PandasColumnType,
  PandasRangeIndex,
  PandasRangeIndexType,
} from "./arrowTypeUtils"

/**
 * Index data value.
 */
type IndexValue = Vector | number[]

/**
 * A row-major matrix of DataFrame index data values.
 */
export type IndexData = IndexValue[]

/**
 * A row-major matrix of DataFrame column header names.
 * This is a matrix (multidimensional array) to support multi-level headers.
 *
 * NOTE: ArrowJS automatically formats the columns in schema, i.e. we always get strings.
 */
export type ColumnNames = string[][]

/**
 * A row-major grid of DataFrame data.
 */
export type Data = Table

/** A DataFrame's index and data column (pandas) types. */
export interface PandasColumnTypes {
  /** Types for each index column. */
  index: PandasColumnType[]

  /** Types for each data column. */
  data: PandasColumnType[]
}

/**
 * Metadata for a single column in an Arrow table.
 * (This can describe an index *or* a data column.)
 */
interface ColumnMetadata {
  /**
   * The fieldName of the column.
   * For a single-index column, this is just the name of the column (e.g. "foo").
   * For a multi-index column, this is a stringified tuple (e.g. "('1','foo')")
   */
  field_name: string

  /**
   * Column-specific metadata. Only used by certain column types
   * (e.g. CategoricalIndex has `num_categories`.)
   */
  metadata: Record<string, any> | null

  /** The name of the column. */
  name: string | null

  /**
   * The type of the column. When `pandas_type == "object"`, `numpy_type`
   * will have a more specific type.
   */
  pandas_type: string

  /**
   * When `pandas_type === "object"`, this field contains the object type.
   * If pandas_type has another value, numpy_type is ignored.
   */
  numpy_type: string
}

/**
 * The Pandas schema extracted from an Arrow table.
 * Arrow stores the schema as a JSON string, and we parse it into this typed object.
 * The Pandas schema is only present if the Arrow table was processed through Pandas.
 */
interface PandasSchema {
  /**
   * The DataFrame's index names (either provided by user or generated,
   * guaranteed unique). It is used to fetch the index data. Each DataFrame has
   * at least 1 index. There are many different index types; for most of them
   * the index name is stored as a string, but for the "range" index a `RangeIndex`
   * object is used. A `RangeIndex` is only ever by itself, never as part of a
   * multi-index. The length represents the dimensions of the DataFrame's index grid.
   *
   * Example:
   * Range index: [{ kind: "range", name: null, start: 1, step: 1, stop: 5 }]
   * Other index types: ["__index_level_0__", "foo", "bar"]
   */
  index_columns: (string | PandasRangeIndex)[]

  /**
   * Schemas for each column (index *and* data columns) in the DataFrame.
   */
  columns: ColumnMetadata[]

  /**
   * DataFrame column headers.
   * The length represents the dimensions of the DataFrame's columns grid.
   */
  column_indexes: ColumnMetadata[]
}

/** True if the index name represents a "range" index.
 *
 * This is only needed for parsing.
 */
function isPandasRangeIndex(
  indexName: string | PandasRangeIndex
): indexName is PandasRangeIndex {
  return typeof indexName === "object" && indexName.kind === "range"
}

/**
 * Parse the Pandas schema that is embedded in the Arrow table if the table was
 * processed through Pandas.
 */
function parsePandasSchema(table: Table): PandasSchema {
  const schema = table.schema.metadata.get("pandas")
  if (isNullOrUndefined(schema)) {
    // This should never happen!
    throw new Error("Table schema is missing.")
  }
  return JSON.parse(schema)
}

/** Get unprocessed column names for data columns. Needed for selecting
 * data columns when there are multi-columns. */
function getRawColumns(pandasSchema: PandasSchema): string[] {
  return (
    pandasSchema.columns
      .map(columnSchema => columnSchema.field_name)
      // Filter out all index columns
      .filter(columnName => !pandasSchema.index_columns.includes(columnName))
  )
}

/** Parse DataFrame's index data values. */
function parseIndexData(table: Table, pandasSchema: PandasSchema): IndexData {
  // TODO(lukasmasuch): Is range index the only case that is not from
  // the table data?
  return pandasSchema.index_columns
    .map(indexName => {
      // Generate a range using the "range" index metadata.
      if (isPandasRangeIndex(indexName)) {
        const { start, stop, step } = indexName
        return range(start, stop, step)
      }

      // Otherwise, use the index name to get the index column data.
      const column = table.getChild(indexName as string)
      if (column instanceof Vector && column.type instanceof Null) {
        return null
      }
      return column
    })
    .filter(
      (column: IndexValue | null): column is IndexValue => column !== null
    )
}

/** Parse DataFrame's index header names. */
function parseIndexNames(schema: PandasSchema): string[] {
  return schema.index_columns.map(indexName => {
    // Range indices are treated differently since they
    // contain additional metadata (e.g. start, stop, step).
    // and not just the name.
    if (isPandasRangeIndex(indexName)) {
      const { name } = indexName
      return name || ""
    }
    if (indexName.startsWith("__index_level_")) {
      // Unnamed indices can have a name like "__index_level_0__".
      return ""
    }
    return indexName
  })
}

/** Parse DataFrame's column header names. */
function parseColumnNames(pandasSchema: PandasSchema): ColumnNames {
  // If DataFrame `columns` has multi-level indexing, the length of
  // `column_indexes` will show how many levels there are.
  const isMultiIndex = pandasSchema.column_indexes.length > 1

  // Perform the following transformation:
  // ["('1','foo')", "('2','bar')", "('3','baz')"] -> ... -> [["1", "2", "3"], ["foo", "bar", "baz"]]
  return unzip(
    pandasSchema.columns
      .map(columnSchema => columnSchema.field_name)
      // Filter out all index columns
      .filter(fieldName => !pandasSchema.index_columns.includes(fieldName))
      .map(fieldName =>
        isMultiIndex
          ? JSON.parse(
              fieldName
                .replace(/\(/g, "[")
                .replace(/\)/g, "]")
                .replace(/'/g, '"')
            )
          : [fieldName]
      )
  )
}

/** Parse DataFrame's non-index data into a Table object. */
function parseData(
  table: Table,
  columnNames: ColumnNames,
  rawColumns: string[]
): Data {
  const numDataRows = table.numRows
  const numDataColumns = columnNames.length > 0 ? columnNames[0].length : 0
  if (numDataRows === 0 || numDataColumns === 0) {
    return table.select([])
  }

  return table.select(rawColumns)
}

/** Parse DataFrame's index and data types. */
function parseColumnTypes(
  table: Table,
  pandasSchema: PandasSchema
): PandasColumnTypes {
  const index = parseIndexType(pandasSchema)
  const data = parseDataType(pandasSchema)
  return { index, data }
}

/** Parse types for each non-index column. */
function parseDataType(pandasSchema: PandasSchema): PandasColumnType[] {
  return (
    pandasSchema.columns
      // Filter out all index columns
      .filter(
        columnSchema =>
          !pandasSchema.index_columns.includes(columnSchema.field_name)
      )
      .map(columnSchema => ({
        pandas_type: columnSchema.pandas_type,
        numpy_type: columnSchema.numpy_type,
        meta: columnSchema.metadata,
      }))
  )
}

/** Parse types for each index column. */
function parseIndexType(pandasSchema: PandasSchema): PandasColumnType[] {
  return pandasSchema.index_columns.map(indexName => {
    if (isPandasRangeIndex(indexName)) {
      return {
        pandas_type: PandasRangeIndexType,
        numpy_type: PandasRangeIndexType,
        meta: indexName as PandasRangeIndex,
      }
    }

    // Find the index column we're looking for in the schema.
    const indexColumn = pandasSchema.columns.find(
      column => column.field_name === indexName
    )

    // This should never happen!
    if (!indexColumn) {
      throw new Error(`${indexName} index not found.`)
    }

    return {
      pandas_type: indexColumn.pandas_type,
      numpy_type: indexColumn.numpy_type,
      meta: indexColumn.metadata,
    }
  })
}

/** Parse Arrow fields into a mapping from column name (field name) to Field metadata. */
function parseFields(arrowSchema: ArrowSchema): Record<string, Field> {
  // None-index data columns are listed first, and all index columns listed last
  // within the fields array in arrow.
  return Object.fromEntries(
    (arrowSchema.fields || []).map((field, index) => [
      field.name.startsWith("__index_level_") ? field.name : String(index),
      field,
    ])
  )
}

interface ParsedTable {
  columnNames: ColumnNames
  fields: Record<string, Field>
  indexData: IndexData
  indexNames: string[]
  data: Data
  columnTypes: PandasColumnTypes
}

/**
 * Parse Arrow bytes (IPC format).
 *
 * @param ipcBytes - Arrow bytes (IPC format)
 * @returns - Parsed Arrow table split into different
 *  components for easier access: columnNames, fields, indexData, indexNames, data, columnTypes.
 */
export function parseArrowIpcBytes(
  ipcBytes: Uint8Array | null | undefined
): ParsedTable {
  // Load arrow table object from IPC data
  const table = tableFromIPC(ipcBytes)
  // Load field information for all columns:
  const fields = parseFields(table.schema)

  // Load pandas schema from metadata (if it exists):
  const pandasSchema = parsePandasSchema(table)

  // Load all column names from table schema:
  const columnNames = parseColumnNames(pandasSchema)

  // Load the display names of the index columns:
  const indexNames = parseIndexNames(pandasSchema)

  // Extract unprocessed column names from pandas schema
  // (needed for parsing the data cells below):
  const rawColumns = getRawColumns(pandasSchema)

  // Load all non-index data cells:
  const data = parseData(table, columnNames, rawColumns)

  // Load all index data cells:
  const indexData = parseIndexData(table, pandasSchema)

  // Load types for index and data columns:
  const columnTypes = parseColumnTypes(table, pandasSchema)

  return {
    columnNames,
    fields,
    indexData,
    indexNames,
    data,
    columnTypes,
  }
}


================================================
File: /frontend/lib/src/dataframes/arrowTypeUtils.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { makeVector } from "apache-arrow"

import { Quiver } from "@streamlit/lib/src/dataframes/Quiver"
import {
  CATEGORICAL,
  DATE,
  DECIMAL,
  DICTIONARY,
  FLOAT64,
  INT64,
  INTERVAL_DATETIME64,
  INTERVAL_FLOAT64,
  INTERVAL_INT64,
  INTERVAL_UINT64,
  PERIOD,
  RANGE,
  TIMEDELTA,
  UINT64,
  UNICODE,
} from "@streamlit/lib/src/mocks/arrow"

import {
  convertVectorToList,
  getTimezone,
  getTypeName,
  isBooleanType,
  isBytesType,
  isCategoricalType,
  isDatetimeType,
  isDateType,
  isDecimalType,
  isDurationType,
  isEmptyType,
  isFloatType,
  isIntegerType,
  isIntervalType,
  isListType,
  isNumericType,
  isObjectType,
  isPeriodType,
  isRangeIndexType,
  isStringType,
  isTimeType,
  isUnsignedIntegerType,
  PandasColumnType,
} from "./arrowTypeUtils"

describe("getTypeName", () => {
  describe("uses numpy_type", () => {
    test("period", () => {
      const mockElement = { data: PERIOD }
      const q = new Quiver(mockElement)
      const dataType = q.columnTypes.data[0]

      expect(getTypeName(dataType)).toEqual("period[Y-DEC]")
    })

    test("decimal", () => {
      const mockElement = { data: DECIMAL }
      const q = new Quiver(mockElement)
      const firstColumnType = q.columnTypes.data[0]

      expect(getTypeName(firstColumnType)).toEqual("decimal")
    })

    test("timedelta", () => {
      const mockElement = { data: TIMEDELTA }
      const q = new Quiver(mockElement)
      const firstColumnType = q.columnTypes.data[0]

      expect(getTypeName(firstColumnType)).toEqual("timedelta64[ns]")
    })

    test("dictionary", () => {
      const mockElement = { data: DICTIONARY }
      const q = new Quiver(mockElement)
      const firstColumnType = q.columnTypes.data[0]

      expect(getTypeName(firstColumnType)).toEqual("object")
    })

    test("interval datetime64[ns]", () => {
      const mockElement = { data: INTERVAL_DATETIME64 }
      const q = new Quiver(mockElement)
      const indexType = q.columnTypes.index[0]

      expect(getTypeName(indexType)).toEqual("interval[datetime64[ns], right]")
    })

    test("interval float64", () => {
      const mockElement = { data: INTERVAL_FLOAT64 }
      const q = new Quiver(mockElement)
      const indexType = q.columnTypes.index[0]

      expect(getTypeName(indexType)).toEqual("interval[float64, right]")
    })

    test("interval int64", () => {
      const mockElement = { data: INTERVAL_INT64 }
      const q = new Quiver(mockElement)
      const indexType = q.columnTypes.index[0]

      expect(getTypeName(indexType)).toEqual("interval[int64, right]")
    })

    test("interval uint64", () => {
      const mockElement = { data: INTERVAL_UINT64 }
      const q = new Quiver(mockElement)
      const indexType = q.columnTypes.index[0]

      expect(getTypeName(indexType)).toEqual("interval[uint64, right]")
    })
  })

  describe("uses pandas_type", () => {
    test("categorical", () => {
      const mockElement = { data: CATEGORICAL }
      const q = new Quiver(mockElement)
      const indexType = q.columnTypes.index[0]

      expect(getTypeName(indexType)).toEqual("categorical")
    })

    test("date", () => {
      const mockElement = { data: DATE }
      const q = new Quiver(mockElement)
      const indexType = q.columnTypes.index[0]

      expect(getTypeName(indexType)).toEqual("datetime")
    })

    test("float64", () => {
      const mockElement = { data: FLOAT64 }
      const q = new Quiver(mockElement)
      const indexType = q.columnTypes.index[0]

      expect(getTypeName(indexType)).toEqual("float64")
    })

    test("int64", () => {
      const mockElement = { data: INT64 }
      const q = new Quiver(mockElement)
      const indexType = q.columnTypes.index[0]

      expect(getTypeName(indexType)).toEqual("int64")
    })

    test("range", () => {
      const mockElement = { data: RANGE }
      const q = new Quiver(mockElement)
      const indexType = q.columnTypes.index[0]

      expect(getTypeName(indexType)).toEqual("range")
    })
