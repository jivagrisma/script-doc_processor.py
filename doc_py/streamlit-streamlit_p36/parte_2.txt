
import numpy as np
import pandas as pd

import streamlit as st

# always generate the same data
np.random.seed(0)

st.image(np.repeat(0, 100).reshape(10, 10))
st.dataframe(
    pd.DataFrame(np.random.randint(0, 100, size=(100, 4)), columns=list("ABCD"))
)


================================================
File: /e2e_playwright/host_config_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, Route, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_loaded


def handle_route_hostconfig_disable_fullscreen(route: Route) -> None:
    response = route.fetch()
    body = response.json()
    body["disableFullscreenMode"] = True
    route.fulfill(
        # Pass all fields from the response.
        response=response,
        # Override response body.
        json=body,
    )


def test_disable_fullscreen(
    page: Page, app_port: int, assert_snapshot: ImageCompareFunction
):
    """Test that fullscreen mode is disabled for elements when set via host-config"""
    page.route("**/_stcore/host-config", handle_route_hostconfig_disable_fullscreen)
    page.goto(f"http://localhost:{app_port}")
    wait_for_app_loaded(page)

    # Test that the toolbar is not shown when hovering over a dataframe
    dataframe_element = page.get_by_test_id("stDataFrame").nth(0)
    dataframe_toolbar = dataframe_element.get_by_test_id("stElementToolbar")

    # Hover over dataframe
    dataframe_element.hover()

    expect(page.get_by_role("button", name="Fullscreen")).not_to_be_attached()

    # Check that it is visible (expect waits)
    expect(dataframe_toolbar).to_have_css("opacity", "1")
    # Take a snapshot
    assert_snapshot(
        dataframe_toolbar, name="host_config-dataframe_disabled_fullscreen_mode"
    )


================================================
File: /e2e_playwright/hostframe_app.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time

import streamlit as st


def page2():
    st.header("Page 2")


def page3():
    st.header("Page 3")


# the multi-pages are added to populate the sidebar. In the test, we are not actually
# use them.
st.navigation(
    [
        st.Page(page2, title="02_App_Page_2", default=True),
        st.Page(page3, title="03_App_Page_3"),
    ]
)

st.slider("Enter a number", 0, 20, 0)
st.checkbox("Check me out", value=True)
st.radio("Radio Widget", ["Option 1", "Option 2", "Option 3"])

with st.sidebar:
    st.write("Hello sidebar")

st.file_uploader("Upload a file")

# Allows for testing of script re-run / stop behavior
time.sleep(3)


================================================
File: /e2e_playwright/hostframe_app_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from pathlib import Path
from typing import Final

from playwright.sync_api import FrameLocator, Locator, Route, expect

from e2e_playwright.conftest import (
    IframedPage,
    IframedPageAttrs,
    ImageCompareFunction,
    wait_for_app_run,
    wait_until,
)
from e2e_playwright.shared.app_utils import (
    get_observed_connection_statuses,
    register_connection_status_observer,
)

TEST_ASSETS_DIR: Final[Path] = Path(__file__).parent / "test_assets"
HOSTFRAME_TEST_HTML: Final[str] = (TEST_ASSETS_DIR / "hostframe.html").read_text()


def _load_html_and_get_locators(
    iframed_app: IframedPage,
) -> tuple[FrameLocator, Locator]:
    page = iframed_app.page

    def fulfill_host_config_request(route: Route):
        response = route.fetch()
        result = response.json()
        result["allowedOrigins"] = ["http://localhost"]
        route.fulfill(json=result)

    page.route("**/_stcore/host-config", fulfill_host_config_request)

    frame_locator = iframed_app.open_app(
        IframedPageAttrs(html_content=HOSTFRAME_TEST_HTML)
    )

    # the toolbar and buttons are part of the HTML page, not the iframe
    toolbar = page.get_by_test_id("toolbar")
    expect(toolbar).to_have_count(1)
    toolbar_buttons = toolbar.get_by_role("button")
    expect(toolbar_buttons).to_have_count(13)
    wait_for_app_run(frame_locator)
    return frame_locator, toolbar_buttons


def test_handles_host_theme_message(
    iframed_app: IframedPage, assert_snapshot: ImageCompareFunction
):
    frame_locator, toolbar_buttons = _load_html_and_get_locators(iframed_app)
    assert_snapshot(
        frame_locator.get_by_test_id("stApp"), name="hostframe_app-theme_message_before"
    )
    toolbar_buttons.get_by_text("Send Theme").click()
    iframed_app.page.wait_for_timeout(5000)
    assert_snapshot(
        frame_locator.get_by_test_id("stApp"), name="hostframe_app-theme_message_after"
    )


def test_handles_set_file_upload_client_config_message(iframed_app: IframedPage):
    frame_locator, toolbar_buttons = _load_html_and_get_locators(iframed_app)

    file_name1 = "file1.txt"
    file_content1 = b"file1content"

    file_name2 = "file2.txt"
    file_content2 = b"file2content"

    files = [
        {"name": file_name1, "mimeType": "text/plain", "buffer": file_content1},
        {"name": file_name2, "mimeType": "text/plain", "buffer": file_content2},
    ]

    uploader_index = 0

    with iframed_app.page.expect_file_chooser() as fc_info:
        frame_locator.get_by_test_id("stFileUploaderDropzone").nth(
            uploader_index
        ).click()

    file_chooser = fc_info.value

    # First test without file upload config
    with iframed_app.page.expect_request(lambda request: request.method == "PUT") as r:
        file_chooser.set_files(files=files[0])

    url = r.value.url
    headers = r.value.all_headers()

    assert r.value.response().status == 204  # Upload successful
    assert url.startswith("http://localhost") and "_stcore/upload_file" in url
    assert "header1" not in headers

    wait_for_app_run(frame_locator, wait_delay=500)

    # Click the button to set the file upload config
    toolbar_buttons.get_by_text("Set file upload config").click()
    iframed_app.page.wait_for_timeout(5000)

    with iframed_app.page.expect_file_chooser() as fc_info:
        frame_locator.get_by_test_id("stFileUploaderDropzone").nth(
            uploader_index
        ).click()

    file_chooser = fc_info.value

    with iframed_app.page.expect_request(lambda request: request.method == "PUT") as r:
        file_chooser.set_files(files=files[1])

    url = r.value.url
    headers = r.value.all_headers()

    assert url.startswith("https://some-prefix.com/somethingelse/_stcore/upload_file/")
    assert "header1" in headers
    assert "header2" in headers

    assert headers["header1"] == "header1value"
    assert headers["header2"] == "header2value"


def test_handles_host_rerun_script_message(iframed_app: IframedPage):
    frame_locator, toolbar_buttons = _load_html_and_get_locators(iframed_app)
    toolbar_buttons.get_by_text("Rerun Script").click()
    expect(frame_locator.get_by_test_id("stApp")).to_have_attribute(
        "data-test-script-state", "running"
    )


def test_handles_host_stop_script_message(iframed_app: IframedPage):
    frame_locator, toolbar_buttons = _load_html_and_get_locators(iframed_app)
    # Make sure script is running
    toolbar_buttons.get_by_text("Rerun Script").click()
    # Check that status widget is running
    expect(frame_locator.get_by_test_id("stApp")).to_have_attribute(
        "data-test-script-state", "running"
    )
    toolbar_buttons.get_by_text("Stop Script").click()
    # Check that status widget is no longer running
    expect(frame_locator.get_by_test_id("stApp")).to_have_attribute(
        "data-test-script-state", "notRunning"
    )


def test_handles_host_close_modal_message(iframed_app: IframedPage):
    frame_locator, toolbar_buttons = _load_html_and_get_locators(iframed_app)

    # Open the Main Menu
    frame_locator.get_by_test_id("stMainMenu").locator("button").click()
    # Open the Settings Modal
    frame_locator.get_by_test_id("stMainMenuList").get_by_text("Settings").click()

    expect(frame_locator.get_by_role("dialog")).to_be_attached()
    # Close the Modal
    toolbar_buttons.get_by_text("Close Modal").click()
    expect(frame_locator.get_by_role("dialog")).not_to_be_attached()


def test_handles_host_menu_item_message(iframed_app: IframedPage):
    frame_locator, toolbar_buttons = _load_html_and_get_locators(iframed_app)
    toolbar_buttons.get_by_text("Add Menu Item").click()
    # Open the Main Menu
    frame_locator.get_by_test_id("stMainMenu").locator("button").click()
    menu_list = frame_locator.get_by_test_id("stMainMenuList")
    expect(menu_list.get_by_text("Adopt a Corgi")).to_be_attached()


def test_handles_host_toolbar_item_message(
    iframed_app: IframedPage, assert_snapshot: ImageCompareFunction
):
    frame_locator, toolbar_buttons = _load_html_and_get_locators(iframed_app)
    toolbar_buttons.get_by_text("Add Toolbar Item").click()

    toolbar_action_button = frame_locator.get_by_test_id("stToolbarActionButton")
    expect(toolbar_action_button).to_have_count(2)
    expect(toolbar_action_button.nth(0)).to_have_text("Favorite")
    expect(toolbar_action_button.nth(1)).to_have_text("Share")

    assert_snapshot(
        frame_locator.get_by_test_id("stApp"), name="hostframe_app-toolbar_items"
    )


def test_handles_hide_sidebar_nav_message(iframed_app: IframedPage):
    frame_locator, toolbar_buttons = _load_html_and_get_locators(iframed_app)
    expect(frame_locator.get_by_test_id("stSidebarNav")).to_be_attached()
    toolbar_buttons.get_by_text("Hide Sidebar Nav").click()
    expect(frame_locator.get_by_test_id("stSidebarNav")).not_to_be_attached()


def test_handles_sidebar_downshift_message(iframed_app: IframedPage):
    frame_locator, toolbar_buttons = _load_html_and_get_locators(iframed_app)
    # Trigger sidebar downshift
    toolbar_buttons.get_by_text("Sidebar Chevron Downshift").click()
    # Hover over sidebar to reveal the button
    frame_locator.get_by_test_id("stSidebarContent").hover()
    # Close the sidebar
    frame_locator.get_by_test_id("stSidebar").locator("button").click()
    # Check chevron positioning
    expect(frame_locator.get_by_test_id("stSidebarCollapsedControl")).to_have_css(
        "top", "50px"
    )


def test_handles_host_terminate_and_restart_websocket_connection_messages(
    iframed_app: IframedPage,
):
    frame_locator, toolbar_buttons = _load_html_and_get_locators(iframed_app)

    # Kill the websocket connection and verify that the app moves into an
    # error state.
    toolbar_buttons.get_by_text("Terminate Websocket").click()
    expect(frame_locator.get_by_test_id("stApp")).to_have_attribute(
        "data-test-connection-state", "DISCONNECTED_FOREVER"
    )
    frame = frame_locator.owner.page.frame("guest")
    assert frame is not None
    # start observing our connection statuses before we click on restart websocket
    register_connection_status_observer(frame)

    # Request that the websocket connection gets restarted.
    toolbar_buttons.get_by_text("Restart Websocket").click()
    wait_until(
        iframed_app.page,
        lambda: len(get_observed_connection_statuses(frame)) == 3,
        timeout=5000,
    )
    statuses = get_observed_connection_statuses(frame)
    assert statuses[0] == "PINGING_SERVER"
    assert statuses[1] == "CONNECTING"
    assert statuses[2] == "CONNECTED"

    # Check that the script state of the app indicates not running.
    expect(frame_locator.get_by_test_id("stApp")).to_have_attribute(
        "data-test-script-state", "notRunning"
    )


================================================
File: /e2e_playwright/i18n.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from datetime import date

import streamlit as st

st.date_input(
    "Single date",
    date(1970, 1, 1),
    min_value=date(1970, 1, 1),
)


================================================
File: /e2e_playwright/i18n_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
from playwright.sync_api import Page

from e2e_playwright.conftest import ImageCompareFunction

"""
Any tests that should be tested against multiple locales should be placed here.
Because `browser_context_args` is applied by Playwright on the file level, we
should keep only tests that should be run against multiple locales in this file.

See https://playwright.dev/python/docs/test-runners#fixtures for more
information.
"""


@pytest.fixture(scope="function", params=["en-US", "de-DE", "ja-JP", "ar-EG"])
def browser_context_args(request, browser_context_args):
    """
    Parameterized fixture that runs for every test function in this module.
    Tests against 4 different locales.
    """
    locale = request.param
    return {
        **browser_context_args,
        "locale": locale,
    }


def test_range_date_calendar_picker_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the range calendar picker renders correctly via screenshots matching."""
    themed_app.get_by_test_id("stDateInput").nth(0).click()
    assert_snapshot(
        themed_app.locator('[data-baseweb="calendar"]').first,
        name="st_date_input-range_two_dates_calendar",
    )


================================================
File: /e2e_playwright/iframe_resizer.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""
The test injects a resizer-script into an iframe. When the app is
interacted with and the markdown elements are added, the iframe is resized automatically
to wrap the content.
"""

import streamlit as st

x = st.slider("Enter a number", 0, 20, 0)

for _ in range(x):
    st.write("Hello example")


================================================
File: /e2e_playwright/iframe_resizer_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

from typing import TYPE_CHECKING, Callable, Final

from playwright.sync_api import FrameLocator, Locator, expect

from e2e_playwright.conftest import IframedPageAttrs
from e2e_playwright.shared.app_utils import wait_for_app_run

if TYPE_CHECKING:
    from e2e_playwright.conftest import IframedPage, ImageCompareFunction

from pathlib import Path

TEST_ASSETS_DIR: Final[Path] = Path(__file__).parent / "test_assets"

# we read the iframeResizer script from the assets file and inject the content within a
# <script>{content}</script> tag to the iframe. I wasn't able to load the script from a
# url in the playwright, which is why we do it inline (I also didn't spend a ton of time
# so it might easily be possible).
IFRAME_RESIZER_SCRIPT: Final[str] = (
    TEST_ASSETS_DIR / "iframerResizer.min.js"
).read_text()


def _open_with_resize_script(
    iframed_app: IframedPage, embed: bool = False, with_min_height: bool = False
) -> FrameLocator:
    """Open the iframe with the resize script and return the frame locator."""
    src_query_params = {}
    if embed:
        src_query_params["embed"] = "true"

    frame_locator: FrameLocator = iframed_app.open_app(
        IframedPageAttrs(
            element_id="exampleframe",
            src_query_params=src_query_params,
            additional_html_head=f"<script>{IFRAME_RESIZER_SCRIPT}</script>",
        )
    )
    wait_for_app_run(frame_locator)

    resize_args: dict[str, str | int] = {"log": "true"}
    if with_min_height:
        resize_args["minHeight"] = 500

    # call the iFrameResize function with the resize arguments
    # this will make the iframe resize itself to the content.
    # The function is exposed by the injected iframerResizer script.
    frame_locator.owner.evaluate(
        f"""
        () => {{
            iFrameResize({resize_args}, '#exampleframe')
        }}
        """,
    )
    return frame_locator


def _snapshot_iframe(
    iframe: FrameLocator,
    action: Callable[[Locator], None] | None,
    assert_snapshot: ImageCompareFunction,
    snapshot_name: str,
):
    slider = iframe.get_by_test_id("stSlider")
    expect(slider).to_have_count(1)
    expect(slider).to_be_visible()
    expect(iframe.get_by_test_id("stMarkdown")).to_have_count(0)

    if action:
        action(slider)

    assert_snapshot(iframe.get_by_test_id("stApp"), name=snapshot_name)


def _snapshot_expanded_iframe(
    iframe: FrameLocator,
    assert_snapshot: ImageCompareFunction,
    snapshot_name: str,
):
    def move_slider_and_expect_markdown(slider: Locator):
        """The app renders markdown elements basedf on the slider value."""
        slider.hover()
        # click in middle of the slider (which should then have the value 10)
        slider.click()
        wait_for_app_run(iframe)
        expect(iframe.get_by_test_id("stMarkdown")).to_have_count(10)

    _snapshot_iframe(
        iframe,
        move_slider_and_expect_markdown,
        assert_snapshot,
        snapshot_name,
    )


def test_render_embedded_iframe_correctly(
    iframed_app: IframedPage, assert_snapshot: ImageCompareFunction
):
    """Test that the iframe is rendered correctly when embedded
    (query param '?embed=true' added to the iframe src url)."""
    frame_locator = _open_with_resize_script(iframed_app, embed=True)
    _snapshot_iframe(
        frame_locator, None, assert_snapshot, "iframe_resizer-embedded_iframe"
    )


def test_render_embedded_iframe_expanded(
    iframed_app: IframedPage, assert_snapshot: ImageCompareFunction
):
    """Test that the iframe is rendered correctly when embedded
    (query param '?embed=true' added to the iframe src url) and
    markdown elements rendered."""
    frame_locator = _open_with_resize_script(iframed_app, embed=True)
    _snapshot_expanded_iframe(
        frame_locator, assert_snapshot, "iframe_resizer-embedded_iframe_expanded"
    )


def test_render_unembedded_iframe_correctly(
    iframed_app: IframedPage, assert_snapshot: ImageCompareFunction
):
    """Test that the iframe is rendered correctly when not embedded (no
    query param added to the iframe src url)."""
    frame_locator = _open_with_resize_script(iframed_app)
    _snapshot_iframe(
        frame_locator, None, assert_snapshot, "iframe_resizer-unembedded_iframe"
    )


def test_render_unembedded_iframe_expanded(
    iframed_app: IframedPage, assert_snapshot: ImageCompareFunction
):
    """Test that the iframe is rendered correctly when not embedded (no
    query param added to the iframe src url) and markdown elements rendered."""
    frame_locator = _open_with_resize_script(iframed_app)
    _snapshot_expanded_iframe(
        frame_locator,
        assert_snapshot,
        "iframe_resizer-unembedded_iframe_expanded",
    )


def test_render_unembedded_iframe_with_minheight(
    iframed_app: IframedPage, assert_snapshot: ImageCompareFunction
):
    """Test that the iframe has a minimum height even if there are no markdown
    elements. This means that this screenshot should have a larger height than
    the non-expanded, unembedded iframe screenshot without a min-height."""

    frame_locator = _open_with_resize_script(iframed_app, with_min_height=True)
    _snapshot_iframe(
        frame_locator,
        None,
        assert_snapshot,
        "iframe_resizer-unembedded_iframe_with_min_height",
    )


def test_render_unembedded_iframe_with_minheight_expanded(
    iframed_app: IframedPage, assert_snapshot: ImageCompareFunction
):
    """Test that the iframe has a minimum height and expands correctly."""
    frame_locator = _open_with_resize_script(iframed_app, with_min_height=True)
    _snapshot_expanded_iframe(
        frame_locator,
        assert_snapshot,
        "iframe_resizer-unembedded_iframe_with_min_height_expanded",
    )


================================================
File: /e2e_playwright/label_markdown.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime

import numpy as np

import streamlit as st

valid_label = ":material/check_circle: :streamlit: ![Image Text](app/static/cat.jpg) **Bold Text** *Italicized* ~Strikethough~ `Code Block` 🐶 :joy: <- -> <-> -- >= <= ~="

color_label = (
    "Colored Text - :red[red] :blue[blue] :green[green] :violet[violet] :orange[orange]"
)

link_label = "Label Link - [Streamlit](https://streamlit.io)"

table = """
| Syntax | Description |
| ----------- | ----------- |
| Header | Title |
| Paragraph | Text |
"""

heading_1 = "# Heading 1"
heading_2 = "## Heading 2"

ordered_list = """
 1. First Item
 2. Second Item
"""
unordered_list = """
 - Item 1
 - Item 2
"""

task_list = """
- [x] Write the press release
- [ ] Update the website
- [ ] Contact the media
"""

blockquote = "> Testing Blockquote"

horizontal_rule = """
Horizontal Rule:

---

"""

img = np.repeat(0, 10000).reshape(100, 100)

# Invalid Markdown: table elements, headings, unordered/ordered lists, task lists, horizontal rules, & blockquotes
with st.container():
    st.subheader(
        "❌ Entirely Disallowed - Table Elements, Headings, Lists, Blockquotes, Horizontal Rules"
    )
    st.checkbox(table)
    st.radio(heading_1, ["Option 1", "Option 2", "Option 3"])
    st.selectbox(heading_2, ["Option 1", "Option 2", "Option 3"])
    st.multiselect(ordered_list, ["Blue", "Purple", "Green"])
    st.slider(unordered_list, 0, 10, 1)
    st.select_slider(task_list, ["Blue", "Purple", "Green"])
    st.text_input(blockquote)
    st.number_input(horizontal_rule)
    st.date_input(table, datetime.date(2000, 3, 7))
    st.time_input(heading_1, datetime.time(8, 45))
    st.file_uploader(heading_2)
    st.color_picker(ordered_list)
    st.metric(unordered_list, value=7, delta=0.5)
    with st.expander(task_list):
        st.write("Expanded!")
    tabA, tabB = st.tabs([blockquote, horizontal_rule])
    st.image(img, caption=table)


# Bold, italics, strikethrough, code, & shortcodes/emojis/streamlit logo, images - allowed in all
with st.container():
    st.subheader(
        "✅ Entirely Allowed - Bold, Italics, Strikethrough, Code, Shortcodes/Emojis, Streamlit logo, Images"
    )
    st.button(valid_label)
    st.checkbox(valid_label)
    st.radio(valid_label, ["Option 1", "Option 2", "Option 3"])
    st.selectbox(valid_label, ["Option 1", "Option 2", "Option 3"])
    st.multiselect(valid_label, ["Blue", "Purple", "Green"])
    st.slider(valid_label, 0, 10, 1)
    st.select_slider(valid_label, ["Blue", "Purple", "Green"])
    st.text_input(valid_label)
    st.number_input(valid_label)
    st.text_area(valid_label)
    st.date_input(valid_label, datetime.date(2000, 3, 7))
    st.time_input(valid_label, datetime.time(8, 45))
    st.file_uploader(valid_label)
    st.color_picker(valid_label)
    st.metric(valid_label, value=7, delta=0.5)
    with st.expander(valid_label):
        st.write("Expanded!")
    st.tabs(
        [
            "**Bold Text**",
            "*Italicized*",
            "~Strikethough~",
            "`Code Block`",
            "🐶",
            ":joy:",
            ":material/check_circle: Icon",
        ]
    )
    st.image(img, caption=valid_label)

# Colored text - allowed in all
with st.container():
    st.subheader("✅ Entirely Allowed - Colored text")
    st.button(color_label)
    st.checkbox(color_label)
    st.radio(color_label, ["Option 1", "Option 2", "Option 3"])
    st.selectbox(color_label, ["Option 1", "Option 2", "Option 3"])
    st.multiselect(color_label, ["Blue", "Purple", "Green"])
    st.slider(color_label, 0, 10, 1)
    st.select_slider(color_label, ["Blue", "Purple", "Green"])
    st.text_input(color_label)
    st.number_input(color_label)
    st.text_area(color_label)
    st.date_input(color_label, datetime.date(2000, 3, 7))
    st.time_input(color_label, datetime.time(8, 45))
    st.file_uploader(color_label)
    st.color_picker(color_label)
    st.metric(color_label, value=7, delta=0.5)
    with st.expander(color_label):
        st.write("Expanded!")
    st.tabs(
        [
            "Colored Text:",
            ":red[red]",
            ":blue[blue]",
            ":green[green]",
            ":violet[violet]",
            ":orange[orange]",
        ]
    )
    st.image(img, caption=color_label)

# Links - only restricted in buttons
with st.container():
    st.subheader("❌ Disallowed in Buttons - Links")
    st.button(link_label)
with st.container():
    st.subheader("✅ Allowed outside of buttons - Links")
    st.checkbox(link_label)
    st.radio(
        link_label,
        ["Option 1 - [Streamlit](https://streamlit.io)", "Option 2", "Option 3"],
    )
    st.selectbox(link_label, ["Option 1", "Option 2", "Option 3"])
    st.multiselect(link_label, ["Blue", "Purple", "Green"])
    st.slider(link_label, 0, 10, 1)
    st.select_slider(link_label, ["Blue", "Purple", "Green"])
    st.text_input(link_label)
    st.number_input(link_label)
    st.text_area(link_label)
    st.date_input(link_label, datetime.date(2000, 3, 7))
    st.time_input(link_label, datetime.time(8, 45))
    st.file_uploader(link_label)
    st.color_picker(link_label)
    st.metric(link_label, value=7, delta=0.5)
    with st.expander(link_label):
        st.write("Expanded!")
    st.tabs([link_label])
    st.image(img, caption=link_label)

st.selectbox("", [])  # No label


================================================
File: /e2e_playwright/label_markdown_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_button_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["valid", "markdown"],
        ["valid", "colored"],
        ["invalid", "link"],
    ]

    buttons = app.get_by_test_id("stButton")
    expect(buttons).to_have_count(3)
    for index, case in enumerate(cases):
        assert_snapshot(
            buttons.nth(index),
            name=f"st_button-{case[0]}_{case[1]}",
        )


def test_checkbox_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "table"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    checkboxes = app.get_by_test_id("stCheckbox")
    expect(checkboxes).to_have_count(4)
    for index, case in enumerate(cases):
        assert_snapshot(
            checkboxes.nth(index).get_by_test_id("stWidgetLabel"),
            name=f"st_checkbox-{case[0]}_{case[1]}",
        )


def test_radio_labels_handle_markdown(app: Page, assert_snapshot: ImageCompareFunction):
    cases = [
        ["invalid", "heading1"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    radios = app.get_by_test_id("stRadio")
    expect(radios).to_have_count(4)
    for index, case in enumerate(cases):
        assert_snapshot(
            radios.nth(index).get_by_test_id("stWidgetLabel"),
            name=f"st_radio-{case[0]}_{case[1]}",
        )


def test_radio_option_supports_links(app: Page, assert_snapshot: ImageCompareFunction):
    radio_option = app.get_by_test_id("stRadio").nth(3).locator("p").nth(0)
    assert_snapshot(
        radio_option,
        name="st_radio-supports_links_in_options",
    )


def test_selectbox_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "heading2"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    selectboxes = app.get_by_test_id("stSelectbox")
    expect(selectboxes).to_have_count(5)
    for index, case in enumerate(cases):
        assert_snapshot(
            selectboxes.nth(index).get_by_test_id("stWidgetLabel"),
            name=f"st_selectbox-{case[0]}_{case[1]}",
        )


def test_multiselect_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "ordered-list"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    multiselects = app.get_by_test_id("stMultiSelect")
    expect(multiselects).to_have_count(4)
    for index, case in enumerate(cases):
        assert_snapshot(
            multiselects.nth(index).get_by_test_id("stWidgetLabel"),
            name=f"st_multiselect-{case[0]}_{case[1]}",
        )


def test_slider_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "unordered-list"],
        ["invalid", "task_list"],
        ["valid", "markdown"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "colored"],
        ["valid", "link"],
        ["valid", "link"],
    ]

    sliders = app.get_by_test_id("stSlider")
    expect(sliders).to_have_count(8)
    for index, case in enumerate(cases):
        even = index % 2 == 0
        if even:
            assert_snapshot(
                sliders.nth(index).get_by_test_id("stWidgetLabel"),
                name=f"st_slider-{case[0]}_{case[1]}",
            )
        else:
            assert_snapshot(
                sliders.nth(index), name=f"st_select_slider-{case[0]}_{case[1]}"
            )


def test_text_input_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "blockquote"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    text_inputs = app.get_by_test_id("stTextInput")
    expect(text_inputs).to_have_count(4)

    for index, case in enumerate(cases):
        assert_snapshot(
            text_inputs.nth(index).get_by_test_id("stWidgetLabel"),
            name=f"st_text_input-{case[0]}_{case[1]}",
        )


def test_number_input_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "horizontal-rule"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    number_inputs = app.get_by_test_id("stNumberInput")
    expect(number_inputs).to_have_count(4)

    for index, case in enumerate(cases):
        assert_snapshot(
            number_inputs.nth(index).get_by_test_id("stWidgetLabel"),
            name=f"st_number_input-{case[0]}_{case[1]}",
        )


def test_text_area_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    text_areas = app.get_by_test_id("stTextArea")
    expect(text_areas).to_have_count(3)

    for index, case in enumerate(cases):
        assert_snapshot(
            text_areas.nth(index).get_by_test_id("stWidgetLabel"),
            name=f"st_text_area-{case[0]}_{case[1]}",
        )


def test_date_input_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "table"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    date_inputs = app.get_by_test_id("stDateInput")
    expect(date_inputs).to_have_count(4)

    for index, case in enumerate(cases):
        assert_snapshot(
            date_inputs.nth(index).get_by_test_id("stWidgetLabel"),
            name=f"st_date_input-{case[0]}_{case[1]}",
        )


def test_time_input_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "heading1"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    time_inputs = app.get_by_test_id("stTimeInput")
    expect(time_inputs).to_have_count(4)

    for index, case in enumerate(cases):
        assert_snapshot(
            time_inputs.nth(index).get_by_test_id("stWidgetLabel"),
            name=f"st_time_input-{case[0]}_{case[1]}",
        )


def test_file_uploader_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "heading2"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    file_uploaders = app.get_by_test_id("stFileUploader")
    expect(file_uploaders).to_have_count(4)

    for index, case in enumerate(cases):
        assert_snapshot(
            file_uploaders.nth(index).get_by_test_id("stWidgetLabel"),
            name=f"st_file_uploader-{case[0]}_{case[1]}",
        )


def test_color_picker_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "ordered-list"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    color_pickers = app.get_by_test_id("stColorPicker")
    expect(color_pickers).to_have_count(4)

    for index, case in enumerate(cases):
        assert_snapshot(
            color_pickers.nth(index).get_by_test_id("stWidgetLabel"),
            name=f"st_color_picker-{case[0]}_{case[1]}",
        )


def test_metric_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "unordered-list"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    metrics = app.get_by_test_id("stMetric")
    expect(metrics).to_have_count(4)

    for index, case in enumerate(cases):
        assert_snapshot(
            metrics.nth(index).get_by_test_id("stMetricLabel"),
            name=f"st_metric-{case[0]}_{case[1]}",
        )


def test_expander_labels_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "task-list"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    expanders = app.get_by_test_id("stExpander")
    expect(expanders).to_have_count(4)

    for index, case in enumerate(cases):
        assert_snapshot(
            expanders.nth(index),
            name=f"st_expander-{case[0]}_{case[1]}",
        )


def test_tabs_labels_handle_markdown(app: Page, assert_snapshot: ImageCompareFunction):
    cases = [
        ["invalid", "blockquote-and-hr"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    tabs = app.get_by_test_id("stTabs")
    expect(tabs).to_have_count(4)

    for index, case in enumerate(cases):
        assert_snapshot(
            tabs.nth(index),
            name=f"st_tab-{case[0]}_{case[1]}",
        )


def test_image_captions_handle_markdown(
    app: Page, assert_snapshot: ImageCompareFunction
):
    cases = [
        ["invalid", "table"],
        ["valid", "markdown"],
        ["valid", "colored"],
        ["valid", "link"],
    ]

    images = app.get_by_test_id("stImage")
    expect(images).to_have_count(4)

    for index, case in enumerate(cases):
        assert_snapshot(
            images.nth(index),
            name=f"st_image-{case[0]}_{case[1]}",
        )


def test_empty_labels(app: Page, assert_snapshot: ImageCompareFunction):
    empty_label_selectbox = app.get_by_test_id("stSelectbox").last
    expect(empty_label_selectbox).to_have_text("No options to select.open")
    assert_snapshot(empty_label_selectbox, name="st_selectbox-empty_label")


================================================
File: /e2e_playwright/lazy_loaded_modules.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import importlib.util
import sys

import streamlit as st

lazy_loaded_modules = [
    "altair",
    "bokeh",
    "graphviz",
    "matplotlib",
    "numpy",
    # There is currently a 10% probability that we check for new
    # versions on streamlit start-up. This is using the packaging module.
    # So, we cannot check this without it being flaky.
    # "packaging",
    "pandas",
    # Pillow is lazy-loaded, but it gets imported by plotly,
    # which we have to import in case it is installed to correctly
    # configure the Streamlit theme. So, we cannot test this here.
    # "PIL",
    "pyarrow",
    "pydeck",
    "rich",
    "tenacity",
    # toml is automatically loaded if there is a secret.toml, config.toml or
    # a local credentials.toml file. So, we cannot test this here.
    "unittest",
    # Internal modules:
    "streamlit.emojis",
    "streamlit.external",
    "streamlit.material_icon_names",
    "streamlit.proto.openmetrics_data_model_pb2",
    "streamlit.vendor.pympler",
    # Requires `server.fileWatcherType` to be configured with `none` or `poll`:
    "watchdog",
    "streamlit.watcher.event_based_path_watcher",
]


for module in lazy_loaded_modules:
    if module in sys.modules:
        label = "imported"
    elif importlib.util.find_spec(module) is not None:
        label = "not loaded"
    else:
        label = "not found"

    st.write(
        f"**{module}**:",
        label,
    )


if st.button("Import lazy loaded modules"):
    for module in lazy_loaded_modules:
        __import__(module)
    st.rerun()


================================================
File: /e2e_playwright/lazy_loaded_modules_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from playwright.sync_api import Page, expect


def test_lazy_loaded_modules_are_not_imported(app: Page):
    """Test that lazy loaded modules are not imported when the page is loaded."""
    markdown_elements = app.get_by_test_id("stMarkdown")
    expect(markdown_elements).to_have_count(18)
    for element in markdown_elements.all():
        expect(element).to_have_text(re.compile(r".*not loaded.*"))


================================================
File: /e2e_playwright/main_menu.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit.commands.page_config import MenuItems

menu_items: MenuItems = {"about": "_*This can be markdown!*_"}
st.set_page_config(menu_items=menu_items)


================================================
File: /e2e_playwright/main_menu_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_main_menu_images(themed_app: Page, assert_snapshot: ImageCompareFunction):
    themed_app.get_by_test_id("stMainMenu").click()

    element = themed_app.get_by_test_id("stMainMenuPopover")
    assert_snapshot(element, name="main_menu")


def test_renders_settings_dialog_properly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    themed_app.get_by_test_id("stMainMenu").click()

    themed_app.get_by_text("Settings").click()
    dialog = themed_app.get_by_test_id("stDialog")
    expect(dialog).to_be_visible()

    assert_snapshot(dialog.get_by_role("dialog"), name="settings_dialog")


# Webkit (safari) and firefox doesn't support screencast on linux machines
@pytest.mark.only_browser("chromium")
def test_renders_screencast_dialog_properly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    themed_app.get_by_test_id("stMainMenu").click()

    themed_app.get_by_text("Record a screencast").click()
    dialog = themed_app.get_by_test_id("stDialog")
    expect(dialog).to_be_visible()
    assert_snapshot(dialog.get_by_role("dialog"), name="record_screencast_dialog")


# Webkit (safari) and firefox doesn't support screencast on linux machines
@pytest.mark.only_browser("chromium")
def test_renders_screencast_recorded_dialog_properly(themed_app: Page):
    themed_app.get_by_test_id("stMainMenu").click()

    themed_app.get_by_text("Record a screencast").click()
    themed_app.get_by_text("Start recording!").click()

    # Wait 5 seconds because there is a 3! 2! 1! on the screen until recording occurs and there may be buffer
    themed_app.wait_for_timeout(5000)

    # stop recording
    themed_app.keyboard.press("Escape")
    dialog = themed_app.get_by_test_id("stDialog")
    expect(dialog).to_be_visible()

    # don't use screenshot as the recording may differ so just check for specific text
    expect(
        themed_app.get_by_role("dialog").get_by_text("Preview your video below:")
    ).to_be_visible()


def test_renders_about_dialog_properly(themed_app: Page):
    themed_app.get_by_test_id("stMainMenu").click()

    themed_app.get_by_text("About").click()
    dialog = themed_app.get_by_test_id("stDialog")
    expect(dialog).to_be_visible()
    expect(dialog).to_contain_text("Made with Streamlit v")


def test_renders_clear_cache_dialog_properly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    themed_app.get_by_test_id("stMainMenu").click()

    themed_app.get_by_text("Clear cache").click()
    dialog = themed_app.get_by_test_id("stDialog")
    expect(dialog).to_be_visible()
    expect(dialog).to_contain_text(
        "Are you sure you want to clear the app's function caches?"
    )
    assert_snapshot(dialog.get_by_role("dialog"), name="clear_cache_dialog")


def test_renders_active_theme_dialog_properly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    themed_app.get_by_test_id("stMainMenu").click()
    themed_app.get_by_text("Settings").click()
    themed_app.get_by_text("Edit active theme").click()

    dialog = themed_app.get_by_test_id("stDialog")
    expect(dialog).to_be_visible()
    assert_snapshot(dialog.get_by_role("dialog"), name="edit_active_theme_dialog")


================================================
File: /e2e_playwright/pytest.ini
================================================
[pytest]
markers =
    early: prioritize the execution of a fixture
    performance: performance tests
filterwarnings =
    # PyTest filter syntax cheatsheet -> action:message:category:module:line
    ignore::UserWarning:altair.*:
    ignore::DeprecationWarning:flatbuffers.*:
    ignore::DeprecationWarning:keras_preprocessing.*:


================================================
File: /e2e_playwright/st_add_rows.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time

import altair as alt
import numpy as np
import pandas as pd

import streamlit as st

df = pd.DataFrame({"a": [1, 2], "b": [3, 4], "c": [5, 6]})

table_element = st.table(df)
dataframe_element = st.dataframe(df)
chart_element_1 = st.line_chart()
chart_element_2 = st.line_chart(df)

# 4 identical charts, built in different ways.
vega_element_1 = st.vega_lite_chart(
    df,
    {
        "mark": {"type": "line", "point": True},
        "encoding": {
            "x": {"field": "a", "type": "quantitative"},
            "y": {"field": "b", "type": "quantitative"},
        },
    },
    use_container_width=True,
)
vega_element_2 = st.vega_lite_chart(
    {
        "datasets": {"foo": df},
        "data": {"name": "foo"},
        "mark": {"type": "line", "point": True},
        "encoding": {
            "x": {"field": "a", "type": "quantitative"},
            "y": {"field": "b", "type": "quantitative"},
        },
    },
    use_container_width=True,
)
vega_element_3 = st.vega_lite_chart(
    {
        "datasets": {"foo": df},
        "data": {"name": "foo"},
        "mark": {"type": "line", "point": True},
        "encoding": {
            "x": {"field": "a", "type": "quantitative"},
            "y": {"field": "b", "type": "quantitative"},
        },
    },
    use_container_width=True,
)
altair_element = st.altair_chart(
    alt.Chart(df).mark_line(point=True).encode(x="a", y="b").interactive(),
    use_container_width=True,
)

table_element.add_rows(df)
dataframe_element.add_rows(df)
chart_element_1.add_rows(df)
chart_element_2.add_rows(df)
vega_element_1.add_rows(df)
vega_element_2.add_rows(df)
vega_element_3.add_rows(foo=df)
altair_element.add_rows(df)

# The following example was failing due to an issue (#3653) in st.add_rows.
# In the previous implementation of Quiver, we were mutating the Quiver element
# in the addRows function, which prevented re-rendering of the line chart.
# This example reproduces the issue, so that we don't repeat the same mistake
# in the future.

current_time = pd.to_datetime("08:00:00 2021-01-01", utc=True)
simulation_step = pd.Timedelta(seconds=10)

df1 = pd.DataFrame(data=[[current_time, 1]], columns=["t", "y"]).set_index("t")
line_chart = st.line_chart(df1, use_container_width=True)

for count in range(5):
    current_time += simulation_step
    df2 = pd.DataFrame(data=[[current_time, count]], columns=["t", "y"]).set_index("t")
    line_chart.add_rows(df2)
    time.sleep(0.25)

# Test that `add_rows` errors out when the dataframe dimensions don't match.
# This should show an error!
dataframe_element = st.dataframe(df)
dataframe_element.add_rows(np.abs(np.random.randn(1, 6)))


================================================
File: /e2e_playwright/st_add_rows_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_that_no_new_elements_are_created(themed_app: Page):
    expect(themed_app.get_by_test_id("stTable")).to_have_count(1)
    expect(themed_app.get_by_test_id("stDataFrame")).to_have_count(1)
    expect(themed_app.get_by_test_id("stVegaLiteChart")).to_have_count(7)


def test_correctly_adds_rows_to_table(themed_app: Page):
    expect(themed_app.get_by_test_id("stTable").locator("tbody tr")).to_have_count(4)


def test_correctly_adds_rows_to_charts(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    charts = themed_app.get_by_test_id("stVegaLiteChart")
    for index in range(charts.count()):
        assert_snapshot(
            charts.nth(index), name=f"st_vega_lite_chart-added_rows-{index}"
        )


def test_correctly_adds_rows_to_dataframe(
    app: Page, assert_snapshot: ImageCompareFunction
):
    dataframe = app.get_by_test_id("stDataFrame")
    assert_snapshot(dataframe, name="st_dataframe-added_rows")


def test_raises_an_exception_when_shapes_dont_match(themed_app: Page):
    expect(themed_app.get_by_test_id("stAlert")).to_be_visible()


================================================
File: /e2e_playwright/st_alert.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.error("This is an error")
st.warning("This is a warning")
st.info("This is an info message")
st.success("This is a success message")

# This is here so we can test the distance between alert messages and
# elements above/below them.
st.write("Some non-alert text!")

st.error("This is an error", icon="🚨")
st.warning("This is a warning", icon="⚠️")
st.info("This is an info message", icon="👉🏻")
st.success("This is a success message", icon="✅")

# Verify that line-wrapping works as expected both with and without break words.
st.error("A" + 100 * "H")
st.error("If I repeat myself enough the line should " + 20 * "wrap ")

text = """
    This is an example error from caching.py

    This error can occur when your virtual environment lives in the same
    folder as your project, since that makes it hard for Streamlit to
    understand which files it should check. If you think that's what caused
    this, please add the following to `~/.streamlit/config.toml`:

    ```toml
    [server]
    folderWatchBlacklist = ['foldername']
    ```

    ...where `foldername` is the relative or absolute path to the folder
    where you put your virtual environment.

    Otherwise, please [file a bug
    here](https://github.com/streamlit/streamlit/issues/new/choose).

    To stop this warning from showing in the meantime, try one of the
    following:

    * **Preferred:** modify your code to avoid using this type of object.
    * Or add the argument `allow_output_mutation=True` to the `st.cache` decorator.
    """

st.error(text)
st.warning(text)
st.info(text)
st.success(text)

# Check resolution of issue #6394
text = """
Here is some code:

```
import streamlit as st
st.write("Hello world!")
# this is a very long comment just to demonstrate the overflowing behavior it goes on and on and on
```
"""

st.error(text, icon="🚨")
st.success(text)

st.error("This is an error with non emoji icon", icon=":material/running_with_errors:")

st.warning("This is a warning with non emoji icon", icon=":material/warning:")
st.info("This is an info message with non emoji icon", icon=":material/info:")
st.success(
    "This is a success message with non emoji icon",
    icon=":material/celebration:",
)

st.error("""
## Big error

This is a big error message.

""")

st.success(
    "Success message to test material icon from latest material symbols font",
    icon=":material/graph_2:",
)


================================================
File: /e2e_playwright/st_alert_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class


def test_alerts_rendering(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that alerts render correctly using snapshot testing."""
    alert_elements = themed_app.get_by_test_id("stAlert")
    expect(alert_elements).to_have_count(22)

    # The first 4 alerts are super basic, no need to screenshot test those
    expect(alert_elements.nth(0)).to_have_text("This is an error")
    expect(alert_elements.nth(1)).to_have_text("This is a warning")
    expect(alert_elements.nth(2)).to_have_text("This is an info message")
    expect(alert_elements.nth(3)).to_have_text("This is a success message")

    assert_snapshot(alert_elements.nth(4), name="st_alert-error_icon")
    assert_snapshot(alert_elements.nth(5), name="st_alert-warning_icon")
    assert_snapshot(alert_elements.nth(6), name="st_alert-info_icon")
    assert_snapshot(alert_elements.nth(7), name="st_alert-success_icon")

    assert_snapshot(alert_elements.nth(8), name="st_alert-error_line_wrapping_1")
    assert_snapshot(alert_elements.nth(9), name="st_alert-error_line_wrapping_2")

    assert_snapshot(alert_elements.nth(10), name="st_alert-error_markdown")
    assert_snapshot(alert_elements.nth(11), name="st_alert-warning_markdown")
    assert_snapshot(alert_elements.nth(12), name="st_alert-info_markdown")
    assert_snapshot(alert_elements.nth(13), name="st_alert-success_markdown")

    assert_snapshot(alert_elements.nth(14), name="st_alert-error_long_code")
    assert_snapshot(alert_elements.nth(15), name="st_alert-success_long_code")

    assert_snapshot(alert_elements.nth(16), name="st_alert-error_non_emoji_icon")
    assert_snapshot(alert_elements.nth(17), name="st_alert-warning_non_emoji_icon")
    assert_snapshot(alert_elements.nth(18), name="st_alert-info_non_emoji_icon")
    assert_snapshot(alert_elements.nth(19), name="st_alert-success_non_emoji_icon")

    assert_snapshot(alert_elements.nth(20), name="st_alert-error_with_heading")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stAlert")


def test_material_symbol_from_latest_font_version_rendering(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that icon from latest version material symbols font renders correctly."""
    alert_elements = app.get_by_test_id("stAlert")
    expect(alert_elements).to_have_count(22)

    assert_snapshot(alert_elements.nth(21), name="st_alert-latest_material_symbol")


================================================
File: /e2e_playwright/st_altair_chart.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import altair as alt
import numpy as np
import pandas as pd

import streamlit as st

np.random.seed(0)

data = np.random.randn(200, 3)
df = pd.DataFrame(data, columns=["a", "b", "c"])
chart = alt.Chart(df).mark_circle().encode(x="a", y="b", size="c", color="c")

st.write("Show default vega lite theme:")
st.altair_chart(chart, theme=None)

st.write("Show streamlit theme:")
st.altair_chart(chart, theme="streamlit")

st.write("Overwrite theme config:")
chart = (
    alt.Chart(df, usermeta={"embedOptions": {"theme": None}})
    .mark_circle()
    .encode(x="a", y="b", size="c", color="c")
)
st.altair_chart(chart, theme="streamlit")

data = pd.DataFrame(
    {
        "a": ["A", "B", "C", "D", "E", "F", "G", "H", "I"],
        "b": [28, 55, 43, 91, 81, 53, 19, 87, 52],
    }
)

chart = alt.Chart(data).mark_bar().encode(x="a", y="b")

st.write("Bar chart with overwritten theme props:")
st.altair_chart(chart.configure_mark(color="black"), theme="streamlit")

# mark_arc was added in 4.2, but we have to support altair 4.0-4.1, so we
# have to skip this part of the test when testing min versions.
major, minor, patch = alt.__version__.split(".")
if not (major == "4" and minor < "2"):
    source = pd.DataFrame(
        {"category": [1, 2, 3, 4, 5, 6], "value": [4, 6, 10, 3, 7, 8]}
    )

    chart = (
        alt.Chart(source)
        .mark_arc(innerRadius=50)
        .encode(
            theta=alt.Theta(field="value", type="quantitative"),
            color=alt.Color(field="category", type="nominal"),
        )
    )

    st.write("Pie Chart with more than 4 Legend items")
    st.altair_chart(chart, theme="streamlit", use_container_width=False)

# taken from vega_datasets barley example
barley = alt.UrlData(
    "https://cdn.jsdelivr.net/npm/vega-datasets@v2.7.0/data/barley.json"
)

barley_chart = (
    alt.Chart(barley)
    .mark_bar()
    .encode(x="year:O", y="sum(yield):Q", color="year:N", column="site:N")
)

st.write("Grouped Bar Chart with default theme:")
st.altair_chart(barley_chart, theme=None)

st.write("Grouped Bar Chart with streamlit theme:")
st.altair_chart(barley_chart, theme="streamlit")

st.write(
    "Grouped Bar Chart with use_container_width=True (note that this doesn't work well)"
)
st.altair_chart(barley_chart, theme=None, use_container_width=True)

st.write("Layered chart")
# Taken from vega_datasets
stocks = alt.UrlData(
    "https://cdn.jsdelivr.net/npm/vega-datasets@v1.29.0/data/stocks.csv"
)

base = (
    alt.Chart(stocks)
    .encode(x="date:T", y="price:Q", color="symbol:N")
    .transform_filter(alt.datum.symbol == "GOOG")
)

new_base_chart = base.mark_line() + base.mark_point()
st.altair_chart(new_base_chart)

x = np.linspace(10, 100, 10)
y1 = 5 * x
y2 = 1 / x

df1 = pd.DataFrame.from_dict({"x": x, "y1": y1, "y2": y2})

c1 = alt.Chart(df1).mark_line().encode(alt.X("x"), alt.Y("y1"))

c2 = alt.Chart(df1).mark_line().encode(alt.X("x"), alt.Y("y2"))

st.altair_chart(c1 & c2, use_container_width=True)


================================================
File: /e2e_playwright/st_altair_chart_basic_select.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import time

import altair as alt
import pandas as pd
from vega_datasets import data

import streamlit as st

# SCATTER CHART
st.header("Altair Chart with point and interval selection")


# taken from vega_datasets cars example
@st.cache_data  # use caching to avoid a potential issue with flakiness
def get_cars_data():
    return data.cars()


cars = get_cars_data()
interval = alt.selection_interval()

point = alt.selection_point()

st.subheader("Scatter chart with selection_point")

if st.button("Create some elements to unmount component"):
    for _ in range(3):
        # The sleep here is needed, because it won't unmount the
        # component if this is too fast.
        time.sleep(1)
        st.write("Another element")

base = (
    alt.Chart(cars)
    .mark_point()
    .encode(
        x="Horsepower:Q",
        y="Miles_per_Gallon:Q",
        color=alt.condition(point, "Origin:N", alt.value("lightgray")),
        tooltip=alt.value(None),
    )
)
chart_point = base.add_params(point)
st.altair_chart(
    chart_point, on_select="rerun", key="scatter_point", use_container_width=True
)
if (
    "scatter_point" in st.session_state
    and len(st.session_state.scatter_point.selection) > 0
):
    st.write("Scatter chart with selection_point:", str(st.session_state.scatter_point))

st.subheader("Scatter chart with selection_interval")
base = (
    alt.Chart(cars)
    .mark_point()
    .encode(
        x="Horsepower:Q",
        y="Miles_per_Gallon:Q",
        color=alt.condition(interval, "Origin:N", alt.value("lightgray")),
        tooltip=alt.value(None),
    )
)
chart_interval = base.add_params(interval)
# Set use_container_width=True for all charts so that the width is not dependent on Vega-lib updates.
st.altair_chart(
    chart_interval, on_select="rerun", key="scatter_interval", use_container_width=True
)
if (
    "scatter_interval" in st.session_state
    and len(st.session_state.scatter_interval.selection) > 0
):
    st.write(
        "Scatter chart with selection_interval:", str(st.session_state.scatter_interval)
    )

# BAR CHART
st.subheader("Bar chart with selection_point")
source = pd.DataFrame(
    {
        "a": ["A", "B", "C", "D", "E", "F", "G", "H", "I"],
        "b": [28, 55, 43, 91, 81, 53, 19, 87, 52],
    }
)

bar_graph_point = (
    alt.Chart(source)
    .mark_bar()
    .encode(
        x="a",
        y="b",
        fillOpacity=alt.condition(point, alt.value(1), alt.value(0.3)),
        tooltip=alt.value(None),
    )
    .add_params(point)
)
st.altair_chart(
    bar_graph_point, on_select="rerun", key="bar_point", use_container_width=True
)
if "bar_point" in st.session_state and len(st.session_state.bar_point.selection) > 0:
    st.write("Bar chart with selection_point:", str(st.session_state.bar_point))


bar_graph_interval = (
    alt.Chart(source)
    .mark_bar()
    .encode(
        x="a",
        y="b",
        fillOpacity=alt.condition(interval, alt.value(1), alt.value(0.3)),
        tooltip=alt.value(None),
    )
    .add_params(interval)
)

st.subheader("Bar chart with selection_interval")
st.altair_chart(
    bar_graph_interval, on_select="rerun", key="bar_interval", use_container_width=True
)
if (
    "bar_interval" in st.session_state
    and len(st.session_state.bar_interval.selection) > 0
):
    st.write("Bar chart with selection_interval:", str(st.session_state.bar_interval))

# STACKED AREA CHART
source = data.iowa_electricity()

base = (
    alt.Chart(source)
    .mark_area()
    .encode(
        x="year:T",
        y="net_generation:Q",
        color=alt.condition(point, "source:N", alt.value("lightgray")),
        tooltip=alt.value(None),
    )
)
area_chart_point = base.add_params(point)
st.subheader("Area chart with selection_point")
selection = st.altair_chart(
    area_chart_point, on_select="rerun", key="area_point", use_container_width=True
)
if len(selection.selection) > 0:
    st.write("Area chart with selection_point:", str(selection.selection))


base = (
    alt.Chart(source)
    .mark_area()
    .encode(
        x="year:T",
        y="net_generation:Q",
        color=alt.condition(interval, "source:N", alt.value("lightgray")),
        tooltip=alt.value(None),
    )
)
area_chart_interval = base.add_params(interval)
st.subheader("Area chart with selection_interval")
area_interval_selection = st.altair_chart(
    area_chart_interval,
    on_select="rerun",
    key="area_interval",
    use_container_width=True,
)
if len(area_interval_selection.selection) > 0:
    st.write(
        "Area chart with selection_interval:", str(area_interval_selection.selection)
    )

# HISTOGRAM CHART
source = data.movies()

base = (
    alt.Chart(source)
    .mark_bar()
    .encode(
        alt.X("IMDB_Rating:Q", bin=True),
        y="count()",
        color=alt.condition(point, "IMDB_Rating:Q", alt.value("lightgray")),
        tooltip=alt.value(None),
    )
)
histogram_point = base.add_params(point)
st.subheader("Histogram chart with selection_point")
st.altair_chart(
    histogram_point, on_select="rerun", key="histogram_point", use_container_width=True
)
if (
    "histogram_point" in st.session_state
    and len(st.session_state.histogram_point.selection) > 0
):
    st.write(
        "Histogram chart with selection_point:", str(st.session_state.histogram_point)
    )

base = (
    alt.Chart(source)
    .mark_bar()
    .encode(
        alt.X("IMDB_Rating:Q", bin=True),
        y="count()",
        color=alt.condition(interval, "IMDB_Rating:Q", alt.value("lightgray")),
        tooltip=alt.value(None),
    )
)
histogram_interval = base.add_params(interval)
st.subheader("Histogram chart with selection_interval")
st.altair_chart(
    histogram_interval,
    on_select="rerun",
    key="histogram_interval",
    use_container_width=True,
)
if (
    "histogram_interval" in st.session_state
    and len(st.session_state.histogram_interval.selection) > 0
):
    st.write(
        "Histogram chart with selection_interval:",
        str(st.session_state.histogram_interval),
    )

# SELECTIONS IN FORM
st.header("Selections in form:")

with st.form(key="my_form", clear_on_submit=True):
    selection = st.altair_chart(
        histogram_point,
        on_select="rerun",
        key="histogram_point_in_form",
        use_container_width=True,
    )
    st.form_submit_button("Submit")

st.write("Histogram-in-form selection:", str(selection))
if "histogram_point_in_form" in st.session_state:
    st.write(
        "Histogram-in-form selection in session state:",
        str(st.session_state.histogram_point_in_form),
    )

# SELECTIONS IN CALLBACK
st.header("Selection callback:")


def on_selection():
    st.write(
        "Histogram selection callback:",
        str(st.session_state.histogram_point_in_callback),
    )


selection = st.altair_chart(
    histogram_point,
    on_select=on_selection,
    key="histogram_point_in_callback",
    use_container_width=True,
)


# SELECTIONS IN FRAGMENT
st.header("Selections in fragment:")


@st.fragment
def test_fragment():
    selection = st.altair_chart(
        histogram_point,
        on_select=on_selection,
        key="histogram_point_in_fragment",
        use_container_width=True,
    )
    st.write("Histogram-in-fragment selection:", str(selection))


test_fragment()

if "runs" not in st.session_state:
    st.session_state.runs = 0
st.session_state.runs += 1
st.write("Runs:", st.session_state.runs)


================================================
File: /e2e_playwright/st_altair_chart_basic_select_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


"""To determine the Canvas click points, you can run the Streamlit app, attach an event listener to the canvas and read the position from there."""

import re
from dataclasses import dataclass

import pytest
from playwright.sync_api import Locator, Page, expect

from e2e_playwright.conftest import (
    ImageCompareFunction,
    wait_for_app_run,
)
from e2e_playwright.shared.app_utils import (
    click_form_button,
    expect_prefixed_markdown,
    get_element_by_key,
)


@dataclass
class _MousePosition:
    x: int
    y: int


def _create_selection_rectangle(
    app: Page,
    chart: Locator,
    canvas_start_pos: _MousePosition,
    canvas_end_pos: _MousePosition,
) -> None:
    chart.scroll_into_view_if_needed()
    expect(chart).to_be_visible()
    bounding_box = chart.bounding_box()
    assert bounding_box is not None
    canvas_start_x_px = bounding_box.get("x", 0)
    canvas_start_y_px = bounding_box.get("y", 0)
    app.mouse.move(
        canvas_start_x_px + canvas_start_pos.x, canvas_start_y_px + canvas_start_pos.y
    )
    app.mouse.down()
    app.mouse.move(
        canvas_start_x_px + canvas_end_pos.x, canvas_start_y_px + canvas_end_pos.y
    )
    app.mouse.up()
    wait_for_app_run(app)


def _click(app: Page, chart: Locator, click_position: _MousePosition) -> None:
    chart.scroll_into_view_if_needed()
    expect(chart).to_be_visible()
    chart.click(position={"x": click_position.x, "y": click_position.y})
    wait_for_app_run(app)


def _get_selection_point_scatter_chart(app: Page) -> Locator:
    return app.get_by_test_id("stVegaLiteChart").locator("canvas").nth(0)


def _get_selection_interval_scatter_chart(app: Page) -> Locator:
    return app.get_by_test_id("stVegaLiteChart").locator("canvas").nth(1)


def _get_selection_point_bar_chart(app: Page) -> Locator:
    return app.get_by_test_id("stVegaLiteChart").locator("canvas").nth(2)


def _get_selection_interval_bar_chart(app: Page) -> Locator:
    return app.get_by_test_id("stVegaLiteChart").locator("canvas").nth(3)


def _get_selection_point_area_chart(app: Page) -> Locator:
    return app.get_by_test_id("stVegaLiteChart").locator("canvas").nth(4)


def _get_selection_interval_area_chart(app: Page) -> Locator:
    return app.get_by_test_id("stVegaLiteChart").locator("canvas").nth(5)


def _get_selection_point_histogram(app: Page) -> Locator:
    return app.get_by_test_id("stVegaLiteChart").locator("canvas").nth(6)


def _get_selection_interval_histogram(app: Page) -> Locator:
    return app.get_by_test_id("stVegaLiteChart").locator("canvas").nth(7)


def _get_in_form_chart(app: Page) -> Locator:
    return app.get_by_test_id("stVegaLiteChart").locator("canvas").nth(8)


def _get_callback_chart(app: Page) -> Locator:
    return app.get_by_test_id("stVegaLiteChart").locator("canvas").nth(9)


def _get_in_fragment_chart(app: Page) -> Locator:
    return app.get_by_test_id("stVegaLiteChart").locator("canvas").nth(10)


def test_point_bar_chart_displays_selection_text(app: Page):
    chart = _get_selection_point_bar_chart(app)

    # click on E-bar
    _click(app, chart, _MousePosition(150, 180))

    expected_prefix = "Bar chart with selection_point:"
    expected_selection = re.compile(
        "\\{'selection': \\{'param_1': \\[\\{'a': 'B', 'b': 55\\}]\\}\\}"
    )
    expect_prefixed_markdown(app, expected_prefix, expected_selection)


def test_interval_bar_chart_displays_selection_text(app: Page):
    chart = _get_selection_interval_bar_chart(app)
    expect(chart).to_be_visible()

    # change also height, because otherwise the selection is not triggered
    _create_selection_rectangle(
        app, chart, _MousePosition(90, 150), _MousePosition(175, 155)
    )

    expected_prefix = "Bar chart with selection_interval:"
    expected_selection = re.compile(
        "\\{'selection': \\{'param_1': \\{'a': \\['A', 'B'\\], 'b': \\[.+, .+\\]\\}\\}\\}"
    )
    expect_prefixed_markdown(app, expected_prefix, expected_selection)


def test_point_area_chart_displays_selection_text(app: Page):
    chart = _get_selection_point_area_chart(app)

    _click(app, chart, _MousePosition(150, 150))

    expected_prefix = "Area chart with selection_point:"
    expected_selection = re.compile(
        "\\{'param_1': \\[\\{'source': 'Fossil Fuels', 'year': .+, 'net_generation': .+\\}\\]\\}"
    )
    expect_prefixed_markdown(app, expected_prefix, expected_selection)


def test_interval_area_chart_displays_selection_text(app: Page):
    chart = _get_selection_interval_area_chart(app)

    _create_selection_rectangle(
        app, chart, _MousePosition(120, 110), _MousePosition(225, 195)
    )

    expected_prefix = "Area chart with selection_interval:"
    expected_selection = re.compile(
        "\\{'param_1': \\{'year': \\[.+, .+\\], 'net_generation': \\[.+, .+\\]\\}\\}"
    )
    expect_prefixed_markdown(app, expected_prefix, expected_selection)


def test_point_histogram_chart_displays_selection_text(app: Page):
    chart = _get_selection_point_histogram(app)

    _click(app, chart, _MousePosition(255, 238))

    expected_prefix = "Histogram chart with selection_point:"
    expected_selection = re.compile(
        "{'selection': {'param_1': \\[{'IMDB_Rating': 4.6}\\]}}"
    )
    expect_prefixed_markdown(app, expected_prefix, expected_selection)


def test_interval_histogram_chart_displays_selection_text(app: Page):
    chart = _get_selection_interval_histogram(app)

    _create_selection_rectangle(
        app, chart, _MousePosition(160, 210), _MousePosition(205, 200)
    )

    expected_prefix = "Histogram chart with selection_interval:"
    expected_selection = re.compile(
        "\\{'selection': \\{'param_1': \\{'IMDB_Rating': \\[.+, .+\\]\\}\\}\\}"
    )
    expect_prefixed_markdown(app, expected_prefix, expected_selection)


def test_double_click_interval_shows_no_selection_text(app: Page):
    chart = _get_selection_interval_scatter_chart(app)

    _create_selection_rectangle(
        app, chart, _MousePosition(130, 100), _MousePosition(215, 160)
    )

    expected_prefix = "Scatter chart with selection_interval:"
    expected_selection = re.compile(
        "\\{'selection': \\{'param_1': \\{'Horsepower': \\[.+, .+\\], 'Miles_per_Gallon': \\[.+, .+\\]\\}\\}\\}"
    )
    expect_prefixed_markdown(app, expected_prefix, expected_selection)

    chart.dblclick(position={"x": 130, "y": 100})
    wait_for_app_run(app)
    selection_text = app.get_by_test_id("stMarkdownContainer").filter(
        has_text=expected_selection
    )
    expect(selection_text).to_have_count(0)


def test_point_selection_scatter_chart_displays_selection_text(app: Page):
    chart = _get_selection_point_scatter_chart(app)

    _click(app, chart, _MousePosition(264, 162))

    expected_prefix = "Scatter chart with selection_point:"
    expected_selection = re.compile(
        "\\{'selection': \\{'param_1': \\[\\{'Origin': 'USA', 'Horsepower': .+, 'Miles_per_Gallon': .+\\}\\]\\}\\}"
    )
    expect_prefixed_markdown(app, expected_prefix, expected_selection)


def test_interval_selection_scatter_chart_displays_selection_snapshot(
    app: Page, assert_snapshot: ImageCompareFunction
):
    chart = _get_selection_interval_scatter_chart(app)

    _create_selection_rectangle(
        app, chart, _MousePosition(260, 110), _MousePosition(433, 220)
    )

    expected_prefix = "Scatter chart with selection_interval:"
    expected_selection = re.compile(
        "\\{'selection': \\{'param_1': \\{'Horsepower': \\[.+, .+\\], 'Miles_per_Gallon': \\[.+, .+\\]\\}\\}\\}"
    )
    expect_prefixed_markdown(app, expected_prefix, expected_selection)

    assert_snapshot(chart, name="st_altair_chart-scatter_interval_selection")


def _test_shift_click_point_selection_scatter_chart_displays_selection(
    app: Page,
) -> Locator:
    chart = _get_selection_point_scatter_chart(app)
    expect(chart).to_be_visible()
    chart.scroll_into_view_if_needed()
    chart.click(position={"x": 264, "y": 162})
    wait_for_app_run(app)
    chart.click(position={"x": 310, "y": 175}, modifiers=["Shift"])
    wait_for_app_run(app)
    chart.click(position={"x": 402, "y": 194}, modifiers=["Shift"])
    wait_for_app_run(app)
    chart.click(position={"x": 181, "y": 94}, modifiers=["Shift"])
    wait_for_app_run(app)

    # move the mouse away so that we do not have any hover-menu effects on the chart when taking the screenshot.
    # we re-use the screenshot for the unmounting test.
    app.mouse.move(0, 0)
    app.wait_for_timeout(250)

    expected_prefix = "Scatter chart with selection_point:"
    expected_selection = re.compile(
        "\\{'selection': \\{'param_1': \\[\\{'Origin': 'USA', 'Horsepower': .+, 'Miles_per_Gallon': .+\\}, \\{'Origin': 'USA', 'Horsepower': .+, 'Miles_per_Gallon': .+\\}, \\{'Origin': 'USA', 'Horsepower': .+, 'Miles_per_Gallon': .+\\}, \\{'Origin': 'Japan', 'Horsepower': .+, 'Miles_per_Gallon': .+\\}\\]\\}\\}"
    )
    expect_prefixed_markdown(app, expected_prefix, expected_selection)

    return chart


def test_in_form_selection_and_session_state(app: Page):
    chart = _get_in_form_chart(app)
    expect(chart).to_be_visible()

    _click(app, chart, _MousePosition(255, 238))

    markdown_prefix = "Histogram-in-form selection:"
    markdown_prefix_session_state = "Histogram-in-form selection in session state:"
    empty_selection = re.compile("\\{'selection': \\{'param_1': \\{\\}\\}\\}")
    # nothing should be shown yet because we did not submit the form
    expect_prefixed_markdown(
        app,
        markdown_prefix,
        empty_selection,
    )
    expect_prefixed_markdown(
        app,
        markdown_prefix_session_state,
        empty_selection,
    )

    # submit the form. The selection uses a debounce of 200ms; if we click too early, the state is not updated correctly and we submit the old, unselected values
    # app.wait_for_timeout(210)
    click_form_button(app, "Submit")

    expected_selection = re.compile(
        "{'selection': {'param_1': \\[{'IMDB_Rating': 4.6}\\]}}"
    )
    expect_prefixed_markdown(app, markdown_prefix, expected_selection)
    expect_prefixed_markdown(app, markdown_prefix_session_state, expected_selection)


def test_selection_with_callback(app: Page):
    chart = _get_callback_chart(app)
    expect(chart).to_be_visible()

    _click(app, chart, _MousePosition(255, 238))

    markdown_prefix = "Histogram selection callback:"
    expected_selection = re.compile(
        "{'selection': {'param_1': \\[{'IMDB_Rating': 4.6}\\]}}"
    )
    expect_prefixed_markdown(app, markdown_prefix, expected_selection)


def test_selection_in_fragment(app: Page):
    chart = _get_in_fragment_chart(app)
    expect(chart).to_be_visible()

    markdown_prefix = "Histogram-in-fragment selection:"
    empty_selection = re.compile("\\{'selection': \\{'param_1': \\{\\}\\}\\}")
    expect_prefixed_markdown(app, markdown_prefix, empty_selection)

    _click(app, chart, _MousePosition(255, 238))

    expected_selection = re.compile(
        "{'selection': {'param_1': \\[{'IMDB_Rating': 4.6}\\]}}"
    )
    expect_prefixed_markdown(app, markdown_prefix, expected_selection)

    # Check that the main script has run once (the initial run), but not after the selection:
    expect(app.get_by_text("Runs: 1")).to_be_visible()


def test_shift_click_point_selection_scatter_chart_snapshot(
    app: Page, assert_snapshot: ImageCompareFunction
):
    chart = _test_shift_click_point_selection_scatter_chart_displays_selection(app)
    chart.scroll_into_view_if_needed()
    assert_snapshot(chart, name="st_altair_chart-scatter_shift_selection")


# Skip firefox since it takes a snapshot with a slightly different size
# compared to the one in the test_multi_row_and_multi_column_select_snapshot test
@pytest.mark.skip_browser("firefox")
def test_selection_state_remains_after_unmounting_snapshot(
    app: Page, assert_snapshot: ImageCompareFunction
):
    chart = _test_shift_click_point_selection_scatter_chart_displays_selection(app)

    # click on button to trigger unmounting / mounting
    app.get_by_test_id("stButton").filter(
        has_text="Create some elements to unmount component"
    ).locator("button").click()
    wait_for_app_run(app, wait_delay=4000)
    chart.scroll_into_view_if_needed()
    # Use the same snapshot name as the previous test to ensure visual consistency
    # Increase the image_threshold slightly because the second image is a little bit moved for some reason
    assert_snapshot(
        chart,
        name="st_altair_chart-scatter_shift_selection",
        image_threshold=0.041,
    )


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "scatter_point")).to_be_visible()


================================================
File: /e2e_playwright/st_altair_chart_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class


def test_altair_chart_displays_correctly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    expect(
        themed_app.get_by_test_id("stVegaLiteChart").locator("canvas")
    ).to_have_count(10)
    charts = themed_app.get_by_test_id("stVegaLiteChart")
    expect(charts).to_have_count(10)
    snapshot_names = [
        "st_altair_chart-scatter_chart_default_theme",
        "st_altair_chart-scatter_chart_streamlit_theme",
        "st_altair_chart-scatter_chart_overwritten_theme",
        "st_altair_chart-bar_chart_overwritten_theme",
        "st_altair_chart-pie_chart_large_legend_items",
        "st_altair_chart-grouped_bar_chart_default_theme",
        "st_altair_chart-grouped_bar_chart_streamlit_theme",
        "st_altair_chart-grouped_use_container_width_default_theme",
        "st_altair_chart-grouped_layered_line_chart_streamlit_theme",
        "st_altair_chart-vconcat_width",
    ]
    for i, name in enumerate(snapshot_names):
        # We use a higher threshold here to prevent some flakiness
        # We should probably remove this once we have refactored the
        # altair frontend component.
        assert_snapshot(charts.nth(i), name=name, image_threshold=0.6)


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stVegaLiteChart")


def test_chart_tooltip_styling(app: Page, assert_snapshot: ImageCompareFunction):
    """Check that the chart tooltip styling is correct."""
    pie_chart = app.get_by_test_id("stVegaLiteChart").nth(4)
    pie_chart.scroll_into_view_if_needed()
    pie_chart.locator("canvas").hover(position={"x": 60, "y": 60}, force=True)
    tooltip = app.locator("#vg-tooltip-element")
    expect(tooltip).to_be_visible()

    assert_snapshot(tooltip, name="st_altair_chart-tooltip_styling")


def test_chart_menu_styling(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Check that the chart menu styling is correct."""
    chart = themed_app.get_by_test_id("stVegaLiteChart").first
    chart.locator("summary").click()
    chart_menu = chart.locator(".vega-actions")
    expect(chart_menu).to_be_visible()
    assert_snapshot(chart_menu, name="st_altair_chart-menu_styling")


================================================
File: /e2e_playwright/st_area_chart.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from datetime import date

import numpy as np
import pandas as pd
from vega_datasets import data as vega_data

import streamlit as st

np.random.seed(0)


data = np.random.randn(20, 3)
df = pd.DataFrame(data, columns=["a", "b", "c"])

# st.area/bar/line_chart all use Altair/Vega-Lite under the hood.
# By default, Vega-Lite displays time values in the browser's local
# time zone, but data is sent down to the browser as UTC. This means
# Times need to be set correctly to the users timezone.
utc_df = pd.DataFrame(
    {
        "index": [
            date(2019, 8, 9),
            date(2019, 8, 10),
            date(2019, 8, 11),
            date(2019, 8, 12),
        ],
        "numbers": [10, 50, 30, 40],
    }
)

utc_df.set_index("index", inplace=True)

# Dataframe to test the color parameter support:
N = 100

color_df = pd.DataFrame(
    {
        # Using a negative range so certain kinds of bugs are more visible.
        "a": -np.arange(N),
        "b": np.random.rand(N) * 10,
        "c": np.random.rand(N) * 10,
        "d": np.random.randn(N) * 30,
        "e": ["bird" if x % 2 else "airplane" for x in range(N)],
    }
)

st.header("Area Chart")

st.area_chart()
st.area_chart(df)
st.area_chart(df, x="a")
st.area_chart(df, y="a")
st.area_chart(df, y=["a", "b"])
st.area_chart(df, x="a", y="b", height=500, width=300, use_container_width=False)
st.area_chart(df, x="b", y="a")
st.area_chart(df, x="a", y=["b", "c"])
st.area_chart(utc_df)
st.area_chart(color_df, x="a", y="b", color="e")
st.area_chart(df, x_label="X Axis Label", y_label="Y Axis Label")

# Additional tests for stacking options
np.random.seed(5)
df = pd.DataFrame(np.random.randn(20, 3), columns=["a", "b", "c"])
st.area_chart(df, color=["#ffaa00", "#3399ff", "#009900"], stack=False)
source = vega_data.unemployment_across_industries()
st.area_chart(source, x="date", y="count", color="series", stack=True)
st.area_chart(source, x="date", y="count", color="series", stack="normalize")
st.area_chart(source, x="date", y="count", color="series", stack="center")


================================================
File: /e2e_playwright/st_area_chart_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class

TOTAL_AREA_CHARTS = 15


def test_area_chart_rendering(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.area_chart renders correctly via snapshot testing."""
    area_chart_elements = app.get_by_test_id("stVegaLiteChart")
    expect(area_chart_elements).to_have_count(TOTAL_AREA_CHARTS)

    # Also make sure that all canvas objects are rendered:
    expect(area_chart_elements.locator("canvas")).to_have_count(TOTAL_AREA_CHARTS)

    for i, element in enumerate(area_chart_elements.all()):
        assert_snapshot(element, name=f"st_area_chart-{i}")


def test_themed_area_chart_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.area_chart renders with different theming."""
    area_chart_elements = themed_app.get_by_test_id("stVegaLiteChart")
    expect(area_chart_elements).to_have_count(TOTAL_AREA_CHARTS)

    # Also make sure that all canvas objects are rendered:
    expect(area_chart_elements.locator("canvas")).to_have_count(TOTAL_AREA_CHARTS)

    # Only test a single chart per built-in chart type:
    assert_snapshot(area_chart_elements.nth(1), name="st_area_chart_themed")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stVegaLiteChart")


================================================
File: /e2e_playwright/st_audio.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time
from pathlib import Path

import requests

import streamlit as st

# Construct test assets path relative to this script file to
# allow its execution with different working directories.
TEST_ASSETS_DIR = Path(__file__).parent / "test_assets"

st.header("Audio from bytes")
url1 = "https://www.w3schools.com/html/horse.ogg"
file = requests.get(url1).content
st.audio(file)

st.header("Audio from URL")
url2 = "https://mdn.github.io/learning-area/html/multimedia-and-embedding/video-and-audio-content/viper.mp3"
st.audio(url2, start_time=10, end_time=13)
st.audio(url2, start_time=15, end_time=19, loop=True)

st.header("Audio from mp3 file (str and Path)")
CAT_AUDIO = TEST_ASSETS_DIR / "cat-purr.mp3"
st.audio(str(CAT_AUDIO))
st.audio(CAT_AUDIO)

st.header("Autoplay)")
autoplay = st.checkbox("Autoplay", value=False)
if st.button("Create some elements to unmount component"):
    for _ in range(3):
        # The sleep here is needed, because it won't unmount the
        # component if this is too fast.
        time.sleep(1)
        st.write("Another element")
st.audio(url2, autoplay=autoplay)


================================================
File: /e2e_playwright/st_audio_input.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import io
import time
import wave

import streamlit as st


# Main Audio Input Section
def render_main_audio_input():
    """
    Renders the main audio input component with a label and help tooltip.
    Displays the recorded audio and a boolean indicating if any audio was captured.
    """
    audio_input = st.audio_input(
        label="Audio Input 1", key="the_audio_input", help="This is the help text"
    )
    st.audio(audio_input)  # Display the audio playback if available
    st.write("Audio Input 1:", bool(audio_input))  # Display True if audio was captured

    if audio_input is not None:
        # Load the uploaded file as a file-like object
        wav_file_like = io.BytesIO(audio_input.read())

        try:
            # Open the in-memory file with the wave module
            with wave.open(wav_file_like, "rb") as wav_file:
                # Extract information about the WAV file
                num_channels = wav_file.getnchannels()
                sample_width = wav_file.getsampwidth()
                frame_rate = wav_file.getframerate()
                num_frames = wav_file.getnframes()
                duration = num_frames / float(frame_rate)

                # Display the information
                st.write(f"**Channels**: {num_channels}")
                st.write(f"**Sample Width**: {sample_width} bytes")
                st.write(f"**Frame Rate (Sample Rate)**: {frame_rate} Hz")
                st.write(f"**Number of Frames**: {num_frames}")
                st.write(f"**Duration**: {duration:.2f} seconds")

        except wave.Error as e:
            st.error(f"Error loading WAV file: {e}")


# Form Audio Input Section
def render_form_audio_input():
    """
    Renders a form with an audio input and a submit button.
    The form clears on submission and displays the captured audio.
    """
    audio_input_from_form = None
    with st.form(key="my_form", clear_on_submit=True):
        audio_input_from_form = st.audio_input(label="Audio Input in Form")
        st.form_submit_button("Submit")

    st.write("Audio Input in Form:", audio_input_from_form)


# Fragment Audio Input Section
@st.fragment()
def test_fragment():
    """
    Defines a fragment that includes an audio input component.
    Displays the captured audio from the fragment.
    """
    audio_input_from_fragment = st.audio_input(label="Audio Input in Fragment")
    st.write("Audio Input in Fragment:", audio_input_from_fragment)


# Audio Input with Various Options
def render_special_audio_inputs():
    """
    Renders various audio inputs with different properties such as
    disabled and hidden label visibility.
    """
    st.audio_input(label="Disabled Audio Input", disabled=True)
    st.audio_input(label="Hidden Label Audio Input", label_visibility="hidden")


# Callback Example
def on_change():
    """Callback function to set a flag when audio input changes."""
    st.session_state.audio_input_changed = True


def render_callback_audio_input():
    """
    Renders an audio input component with an `on_change` callback.
    Displays whether the audio input has changed.
    """
    st.audio_input(
        label="Testing Callback",
        on_change=on_change,
    )
    st.write("Audio Input Changed:", "audio_input_changed" in st.session_state)


# Component Remounting Section
def render_remount_test():
    """
    Renders an audio input component, simulates element unmounting, and checks
    if the value persists after remounting. Also includes a button to create additional elements.
    """
    if st.button("Create some elements to unmount component"):
        for _ in range(3):
            # Sleep is required to ensure the component properly unmounts.
            time.sleep(1)
            st.write("Another element")

    audio_input_after_sleep = st.audio_input(
        label="After sleep audio input", key="after_sleep_audio_input"
    )
    st.write("audio_input-after-sleep:", bool(audio_input_after_sleep))


# Runs Tracker
def track_runs():
    """Tracks how many times the app has been run in this session."""
    if "runs" not in st.session_state:
        st.session_state.runs = 0
    st.session_state.runs += 1
    st.write("Runs:", st.session_state.runs)


# Direct function calls to render the app
st.title("Audio Input Test App")

render_main_audio_input()
render_form_audio_input()
test_fragment()  # Fragment function call
render_special_audio_inputs()
render_callback_audio_input()
render_remount_test()
track_runs()


================================================
File: /e2e_playwright/st_audio_input_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import annotations

import pytest
from playwright.sync_api import FrameLocator, Locator, Page, Route, expect

from e2e_playwright.conftest import IframedPage, ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_button,
    click_form_button,
    expect_help_tooltip,
    get_element_by_key,
)


def stop_recording(audio_input: Locator, app: Page):
    """Stop recording audio and wait for the recording to complete."""
    audio_input.get_by_role("button", name="Stop recording").click()
    app.wait_for_timeout(5000)  # ci seems to be very slow so adding wait here


def ensure_waveform_is_not_rendered(audio_input: Locator):
    expect(audio_input.get_by_test_id("stAudioInputWaveSurfer")).not_to_be_visible()

    time_code = audio_input.get_by_test_id("stAudioInputWaveformTimeCode")
    expect(time_code).to_have_text("00:00")

    audio_input.hover()
    expect(
        audio_input.get_by_role("button", name="Clear recording")
    ).not_to_be_visible()


def ensure_waveform_rendered(audio_input: Locator):
    # Check for the waveform and time code
    expect(audio_input.get_by_test_id("stAudioInputWaveSurfer")).to_be_visible()

    time_code = audio_input.get_by_test_id("stAudioInputWaveformTimeCode")
    expect(time_code).to_be_visible()
    expect(time_code).not_to_have_text("00:00")

    audio_input.hover()
    expect(audio_input.get_by_role("button", name="Clear recording")).to_be_visible()
    expect(audio_input.get_by_role("button", name="Download as WAV")).to_be_visible()


def test_audio_input_renders(app: Page):
    """Test that the audio input component is rendered the correct number of times."""
    audio_input_elements = app.get_by_test_id("stAudioInput")
    count = 7  # Expected number of audio input elements

    # Verify that the expected number of elements is rendered
    expect(audio_input_elements).to_have_count(count)

    # Check each element is visible
    for i in range(count):
        expect(audio_input_elements.nth(i)).to_be_visible()


def test_check_top_level_class(app: Page):
    """Check that the top-level class 'stAudioInput' is correctly applied."""
    check_top_level_class(app, "stAudioInput")


def test_custom_css_class_via_key(app: Page):
    """Test that a custom CSS class can be applied to the audio input component via the key."""
    expect(get_element_by_key(app, "the_audio_input")).to_be_visible()


def test_audio_input_default_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Take a snapshot of the default state of the audio input element for visual regression."""
    audio_input_element = themed_app.get_by_test_id("stAudioInput").first
    assert_snapshot(audio_input_element, name="st_audio_input-default")


def test_audio_input_disabled_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Take a snapshot of the disabled audio input element for visual regression."""
    disabled_audio_input_element = themed_app.get_by_test_id("stAudioInput").nth(3)
    assert_snapshot(disabled_audio_input_element, name="st_audio_input-disabled")


@pytest.mark.only_browser("webkit")
def test_no_permission_audio_input_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Take a snapshot of the audio input element when no permission is granted."""
    no_permission_audio_input = themed_app.get_by_test_id("stAudioInput").nth(0)
    record_button = no_permission_audio_input.get_by_role("button", name="Record")

    expect(
        themed_app.get_by_text("This app would like to use your microphone.")
    ).not_to_be_visible()

    expect(record_button).to_be_visible()
    expect(record_button).not_to_be_disabled()

    expect(record_button).not_to_be_disabled()
    record_button.click()

    # Verify the permission message is visible
    expect(
        themed_app.get_by_text("This app would like to use your microphone.")
    ).to_be_visible()

    # Capture the snapshot
    assert_snapshot(no_permission_audio_input, name="st_audio_input-no_permission")


def test_audio_input_label_visibility_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Take a snapshot to check visibility of the audio input label when hidden."""
    audio_input_no_label_visibility = themed_app.get_by_test_id("stAudioInput").nth(4)

    # Verify the label is hidden
    expect(themed_app.get_by_text("Hidden Label Audio Input")).not_to_be_visible()

    # Capture the snapshot
    assert_snapshot(
        audio_input_no_label_visibility, name="st_audio_input-label_visibility_disabled"
    )


def _test_download_audio_file(app: Page, locator: FrameLocator | Locator):
    audio_input = locator.get_by_test_id("stAudioInput").nth(1)
    audio_input.get_by_role("button", name="Record").click()
    app.wait_for_timeout(1500)

    stop_recording(audio_input, app)

    with app.expect_download() as download_info:
        download_button = audio_input.get_by_role("button", name="Download as WAV")
        download_button.click()

    download = download_info.value
    file_name = download.suggested_filename

    assert file_name == "recording.wav"


@pytest.mark.only_browser("chromium")
def test_audio_input_file_download(app: Page):
    """Test that the audio input file can be downloaded."""
    app.context.grant_permissions(["microphone"])

    _test_download_audio_file(app, app.locator("body"))


@pytest.mark.only_browser("chromium")
def test_audio_input_file_download_in_iframe(iframed_app: IframedPage):
    """Test that the audio input file can be downloaded within an iframe."""

    page: Page = iframed_app.page
    frame_locator: FrameLocator = iframed_app.open_app(None)

    _test_download_audio_file(page, frame_locator)


@pytest.mark.only_browser("chromium")
def test_audio_input_callback(app: Page):
    """Test that the callback is triggered when audio input changes."""
    # Initial state before any interaction
    expect(app.get_by_text("Audio Input Changed: False")).to_be_visible()

    # Simulate recording interaction
    audio_input = app.get_by_test_id("stAudioInput").nth(5)
    audio_input.get_by_role("button", name="Record").click()
    app.wait_for_timeout(1500)

    stop_recording(audio_input, app)

    ensure_waveform_rendered(audio_input)

    # Verify the callback updated the UI
    expect(app.get_by_text("Audio Input Changed: True")).to_be_visible()


@pytest.mark.only_browser("chromium")
def test_audio_input_remount_keep_value(app: Page):
    """Test that the audio input component remounts without resetting its value."""
    expect(app.get_by_text("audio_input-after-sleep: False")).to_be_visible()

    # Simulate recording interaction
    audio_input = app.get_by_test_id("stAudioInput").nth(6)
    audio_input.scroll_into_view_if_needed()
    audio_input.get_by_role("button", name="Record").click()
    app.wait_for_timeout(1500)

    stop_recording(audio_input, app)

    wait_for_app_run(app)

    # Ensure the value is retained after remount
    expect(app.get_by_text("audio_input-after-sleep: True")).to_be_visible()

    # Unmount the component and verify the value is still retained
    click_button(app, "Create some elements to unmount component")
    expect(app.get_by_text("audio_input-after-sleep: True")).to_be_visible()

    ensure_waveform_rendered(audio_input)


@pytest.mark.only_browser("chromium")
def test_audio_input_works_in_forms(app: Page):
    """Test the functionality of the audio input component within a form."""
    app.context.grant_permissions(["microphone"])

    # Initial form state
    expect(app.get_by_text("Audio Input in Form: None")).to_be_visible()

    # Simulate recording in the form
    form_audio_input = app.get_by_test_id("stAudioInput").nth(1)
    form_audio_input.get_by_role("button", name="Record").click()
    app.wait_for_timeout(1500)

    stop_recording(form_audio_input, app)

    submit_button = app.get_by_role("button", name="Submit")
    submit_button.scroll_into_view_if_needed()
    expect(submit_button).to_be_enabled()

    # Verify the form state has not changed yet
    expect(app.get_by_text("Audio Input in Form: None")).to_be_visible()

    app.wait_for_timeout(1500)

    # Submit the form and verify the state update
    click_form_button(app, "Submit")
    wait_for_app_run(app)

    ensure_waveform_is_not_rendered(form_audio_input)

    app.get_by_text("Audio Input in Form:").scroll_into_view_if_needed()
    expect(app.get_by_text("Audio Input in Form: None")).not_to_be_visible()


@pytest.mark.only_browser("chromium")
def test_audio_input_works_with_fragments(app: Page):
    """Test that the audio input component works correctly inside fragments."""
    app.context.grant_permissions(["microphone"])

    # Initial state for fragments
    expect(app.get_by_text("Runs: 1")).to_be_visible()
    expect(app.get_by_text("Audio Input in Fragment: None")).to_be_visible()

    # Simulate recording interaction in a fragment
    fragment_audio_input = app.get_by_test_id("stAudioInput").nth(2)
    fragment_audio_input.scroll_into_view_if_needed()
    fragment_audio_input.get_by_role("button", name="Record").click()
    app.wait_for_timeout(1500)

    stop_recording(fragment_audio_input, app)

    wait_for_app_run(app)

    # Verify the state is updated without additional reruns
    app.get_by_text("Audio Input in Fragment:").scroll_into_view_if_needed()
    expect(app.get_by_text("Audio Input in Fragment: None")).not_to_be_visible()
    expect(app.get_by_text("Runs: 1")).to_be_visible()

    # Clear recording and verify the state remains consistent
    fragment_audio_input.get_by_role("button", name="Clear recording").click()
    wait_for_app_run(app)
    expect(app.get_by_text("Runs: 1")).to_be_visible()


@pytest.mark.only_browser("chromium")
def test_audio_input_basic_flow(app: Page):
    """Test the basic flow of recording, playing, and clearing audio input."""
    app.context.grant_permissions(["microphone"])

    # Verify initial state
    expect(app.get_by_text("Audio Input 1: False")).to_be_visible()
    audio_input = app.get_by_test_id("stAudioInput").first

    # Check for help tooltip and ensure permissions message is hidden
    expect_help_tooltip(app, audio_input, "This is the help text")
    expect(
        app.get_by_text("This app would like to use your microphone.").first
    ).not_to_be_visible()

    # Start recording and verify time code
    record_button = app.get_by_role("button", name="Record").first
    clock = audio_input.get_by_test_id("stAudioInputWaveformTimeCode")
    expect(clock).to_have_text("00:00")
    record_button.click()

    app.wait_for_timeout(1500)

    stop_recording(audio_input, app)

    wait_for_app_run(app)
    expect(app.get_by_text("Audio Input 1: True")).to_be_visible()

    ensure_waveform_rendered(audio_input)

    expect(app.get_by_text("Channels:")).to_be_visible()
    expect(app.get_by_text("Sample Width:")).to_be_visible()
    expect(app.get_by_text("Frame Rate (Sample Rate):")).to_be_visible()
    expect(app.get_by_text("Duration:")).to_be_visible()

    # Ensure no error is displayed
    expect(app.get_by_text("Error loading WAV file")).not_to_be_visible()

    # Play and pause the recording, then verify the controls
    play_button = audio_input.get_by_role("button", name="Play").first
    expect(clock).not_to_have_text("00:00")
    play_button.click()

    pause_button = audio_input.get_by_role("button", name="Pause").first
    expect(pause_button).to_be_visible()
    pause_button.click()
    expect(play_button).to_be_visible()

    # Clear the recording and verify reset to initial state
    audio_input.hover()
    clear_button = audio_input.get_by_role("button", name="Clear recording").first
    expect(clear_button).to_be_visible()
    clear_button.click()

    wait_for_app_run(app)
    expect(app.get_by_text("Audio Input 1: False")).to_be_visible()
    expect(audio_input.get_by_role("button", name="Record").first).to_be_visible()
    expect(clock).to_have_text("00:00")


@pytest.mark.only_browser("chromium")
def test_audio_input_error_state(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test the error state of audio input."""
    themed_app.context.grant_permissions(["microphone"])

    def handle(route: Route):
        route.abort("failed")

    themed_app.route("**/_stcore/upload_file/**", handle)

    audio_input = themed_app.get_by_test_id("stAudioInput").first

    audio_input.get_by_role("button", name="Record").click()
    themed_app.wait_for_timeout(1500)
    stop_recording(audio_input, themed_app)

    expect(
        audio_input.get_by_text("An error has occurred, please try again.")
    ).to_be_visible()

    assert_snapshot(audio_input, name="st_audio_input-error_state")

    audio_input.get_by_role("button", name="Reset").click()
    expect(
        audio_input.get_by_text("An error has occurred, please try again.")
    ).not_to_be_visible()


================================================
File: /e2e_playwright/st_audio_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import re

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import wait_until
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_button,
    click_checkbox,
)


def test_audio_has_correct_properties(app: Page):
    """Test that `st.audio` renders correct properties."""
    audio_elements = app.get_by_test_id("stAudio")
    expect(audio_elements).to_have_count(6)
    expect(audio_elements.nth(0)).to_be_visible()
    expect(audio_elements.nth(0)).to_have_attribute("controls", "")
    expect(audio_elements.nth(0)).to_have_attribute("src", re.compile(r".*media.*wav"))


@pytest.mark.skip_browser("webkit")
def test_audio_end_time(app: Page):
    """Test that `st.audio` end_time property works correctly."""
    audio_element = app.get_by_test_id("stAudio").nth(1)
    expect(audio_element).to_be_visible()
    audio_element.evaluate("el => el.play()")
    app.wait_for_timeout(5000)
    expect(audio_element).to_have_js_property("paused", True)
    wait_until(app, lambda: int(audio_element.evaluate("el => el.currentTime")) == 13)


@pytest.mark.skip_browser("webkit")
def test_audio_end_time_loop(app: Page):
    """Test that `st.audio` end_time and loop properties work correctly."""
    audio_element = app.get_by_test_id("stAudio").nth(2)
    audio_element.evaluate("el => el.play()")
    # The corresponding element definition looks like this:
    # st.audio(url2, start_time=15, end_time=19, loop=True)
    # We wait for 6 seconds, which mean the current time should be
    # approximately 17 (4 seconds until end_time and 2 seconds starting from start time)
    app.wait_for_timeout(6000)
    expect(audio_element).to_have_js_property("paused", False)
    wait_until(app, lambda: 16 < audio_element.evaluate("el => el.currentTime") < 18)


def test_audio_autoplay(app: Page):
    """Test that `st.audio` autoplay property works correctly."""
    audio_element = app.get_by_test_id("stAudio").nth(5)
    expect(audio_element).to_have_js_property("paused", True)
    expect(audio_element).to_have_js_property("autoplay", False)

    # To prevent flakiness, we wait for the audio to load and start playing
    wait_until(
        app, lambda: audio_element.evaluate("el => el.readyState") == 4, timeout=15000
    )

    click_checkbox(app, "Autoplay")

    expect(audio_element).to_have_js_property("autoplay", True)
    expect(audio_element).to_have_js_property("paused", False)


def test_audio_remount_no_autoplay(app: Page):
    """Test that `st.audio` remounts correctly without autoplay."""
    audio_element = app.get_by_test_id("stAudio").nth(5)
    expect(audio_element).to_have_js_property("paused", True)
    expect(audio_element).to_have_js_property("autoplay", False)

    # To prevent flakiness, we wait for the audio to load and start playing
    wait_until(
        app, lambda: audio_element.evaluate("el => el.readyState") == 4, timeout=15000
    )

    click_checkbox(app, "Autoplay")

    expect(audio_element).to_have_js_property("autoplay", True)
    expect(audio_element).to_have_js_property("paused", False)

    click_checkbox(app, "Autoplay")
    click_button(app, "Create some elements to unmount component")

    expect(audio_element).to_have_js_property("autoplay", False)
    expect(audio_element).to_have_js_property("paused", True)


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stAudio")


================================================
File: /e2e_playwright/st_balloons.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.balloons()


================================================
File: /e2e_playwright/st_balloons_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.shared.app_utils import check_top_level_class


def test_balloons_are_present_on_page(app: Page):
    expect(app.get_by_test_id("stBalloons")).to_have_count(1)
    check_top_level_class(app, "stBalloons")


================================================
File: /e2e_playwright/st_bar_chart.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
from datetime import date

import numpy as np
import pandas as pd
from vega_datasets import data as vega_data

import streamlit as st

np.random.seed(0)


data = np.random.randn(20, 3)
df = pd.DataFrame(data, columns=["a", "b", "c"])

# st.area/bar/line_chart all use Altair/Vega-Lite under the hood.
# By default, Vega-Lite displays time values in the browser's local
# time zone, but data is sent down to the browser as UTC. This means
# Times need to be set correctly to the users timezone.
utc_df = pd.DataFrame(
    {
        "index": [
            date(2019, 8, 9),
            date(2019, 8, 10),
            date(2019, 8, 11),
            date(2019, 8, 12),
        ],
        "numbers": [10, 50, 30, 40],
    }
)

utc_df.set_index("index", inplace=True)

# Dataframe to test the color parameter support:
N = 100

color_df = pd.DataFrame(
    {
        # Using a negative range so certain kinds of bugs are more visible.
        "a": -np.arange(N),
        "b": np.random.rand(N) * 10,
        "c": np.random.rand(N) * 10,
        "d": np.random.randn(N) * 30,
        "e": ["bird" if x % 2 else "airplane" for x in range(N)],
    }
)

st.header("Bar Chart")

st.bar_chart()
st.bar_chart(df)
st.bar_chart(df, x="a")
st.bar_chart(df, y="a")
st.bar_chart(df, y=["a", "b"])
st.bar_chart(df, x="a", y="b", height=500, width=300, use_container_width=False)
st.bar_chart(df, x="b", y="a")
st.bar_chart(df, x="a", y=["b", "c"])
st.bar_chart(utc_df)
st.bar_chart(color_df, x="a", y="b", color="e")
st.bar_chart(df, x_label="X Axis Label", y_label="Y Axis Label")
st.bar_chart(df, horizontal=True)
st.bar_chart(df, horizontal=True, x_label="X Label", y_label="Y Label")

# Additional tests for stacking options
source = vega_data.barley()
st.bar_chart(source, x="variety", y="yield", color="site", stack=True)
st.bar_chart(source, x="variety", y="yield", color="site", stack=False)
st.bar_chart(source, x="variety", y="yield", color="site", stack="normalize")
st.bar_chart(source, x="variety", y="yield", color="site", stack="center")
st.bar_chart(source, x="variety", y="yield", color="site", stack="layered")


================================================
File: /e2e_playwright/st_bar_chart_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class

TOTAL_BAR_CHARTS = 18


def test_bar_chart_rendering(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.bar_chart renders correctly via snapshot testing."""
    bar_chart_elements = app.get_by_test_id("stVegaLiteChart")
    expect(bar_chart_elements).to_have_count(TOTAL_BAR_CHARTS)

    # Also make sure that all canvas objects are rendered:
    expect(bar_chart_elements.locator("canvas")).to_have_count(TOTAL_BAR_CHARTS)

    for i, element in enumerate(bar_chart_elements.all()):
        assert_snapshot(element, name=f"st_bar_chart-{i}")


def test_themed_bar_chart_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.bar_chart renders with different theming."""
    bar_chart_elements = themed_app.get_by_test_id("stVegaLiteChart")
    expect(bar_chart_elements).to_have_count(TOTAL_BAR_CHARTS)

    # Also make sure that all canvas objects are rendered:
    expect(bar_chart_elements.locator("canvas")).to_have_count(TOTAL_BAR_CHARTS)

    # Only test a single chart per built-in chart type:
    assert_snapshot(bar_chart_elements.nth(1), name="st_bar_chart_themed")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stVegaLiteChart")


================================================
File: /e2e_playwright/st_bokeh_chart.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import numpy as np
from bokeh.layouts import column, row
from bokeh.models import ColumnDataSource, CustomJS, Slider
from bokeh.plotting import figure

import streamlit as st

x = [1, 2, 3, 4, 5]
y = [6, 7, 2, 4, 5]

p = figure(title="simple line example", x_axis_label="x", y_axis_label="y")
p.line(x, y, legend="Trend", line_width=2)
st.bokeh_chart(p)

# draw charts in columns

left_chart = figure(title="Left", x_axis_label="x", y_axis_label="y")
left_chart.line(x, y, legend="Trend", line_width=2)

right_chart = figure(title="Right", x_axis_label="x", y_axis_label="y")
right_chart.line(x, y, legend="Trend", line_width=2)

col1, col2 = st.columns([1, 1])

with col1:
    st.bokeh_chart(left_chart, use_container_width=True)

with col2:
    st.bokeh_chart(right_chart, use_container_width=True)

x = np.linspace(0, 10, 500)
y = np.sin(x)

source = ColumnDataSource(data={"x": x, "y": y})

plot = figure(y_range=(-10, 10), width=400, height=400)

plot.line("x", "y", source=source, line_width=3, line_alpha=0.6)

amp = Slider(start=0.1, end=10, value=1, step=0.1, title="Amplitude")
freq = Slider(start=0.1, end=10, value=1, step=0.1, title="Frequency")
phase = Slider(start=-6.4, end=6.4, value=0, step=0.1, title="Phase")
offset = Slider(start=-9, end=9, value=0, step=0.1, title="Offset")

callback = CustomJS(
    args={"source": source, "amp": amp, "freq": freq, "phase": phase, "offset": offset},
    code="""
    const A = amp.value
    const k = freq.value
    const phi = phase.value
    const B = offset.value

    const x = source.data.x
    const y = Array.from(x, (x) => B + A*Math.sin(k*x+phi))
    source.data = { x, y }
""",
)

amp.js_on_change("value", callback)
freq.js_on_change("value", callback)
phase.js_on_change("value", callback)
offset.js_on_change("value", callback)

st.bokeh_chart(row(plot, column(amp, freq, phase, offset)))


================================================
File: /e2e_playwright/st_bokeh_chart_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.shared.app_utils import check_top_level_class


def test_bokeh_chart(app: Page):
    """Test that st.bokeh_chart renders correctly."""
    bokeh_chart_elements = app.get_by_test_id("stBokehChart")
    expect(bokeh_chart_elements).to_have_count(4)

    expect(bokeh_chart_elements.nth(0).locator("canvas").nth(0)).to_be_visible()
    expect(bokeh_chart_elements.nth(1).locator("canvas").nth(0)).to_be_visible()
    expect(bokeh_chart_elements.nth(2).locator("canvas").nth(0)).to_be_visible()

    # show a bokeh slider
    expect(bokeh_chart_elements.nth(3).locator("canvas").nth(0)).to_be_visible()


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stBokehChart")


================================================
File: /e2e_playwright/st_both_query_params_error.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.query_params.y = 1.23

# Should throw an error after both apis are used
params = st.experimental_get_query_params()


================================================
File: /e2e_playwright/st_both_query_params_error_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect


def test_query_params_exception_msg(app: Page):
    expect(app.get_by_test_id("stException")).to_be_visible()
    expect(
        app.get_by_text(
            "Using st.query_params together with either st.experimental_get_query_params or st.experimental_set_query_params is not supported. Please convert your app to only use st.query_params"
        )
    ).to_be_visible()


================================================
File: /e2e_playwright/st_button.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit import runtime

# st.session_state can only be used in streamlit
if runtime.exists():

    def on_click(x, y):
        if "click_count" not in st.session_state:
            st.session_state.click_count = 0

        st.session_state.click_count += 1
        st.session_state.x = x
        st.session_state.y = y

    i1 = st.button(
        "button 1", key="button", on_click=on_click, args=(1,), kwargs={"y": 2}
    )
    st.write("value:", i1)
    st.write("value from state:", st.session_state["button"])

    button_was_clicked = "click_count" in st.session_state
    st.write("Button was clicked:", button_was_clicked)

    if button_was_clicked:
        st.write("times clicked:", st.session_state.click_count)
        st.write("arg value:", st.session_state.x)
        st.write("kwarg value:", st.session_state.y)

i2 = st.checkbox("reset button return value")

i3 = st.button("button 2 (disabled)", disabled=True)
st.write("value 2:", i3)

i4 = st.button("button 3 (primary)", type="primary")
st.write("value 3:", i4)

i5 = st.button("button 4 (primary + disabled)", type="primary", disabled=True)
st.write("value 4:", i5)

st.button("button 5 (container_width)", use_container_width=True)

st.button(
    "button 6 (container_width + help)", use_container_width=True, help="help text"
)

st.button(
    ":material/search: _button 7_ (**styled** :green[label]) :material/arrow_forward:"
)

st.button("Like Button", icon=":material/thumb_up:")
st.button("Star Button", icon="⭐")

st.button("Tertiary Button", type="tertiary")
st.button("Disabled Tertiary Button", type="tertiary", disabled=True)


cols = st.columns(3)

# Order of conn_types matters to preserve the order in st_button.spec.js and the snapshot
conn_types = [
    "snowflake",
    "bigquery",
    "huggingface",
    "aws_s3",
    "http_file",
    "postgresql",
    "gsheets",
    "custom",
]
for i in range(len(conn_types)):
    cols[i % 3].button(conn_types[i], use_container_width=True)


================================================
File: /e2e_playwright/st_button_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_button,
    click_checkbox,
    get_element_by_key,
)


def test_button_widget_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the button widgets are correctly rendered via screenshot matching."""
    button_elements = themed_app.get_by_test_id("stButton")
    expect(button_elements).to_have_count(19)

    assert_snapshot(button_elements.nth(0), name="st_button-default")
    assert_snapshot(button_elements.nth(1), name="st_button-disabled")
    assert_snapshot(button_elements.nth(2), name="st_button-primary")
    assert_snapshot(button_elements.nth(3), name="st_button-disabled_primary")
    assert_snapshot(button_elements.nth(4), name="st_button-use_container_width")
    assert_snapshot(button_elements.nth(5), name="st_button-use_container_width_help")
    assert_snapshot(button_elements.nth(6), name="st_button-styled_label")
    assert_snapshot(button_elements.nth(7), name="st_button-material_icon")
    assert_snapshot(button_elements.nth(8), name="st_button-emoji_icon")
    assert_snapshot(button_elements.nth(9), name="st_button-tertiary")
    assert_snapshot(button_elements.nth(10), name="st_button-disabled_tertiary")

    # The rest is tested in one screenshot in the following test


def test_material_icon_hover(app: Page, assert_snapshot: ImageCompareFunction):
    material_icon_button = app.get_by_test_id("stButton").nth(7)
    app.get_by_text("Like Button").hover()
    assert_snapshot(material_icon_button, name="st_button-material_icon_hover")


def test_buttons_in_columns(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that the button widgets are correctly rendered in columns via screenshot matching."""
    columns_container = themed_app.get_by_test_id("stHorizontalBlock")
    expect(columns_container).to_have_count(1)

    assert_snapshot(columns_container, name="st_button-in_columns")


def test_value_correct_on_click(app: Page):
    button_element = app.get_by_test_id("stButton").locator("button").first
    button_element.click()
    expect(app.get_by_test_id("stMarkdown").nth(0)).to_have_text("value: True")
    expect(app.get_by_test_id("stMarkdown").nth(1)).to_have_text(
        "value from state: True"
    )


def test_value_not_reset_on_reclick(app: Page):
    button_element = app.get_by_test_id("stButton").locator("button").first
    button_element.click()
    button_element.click()
    expect(app.get_by_test_id("stMarkdown").first).to_have_text("value: True")


def test_click_calls_callback(app: Page):
    button_element = app.get_by_test_id("stButton").locator("button").first
    expect(app.get_by_test_id("stMarkdown").nth(2)).to_contain_text(
        "Button was clicked: False"
    )
    button_element.click()
    expect(app.get_by_test_id("stMarkdown").nth(2)).to_have_text(
        "Button was clicked: True"
    )
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text("times clicked: 1")
    expect(app.get_by_test_id("stMarkdown").nth(4)).to_have_text("arg value: 1")
    expect(app.get_by_test_id("stMarkdown").nth(5)).to_have_text("kwarg value: 2")


def test_click_increment_count(app: Page):
    button_element = app.get_by_test_id("stButton").locator("button").first
    button_element.click()
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text("times clicked: 1")
    button_element.click()
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text("times clicked: 2")
    button_element.click()
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text("times clicked: 3")


def test_reset_on_other_widget_change(app: Page):
    click_button(app, "button 1")
    expect(app.get_by_test_id("stMarkdown").nth(0)).to_have_text("value: True")
    expect(app.get_by_test_id("stMarkdown").nth(1)).to_have_text(
        "value from state: True"
    )

    click_checkbox(app, "reset button return value")
    expect(app.get_by_test_id("stMarkdown").nth(0)).to_have_text("value: False")
    expect(app.get_by_test_id("stMarkdown").nth(1)).to_have_text(
        "value from state: False"
    )


def test_show_tooltip_on_hover(app: Page, assert_snapshot: ImageCompareFunction):
    button_element = app.get_by_test_id("stButton").nth(5)
    button_element.hover()
    assert_snapshot(button_element, name="st_button-on_hover")
    expect(app.get_by_test_id("stTooltipContent")).to_have_text("help text")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stButton")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "button")).to_be_visible()


def test_shows_cursor_pointer(app: Page):
    """Test that the button shows cursor pointer when hovered."""
    button_element = app.get_by_test_id("stButton").first
    expect(button_element.locator("button")).to_have_css("cursor", "pointer")


================================================
File: /e2e_playwright/st_cache_data.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import numpy as np
import requests

import streamlit as st


@st.cache_data
def with_cached_widget_warning():
    st.write("Cached function that should show a widget usage warning.")
    st.selectbox("selectbox", ["foo", "bar", "baz", "qux"], index=1)


if st.button("Run cached function with widget warning"):
    with_cached_widget_warning()


@st.cache_data
def inner_cache_function():
    st.radio("radio 2", ["foo", "bar", "baz", "qux"], index=1)


@st.cache_data
def nested_cached_function():
    inner_cache_function()
    st.selectbox("selectbox 2", ["foo", "bar", "baz", "qux"], index=1)


if st.button("Run nested cached function with widget warning"):
    # When running nested_cached_function(), we get two warnings, one from
    # nested_cached_function() and one from inner_cache_function. inner_cache_function()
    # on its own would allow the widget usage, but since it is nested in the other
    # function that does not allow it, we don't allow it.
    # The outer experimental_allow_widgets=False will always take priority.
    # Otherwise, we would need to recompute the outer cached function whenever
    # the widget in the inner function is used. Which we don't want to do when
    # experimental_allow_widgets is set to False.
    nested_cached_function()


if "run_counter" not in st.session_state:
    st.session_state.run_counter = 0


@st.cache_data
def replay_element():
    st.session_state.run_counter += 1
    st.markdown(f"Cache executions: {st.session_state.run_counter}")
    return st.session_state.run_counter


if st.button("Cached function with element replay"):
    st.write("Cache return", replay_element())


@st.cache_data
def audio():
    url = "https://www.w3schools.com/html/horse.ogg"
    file = requests.get(url).content
    st.audio(file)


@st.cache_data
def video():
    url = "https://www.w3schools.com/html/mov_bbb.mp4"
    file = requests.get(url).content
    st.video(file)


audio()
video()


@st.cache_data
def image():
    img = np.repeat(0, 10000).reshape(100, 100)
    st.image(img, caption="A black square", width=200)


if st.checkbox("Show image", True):
    image()


================================================
File: /e2e_playwright/st_cache_data_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import re

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import rerun_app, wait_for_app_run
from e2e_playwright.shared.app_utils import click_button, click_checkbox, get_image


def test_that_caching_shows_cached_widget_warning(app: Page):
    click_button(app, "Run cached function with widget warning")
    wait_for_app_run(app)
    expect(app.get_by_test_id("stException")).to_have_count(1)

    exception_element = app.get_by_test_id("stException").nth(0)
    expect(exception_element).to_contain_text("CachedWidgetWarning: Your script uses")


def test_that_nested_cached_function_shows_cached_widget_warning(app: Page):
    click_button(app, "Run nested cached function with widget warning")
    expect(app.get_by_test_id("stException")).to_have_count(2)

    expect(app.get_by_test_id("stException").nth(0)).to_contain_text(
        "CachedWidgetWarning: Your script uses"
    )
    expect(app.get_by_test_id("stException").nth(1)).to_contain_text(
        "CachedWidgetWarning: Your script uses"
    )


def test_that_replay_element_works_as_expected(app: Page):
    click_button(app, "Cached function with element replay")
    expect(app.get_by_test_id("stException")).to_have_count(0)
    expect(app.get_by_text("Cache executions: 1")).to_be_visible()
    expect(app.get_by_text("Cache return 1")).to_be_visible()

    # Execute again, the values should be the same:
    click_button(app, "Cached function with element replay")
    expect(app.get_by_test_id("stException")).to_have_count(0)
    expect(app.get_by_text("Cache executions: 1")).to_be_visible()
    expect(app.get_by_text("Cache return 1")).to_be_visible()


# have 1 test so we don't have to reload the video
def test_st_audio_player_and_video_player(app: Page):
    audio = app.get_by_test_id("stAudio")

    expect(audio).to_be_visible()
    expect(audio).to_have_attribute("controls", "")
    expect(audio).to_have_attribute("src", re.compile(r"^.*\.wav$", re.IGNORECASE))
    audio_src = audio.get_attribute("src")

    video_player = app.get_by_test_id("stVideo")
    expect(video_player).to_be_visible()
    expect(video_player).to_have_attribute(
        "src", re.compile(r"^.*\.mp4$", re.IGNORECASE)
    )
    video_src = video_player.get_attribute("src")

    rerun_app(app)

    expect(audio).to_have_attribute("src", audio_src or "")
    expect(video_player).to_have_attribute("src", video_src or "")


def test_cached_image_replay(app: Page):
    """Test that the image is cached and replayed correctly."""
    image_element = get_image(app, "A black square").locator("img")
    # Image should be visible
    expect(image_element).to_be_visible()

    expect(image_element).to_have_css("height", "200px")
    expect(image_element).to_have_css("width", "200px")
    image_src = image_element.get_attribute("src")

    click_checkbox(app, "Show image")
    # Image should disappear
    expect(image_element).not_to_be_attached()

    click_checkbox(app, "Show image")
    # Image should be visible again
    expect(image_element).to_be_visible()
    expect(image_element).to_have_css("height", "200px")
    expect(image_element).to_have_css("width", "200px")
    expect(image_element).to_have_attribute("src", image_src or "")


================================================
File: /e2e_playwright/st_cache_resource.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st


@st.cache_resource
def with_cached_widget_warning():
    st.write("Cached function that should show a widget usage warning.")
    st.selectbox("selectbox", ["foo", "bar", "baz", "qux"], index=1)


if st.button("Run cached function with widget warning"):
    with_cached_widget_warning()


@st.cache_resource
def inner_cache_function():
    st.radio("radio 2", ["foo", "bar", "baz", "qux"], index=1)


@st.cache_resource
def nested_cached_function():
    inner_cache_function()
    st.selectbox("selectbox 2", ["foo", "bar", "baz", "qux"], index=1)


if st.button("Run nested cached function with widget warning"):
    # When running nested_cached_function(), we get two warnings, one from
    # nested_cached_function() and one from inner_cache_function. inner_cache_function()
    # on its own would allow the widget usage, but since it is nested in the other
    # function that does not allow it, we don't allow it.
    # The outer experimental_allow_widgets=False will always take priority.
    # Otherwise, we would need to recompute the outer cached function whenever
    # the widget in the inner function is used. Which we don't want to do when
    # experimental_allow_widgets is set to False.
    nested_cached_function()

if "run_counter" not in st.session_state:
    st.session_state.run_counter = 0


@st.cache_resource
def replay_element():
    st.session_state.run_counter += 1
    st.markdown(f"Cache executions: {st.session_state.run_counter}")
    return st.session_state.run_counter


if st.button("Cached function with element replay"):
    st.write("Cache return", replay_element())


================================================
File: /e2e_playwright/st_cache_resource_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from playwright.sync_api import Page, expect

from e2e_playwright.shared.app_utils import click_button


def test_that_caching_shows_cached_widget_warning(app: Page):
    click_button(app, "Run cached function with widget warning")
    expect(app.get_by_test_id("stException")).to_have_count(1)

    exception_element = app.get_by_test_id("stException").nth(0)
    expect(exception_element).to_contain_text("CachedWidgetWarning: Your script uses")


def test_that_nested_cached_function_shows_cached_widget_warning(app: Page):
    click_button(app, "Run nested cached function with widget warning")
    expect(app.get_by_test_id("stException")).to_have_count(2)

    expect(app.get_by_test_id("stException").nth(0)).to_contain_text(
        "CachedWidgetWarning: Your script uses"
    )
    expect(app.get_by_test_id("stException").nth(1)).to_contain_text(
        "CachedWidgetWarning: Your script uses"
    )


def test_that_replay_element_works_as_expected(app: Page):
    click_button(app, "Cached function with element replay")
    expect(app.get_by_test_id("stException")).to_have_count(0)
    expect(app.get_by_text("Cache executions: 1")).to_be_visible()
    expect(app.get_by_text("Cache return 1")).to_be_visible()

    # Execute again, the values should be the same:
    click_button(app, "Cached function with element replay")
    expect(app.get_by_test_id("stException")).to_have_count(0)
    expect(app.get_by_text("Cache executions: 1")).to_be_visible()
    expect(app.get_by_text("Cache return 1")).to_be_visible()


================================================
File: /e2e_playwright/st_camera_input.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

x = st.camera_input("Label1", help="help1", key="camera_input_1")

if x is not None:
    st.image(x)

y = st.camera_input("Label2", help="help2", disabled=True)


================================================
File: /e2e_playwright/st_camera_input_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class, get_element_by_key


@pytest.mark.skip_browser("webkit")
def test_displays_correct_number_of_elements(app: Page):
    """Test that it renders correct number of camera_input elements."""
    camera_input_widgets = app.get_by_test_id("stCameraInput")
    expect(camera_input_widgets).to_have_count(2)


@pytest.mark.only_browser("chromium")
def test_captures_photo(app: Page):
    """Test camera_input captures photo when 'Take photo' button clicked."""
    # Wait for some timeout, until fake video stream available for camera_input
    app.wait_for_timeout(3000)
    take_photo_button = app.get_by_test_id("stCameraInputButton").first
    # Capture a photo
    take_photo_button.click()
    expect(app.get_by_test_id("stImage")).to_have_count(1)


@pytest.mark.only_browser("chromium")
def test_clear_photo(app: Page):
    """Test camera_input removes photo when 'Clear photo' button clicked."""
    # Wait for some timeout, until fake video stream available for camera_input
    app.wait_for_timeout(3000)
    take_photo_button = app.get_by_test_id("stCameraInputButton").first
    # Capture a photo
    take_photo_button.click()
    expect(app.get_by_test_id("stImage")).to_have_count(1)
    remove_photo_button = app.get_by_text("Clear photo").first
    remove_photo_button.click()
    expect(app.get_by_test_id("stImage")).to_have_count(0)


@pytest.mark.skip_browser("webkit")
def test_shows_disabled_widget_correctly(
    themed_app: Page,
    assert_snapshot: ImageCompareFunction,
):
    """Test that it renders disabled camera_input widget correctly."""
    camera_input_widgets = themed_app.get_by_test_id("stCameraInput")
    expect(camera_input_widgets).to_have_count(2)
    disabled_camera_input = camera_input_widgets.nth(1)
    assert_snapshot(disabled_camera_input, name="st_camera_input-disabled")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stCameraInput")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "camera_input_1")).to_be_visible()


================================================
File: /e2e_playwright/st_caption.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

# keep the sidebar collapsed by default to prevent render flakiness
st.set_page_config(initial_sidebar_state="collapsed")
sidebar_markdown = """# I am a header

## I am a subheader

### I am a subsubheader

I am some body text

[I am a link](https://google.com)

Foo `bar` baz"""

with st.sidebar:
    st.caption(sidebar_markdown)

st.caption("This is a caption!")
st.caption(
    "This is a caption that contains <div>html</div> inside it!", unsafe_allow_html=True
)
st.caption("This is a caption with a help tooltip", help="This is some help tooltip!")

st.caption(
    """:material/chevron_right:  This is a caption that contains a bunch of interesting markdown:

# heading 1

## heading 2

### heading 3

#### heading 4

##### heading 5

###### heading 6

 * unordered list item 1
 * unordered list item 2
 * unordered list item 3

 1. ordered list item 1
 1. ordered list item 2
 1. ordered list item 3

 This is a *caption* that contains **markdown inside it**!

 This line contains <div>html</div>!
"""
)


================================================
File: /e2e_playwright/st_caption_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import expand_sidebar, expect_help_tooltip


def test_correct_number_of_elements(app: Page):
    caption_containers = app.get_by_test_id("stCaptionContainer")
    expect(caption_containers).to_have_count(5)


def test_correct_content_in_caption(app: Page):
    """Check that the captions have the correct content and also use the correct
    markdown formatting."""
    caption_containers = app.get_by_test_id("stCaptionContainer")
    expect(caption_containers.nth(1)).to_have_text("This is a caption!")
    expect(caption_containers.nth(2)).to_have_text(
        "This is a caption that contains html inside it!"
    )
    expect(caption_containers.nth(3)).to_have_text(
        "This is a caption with a help tooltip"
    )


def test_help_tooltip_works(app: Page):
    """Test that the help tooltip is displayed on hover."""
    # The stMarkdown div is the outermost container that holds the caption and the
    # help tooltip:
    caption_with_help = app.get_by_test_id("stMarkdown").nth(3)
    expect_help_tooltip(app, caption_with_help, "This is some help tooltip!")


def test_match_snapshot_for_caption_with_html_and_unsafe_html_true(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the unsafe_html caption matches the snapshot."""
    # fetching the stMarkdown so that when we capture a snapshot, it contains
    # the tooltip
    caption_container = (
        app.get_by_test_id("stMarkdown")
        .filter(has=app.get_by_test_id("stCaptionContainer"))
        .nth(2)
    )
    assert_snapshot(caption_container, name="st_caption-with_html_and_unsafe_html_true")


def test_match_snapshot_for_caption_with_tooltip(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the caption with matches the snapshot. Also test dark-theme to make
    sure icon is visible."""
    caption_container = (
        themed_app.get_by_test_id("stElementContainer")
        .filter(has=themed_app.get_by_test_id("stCaptionContainer"))
        .nth(3)
    )
    assert_snapshot(caption_container, name="st_caption-with_tooltip")


def test_match_snapshot_for_mixed_markdown_content(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the big markdown caption with the mixed content matches the snapshot."""
    caption_container = (
        app.get_by_test_id("stElementContainer")
        .filter(has=app.get_by_test_id("stCaptionContainer"))
        .nth(4)
    )
    assert_snapshot(
        caption_container, name="st_caption-with_different_markdown_content"
    )


def test_match_snapshot_in_sidebar(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    sidebar = expand_sidebar(themed_app)
    caption_in_sidebar = sidebar.get_by_test_id("stCaptionContainer")
    assert_snapshot(caption_in_sidebar, name="st_caption-sidebar_caption")


================================================
File: /e2e_playwright/st_chat_input.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit import runtime

v1 = st.container().chat_input("Chat input 1 (inline)")
st.write("Chat input 1 (inline) - value:", v1)

col1, _ = st.columns(2)

v2 = col1.chat_input("Chat input 2 (in column, disabled)", disabled=True)
st.write("Chat input 2 (in column, disabled) - value:", v2)

if runtime.exists():

    def on_submit():
        st.text("chat input submitted")

    st.container().chat_input(
        "Chat input 3 (callback)", key="chat_input_3", on_submit=on_submit
    )
    st.write("Chat input 3 (callback) - value:", st.session_state.get("chat_input_3"))

v4 = st.chat_input("Chat input 4 (bottom, max_chars)", max_chars=200)
st.write("Chat input 4 (bottom, max_chars) - value:", v4)


================================================
File: /e2e_playwright/st_chat_input_file_uploader_regression.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time

import streamlit as st

if "messages" not in st.session_state:
    st.session_state.messages = []

# A count to record the index of dialog
if "count" not in st.session_state:
    st.session_state.count = 0

for message in st.session_state.messages:
    with st.chat_message(message["role"]):
        st.markdown(message["content"])

uploaded_files = st.sidebar.file_uploader(label="Upload", accept_multiple_files=True)

for file in uploaded_files:
    st.sidebar.write(file.name)

if prompt := st.chat_input("What is up?"):
    # Display user message in chat message container
    with st.chat_message("user"):
        st.markdown(prompt)
    # Add user message to chat history
    st.session_state.messages.append({"role": "user", "content": prompt})
    st.session_state.count += 1

    # Sleep one second here to simulate the process of assistant.
    time.sleep(1)
    with st.chat_message("assistant"):
        assistant = f"Good at {st.session_state.count}"
        st.markdown(assistant)
    # Add assistant message to chat history
    st.session_state.messages.append({"role": "assistant", "content": assistant})


================================================
File: /e2e_playwright/st_chat_input_file_uploader_regression_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import wait_for_app_run


def test_regression_with_file_uploader_and_chat_input(app: Page):
    """Test issue described in https://github.com/streamlit/streamlit/issues/7556."""
    chat_input_element = app.get_by_test_id("stChatInputTextArea").first
    chat_input_element.type("Hello world!")
    chat_input_element.press("Enter")
    wait_for_app_run(app)
    last_chat_message = app.get_by_test_id("stChatMessageContent").last
    expect(last_chat_message).to_have_text("Good at 1", use_inner_text=True)


================================================
File: /e2e_playwright/st_chat_input_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, rerun_app, wait_for_app_loaded
from e2e_playwright.shared.app_utils import check_top_level_class, get_element_by_key


def test_chat_input_rendering(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that the st.chat_input widgets are correctly rendered via screenshot matching."""
    chat_input_widgets = app.get_by_test_id("stChatInput")
    expect(chat_input_widgets).to_have_count(4)

    assert_snapshot(chat_input_widgets.nth(0), name="st_chat_input-inline")
    assert_snapshot(chat_input_widgets.nth(1), name="st_chat_input-in_column_disabled")
    assert_snapshot(chat_input_widgets.nth(2), name="st_chat_input-callback")
    assert_snapshot(chat_input_widgets.nth(3), name="st_chat_input-bottom")


def test_max_characters_enforced(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the max_chars parameter is enforced."""
    long_text = (
        "Lorem ipsum dolor amet, consectetur adipiscing elit. Mauris tristique est at "
        "tincidunt pul vinar. Nam pulvinar neque sapien, eu pellentesque metus pellentesque "
        "at. Ut et dui molestie, iaculis magna sed. This text should not appear in the input."
    )
    chat_input = themed_app.get_by_test_id("stChatInput").nth(3)
    chat_input_area = chat_input.locator("textarea")

    chat_input_area.type(long_text)

    expected_text = (
        "Lorem ipsum dolor amet, consectetur adipiscing elit. Mauris tristique est at "
        "tincidunt pul vinar. Nam pulvinar neque sapien, eu pellentesque metus pellentesque "
        "at. Ut et dui molestie, iaculis magna se"
    )
    expect(chat_input_area).to_have_value(expected_text)
    assert_snapshot(chat_input, name="st_chat_input-max_chars")


def test_embedded_app_with_bottom_chat_input(
    page: Page, app_port: int, assert_snapshot: ImageCompareFunction
):
    """Test that an embedded app with bottom chat input renders correctly."""
    page.goto(f"http://localhost:{app_port}/?embed=true")
    wait_for_app_loaded(page, embedded=True)

    app_view_block = page.get_by_test_id("stMainBlockContainer")
    # Bottom padding should be 16px (1rem):
    expect(app_view_block).to_have_css("padding-bottom", "16px")
    bottom_block = page.get_by_test_id("stBottomBlockContainer")
    # Bottom padding should be 32px (2rem):
    expect(bottom_block).to_have_css("padding-bottom", "32px")
    # Top padding should be 16px (1rem):
    expect(bottom_block).to_have_css("padding-top", "16px")

    # There shouldn't be an iframe resizer anchor:
    expect(page.get_by_test_id("stAppIframeResizerAnchor")).to_be_hidden()
    # The scroll container should be switched to scroll to bottom:
    expect(page.get_by_test_id("stAppScrollToBottomContainer")).to_be_attached()

    assert_snapshot(
        page.get_by_test_id("stAppViewContainer"),
        name="st_chat_input-app_embedded_with_bottom",
    )


def test_app_with_bottom_chat_input(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that an app with bottom chat input renders correctly."""
    app_view_block = app.get_by_test_id("stMainBlockContainer")
    # Bottom padding should be 16px (1rem):
    expect(app_view_block).to_have_css("padding-bottom", "16px")

    bottom_block = app.get_by_test_id("stBottomBlockContainer")
    # Bottom padding should be 56px (3.5rem):
    expect(bottom_block).to_have_css("padding-bottom", "56px")
    # Top padding should be 16px (1rem):
    expect(bottom_block).to_have_css("padding-top", "16px")

    # There shouldn't be an iframe resizer anchor:
    expect(app.get_by_test_id("stAppIframeResizerAnchor")).to_be_hidden()
    # The scroll container should be switched to scroll to bottom:
    expect(app.get_by_test_id("stAppScrollToBottomContainer")).to_be_attached()

    assert_snapshot(app.get_by_test_id("stBottom"), name="st_chat_input-app_bottom")


def test_submit_hover_state_with_input_value(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test the submit button's hover state when input value is present."""
    chat_input = app.get_by_test_id("stChatInput").nth(3)
    chat_input_area = chat_input.locator("textarea")
    chat_input_area.type("Corgi")

    submit_button = chat_input.get_by_test_id("stChatInputSubmitButton")
    submit_button.hover()
    assert_snapshot(chat_input, name="st_chat_input-submit_hover")


def test_enter_submits_clears_input(app: Page):
    """Test that pressing Enter submits and clears the input."""
    markdown_output = app.get_by_test_id("stMarkdown").nth(3)
    expect(markdown_output).to_have_text(
        "Chat input 4 (bottom, max_chars) - value: None"
    )

    chat_input_area = app.get_by_test_id("stChatInputTextArea").nth(3)
    chat_input_area.type("Corgi")
    chat_input_area.press("Enter")
    expect(chat_input_area).to_have_value("")

    expect(markdown_output).to_have_text(
        "Chat input 4 (bottom, max_chars) - value: Corgi"
    )


def test_shift_enter_creates_new_line(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that Shift+Enter creates a new line."""
    chat_input = app.get_by_test_id("stChatInput").nth(3)
    chat_input_area = chat_input.locator("textarea")
    chat_input_area.fill("")  # Clear the input first
    chat_input_area.press("Shift+Enter")
    chat_input_area.type("New Line")
    assert_snapshot(chat_input, name="st_chat_input-shift_enter_new_line")


def test_click_button_to_submit_clears_input(app: Page):
    """Test that clicking the button submits and clears the input."""
    chat_input = app.get_by_test_id("stChatInput").nth(0)
    submit_button = chat_input.get_by_test_id("stChatInputSubmitButton")
    chat_input_area = chat_input.locator("textarea")

    chat_input_area.type("Corgi")
    submit_button.click()

    expect(chat_input_area).to_have_value("")

    markdown_output = app.get_by_test_id("stMarkdown").nth(0)
    expect(markdown_output).to_have_text("Chat input 1 (inline) - value: Corgi")


def test_chat_input_focus_state(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.chat_input renders the focus state correctly."""
    chat_input = themed_app.get_by_test_id("stChatInput").nth(3)
    chat_input_area = chat_input.locator("textarea")
    chat_input_area.click()
    expect(chat_input_area).to_be_focused()
    assert_snapshot(chat_input, name="st_chat_input-focused")


def test_grows_shrinks_input_text(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that input grows with long text and shrinks when text is deleted."""
    chat_input = app.get_by_test_id("stChatInput").nth(3)
    chat_input_area = chat_input.locator("textarea")
    chat_input_area.type(
        "Lorem ipsum dolor amet, consectetur adipiscing elit. "
        "Mauris tristique est at tincidunt pul vinar. Nam pulvinar neque sapien, "
        "eu pellentesque metus pellentesque at. Ut et dui molestie, iaculis magna."
    )
    assert_snapshot(chat_input, name="st_chat_input-grows")
    for _ in range(20):
        chat_input_area.press("Backspace", delay=10)
    assert_snapshot(chat_input, name="st_chat_input-shrinks")


def test_calls_callback_on_submit(app: Page):
    """Test that it correctly calls the callback on submit."""
    chat_input_area = app.get_by_test_id("stChatInputTextArea").nth(2)

    chat_input_area.type("hello world")
    chat_input_area.press("Enter")

    markdown_output = app.get_by_test_id("stMarkdown").nth(2)
    expect(app.get_by_test_id("stText").nth(0)).to_have_text(
        "chat input submitted",
        use_inner_text=True,
    )
    expect(markdown_output).to_have_text(
        "Chat input 3 (callback) - value: hello world",
        use_inner_text=True,
    )

    rerun_app(app)

    # Expect the callback to not be triggered:
    expect(app.get_by_test_id("stText")).not_to_be_attached()
    # And the session state value to be reset
    expect(markdown_output).to_have_text(
        "Chat input 3 (callback) - value: None",
        use_inner_text=True,
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stChatInput")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "chat_input_3")).to_be_visible()


================================================
File: /e2e_playwright/st_chat_message.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from pathlib import Path

import numpy as np
import pandas as pd
from PIL import Image

import streamlit as st

TEST_ASSETS_DIR = Path(__file__).parent / "test_assets"
np.random.seed(0)

# Generate a random dataframe
df = pd.DataFrame(
    np.random.randn(5, 5),
    columns=("col_%d" % i for i in range(5)),
)

with st.chat_message("user"):
    st.write("Hello…")

with st.chat_message("assistant"):
    st.write(
        """
Hello, here is a code snippet:

```python
import streamlit as st
with st.chat_message("assistant"):
     st.write("Hello, here is a code snippet...")
```
"""
    )

with st.chat_message("user", avatar="🧑"):
    st.write(
        """
Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris tristique est
at tincidunt pul vinar. Nam pulvinar neque sapien, eu pellentesque metus pellentesque
at. Ut et dui molestie, iaculis magna sed.
"""
    )

with st.chat_message("dog", avatar="https://static.streamlit.io/examples/dog.jpg"):
    st.write("Woof woof! I'm a dog and I like charts:")
    st.line_chart(df, use_container_width=True)

cat = st.chat_message("cat", avatar="https://static.streamlit.io/examples/cat.jpg")
cat.write("I'm a cat and I like this dataset:")
cat.dataframe(df, use_container_width=True)
cat.text_input("What's your name?")


with st.chat_message("Bot"):
    with st.expander("See more", expanded=True):
        st.write("Lorem ipsum dolor sit amet")

st.chat_message("human")


image1 = Image.new("RGB", (10, 255), "red")
st.chat_message("user", avatar=image1).write("Red local image")

image2 = Image.new("RGB", (10, 10), "blue")
st.chat_message("assistant", avatar=image2).write("Blue local image")
st.chat_message("assistant", avatar=image2).write(
    "Another message with the same blue avatar."
)

# Test avatar using local image
CAT_IMAGE_PATH = TEST_ASSETS_DIR / "cat.jpg"
st.chat_message("user", avatar=str(CAT_IMAGE_PATH)).write("Cat avatar using str path")
st.chat_message("user", avatar=CAT_IMAGE_PATH).write("Cat avatar using Path")

with st.chat_message("user", avatar=":material/airline_seat_recline_extra:"):
    st.write("Hello from USER, non-emoji icon.")

with st.chat_message("AI", avatar=":material/photo_album:"):
    st.write("Hello from AI, non-emoji icon.")

query = "This is a hardcoded user message"
sources = "example sources"
llm_response = "some response"

past_messages = st.empty()

if "messages" not in st.session_state:
    st.session_state.messages = []

with past_messages.container():
    for message in st.session_state.messages:
        with st.chat_message(message["role"]):
            st.markdown(message["content"])
            if message["role"] != "user":
                with st.expander("See sources"):
                    st.markdown(message["sources"])

with st.chat_message("user"):
    st.markdown(query)

user_message = {"role": "user", "content": query, "sources": ""}
st.session_state.messages.append(user_message)

with st.chat_message("assistant"):
    displayed_response = st.empty()
    with displayed_response.container():
        st.markdown(llm_response)
        with st.expander("See sources"):
            st.markdown(sources)

assistant_message = {"role": "assistant", "content": llm_response, "sources": sources}
st.session_state.messages.append(assistant_message)


================================================
File: /e2e_playwright/st_chat_message_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, rerun_app
from e2e_playwright.shared.app_utils import check_top_level_class


def test_renders_chat_messages_correctly_1(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test if the chat messages render correctly"""
    # Wait a bit more to allow all images to load:
    chat_message_elements = themed_app.get_by_test_id("stChatMessage")
    expect(chat_message_elements).to_have_count(16)

    # rerun to populate session state chat message
    rerun_app(themed_app)

    expect(chat_message_elements).to_have_count(18)
    for i, element in enumerate(chat_message_elements.all()):
        element.scroll_into_view_if_needed()
        expect(element).to_be_in_viewport()
        # Wait a bit more to allow the avatar images to load:
        themed_app.wait_for_timeout(100)
        assert_snapshot(element, name=f"st_chat_message-{i}")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stChatMessage")


================================================
File: /e2e_playwright/st_checkbox.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit import runtime

leading_indent_code_tooltip = """
Code:

    This
    is
    a
    code
    block!"""
i1 = st.checkbox("checkbox 1 (True)", True, help=leading_indent_code_tooltip)
st.write("checkbox 1 - value:", i1)

i2 = st.checkbox("checkbox 2 (False)", False)
st.write("checkbox 2 - value:", i2)

i3 = st.checkbox(
    "checkbox 3: This is a really really really really long label that should wrap eventually if we keep addding more text to it"
)
st.write("checkbox 3 - value:", i3)

if runtime.exists():

    def on_change():
        st.session_state.checkbox_clicked = True

    st.checkbox("checkbox 4 (with callback)", key="checkbox4", on_change=on_change)
    st.write("checkbox 4 - value:", st.session_state.checkbox4)
    st.write("checkbox 4 - clicked:", "checkbox_clicked" in st.session_state)

i5 = st.checkbox("checkbox 5 (False, disabled)", disabled=True)
st.write("checkbox 5 - value:", i5)

i6 = st.checkbox("checkbox 6 (True, disabled)", value=True, disabled=True)
st.write("checkbox 6 - value:", i6)

i7 = st.checkbox("checkbox 7 (label hidden)", label_visibility="hidden")
st.write("checkbox 7 - value:", i7)

i8 = st.checkbox("checkbox 8 (label collapsed)", label_visibility="collapsed")
st.write("checkbox 8 - value:", i8)

with st.expander("Grouped checkboxes", expanded=True):
    st.checkbox("checkbox group - 1")
    st.checkbox("checkbox group - 2")
    st.checkbox("checkbox group - 3")
    st.text("A non-checkbox element")


================================================
File: /e2e_playwright/st_checkbox_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    expect_help_tooltip,
    get_element_by_key,
    get_expander,
)

CHECKBOX_ELEMENTS = 11


def test_checkbox_widget_display(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.checkbox renders correctly."""
    checkbox_elements = themed_app.get_by_test_id("stCheckbox")
    expect(checkbox_elements).to_have_count(CHECKBOX_ELEMENTS)

    assert_snapshot(checkbox_elements.nth(0), name="st_checkbox-true")
    assert_snapshot(checkbox_elements.nth(1), name="st_checkbox-false")
    assert_snapshot(checkbox_elements.nth(2), name="st_checkbox-long_label")
    assert_snapshot(checkbox_elements.nth(3), name="st_checkbox-callback")
    assert_snapshot(checkbox_elements.nth(4), name="st_checkbox-false_disabled")
    assert_snapshot(checkbox_elements.nth(5), name="st_checkbox-true_disabled")
    assert_snapshot(checkbox_elements.nth(6), name="st_checkbox-hidden_label")
    assert_snapshot(checkbox_elements.nth(7), name="st_checkbox-collapsed_label")


def test_help_tooltip_works(app: Page):
    leading_indent_code_tooltip = """
    Code:

        This
        is
        a
        code
        block!"""
    element_with_help = app.get_by_test_id("stCheckbox").nth(0)
    expect_help_tooltip(app, element_with_help, leading_indent_code_tooltip)


def test_checkbox_initial_values(app: Page):
    """Test that st.checkbox has the correct initial values."""
    markdown_elements = app.get_by_test_id("stMarkdown")
    expect(markdown_elements).to_have_count(9)

    expected = [
        "checkbox 1 - value: True",
        "checkbox 2 - value: False",
        "checkbox 3 - value: False",
        "checkbox 4 - value: False",
        "checkbox 4 - clicked: False",
        "checkbox 5 - value: False",
        "checkbox 6 - value: True",
        "checkbox 7 - value: False",
        "checkbox 8 - value: False",
    ]

    for markdown_element, expected_text in zip(markdown_elements.all(), expected):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_checkbox_values_on_click(app: Page):
    """Test that st.checkbox updates values correctly when user clicks."""
    checkbox_elements = app.get_by_test_id("stCheckbox")
    expect(checkbox_elements).to_have_count(CHECKBOX_ELEMENTS)

    for checkbox_element in checkbox_elements.all():
        # Not sure if this is needed, but somehow it is slightly
        # flaky with the last checkbox without it.
        # It seems that it sometimes fails to click,
        # and in these cases the checkbox was not scrolled into view.
        # So, maybe thats the reason why it fails to click it.
        # But this is just a guess.
        checkbox_element.scroll_into_view_if_needed()
        checkbox_element.locator("label").first.click(delay=50, force=True)
        wait_for_app_run(app)

    markdown_elements = app.get_by_test_id("stMarkdown")
    expected = [
        "checkbox 1 - value: False",
        "checkbox 2 - value: True",
        "checkbox 3 - value: True",
        "checkbox 4 - value: True",
        "checkbox 4 - clicked: True",
        "checkbox 5 - value: False",
        "checkbox 6 - value: True",
        "checkbox 7 - value: True",
        "checkbox 8 - value: True",
    ]

    for markdown_element, expected_text in zip(markdown_elements.all(), expected):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_grouped_checkboxes_height(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that grouped checkboxes have the correct height."""

    expander_details = get_expander(app, "Grouped checkboxes").get_by_test_id(
        "stExpanderDetails"
    )
    expect(expander_details.get_by_test_id("stCheckbox")).to_have_count(3)
    assert_snapshot(expander_details, name="st_checkbox-grouped_styling")
    expect(expander_details.get_by_test_id("stCheckbox").nth(0)).to_have_css(
        "height", "24px"
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stCheckbox")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "checkbox4")).to_be_visible()


================================================
File: /e2e_playwright/st_code.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.code("# This code is awesome!")

st.code("")

code = """
def hello():
    print("Hello, Streamlit!")
"""
st.code(code, language="python")

st.code(code, language="python", line_numbers=True)

st.code("PLAIN TEXT", language=None, line_numbers=True)

st.markdown("```python\n" + code + "\n```")

st.code(
    """
--- main
+++ develop
@@ -52,21 +52,19 @@
     "title": "Democracy index",
     "yAxis": {
         "max": 10,
-        "min": -10,
-        "facetDomain": "shared"
+        "min": -10
     },
""",
    language="diff",
)

with st.expander("`st.code` usage", expanded=True):
    st.code(code, language="python")
    st.code(code, language="python")

with st.expander("`st.markdown` code usage", expanded=True):
    st.markdown("```python\n" + code + "\n```")
    st.markdown("```python\n" + code + "\n```")
    st.markdown("[a link with `code`](https://streamlit.io)")


long_string = "Testing line wrapping: " + "foo bar baz " * 10 + "{EOL}"

wide_code_block = f"""
def foo():
    bar(f"{long_string}")
    return 123
"""

st.code(wide_code_block, wrap_lines=False)
st.code(wide_code_block, wrap_lines=False, line_numbers=True)
st.code(wide_code_block, wrap_lines=True)
st.code(wide_code_block, wrap_lines=True, line_numbers=True)


long_code = """
print("Hello!")
print("This is a tall code block")
print("With many lines")
print("That will scroll")
print("Hello!")
print("This is a tall code block")
print("With many lines")
print("That will scroll")
print("Hello!")
print("This is a tall code block")
print("With many lines")
print("That will scroll")
print("Hello!")
print("This is a tall code block")
print("With many lines")
print("That will scroll")
print("Hello!")
print("This is a tall code block")
print("With many lines")
print("That will scroll")
"""

st.code(long_code, height=200)
st.code(code, height=200)


================================================
File: /e2e_playwright/st_code_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class


def test_code_display(app: Page):
    """Test that st.code displays a code block."""
    code_element = app.get_by_test_id("stCode").first
    expect(code_element).to_contain_text("This code is awesome!")


def test_syntax_highlighting(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that the copy-to-clipboard action appears on hover."""
    first_code_element = themed_app.get_by_test_id("stCode").first
    first_code_element.hover()
    assert_snapshot(first_code_element, name="st_code-hover_copy")


def test_code_blocks_render_correctly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the code blocks render as expected via screenshot matching."""
    code_blocks = themed_app.get_by_test_id("stCode")
    expect(code_blocks).to_have_count(17)
    # The code blocks might require a bit more time for rendering, so wait until
    # the text is truly visible. Otherwise we might get blank code blocks in the
    # screenshots.
    foo_func_count = 5
    themed_app.wait_for_function(
        f"()=>document.body.textContent.split('def foo()').length === {foo_func_count}"
    )

    assert_snapshot(code_blocks.nth(0), name="st_code-auto_lang")
    assert_snapshot(code_blocks.nth(1), name="st_code-empty")
    assert_snapshot(code_blocks.nth(2), name="st_code-python_lang")
    assert_snapshot(code_blocks.nth(3), name="st_code-line_numbers")
    assert_snapshot(code_blocks.nth(4), name="st_code-no_lang")
    assert_snapshot(code_blocks.nth(5), name="st_markdown-code_block")
    assert_snapshot(code_blocks.nth(6), name="st_code-diff_lang")

    # Test long lines draw as expected.
    assert_snapshot(code_blocks.nth(11), name="st_code-long-no_wrap")
    assert_snapshot(code_blocks.nth(12), name="st_code-long-numbers-no_wrap")
    assert_snapshot(code_blocks.nth(13), name="st_code-long-wrap")
    assert_snapshot(code_blocks.nth(14), name="st_code-long-numbers-wrap")

    # Test height prop
    assert_snapshot(code_blocks.nth(15), name="st_code-height-long-code")
    assert_snapshot(code_blocks.nth(16), name="st_code-height-short-code")


def test_correct_bottom_spacing_for_code_blocks(app: Page):
    """Test that the code blocks have the correct bottom spacing."""

    # The first code block should have no bottom margin:
    expect(
        app.get_by_test_id("stExpander").nth(0).get_by_test_id("stCode").first
    ).to_have_css("margin-bottom", "0px")
    # While the codeblock used inside markdown should have a bottom margin to imitate the gap:
    expect(
        app.get_by_test_id("stExpander").nth(1).get_by_test_id("stMarkdownPre").first
    ).to_have_css("margin-bottom", "16px")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stCode")


def test_line_wrap(app: Page):
    """Test that line-wrapping works correctly."""

    code_blocks = app.get_by_test_id("stCode")

    # When line-wrap is off, the "EOL" token should not be visible.

    curr_block = code_blocks.nth(11)
    curr_block.scroll_into_view_if_needed()
    expect(curr_block.get_by_text("EOL")).not_to_be_in_viewport()

    curr_block = code_blocks.nth(12)
    curr_block.scroll_into_view_if_needed()
    expect(curr_block.get_by_text("EOL")).not_to_be_in_viewport()

    # When line-wrap is on, the "EOL" token should be visible.

    curr_block = code_blocks.nth(13)
    curr_block.scroll_into_view_if_needed()
    expect(curr_block.get_by_text("EOL")).to_be_in_viewport()

    curr_block = code_blocks.nth(14)
    curr_block.scroll_into_view_if_needed()
    expect(curr_block.get_by_text("EOL")).to_be_in_viewport()


def test_height_parameter(app: Page):
    """Test that the height prop works correctly."""
    code_blocks = app.get_by_test_id("stCode")

    # Test long code with fixed height
    curr_block = code_blocks.nth(15)
    curr_block.scroll_into_view_if_needed()
    expect(curr_block.locator("pre")).to_have_css("height", "200px")
    # The "EOL" token at the end of the code block should not be visible.
    expect(curr_block.get_by_text("EOL")).not_to_be_in_viewport()

    # Test short code with fixed height
    curr_block = code_blocks.nth(16)
    curr_block.scroll_into_view_if_needed()
    expect(curr_block.locator("pre")).to_have_css("height", "200px")


================================================
File: /e2e_playwright/st_color_picker.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st


def callback():
    st.write("Hello world")


c1 = st.color_picker("Default Color", on_change=callback, key="color_picker_1")
st.write("Color 1", c1)

c2 = st.color_picker("New Color", "#EB144C", help="help string")
st.write("Color 2", c2)

c3 = st.color_picker("Disabled", disabled=True)
st.write("Color 3", c3)

c4 = st.color_picker("Hidden Label", label_visibility="hidden")
st.write("Color 4", c4)

c5 = st.color_picker("Collapsed Label", label_visibility="collapsed")
st.write("Color 5", c5)

with st.form(key="my_form", clear_on_submit=True):
    selection = st.color_picker("Form Color Picker", key="color_picker_form")
    st.form_submit_button("Submit")

st.write("color_picker-in-form selection:", str(selection))
if "color_picker_form" in st.session_state:
    st.write(
        "color_picker-in-form selection in session state:",
        str(st.session_state.color_picker_form),
    )


@st.fragment
def test_fragment():
    selection = st.color_picker("Fragment Color Picker")
    st.write("color_picker-in-fragment selection:", str(selection))


test_fragment()

if "runs" not in st.session_state:
    st.session_state.runs = 0
st.session_state.runs += 1
st.write("Runs:", st.session_state.runs)


================================================
File: /e2e_playwright/st_color_picker_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_form_button,
    expect_help_tooltip,
    get_element_by_key,
)


def test_color_picker_widget_display(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.color_picker renders correctly."""
    color_pickers = themed_app.get_by_test_id("stColorPicker")
    expect(color_pickers).to_have_count(7)

    for i in range(5):
        assert_snapshot(color_pickers.nth(i), name=f"st_color_picker-{i}")


def test_help_tooltip_works(app: Page):
    element_with_help = app.get_by_test_id("stColorPicker").nth(1)
    expect_help_tooltip(app, element_with_help, "help string")


# The coordinates (0, 0) for the click action behaves differently across firefox.
@pytest.mark.skip_browser("firefox")
def test_clicking_color_on_color_picker_works(
    app: Page, assert_snapshot: ImageCompareFunction
):
    color_pickers = app.get_by_test_id("stColorPicker")
    color_pickers.nth(0).get_by_test_id("stColorPickerBlock").click()

    app.get_by_test_id("stColorPickerPopover").click(position={"x": 0, "y": 0})

    # click outside of color picker
    app.get_by_text("Default Color").click()
    wait_for_app_run(app)
    expect(app.get_by_text("#ffffff")).to_be_visible()
    assert_snapshot(color_pickers.nth(0), name="st_color_picker-clicked_new_color")


def test_typing_new_hex_color_on_color_picker_works_with_callback(
    app: Page, assert_snapshot: ImageCompareFunction
):
    expect(app.get_by_text("Hello world")).to_have_count(0)
    color_pickers = app.get_by_test_id("stColorPicker")
    color_pickers.nth(0).get_by_test_id("stColorPickerBlock").click()

    text_input = app.get_by_test_id("stColorPickerPopover").locator("input")
    text_input.fill("#ffffff")

    # click outside of color picker
    app.get_by_text("Default Color").click()
    wait_for_app_run(app)

    # callback writes "Hello world"
    expect(app.get_by_text("Hello world")).to_be_visible()
    expect(app.get_by_text("#ffffff")).to_be_visible()
    assert_snapshot(color_pickers.nth(0), name="st_color_picker-typed_new_hex_color")


def test_typing_new_RGB_color_on_color_picker_works(
    app: Page, assert_snapshot: ImageCompareFunction
):
    color_pickers = app.get_by_test_id("stColorPicker")
    color_pickers.nth(0).get_by_test_id("stColorPickerBlock").click()

    color_picker_popover = app.get_by_test_id("stColorPickerPopover")

    # click button to swap color picker mode to RGB
    color_picker_popover.locator("svg").click()

    rgb_text_inputs = app.get_by_test_id("stColorPickerPopover").locator("input")
    rgb_text_inputs.nth(0).type("255")
    rgb_text_inputs.nth(1).type("255")
    rgb_text_inputs.nth(2).type("255")

    # click outside of color picker
    app.get_by_text("Default Color").click()
    wait_for_app_run(app)
    expect(app.get_by_text("#ffffff")).to_be_visible()
    assert_snapshot(color_pickers.nth(0), name="st_color_picker-typed_new_rgb_color")


def test_typing_new_HSL_color_on_color_picker_works(
    app: Page, assert_snapshot: ImageCompareFunction
):
    color_pickers = app.get_by_test_id("stColorPicker")
    color_pickers.nth(0).get_by_test_id("stColorPickerBlock").click()

    color_picker_popover = app.get_by_test_id("stColorPickerPopover")

    # click button to swap color picker mode to HSL
    color_picker_input_button = color_picker_popover.locator("svg")
    color_picker_input_button.click()
    color_picker_input_button.click()

    hsl_text_inputs = app.get_by_test_id("stColorPickerPopover").locator("input")
    hsl_text_inputs.nth(0).fill("0%")
    hsl_text_inputs.nth(1).fill("0%")
    hsl_text_inputs.nth(2).fill("100%")

    # click outside of color picker
    app.get_by_text("Default Color").click()
    wait_for_app_run(app)
    expect(app.get_by_text("#ffffff")).to_be_visible()
    assert_snapshot(color_pickers.nth(0), name="st_color_picker-typed_new_hsl_color")


def test_in_form_selection_and_session_state(app: Page):
    expect(app.get_by_text("color_picker-in-form selection: #000000")).to_be_visible()
    expect(
        app.get_by_text("color_picker-in-form selection in session state: #000000")
    ).to_be_visible()

    app.get_by_test_id("stColorPicker").nth(5).get_by_test_id(
        "stColorPickerBlock"
    ).click()

    text_input = app.get_by_test_id("stColorPickerPopover").locator("input")
    text_input.fill("#ffffff")

    # click outside of color picker
    app.get_by_text("Default Color").click()
    wait_for_app_run(app)

    click_form_button(app, "Submit")

    expect(app.get_by_text("color_picker-in-form selection: #ffffff")).to_be_visible()
    expect(
        app.get_by_text("color_picker-in-form selection in session state: #ffffff")
    ).to_be_visible()


def test_color_picker_in_fragment(app: Page):
    expect(
        app.get_by_text("color_picker-in-fragment selection: #000000")
    ).to_be_visible()

    app.get_by_test_id("stColorPicker").nth(6).get_by_test_id(
        "stColorPickerBlock"
    ).click()
    text_input = app.get_by_test_id("stColorPickerPopover").locator("input")
    text_input.fill("#ffffff")

    # click outside of color picker
    app.get_by_text("Default Color").click()

    wait_for_app_run(app)

    expect(
        app.get_by_text("color_picker-in-fragment selection: #ffffff")
    ).to_be_visible()
    expect(app.get_by_text("Runs: 1")).to_be_visible()


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stColorPicker")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "color_picker_1")).to_be_visible()


================================================
File: /e2e_playwright/st_columns.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import numpy as np

import streamlit as st

LOREM_IPSUM = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."

BLACK_IMG = np.repeat(0, 601350).reshape(633, 950)

# Basic columns:
c1, c2, c3 = st.columns(3)

c1.write(LOREM_IPSUM)
c2.write(LOREM_IPSUM)
c3.write(LOREM_IPSUM)

# Only fill in the last column and keep the others empty
c1, c2, c3 = st.columns(3)
c3.write(LOREM_IPSUM)

col1, col2 = st.columns(2, border=True)
with col1:
    st.metric("Temperature", "72°F", "2%")
with col2:
    st.metric("Pressure", "30.2 in", "-4%")
    st.slider("Slider", 0, 100, 50)

with st.expander("Variable-width columns (relative numbers)", expanded=True):
    for c in st.columns([0.6, 0.3, 0.1]):
        c.image(BLACK_IMG)

with st.expander("Variable-width columns (absolute numbers)", expanded=True):
    for c in st.columns((1, 2, 3, 4)):
        c.image(BLACK_IMG)

# Various column gaps
with st.expander("Column gap small", expanded=True):
    c4, c5, c6 = st.columns(3, gap="small")
    c4.image(BLACK_IMG)
    c5.image(BLACK_IMG)
    c6.image(BLACK_IMG)

with st.expander("Column gap medium", expanded=True):
    c7, c8, c9 = st.columns(3, gap="medium")
    c7.image(BLACK_IMG)
    c8.image(BLACK_IMG)
    c9.image(BLACK_IMG)

with st.expander("Column gap large", expanded=True):
    c10, c11, c12 = st.columns(3, gap="large")
    c10.image(BLACK_IMG)
    c11.image(BLACK_IMG)
    c12.image(BLACK_IMG)

with st.expander("Nested columns - one level", expanded=True):
    col1, col2 = st.columns(2)
    with col1:
        subcol1, subcol2 = st.columns(2)
        subcol1.write(LOREM_IPSUM)
        subcol2.write(LOREM_IPSUM)
        st.write("")
        st.write(LOREM_IPSUM)

    with col2:
        subcol1, subcol2 = st.columns(2)
        subcol1.write(LOREM_IPSUM)
        subcol2.write(LOREM_IPSUM)
        st.write("")
        subcol1, subcol2 = st.columns(2)
        subcol1.write(LOREM_IPSUM)
        subcol2.write(LOREM_IPSUM)

with st.expander("Vertical alignment - top", expanded=True):
    col1, col2, col3 = st.columns(3, vertical_alignment="top")
    col1.text_input("Text input (top)")
    col2.button("Button (top)", use_container_width=True)
    col3.checkbox("Checkbox (top)")

with st.expander("Vertical alignment - center", expanded=True):
    col1, col2, col3 = st.columns(3, vertical_alignment="center")
    col1.text_input("Text input (center)")
    col2.button("Button (center)", use_container_width=True)
    col3.checkbox("Checkbox (center)")

with st.expander("Vertical alignment - bottom", expanded=True):
    col1, col2, col3 = st.columns(3, vertical_alignment="bottom")
    col1.text_input("Text input (bottom)")
    col2.button("Button (bottom)", use_container_width=True)
    col3.checkbox("Checkbox (bottom)")

if st.button("Nested columns - two levels (raises exception)"):
    col1, col2 = st.columns(2)
    with col1:
        subcol1, subcol2 = st.columns(2)
        with subcol1:
            subcol1.write(LOREM_IPSUM)
            subsubcol1, subsubcol2 = st.columns(2)
            subsubcol1.write(LOREM_IPSUM)
            subsubcol2.write(LOREM_IPSUM)
        subcol2.write(LOREM_IPSUM)
        st.write(LOREM_IPSUM)

if st.button("Nested columns - in sidebar (raises exception)"):
    with st.sidebar:
        col1, col2 = st.columns(2)
        col1.text_input("Text input 1")
        col2.text_input("Text input 2")
        col3, col4 = col1.columns(2)
        col3.text_input("Text input 3")
        col4.text_input("Text input 4")
        st.text_input("Text input 5")


================================================
File: /e2e_playwright/st_columns_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import click_button, expect_exception, get_expander


def _get_basic_column_container(
    app: Page,
):
    column_container = app.get_by_test_id("stHorizontalBlock").nth(0)
    expect(column_container).to_be_visible()
    return column_container


def test_show_columns_horizontally_when_viewport_allows(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """shows columns horizontally when viewport > 640"""
    app.set_viewport_size({"width": 641, "height": 800})
    column_container = _get_basic_column_container(app)
    assert_snapshot(
        column_container.nth(0), name="st_columns-responsive_layout_horizontal"
    )


def test_show_columns_vertically_when_viewport_requires(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """stacks columns vertically when viewport <= 640"""
    app.set_viewport_size({"width": 640, "height": 800})
    column_container = _get_basic_column_container(app)
    assert_snapshot(column_container, name="st_columns-responsive_layout_vertical")


def test_columns_always_take_up_space(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that columns still takes up space with no elements present"""
    column_element = app.get_by_test_id("stHorizontalBlock").nth(1)
    assert_snapshot(column_element, name="st_columns-with_empty_columns")


def test_columns_with_border(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that columns with border are correctly displayed"""
    column_element = app.get_by_test_id("stHorizontalBlock").nth(2)
    assert_snapshot(column_element, name="st_columns-with_border")


def test_column_gap_small_is_correctly_applied(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the small column gap is correctly applied."""
    column_gap_small = (
        get_expander(app, "Column gap small").get_by_test_id("stHorizontalBlock").nth(0)
    )
    # We use regex here since some browsers may resolve this to two numbers:
    expect(column_gap_small).to_have_css("gap", re.compile("16px"))
    column_gap_small.scroll_into_view_if_needed()
    assert_snapshot(column_gap_small, name="st_columns-column_gap_small")


def test_column_gap_medium_is_correctly_applied(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the medium column gap is correctly applied."""
    column_gap_medium = (
        get_expander(app, "Column gap medium")
        .get_by_test_id("stHorizontalBlock")
        .nth(0)
    )
    # We use regex here since some browsers may resolve this to two numbers:
    expect(column_gap_medium).to_have_css("gap", re.compile("32px"))
    column_gap_medium.scroll_into_view_if_needed()
    assert_snapshot(column_gap_medium, name="st_columns-column_gap_medium")


def test_column_gap_large_is_correctly_applied(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the large column gap is correctly applied."""
    column_gap_large = (
        get_expander(app, "Column gap large").get_by_test_id("stHorizontalBlock").nth(0)
    )
    # We use regex here since some browsers may resolve this to two numbers:
    expect(column_gap_large).to_have_css("gap", re.compile("64px"))
    column_gap_large.scroll_into_view_if_needed()
    assert_snapshot(column_gap_large, name="st_columns-column_gap_large")


def test_one_level_nesting_works_correctly(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that its possible to nest columns for one level."""
    nested_columns = (
        get_expander(app, "Nested columns - one level")
        .get_by_test_id("stHorizontalBlock")
        .nth(0)
    )
    assert_snapshot(nested_columns, name="st_columns-nested_one_level")


def test_column_variable_relative_width(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that a variable relative width works correctly."""
    column_gap_small = (
        get_expander(app, "Variable-width columns (relative numbers)")
        .get_by_test_id("stHorizontalBlock")
        .nth(0)
    )
    assert_snapshot(column_gap_small, name="st_columns-variable_width_relative")


def test_column_variable_absolute_width(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that a variable absolute width works correctly."""
    column_gap_small = (
        get_expander(app, "Variable-width columns (absolute numbers)")
        .get_by_test_id("stHorizontalBlock")
        .nth(0)
    )
    assert_snapshot(column_gap_small, name="st_columns-variable_width_absolute")


def test_column_vertical_alignment_top(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that vertical alignment top works correctly."""
    column_gap_small = (
        get_expander(app, "Vertical alignment - top")
        .get_by_test_id("stHorizontalBlock")
        .nth(0)
    )
    assert_snapshot(
        column_gap_small,
        name="st_columns-vertical_alignment_top",
    )


def test_column_vertical_alignment_center(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that vertical alignment center works correctly."""
    column_gap_small = (
        get_expander(app, "Vertical alignment - center")
        .get_by_test_id("stHorizontalBlock")
        .nth(0)
    )
    assert_snapshot(
        column_gap_small,
        name="st_columns-vertical_alignment_center",
    )


def test_column_vertical_alignment_bottom(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that vertical alignment center works correctly."""
    column_gap_small = (
        get_expander(app, "Vertical alignment - bottom")
        .get_by_test_id("stHorizontalBlock")
        .nth(0)
    )
    assert_snapshot(
        column_gap_small,
        name="st_columns-vertical_alignment_bottom",
    )


def test_two_level_nested_columns_shows_exception(app: Page):
    """Shows exception when trying to nest columns more than one level deep."""

    click_button(app, "Nested columns - two levels (raises exception)")
    expect_exception(
        app,
        re.compile(
            "Columns can only be placed inside other columns up to one level of nesting."
        ),
    )


def test_nested_columns_in_sidebar_shows_exception(app: Page):
    """Shows exception when trying to nest columns in the sidebar."""

    click_button(app, "Nested columns - in sidebar (raises exception)")
    expect_exception(
        app,
        re.compile(
            "Columns cannot be placed inside other columns in the sidebar. This is only possible in the main area of the app."
        ),
    )


================================================
File: /e2e_playwright/st_components_v1.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
import streamlit.components.v1 as components

html = r"<h1>Hello, Streamlit!</h1>"
components.html(html, width=200, height=500, scrolling=False)

src = "http://not.a.real.url"
components.iframe(src, width=200, height=500, scrolling=True)

# Set a query parameter to ensure that it doesn't affect the path of the custom component,
# since that would trigger a reload if the query param changes
st.query_params["hello"] = "world"

url = "http://not.a.real.url"
test_component = components.declare_component("test_component", url=url)

test_component(key="component_1")


================================================
File: /e2e_playwright/st_components_v1_import_legacy_file.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# PLEASE DO NOT ADD MORE IMPORTS HERE OR MOVE THE CODE TO ANOTHER FILE.
# This file relies on a clean import to make sure the functionality is not made available transiently.
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

from streamlit.components.v1 import components

components.declare_component
components.CustomComponent


================================================
File: /e2e_playwright/st_components_v1_import_legacy_file_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect


def test_imports_dont_throw(app: Page):
    expect(app.get_by_test_id("stException")).not_to_be_visible()


================================================
File: /e2e_playwright/st_components_v1_import_via_st.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# PLEASE DO NOT ADD MORE IMPORTS HERE OR MOVE THE CODE TO ANOTHER FILE.
# This file relies on a clean import to make sure the functionality is not made available transiently.
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

import streamlit as st

st.components.v1.html("<div>This import and usage worked!</div>")
st.write(str(st.components.v1.iframe))
st.write(str(st.components.v1.declare_component))


================================================
File: /e2e_playwright/st_components_v1_import_via_st_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from playwright.sync_api import Page, expect

from e2e_playwright.shared.app_utils import expect_markdown


def test_components_v1_was_imported_successfully(app: Page):
    expect(app.locator("iframe")).to_be_attached()
    iframe = app.frame_locator("iframe")
    div = iframe.locator("div")
    expect(div).to_have_text("This import and usage worked!")

    expect_markdown(app, "<bound method IframeMixin._iframe of DeltaGenerator()>")
    expect_markdown(app, re.compile("<function declare_component at .*>"))


================================================
File: /e2e_playwright/st_components_v1_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    get_element_by_key,
)


def test_components_iframe_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that our components v1 API correctly renders elements via screenshot matching."""

    elements = themed_app.locator("iframe")
    expect(elements).to_have_count(3)

    # Only doing a snapshot of the html component, since the iframe one
    # does not use a valid URL.
    assert_snapshot(elements.nth(0), name="st_components-html")

    # Emulate dark theme OS setting:
    themed_app.emulate_media(color_scheme="dark")
    assert_snapshot(elements.nth(0), name="st_components-html")


def test_html_correctly_sets_attr(app: Page):
    """Test that html correctly sets attributes."""

    html_component = app.locator("iframe").nth(0)

    expect(html_component).to_have_attribute("srcDoc", "<h1>Hello, Streamlit!</h1>")
    expect(html_component).to_have_attribute("width", "200")
    expect(html_component).to_have_attribute("height", "500")
    expect(html_component).to_have_attribute("scrolling", "no")


def test_iframe_correctly_sets_attr(app: Page):
    """Test that iframe correctly sets attributes."""

    iframe_component = app.locator("iframe").nth(1)

    expect(iframe_component).to_have_attribute("src", "http://not.a.real.url")
    expect(iframe_component).to_have_attribute("width", "200")
    expect(iframe_component).to_have_attribute("height", "500")
    expect(iframe_component).to_have_attribute("scrolling", "auto")


def test_declare_component_correctly_sets_attr(app: Page):
    """Test that components.declare_component correctly sets attributes."""

    declare_component = app.locator("iframe").nth(2)

    expect(declare_component).to_have_attribute(
        "title", "st_components_v1.test_component"
    )
    expect(declare_component).to_have_attribute(
        "src",
        re.compile(
            r"http://not.a.real.url\?streamlitUrl=http%3A%2F%2Flocalhost%3A\d*%2F$"
        ),
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stCustomComponentV1")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "component_1")).to_be_visible()


# TODO (willhuang1997): Add tests for handling bytes, JSON, DFs, theme
# TODO (willhuang1997):add tests to ensure the messages actually go to the iframe
# Relevant code is here from the past: https://github.com/streamlit/streamlit/blob/3d0b0603627037255790fe55a483f55fce5eff67/frontend/lib/src/components/widgets/CustomComponent/ComponentInstance.test.tsx#L257
# Relevant PR is here: https://github.com/streamlit/streamlit/pull/7971


================================================
File: /e2e_playwright/st_container.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

container = st.container(key="first container")

st.write("Line 1")
container.write("Line 2")
with container:
    "Line 3"
st.write("Line 4")

# Ensure widget states persist when React nodes shift
if st.button("Step 2: Press me"):
    st.header("Pressed!")
c = st.container()
if c.checkbox("Step 1: Check me"):
    c.title("Checked!")

with st.container(border=True):
    st.markdown(
        "This is inside a container with a border. And it doesn't overflow "
        "the borders if the text requires multiple lines."
    )
    st.button("Stretch full width", use_container_width=True)

with st.container(height=200):
    st.markdown("This is inside a scrolling container.")
    st.text_input("Widget in scroll container")

    for i in range(10):
        st.markdown(f"Message {i}")

empty_container = st.container(height=100)

if st.button("Add message"):
    empty_container.chat_message("user").write("Hello world")

with st.container(height=200):
    for i in range(10):
        st.chat_message("user").write(f"Message {i}")


================================================
File: /e2e_playwright/st_container_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_button,
    click_checkbox,
    get_checkbox,
    get_element_by_key,
)


def test_permits_multiple_out_of_order_elements(app: Page):
    """Test that st.container permits multiple out-of-order elements."""
    markdown_elements = app.get_by_test_id("stMarkdown")

    expect(markdown_elements.nth(0)).to_have_text("Line 2")
    expect(markdown_elements.nth(1)).to_have_text("Line 3")
    expect(markdown_elements.nth(2)).to_have_text("Line 1")
    expect(markdown_elements.nth(3)).to_have_text("Line 4")


def test_persists_widget_state_across_reruns(app: Page):
    """Test that st.container persists widget state across reruns."""

    click_checkbox(app, "Step 1: Check me")

    expect(app.locator("h1").first).to_have_text("Checked!")

    click_button(app, "Step 2: Press me")

    expect(app.locator("h2").first).to_have_text("Pressed!")
    expect(get_checkbox(app, "Step 1: Check me").locator("input")).to_have_attribute(
        "aria-checked", "true"
    )


def test_renders_container_with_border(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.container(border=True) renders correctly with a border."""
    container_with_border = themed_app.get_by_test_id(
        "stVerticalBlockBorderWrapper"
    ).nth(3)
    assert_snapshot(container_with_border, name="st_container-has_border")
    # This one should not have scrolling activated:
    expect(container_with_border).not_to_have_css("overflow", "auto")


def test_renders_scroll_container(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.container(height=<pixels>) renders a scroll container."""

    scroll_container = app.get_by_test_id("stVerticalBlockBorderWrapper").nth(4)
    expect(scroll_container).to_have_css("overflow", "auto")
    expect(scroll_container).to_have_css("height", "200px")
    expect(scroll_container).to_have_attribute("data-test-scroll-behavior", "normal")
    assert_snapshot(scroll_container, name="st_container-scroll_container")

    scroll_container_empty = app.get_by_test_id("stVerticalBlockBorderWrapper").nth(5)
    expect(scroll_container_empty).to_have_css("overflow", "auto")
    expect(scroll_container_empty).to_have_css("height", "100px")
    expect(scroll_container_empty).to_have_attribute(
        "data-test-scroll-behavior", "normal"
    )
    assert_snapshot(scroll_container_empty, name="st_container-scroll_container_empty")

    # This one should be pinned to the bottom:
    scroll_container_chat = app.get_by_test_id("stVerticalBlockBorderWrapper").nth(6)
    expect(scroll_container_chat).to_have_css("overflow", "auto")
    expect(scroll_container_chat).to_have_css("height", "200px")
    expect(scroll_container_chat).to_have_attribute(
        "data-test-scroll-behavior", "scroll-to-bottom"
    )
    assert_snapshot(scroll_container_chat, name="st_container-scroll_container_chat")


def test_correctly_handles_first_chat_message(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.container(height=<pixels>) correctly handles the scroll
    behaviour change when adding the first chat message ."""

    # Click button to add a chat message to the empty container:
    click_button(app, "Add message")

    wait_for_app_run(app)

    # Wait for the stVerticalBlockBorderWrapper container to switch to scroll-to-bottom:
    expect(app.get_by_test_id("stVerticalBlockBorderWrapper").nth(5)).to_have_attribute(
        "data-test-scroll-behavior", "scroll-to-bottom"
    )

    assert_snapshot(
        app.get_by_test_id("stVerticalBlockBorderWrapper").nth(5),
        name="st_container-added_chat_message",
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stVerticalBlock")


def test_custom_css_class_via_key(app: Page):
    """Test that the container can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "first container")).to_be_visible()


================================================
File: /e2e_playwright/st_data_editor_column_types.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import random

import numpy as np

import streamlit as st
from shared.data_mocks import (
    BASE_TYPES_DF,
    DATETIME_TYPES_DF,
    INTERVAL_TYPES_DF,
    LIST_TYPES_DF,
    NUMBER_TYPES_DF,
    PERIOD_TYPES_DF,
    SPECIAL_TYPES_DF,
    UNSUPPORTED_TYPES_DF,
)

np.random.seed(0)
random.seed(0)

st.set_page_config(layout="wide")

st.subheader("Base types")
st.data_editor(BASE_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("Number types")
st.data_editor(NUMBER_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("Date, time and datetime types")
st.data_editor(DATETIME_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("List types")
st.data_editor(LIST_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("Interval dtypes in pd.DataFrame")
st.data_editor(INTERVAL_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("Special types")
st.data_editor(
    SPECIAL_TYPES_DF,
    use_container_width=True,
    # Timedelta is only editable if it is explicitly configured as number column.
    # Reason is that the timedelta is provided as nanoseconds as default, which
    # quickly overflows the max value supported by Number in Javascript.
    column_config={"timedelta": st.column_config.NumberColumn()},
    hide_index=True,
)

st.subheader("Period dtypes in pd.DataFrame")
st.data_editor(PERIOD_TYPES_DF, use_container_width=True, hide_index=True)

st.subheader("Unsupported types (string fallback)")
st.data_editor(UNSUPPORTED_TYPES_DF, use_container_width=True, hide_index=True)


================================================
File: /e2e_playwright/st_data_editor_column_types_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_data_editor_column_types(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.data_editor render various column types correctly."""
    elements = themed_app.get_by_test_id("stDataFrame")
    expect(elements).to_have_count(8)

    # The dataframe component might require a bit more time for rendering the canvas
    themed_app.wait_for_timeout(250)

    assert_snapshot(elements.nth(0), name="st_data_editor-base_types")
    assert_snapshot(elements.nth(1), name="st_data_editor-numerical_types")
    assert_snapshot(elements.nth(2), name="st_data_editor-datetime_types")
    assert_snapshot(elements.nth(3), name="st_data_editor-list_types")
    assert_snapshot(elements.nth(4), name="st_data_editor-interval_types")
    assert_snapshot(elements.nth(5), name="st_data_editor-special_types")
    assert_snapshot(elements.nth(6), name="st_data_editor-period_types")
    assert_snapshot(elements.nth(7), name="st_data_editor-unsupported_types")


================================================
File: /e2e_playwright/st_data_editor_config.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import datetime
import random

import numpy as np
import pandas as pd

import streamlit as st

np.random.seed(0)
random.seed(0)

st.set_page_config(layout="wide")

# Generate a random dataframe
df = pd.DataFrame(
    np.random.randn(5, 5),
    columns=("col_%d" % i for i in range(5)),
)

st.header("Disabled parameter:")
st.data_editor(df, disabled=True)
st.data_editor(df, disabled=["col_4", "col_1"])

st.header("Hide index parameter:")
st.data_editor(df, hide_index=True)
st.data_editor(df, hide_index=False)

st.header("Column order parameter:")
st.data_editor(df, column_order=["col_4", "col_3", "col_0"])

st.header("Set column labels:")
st.data_editor(
    df,
    column_config={
        "_index": "Index column",
        "col_0": "Column 0",
        "col_2": st.column_config.Column("Column 1"),
    },
)

st.header("Hide columns:")
st.data_editor(df, column_config={"col_1": None, "col_3": {"hidden": True}})

st.header("Set column width:")
st.data_editor(
    df,
    column_config={
        "col_0": st.column_config.Column(width="small"),
        "col_1": st.column_config.Column(width="medium"),
        "col_4": {"width": "large"},
    },
)

st.header("Set help tooltips:")
st.caption("Hover over the column headers to see the tooltips.")
st.data_editor(
    pd.DataFrame(
        {
            "col_0": ["a", "b", "c", None],
        }
    ),
    column_config={
        "col_0": st.column_config.Column(help="This :red[is] a **tooltip** 🌟"),
        "_index": {"help": "Index tooltip!"},
    },
)

st.header("Text column:")
st.caption(
    "Editing the first column should only allow 5 characters. The second column should"
    " only allow numerical characters."
)
st.data_editor(
    pd.DataFrame(
        {
            "col_0": ["Hello World", "Lorem ipsum", "", None],
            "col_1": ["1", "2", "3", None],
        }
    ),
    column_config={
        "col_0": st.column_config.TextColumn(
            "Text column",
            width="medium",
            help="This is a text column",
            required=True,
            disabled=False,
            default="invalid",
            max_chars=5,
        ),
        "col_1": st.column_config.TextColumn(
            validate="^[0-9]+$",
        ),
    },
)

st.header("Number column:")
st.caption(
    "Editing the first column should only allow to submit numbers between 0 and 5. "
    "And only a maximum of 2 decimals."
)
st.data_editor(
    pd.DataFrame(
        {
            "col_0": [1, 2, 3, None],
            "col_1": ["1", "2", "invalid", None],
        }
    ),
    column_config={
        "col_0": st.column_config.NumberColumn(
            "Number column",
            width="medium",
            help="This is a number column",
            required=True,
            disabled=False,
            default=0,
            min_value=5,
            max_value=10,
            step=0.01,
        ),
        "col_1": st.column_config.NumberColumn(
            format="%.2f%%",
        ),
    },
)

st.header("Checkbox column:")
st.data_editor(
    pd.DataFrame(
        {
            "col_0": [True, False, False, None],
            "col_1": ["yes", "no", "invalid", None],
        }
    ),
    column_config={
        "col_0": st.column_config.CheckboxColumn(
            "Checkbox column",
            width="medium",
            help="This is a checkbox column",
            required=True,
            disabled=False,
            default=True,
        ),
        "col_1": st.column_config.CheckboxColumn(),
    },
)

st.header("Selectbox column:")

st.data_editor(
    pd.DataFrame(
        {
            "col_0": [1, 2, 3, None],
            "col_1": ["a", "b", "c", None],
        }
    ),
    column_config={
        "col_0": st.column_config.SelectboxColumn(
            "Selectbox column",
            width="medium",
            help="This is a selectbox column",
            required=True,
            disabled=False,
            default=True,
            options=[1, 2, 3, 4, 5],
        ),
        "col_1": st.column_config.SelectboxColumn(options=["a", "b", "c", "d"]),
    },
)

st.header("Link column:")
st.caption(
    "Editing the first column should only submitting values starting with http and a "
    "maximum of 50 characters."
)
st.data_editor(
    pd.DataFrame(
        {
            "col_0": [
                "https://streamlit.io/",
                "https://docs.streamlit.io/",
                "https://streamlit.io/gallery",
                None,
            ],
            "col_1": ["/a", "/b", "", None],
            "col_2": [
                "https://roadmap.streamlit.app",
                "https://extras.streamlit.app",
                "",
                None,
            ],
        }
    ),
    column_config={
        "col_0": st.column_config.LinkColumn(
            "Link column",
            width="medium",
            help="This is a link column",
            required=True,
            disabled=False,
            default="https://streamlit.io/",
            max_chars=50,
            validate=r"^http.*$",
        ),
        "col_1": st.column_config.LinkColumn(),
        "col_2": st.column_config.LinkColumn(
            "Display text via Regex",
            validate=r"^https://.*?\.streamlit\.app$",
            display_text=r"https://(.*?)\.streamlit\.app",
        ),
    },
)

st.header("Datetime column:")
st.caption(
    "Editing the first column should only allow datetime values between 2021-01-01 and "
    "2022-01-01."
)
st.data_editor(
    pd.DataFrame(
        {
            "col_0": [
                datetime.datetime(2021, 1, 1, 1, 0, 0, 123000),
                datetime.datetime(2022, 1, 2, 2, 0, 0, 234000),
                datetime.datetime(2023, 1, 3, 3, 0, 0, 345000),
                None,
            ],
        }
    ),
    column_config={
        "col_0": st.column_config.DatetimeColumn(
            "Datetime column",
            width="medium",
            help="This is a datetime column",
            required=True,
            disabled=False,
            default=datetime.datetime(2021, 1, 1, 1, 0, 0),
            min_value=datetime.datetime(2021, 1, 1, 1, 0, 0),
            max_value=datetime.datetime(2022, 1, 1, 1, 0, 0),
            step=0.01,
            format="YYYY-MM-DD HH:mm:ss.SSS",
        ),
    },
)

st.header("Date column:")
st.caption(
    "Editing the first column should only allow picking every second day and between "
    "2021-01-01 and 2022-01-01."
)
st.data_editor(
    pd.DataFrame(
        {
            "col_0": [
                datetime.date(2021, 1, 1),
                datetime.date(2022, 1, 2),
                datetime.date(2023, 1, 3),
                None,
            ],
        }
    ),
    column_config={
        "col_0": st.column_config.DateColumn(
            "Date column",
            width="medium",
            help="This is a date column",
            required=True,
            disabled=False,
            default=datetime.date(2021, 1, 1),
            min_value=datetime.date(2021, 1, 1),
            max_value=datetime.date(2022, 1, 1),
            step=2,
        ),
    },
)

st.header("Time column:")
st.caption(
    "Editing the first column should only allow datetime values "
    "between 01:02 and 01:03."
)
st.data_editor(
    pd.DataFrame(
        {
            "col_0": [
                datetime.time(1, 2, 0, 123000),
                datetime.time(2, 3, 0, 234000),
                datetime.time(3, 4, 0, 345000),
                None,
            ]
        }
    ),
    column_config={
        "col_0": st.column_config.TimeColumn(
            "Time column",
            width="medium",
            help="This is a time column",
            required=True,
            disabled=False,
            default=datetime.time(1, 2, 0),
            min_value=datetime.time(1, 2, 0),
            max_value=datetime.time(1, 3, 0),
            step=datetime.timedelta(milliseconds=1),
        ),
    },
)

st.header("Progress column:")

st.data_editor(
    pd.DataFrame(
        {
            "col_0": [0.1, 0.4, 1.1, None],
            "col_1": ["200", "550", "1000", None],
        }
    ),
    column_config={
        "col_0": st.column_config.ProgressColumn(
            "Progress column",
            width="medium",
            help="This is a progress column",
        ),
        "col_1": st.column_config.ProgressColumn(
            format="$%f", min_value=0, max_value=1000
        ),
    },
)

st.header("List column:")

st.data_editor(
    pd.DataFrame(
        {
            "col_0": [[1, 2], [2, 3, 4], [], None],
            "col_1": ["a,b", "c,d,e", "", None],
        }
    ),
    column_config={
        "col_0": st.column_config.ListColumn(
            "List column",
            width="medium",
            help="This is a list column",
        ),
        "col_1": st.column_config.ListColumn(),
    },
)

st.header("Bar chart column:")

st.data_editor(
    pd.DataFrame(
        {
            "col_0": [[1, 5, 2], [2, 3, 5, -4, -5], [], None],
            "col_1": ["1,2,3,4", "6, 5, 1, 10", "invalid", None],
        }
    ),
    column_config={
        "col_0": st.column_config.BarChartColumn(
            "Bar chart column",
            width="medium",
            help="This is a bar chart column",
            y_min=-5,
            y_max=5,
        ),
        "col_1": st.column_config.BarChartColumn(),
    },
)


st.header("Line chart column:")

st.data_editor(
    pd.DataFrame(
        {
            "col_0": [[1, 5, 2], [2, 3, 5, -4, -5], [], None],
            "col_1": ["1,2,3,4", "6, 5, 1, 10", "invalid", None],
        }
    ),
    column_config={
        "col_0": st.column_config.LineChartColumn(
            "Line chart column",
            width="medium",
            help="This is a line chart column",
            y_min=-5,
            y_max=5,
        ),
        "col_1": st.column_config.LineChartColumn(),
    },
)

st.header("Image column:")

st.data_editor(
    pd.DataFrame(
        {
            "col_0": [
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJYAAABSCAMAAACBpt1yAAAAwFBMVEVHcEyAhJWAhJUzNT97f4+AhJWAhJVtcH9WWWaAhJWAhJWAhJVCRFGAhJWAhJWAhJVVWGeAhJWAhJWAhJVVWGcmJzCAhJWAhJWAhJUmJzAmJzBVWGcmJzAmJzAmJzAmJzAmJzCAhJUmJzBVWGcmJzAmJzAmJzBVWGeAhJVVWGdVWGdVWGeAhJVVWGdVWGdVWGdvcoJVJ2WAhJVVWGcmJzBTVmVaXWx8f5B1eYlhZHNoa3tDRVI3OUQtLzhucoJMT13kXsyQAAAAMXRSTlMA+SYWE/ExBQvmfME1P7Uc9lhpjSdsTZ7cnETlsyP6xvHNg7XXV+bYq6NjTtR1yJLh8/IzCQAABHhJREFUaN7Nmut2mkAYRZGLIMQbRMFbvMQYkmjS9YFJU23z/m9VwEpgGJgZYLo4/2ratXbdhyNMFIS68jzzXm+EpuVl5nne623DqKRXL8yb2iyst4jKG7w0S+HgguU93jZPYZin5mhU32Iqb/DcPIWN0phQGGnUGqewQRpTChuj8fbVQ1ODRnVsDeUaFVbXuBhtpsJYgZYxLP3fUzMKK2qURlvf3wkWBGn1xiVX8PbRw6WsRmm09MOE71YYxe2qNSmMUkqj9rC8i6hWgmzAJYrdVqtfhRU0ag/zC5TvzwVBh2s6drsehWHuGTVq0xjKXz0IgtiBbzBLZFL45OWHSaM6naz8OEspeMWGRBydAex5UIA1Y7iDvklC+f4ofG3cSnLBXu9XV8ik8WayS0L5u0X4qryGdNYm1b5qT4VU3uBAt56bNJTvTy6Xng5o1jTDX6iQVuNis0Wg/Lvp5UftToaLYvgJCqk0RpOOJix8dBm4kA1p+EkKoxyoJh3J5vrzYQvDRRh+okKSRuk66Uh28b/JlD4e/m4FhZFGmTzp+MLjS08YfiqF+RqTk44W/uH7r2FKXzz8VArzNKrT+crPy7XwuaWPwbLDfzPzaJPRqCKTnlf4/NJ/fyKlh1+79+hzKJ703MKH6e+hMPvU8B8YqNIas5OOZJ6eOgsISXwiMShMa8RMekHhw3QVElc8/EwKExqxk45kKyFF7AEx/4b/wEjlzV4ooZDChzGBIsHwsyqMNEpazqQjWU1RrL4DVGD2vXdk55rTQGUKT1X6a/58MmN9namo7kbZ7SWX/pqPP+/MXL9psLYLzOeUAdT5+MUIdjzRvFkT3OenCcAP7HguU/gwosPCBT9/vTN0/0jWeLfE38zaABzByBpH+Fsz+tLHYJ/Ua3Ekatwt8FiyAcARjKRxkneLbgJwBCNcjfjClyh9PGOfdVyNSyn3acQGKAf2Xl3jKP8hadwCrmAn2tvS6qVnASvQOCl6WNahfGiGP1cjeluKlL5TgYtmX0/shRfQMzgOYHkaN8VnKKVLTztjeI07wplT3nFEfWBYjXPSIbcOwBnszFp4wnFETcOP0biViEfRLgBnsBNr4cnHEbXsK6pxRXHIWkPpSfuKapzTHJXrALzBToyFD8vVVoA72Jn0HMat9IXDn9K4EahSV+mLZuyL5rYUOY7YA/AGS3w2zml/N2QBcAc7/qa4La36ZEa3r0fc1UhX+Og4ogfABwxzNU7of+1oAvABe89opC08wxlcxRn7It+W8i89BuzMUnhepU+AHWONuwULlmYAx8TD/1X8HPbfSo/M2PE0ZaIqeRzBDMb6JQ7BbAF/sBnzt41VXeHN9fGjxJdn1bHBF0xx20KZyF3d7hn7jlKvz5bi7A3X1rsVvqqnarLYHg9N3XIDQqejlGJsKUrHWRs929LNYbctylpt3+VVVVnui+1uwBhAWrbb6xnGer13HKeTSvCCs1+vDaPnurYVgJjDcYDSr5GlEDN4J+V+EFEU23GCP4jBa7IcUKilOf4CgQRuuzC9EJcAAAAASUVORK5CYII=",
                "data:image/svg+xml,%3Csvg width='301' height='165' viewBox='0 0 301 165' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M150.731 101.547L98.1387 73.7471L6.84674 25.4969C6.7634 25.4136 6.59674 25.4136 6.51341 25.4136C3.18007 23.8303 -0.236608 27.1636 1.0134 30.497L47.5302 149.139L47.5385 149.164C47.5885 149.281 47.6302 149.397 47.6802 149.514C49.5885 153.939 53.7552 156.672 58.2886 157.747C58.6719 157.831 58.9461 157.906 59.4064 157.998C59.8645 158.1 60.5052 158.239 61.0552 158.281C61.1469 158.289 61.2302 158.289 61.3219 158.297H61.3886C61.4552 158.306 61.5219 158.306 61.5886 158.314H61.6802C61.7386 158.322 61.8052 158.322 61.8636 158.322H61.9719C62.0386 158.331 62.1052 158.331 62.1719 158.331V158.331C121.084 164.754 180.519 164.754 239.431 158.331V158.331C240.139 158.331 240.831 158.297 241.497 158.231C241.714 158.206 241.922 158.181 242.131 158.156C242.156 158.147 242.189 158.147 242.214 158.139C242.356 158.122 242.497 158.097 242.639 158.072C242.847 158.047 243.056 158.006 243.264 157.964C243.681 157.872 243.87 157.806 244.436 157.611C245.001 157.417 245.94 157.077 246.527 156.794C247.115 156.511 247.522 156.239 248.014 155.931C248.622 155.547 249.201 155.155 249.788 154.715C250.041 154.521 250.214 154.397 250.397 154.222L250.297 154.164L150.731 101.547Z' fill='%23FF4B4B'/%3E%3Cpath d='M294.766 25.4981H294.683L203.357 73.7483L254.124 149.357L300.524 30.4981V30.3315C301.691 26.8314 298.108 23.6648 294.766 25.4981' fill='%237D353B'/%3E%3Cpath d='M155.598 2.55572C153.264 -0.852624 148.181 -0.852624 145.931 2.55572L98.1389 73.7477L150.731 101.548L250.398 154.222C251.024 153.609 251.526 153.012 252.056 152.381C252.806 151.456 253.506 150.465 254.123 149.356L203.356 73.7477L155.598 2.55572Z' fill='%23BD4043'/%3E%3C/svg%3E%0A",
                "",
                None,
            ],
        }
    ),
    column_config={
        "col_0": st.column_config.ImageColumn(
            "Image column",
            width="medium",
            help="This is a image column",
        ),
    },
)


================================================
File: /e2e_playwright/st_data_editor_config_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class


def test_data_editor_supports_various_configurations(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Screenshot test that st.data_editor supports various configuration options."""
    # The dataframe config test is already testing with themed apps, so using the
    # default theme only is fine here.
    elements = app.get_by_test_id("stDataFrame")
    expect(elements).to_have_count(22)

    # The dataframe component might require a bit more time for rendering the canvas
    app.wait_for_timeout(500)

    assert_snapshot(elements.nth(0), name="st_data_editor-disabled_all_columns")
    assert_snapshot(elements.nth(1), name="st_data_editor-disabled_two_columns")
    assert_snapshot(elements.nth(2), name="st_data_editor-hide_index")
    assert_snapshot(elements.nth(3), name="st_data_editor-show_index")
    assert_snapshot(elements.nth(4), name="st_data_editor-custom_column_order")
    assert_snapshot(elements.nth(5), name="st_data_editor-column_labels")
    assert_snapshot(elements.nth(6), name="st_data_editor-hide_columns")
    assert_snapshot(elements.nth(7), name="st_data_editor-set_column_width")
    assert_snapshot(elements.nth(8), name="st_data_editor-help_tooltips")
    assert_snapshot(elements.nth(9), name="st_data_editor-text_column")
    assert_snapshot(elements.nth(10), name="st_data_editor-number_column")
    assert_snapshot(elements.nth(11), name="st_data_editor-checkbox_column")
    assert_snapshot(elements.nth(12), name="st_data_editor-selectbox_column")
    assert_snapshot(elements.nth(13), name="st_data_editor-link_column")
    assert_snapshot(elements.nth(14), name="st_data_editor-datetime_column")
    assert_snapshot(elements.nth(15), name="st_data_editor-date_column")
    assert_snapshot(elements.nth(16), name="st_data_editor-time_column")
    assert_snapshot(elements.nth(17), name="st_data_editor-progress_column")
    assert_snapshot(elements.nth(18), name="st_data_editor-list_column")
    assert_snapshot(elements.nth(19), name="st_data_editor-bar_chart_column")
    assert_snapshot(elements.nth(20), name="st_data_editor-line_chart_column")
    assert_snapshot(elements.nth(21), name="st_data_editor-image_column")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stDataFrame")


================================================
File: /e2e_playwright/st_data_editor_index_types.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import random

import numpy as np

import streamlit as st
from shared.data_mocks import BASE_TYPES_DF, DATETIME_TYPES_DF, NUMBER_TYPES_DF

np.random.seed(0)
random.seed(0)

st.set_page_config(layout="wide")

st.header("Index types")

st.subheader("String Index (pd.Index)")
st.data_editor(
    BASE_TYPES_DF.set_index("string"), use_container_width=True, num_rows="dynamic"
)

st.subheader("Float64 Index (pd.Float64Index)")
st.data_editor(
    NUMBER_TYPES_DF.set_index("float64"), use_container_width=True, num_rows="dynamic"
)

st.subheader("Int64 Index (pd.Int64Index)")
st.data_editor(
    NUMBER_TYPES_DF.set_index("int64"), use_container_width=True, num_rows="dynamic"
)

st.subheader("Uint64 Index (pd.UInt64Index)")
st.data_editor(
    NUMBER_TYPES_DF.set_index("uint64"), use_container_width=True, num_rows="dynamic"
)

st.subheader("Date Index (pd.Index)")
st.data_editor(
    DATETIME_TYPES_DF.set_index("date"), use_container_width=True, num_rows="dynamic"
)

st.subheader("Time Index (pd.Index)")
st.data_editor(
    DATETIME_TYPES_DF.set_index("time"), use_container_width=True, num_rows="dynamic"
)

st.subheader("Datetime Index (pd.DatetimeIndex)")
