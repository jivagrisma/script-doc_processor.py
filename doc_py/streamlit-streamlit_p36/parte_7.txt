"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.


================================================
File: /frontend/app/src/assets/fonts/Source_Sans_Pro/Source-Sans-Pro.LICENSE
================================================
Copyright 2010-2018 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.

This Font Software is licensed under the SIL Open Font License, Version 1.1.

This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL


-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded, 
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.


================================================
File: /frontend/app/src/assets/fonts/Source_Serif_Pro/Source-Serif-Pro.LICENSE
================================================
Copyright 2014-2018 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.

This Font Software is licensed under the SIL Open Font License, Version 1.1.

This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL


-----------------------------------------------------------
SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007
-----------------------------------------------------------

PREAMBLE
The goals of the Open Font License (OFL) are to stimulate worldwide
development of collaborative font projects, to support the font creation
efforts of academic and linguistic communities, and to provide a free and
open framework in which fonts may be shared and improved in partnership
with others.

The OFL allows the licensed fonts to be used, studied, modified and
redistributed freely as long as they are not sold by themselves. The
fonts, including any derivative works, can be bundled, embedded,
redistributed and/or sold with any software provided that any reserved
names are not used by derivative works. The fonts and derivatives,
however, cannot be released under any other type of license. The
requirement for fonts to remain under this license does not apply
to any document created using the fonts or their derivatives.

DEFINITIONS
"Font Software" refers to the set of files released by the Copyright
Holder(s) under this license and clearly marked as such. This may
include source files, build scripts and documentation.

"Reserved Font Name" refers to any names specified as such after the
copyright statement(s).

"Original Version" refers to the collection of Font Software components as
distributed by the Copyright Holder(s).

"Modified Version" refers to any derivative made by adding to, deleting,
or substituting -- in part or in whole -- any of the components of the
Original Version, by changing formats or by porting the Font Software to a
new environment.

"Author" refers to any designer, engineer, programmer, technical
writer or other person who contributed to the Font Software.

PERMISSION & CONDITIONS
Permission is hereby granted, free of charge, to any person obtaining
a copy of the Font Software, to use, study, copy, merge, embed, modify,
redistribute, and sell modified and unmodified copies of the Font
Software, subject to the following conditions:

1) Neither the Font Software nor any of its individual components,
in Original or Modified Versions, may be sold by itself.

2) Original or Modified Versions of the Font Software may be bundled,
redistributed and/or sold with any software, provided that each copy
contains the above copyright notice and this license. These can be
included either as stand-alone text files, human-readable headers or
in the appropriate machine-readable metadata fields within text or
binary files as long as those fields can be easily viewed by the user.

3) No Modified Version of the Font Software may use the Reserved Font
Name(s) unless explicit written permission is granted by the corresponding
Copyright Holder. This restriction only applies to the primary font name as
presented to the users.

4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font
Software shall not be used to promote, endorse or advertise any
Modified Version, except to acknowledge the contribution(s) of the
Copyright Holder(s) and the Author(s) or with their explicit written
permission.

5) The Font Software, modified or unmodified, in part or in whole,
must be distributed entirely under this license, and must not be
distributed under any other license. The requirement for fonts to
remain under this license does not apply to any document created
using the Font Software.

TERMINATION
This license becomes null and void if any of the above conditions are
not met.

DISCLAIMER
THE FONT SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT
OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE
COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL
DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM
OTHER DEALINGS IN THE FONT SOFTWARE.


================================================
File: /frontend/app/src/assets/img/Material-Icons.LICENSE
================================================
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.


================================================
File: /frontend/app/src/assets/img/Open-Iconic.LICENSE
================================================
The MIT License (MIT)

Copyright (c) 2014 Waybury

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.

================================================
File: /frontend/app/src/components/AppContext.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { AppConfig, IGitInfo, PageConfig } from "@streamlit/lib"

export interface Props {
  /**
   * If true, render the app with a wider column size.
   * Set from the UserSettings object.
   * @see UserSettings
   */
  wideMode: boolean

  /**
   * The sidebar's default display state.
   * Set from the PageConfig protobuf.
   */
  initialSidebarState: PageConfig.SidebarState

  /**
   * True if the app is embedded.
   * @see isEmbed
   */
  embedded: boolean

  /**
   * True if padding is enabled.
   * @see isPaddingDisplayed
   */
  showPadding: boolean

  /**
   * True if scrolling is disabled.
   * @see isScrollingHidden
   */
  disableScrolling: boolean

  /**
   * True if the toolbar should be displayed.
   * @see isToolbarDisplayed
   */
  showToolbar: boolean

  /**
   * True if the thin colored line at the top of the app should be displayed.
   * @see isColoredLineDisplayed
   */
  showColoredLine: boolean

  /**
   * Part of URL construction for an app page in a multi-page app;
   * this is set from the host communication manager via host message.
   * @see SidebarNav
   */
  pageLinkBaseUrl: string

  /**
   * If non-zero, this is the number of pixels that the sidebar's
   * "chevron" icon is shifted. (If sidebarChevronDownshift is 0, then
   * the current theme's spacing is used.);
   * this is set from the host communication manager via host message.
   * @see StyledSidebarCollapsedControl
   */
  sidebarChevronDownshift: number

  /**
   * The latest state of the git information related to the app.
   */
  gitInfo: IGitInfo | null

  /** The app-specific configuration from the apps host which is requested via the
   * _stcore/host-config endpoint.
   */
  appConfig: AppConfig
}

export const AppContext = React.createContext<Props>({
  wideMode: false,
  initialSidebarState: PageConfig.SidebarState.AUTO,
  embedded: false,
  showPadding: false,
  disableScrolling: false,
  showToolbar: false,
  showColoredLine: false,
  pageLinkBaseUrl: "",
  sidebarChevronDownshift: 0,
  gitInfo: null,
  appConfig: {},
})


================================================
File: /frontend/app/src/components/AppView/AppView.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen, within } from "@testing-library/react"

import {
  AppRoot,
  BlockNode,
  Block as BlockProto,
  ComponentRegistry,
  createFormsData,
  Element,
  ElementNode,
  FileUploadClient,
  ForwardMsgMetadata,
  Logo as LogoProto,
  makeElementWithInfoText,
  mockEndpoints,
  mockSessionInfo,
  PageConfig,
  render,
  ScriptRunState,
  WidgetStateManager,
} from "@streamlit/lib"
import {
  AppContext,
  Props as AppContextProps,
} from "@streamlit/app/src/components/AppContext"

import AppView, { AppViewProps } from "./AppView"

// Mock needed for Block.tsx
class ResizeObserver {
  observe(): void {}

  unobserve(): void {}

  disconnect(): void {}
}
window.ResizeObserver = ResizeObserver

const FAKE_SCRIPT_HASH = "fake_script_hash"

function getContextOutput(context: Partial<AppContextProps>): AppContextProps {
  return {
    wideMode: false,
    initialSidebarState: PageConfig.SidebarState.AUTO,
    embedded: false,
    showPadding: false,
    disableScrolling: false,
    showToolbar: false,
    showColoredLine: false,
    pageLinkBaseUrl: "",
    sidebarChevronDownshift: 0,
    ...context,
  }
}

const mockEndpointProp = mockEndpoints()

function getProps(props: Partial<AppViewProps> = {}): AppViewProps {
  const formsData = createFormsData()

  const sessionInfo = mockSessionInfo()

  return {
    endpoints: mockEndpointProp,
    elements: AppRoot.empty(FAKE_SCRIPT_HASH, true),
    sendMessageToHost: vi.fn(),
    scriptRunId: "script run 123",
    scriptRunState: ScriptRunState.NOT_RUNNING,
    widgetMgr: new WidgetStateManager({
      sendRerunBackMsg: vi.fn(),
      formsDataChanged: vi.fn(),
    }),
    uploadClient: new FileUploadClient({
      sessionInfo,
      endpoints: mockEndpointProp,
      formsWithPendingRequestsChanged: () => {},
      requestFileURLs: vi.fn(),
    }),
    widgetsDisabled: true,
    componentRegistry: new ComponentRegistry(mockEndpointProp),
    formsData,
    appLogo: null,
    appPages: [{ pageName: "streamlit_app", pageScriptHash: "page_hash" }],
    navSections: [],
    onPageChange: vi.fn(),
    currentPageScriptHash: "main_page_script_hash",
    hideSidebarNav: false,
    expandSidebarNav: false,
    ...props,
  }
}

describe("AppView element", () => {
  afterEach(() => {
    vi.restoreAllMocks()
  })

  it("renders without crashing", () => {
    render(<AppView {...getProps()} />)
    const appViewContainer = screen.getByTestId("stAppViewContainer")
    expect(appViewContainer).toBeInTheDocument()
    expect(appViewContainer).toHaveClass("stAppViewContainer")
  })

  it("does not render a sidebar when there are no elements and only one page", () => {
    const props = getProps()
    render(<AppView {...props} />)

    const sidebar = screen.queryByTestId("stSidebar")
    expect(sidebar).not.toBeInTheDocument()
  })

  it("renders a sidebar when there are elements and only one page", () => {
    const sidebarElement = new ElementNode(
      makeElementWithInfoText("sidebar!"),
      ForwardMsgMetadata.create({}),
      "no script run id",
      FAKE_SCRIPT_HASH
    )

    const sidebar = new BlockNode(
      FAKE_SCRIPT_HASH,
      [sidebarElement],
      new BlockProto({ allowEmpty: true })
    )

    const main = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )
    const event = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )
    const bottom = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )

    const props = getProps({
      elements: new AppRoot(
        FAKE_SCRIPT_HASH,
        new BlockNode(FAKE_SCRIPT_HASH, [main, sidebar, event, bottom])
      ),
    })
    render(<AppView {...props} />)

    const sidebarDOMElement = screen.queryByTestId("stSidebar")
    expect(sidebarDOMElement).toBeInTheDocument()
  })

  it("renders a sidebar when there are no elements but multiple pages", () => {
    const appPages = [
      { pageName: "streamlit_app", pageScriptHash: "page_hash" },
      { pageName: "streamlit_app2", pageScriptHash: "page_hash2" },
    ]
    render(<AppView {...getProps({ appPages })} />)

    const sidebarDOMElement = screen.queryByTestId("stSidebar")
    expect(sidebarDOMElement).toBeInTheDocument()
  })

  it("does not render a sidebar when there are no elements, multiple pages, and hideSidebarNav is true", () => {
    const appPages = [
      { pageName: "streamlit_app", pageScriptHash: "page_hash" },
      { pageName: "streamlit_app2", pageScriptHash: "page_hash2" },
    ]
    render(<AppView {...getProps({ appPages, hideSidebarNav: true })} />)

    const sidebar = screen.queryByTestId("stSidebar")
    expect(sidebar).not.toBeInTheDocument()
  })

  it("renders a sidebar when there are elements and multiple pages", () => {
    const sidebarElement = new ElementNode(
      makeElementWithInfoText("sidebar!"),
      ForwardMsgMetadata.create({}),
      "no script run id",
      FAKE_SCRIPT_HASH
    )

    const sidebar = new BlockNode(
      FAKE_SCRIPT_HASH,
      [sidebarElement],
      new BlockProto({ allowEmpty: true })
    )

    const main = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )
    const event = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )
    const bottom = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )

    const appPages = [
      { pageName: "streamlit_app", pageScriptHash: "page_hash" },
      { pageName: "streamlit_app2", pageScriptHash: "page_hash2" },
    ]
    const props = getProps({
      elements: new AppRoot(
        FAKE_SCRIPT_HASH,
        new BlockNode(FAKE_SCRIPT_HASH, [main, sidebar, event, bottom])
      ),
      appPages,
    })
    render(<AppView {...props} />)

    const sidebarDOMElement = screen.queryByTestId("stSidebar")
    expect(sidebarDOMElement).toBeInTheDocument()
  })

  it("does not render the sidebar if there are no elements, multiple pages but hideSidebarNav is true", () => {
    const appPages = [
      { pageName: "streamlit_app", pageScriptHash: "page_hash" },
      { pageName: "streamlit_app2", pageScriptHash: "page_hash2" },
    ]
    const props = getProps({
      appPages,
      hideSidebarNav: true,
    })
    render(<AppView {...props} />)

    const sidebar = screen.queryByTestId("stSidebar")
    expect(sidebar).not.toBeInTheDocument()
  })

  it("does not render the wide class", () => {
    const realUseContext = React.useContext
    vi.spyOn(React, "useContext").mockImplementation(input => {
      if (input === AppContext) {
        return getContextOutput({ wideMode: false, embedded: false })
      }

      return realUseContext(input)
    })

    const main = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )
    const sidebar = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )
    const event = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )
    const bottom = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )

    const props = getProps({
      elements: new AppRoot(
        FAKE_SCRIPT_HASH,
        new BlockNode(FAKE_SCRIPT_HASH, [main, sidebar, event, bottom])
      ),
    })
    render(<AppView {...props} />)

    const style = window.getComputedStyle(
      screen.getByTestId("stMainBlockContainer")
    )
    expect(style.maxWidth).not.toEqual("initial")
  })

  it("does render the wide class when specified", () => {
    const realUseContext = React.useContext
    vi.spyOn(React, "useContext").mockImplementation(input => {
      if (input === AppContext) {
        return getContextOutput({ wideMode: true, embedded: false })
      }

      return realUseContext(input)
    })
    render(<AppView {...getProps()} />)
    const style = window.getComputedStyle(
      screen.getByTestId("stMainBlockContainer")
    )
    expect(style.maxWidth).toEqual("initial")
  })

  describe("handles padding an embedded app", () => {
    it("embedded triggers default padding", () => {
      const realUseContext = React.useContext
      vi.spyOn(React, "useContext").mockImplementation(input => {
        if (input === AppContext) {
          return getContextOutput({ embedded: true })
        }

        return realUseContext(input)
      })
      render(<AppView {...getProps()} />)
      const style = window.getComputedStyle(
        screen.getByTestId("stMainBlockContainer")
      )
      expect(style.paddingTop).toEqual("2.1rem")
      expect(style.paddingBottom).toEqual("1rem")
    })

    it("showPadding triggers expected padding", () => {
      const realUseContext = React.useContext
      vi.spyOn(React, "useContext").mockImplementation(input => {
        if (input === AppContext) {
          return getContextOutput({ showPadding: true })
        }

        return realUseContext(input)
      })
      render(<AppView {...getProps()} />)
      const style = window.getComputedStyle(
        screen.getByTestId("stMainBlockContainer")
      )
      expect(style.paddingTop).toEqual("6rem")
      expect(style.paddingBottom).toEqual("10rem")
    })

    it("showToolbar triggers expected top padding", () => {
      const realUseContext = React.useContext
      vi.spyOn(React, "useContext").mockImplementation(input => {
        if (input === AppContext) {
          return getContextOutput({ showToolbar: true })
        }

        return realUseContext(input)
      })
      render(<AppView {...getProps()} />)
      const style = window.getComputedStyle(
        screen.getByTestId("stMainBlockContainer")
      )
      expect(style.paddingTop).toEqual("4.5rem")
      expect(style.paddingBottom).toEqual("1rem")
    })

    it("hasSidebar triggers expected top padding", () => {
      const realUseContext = React.useContext
      vi.spyOn(React, "useContext").mockImplementation(input => {
        if (input === AppContext) {
          return getContextOutput({ embedded: true })
        }

        return realUseContext(input)
      })

      const sidebarElement = new ElementNode(
        makeElementWithInfoText("sidebar!"),
        ForwardMsgMetadata.create({}),
        "no script run id",
        FAKE_SCRIPT_HASH
      )

      const sidebar = new BlockNode(
        FAKE_SCRIPT_HASH,
        [sidebarElement],
        new BlockProto({ allowEmpty: true })
      )

      const empty = new BlockNode(
        FAKE_SCRIPT_HASH,
        [],
        new BlockProto({ allowEmpty: true })
      )

      const props = getProps({
        elements: new AppRoot(
          FAKE_SCRIPT_HASH,
          new BlockNode(FAKE_SCRIPT_HASH, [empty, sidebar, empty, empty])
        ),
      })

      render(<AppView {...props} />)
      const style = window.getComputedStyle(
        screen.getByTestId("stMainBlockContainer")
      )
      expect(style.paddingTop).toEqual("4.5rem")
      expect(style.paddingBottom).toEqual("1rem")
    })
  })

  describe("handles logo rendering with no sidebar", () => {
    const imageOnly = LogoProto.create({
      image:
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png",
    })

    const imageWithLink = LogoProto.create({
      image:
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png",
      link: "www.example.com",
    })

    const imageWithSize = LogoProto.create({
      image:
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png",
      size: "large",
    })

    const fullAppLogo = LogoProto.create({
      image:
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png",
      link: "www.example.com",
      iconImage: "https://docs.streamlit.io/logo.svg",
    })

    it("doesn't render if no logo provided", () => {
      render(<AppView {...getProps()} />)
      expect(screen.queryByTestId("stLogo")).not.toBeInTheDocument()
    })

    it("uses iconImage if provided", () => {
      const sourceSpy = vi.spyOn(mockEndpointProp, "buildMediaURL")
      render(<AppView {...getProps({ appLogo: fullAppLogo })} />)
      const openSidebarContainer = screen.getByTestId(
        "stSidebarCollapsedControl"
      )
      expect(openSidebarContainer).toBeInTheDocument()
      const collapsedLogo = within(openSidebarContainer).getByTestId("stLogo")
      expect(collapsedLogo).toBeInTheDocument()
      expect(sourceSpy).toHaveBeenCalledWith(
        "https://docs.streamlit.io/logo.svg"
      )
      expect(collapsedLogo).toHaveClass("stLogo")
    })

    it("defaults to image if no iconImage", () => {
      const sourceSpy = vi.spyOn(mockEndpointProp, "buildMediaURL")
      render(<AppView {...getProps({ appLogo: imageOnly })} />)
      const openSidebarContainer = screen.getByTestId(
        "stSidebarCollapsedControl"
      )
      expect(openSidebarContainer).toBeInTheDocument()
      const collapsedLogo = within(openSidebarContainer).getByTestId("stLogo")
      expect(collapsedLogo).toBeInTheDocument()
      expect(sourceSpy).toHaveBeenCalledWith(
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png"
      )
    })

    it("default no link with image size medium", () => {
      render(<AppView {...getProps({ appLogo: imageOnly })} />)
      expect(screen.queryByTestId("stLogoLink")).not.toBeInTheDocument()
      expect(screen.getByTestId("stLogo")).toHaveStyle({ height: "1.5rem" })
    })

    it("link with image if provided", () => {
      render(<AppView {...getProps({ appLogo: imageWithLink })} />)
      expect(screen.getByTestId("stLogoLink")).toHaveAttribute(
        "href",
        "www.example.com"
      )
    })

    it("renders logo - large size when specified", () => {
      render(<AppView {...getProps({ appLogo: imageWithSize })} />)
      expect(screen.getByTestId("stLogo")).toHaveStyle({ height: "2rem" })
    })
  })

  describe("when window.location.hash changes", () => {
    let originalLocation: Location
    beforeEach(() => (originalLocation = window.location))
    afterEach(() => (window.location = originalLocation))

    it("sends UPDATE_HASH message to host", () => {
      const sendMessageToHost = vi.fn()
      render(<AppView {...getProps({ sendMessageToHost })} />)

      window.location.hash = "mock_hash"
      window.dispatchEvent(new HashChangeEvent("hashchange"))
      expect(sendMessageToHost).toHaveBeenCalledWith({
        hash: "#mock_hash",
        type: "UPDATE_HASH",
      })
    })
  })

  it("does not render a Scroll To Bottom container when no bottom container is present", () => {
    const props = getProps()
    render(<AppView {...props} />)

    const stbContainer = screen.queryByTestId("stAppScrollToBottomContainer")
    expect(stbContainer).not.toBeInTheDocument()
  })

  it("renders a Scroll To Bottom container if there is an element in the bottom container.", () => {
    const chatInputElement = new ElementNode(
      new Element({
        chatInput: {
          id: "123",
          placeholder: "Enter Text Here",
          disabled: false,
          default: "",
        },
      }),
      ForwardMsgMetadata.create({}),
      "no script run id",
      FAKE_SCRIPT_HASH
    )

    const main = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )
    const sidebar = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )
    const event = new BlockNode(
      FAKE_SCRIPT_HASH,
      [],
      new BlockProto({ allowEmpty: true })
    )
    const bottom = new BlockNode(
      FAKE_SCRIPT_HASH,
      [chatInputElement],
      new BlockProto({ allowEmpty: true })
    )

    const props = getProps({
      elements: new AppRoot(
        FAKE_SCRIPT_HASH,
        new BlockNode(FAKE_SCRIPT_HASH, [main, sidebar, event, bottom])
      ),
    })

    render(<AppView {...props} />)

    const stbContainer = screen.queryByTestId("stAppScrollToBottomContainer")
    expect(stbContainer).toBeInTheDocument()
  })
})


================================================
File: /frontend/app/src/components/AppView/AppView.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import {
  AppRoot,
  BlockNode,
  ComponentRegistry,
  FileUploadClient,
  FormsData,
  IAppPage,
  IGuestToHostMessage,
  LibContext,
  Logo,
  Profiler,
  ScriptRunState,
  StreamlitEndpoints,
  VerticalBlock,
  WidgetStateManager,
} from "@streamlit/lib"
import { ThemedSidebar } from "@streamlit/app/src/components/Sidebar"
import EventContainer from "@streamlit/app/src/components/EventContainer"
import {
  StyledLogo,
  StyledLogoLink,
  StyledSidebarOpenContainer,
} from "@streamlit/app/src/components/Sidebar/styled-components"
import { AppContext } from "@streamlit/app/src/components/AppContext"

import {
  StyledAppViewBlockContainer,
  StyledAppViewBlockSpacer,
  StyledAppViewContainer,
  StyledAppViewMain,
  StyledBottomBlockContainer,
  StyledEventBlockContainer,
  StyledIFrameResizerAnchor,
  StyledInnerBottomContainer,
  StyledSidebarBlockContainer,
  StyledStickyBottomContainer,
} from "./styled-components"
import ScrollToBottomContainer from "./ScrollToBottomContainer"

export interface AppViewProps {
  elements: AppRoot

  endpoints: StreamlitEndpoints

  sendMessageToHost: (message: IGuestToHostMessage) => void

  // The unique ID for the most recent script run.
  scriptRunId: string

  scriptRunState: ScriptRunState

  widgetMgr: WidgetStateManager

  uploadClient: FileUploadClient

  // Disable the widgets when not connected to the server.
  widgetsDisabled: boolean

  componentRegistry: ComponentRegistry

  formsData: FormsData

  appLogo: Logo | null

  appPages: IAppPage[]

  navSections: string[]

  onPageChange: (pageName: string) => void

  currentPageScriptHash: string

  hideSidebarNav: boolean

  expandSidebarNav: boolean
}

/**
 * Renders a Streamlit app.
 */
function AppView(props: AppViewProps): ReactElement {
  const {
    elements,
    scriptRunId,
    scriptRunState,
    widgetMgr,
    widgetsDisabled,
    uploadClient,
    componentRegistry,
    formsData,
    appLogo,
    appPages,
    navSections,
    onPageChange,
    currentPageScriptHash,
    expandSidebarNav,
    hideSidebarNav,
    sendMessageToHost,
    endpoints,
  } = props

  React.useEffect(() => {
    const listener = (): void => {
      sendMessageToHost({
        type: "UPDATE_HASH",
        hash: window.location.hash,
      })
    }
    window.addEventListener("hashchange", listener, false)
    return () => window.removeEventListener("hashchange", listener, false)
  }, [sendMessageToHost])

  const {
    wideMode,
    initialSidebarState,
    embedded,
    showPadding,
    disableScrolling,
    showToolbar,
    showColoredLine,
    sidebarChevronDownshift,
  } = React.useContext(AppContext)

  const { addScriptFinishedHandler, removeScriptFinishedHandler } =
    React.useContext(LibContext)

  const layout = wideMode ? "wide" : "narrow"
  const hasSidebarElements = !elements.sidebar.isEmpty
  const hasEventElements = !elements.event.isEmpty
  const hasBottomElements = !elements.bottom.isEmpty

  const [showSidebarOverride, setShowSidebarOverride] = React.useState(false)

  const showSidebar =
    hasSidebarElements ||
    (!hideSidebarNav && appPages.length > 1) ||
    showSidebarOverride

  React.useEffect(() => {
    // Handle sidebar flicker/unmount with MPA & hideSidebarNav
    if (showSidebar && hideSidebarNav && !showSidebarOverride) {
      setShowSidebarOverride(true)
    }
  }, [showSidebar, hideSidebarNav, showSidebarOverride])

  const scriptFinishedHandler = React.useCallback(() => {
    // Check at end of script run if no sidebar elements
    if (!hasSidebarElements && showSidebarOverride) {
      setShowSidebarOverride(false)
    }
  }, [hasSidebarElements, showSidebarOverride])

  React.useEffect(() => {
    addScriptFinishedHandler(scriptFinishedHandler)
    return () => {
      removeScriptFinishedHandler(scriptFinishedHandler)
    }
  }, [
    scriptFinishedHandler,
    addScriptFinishedHandler,
    removeScriptFinishedHandler,
  ])

  const renderLogo = (appLogo: Logo): ReactElement => {
    const displayImage = appLogo.iconImage ? appLogo.iconImage : appLogo.image
    const source = endpoints.buildMediaURL(displayImage)

    const logo = (
      <StyledLogo
        src={source}
        size={appLogo.size}
        alt="Logo"
        className="stLogo"
        data-testid="stLogo"
      />
    )

    if (appLogo.link) {
      return (
        <StyledLogoLink
          href={appLogo.link}
          target="_blank"
          rel="noreferrer"
          data-testid="stLogoLink"
        >
          {logo}
        </StyledLogoLink>
      )
    }
    return logo
  }

  // Activate scroll to bottom whenever there are bottom elements:
  const Component = hasBottomElements
    ? ScrollToBottomContainer
    : StyledAppViewMain

  const renderBlock = (node: BlockNode): ReactElement => (
    <VerticalBlock
      node={node}
      endpoints={endpoints}
      scriptRunId={scriptRunId}
      scriptRunState={scriptRunState}
      widgetMgr={widgetMgr}
      widgetsDisabled={widgetsDisabled}
      uploadClient={uploadClient}
      componentRegistry={componentRegistry}
      formsData={formsData}
    />
  )

  // The tabindex is required to support scrolling by arrow keys.
  return (
    <StyledAppViewContainer
      className="stAppViewContainer appview-container"
      data-testid="stAppViewContainer"
      data-layout={layout}
    >
      {showSidebar && (
        <Profiler id="Sidebar">
          <ThemedSidebar
            endpoints={endpoints}
            initialSidebarState={initialSidebarState}
            appLogo={appLogo}
            appPages={appPages}
            navSections={navSections}
            hasElements={hasSidebarElements}
            onPageChange={onPageChange}
            currentPageScriptHash={currentPageScriptHash}
            hideSidebarNav={hideSidebarNav}
            expandSidebarNav={expandSidebarNav}
          >
            <StyledSidebarBlockContainer>
              {renderBlock(elements.sidebar)}
            </StyledSidebarBlockContainer>
          </ThemedSidebar>
        </Profiler>
      )}
      {!showSidebar && appLogo && (
        <StyledSidebarOpenContainer
          chevronDownshift={sidebarChevronDownshift}
          data-testid="stSidebarCollapsedControl"
        >
          {renderLogo(appLogo)}
        </StyledSidebarOpenContainer>
      )}
      <Component
        tabIndex={0}
        isEmbedded={embedded}
        disableScrolling={disableScrolling}
        className="stMain"
        data-testid="stMain"
      >
        <Profiler id="Main">
          <StyledAppViewBlockContainer
            className="stMainBlockContainer block-container"
            data-testid="stMainBlockContainer"
            isWideMode={wideMode}
            showPadding={showPadding}
            addPaddingForHeader={showToolbar || showColoredLine}
            hasBottom={hasBottomElements}
            isEmbedded={embedded}
            hasSidebar={showSidebar}
          >
            {renderBlock(elements.main)}
          </StyledAppViewBlockContainer>
        </Profiler>
        {/* Anchor indicates to the iframe resizer that this is the lowest
        possible point to determine height. But we don't add an anchor if there is
        a bottom container in the app, since those two aspects don't work
        well together. */}
        {!hasBottomElements && (
          <StyledIFrameResizerAnchor
            data-testid="stAppIframeResizerAnchor"
            data-iframe-height
          />
        )}
        {hasBottomElements && (
          <Profiler id="Bottom">
            {/* We add spacing here to make sure that the sticky bottom is
           always pinned the bottom. Using sticky layout here instead of
           absolut / fixed is a trick to automatically account for the bottom
           height in the scroll area. Thereby, the bottom container will never
           cover something if you scroll to the end.*/}
            <StyledAppViewBlockSpacer />
            <StyledStickyBottomContainer
              className="stBottom"
              data-testid="stBottom"
            >
              <StyledInnerBottomContainer>
                <StyledBottomBlockContainer
                  data-testid="stBottomBlockContainer"
                  isWideMode={wideMode}
                  showPadding={showPadding}
                >
                  {renderBlock(elements.bottom)}
                </StyledBottomBlockContainer>
              </StyledInnerBottomContainer>
            </StyledStickyBottomContainer>
          </Profiler>
        )}
      </Component>
      {hasEventElements && (
        <Profiler id="Event">
          <EventContainer scriptRunId={elements.event.scriptRunId}>
            <StyledEventBlockContainer
              className="stEvent"
              data-testid="stEvent"
            >
              {renderBlock(elements.event)}
            </StyledEventBlockContainer>
          </EventContainer>
        </Profiler>
      )}
    </StyledAppViewContainer>
  )
}

export default AppView


================================================
File: /frontend/app/src/components/AppView/ScrollToBottomContainer.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, ReactNode } from "react"

import { useScrollToBottom } from "@streamlit/lib"

import { StyledAppViewMain } from "./styled-components"

export interface Props {
  className: string
  tabIndex: number
  isEmbedded: boolean
  disableScrolling: boolean
  children: ReactNode
}

export default function ScrollToBottomContainer(props: Props): ReactElement {
  const { className, tabIndex, children, isEmbedded, disableScrolling } = props
  const scrollContainerRef = useScrollToBottom()

  return (
    <StyledAppViewMain
      tabIndex={tabIndex}
      className={className}
      isEmbedded={isEmbedded}
      disableScrolling={disableScrolling}
      ref={scrollContainerRef}
      data-testid="stAppScrollToBottomContainer"
    >
      {children}
    </StyledAppViewMain>
  )
}


================================================
File: /frontend/app/src/components/AppView/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./AppView"


================================================
File: /frontend/app/src/components/AppView/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled, { CSSObject } from "@emotion/styled"

import { EmotionTheme } from "@streamlit/lib"

export const StyledAppViewContainer = styled.div({
  display: "flex",
  flexDirection: "row",
  justifyContent: "flex-start",
  alignItems: "stretch",
  alignContent: "flex-start",
  position: "absolute",
  top: 0,
  left: 0,
  right: 0,
  bottom: 0,
  overflow: "hidden",

  "@media print": {
    // print multiple pages if app is scrollable in Safari
    overflow: "visible",
  },
})

export interface StyledAppViewMainProps {
  isEmbedded: boolean
  disableScrolling: boolean
}

export const StyledAppViewMain = styled.section<StyledAppViewMainProps>(
  ({ disableScrolling, theme }) => ({
    display: "flex",
    flexDirection: "column",
    width: theme.sizes.full,
    overflow: disableScrolling ? "hidden" : "auto",
    alignItems: "center",

    "&:focus": {
      outline: "none",
    },

    // Added so sidebar overlays main app content on
    // smaller screen sizes, except when printing
    "@media not print": {
      [`@media (max-width: ${theme.breakpoints.md})`]: {
        position: "absolute",
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
      },
    },

    "@media print": {
      // print multiple pages if app is scrollable in Safari
      overflow: "visible",
    },
  })
)

export const StyledStickyBottomContainer = styled.div(({ theme }) => ({
  position: "sticky",
  left: 0,
  bottom: 0,
  width: "100%",
  zIndex: theme.zIndices.bottom,

  // move the bottom container to the end of pages in print-mode so that nothing
  // (e.g. a floating chat-input) overlays the actual app content
  "@media print": {
    position: "static",
  },
}))

export const StyledInnerBottomContainer = styled.div(({ theme }) => ({
  position: "relative",
  bottom: 0,
  width: "100%",
  minWidth: "100%",
  backgroundColor: theme.colors.bgColor,
  display: "flex",
  flexDirection: "column",
  alignItems: "center",
}))

/**
 * Adds the CSS query for wide mode.
 */
const applyWideModePadding = (theme: EmotionTheme): CSSObject => {
  return {
    // Increase side padding, if layout = wide and the screen is wide enough
    // The calculation is used to make sure that wide mode always has the same or larger
    // content compared to centered mode.
    [`@media (min-width: calc(${theme.sizes.contentMaxWidth} + 2 * (${theme.sizes.wideSidePadding} - ${theme.spacing.lg})))`]:
      {
        paddingLeft: theme.sizes.wideSidePadding,
        paddingRight: theme.sizes.wideSidePadding,
      },
    minWidth: "auto",
    maxWidth: "initial",
  }
}

export interface StyledAppViewBlockContainerProps {
  hasSidebar: boolean
  isEmbedded: boolean
  isWideMode: boolean
  showPadding: boolean
  addPaddingForHeader: boolean
  hasBottom: boolean
}

export const StyledAppViewBlockContainer =
  styled.div<StyledAppViewBlockContainerProps>(
    ({
      hasSidebar,
      hasBottom,
      isEmbedded,
      isWideMode,
      showPadding,
      addPaddingForHeader,
      theme,
    }) => {
      const littlePadding = "2.1rem"
      let topEmbedPadding: string = showPadding ? "6rem" : littlePadding
      if (
        (addPaddingForHeader && !showPadding) ||
        (isEmbedded && hasSidebar)
      ) {
        // Use parseFloat vs. calc to allow for JS unit test
        topEmbedPadding = `${
          parseFloat(theme.sizes.headerHeight) + parseFloat(theme.spacing.md)
        }rem`
      }
      const bottomEmbedPadding =
        showPadding && !hasBottom ? "10rem" : theme.spacing.lg

      return {
        width: theme.sizes.full,
        paddingLeft: theme.spacing.lg,
        paddingRight: theme.spacing.lg,
        paddingTop: topEmbedPadding,
        paddingBottom: bottomEmbedPadding,
        maxWidth: theme.sizes.contentMaxWidth,
        ...(isWideMode && applyWideModePadding(theme)),
        [`@media print`]: {
          paddingTop: littlePadding,
        },
      }
    }
  )

export const StyledSidebarBlockContainer = styled.div(({ theme }) => {
  return {
    width: theme.sizes.full,
  }
})

export const StyledEventBlockContainer = styled.div({
  display: "none",
})

export interface StyledBottomBlockContainerProps {
  isWideMode: boolean
  showPadding: boolean
}

export const StyledBottomBlockContainer =
  styled.div<StyledBottomBlockContainerProps>(
    ({ isWideMode, showPadding, theme }) => {
      return {
        width: theme.sizes.full,
        paddingLeft: theme.spacing.lg,
        paddingRight: theme.spacing.lg,
        paddingTop: theme.spacing.lg,
        paddingBottom: showPadding
          ? theme.sizes.appDefaultBottomPadding
          : theme.spacing.threeXL,
        maxWidth: theme.sizes.contentMaxWidth,
        ...(isWideMode && applyWideModePadding(theme)),
        [`@media print`]: {
          paddingTop: theme.spacing.none,
        },
      }
    }
  )

export const StyledAppViewBlockSpacer = styled.div(({ theme }) => {
  return {
    width: theme.sizes.full,
    flexGrow: 1,
  }
})

export const StyledIFrameResizerAnchor = styled.div(({ theme }) => ({
  position: "relative",
  bottom: theme.spacing.none,
}))


================================================
File: /frontend/app/src/components/Countdown/Countdown.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib"

import Countdown from "./Countdown"

describe("Countdown Component", () => {
  it("should render without crashing", () => {
    render(<Countdown countdown={10} />)
    const countdownElement = screen.getByText("10")

    expect(countdownElement).toBeVisible()
  })
})


================================================
File: /frontend/app/src/components/Countdown/Countdown.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { useState } from "react"

import { StyledCountdown } from "./styled-components"

interface Props {
  countdown: number
  endCallback: () => void
}

const Countdown: React.FC<Props> = ({ countdown, endCallback }) => {
  const [currentCountdown, setCurrentCountdown] = useState(countdown)

  const onAnimationEnd = (): void => {
    const newCountdown = currentCountdown - 1

    if (newCountdown >= 0) {
      setCurrentCountdown(newCountdown)
    }

    if (newCountdown === 0) {
      endCallback()
    }
  }

  return (
    <StyledCountdown
      data-testid="stCountdown"
      onAnimationEnd={onAnimationEnd}
      key={`frame${currentCountdown}`}
    >
      {/* The key forces DOM mutations, for animation to restart. */}
      <span>{currentCountdown}</span>
    </StyledCountdown>
  )
}

export default Countdown


================================================
File: /frontend/app/src/components/Countdown/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Countdown"


================================================
File: /frontend/app/src/components/Countdown/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"
import { keyframes } from "@emotion/react"

const screencastCounterAnimation = keyframes`
0% {
  opacity: 0;
}
25% {
  opacity: 1;
}
100% {
  opacity: 0;
}`

export const StyledCountdown = styled.div(({ theme }) => ({
  position: "fixed",
  display: "flex",
  justifyContent: "center",
  alignItems: "center",
  top: 0,
  left: 0,
  width: theme.sizes.full,
  height: theme.sizes.full,
  fontSize: "40vh",
  color: theme.colors.red,
  fontWeight: theme.fontWeights.bold,
  opacity: "0.8",
  textShadow: `1px 1px 10px ${theme.colors.darkGray}`,
  transition: "opacity 0.3s ease-in-out",
  animation: `${screencastCounterAnimation} 1s`,
}))


================================================
File: /frontend/app/src/components/DeployButton/DeployButton.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, MouseEvent } from "react"

import { BaseButton, BaseButtonKind } from "@streamlit/lib"

import { DeployButtonContainer } from "./styled-components"

interface IDeployButtonProps {
  onClick: (event: MouseEvent<HTMLButtonElement>) => any
}

const DeployButton: FC<IDeployButtonProps> = ({ onClick }) => {
  return (
    <div className="stAppDeployButton" data-testid="stAppDeployButton">
      <BaseButton kind={BaseButtonKind.HEADER_BUTTON} onClick={onClick}>
        <DeployButtonContainer>
          <span>Deploy</span>
        </DeployButtonContainer>
      </BaseButton>
    </div>
  )
}

export default DeployButton


================================================
File: /frontend/app/src/components/DeployButton/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import DeployButton from "./DeployButton"

export default DeployButton


================================================
File: /frontend/app/src/components/DeployButton/styled-components.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const DeployButtonContainer = styled.div(({ theme }) => ({
  display: "flex",
  gap: theme.spacing.sm,
  alignItems: "center",
  lineHeight: theme.iconSizes.md,
}))


================================================
File: /frontend/app/src/components/EventContainer/EventContainer.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib"

import EventContainer from "./EventContainer"

describe("EventContainer Component", () => {
  test("renders Toast Container", () => {
    render(<EventContainer scriptRunId="123" />)

    const toastContainer = screen.getByTestId("stToastContainer")
    expect(toastContainer).toBeInTheDocument()
    expect(toastContainer).toHaveClass("stToastContainer")
  })
})


================================================
File: /frontend/app/src/components/EventContainer/EventContainer.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, ReactNode, useEffect } from "react"

import { PLACEMENT, toaster, ToasterContainer } from "baseui/toast"
import { useTheme } from "@emotion/react"

import { EmotionTheme } from "@streamlit/lib"

export interface EventContainerProps {
  scriptRunId: string
  children?: ReactNode
}

function EventContainer({
  scriptRunId,
  children,
}: Readonly<EventContainerProps>): ReactElement {
  const theme: EmotionTheme = useTheme()

  useEffect(() => {
    // Ensure all toasts cleared on script re-run
    toaster.getRef()?.clearAll()
  }, [scriptRunId])

  return (
    <>
      <ToasterContainer
        placement={PLACEMENT.topRight}
        autoHideDuration={4 * 1000} // in milliseconds
        overrides={{
          Root: {
            style: {
              // Avoids blocking the header
              top: theme.sizes.headerHeight,
              zIndex: theme.zIndices.toast,
            },
            props: {
              "data-testid": "stToastContainer",
              className: "stToastContainer",
            },
          },
        }}
      />
      {children}
    </>
  )
}

export default EventContainer


================================================
File: /frontend/app/src/components/EventContainer/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./EventContainer"


================================================
File: /frontend/app/src/components/FontFaceDeclaration/FontFaceDeclaration.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { css, Global } from "@emotion/react"

export interface FontFaceDeclarationProps {
  fontFaces: object[]
}

const FontFaceDeclaration = ({
  fontFaces,
}: FontFaceDeclarationProps): ReactElement => {
  const fontMarkup = fontFaces.map((font: any) => {
    const { family, weight, url } = font

    return `
      @font-face {
        font-family: ${family};
        font-weight: ${weight};
        font-style: normal;
        font-display: swap;
        src: url(${url}) format("woff2");
      }
    `
  })

  return (
    <Global
      styles={css`
        ${fontMarkup}
      `}
    />
  )
}

export default FontFaceDeclaration


================================================
File: /frontend/app/src/components/FontFaceDeclaration/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./FontFaceDeclaration"


================================================
File: /frontend/app/src/components/Header/Header.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, ReactNode } from "react"

import { AppContext } from "@streamlit/app/src/components/AppContext"

import {
  StyledHeader,
  StyledHeaderDecoration,
  StyledHeaderToolbar,
} from "./styled-components"

export interface HeaderProps {
  children: ReactNode
  isStale?: boolean
}

function Header({ isStale, children }: Readonly<HeaderProps>): ReactElement {
  const { wideMode, embedded, showToolbar, showColoredLine } =
    React.useContext(AppContext)

  let showHeader = true
  if (embedded) {
    showHeader = showToolbar || showColoredLine
  }
  return (
    <StyledHeader
      showHeader={showHeader}
      isWideMode={wideMode}
      // The tabindex below is required for testing.
      tabIndex={-1}
      isStale={isStale}
      className="stAppHeader"
      data-testid="stHeader"
    >
      {showColoredLine && (
        <StyledHeaderDecoration
          className="stDecoration"
          data-testid="stDecoration"
          id="stDecoration"
        />
      )}
      {showToolbar && (
        <StyledHeaderToolbar className="stAppToolbar" data-testid="stToolbar">
          {children}
        </StyledHeaderToolbar>
      )}
    </StyledHeader>
  )
}

export default Header


================================================
File: /frontend/app/src/components/Header/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Header"


================================================
File: /frontend/app/src/components/Header/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export interface StyledHeaderProps {
  showHeader: boolean
  isWideMode: boolean
  isStale?: boolean
}

export const StyledHeader = styled.header<StyledHeaderProps>(
  ({ showHeader, theme }) => ({
    position: "fixed",
    top: theme.spacing.none,
    left: theme.spacing.none,
    right: theme.spacing.none,
    height: theme.sizes.headerHeight,
    background: theme.colors.bgColor,
    outline: "none",
    zIndex: theme.zIndices.header,
    display: showHeader ? "block" : "none",
    "@media print": {
      display: "none",
    },
  })
)

export const StyledHeaderDecoration = styled.div(({ theme }) => ({
  position: "absolute",
  top: theme.spacing.none,
  right: theme.spacing.none,
  left: theme.spacing.none,
  height: theme.sizes.headerDecorationHeight,
  backgroundImage: `linear-gradient(90deg, ${theme.colors.red70}, #fffd80)`,
  zIndex: theme.zIndices.header,
}))

export const StyledHeaderToolbar = styled.div(({ theme }) => ({
  position: "absolute",
  top: theme.spacing.xl,
  right: theme.spacing.xl,
  display: "flex",
  flexDirection: "row",
  alignItems: "center",
}))


================================================
File: /frontend/app/src/components/MainMenu/MainMenu.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen, within } from "@testing-library/react"

import { Config, IMenuItem, mockSessionInfo, render } from "@streamlit/lib"
import { MetricsManager } from "@streamlit/app/src/MetricsManager"

import { getMenuStructure, openMenu } from "./mainMenuTestHelpers"
import MainMenu, { Props } from "./MainMenu"

const getProps = (extend?: Partial<Props>): Props => ({
  aboutCallback: vi.fn(),
  printCallback: vi.fn(),
  clearCacheCallback: vi.fn(),
  isServerConnected: true,
  quickRerunCallback: vi.fn(),
  hostMenuItems: [],
  screencastCallback: vi.fn(),
  screenCastState: "",
  sendMessageToHost: vi.fn(),
  settingsCallback: vi.fn(),
  menuItems: {},
  developmentMode: true,
  metricsMgr: new MetricsManager(mockSessionInfo()),
  toolbarMode: Config.ToolbarMode.AUTO,
  ...extend,
})

describe("MainMenu", () => {
  beforeEach(() => {
    // BaseWeb uses timers under the hood. We simplify by using fake timers.
    vi.useFakeTimers()
  })

  it("renders without crashing", () => {
    const props = getProps()
    render(<MainMenu {...props} />)

    expect(screen.getByTestId("stMainMenu")).toBeInTheDocument()
  })

  it("should render host menu items", () => {
    const items: IMenuItem[] = [
      {
        type: "separator",
      },
      {
        type: "text",
        label: "View app source",
        key: "source",
      },
      {
        type: "text",
        label: "Report bug with app",
        key: "support",
      },
      {
        type: "separator",
      },
    ]
    const props = getProps({
      hostMenuItems: items,
    })
    render(<MainMenu {...props} />)
    openMenu(screen)

    const menuOptions = screen.getAllByRole("option")

    const expectedLabels = [
      "Rerun",
      "Settings",
      "Print",
      "View app source",
      "Report bug with app",
      "About",
      "Developer options",
      "Clear cache",
    ]

    expectedLabels.forEach((label, index) => {
      expect(menuOptions[index]).toHaveTextContent(label)
    })
  })

  it("should render core set of menu elements", () => {
    const props = getProps()
    render(<MainMenu {...props} />)
    openMenu(screen)

    const menuOptions = screen.getAllByRole("option")

    const expectedLabels = [
      "Rerun",
      "Settings",
      "Print",
      "About",
      "Developer options",
      "Clear cache",
    ]

    expectedLabels.forEach((label, index) => {
      expect(menuOptions[index]).toHaveTextContent(label)
    })
  })

  it("should not render set of configurable elements", () => {
    const menuItems = {
      hideGetHelp: true,
      hideReportABug: true,
      aboutSectionMd: "",
    }
    const props = getProps({ menuItems })
    render(<MainMenu {...props} />)
    openMenu(screen)

    // first SubMenu (menu items, not dev menu items)
    const coreMenu = screen.getAllByTestId("stMainMenuList")[0]

    const coreMenuOptions = within(coreMenu).getAllByRole("option")
    expect(coreMenuOptions).toHaveLength(4)

    const expectedLabels = ["Rerun", "Settings", "Print", "About"]
    coreMenuOptions.forEach((option, index) => {
      expect(option).toHaveTextContent(expectedLabels[index])
    })
  })

  it("should not render report a bug in core menu", () => {
    const menuItems = {
      getHelpUrl: "testing",
      hideGetHelp: false,
      hideReportABug: true,
      aboutSectionMd: "",
    }
    const props = getProps({ menuItems })
    render(<MainMenu {...props} />)
    openMenu(screen)

    expect(screen.queryByRole("option", { name: "Report a bug" })).toBeNull()
  })

  it("should render report a bug in core menu", () => {
    const menuItems = {
      reportABugUrl: "testing",
      hideGetHelp: false,
      hideReportABug: false,
      aboutSectionMd: "",
    }
    const props = getProps({ menuItems })
    render(<MainMenu {...props} />)
    openMenu(screen)

    const reportOption = screen.getByRole("option", {
      name: "Report a bug",
    })
    expect(reportOption).toBeDefined()
  })

  it("should not render dev menu when developmentMode is false", () => {
    const props = getProps({ developmentMode: false })
    render(<MainMenu {...props} />)
    openMenu(screen)

    const subMenus = screen.getAllByTestId("stMainMenuList")
    // Make sure there is only one SubMenu (no dev menu)
    expect(subMenus).toHaveLength(1)

    const coreMenuOptions = within(subMenus[0]).getAllByRole("option")
    expect(coreMenuOptions).toHaveLength(4)

    const expectedLabels = ["Rerun", "Settings", "Print", "About"]
    coreMenuOptions.forEach((option, index) => {
      expect(option).toHaveTextContent(expectedLabels[index])
    })
  })

  it.each([
    [Config.ToolbarMode.AUTO],
    [Config.ToolbarMode.DEVELOPER],
    [Config.ToolbarMode.VIEWER],
    [Config.ToolbarMode.MINIMAL],
  ])("should render host menu items if available[%s]", toolbarMode => {
    const props = getProps({
      toolbarMode,
      hostMenuItems: [
        { label: "Host menu item", key: "host-item", type: "text" },
      ],
    })
    const view = render(<MainMenu {...props} />)
    openMenu(screen)

    const menuStructure = getMenuStructure(view)
    expect(menuStructure[0]).toContainEqual({
      type: "option",
      label: "Host menu item",
    })
  })

  it("should hide main menu when toolbarMode is Minimal and no host items", () => {
    const props = getProps({
      developmentMode: false,
      toolbarMode: Config.ToolbarMode.MINIMAL,
      hostMenuItems: [],
    })

    render(<MainMenu {...props} />)

    expect(screen.queryByRole("button")).toBeNull()
  })

  it("should skip divider from host menu items if it is at the beginning and end", () => {
    const props = getProps({
      developmentMode: false,
      toolbarMode: Config.ToolbarMode.MINIMAL,
      hostMenuItems: [
        { type: "separator" },
        { type: "text", label: "View all apps", key: "viewAllApps" },
        { type: "separator" },
        { type: "text", label: "About Streamlit Cloud", key: "about" },
        { type: "separator" },
      ],
    })
    const view = render(<MainMenu {...props} />)
    openMenu(screen)

    const menuStructure = getMenuStructure(view)
    expect(menuStructure).toEqual([
      [{ type: "option", label: "View all apps" }],
    ])
  })

  it.each([
    [
      ["getHelpUrl", "reportABugUrl", "aboutSectionMd"],
      [
        {
          label: "Report a bug",
          type: "option",
        },
        {
          label: "Get help",
          type: "option",
        },
        {
          type: "separator",
        },
        {
          label: "About",
          type: "option",
        },
      ],
    ],
    [
      ["getHelpUrl"],
      [
        {
          label: "Get help",
          type: "option",
        },
      ],
    ],
    [
      ["reportABugUrl"],
      [
        {
          label: "Report a bug",
          type: "option",
        },
      ],
    ],
    [
      ["aboutSectionMd"],
      [
        {
          label: "About",
          type: "option",
        },
      ],
    ],
  ])(
    "should render custom items in minimal mode[%s]",
    (menuItems, expectedMenuItems) => {
      const allMenuItems = {
        getHelpUrl: "https://www.extremelycoolapp.com/help",
        reportABugUrl: "https://www.extremelycoolapp.com/bug",
        aboutSectionMd: "# This is a header. This is an *extremely* cool app!",
      }
      const props = getProps({
        developmentMode: false,
        toolbarMode: Config.ToolbarMode.MINIMAL,
        menuItems: Object.fromEntries(
          Object.entries(allMenuItems).filter(d => menuItems.includes(d[0]))
        ),
      })

      const view = render(<MainMenu {...props} />)
      openMenu(screen)

      const menuStructure = getMenuStructure(view)
      expect(menuStructure).toEqual([expectedMenuItems])
    }
  )

  it("should render host menu items and custom items in minimal mode", () => {
    const props = getProps({
      developmentMode: false,
      toolbarMode: Config.ToolbarMode.MINIMAL,
      hostMenuItems: [
        { type: "separator" },
        { type: "text", label: "View all apps", key: "viewAllApps" },
        { type: "separator" },
        { type: "text", label: "About Streamlit Cloud", key: "about" },
        { type: "separator" },
      ],
      menuItems: {
        getHelpUrl: "https://www.extremelycoolapp.com/help",
        reportABugUrl: "https://www.extremelycoolapp.com/bug",
        aboutSectionMd: "# This is a header. This is an *extremely* cool app!",
      },
    })
    const view = render(<MainMenu {...props} />)
    openMenu(screen)

    const menuStructure = getMenuStructure(view)
    expect(menuStructure).toEqual([
      [
        {
          label: "Report a bug",
          type: "option",
        },
        {
          label: "Get help",
          type: "option",
        },
        {
          type: "separator",
        },
        {
          label: "View all apps",
          type: "option",
        },
        {
          type: "separator",
        },
        {
          label: "About",
          type: "option",
        },
      ],
    ])
  })
})


================================================
File: /frontend/app/src/components/MainMenu/MainMenu.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { forwardRef, memo, MouseEvent, ReactElement } from "react"

import { StatefulMenu } from "baseui/menu"
import { PLACEMENT, StatefulPopover } from "baseui/popover"
import { MoreVert } from "@emotion-icons/material-rounded"
import { useTheme } from "@emotion/react"

import {
  BaseButton,
  BaseButtonKind,
  Config,
  EmotionTheme,
  Icon,
  IGuestToHostMessage,
  IMenuItem,
  notNullOrUndefined,
  PageConfig,
} from "@streamlit/lib"
import ScreenCastRecorder from "@streamlit/app/src/util/ScreenCastRecorder"
import { MetricsManager } from "@streamlit/app/src/MetricsManager"

import {
  StyledCoreItem,
  StyledDevItem,
  StyledMainMenuContainer,
  StyledMenuContainer,
  StyledMenuDivider,
  StyledMenuItem,
  StyledMenuItemLabel,
  StyledMenuItemShortcut,
  StyledRecordingIndicator,
} from "./styled-components"

const SCREENCAST_LABEL: { [s: string]: string } = {
  COUNTDOWN: "Cancel screencast",
  RECORDING: "Stop recording",
}

export interface Props {
  /** True if we're connected to the Streamlit server. */
  isServerConnected: boolean

  /** Rerun the current script. */
  quickRerunCallback: () => void

  /** Clear the cache. */
  clearCacheCallback: () => void

  /** Show the screen recording dialog. */
  screencastCallback: () => void

  /** Show the Settings dialog. */
  settingsCallback: () => void

  /** Show the About dialog. */
  aboutCallback: () => void

  /** Open the Print Dialog, if the app is in iFrame first open a new tab with app URL */
  printCallback: () => void

  screenCastState: string

  hostMenuItems: IMenuItem[]

  sendMessageToHost: (message: IGuestToHostMessage) => void

  menuItems?: PageConfig.IMenuItems | null

  developmentMode: boolean

  toolbarMode: Config.ToolbarMode

  metricsMgr: MetricsManager
}

const getOpenInWindowCallback = (url: string) => (): void => {
  window.open(url, "_blank")
}

export const isLocalhost = (): boolean => {
  return (
    window.location.hostname === "localhost" ||
    window.location.hostname === "127.0.0.1"
  )
}

export interface MenuItemProps {
  item: any
  "aria-selected": boolean
  onClick: (e: MouseEvent<HTMLLIElement>) => void
  onMouseEnter: (e: MouseEvent<HTMLLIElement>) => void
  $disabled: boolean
  $isHighlighted: boolean
}

export interface SubMenuProps {
  menuItems: any[]
  closeMenu: () => void
  isDevMenu: boolean
  metricsMgr: MetricsManager
}

// BaseWeb provides a very basic list item (or option) for its dropdown
// menus. We want to customize it to our liking. We want to support:
//  * Shortcuts
//  * Red coloring for the stop recording
//  * Dividers (There's no special MenuListItem divider, so items have
//    a hasDividerAbove property to add the border properly.
// Unfortunately, because we are overriding the component, we need to
// implement some of the built in-features, namely:
//  * A11y for selected and disabled
//  * $disabled field (BaseWeb does not use CSS :disabled here)
//  * $isHighlighted field (BaseWeb does not use CSS :hover here)
//  * creating a forward ref to add properties to the DOM element.
function buildMenuItemComponent(
  StyledMenuItemType: typeof StyledCoreItem | typeof StyledDevItem,
  metricsMgr: MetricsManager
): any {
  const MenuItem = forwardRef<HTMLLIElement, MenuItemProps>(
    (
      {
        item,
        "aria-selected": ariaSelected,
        onClick,
        onMouseEnter,
        $disabled,
        $isHighlighted,
      },
      ref
    ) => {
      const {
        label,
        shortcut,
        hasDividerAbove,
        styleProps,
        noHighlight,
        interactions,
      } = item
      const itemProps = {
        isDisabled: $disabled,
        isRecording: Boolean(item.stopRecordingIndicator),
      }
      const itemStyleProps = {
        isHighlighted: !noHighlight && $isHighlighted,
        styleProps,
      }
      const interactiveProps =
        interactions ||
        ($disabled
          ? {}
          : {
              onClick: (e: MouseEvent<HTMLLIElement>) => {
                metricsMgr.enqueue("menuClick", {
                  label,
                })
                onClick(e)
              },
              onMouseEnter,
            })

      return (
        <>
          {hasDividerAbove && (
            <StyledMenuDivider data-testid="stMainMenuDivider" />
          )}
          <StyledMenuItem
            ref={ref}
            role="option"
            aria-selected={ariaSelected}
            aria-disabled={$disabled}
            {...itemProps}
            {...interactiveProps}
          >
            <StyledMenuItemType {...itemStyleProps}>
              <StyledMenuItemLabel {...itemProps}>{label}</StyledMenuItemLabel>
              {shortcut && (
                <StyledMenuItemShortcut {...itemProps}>
                  {shortcut}
                </StyledMenuItemShortcut>
              )}
            </StyledMenuItemType>
          </StyledMenuItem>
        </>
      )
    }
  )
  MenuItem.displayName = "MenuItem"
  return MenuItem
}

const SubMenu = (props: SubMenuProps): ReactElement => {
  const { colors, sizes, spacing }: EmotionTheme = useTheme()
  const StyledMenuItemType = props.isDevMenu ? StyledDevItem : StyledCoreItem

  return (
    <StatefulMenu
      items={props.menuItems}
      onItemSelect={({ item }) => {
        item.onClick()
        props.closeMenu()
      }}
      overrides={{
        Option: buildMenuItemComponent(StyledMenuItemType, props.metricsMgr),
        List: {
          props: {
            "data-testid": "stMainMenuList",
          },
          style: {
            backgroundColor: "inherit",

            borderBottomRadius: 0,
            borderTopRadius: 0,
            borderLeftRadius: 0,
            borderRightRadius: 0,

            paddingBottom: spacing.sm,
            paddingTop: spacing.sm,

            ":focus": {
              outline: "none",
            },
            border: `${sizes.borderWidth} solid ${colors.borderColor}`,
          },
        },
      }}
    />
  )
}

function getDevMenuItems(
  theme: EmotionTheme,
  coreDevMenuItems: Record<string, any>
): any[] {
  const devMenuItems = []
  const preferredDevMenuOrder: any[] = [
    coreDevMenuItems.developerOptions,
    coreDevMenuItems.clearCache,
  ]

  let devLastMenuItem = null

  for (const devMenuItem of preferredDevMenuOrder) {
    if (devMenuItem) {
      if (devMenuItem !== coreDevMenuItems.DIVIDER) {
        if (devLastMenuItem === coreDevMenuItems.DIVIDER) {
          devMenuItems.push({ ...devMenuItem, hasDividerAbove: true })
        } else {
          devMenuItems.push(devMenuItem)
        }
      }

      devLastMenuItem = devMenuItem
    }
  }

  if (notNullOrUndefined(devLastMenuItem)) {
    devLastMenuItem.styleProps = {
      margin: `0 0 -${theme.spacing.sm} 0`,
      padding: `${theme.spacing.twoXS} ${theme.spacing.none} ${theme.spacing.twoXS} ${theme.spacing.twoXL}`,
    }
  }
  return devMenuItems
}

function getPreferredMenuOrder(
  props: Props,
  hostMenuItems: any[],
  coreMenuItems: Record<string, any>
): any[] {
  let preferredMenuOrder: any[]
  if (props.toolbarMode == Config.ToolbarMode.MINIMAL) {
    // If toolbar mode == minimal then show only host menu items if any.
    preferredMenuOrder = [
      coreMenuItems.report,
      coreMenuItems.community,
      coreMenuItems.DIVIDER,
      ...(hostMenuItems.length > 0 ? hostMenuItems : [coreMenuItems.DIVIDER]),
      coreMenuItems.about,
    ]

    preferredMenuOrder = preferredMenuOrder.filter(d => d)
    // If the first or last item is a divider, delete it, because
    // we don't want to start/end the menu with it.
    // TODO(sfc-gh-kbregula): We should use Array#at when supported by
    //  browsers or transpilers.
    //  See: https://github.com/tc39/proposal-relative-indexing-method
    while (
      preferredMenuOrder.length > 0 &&
      preferredMenuOrder[0] == coreMenuItems.DIVIDER
    ) {
      preferredMenuOrder.shift()
    }
    while (
      preferredMenuOrder.length > 0 &&
      preferredMenuOrder.at(preferredMenuOrder.length - 1) ==
        coreMenuItems.DIVIDER
    ) {
      preferredMenuOrder.pop()
    }
    return preferredMenuOrder
  }
  return [
    coreMenuItems.rerun,
    coreMenuItems.settings,
    coreMenuItems.DIVIDER,
    coreMenuItems.print,
    ...(ScreenCastRecorder.isSupportedBrowser()
      ? [coreMenuItems.recordScreencast]
      : []),
    coreMenuItems.DIVIDER,
    coreMenuItems.report,
    coreMenuItems.community,
    ...(hostMenuItems.length > 0 ? hostMenuItems : [coreMenuItems.DIVIDER]),
    coreMenuItems.about,
  ]
}

function MainMenu(props: Readonly<Props>): ReactElement {
  const theme: EmotionTheme = useTheme()

  const isServerDisconnected = !props.isServerConnected

  const showAboutMenu =
    props.toolbarMode != Config.ToolbarMode.MINIMAL ||
    (props.toolbarMode == Config.ToolbarMode.MINIMAL &&
      props.menuItems?.aboutSectionMd)

  const coreMenuItems = {
    DIVIDER: { isDivider: true },
    rerun: {
      disabled: isServerDisconnected,
      onClick: props.quickRerunCallback,
      label: "Rerun",
      shortcut: "r",
    },
    print: { onClick: props.printCallback, label: "Print" },
    recordScreencast: {
      onClick: props.screencastCallback,
      label: SCREENCAST_LABEL[props.screenCastState] || "Record a screencast",
      shortcut: SCREENCAST_LABEL[props.screenCastState] ? "esc" : "",
      stopRecordingIndicator: Boolean(SCREENCAST_LABEL[props.screenCastState]),
    },
    saveSnapshot: {
      disabled: isServerDisconnected,
      label: "Save a snapshot",
    },
    ...(!props.menuItems?.hideGetHelp &&
      props.menuItems?.getHelpUrl && {
        community: {
          onClick: getOpenInWindowCallback(props.menuItems?.getHelpUrl),
          label: "Get help",
        },
      }),
    ...(!props.menuItems?.hideReportABug &&
      props.menuItems?.reportABugUrl && {
        report: {
          onClick: getOpenInWindowCallback(props.menuItems?.reportABugUrl),
          label: "Report a bug",
        },
      }),
    settings: { onClick: props.settingsCallback, label: "Settings" },
    ...(showAboutMenu && {
      about: { onClick: props.aboutCallback, label: "About" },
    }),
  }

  const coreDevMenuItems = {
    DIVIDER: { isDivider: true },
    developerOptions: {
      label: "Developer options",
      noHighlight: true,
      interactions: {},
      styleProps: {
        fontSize: theme.fontSizes.twoSmPx,
        margin: `-${theme.spacing.sm} 0 0 0`,
        padding: `${theme.spacing.twoXS} ${theme.spacing.none} ${theme.spacing.twoXS} ${theme.spacing.twoXL}`,
        pointerEvents: "none",
      },
    },
    clearCache: {
      disabled: isServerDisconnected,
      onClick: props.clearCacheCallback,
      label: "Clear cache",
      shortcut: "c",
    },
  }

  const hostMenuItems = props.hostMenuItems.map(item => {
    if (item.type === "separator") {
      return coreMenuItems.DIVIDER
    }

    if (item.key === "reportBug" && props.menuItems?.hideGetHelp) {
      return null
    }

    if (item.key === "about" && props.menuItems?.aboutSectionMd !== "") {
      return null
    }

    return {
      onClick: () =>
        props.sendMessageToHost({
          type: "MENU_ITEM_CALLBACK",
          key: item.key,
        }),
      label: item.label,
    }
  }, [] as any[])

  const preferredMenuOrder = getPreferredMenuOrder(
    props,
    hostMenuItems,
    coreMenuItems
  )

  // Remove empty entries, and add dividers into menu options as needed.
  const menuItems: any[] = []
  let lastMenuItem = null
  for (const menuItem of preferredMenuOrder) {
    if (menuItem) {
      if (menuItem !== coreMenuItems.DIVIDER) {
        if (lastMenuItem === coreMenuItems.DIVIDER) {
          menuItems.push({ ...menuItem, hasDividerAbove: true })
        } else {
          menuItems.push(menuItem)
        }
      }

      lastMenuItem = menuItem
    }
  }

  const devMenuItems: any[] = props.developmentMode
    ? getDevMenuItems(theme, coreDevMenuItems)
    : []

  if (menuItems.length == 0 && devMenuItems.length == 0) {
    // Don't show an empty menu.
    return <></>
  }

  return (
    <StatefulPopover
      focusLock
      placement={PLACEMENT.bottomRight}
      content={({ close }) => (
        <StyledMenuContainer>
          {menuItems.length != 0 && (
            <SubMenu
              menuItems={menuItems}
              closeMenu={close}
              isDevMenu={false}
              metricsMgr={props.metricsMgr}
            />
          )}
          {devMenuItems.length != 0 && (
            <SubMenu
              menuItems={devMenuItems}
              closeMenu={close}
              isDevMenu={true}
              metricsMgr={props.metricsMgr}
            />
          )}
        </StyledMenuContainer>
      )}
      overrides={{
        Body: {
          props: {
            "data-testid": "stMainMenuPopover",
            className: "stMainMenuPopover",
          },
        },
      }}
    >
      <StyledMainMenuContainer
        id="MainMenu"
        className="stMainMenu"
        data-testid="stMainMenu"
      >
        <BaseButton kind={BaseButtonKind.HEADER_NO_PADDING}>
          <Icon content={MoreVert} size="lg" />
        </BaseButton>
        {props.screenCastState === "RECORDING" && <StyledRecordingIndicator />}
      </StyledMainMenuContainer>
    </StatefulPopover>
  )
}

export default memo(MainMenu)


================================================
File: /frontend/app/src/components/MainMenu/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default, isLocalhost } from "./MainMenu"


================================================
File: /frontend/app/src/components/MainMenu/mainMenuTestHelpers.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable import/no-extraneous-dependencies */
import { fireEvent, RenderResult, Screen } from "@testing-library/react"

export function openMenu(screen: Screen): void {
  fireEvent.click(screen.getByRole("button"))
  // Each SubMenu is a listbox, so need to use findAllByRole (findByRole throws error if multiple matches)
  vi.runOnlyPendingTimers()
  const menu = screen.getAllByRole("listbox")
  expect(menu).toBeDefined()
}

export function getMenuStructure(
  renderResult: RenderResult
): ({ type: "separator" } | { type: "option"; label: string })[][] {
  return Array.from(
    renderResult.baseElement.querySelectorAll('[role="listbox"]')
  ).map(listBoxElement => {
    return Array.from(
      listBoxElement.querySelectorAll(
        '[role=option] span:first-of-type, [data-testid="stMainMenuDivider"]'
      )
    ).map(d =>
      d.getAttribute("data-testid") == "stMainMenuDivider"
        ? { type: "separator" }
        : { type: "option", label: d.textContent as string }
    )
  })
}


================================================
File: /frontend/app/src/components/MainMenu/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { keyframes } from "@emotion/react"
import { Keyframes } from "@emotion/serialize"
import styled from "@emotion/styled"
import { transparentize } from "color2k"

import { EmotionTheme } from "@streamlit/lib"

const recordingIndicatorPulse = (theme: EmotionTheme): Keyframes => keyframes`
0% {
  box-shadow: 0 0 ${theme.spacing.twoXS} ${theme.colors.red};
}
50% {
  box-shadow: 0 0 ${theme.spacing.sm} ${theme.spacing.twoXS} ${theme.colors.red};
}
100% {
  box-shadow: 0 0 ${theme.spacing.twoXS} ${theme.colors.red};
}`

export const StyledRecordingIndicator = styled.div(({ theme }) => ({
  position: "absolute",
  bottom: theme.spacing.lg,
  right: theme.spacing.sm,
  width: theme.spacing.sm,
  height: theme.spacing.sm,
  backgroundColor: theme.colors.red,
  borderRadius: theme.radii.full,
  boxShadow: `0 0 ${theme.spacing.twoXS} ${theme.colors.red}`,
  animation: `${recordingIndicatorPulse(theme)} 2s linear infinite`,
}))

export const StyledMenuDivider = styled.div(({ theme }) => ({
  borderTop: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
  margin: `${theme.spacing.sm} ${theme.spacing.none}`,
}))

export interface ItemProps {
  isDisabled: boolean
  isRecording: boolean
}

export interface ItemStyleProps {
  isHighlighted: boolean
  styleProps?: React.CSSProperties
}

export const StyledMenuItemShortcut = styled.span<ItemProps>(
  ({ isRecording, theme }) => {
    return {
      color: isRecording ? theme.colors.red : theme.colors.fadedText60,
      fontSize: theme.fontSizes.sm,
      marginTop: theme.spacing.twoXS,
      fontVariant: "small-caps",
      textTransform: "uppercase",
    }
  }
)

export const StyledMenuItem = styled.ul<ItemProps>(
  ({ isDisabled, isRecording, theme }) => {
    const disabledStyles = isDisabled
      ? {
          backgroundColor: theme.colors.transparent,
          color: theme.colors.fadedText60,
          cursor: "not-allowed",
        }
      : {
          "&:focus": {
            backgroundColor: theme.colors.primary,
            color: theme.colors.white,
          },
        }

    const recordingStyles = isRecording && {
      color: theme.colors.red,
      fontWeight: theme.fontWeights.bold,
    }

    return {
      display: "block",
      flexDirection: "row",
      alignItems: "flex-start",
      padding: theme.spacing.none,
      cursor: "pointer",
      ...(recordingStyles || {}),
      ...disabledStyles,
      "@media print": {
        display: "none !important",
      },
    }
  }
)

export const StyledCoreItem = styled.li<ItemStyleProps>(
  ({ isHighlighted, styleProps, theme }) => {
    const highlightedStyles = isHighlighted && {
      "&:hover": {
        backgroundColor: theme.colors.secondaryBg,
      },
    }

    const margin = styleProps?.margin || 0
    const padding =
      styleProps?.padding || `${theme.spacing.twoXS} ${theme.spacing.twoXL}`
    const backgroundColor =
      styleProps?.backgroundColor || theme.colors.primaryBg
    const fontSize = styleProps?.fontSize || theme.fontSizes.md

    return {
      margin,
      padding,
      backgroundColor,
      fontSize,
      ...(highlightedStyles || {}),
      display: "block",
    }
  }
)

export const StyledDevItem = styled.li<ItemStyleProps>(
  ({ isHighlighted, styleProps, theme }) => {
    const highlightedStyles = isHighlighted && {
      "&:hover": {
        // Whatever color we use here as the hover state, we want to transparentize it
        // to its full extend, so you can see the underlying color of the menu.
        backgroundColor: transparentize(theme.colors.secondaryBg, 1),
      },
    }
    const margin = styleProps?.margin || 0
    const padding =
      styleProps?.padding || `${theme.spacing.twoXS} ${theme.spacing.twoXL}`
    const backgroundColor =
      styleProps?.backgroundColor || theme.colors.secondaryBg
    const fontSize = styleProps?.fontSize || theme.fontSizes.md
    return {
      margin,
      padding,
      backgroundColor,
      fontSize,
      ...(highlightedStyles || {}),
      display: "block",
    }
  }
)

export const StyledMenuItemLabel = styled.span(({ theme }) => ({
  marginRight: theme.spacing.md,
  flexGrow: 1,
  // We do not want to change the font for this based on theme.
  fontFamily: theme.fonts.sansSerif,
}))

export const StyledMenuContainer = styled.div(({ theme }) => ({
  // We start by adding border radius to all menus
  ul: {
    borderRadius: theme.radii.default,
  },

  // This selects the standard menu only if there's another menu below.
  // We use this to override the bottom border radius on the last item if the developer options menu is visible.
  "& > ul[role=listbox]:not(:last-child)": {
    borderBottomLeftRadius: 0,
    borderBottomRightRadius: 0,
  },

  // This selects the developer options menu, if it exists.
  // We use this to override the top border radius.
  "ul[role=listbox] ~ ul[role=listbox]": {
    borderTopLeftRadius: 0,
    borderTopRightRadius: 0,
    boxShadow: "none",
    borderTop: "none",
  },
  "@media print": {
    display: "none",
  },
}))

export const StyledMainMenuContainer = styled.span({
  lineHeight: "initial",
})


================================================
File: /frontend/app/src/components/Sidebar/NavSection.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { StyledSidebarNavSectionHeader } from "./styled-components"

export interface NavSectionProps {
  header?: string
  children: ReactElement[]
}

const NavSection = ({
  header = "",
  children,
}: NavSectionProps): ReactElement => {
  return (
    <>
      {header && (
        <StyledSidebarNavSectionHeader data-testid="stNavSectionHeader">
          {header}
        </StyledSidebarNavSectionHeader>
      )}
      {children}
    </>
  )
}

export default NavSection


================================================
File: /frontend/app/src/components/Sidebar/Sidebar.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import {
  fireEvent,
  RenderResult,
  screen,
  within,
} from "@testing-library/react"

import {
  emotionLightTheme,
  Logo,
  mockEndpoints,
  PageConfig,
  render,
} from "@streamlit/lib"

import Sidebar, { SidebarProps } from "./Sidebar"

vi.mock("@streamlit/lib/src/util/Hooks", async () => ({
  __esModule: true,
  ...(await vi.importActual("@streamlit/lib/src/util/Hooks")),
  useIsOverflowing: vi.fn(),
}))

const mockEndpointProp = mockEndpoints()

function renderSidebar(props: Partial<SidebarProps> = {}): RenderResult {
  return render(
    <Sidebar
      endpoints={mockEndpointProp}
      chevronDownshift={0}
      theme={emotionLightTheme}
      appLogo={null}
      appPages={[]}
      navSections={[]}
      onPageChange={vi.fn()}
      currentPageScriptHash={""}
      hasElements
      hideSidebarNav={false}
      expandSidebarNav={false}
      {...props}
    />
  )
}

describe("Sidebar Component", () => {
  it("should render without crashing", () => {
    renderSidebar({})

    expect(screen.getByTestId("stSidebar")).toBeInTheDocument()
  })

  it("should render expanded", () => {
    renderSidebar({
      initialSidebarState: PageConfig.SidebarState.EXPANDED,
    })

    expect(screen.getByTestId("stSidebar")).toHaveAttribute(
      "aria-expanded",
      "true"
    )
  })

  it("should render collapsed", () => {
    renderSidebar({
      initialSidebarState: PageConfig.SidebarState.COLLAPSED,
    })

    expect(screen.getByTestId("stSidebar")).toHaveAttribute(
      "aria-expanded",
      "false"
    )
  })

  it("should collapse on toggle if expanded", () => {
    renderSidebar({
      initialSidebarState: PageConfig.SidebarState.EXPANDED,
    })

    expect(screen.getByTestId("stSidebar")).toHaveAttribute(
      "aria-expanded",
      "true"
    )

    // Click the close sidebar <
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.mouseOver(screen.getByTestId("stSidebarHeader"))
    const sidebarCollapseButton = within(
      screen.getByTestId("stSidebarCollapseButton")
    ).getByRole("button")
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(sidebarCollapseButton)

    expect(screen.getByTestId("stSidebar")).toHaveAttribute(
      "aria-expanded",
      "false"
    )
  })

  it("should expand on toggle if collapsed", () => {
    renderSidebar({
      initialSidebarState: PageConfig.SidebarState.COLLAPSED,
    })

    expect(screen.getByTestId("stSidebar")).toHaveAttribute(
      "aria-expanded",
      "false"
    )

    // Click the expand sidebar > button
    const expandButton = within(
      screen.getByTestId("stSidebarCollapsedControl")
    ).getByRole("button")
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(expandButton)

    expect(screen.getByTestId("stSidebar")).toHaveAttribute(
      "aria-expanded",
      "true"
    )
  })

  it("shows/hides the collapse arrow when hovering over top of sidebar", () => {
    const appPages = [
      { pageName: "first_page", pageScriptHash: "page_hash" },
      { pageName: "second_page", pageScriptHash: "page_hash2" },
    ]

    renderSidebar({ appPages })

    // Hidden when not hovering near the top of sidebar
    expect(screen.getByTestId("stSidebarCollapseButton")).toHaveStyle(
      "display: none"
    )

    // Hover over the sidebar header
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.mouseOver(screen.getByTestId("stSidebarHeader"))

    // Displays the collapse <
    expect(screen.getByTestId("stSidebarCollapseButton")).toHaveStyle(
      "display: inline"
    )
  })

  it("has no top padding if no SidebarNav is displayed", () => {
    renderSidebar({
      appPages: [{ pageName: "streamlit_app", pageScriptHash: "page_hash" }],
    })

    expect(screen.getByTestId("stSidebarUserContent")).toHaveStyle(
      "padding-top: 0"
    )
  })

  it("has small padding if the SidebarNav is displayed", () => {
    renderSidebar({
      appPages: [
        { pageName: "streamlit_app", pageScriptHash: "page_hash" },
        { pageName: "streamlit_app2", pageScriptHash: "page_hash2" },
      ],
    })

    expect(screen.getByTestId("stSidebarUserContent")).toHaveStyle(
      "padding-top: 1.5rem"
    )
  })

  it("uses the default chevron spacing if chevronDownshift is zero", () => {
    renderSidebar({
      chevronDownshift: 0,
      initialSidebarState: PageConfig.SidebarState.COLLAPSED,
    })

    expect(screen.getByTestId("stSidebarCollapsedControl")).toHaveStyle(
      "top: 1.25rem"
    )
  })

  it("uses the given chevron spacing if chevronDownshift is nonzero", () => {
    renderSidebar({
      chevronDownshift: 50,
      initialSidebarState: PageConfig.SidebarState.COLLAPSED,
    })

    expect(screen.getByTestId("stSidebarCollapsedControl")).toHaveStyle(
      "top: 50px"
    )
  })

  it("renders SidebarNav component", () => {
    const appPages = [
      {
        pageName: "first page",
        pageScriptHash: "page_hash",
        urlPathname: "first_page",
      },
      {
        pageName: "second page",
        pageScriptHash: "page_hash2",
        urlPathname: "second_page",
      },
    ]
    renderSidebar({ appPages })

    expect(screen.getByTestId("stSidebarNav")).toBeInTheDocument()

    const sidebarAppPages = screen.getAllByRole("listitem")
    expect(sidebarAppPages).toHaveLength(2)
    expect(sidebarAppPages[0]).toHaveTextContent("first page")
    expect(sidebarAppPages[1]).toHaveTextContent("second page")
  })

  it("can hide SidebarNav with the hideSidebarNav option", () => {
    const appPages = [
      { pageName: "streamlit_app", pageScriptHash: "page_hash" },
      { pageName: "streamlit_app2", pageScriptHash: "page_hash2" },
    ]
    renderSidebar({ appPages, hideSidebarNav: true })

    expect(screen.queryByTestId("stSidebarNav")).not.toBeInTheDocument()
  })

  describe("handles appLogo rendering", () => {
    const imageOnly = Logo.create({
      image:
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png",
    })

    const imageWithLink = Logo.create({
      image:
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png",
      link: "www.example.com",
    })

    const fullAppLogo = Logo.create({
      image:
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png",
      link: "www.example.com",
      iconImage: "https://docs.streamlit.io/logo.svg",
    })

    const logoWithSize = Logo.create({
      image:
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png",
      link: "www.example.com",
      iconImage: "https://docs.streamlit.io/logo.svg",
      size: "small",
    })

    it("renders spacer if no logo provided", () => {
      renderSidebar({ appLogo: null })
      const sidebarLogoSpacer = within(
        screen.getByTestId("stSidebar")
      ).getByTestId("stLogoSpacer")
      expect(sidebarLogoSpacer).toBeInTheDocument()
    })

    it("renders logo when sidebar collapsed - uses iconImage if provided", () => {
      const sourceSpy = vi.spyOn(mockEndpointProp, "buildMediaURL")
      renderSidebar({
        initialSidebarState: PageConfig.SidebarState.COLLAPSED,
        appLogo: fullAppLogo,
      })
      const openSidebarContainer = screen.getByTestId(
        "stSidebarCollapsedControl"
      )
      expect(openSidebarContainer).toBeInTheDocument()
      const collapsedLogo = within(openSidebarContainer).getByTestId("stLogo")
      expect(collapsedLogo).toBeInTheDocument()
      expect(sourceSpy).toHaveBeenCalledWith(
        "https://docs.streamlit.io/logo.svg"
      )
    })

    it("renders logo when sidebar collapsed - defaults to image if no iconImage", () => {
      const sourceSpy = vi.spyOn(mockEndpointProp, "buildMediaURL")
      renderSidebar({
        initialSidebarState: PageConfig.SidebarState.COLLAPSED,
        appLogo: imageOnly,
      })
      const openSidebarContainer = screen.getByTestId(
        "stSidebarCollapsedControl"
      )
      expect(openSidebarContainer).toBeInTheDocument()
      const collapsedLogo = within(openSidebarContainer).getByTestId("stLogo")
      expect(collapsedLogo).toBeInTheDocument()
      expect(sourceSpy).toHaveBeenCalledWith(
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png"
      )
    })

    it("renders logo's image param when sidebar expanded", () => {
      const sourceSpy = vi.spyOn(mockEndpointProp, "buildMediaURL")
      renderSidebar({ appLogo: fullAppLogo })
      const sidebarLogoContainer = screen.getByTestId("stSidebarHeader")
      expect(sidebarLogoContainer).toBeInTheDocument()
      const sidebarLogo = within(sidebarLogoContainer).getByTestId("stLogo")
      expect(sidebarLogo).toBeInTheDocument()
      expect(sourceSpy).toHaveBeenCalledWith(
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png"
      )
    })

    it("renders logo - default image has no link & medium size", () => {
      renderSidebar({ appLogo: imageOnly })
      const sidebarLogoLink = within(
        screen.getByTestId("stSidebar")
      ).queryByTestId("stLogoLink")
      expect(sidebarLogoLink).not.toBeInTheDocument()
      const sidebarLogo = within(screen.getByTestId("stSidebar")).getByTestId(
        "stLogo"
      )
      expect(sidebarLogo).toHaveStyle({ height: "1.5rem" })
    })

    it("renders logo - image has link if provided", () => {
      renderSidebar({ appLogo: imageWithLink })
      const sidebarLogoLink = within(
        screen.getByTestId("stSidebar")
      ).getByTestId("stLogoLink")
      expect(sidebarLogoLink).toHaveAttribute("href", "www.example.com")
      const sidebarLogo = within(screen.getByTestId("stSidebar")).getByTestId(
        "stLogo"
      )
      expect(sidebarLogo).toHaveStyle({ height: "1.5rem" })
    })

    it("renders logo - small size when specified", () => {
      renderSidebar({ appLogo: logoWithSize })
      const sidebarLogo = within(screen.getByTestId("stSidebar")).getByTestId(
        "stLogo"
      )
      expect(sidebarLogo).toHaveStyle({ height: "1.25rem" })
    })

    it("sets maxWidth of logo based on sidebar width", () => {
      renderSidebar({ appLogo: imageWithLink })
      const sidebarWidth = window.getComputedStyle(
        screen.getByTestId("stSidebar")
      ).width
      const sidebarLogo = within(screen.getByTestId("stSidebar")).getByTestId(
        "stLogo"
      )
      // L & R padding (twoXL) + R margin (sm) + collapse button (2.25rem)
      expect(sidebarLogo).toHaveStyle(
        `max-width: calc(${sidebarWidth} - 2 * 1.5rem - 0.5rem - 2.25rem)`
      )
    })
  })
})


================================================
File: /frontend/app/src/components/Sidebar/Sidebar.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { PureComponent, ReactElement, ReactNode } from "react"

import { ChevronLeft, ChevronRight } from "@emotion-icons/material-outlined"
import { withTheme } from "@emotion/react"
import { Resizable } from "re-resizable"

import {
  BaseButton,
  BaseButtonKind,
  EmotionTheme,
  IAppPage,
  Icon,
  isColoredLineDisplayed,
  isEmbed,
  IsSidebarContext,
  localStorageAvailable,
  Logo,
  PageConfig,
  StreamlitEndpoints,
} from "@streamlit/lib"

import {
  RESIZE_HANDLE_WIDTH,
  StyledCollapseSidebarButton,
  StyledLogo,
  StyledLogoLink,
  StyledNoLogoSpacer,
  StyledOpenSidebarButton,
  StyledResizeHandle,
  StyledSidebar,
  StyledSidebarContent,
  StyledSidebarHeaderContainer,
  StyledSidebarOpenContainer,
  StyledSidebarUserContent,
} from "./styled-components"
import SidebarNav from "./SidebarNav"

export interface SidebarProps {
  endpoints: StreamlitEndpoints
  chevronDownshift: number
  children?: ReactElement
  initialSidebarState?: PageConfig.SidebarState
  theme: EmotionTheme
  hasElements: boolean
  appLogo: Logo | null
  appPages: IAppPage[]
  navSections: string[]
  onPageChange: (pageName: string) => void
  currentPageScriptHash: string
  hideSidebarNav: boolean
  expandSidebarNav: boolean
}

interface State {
  collapsedSidebar: boolean
  sidebarWidth: string
  lastInnerWidth: number

  // When hovering sidebar header
  showSidebarCollapse: boolean
}

class Sidebar extends PureComponent<SidebarProps, State> {
  private mediumBreakpointPx: number

  static readonly minWidth = "336"

  public static calculateMaxBreakpoint(value: string): number {
    // We subtract a margin of 0.02 to use as a max-width
    return parseInt(value, 10) - 0.02
  }

  private sidebarRef = React.createRef<HTMLDivElement>()

  constructor(props: SidebarProps) {
    super(props)
    this.mediumBreakpointPx = Sidebar.calculateMaxBreakpoint(
      props.theme.breakpoints.md
    )

    const cachedSidebarWidth = localStorageAvailable()
      ? window.localStorage.getItem("sidebarWidth")
      : undefined

    this.state = {
      collapsedSidebar: Sidebar.shouldCollapse(props, this.mediumBreakpointPx),
      sidebarWidth: cachedSidebarWidth || Sidebar.minWidth,
      lastInnerWidth: window ? window.innerWidth : Infinity,
      showSidebarCollapse: false,
    }
  }

  componentDidUpdate(prevProps: any): void {
    this.mediumBreakpointPx = Sidebar.calculateMaxBreakpoint(
      this.props.theme.breakpoints.md
    )
    // Immediately expand/collapse sidebar when initialSidebarState or hasElements changes
    if (
      this.props.initialSidebarState !== prevProps.initialSidebarState ||
      this.props.hasElements !== prevProps.hasElements
    ) {
      this.setState({
        collapsedSidebar: Sidebar.shouldCollapse(
          this.props,
          this.mediumBreakpointPx
        ),
      })
    }
  }

  static shouldCollapse(
    props: SidebarProps,
    mediumBreakpointPx: number
  ): boolean {
    switch (props.initialSidebarState) {
      case PageConfig.SidebarState.EXPANDED:
        return false
      case PageConfig.SidebarState.COLLAPSED:
        return true
      case PageConfig.SidebarState.AUTO:
      default: {
        // Expand sidebar only if browser width > MEDIUM_BREAKPOINT_PX
        const { innerWidth } = window || {}
        return innerWidth ? innerWidth <= mediumBreakpointPx : false
      }
    }
  }

  componentDidMount(): void {
    window.addEventListener("resize", this.checkMobileOnResize)
    document.addEventListener("mousedown", this.handleClickOutside)
  }

  componentWillUnmount(): void {
    window.removeEventListener("resize", this.checkMobileOnResize)
    document.removeEventListener("mousedown", this.handleClickOutside)
  }

  handleClickOutside = (event: any): void => {
    if (this.sidebarRef && window) {
      const { current } = this.sidebarRef
      const { innerWidth } = window

      if (
        current &&
        !current.contains(event.target) &&
        innerWidth <= this.mediumBreakpointPx
      ) {
        this.setState({ collapsedSidebar: true })
      }
    }
  }

  setSidebarWidth = (width: number): void => {
    const newWidth = width.toString()

    this.setState({ sidebarWidth: newWidth })

    if (localStorageAvailable()) {
      window.localStorage.setItem("sidebarWidth", newWidth)
    }
  }

  resetSidebarWidth = (event: any): void => {
    // Double clicking on the resize handle resets sidebar to default width
    if (event.detail === 2) {
      this.setState({ sidebarWidth: Sidebar.minWidth })
      if (localStorageAvailable()) {
        window.localStorage.setItem("sidebarWidth", Sidebar.minWidth)
      }
    }
  }

  checkMobileOnResize = (): boolean => {
    if (!window) return false

    const { innerWidth } = window

    // Collapse the sidebar if the window was narrowed and is now mobile-sized
    if (
      innerWidth < this.state.lastInnerWidth &&
      innerWidth <= this.mediumBreakpointPx
    ) {
      this.setState({ collapsedSidebar: true })
    }
    this.setState({ lastInnerWidth: innerWidth })

    return true
  }

  toggleCollapse = (): void => {
    const { collapsedSidebar } = this.state

    this.setState({ collapsedSidebar: !collapsedSidebar })
  }

  onMouseOver = (): void => {
    this.setState({ showSidebarCollapse: true })
  }

  onMouseOut = (): void => {
    this.setState({ showSidebarCollapse: false })
  }

  // Additional safeguard for sidebar height sizing
  headerDecorationVisible(): boolean {
    let coloredLineExists = false
    const headerDecoration = document.getElementById("stDecoration")
    if (headerDecoration) {
      const decorationStyles = window.getComputedStyle(headerDecoration)
      coloredLineExists =
        decorationStyles.visibility !== "hidden" &&
        decorationStyles.visibility !== "collapse" &&
        decorationStyles.display !== "none"
    }
    return coloredLineExists
  }

  renderLogo(collapsed: boolean): ReactElement {
    const { appLogo, endpoints } = this.props
    const { sidebarWidth } = this.state

    if (!appLogo) {
      return <StyledNoLogoSpacer data-testid="stLogoSpacer" />
    }

    const displayImage =
      collapsed && appLogo.iconImage ? appLogo.iconImage : appLogo.image
    const source = endpoints.buildMediaURL(displayImage)

    const logo = (
      <StyledLogo
        src={source}
        size={appLogo.size}
        sidebarWidth={sidebarWidth}
        alt="Logo"
        className="stLogo"
        data-testid="stLogo"
      />
    )

    if (appLogo.link) {
      return (
        <StyledLogoLink
          href={appLogo.link}
          target="_blank"
          rel="noreferrer"
          data-testid="stLogoLink"
        >
          {logo}
        </StyledLogoLink>
      )
    }
    return logo
  }

  public render(): ReactNode {
    const { collapsedSidebar, sidebarWidth, showSidebarCollapse } = this.state
    const {
      appPages,
      chevronDownshift,
      children,
      hasElements,
      onPageChange,
      currentPageScriptHash,
      hideSidebarNav,
      expandSidebarNav,
      navSections,
    } = this.props

    const hasPageNavAbove = appPages.length > 1 && !hideSidebarNav

    // Handles checking the URL params
    const isEmbedded = isEmbed() && !isColoredLineDisplayed()
    // If header decoration visible, move sidebar down so decoration doesn't go below it
    const sidebarAdjust = !isEmbedded && this.headerDecorationVisible()

    // The tabindex is required to support scrolling by arrow keys.
    return (
      <>
        <StyledSidebarOpenContainer
          chevronDownshift={chevronDownshift}
          data-testid="stSidebarCollapsedControl"
        >
          {this.renderLogo(true)}
          <StyledOpenSidebarButton>
            <BaseButton
              kind={BaseButtonKind.HEADER_NO_PADDING}
              onClick={this.toggleCollapse}
            >
              <Icon content={ChevronRight} size="xl" />
            </BaseButton>
          </StyledOpenSidebarButton>
        </StyledSidebarOpenContainer>
        <Resizable
          className="stSidebar"
          data-testid="stSidebar"
          aria-expanded={!collapsedSidebar}
          enable={{
            top: false,
            right: true,
            bottom: false,
            left: false,
          }}
          handleStyles={{
            right: {
              width: RESIZE_HANDLE_WIDTH,
              right: "-6px",
            },
          }}
          handleComponent={{
            right: <StyledResizeHandle onClick={this.resetSidebarWidth} />,
          }}
          size={{
            width: sidebarWidth,
            height: "auto",
          }}
          as={StyledSidebar}
          onResizeStop={(e, direction, ref, d) => {
            const newWidth = parseInt(sidebarWidth, 10) + d.width
            this.setSidebarWidth(newWidth)
          }}
          // Props part of StyledSidebar, but not Resizable component
          // @ts-expect-error
          isCollapsed={collapsedSidebar}
          adjustTop={sidebarAdjust}
          sidebarWidth={sidebarWidth}
        >
          <StyledSidebarContent
            data-testid="stSidebarContent"
            ref={this.sidebarRef}
            onMouseOver={this.onMouseOver}
            onMouseOut={this.onMouseOut}
          >
            <StyledSidebarHeaderContainer data-testid="stSidebarHeader">
              {this.renderLogo(false)}
              <StyledCollapseSidebarButton
                showSidebarCollapse={showSidebarCollapse}
                data-testid="stSidebarCollapseButton"
              >
                <BaseButton
                  kind={BaseButtonKind.HEADER_NO_PADDING}
                  onClick={this.toggleCollapse}
                >
                  <Icon content={ChevronLeft} size="xl" />
                </BaseButton>
              </StyledCollapseSidebarButton>
            </StyledSidebarHeaderContainer>
            {hasPageNavAbove && (
              <SidebarNav
                endpoints={this.props.endpoints}
                appPages={appPages}
                collapseSidebar={this.toggleCollapse}
                currentPageScriptHash={currentPageScriptHash}
                navSections={navSections}
                hasSidebarElements={hasElements}
                expandSidebarNav={expandSidebarNav}
                onPageChange={onPageChange}
              />
            )}
            <StyledSidebarUserContent
              hasPageNavAbove={hasPageNavAbove}
              data-testid="stSidebarUserContent"
            >
              {children}
            </StyledSidebarUserContent>
          </StyledSidebarContent>
        </Resizable>
      </>
    )
  }
}

function SidebarWithProvider(props: SidebarProps): ReactElement {
  return (
    <IsSidebarContext.Provider value={true}>
      <Sidebar {...props} />
    </IsSidebarContext.Provider>
  )
}

export default withTheme(SidebarWithProvider)


================================================
File: /frontend/app/src/components/Sidebar/SidebarNav.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import * as reactDeviceDetect from "react-device-detect"
import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { IAppPage, mockEndpoints, render } from "@streamlit/lib"

import SidebarNav, { Props } from "./SidebarNav"

vi.mock("@streamlit/lib/src/util/Hooks", async () => ({
  __esModule: true,
  ...(await vi.importActual("@streamlit/lib/src/util/Hooks")),
  useIsOverflowing: vi.fn(),
}))

const getProps = (props: Partial<Props> = {}): Props => ({
  appPages: [
    {
      pageScriptHash: "main_page_hash",
      pageName: "streamlit app",
      urlPathname: "streamlit_app",
      isDefault: true,
    },
    {
      pageScriptHash: "other_page_hash",
      pageName: "my other page",
      urlPathname: "my_other_page",
    },
  ],
  navSections: [],
  collapseSidebar: vi.fn(),
  currentPageScriptHash: "",
  hasSidebarElements: false,
  expandSidebarNav: false,
  onPageChange: vi.fn(),
  endpoints: mockEndpoints(),
  ...props,
})

describe("SidebarNav", () => {
  afterEach(() => {
    // @ts-expect-error
    reactDeviceDetect.isMobile = false
    window.localStorage.clear()
  })

  it("replaces underscores with spaces in pageName", () => {
    render(<SidebarNav {...getProps()} />)

    expect(screen.getByText("streamlit app")).toBeInTheDocument()
    expect(screen.getByText("my other page")).toBeInTheDocument()
  })

  describe("page links", () => {
    const { location: originalLocation } = window

    beforeEach(() => {
      // Replace window.location with a mutable object that otherwise has
      // the same contents so that we can change port below.
      // @ts-expect-error
      delete window.location
      window.location = { ...originalLocation }
    })

    afterEach(() => {
      window.location = originalLocation
    })

    it("are added to each link", () => {
      const buildAppPageURL = vi
        .fn()
        .mockImplementation((pageLinkBaseURL: string, page: IAppPage) => {
          return `http://mock/app/page/${page.urlPathname}`
        })
      const props = getProps({ endpoints: mockEndpoints({ buildAppPageURL }) })

      render(<SidebarNav {...props} />)

      const links = screen.getAllByRole("link")
      expect(links).toHaveLength(2)

      expect(links[0]).toHaveAttribute(
        "href",
        "http://mock/app/page/streamlit_app"
      )
      expect(links[1]).toHaveAttribute(
        "href",
        "http://mock/app/page/my_other_page"
      )
    })
  })

  it("does not add separator below if there are no sidebar elements", () => {
    render(<SidebarNav {...getProps({ hasSidebarElements: false })} />)
    expect(
      screen.queryByTestId("stSidebarNavSeparator")
    ).not.toBeInTheDocument()
  })

  it("adds separator below if the sidebar also has elements", () => {
    render(<SidebarNav {...getProps({ hasSidebarElements: true })} />)
    expect(screen.getByTestId("stSidebarNavSeparator")).toBeInTheDocument()
  })

  it("renders View more button when there are 13 elements", () => {
    render(
      <SidebarNav
        {...getProps({
          hasSidebarElements: true,
          appPages: [
            {
              pageScriptHash: "main_page_hash",
              pageName: "streamlit app",
              urlPathname: "streamlit_app",
              isDefault: true,
            },
          ].concat(
            Array.from({ length: 12 }, (_, index) => ({
              pageScriptHash: `other_page_hash${index}`,
              pageName: `my other page${index}`,
              urlPathname: `my_other_page${index}`,
              isDefault: false,
            }))
          ),
        })}
      />
    )

    expect(screen.getByTestId("stSidebarNavSeparator")).toBeInTheDocument()
    expect(screen.getByTestId("stSidebarNavViewButton")).toHaveTextContent(
      "View 3 more"
    )
  })

  it("does not render View less button when explicitly asked to expand", () => {
    render(
      <SidebarNav
        {...getProps({
          expandSidebarNav: true,
          hasSidebarElements: true,
          appPages: [
            {
              pageScriptHash: "main_page_hash",
              pageName: "streamlit app",
              urlPathname: "streamlit_app",
              isDefault: true,
            },
          ].concat(
            Array.from({ length: 12 }, (_, index) => ({
              pageScriptHash: `other_page_hash${index}`,
              pageName: `my other page${index}`,
              urlPathname: `my_other_page${index}`,
              isDefault: false,
            }))
          ),
        })}
      />
    )

    expect(screen.getByTestId("stSidebarNavSeparator")).toBeInTheDocument()
    expect(
      screen.queryByTestId("stSidebarNavViewButton")
    ).not.toBeInTheDocument()
  })

  it("renders View more button when there are more than 13 elements", () => {
    render(
      <SidebarNav
        {...getProps({
          hasSidebarElements: true,
          appPages: [
            {
              pageScriptHash: "main_page_hash",
              pageName: "streamlit app",
              urlPathname: "streamlit_app",
              isDefault: true,
            },
          ].concat(
            Array.from({ length: 13 }, (_, index) => ({
              pageScriptHash: `other_page_hash${index}`,
              pageName: `my other page${index}`,
              urlPathname: `my_other_page${index}`,
              isDefault: false,
            }))
          ),
        })}
      />
    )

    expect(screen.getByTestId("stSidebarNavSeparator")).toBeInTheDocument()
    expect(screen.getByTestId("stSidebarNavViewButton")).toHaveTextContent(
      "View 4 more"
    )
  })

  it("does not render View more button when there are < 13 elements", () => {
    render(
      <SidebarNav
        {...getProps({
          hasSidebarElements: true,
          appPages: [
            {
              pageScriptHash: "main_page_hash",
              pageName: "streamlit app",
              urlPathname: "streamlit_app",
              isDefault: true,
            },
          ].concat(
            Array.from({ length: 11 }, (_, index) => ({
              pageScriptHash: `other_page_hash${index}`,
              pageName: `my other page${index}`,
              urlPathname: `my_other_page${index}`,
              isDefault: false,
            }))
          ),
        })}
      />
    )

    expect(
      screen.queryByTestId("stSidebarNavViewButton")
    ).not.toBeInTheDocument()
    expect(screen.getAllByTestId("stSidebarNavLink")).toHaveLength(12)
  })

  it("renders View less button when expanded", async () => {
    const user = userEvent.setup()
    render(
      <SidebarNav
        {...getProps({
          hasSidebarElements: true,
          appPages: [
            {
              pageScriptHash: "main_page_hash",
              pageName: "streamlit app",
              urlPathname: "streamlit_app",
              isDefault: true,
            },
          ].concat(
            Array.from({ length: 13 }, (_, index) => ({
              pageScriptHash: `other_page_hash${index}`,
              pageName: `my other page${index}`,
              urlPathname: `my_other_page${index}`,
              isDefault: false,
            }))
          ),
        })}
      />
    )

    // Click on the separator to expand the nav component.
    await user.click(screen.getByTestId("stSidebarNavViewButton"))

    const viewLessButton = await screen.findByText("View less")
    expect(viewLessButton).toBeInTheDocument()
  })

  it("renders View less button when user prefers expansion", () => {
    window.localStorage.setItem("sidebarNavState", "expanded")

    render(
      <SidebarNav
        {...getProps({
          hasSidebarElements: true,
          appPages: [
            {
              pageScriptHash: "main_page_hash",
              pageName: "streamlit app",
              urlPathname: "streamlit_app",
              isDefault: true,
            },
          ].concat(
            Array.from({ length: 13 }, (_, index) => ({
              pageScriptHash: `other_page_hash${index}`,
              pageName: `my other page${index}`,
              urlPathname: `my_other_page${index}`,
              isDefault: false,
            }))
          ),
        })}
      />
    )

    const viewLessButton = screen.getByText("View less")
    expect(viewLessButton).toBeInTheDocument()
    const navLinks = screen.getAllByTestId("stSidebarNavLink")
    expect(navLinks).toHaveLength(14)
  })

  it("is unexpanded by default, displaying 10 links when > 12 pages", () => {
    render(
      <SidebarNav
        {...getProps({
          hasSidebarElements: true,
          appPages: [
            {
              pageScriptHash: "main_page_hash",
              pageName: "streamlit app",
              urlPathname: "streamlit_app",
              isDefault: true,
            },
          ].concat(
            Array.from({ length: 13 }, (_, index) => ({
              pageScriptHash: `other_page_hash${index}`,
              pageName: `my other page${index}`,
              urlPathname: `my_other_page${index}`,
              isDefault: false,
            }))
          ),
        })}
      />
    )

    const navLinks = screen.getAllByTestId("stSidebarNavLink")
    expect(navLinks).toHaveLength(10)
  })

  it("toggles to expanded and back when the View more/less buttons are clicked", async () => {
    const user = userEvent.setup()
    render(
      <SidebarNav
        {...getProps({
          hasSidebarElements: true,
          appPages: [
            {
              pageScriptHash: "main_page_hash",
              pageName: "streamlit app",
              urlPathname: "streamlit_app",
              isDefault: true,
            },
          ].concat(
            Array.from({ length: 13 }, (_, index) => ({
              pageScriptHash: `other_page_hash${index}`,
              pageName: `my other page${index}`,
              urlPathname: `my_other_page${index}`,
              isDefault: false,
            }))
          ),
        })}
      />
    )

    expect(screen.getByTestId("stSidebarNavSeparator")).toBeInTheDocument()
    expect(screen.getAllByTestId("stSidebarNavLink")).toHaveLength(10)
    // Expand the pages menu
    await user.click(screen.getByTestId("stSidebarNavViewButton"))

    expect(screen.getAllByTestId("stSidebarNavLink")).toHaveLength(14)
    // Collapse the pages menu
    await user.click(screen.getByTestId("stSidebarNavViewButton"))
    expect(screen.getAllByTestId("stSidebarNavLink")).toHaveLength(10)
  })

  it("displays partial sections", async () => {
    const user = userEvent.setup()
    render(
      <SidebarNav
        {...getProps({
          hasSidebarElements: true,
          navSections: ["section 1", "section 2"],
          appPages: [
            {
              pageScriptHash: "main_page_hash",
              pageName: "streamlit app",
              urlPathname: "streamlit_app",
              isDefault: true,
              sectionHeader: "section 1",
            },
          ].concat(
            Array.from({ length: 13 }, (_, index) => ({
              pageScriptHash: `other_page_hash${index}`,
              pageName: `my other page${index}`,
              urlPathname: `my_other_page${index}`,
              isDefault: false,
              sectionHeader: `section ${(index % 2) + 1}`,
            }))
          ),
        })}
      />
    )

    expect(screen.getByTestId("stSidebarNavSeparator")).toBeInTheDocument()
    expect(screen.getAllByTestId("stSidebarNavLink")).toHaveLength(10)
    expect(screen.getAllByTestId("stNavSectionHeader")).toHaveLength(2)

    // Expand the pages menu
    await user.click(screen.getByTestId("stSidebarNavViewButton"))

    expect(screen.getAllByTestId("stSidebarNavLink")).toHaveLength(14)
    expect(screen.getAllByTestId("stNavSectionHeader")).toHaveLength(2)
    // Collapse the pages menu
    await user.click(screen.getByTestId("stSidebarNavViewButton"))
    expect(screen.getAllByTestId("stSidebarNavLink")).toHaveLength(10)
    expect(screen.getAllByTestId("stNavSectionHeader")).toHaveLength(2)
  })

  it("will not display a section if no pages in it are visible", async () => {
    const user = userEvent.setup()
    // First section has 6 pages, second section has 4 pages, third section has 4 pages
    // Since 6+4 = 10, only the first two sections should be visible
    render(
      <SidebarNav
        {...getProps({
          hasSidebarElements: true,
          navSections: ["section 1", "section 2", "section 3"],
          appPages: [
            {
              pageScriptHash: "main_page_hash",
              pageName: "streamlit app",
              urlPathname: "streamlit_app",
              isDefault: true,
              sectionHeader: "section 1",
            },
          ].concat(
            Array.from({ length: 13 }, (_, index) => ({
              pageScriptHash: `other_page_hash${index}`,
              pageName: `my other page${index}`,
              urlPathname: `my_other_page${index}`,
              isDefault: false,
              sectionHeader: `section ${(index % 3) + 1}`,
            }))
          ),
        })}
      />
    )

    expect(screen.getByTestId("stSidebarNavSeparator")).toBeInTheDocument()
    expect(screen.getAllByTestId("stSidebarNavLink")).toHaveLength(10)
    expect(screen.getAllByTestId("stNavSectionHeader")).toHaveLength(2)

    // Expand the pages menu
    await user.click(screen.getByTestId("stSidebarNavViewButton"))

    expect(screen.getAllByTestId("stSidebarNavLink")).toHaveLength(14)
    expect(screen.getAllByTestId("stNavSectionHeader")).toHaveLength(3)
    // Collapse the pages menu
    await user.click(screen.getByTestId("stSidebarNavViewButton"))
    expect(screen.getAllByTestId("stSidebarNavLink")).toHaveLength(10)
    expect(screen.getAllByTestId("stNavSectionHeader")).toHaveLength(2)
  })

  it("passes the pageScriptHash to onPageChange if a link is clicked", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<SidebarNav {...props} />)

    const links = screen.getAllByTestId("stSidebarNavLink")
    await user.click(links[1])

    expect(props.onPageChange).toHaveBeenCalledWith("other_page_hash")
    expect(props.collapseSidebar).not.toHaveBeenCalled()
  })

  it("collapses sidebar on page change when on mobile", async () => {
    const user = userEvent.setup()
    // @ts-expect-error
    reactDeviceDetect.isMobile = true

    const props = getProps()
    render(<SidebarNav {...props} />)

    const links = screen.getAllByTestId("stSidebarNavLink")
    await user.click(links[1])

    expect(props.onPageChange).toHaveBeenCalledWith("other_page_hash")
    expect(props.collapseSidebar).toHaveBeenCalled()
  })

  it("handles default and custom page icons", () => {
    const props = getProps({
      appPages: [
        { pageName: "streamlit_app" },
        { pageName: "my_other_page", icon: "🦈" },
      ],
    })

    render(<SidebarNav {...props} />)

    const links = screen.getAllByTestId("stSidebarNavLink")
    expect(links).toHaveLength(2)
    expect(links[1]).toHaveTextContent("🦈")
  })

  it("indicates the current page as active", () => {
    const props = getProps({ currentPageScriptHash: "other_page_hash" })
    render(<SidebarNav {...props} />)

    const links = screen.getAllByTestId("stSidebarNavLink")
    expect(links).toHaveLength(2)

    // isActive prop used to style background color, so check that
    expect(links[0]).toHaveStyle("background-color: rgba(0, 0, 0, 0)")
    expect(links[1]).toHaveStyle("background-color: rgba(151, 166, 195, 0.25)")
  })
})


================================================
File: /frontend/app/src/components/Sidebar/SidebarNav.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  MouseEvent,
  ReactElement,
  ReactNode,
  useCallback,
  useContext,
  useEffect,
  useState,
} from "react"

import groupBy from "lodash/groupBy"
// We import react-device-detect in this way so that tests can mock its
// isMobile field sanely.
import * as reactDeviceDetect from "react-device-detect"

import {
  IAppPage,
  localStorageAvailable,
  StreamlitEndpoints,
} from "@streamlit/lib"
import { AppContext } from "@streamlit/app/src/components/AppContext"

import NavSection from "./NavSection"
import SidebarNavLink from "./SidebarNavLink"
import {
  StyledSidebarNavContainer,
  StyledSidebarNavItems,
  StyledSidebarNavSeparator,
  StyledViewButton,
} from "./styled-components"

export interface Props {
  endpoints: StreamlitEndpoints
  appPages: IAppPage[]
  navSections: string[]
  collapseSidebar: () => void
  currentPageScriptHash: string
  hasSidebarElements: boolean
  expandSidebarNav: boolean
  onPageChange: (pageName: string) => void
}

// We make the sidebar nav collapsible when there are more than 12 pages.
const COLLAPSE_THRESHOLD = 12
// However, we show the first 10 pages when the sidebar is collapsed.
const NUM_PAGES_TO_SHOW_WHEN_COLLAPSED = 10

interface NavLinkProps {
  pageUrl: string
  page: IAppPage
  isActive: boolean
  onClick: (e: MouseEvent) => void
}

function NavLink({
  pageUrl,
  page,
  isActive,
  onClick,
}: NavLinkProps): ReactElement {
  const pageName = page.pageName as string

  return (
    <li>
      <SidebarNavLink
        isActive={isActive}
        pageUrl={pageUrl}
        icon={page.icon}
        onClick={onClick}
      >
        {pageName}
      </SidebarNavLink>
    </li>
  )
}

function generateNavSections(
  navSections: string[],
  appPages: IAppPage[],
  needsCollapse: boolean,
  generateNavLink: (page: IAppPage, index: number) => ReactElement
): ReactNode[] {
  const contents: ReactNode[] = []
  const pagesBySectionHeader = groupBy(
    appPages,
    page => page.sectionHeader || ""
  )
  let currentPageCount = 0
  navSections.forEach(header => {
    const sectionPages = pagesBySectionHeader[header] ?? []
    let viewablePages = sectionPages

    if (needsCollapse) {
      if (currentPageCount >= NUM_PAGES_TO_SHOW_WHEN_COLLAPSED) {
        // We cannot even show the section
        return
      } else if (
        currentPageCount + sectionPages.length >
        NUM_PAGES_TO_SHOW_WHEN_COLLAPSED
      ) {
        // We can partially show the section
        viewablePages = sectionPages.slice(
          0,
          NUM_PAGES_TO_SHOW_WHEN_COLLAPSED - currentPageCount
        )
      }
    }
    currentPageCount += viewablePages.length

    contents.push(
      <NavSection key={header} header={header}>
        {viewablePages.map(generateNavLink)}
      </NavSection>
    )
  })

  return contents
}

/** Displays a list of navigable app page links for multi-page apps. */
const SidebarNav = ({
  endpoints,
  appPages,
  collapseSidebar,
  expandSidebarNav,
  currentPageScriptHash,
  hasSidebarElements,
  navSections,
  onPageChange,
}: Props): ReactElement | null => {
  const [expanded, setExpanded] = useState(false)
  const { pageLinkBaseUrl } = useContext(AppContext)

  useEffect(() => {
    const cachedSidebarNavExpanded =
      localStorageAvailable() &&
      window.localStorage.getItem("sidebarNavState") === "expanded"

    if (!expanded && (expandSidebarNav || cachedSidebarNavExpanded)) {
      setExpanded(true)
    }
  }, [expanded, expandSidebarNav])

  const handleViewButtonClick = useCallback(() => {
    const nextState = !expanded
    if (localStorageAvailable()) {
      if (nextState) {
        window.localStorage.setItem("sidebarNavState", "expanded")
      } else {
        window.localStorage.removeItem("sidebarNavState")
      }
    }
    setExpanded(nextState)
  }, [expanded])

  const generateNavLink = useCallback(
    (page: IAppPage, index: number) => {
      const pageUrl = endpoints.buildAppPageURL(pageLinkBaseUrl, page)
      const isActive = page.pageScriptHash === currentPageScriptHash

      return (
        <NavLink
          key={`${page.pageName}-${index}`}
          pageUrl={pageUrl}
          page={page}
          isActive={isActive}
          onClick={e => {
            e.preventDefault()
            onPageChange(page.pageScriptHash as string)
            if (reactDeviceDetect.isMobile) {
              collapseSidebar()
            }
          }}
        />
      )
    },
    [
      collapseSidebar,
      currentPageScriptHash,
      endpoints,
      onPageChange,
      pageLinkBaseUrl,
    ]
  )

  let contents: ReactNode[] = []
  const totalPages = appPages.length
  const shouldShowViewButton =
    hasSidebarElements && totalPages > COLLAPSE_THRESHOLD && !expandSidebarNav
  const needsCollapse = shouldShowViewButton && !expanded
  if (navSections.length > 0) {
    // For MPAv2 with headers: renders a NavSection for each header with its respective pages
    contents = generateNavSections(
      navSections,
      appPages,
      needsCollapse,
      generateNavLink
    )
  } else {
    const viewablePages = needsCollapse
      ? appPages.slice(0, NUM_PAGES_TO_SHOW_WHEN_COLLAPSED)
      : appPages
    // For MPAv1 / MPAv2 with no section headers, single NavSection with all pages
    contents = viewablePages.map(generateNavLink)
  }

  return (
    <StyledSidebarNavContainer data-testid="stSidebarNav">
      <StyledSidebarNavItems data-testid="stSidebarNavItems">
        {contents}
      </StyledSidebarNavItems>
      {shouldShowViewButton && (
        <StyledViewButton
          onClick={handleViewButtonClick}
          data-testid="stSidebarNavViewButton"
        >
          {expanded
            ? "View less"
            : `View ${totalPages - NUM_PAGES_TO_SHOW_WHEN_COLLAPSED} more`}
        </StyledViewButton>
      )}
      {hasSidebarElements && (
        <StyledSidebarNavSeparator data-testid="stSidebarNavSeparator" />
      )}
    </StyledSidebarNavContainer>
  )
}

export default SidebarNav


================================================
File: /frontend/app/src/components/Sidebar/SidebarNavLink.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { MouseEvent, ReactElement } from "react"

import { DynamicIcon } from "@streamlit/lib"

import {
  StyledSidebarLinkText,
  StyledSidebarNavIcon,
  StyledSidebarNavLink,
  StyledSidebarNavLinkContainer,
} from "./styled-components"

export interface SidebarNavLinkProps {
  isActive: boolean
  pageUrl: string
  icon: string | undefined | null
  onClick: (e: MouseEvent) => void
  children: string
}

const SidebarNavLink = ({
  isActive,
  pageUrl,
  icon,
  onClick,
  children,
}: SidebarNavLinkProps): ReactElement => {
  return (
    <StyledSidebarNavLinkContainer>
      <StyledSidebarNavLink
        data-testid="stSidebarNavLink"
        isActive={isActive}
        href={pageUrl}
        onClick={onClick}
      >
        {icon && icon.length && (
          <StyledSidebarNavIcon isActive={isActive}>
            <DynamicIcon size="md" iconValue={icon} />
          </StyledSidebarNavIcon>
        )}
        <StyledSidebarLinkText isActive={isActive}>
          {children}
        </StyledSidebarLinkText>
      </StyledSidebarNavLink>
    </StyledSidebarNavLinkContainer>
  )
}

export default SidebarNavLink


================================================
File: /frontend/app/src/components/Sidebar/ThemedSidebar.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { emotionLightTheme, mockEndpoints, render } from "@streamlit/lib"

import { SidebarProps } from "./Sidebar"
import ThemedSidebar from "./ThemedSidebar"

function getProps(
  props: Partial<SidebarProps> = {}
): Omit<SidebarProps, "chevronDownshift" | "theme"> {
  return {
    endpoints: mockEndpoints(),
    appPages: [],
    navSections: [],
    onPageChange: vi.fn(),
    currentPageScriptHash: "page_hash",
    hasElements: true,
    hideSidebarNav: false,
    ...props,
  }
}

describe("ThemedSidebar Component", () => {
  it("should render without crashing", () => {
    render(<ThemedSidebar {...getProps()} />)

    expect(screen.getByTestId("stSidebar")).toBeInTheDocument()
  })

  it("should switch bgColor and secondaryBgColor", () => {
    render(<ThemedSidebar {...getProps()} />)

    expect(screen.getByTestId("stSidebar")).toHaveStyle({
      backgroundColor: emotionLightTheme.colors.secondaryBg,
    })
  })

  it("plumbs appPages to main Sidebar component", () => {
    const appPages = [
      {
        pageName: "streamlit app",
        scriptPath: "streamlit_app.py",
        urlPathname: "streamlit_app",
      },
      {
        pageName: "other app page",
        scriptPath: "other_app_page.py",
        urlPathname: "other_app_page",
      },
    ]
    render(<ThemedSidebar {...getProps({ appPages })} />)

    // Check Sidebar & SidebarNav render
    expect(screen.getByTestId("stSidebar")).toBeInTheDocument()
    expect(screen.getByTestId("stSidebarNav")).toBeInTheDocument()

    // Check the app pages passed
    expect(screen.getByText("streamlit app")).toBeInTheDocument()
    expect(screen.getByText("other app page")).toBeInTheDocument()
  })
})


================================================
File: /frontend/app/src/components/Sidebar/ThemedSidebar.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import {
  createTheme,
  LibContext,
  ThemeConfig,
  ThemeProvider,
} from "@streamlit/lib"
import { AppContext } from "@streamlit/app/src/components/AppContext"

import Sidebar, { SidebarProps } from "./Sidebar"

const createSidebarTheme = (theme: ThemeConfig): ThemeConfig => {
  return createTheme(
    "Sidebar",
    {
      secondaryBackgroundColor: theme.emotion.colors.bgColor,
      backgroundColor: theme.emotion.colors.secondaryBg,

      // Explictly pass these props to the sidebar theming as well.
      // This ensures custom fonts passed through postMessage propagate to the sidebar as well.
      bodyFont: theme.emotion.genericFonts.bodyFont,
      codeFont: theme.emotion.genericFonts.codeFont,
    },
    theme,
    // inSidebar
    true
  )
}

const ThemedSidebar = ({
  children,
  ...sidebarProps
}: Omit<SidebarProps, "chevronDownshift" | "theme">): ReactElement => {
  const { sidebarChevronDownshift: chevronDownshift } =
    React.useContext(AppContext)
  const { activeTheme } = React.useContext(LibContext)
  const sidebarTheme = createSidebarTheme(activeTheme)

  return (
    <ThemeProvider
      theme={sidebarTheme.emotion}
      baseuiTheme={sidebarTheme.basewebTheme}
    >
      <Sidebar {...sidebarProps} chevronDownshift={chevronDownshift}>
        {children}
      </Sidebar>
    </ThemeProvider>
  )
}

export default ThemedSidebar


================================================
File: /frontend/app/src/components/Sidebar/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import ThemedSidebar from "./ThemedSidebar"

export { default } from "./Sidebar"
export { ThemedSidebar }


================================================
File: /frontend/app/src/components/Sidebar/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"
import { transparentize } from "color2k"

import { hasLightBackgroundColor } from "@streamlit/lib"

// Check for custom text color & handle colors in SidebarNav accordingly
const conditionalCustomColor = (
  theme: any,
  customThemeColor: string,
  defaultThemeColor: string
): string => {
  let customTextColor = theme.colors.bodyText !== theme.colors.gray10

  if (hasLightBackgroundColor(theme)) {
    customTextColor = theme.colors.bodyText !== theme.colors.gray85
  }

  return customTextColor ? customThemeColor : defaultThemeColor
}

export interface StyledSidebarProps {
  isCollapsed: boolean
  adjustTop: boolean
  sidebarWidth: string
}

export const StyledSidebar = styled.section<StyledSidebarProps>(
  ({ theme, isCollapsed, adjustTop, sidebarWidth }) => {
    const minWidth = isCollapsed ? 0 : Math.min(244, window.innerWidth)
    const maxWidth = isCollapsed ? 0 : Math.min(550, window.innerWidth * 0.9)

    return {
      position: "relative",
      // Nudge the sidebar by 2px so the header decoration doesn't go below it
      top: adjustTop ? theme.sizes.headerDecorationHeight : theme.spacing.none,
      backgroundColor: theme.colors.bgColor,
      zIndex: theme.zIndices.header + 1,

      minWidth,
      maxWidth,
      transform: isCollapsed ? `translateX(-${sidebarWidth}px)` : "none",
      transition: "transform 300ms, min-width 300ms, max-width 300ms",

      "&:focus": {
        outline: "none",
      },

      [`@media (max-width: ${theme.breakpoints.md})`]: {
        boxShadow: `-2rem 0 2rem 2rem ${
          isCollapsed ? "transparent" : "#00000029"
        }`,
      },

      [`@media print`]: {
        display: isCollapsed ? "none" : "initial",
        // set to auto, otherwise the sidebar does not take up the whole page
        height: "auto !important",
        // set maxHeight to little bit less than 100%, otherwise the sidebar might start a mostly blank page
        maxHeight: "99%",
        // on Chrome, sth. adds a box-shadow in printing mode which looks weird
        boxShadow: "none",
      },
    }
  }
)

export const StyledSidebarNavContainer = styled.div({
  position: "relative",
})

export const StyledSidebarNavItems = styled.ul(({ theme }) => {
  return {
    listStyle: "none",
    margin: theme.spacing.none,
    paddingBottom: theme.spacing.threeXS,
    paddingTop: theme.spacing.none,
    paddingRight: theme.spacing.none,
    paddingLeft: theme.spacing.none,
  }
})

export const StyledSidebarNavLinkContainer = styled.div({
  display: "flex",
  flexDirection: "column",
})

export interface StyledSidebarNavIconProps {
  isActive: boolean
}

export const StyledSidebarNavIcon = styled.span<StyledSidebarNavIconProps>(
  ({ theme, isActive }) => {
    const svgColor = conditionalCustomColor(
      theme,
      theme.colors.fadedText60,
      theme.colors.navIconColor
    )
    const activeSvgColor = conditionalCustomColor(
      theme,
      theme.colors.bodyText,
      theme.colors.navActiveTextColor
    )

    return {
      display: "inline-flex",
      span: {
        color: isActive ? activeSvgColor : svgColor,
        fontWeight: isActive
          ? theme.fontWeights.bold
          : theme.fontWeights.normal,
      },
    }
  }
)

export interface StyledSidebarNavLinkProps {
  isActive: boolean
}

export const StyledSidebarNavLink = styled.a<StyledSidebarNavLinkProps>(
  ({ theme, isActive }) => {
    const color = conditionalCustomColor(
      theme,
      theme.colors.bodyText,
      theme.colors.navTextColor
    )

    const defaultPageLinkStyles = {
      textDecoration: "none",
      fontWeight: isActive ? theme.fontWeights.bold : theme.fontWeights.normal,
    }

    return {
      ...defaultPageLinkStyles,
      display: "flex",
      flexDirection: "row",
      alignItems: "center",
      gap: theme.spacing.sm,
      borderRadius: theme.radii.default,
      paddingLeft: theme.spacing.sm,
      paddingRight: theme.spacing.sm,
      marginLeft: theme.spacing.twoXL,
      marginRight: theme.spacing.twoXL,
      marginTop: theme.spacing.threeXS,
      marginBottom: theme.spacing.threeXS,
      lineHeight: theme.lineHeights.menuItem,

      color,
      backgroundColor: isActive ? theme.colors.darkenedBgMix25 : "transparent",

      "&:hover": {
        backgroundColor: transparentize(theme.colors.darkenedBgMix25, 0.1),
      },

      "&:active,&:visited,&:hover": {
        ...defaultPageLinkStyles,
      },

      "&:focus": {
        outline: "none",
      },

      "&:focus-visible": {
        backgroundColor: theme.colors.darkenedBgMix15,
      },

      [`@media print`]: {
        paddingLeft: theme.spacing.none,
      },
    }
  }
)

export const StyledSidebarLinkText = styled.span<StyledSidebarNavLinkProps>(
  ({ isActive, theme }) => {
    const defaultColor = conditionalCustomColor(
      theme,
      transparentize(theme.colors.bodyText, 0.2),
      theme.colors.navTextColor
    )
    const activeColor = conditionalCustomColor(
      theme,
      theme.colors.bodyText,
      theme.colors.navActiveTextColor
    )

    return {
      color: isActive ? activeColor : defaultColor,
      overflow: "hidden",
      whiteSpace: "nowrap",
      textOverflow: "ellipsis",
      display: "table-cell",
    }
  }
)

export interface StyledSidebarUserContentProps {
  hasPageNavAbove: boolean
}

export const StyledSidebarUserContent =
  styled.div<StyledSidebarUserContentProps>(({ hasPageNavAbove, theme }) => ({
    paddingTop: hasPageNavAbove ? theme.spacing.twoXL : 0,
    paddingBottom: theme.sizes.sidebarTopSpace,
    paddingLeft: theme.spacing.twoXL,
    paddingRight: theme.spacing.twoXL,
  }))

export const StyledSidebarContent = styled.div(({}) => ({
  position: "relative",
  height: "100%",
  width: "100%",
  overflow: ["auto", "overlay"],
}))

export const RESIZE_HANDLE_WIDTH = "8px"

export const StyledResizeHandle = styled.div(({ theme }) => ({
  position: "absolute",
  width: RESIZE_HANDLE_WIDTH,
  height: "100%",
  cursor: "col-resize",
  zIndex: theme.zIndices.sidebarMobile,

  "&:hover": {
    backgroundImage: `linear-gradient(to right, transparent 20%, ${theme.colors.fadedText20} 28%, transparent 36%)`,
  },
}))

export const StyledSidebarHeaderContainer = styled.div(({ theme }) => ({
  display: "flex",
  justifyContent: "space-between",
  alignItems: "start",
  padding: theme.spacing.twoXL,
  // Adjust top padding based on the header decoration height
  paddingTop: `calc(${theme.spacing.twoXL} - ${theme.sizes.headerDecorationHeight})`,
}))

export const StyledLogoLink = styled.a(({}) => ({
  "&:hover": {
    opacity: "0.7",
  },
}))

export interface StyledLogoProps {
  size: string
  sidebarWidth?: string
}

function translateLogoHeight(theme: any, size: string): string {
  if (size === "small") {
    return theme.sizes.smallLogoHeight
  } else if (size === "large") {
    return theme.sizes.largeLogoHeight
  }
  // Default logo size
  return theme.sizes.defaultLogoHeight
}

export const StyledLogo = styled.img<StyledLogoProps>(
  ({ theme, size, sidebarWidth }) => ({
    height: translateLogoHeight(theme, size),
    // Extra margin to align small logo with sidebar collapse arrow
    marginTop: size == "small" ? theme.spacing.xs : theme.spacing.twoXS,
    marginBottom: size == "small" ? theme.spacing.xs : theme.spacing.twoXS,
    marginRight: theme.spacing.sm,
    marginLeft: theme.spacing.none,
    zIndex: theme.zIndices.header,
    objectFit: "contain",
    verticalAlign: "middle",
    ...(sidebarWidth && {
      // Control max width of logo so sidebar collapse button always shows (issue #8707)
      // L & R padding (twoXL) + R margin (sm) + collapse button (2.25rem)
      maxWidth: `calc(${sidebarWidth}px - 2 * ${theme.spacing.twoXL} - ${theme.spacing.sm} - 2.25rem)`,
    }),
  })
)

export const StyledNoLogoSpacer = styled.div(({ theme }) => ({
  height: theme.sizes.largeLogoHeight,
}))

export interface StyledSidebarOpenContainerProps {
  chevronDownshift: number
}

export const StyledSidebarOpenContainer =
  styled.div<StyledSidebarOpenContainerProps>(
    ({ theme, chevronDownshift }) => ({
      position: "fixed",
      top: chevronDownshift ? `${chevronDownshift}px` : theme.spacing.xl,
      left: theme.spacing.twoXL,
      zIndex: theme.zIndices.header,
      display: "flex",
      justifyContent: "center",
      alignItems: "center",

      [`@media print`]: {
        position: "static",
      },
    })
  )

export const StyledOpenSidebarButton = styled.div(({ theme }) => {
  const color = conditionalCustomColor(
    theme,
    theme.colors.bodyText,
    theme.colors.sidebarControlColor
  )

  return {
    zIndex: theme.zIndices.header,
    color,
    marginTop: theme.spacing.twoXS,

    button: {
      "&:hover": {
        backgroundColor: theme.colors.darkenedBgMix25,
      },
    },

    [`@media print`]: {
      display: "none",
    },
  }
})

export interface StyledCollapseSidebarButtonProps {
  showSidebarCollapse: boolean
}

export const StyledCollapseSidebarButton =
  styled.div<StyledCollapseSidebarButtonProps>(
    ({ showSidebarCollapse, theme }) => {
      const color = conditionalCustomColor(
        theme,
        theme.colors.bodyText,
        theme.colors.sidebarControlColor
      )

      return {
        display: showSidebarCollapse ? "inline" : "none",
        transition: "left 300ms",
        transitionDelay: "left 300ms",
        color,
        lineHeight: "0",

        [`@media print`]: {
          display: "none",
        },

        [`@media (max-width: ${theme.breakpoints.sm})`]: {
          display: "inline",
        },
      }
    }
  )

export const StyledSidebarNavSectionHeader = styled.header(({ theme }) => {
  const color = conditionalCustomColor(
    theme,
    transparentize(theme.colors.bodyText, 0.15),
    theme.colors.navTextColor
  )

  return {
    fontSize: theme.fontSizes.sm,
    fontWeight: theme.fontWeights.bold,
    color,
    lineHeight: theme.lineHeights.small,
    paddingRight: theme.spacing.sm,
    marginLeft: theme.spacing.twoXL,
    marginRight: theme.spacing.twoXL,
    marginTop: theme.spacing.sm,
    marginBottom: theme.spacing.twoXS,
  }
})

export const StyledViewButton = styled.button(({ theme }) => {
  const color = conditionalCustomColor(
    theme,
    theme.colors.bodyText,
    theme.colors.navActiveTextColor
  )

  return {
    fontSize: theme.fontSizes.sm,
    fontFamily: "inherit",
    lineHeight: theme.lineHeights.base,
    color,
    backgroundColor: theme.colors.transparent,
    border: "none",
    borderRadius: theme.radii.default,
    marginTop: theme.spacing.twoXS,
    marginLeft: theme.spacing.xl,
    marginBottom: theme.spacing.none,
    marginRight: theme.spacing.none,
    padding: `${theme.spacing.threeXS} ${theme.spacing.sm}`,
    "&:hover, &:active, &:focus": {
      border: "none",
      outline: "none",
      boxShadow: "none",
    },
    "&:hover": {
      backgroundColor: theme.colors.darkenedBgMix25,
    },
  }
})

export const StyledSidebarNavSeparator = styled.div(({ theme }) => ({
  paddingTop: theme.spacing.lg,
  borderBottom: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
}))


================================================
File: /frontend/app/src/components/StatusWidget/StatusWidget.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { fireEvent, screen } from "@testing-library/react"

import { render, ScriptRunState, SessionEvent } from "@streamlit/lib"
import { ConnectionState } from "@streamlit/app/src/connection/ConnectionState"
import { SessionEventDispatcher } from "@streamlit/app/src/SessionEventDispatcher"

import StatusWidget, { StatusWidgetProps } from "./StatusWidget"

const getProps = (
  propOverrides: Partial<StatusWidgetProps> = {}
): StatusWidgetProps => ({
  connectionState: ConnectionState.CONNECTED,
  sessionEventDispatcher: new SessionEventDispatcher(),
  scriptRunState: ScriptRunState.RUNNING,
  rerunScript: vi.fn(),
  stopScript: () => {},
  allowRunOnSave: true,
  ...propOverrides,
})

describe("StatusWidget element", () => {
  it("renders a StatusWidget", () => {
    render(<StatusWidget {...getProps()} />)

    expect(screen.getByTestId("stStatusWidget")).toBeInTheDocument()
  })

  it("renders its tooltip when connecting", () => {
    render(
      <StatusWidget
        {...getProps({ connectionState: ConnectionState.CONNECTING })}
      />
    )

    expect(screen.getByTestId("stStatusWidget")).toBeInTheDocument()
    expect(screen.getByText("Connecting")).toBeInTheDocument()
    expect(screen.getByTestId("stTooltipHoverTarget")).toBeInTheDocument()
  })

  it("renders its tooltip when disconnected", () => {
    render(
      <StatusWidget
        {...getProps({
          connectionState: ConnectionState.DISCONNECTED_FOREVER,
        })}
      />
    )

    expect(screen.getByTestId("stStatusWidget")).toBeInTheDocument()
    expect(screen.getByText("Error")).toBeInTheDocument()
    expect(screen.getByTestId("stTooltipHoverTarget")).toBeInTheDocument()
  })

  it("renders its tooltip when running and minimized", () => {
    vi.useFakeTimers()
    render(<StatusWidget {...getProps()} />)
    expect(
      screen.queryByTestId("stTooltipHoverTarget")
    ).not.toBeInTheDocument()

    // Set scrollY so shouldMinimize returns true
    global.scrollY = 50

    render(<StatusWidget {...getProps()} />)
    vi.runAllTimers()
    expect(screen.getByTestId("stTooltipHoverTarget")).toBeInTheDocument()

    // Reset scrollY for following tests not impacted
    global.scrollY = 0
  })

  it("does not render its tooltip when connected", () => {
    render(
      <StatusWidget
        {...getProps({ connectionState: ConnectionState.CONNECTED })}
      />
    )

    expect(
      screen.queryByTestId("stTooltipHoverTarget")
    ).not.toBeInTheDocument()
  })

  it("sets and unsets the sessionEventConnection", () => {
    const sessionEventDispatcher = new SessionEventDispatcher()
    const connectSpy = vi.fn()
    const disconnectSpy = vi.fn()
    sessionEventDispatcher.onSessionEvent.connect =
      connectSpy.mockImplementation(() => ({
        disconnect: disconnectSpy,
      }))

    const { unmount } = render(
      <StatusWidget {...getProps({ sessionEventDispatcher })} />
    )

    expect(connectSpy).toHaveBeenCalled()

    unmount()

    expect(disconnectSpy).toHaveBeenCalled()
  })

  it("calls stopScript when clicked", () => {
    vi.useFakeTimers()
    const stopScript = vi.fn()
    render(<StatusWidget {...getProps({ stopScript })} />)

    vi.runAllTimers()
    const baseButtonHeader = screen.getByTestId("stBaseButton-header")

    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(baseButtonHeader)

    expect(stopScript).toHaveBeenCalled()
  })

  it("shows the rerun button when script changes", () => {
    const sessionEventDispatcher = new SessionEventDispatcher()
    const rerunScript = vi.fn()

    render(
      <StatusWidget
        {...getProps({
          rerunScript,
          sessionEventDispatcher,
          scriptRunState: ScriptRunState.NOT_RUNNING,
        })}
      />
    )

    sessionEventDispatcher.handleSessionEventMsg(
      new SessionEvent({
        scriptChangedOnDisk: true,
        scriptWasManuallyStopped: null,
        scriptCompilationException: null,
      })
    )

    const buttons = screen.getAllByRole("button")
    expect(buttons).toHaveLength(2)

    expect(buttons[0]).toHaveTextContent("Rerun")
    expect(buttons[1]).toHaveTextContent("Always rerun")

    // Click "Rerun" button
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(buttons[0])

    expect(rerunScript).toHaveBeenCalledWith(false)
  })

  it("shows the always rerun button when script changes", () => {
    const sessionEventDispatcher = new SessionEventDispatcher()
    const rerunScript = vi.fn()

    render(
      <StatusWidget
        {...getProps({
          rerunScript,
          sessionEventDispatcher,
          scriptRunState: ScriptRunState.NOT_RUNNING,
        })}
      />
    )

    sessionEventDispatcher.handleSessionEventMsg(
      new SessionEvent({
        scriptChangedOnDisk: true,
        scriptWasManuallyStopped: null,
        scriptCompilationException: null,
      })
    )

    const buttons = screen.getAllByRole("button")
    expect(buttons).toHaveLength(2)

    expect(buttons[0]).toHaveTextContent("Rerun")
    expect(buttons[1]).toHaveTextContent("Always rerun")

    // Click "Always Rerun" button
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(buttons[1])

    expect(rerunScript).toHaveBeenCalledWith(true)
  })

  it("does not show the always rerun button when script changes", () => {
    const sessionEventDispatcher = new SessionEventDispatcher()
    const rerunScript = vi.fn()

    render(
      <StatusWidget
        {...getProps({
          rerunScript,
          sessionEventDispatcher,
          scriptRunState: ScriptRunState.NOT_RUNNING,
          allowRunOnSave: false,
        })}
      />
    )

    sessionEventDispatcher.handleSessionEventMsg(
      new SessionEvent({
        scriptChangedOnDisk: true,
        scriptWasManuallyStopped: null,
        scriptCompilationException: null,
      })
    )
    const buttons = screen.getAllByRole("button")
    expect(buttons).toHaveLength(1)

    expect(buttons[0]).toHaveTextContent("Rerun")
  })

  it("calls always run on save", () => {
    const sessionEventDispatcher = new SessionEventDispatcher()
    const rerunScript = vi.fn()

    render(
      <StatusWidget
        {...getProps({
          rerunScript,
          sessionEventDispatcher,
          scriptRunState: ScriptRunState.NOT_RUNNING,
        })}
      />
    )

    sessionEventDispatcher.handleSessionEventMsg(
      new SessionEvent({
        scriptChangedOnDisk: true,
        scriptWasManuallyStopped: null,
        scriptCompilationException: null,
      })
    )
    // Verify the Always rerun is visible
    expect(screen.getByText("Always rerun")).toBeInTheDocument()

    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.keyDown(document.body, {
      key: "a",
      which: 65,
    })

    expect(rerunScript).toHaveBeenCalledWith(true)
  })
})

describe("Running Icon", () => {
  beforeEach(() => {
    vi.useFakeTimers()
  })

  afterEach(() => {
    vi.useRealTimers()
  })

  it("renders regular running gif before New Years", () => {
    vi.setSystemTime(new Date("December 30, 2022 23:59:00"))

    render(
      <StatusWidget
        {...getProps({ scriptRunState: ScriptRunState.RUNNING })}
      />
    )

    vi.runAllTimers()

    const icon = screen.queryByRole("img")
    expect(icon).toHaveAttribute("src", "/src/assets/img/icon_running.gif")
  })

  it("renders firework gif on Dec 31st", () => {
    vi.setSystemTime(new Date("December 31, 2022 00:00:00"))

    render(
      <StatusWidget
        {...getProps({ scriptRunState: ScriptRunState.RUNNING })}
      />
    )

    vi.runAllTimers()

    const icon = screen.queryByRole("img")
    expect(icon).toHaveAttribute("src", "/src/assets/img/fireworks.gif")
  })

  it("renders firework gif on Jan 6th", () => {
    vi.setSystemTime(new Date("January 6, 2023 23:59:00"))

    render(
      <StatusWidget
        {...getProps({ scriptRunState: ScriptRunState.RUNNING })}
      />
    )

    vi.runAllTimers()

    const icon = screen.queryByRole("img")
    expect(icon).toHaveAttribute("src", "/src/assets/img/fireworks.gif")
  })

  it("renders regular running gif after New Years", async () => {
    vi.setSystemTime(new Date("January 7, 2023 00:00:00"))

    render(
      <StatusWidget
        {...getProps({ scriptRunState: ScriptRunState.RUNNING })}
      />
    )

    vi.runAllTimers()

    const icon = screen.queryByRole("img")
    expect(icon).toHaveAttribute("src", "/src/assets/img/icon_running.gif")
  })

  it("delays render of running gif", () => {
    // Set system time so test doesn't fail during New Years
    vi.setSystemTime(new Date("January 7, 2023 00:00:00"))

    render(
      <StatusWidget
        {...getProps({ scriptRunState: ScriptRunState.RUNNING })}
      />
    )

    let icon = screen.queryByRole("img")
    expect(icon).not.toBeInTheDocument()

    vi.runAllTimers()

    icon = screen.queryByRole("img")
    expect(icon).toHaveAttribute("src", "/src/assets/img/icon_running.gif")
  })
})


================================================
File: /frontend/app/src/components/StatusWidget/StatusWidget.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import React, {
  ReactElement,
  ReactNode,
  useCallback,
  useEffect,
  useRef,
  useState,
} from "react"

import { EmotionIcon } from "@emotion-icons/emotion-icon"
import { Ellipses, Info, Warning } from "@emotion-icons/open-iconic"
import { useTheme } from "@emotion/react"
import Hotkeys from "react-hot-keys"
import { CSSTransition } from "react-transition-group"
import { SignalConnection } from "typed-signals"

import {
  BaseButton,
  BaseButtonKind,
  Icon,
  isNullOrUndefined,
  notNullOrUndefined,
  Placement,
  ScriptRunState,
  SessionEvent,
  Timer,
  Tooltip,
} from "@streamlit/lib"
import iconRunning from "@streamlit/app/src/assets/img/icon_running.gif"
import newYearsRunning from "@streamlit/app/src/assets/img/fireworks.gif"
import { ConnectionState } from "@streamlit/app/src/connection/ConnectionState"
import { SessionEventDispatcher } from "@streamlit/app/src/SessionEventDispatcher"

import {
  StyledAppButtonContainer,
  StyledAppRunningIcon,
  StyledAppStatus,
  StyledAppStatusLabel,
  StyledConnectionStatus,
  StyledConnectionStatusLabel,
  StyledShortcutLabel,
  StyledStatusWidget,
} from "./styled-components"

/** Component props */
export interface StatusWidgetProps {
  /** State of our connection to the server. */
  connectionState: ConnectionState

  /** Dispatches transient SessionEvents received from the server. */
  sessionEventDispatcher: SessionEventDispatcher

  /** Script's current run state */
  scriptRunState: ScriptRunState

  /**
   * Function called when the user chooses to re-run a script in response to
   * its source file changing.
   *
   * @param alwaysRerun if true, also change the run-on-save setting for this
   * session
   */
  rerunScript: (alwaysRerun: boolean) => void

  /** Function called when the user chooses to stop the running script. */
  stopScript: () => void

  /** Allows users to change user settings to allow rerun on save */
  allowRunOnSave: boolean
}

interface ConnectionStateUI {
  icon: EmotionIcon
  label: string
  tooltip: string
}

// Amount of time to display the "Script Changed. Rerun?" prompt when it first appears.
const PROMPT_DISPLAY_INITIAL_TIMEOUT_MS = 15 * 1000

// Amount of time to display the Script Changed prompt after the user has hovered
// and then unhovered on it.
const PROMPT_DISPLAY_HOVER_TIMEOUT_MS = 1.0 * 1000

// Delay time for displaying running man animation.
const RUNNING_MAN_DISPLAY_DELAY_TIME_MS = 500

interface PromptButtonProps {
  title: ReactNode
  disabled: boolean
  onClick: () => void
  isMinimized: boolean
}

const PromptButton = (props: PromptButtonProps): ReactElement => {
  return (
    <StyledAppButtonContainer isMinimized={props.isMinimized}>
      <BaseButton
        kind={BaseButtonKind.HEADER_BUTTON}
        disabled={props.disabled}
        fluidWidth
        onClick={props.onClick}
      >
        {props.title}
      </BaseButton>
    </StyledAppButtonContainer>
  )
}

/**
 * Displays various script- and connection-related info: our WebSocket
 * connection status, the run-state of our script, and other transient events.
 */
const StatusWidget: React.FC<StatusWidgetProps> = ({
  connectionState,
  sessionEventDispatcher,
  scriptRunState,
  rerunScript,
  stopScript,
  allowRunOnSave,
}) => {
  const shouldMinimize = useCallback((): boolean => {
    return window.scrollY > 32
  }, [])
  const [statusMinimized, setStatusMinimized] = useState(shouldMinimize())
  const [scriptChangedOnDisk, setScriptChangedOnDisk] = useState(false)
  const [promptMinimized, setPromptMinimized] = useState(false)
  const [promptHovered, setPromptHovered] = useState(false)
  const [showRunningMan, setShowRunningMan] = useState(false)
  const minimizePromptTimer: React.MutableRefObject<Timer | null> =
    useRef(null)
  const showRunningManTimer: React.MutableRefObject<Timer | null> =
    useRef(null)
  const sessionEventConn = useRef<SignalConnection>()
  const theme = useTheme()

  const handleAlwaysRerunClick = (): void => {
    if (allowRunOnSave) {
      rerunScript(true)
    }
  }

  const handleKeyDown = (keyName: string): void => {
    // NOTE: 'r' is handled at the App Level
    if (keyName === "a") {
      handleAlwaysRerunClick()
    }
  }

  const isConnected = connectionState === ConnectionState.CONNECTED

  const minimizePromptAfterTimeout = useCallback((timeout: number): void => {
    // Don't cut an existing timer short. If our timer is already
    // running, and is due to expire later than the new timeout
    // value, leave the timer alone.
    if (minimizePromptTimer.current !== null) {
      if (timeout > minimizePromptTimer.current.remainingTime) {
        minimizePromptTimer.current.setTimeout(() => {
          setPromptMinimized(true)
        }, timeout)
      }
    }
  }, [])

  const handleSessionEvent = useCallback(
    (event: SessionEvent): void => {
      if (event.type === "scriptChangedOnDisk") {
        setScriptChangedOnDisk(true)
        setPromptMinimized(false)
        minimizePromptAfterTimeout(PROMPT_DISPLAY_INITIAL_TIMEOUT_MS)
      }
    },
    [minimizePromptAfterTimeout]
  )

  const showRunningManAfterInitialDelay = useCallback(
    (delay: number): void => {
      if (showRunningManTimer.current !== null) {
        showRunningManTimer.current.setTimeout(() => {
          setShowRunningMan(true)
        }, delay)
      }
    },
    []
  )

  const handleScroll = useCallback((): void => {
    setStatusMinimized(shouldMinimize())
  }, [shouldMinimize])

  const onAppPromptHover = (): void => {
    setPromptHovered(true)
  }

  const onAppPromptUnhover = (): void => {
    setPromptHovered(false)
    setPromptMinimized(false)
    minimizePromptAfterTimeout(PROMPT_DISPLAY_HOVER_TIMEOUT_MS)
  }

  const handleStopScriptClick = (): void => {
    stopScript()
  }

  const handleRerunClick = (): void => {
    rerunScript(false)
  }

  const isNewYears = (): boolean => {
    // Test if current date between 12/31 & 1/06
    const currentDate = new Date()
    const month = currentDate.getMonth()
    const date = currentDate.getDate()
    // Check if Dec 31st
    if (month === 11 && date === 31) return true
    // Check if Jan 1st through 6th
    if (month === 0 && date <= 6) return true
    return false
  }

  function getConnectionStateUI(
    state: ConnectionState
  ): ConnectionStateUI | undefined {
    switch (state) {
      case ConnectionState.INITIAL:
      case ConnectionState.PINGING_SERVER:
      case ConnectionState.CONNECTING:
        return {
          icon: Ellipses,
          label: "Connecting",
          tooltip: "Connecting to Streamlit server",
        }
      case ConnectionState.CONNECTED:
        return undefined
      case ConnectionState.DISCONNECTED_FOREVER:
      default:
        return {
          icon: Warning,
          label: "Error",
          tooltip: "Unable to connect to Streamlit server",
        }
    }
  }

  useEffect(() => {
    sessionEventConn.current =
      sessionEventDispatcher.onSessionEvent.connect(handleSessionEvent)
    return () => {
      if (sessionEventConn.current !== undefined) {
        sessionEventConn.current.disconnect()
        sessionEventConn.current = undefined
      }
    }
  }, [handleSessionEvent, sessionEventDispatcher.onSessionEvent])

  useEffect(() => {
    if (minimizePromptTimer.current === null) {
      minimizePromptTimer.current = new Timer()
    }
    if (showRunningManTimer.current === null) {
      showRunningManTimer.current = new Timer()
    }

    const minimizePromptTimerCurr = minimizePromptTimer.current
    const showRunningManTimerCurr = minimizePromptTimer.current

    return () => {
      minimizePromptTimerCurr.cancel()
      showRunningManTimerCurr.cancel()
    }
  }, [])

  useEffect(() => {
    window.addEventListener("scroll", handleScroll)
    return () => {
      window.removeEventListener("scroll", handleScroll)
    }
  }, [handleScroll])

  useEffect(() => {
    if (scriptRunState === ScriptRunState.RUNNING) {
      setScriptChangedOnDisk(false)
      setPromptHovered(false)
    }
  }, [scriptRunState])

  useEffect(() => {
    if (isConnected) {
      if (
        scriptRunState === ScriptRunState.RUNNING ||
        scriptRunState === ScriptRunState.RERUN_REQUESTED
      ) {
        showRunningManAfterInitialDelay(RUNNING_MAN_DISPLAY_DELAY_TIME_MS)
      }
    }
    if (scriptRunState === ScriptRunState.NOT_RUNNING) {
      setShowRunningMan(false)
    }
  }, [scriptRunState, showRunningManAfterInitialDelay, isConnected])

  const renderScriptIsRunning = (): ReactNode => {
    const minimized = statusMinimized
    const stopRequested = scriptRunState === ScriptRunState.STOP_REQUESTED
    const isNewYear = isNewYears()
    const runningSrc = isNewYear ? newYearsRunning : iconRunning
    const runningIcon = (
      <StyledAppRunningIcon
        isNewYears={isNewYear}
        src={runningSrc}
        alt="Running..."
      />
    )
    return showRunningMan ? (
      <StyledAppStatus>
        {minimized ? (
          <Tooltip
            placement={Placement.BOTTOM}
            content="This script is currently running"
          >
            {runningIcon}
          </Tooltip>
        ) : (
          runningIcon
        )}
        <StyledAppStatusLabel isMinimized={statusMinimized} isPrompt={false}>
          Running...
        </StyledAppStatusLabel>
        <PromptButton
          isMinimized={statusMinimized}
          title={stopRequested ? "Stopping..." : "Stop"}
          disabled={stopRequested}
          onClick={handleStopScriptClick}
        />
      </StyledAppStatus>
    ) : (
      <></>
    )
  }

  const renderRerunScriptPrompt = (): ReactNode => {
    const rerunRequested = scriptRunState === ScriptRunState.RERUN_REQUESTED
    const minimized = promptMinimized && !promptHovered
    const { colors } = theme
    return (
      <Hotkeys keyName="a" onKeyDown={handleKeyDown}>
        <div onMouseEnter={onAppPromptHover} onMouseLeave={onAppPromptUnhover}>
          <StyledAppStatus>
            <Icon content={Info} margin="0 sm 0 0" color={colors.bodyText} />
            <StyledAppStatusLabel isMinimized={minimized} isPrompt>
              Source file changed.
            </StyledAppStatusLabel>
            <PromptButton
              isMinimized={minimized}
              title={<StyledShortcutLabel>Rerun</StyledShortcutLabel>}
              disabled={rerunRequested}
              onClick={handleRerunClick}
            />
            {allowRunOnSave && (
              <PromptButton
                isMinimized={minimized}
                title={<StyledShortcutLabel>Always rerun</StyledShortcutLabel>}
                disabled={rerunRequested}
                onClick={handleAlwaysRerunClick}
              />
            )}
          </StyledAppStatus>
        </div>
      </Hotkeys>
    )
  }

  const renderConnectionStatus = (): ReactNode => {
    const ui = getConnectionStateUI(connectionState)
    if (ui === undefined) {
      return null
    }
    return (
      <Tooltip content={ui.tooltip} placement={Placement.BOTTOM}>
        <StyledConnectionStatus
          className="stConnectionStatus"
          data-testid="stConnectionStatus"
        >
          <Icon size="sm" content={ui.icon} />
          <StyledConnectionStatusLabel isMinimized={statusMinimized}>
            {ui.label}
          </StyledConnectionStatusLabel>
        </StyledConnectionStatus>
      </Tooltip>
    )
  }

  const renderWidget = (): ReactNode => {
    if (isConnected) {
      if (
        scriptRunState === ScriptRunState.RUNNING ||
        scriptRunState === ScriptRunState.RERUN_REQUESTED
      ) {
        // Show scriptIsRunning when the script is actually running,
        // but also when the user has just requested a re-run.
        // In the latter case, the server should get around to actually
        // re-running the script in a second or two, but we can appear
        // more responsive by claiming it's started immediately.
        return renderScriptIsRunning()
      }
      if (scriptChangedOnDisk) {
        return renderRerunScriptPrompt()
      }
    }

    return renderConnectionStatus()
  }

  // The StatusWidget fades in on appear and fades out on disappear.
  // We keep track of our most recent result from `renderWidget`,
  // via `this.curView`, so that we can fade out our previous state
  // if `renderWidget` returns null after returning a non-null value.
  const curView = useRef<ReactNode>()
  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  const prevView = curView.current
  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  curView.current = renderWidget()

  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  if (isNullOrUndefined(curView.current) && isNullOrUndefined(prevView)) {
    return <></>
  }

  let animateIn: boolean
  let renderView: ReactNode
  // TODO: Update to match React best practices
  // eslint-disable-next-line react-compiler/react-compiler
  if (notNullOrUndefined(curView.current)) {
    animateIn = true
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    renderView = curView.current
  } else {
    animateIn = false
    renderView = prevView
  }

  // NB: the `timeout` value here must match the transition
  // times specified in the StatusWidget-*-active CSS classes
  return (
    <CSSTransition
      appear={true}
      in={animateIn}
      timeout={200}
      unmountOnExit={true}
      classNames="StatusWidget"
    >
      <StyledStatusWidget
        key="StatusWidget"
        className="stStatusWidget"
        data-testid="stStatusWidget"
      >
        {renderView}
      </StyledStatusWidget>
    </CSSTransition>
  )
}

export default StatusWidget


================================================
File: /frontend/app/src/components/StatusWidget/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./StatusWidget"


================================================
File: /frontend/app/src/components/StatusWidget/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled, { CSSObject } from "@emotion/styled"

import { EmotionTheme, hasLightBackgroundColor } from "@streamlit/lib"

/*
  "ConnectionStatus" styles are used for displaying
  the status of our connection to the server (connected,
  disconnected, error, etc).
*/

export const StyledConnectionStatus = styled.div(({ theme }) => ({
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  color: theme.colors.gray,
}))

export interface StyledConnectionStatusLabelProps {
  isMinimized: boolean
}

export const StyledConnectionStatusLabel =
  styled.label<StyledConnectionStatusLabelProps>(({ isMinimized, theme }) => ({
    fontSize: theme.fontSizes.sm,
    color: theme.colors.gray,
    textTransform: "uppercase",
    marginTop: theme.spacing.none,
    marginRight: isMinimized ? theme.spacing.none : theme.spacing.lg,
    marginBottom: theme.spacing.none,
    marginLeft: theme.spacing.sm,
    whiteSpace: "nowrap",
    maxWidth: isMinimized ? "0" : theme.sizes.appStatusMaxWidth,
    transition:
      "opacity 500ms 0ms, clip 500ms 0ms, max-width 500ms 0ms, margin 500ms 0ms, visibility 0ms 500ms",
    opacity: isMinimized ? 0 : 1,
    visibility: isMinimized ? "hidden" : "visible",
    lineHeight: theme.lineHeights.none,
  }))

/*
  "AppStatus" styles are for app-related statuses:
  whether it's running, if the source file has changed on disk,
  etc.
*/

export const StyledAppStatus = styled.div(({ theme }) => ({
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  borderRadius: theme.radii.md,
  margin: `0 ${theme.spacing.sm} 0 0`,
  paddingLeft: theme.spacing.sm,
  height: theme.sizes.appRunningMen,
}))

const minimizedStyles = (theme: EmotionTheme): CSSObject => ({
  opacity: 0,
  padding: theme.spacing.none,
  margin: theme.spacing.none,
  maxWidth: 0,
  minWidth: 0,
  border: 0,
})

export interface StyledAppStatusLabelProps {
  isPrompt: boolean
  isMinimized: boolean
}

export const StyledAppStatusLabel = styled.label<StyledAppStatusLabelProps>(
  ({ isPrompt, isMinimized, theme }) => ({
    fontSize: theme.fontSizes.sm,
    color: isPrompt ? theme.colors.bodyText : theme.colors.gray,
    textTransform: isPrompt ? "none" : "uppercase",
    margin: `0 0 0 ${theme.spacing.lg}`,
    whiteSpace: "nowrap",
    maxWidth: theme.sizes.appStatusMaxWidth,
    borderRadius: isPrompt ? theme.radii.md : undefined,
    transition: `opacity 200ms ease-out 0s,
  clip 200ms ease-out 0s, min-width 200ms ease-out 0s,
  max-width 200ms ease-out 0s, padding 200ms ease-out 0s`, // Hide at end of the transition
    ...(isMinimized ? minimizedStyles(theme) : {}),
  })
)

export interface StyledAppButtonContainerProps {
  isMinimized: boolean
}

export const StyledAppButtonContainer =
  styled.span<StyledAppButtonContainerProps>(({ isMinimized, theme }) => ({
    marginLeft: theme.spacing.sm,
    whiteSpace: "nowrap",
    transition: `opacity 200ms ease-out 0s,
  clip 200ms ease-out 0s, min-width 200ms ease-out 0s,
  max-width 200ms ease-out 0s, padding 200ms ease-out 0s`, // Hide at end of the transition
    ...(isMinimized ? minimizedStyles(theme) : {}),
  }))

export interface StyledAppRunningIconProps {
  isNewYears: boolean
}

export const StyledAppRunningIcon = styled.img<StyledAppRunningIconProps>(
  ({ isNewYears, theme }) => {
    // Testing if current background color is light or dark to modify img:
    const filter = hasLightBackgroundColor(theme) ? "" : "invert(1)"

    // New years gif has unique styling - regular running man unchanged
    return {
      opacity: isNewYears ? 1 : 0.4,
      width: isNewYears ? "2.2rem" : theme.sizes.appRunningMen,
      height: isNewYears ? "2.2rem" : theme.sizes.appRunningMen,
      marginRight: `-${theme.spacing.sm}`,
      filter: isNewYears ? "" : filter,
    }
  }
)

export const StyledStatusWidget = styled.div({
  "&.StatusWidget-appear": {
    opacity: 0,
  },

  "&.StatusWidget-appear-active": {
    opacity: 1,
    transition: "opacity 200ms ease-out",
  },

  "&.StatusWidget-enter": {
    opacity: 0,
  },

  "&.StatusWidget-enter-active": {
    opacity: 1,
    transition: "opacity 200ms ease-out",
  },

  "&.StatusWidget-exit": {
    opacity: 1,
  },

  "&.StatusWidget-exit-active": {
    opacity: 0,
    transition: "opacity 200ms ease-out",
  },
})

export const StyledShortcutLabel = styled.div({
  "&::first-letter": {
    textDecoration: "underline",
  },
})


================================================
File: /frontend/app/src/components/StreamlitDialog/SettingsDialog.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { userEvent } from "@testing-library/user-event"
import { screen } from "@testing-library/react"

import {
  createPresetThemes,
  customRenderLibContext,
  darkTheme,
  LibContextProps,
  lightTheme,
  mockSessionInfo,
} from "@streamlit/lib"
import { MetricsManager } from "@streamlit/app/src/MetricsManager"

import { Props, SettingsDialog } from "./SettingsDialog"

const mockSetTheme = vi.fn()
const mockAddThemes = vi.fn()

const getContext = (
  extend?: Partial<LibContextProps>
): Partial<LibContextProps> => ({
  activeTheme: lightTheme,
  setTheme: mockSetTheme,
  availableThemes: [],
  addThemes: mockAddThemes,
  ...extend,
})

const getProps = (extend?: Partial<Props>): Props => ({
  isServerConnected: true,
  onClose: vi.fn(),
  onSave: vi.fn(),
  settings: { wideMode: false, runOnSave: false },
  allowRunOnSave: false,
  developerMode: true,
  animateModal: true,
  openThemeCreator: vi.fn(),
  metricsMgr: new MetricsManager(
    // @ts-expect-error The mock seems to have a mismatched internal type to what's expected.
    mockSessionInfo()
  ),
  ...extend,
})

describe("SettingsDialog", () => {
  it("renders without crashing", () => {
    const availableThemes = [lightTheme, darkTheme]
    const props = getProps()
    const context = getContext({ availableThemes })

    customRenderLibContext(<SettingsDialog {...props} />, context)

    expect(screen.getByText("Settings")).toBeVisible()
  })

  it("should render run on save checkbox", async () => {
    const user = userEvent.setup()
    const props = getProps({
      allowRunOnSave: true,
    })
    const context = getContext()
    customRenderLibContext(<SettingsDialog {...props} />, context)

    await user.click(screen.getByText("Run on save"))

    expect(props.onSave).toHaveBeenCalledTimes(1)
    expect(props.onSave).toHaveBeenCalledWith(
      expect.objectContaining({ runOnSave: true })
    )
  })

  it("should render wide mode checkbox", async () => {
    const user = userEvent.setup()
    const props = getProps()
    const context = getContext()
    customRenderLibContext(<SettingsDialog {...props} />, context)
    expect(screen.getByText("Wide mode")).toBeVisible()

    await user.click(screen.getByText("Wide mode"))

    expect(props.onSave).toHaveBeenCalledTimes(1)
    expect(props.onSave).toHaveBeenCalledWith(
      expect.objectContaining({ wideMode: true })
    )
  })

  it("should render theme selector", () => {
    const availableThemes = [lightTheme, darkTheme]
    const props = getProps()
    const context = getContext({ availableThemes })

    customRenderLibContext(<SettingsDialog {...props} />, context)

    expect(
      screen.getByText("Choose app theme, colors and fonts")
    ).toBeVisible()

    expect(screen.getByRole("combobox")).toBeVisible()
  })

  it("should show custom theme exists", async () => {
    const user = userEvent.setup()
    const presetThemes = createPresetThemes()
    const availableThemes = [...presetThemes, lightTheme]
    const props = getProps()
    const context = getContext({ availableThemes })

    customRenderLibContext(<SettingsDialog {...props} />, context)

    await user.click(screen.getByRole("combobox"))
    expect(screen.getAllByRole("option")).toHaveLength(presetThemes.length + 1)
  })

  it("should show custom theme does not exists", async () => {
    const user = userEvent.setup()
    const presetThemes = createPresetThemes()
    const availableThemes = [...presetThemes]
    const props = getProps()
    const context = getContext({ availableThemes })

    customRenderLibContext(<SettingsDialog {...props} />, context)

    await user.click(screen.getByRole("combobox"))
    expect(screen.getAllByRole("option")).toHaveLength(presetThemes.length)
  })

  it("should show theme creator button if in developer mode", () => {
    const availableThemes = [lightTheme, darkTheme]
    const props = getProps()
    const context = getContext({ availableThemes })

    customRenderLibContext(<SettingsDialog {...props} />, context)

    expect(screen.getByTestId("edit-theme")).toBeVisible()
    expect(screen.getByText("Edit active theme")).toBeVisible()
  })

  it("should call openThemeCreator if the button has been clicked", async () => {
    const user = userEvent.setup()
    const availableThemes = [...createPresetThemes()]
    const props = getProps()
    const context = getContext({ availableThemes })

    customRenderLibContext(<SettingsDialog {...props} />, context)

    expect(screen.getByTestId("edit-theme")).toBeVisible()
    await user.click(screen.getByText("Edit active theme"))
    expect(props.openThemeCreator).toHaveBeenCalledTimes(1)
  })

  it("should hide the theme creator button if not in developer mode", () => {
    const availableThemes = [lightTheme, darkTheme]
    const props = getProps({ developerMode: false })
    const context = getContext({ availableThemes })

    customRenderLibContext(<SettingsDialog {...props} />, context)

    expect(screen.queryByTestId("edit-theme")).not.toBeInTheDocument()
  })
})


================================================
File: /frontend/app/src/components/StreamlitDialog/SettingsDialog.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  ChangeEvent,
  FC,
  memo,
  useCallback,
  useContext,
  useEffect,
  useRef,
} from "react"

import {
  BaseButton,
  BaseButtonKind,
  LibContext,
  Modal,
  ModalBody,
  ModalHeader,
  StreamlitMarkdown,
  ThemeConfig,
  UISelectbox,
} from "@streamlit/lib"
import { MetricsManager } from "@streamlit/app/src/MetricsManager"

import {
  StyledButtonContainer,
  StyledCheckbox,
  StyledDialogBody,
  StyledFullRow,
  StyledHeader,
  StyledLabel,
} from "./styled-components"
import { UserSettings } from "./UserSettings"

export interface Props {
  isServerConnected: boolean
  onClose: () => void
  onSave: (settings: UserSettings) => void
  settings: UserSettings
  allowRunOnSave: boolean
  developerMode: boolean
  openThemeCreator: () => void
  animateModal: boolean
  metricsMgr: MetricsManager
}

const ThemeCreatorButton: FC<Pick<Props, "openThemeCreator">> = ({
  openThemeCreator,
}) => {
  return (
    <StyledButtonContainer data-testid="edit-theme">
      <BaseButton onClick={openThemeCreator} kind={BaseButtonKind.SECONDARY}>
        Edit active theme
      </BaseButton>
    </StyledButtonContainer>
  )
}

/**
 * Implements a dialog that is used to configure user settings.
 */
export const SettingsDialog: FC<Props> = memo(function SettingsDialog({
  isServerConnected,
  onClose,
  onSave,
  settings,
  allowRunOnSave,
  developerMode,
  openThemeCreator,
  animateModal,
  metricsMgr,
}) {
  const libContext = useContext(LibContext)
  const activeSettings = useRef(settings)
  const isFirstRun = useRef(true)
  const [state, setState] = React.useState<UserSettings>({ ...settings })

  const changeSingleSetting = useCallback(
    (name: string, value: boolean): void => {
      setState(state => ({ ...state, [name]: value }))
    },
    []
  )

  useEffect(() => {
    if (isFirstRun.current) {
      isFirstRun.current = false
      return
    }

    activeSettings.current = state
    onSave(activeSettings.current)
  }, [onSave, state])

  const handleCheckboxChange = useCallback(
    (e: ChangeEvent<HTMLInputElement>): void => {
      changeSingleSetting(e.target.name, e.target.checked)
    },
    [changeSingleSetting]
  )

  const handleThemeChange = useCallback(
    (index: number | null): void => {
      const newTheme = libContext.availableThemes[index ?? 0]

      metricsMgr.enqueue("menuClick", {
        label: "changeTheme",
      })

      libContext.setTheme(newTheme)
    },
    [libContext, metricsMgr]
  )

  const themeIndex = libContext.availableThemes.findIndex(
    (theme: ThemeConfig) => theme.name === libContext.activeTheme.name
  )

  return (
    <Modal animate={animateModal} isOpen onClose={onClose}>
      <ModalHeader>Settings</ModalHeader>
      <ModalBody>
        <StyledDialogBody>
          {allowRunOnSave && (
            <React.Fragment>
              <StyledFullRow>
                <StyledHeader>Development</StyledHeader>
                <label>
                  <StyledCheckbox
                    disabled={!isServerConnected}
                    type="checkbox"
                    name="runOnSave"
                    checked={state.runOnSave && isServerConnected}
                    onChange={handleCheckboxChange}
                  />{" "}
                  Run on save
                </label>
                <StreamlitMarkdown
                  source="Automatically updates the app when the underlying code is updated."
                  allowHTML={false}
                  isCaption
                />
              </StyledFullRow>
            </React.Fragment>
          )}

          <StyledFullRow>
            <StyledHeader>Appearance</StyledHeader>
            <label>
              <StyledCheckbox
                type="checkbox"
                name="wideMode"
                checked={state.wideMode}
                onChange={handleCheckboxChange}
              />{" "}
              Wide mode
            </label>
            <StreamlitMarkdown
              source=" Turn on to make this app occupy the entire width of the screen."
              allowHTML={false}
              isCaption
            />
          </StyledFullRow>

          {!!libContext.availableThemes.length && (
            <StyledFullRow>
              <StyledLabel>Choose app theme, colors and fonts</StyledLabel>
              <UISelectbox
                options={libContext.availableThemes.map(
                  (theme: ThemeConfig) => theme.name
                )}
                disabled={false}
                onChange={handleThemeChange}
                value={themeIndex}
              />
              {developerMode && (
                <ThemeCreatorButton openThemeCreator={openThemeCreator} />
              )}
            </StyledFullRow>
          )}
        </StyledDialogBody>
      </ModalBody>
    </Modal>
  )
})


================================================
File: /frontend/app/src/components/StreamlitDialog/StreamlitDialog.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { Fragment } from "react"

import { screen } from "@testing-library/react"

import { mockSessionInfo, render, SessionInfo } from "@streamlit/lib"

import { DialogType, StreamlitDialog } from "./StreamlitDialog"

function flushPromises(): Promise<void> {
  return new Promise(process.nextTick)
}

describe("StreamlitDialog", () => {
  it("renders clear cache dialog and focuses clear cache button", async () => {
    render(
      <Fragment>
        {StreamlitDialog({
          type: DialogType.CLEAR_CACHE,
          confirmCallback: () => {},
          defaultAction: () => {},
          onClose: () => {},
        })}
      </Fragment>
    )

    // Flush promises to give componentDidMount() a chance to run.
    await flushPromises()

    const buttons = await screen.findAllByRole("button")
    const targetButton = buttons[1]
    expect(targetButton).toHaveTextContent("Clear caches")
    expect(targetButton).toHaveFocus()
  })

  it("renders secondary dialog buttons properly", async () => {
    render(
      <Fragment>
        {StreamlitDialog({
          type: DialogType.CLEAR_CACHE,
          confirmCallback: () => {},
          defaultAction: () => {},
          onClose: () => {},
        })}
      </Fragment>
    )

    const baseButtonSecondary = await screen.findByTestId(
      "stBaseButton-secondary"
    )
    expect(baseButtonSecondary).toBeDefined()
  })

  it("renders tertiary dialog buttons properly", async () => {
    render(
      <Fragment>
        {StreamlitDialog({
          type: DialogType.CLEAR_CACHE,
          confirmCallback: () => {},
          defaultAction: () => {},
          onClose: () => {},
        })}
      </Fragment>
    )

    const baseButtonGhost = await screen.findByTestId("stBaseButton-ghost")
    expect(baseButtonGhost).toBeDefined()
  })
})

describe("aboutDialog", () => {
  it("shows version string if SessionInfo is initialized", async () => {
    render(
      <Fragment>
        {StreamlitDialog({
          type: DialogType.ABOUT,
          sessionInfo: mockSessionInfo({ streamlitVersion: "42.42.42" }),
          onClose: () => {},
        })}
      </Fragment>
    )

    expect(screen.getByTestId("stDialog")).toBeInTheDocument()
    // need a regex because there is a line break
    const versionRegex = /Streamlit v\s*42\.42\.42/
    const versionText = screen.getByText(versionRegex)
    expect(versionText).toBeDefined()
  })

  it("shows no version string if SessionInfo is not initialized", async () => {
    const sessionInfo = new SessionInfo()
    expect(sessionInfo.isSet).toBe(false)

    render(
      <Fragment>
        {StreamlitDialog({
          type: DialogType.ABOUT,
          sessionInfo,
          onClose: () => {},
        })}
