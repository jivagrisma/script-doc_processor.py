
  it("should detect Internet Explorer on Windows", () => {
    mockUserAgent(
      "Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; AS; rv:11.0) like Gecko"
    )

    const result = getBrowserInfo()
    expect(result).toEqual({
      browserName: "IE",
      browserVersion: "11.0",
      deviceType: "desktop",
      os: "Windows",
    })
  })

  it("should detect Maxthon browser on Windows", () => {
    mockUserAgent(
      "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:65.0) Gecko/20100101 Firefox/65.0 Maxthon/6.1.0.2000"
    )

    const result = getBrowserInfo()
    expect(result).toEqual({
      browserName: "Maxthon",
      browserVersion: "6.1.0.2000",
      deviceType: "desktop",
      os: "Windows",
    })
  })

  it("should detect Chrome on Chrome OS", () => {
    mockUserAgent(
      "Mozilla/5.0 (X11; CrOS x86_64 13421.99.0) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36"
    )

    const result = getBrowserInfo()
    expect(result).toEqual({
      browserName: "Chrome",
      browserVersion: "91.0.4472.114",
      deviceType: "desktop",
      os: "Chromium OS",
    })
  })

  it("should detect UC Browser on Android", () => {
    mockUserAgent(
      "Mozilla/5.0 (Linux; Android 9; M2004J19C) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 UCBrowser/13.0.0.1288 Mobile Safari/537.36"
    )

    const result = getBrowserInfo()
    expect(result).toEqual({
      browserName: "UCBrowser",
      browserVersion: "13.0.0.1288",
      deviceType: "mobile",
      os: "Android",
    })
  })

  it("should detect Samsung Internet on Android", () => {
    mockUserAgent(
      "Mozilla/5.0 (Linux; Android 10; SAMSUNG SM-G973F) AppleWebKit/537.36 (KHTML, like Gecko) SamsungBrowser/13.2 Chrome/79.0.3945.136 Mobile Safari/537.36"
    )

    const result = getBrowserInfo()
    expect(result).toEqual({
      browserName: "Samsung Internet",
      browserVersion: "13.2",
      deviceType: "mobile",
      os: "Android",
    })
  })

  it("should detect Safari browser on macOS", () => {
    mockUserAgent(
      "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Safari/605.1.15"
    )

    const result = getBrowserInfo()
    expect(result).toEqual({
      browserName: "Safari",
      browserVersion: "14.0",
      deviceType: "desktop",
      os: "Mac OS",
    })
  })

  it("should detect Safari browser on iOS", () => {
    mockUserAgent(
      "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1"
    )

    const result = getBrowserInfo()
    expect(result).toEqual({
      browserName: "Mobile Safari",
      browserVersion: "14.0",
      deviceType: "mobile",
      os: "iOS",
    })
  })

  it("should detect Chrome browser on iOS", () => {
    mockUserAgent(
      "Mozilla/5.0 (iPhone; CPU iPhone OS 14_6 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) CriOS/91.0.4472.114 Mobile/15E148 Safari/604.1"
    )

    const result = getBrowserInfo()
    expect(result).toEqual({
      browserName: "Chrome",
      browserVersion: "91.0.4472.114",
      deviceType: "mobile",
      os: "iOS",
    })
  })
})


================================================
File: /frontend/app/src/util/getBrowserInfo.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import UAParser from "ua-parser-js"

function getBrowserInfo(): {
  browserName: string
  browserVersion: string
  deviceType: string
  os: string
} {
  const parser = new UAParser()
  const result = parser.getResult()

  return {
    browserName: result.browser.name || "Unknown",
    browserVersion: result.browser.version || "Unknown",
    /**
     * 'desktop' is not a valid value for device.type in ua-parser-js.
     * We default to 'desktop' if the value is not present.
     * Possible options from ua-parser-js are:
     * 'mobile', 'tablet', 'smarttv', 'wearable', 'embedded', 'console'
     */
    deviceType: result.device.type || "desktop",
    os: result.os.name || "Unknown",
  }
}

export default getBrowserInfo


================================================
File: /frontend/app/src/util/useThemeManager.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { act, renderHook } from "@testing-library/react-hooks"

import {
  AUTO_THEME_NAME,
  createPresetThemes,
  CUSTOM_THEME_NAME,
  darkTheme,
  LocalStore,
  setCachedTheme,
  ThemeConfig,
} from "@streamlit/lib"

import { useThemeManager } from "./useThemeManager"

const mockCustomThemeConfig = {
  primaryColor: "#1A6CE7",
  backgroundColor: "#FFFFFF",
  secondaryBackgroundColor: "#F5F5F5",
  textColor: "#1A1D21",
  widgetBackgroundColor: "#FFFFFF",
  widgetBorderColor: "#D3DAE8",
  skeletonBackgroundColor: "#CCDDEE",
  fontFaces: [
    {
      family: "Inter",
      url: "https://rsms.me/inter/font-files/Inter-Regular.woff2?v=3.19",
      weight: 400,
    },
  ],
}

describe("useThemeManager", () => {
  beforeEach(() => {
    // sourced from:
    // https://jestjs.io/docs/en/manual-mocks#mocking-methods-which-are-not-implemented-in-jsdom
    Object.defineProperty(window, "matchMedia", {
      writable: true,
      value: vi.fn().mockImplementation(query => ({
        matches: false,
        media: query,
        onchange: null,
        addListener: vi.fn(), // deprecated
        removeListener: vi.fn(), // deprecated
        addEventListener: vi.fn(),
        removeEventListener: vi.fn(),
        dispatchEvent: vi.fn(),
      })),
    })
  })

  afterEach(() => {
    window.localStorage.clear()
  })

  it("updates the theme", () => {
    const { result } = renderHook(() => useThemeManager())
    const [themeManager] = result.current

    act(() => {
      themeManager.setTheme(darkTheme)
    })

    const [themeManager2] = result.current
    const updatedTheme: ThemeConfig = themeManager2.activeTheme

    expect(updatedTheme.name).toBe("Dark")

    const updatedLocalStorage = JSON.parse(
      window.localStorage.getItem(LocalStore.ACTIVE_THEME) || ""
    )

    expect(updatedLocalStorage.name).toBe("Dark")
  })

  it("does not save Auto theme", () => {
    const { result } = renderHook(() => useThemeManager())
    const [themeManager] = result.current

    act(() => {
      themeManager.setTheme(darkTheme)
    })

    const [themeManager2] = result.current

    act(() => {
      themeManager2.setTheme({
        ...darkTheme,
        name: AUTO_THEME_NAME,
      })
    })

    const updatedLocalStorage = window.localStorage.getItem(
      LocalStore.ACTIVE_THEME
    )

    expect(updatedLocalStorage).toBe(null)
  })

  it("updates availableThemes", () => {
    const { result } = renderHook(() => useThemeManager())
    const [themeManager] = result.current

    const initialThemes = themeManager.availableThemes

    act(() => {
      themeManager.addThemes([darkTheme])
      themeManager.addThemes([darkTheme])
    })

    const [themeManager2] = result.current
    const newThemes = themeManager2.availableThemes

    // Should only have added one theme despite multiple calls adding themes.
    expect(newThemes.length).toBe(initialThemes.length + 1)
  })

  it("sets the cached theme as the default theme if one is set", () => {
    setCachedTheme(darkTheme)

    const { result } = renderHook(() => useThemeManager())
    const [themeManager] = result.current
    const { activeTheme, availableThemes } = themeManager

    expect(activeTheme.name).toBe(darkTheme.name)
    expect(availableThemes.length).toBe(createPresetThemes().length)
  })

  it("includes a custom theme as an available theme if one is cached", () => {
    setCachedTheme({
      ...darkTheme,
      name: CUSTOM_THEME_NAME,
    })

    const { result } = renderHook(() => useThemeManager())
    const [themeManager] = result.current
    const { activeTheme, availableThemes } = themeManager

    expect(activeTheme.name).toBe(CUSTOM_THEME_NAME)
    expect(availableThemes.length).toBe(createPresetThemes().length + 1)
  })

  it("handles custom theme sent from Host", () => {
    const { result } = renderHook(() => useThemeManager())
    const [themeManager, fontFaces] = result.current

    expect(fontFaces).toHaveLength(0)

    act(() => {
      themeManager.setImportedTheme(mockCustomThemeConfig)
    })

    const [themeManager2, fontFaces2] = result.current

    const updatedTheme: ThemeConfig = themeManager2.activeTheme

    expect(updatedTheme.name).toBe(CUSTOM_THEME_NAME)
    expect(updatedTheme.emotion.colors.primary).toBe(
      mockCustomThemeConfig.primaryColor
    )

    expect(fontFaces2).toHaveLength(1)
    expect(fontFaces2).toEqual(mockCustomThemeConfig.fontFaces)
  })
})


================================================
File: /frontend/app/src/util/useThemeManager.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { useCallback, useEffect, useState } from "react"

import {
  AUTO_THEME_NAME,
  createAutoTheme,
  createPresetThemes,
  createTheme,
  CUSTOM_THEME_NAME,
  CustomThemeConfig,
  getDefaultTheme,
  getHostSpecifiedTheme,
  ICustomThemeConfig,
  isPresetTheme,
  removeCachedTheme,
  setCachedTheme,
  ThemeConfig,
} from "@streamlit/lib"

export interface ThemeManager {
  activeTheme: ThemeConfig
  availableThemes: ThemeConfig[]
  setTheme: (theme: ThemeConfig) => void
  addThemes: (themes: ThemeConfig[]) => void
  setImportedTheme: (themeInfo: ICustomThemeConfig) => void
}

export function useThemeManager(): [ThemeManager, object[]] {
  const defaultTheme = getDefaultTheme()
  const [theme, setTheme] = useState<ThemeConfig>(defaultTheme)
  const [fontFaces, setFontFaces] = useState<object[]>([])
  const [availableThemes, setAvailableThemes] = useState<ThemeConfig[]>([
    ...createPresetThemes(),
    ...(isPresetTheme(defaultTheme) ? [] : [defaultTheme]),
  ])

  const addThemes = (themeConfigs: ThemeConfig[]): void => {
    setAvailableThemes([...createPresetThemes(), ...themeConfigs])
  }

  const updateTheme = useCallback(
    (newTheme: ThemeConfig): void => {
      if (newTheme !== theme) {
        setTheme(newTheme)

        // Only save to localStorage if it is not Auto since auto is the default.
        // Important to not save since it can change depending on time of day.
        if (newTheme.name === AUTO_THEME_NAME) {
          removeCachedTheme()
        } else {
          setCachedTheme(newTheme)
        }
      }
    },
    [setTheme, theme]
  )

  const updateAutoTheme = useCallback((): void => {
    if (theme.name === AUTO_THEME_NAME) {
      updateTheme(getHostSpecifiedTheme())
    }
    const constantThemes = availableThemes.filter(
      theme => theme.name !== AUTO_THEME_NAME
    )
    setAvailableThemes([createAutoTheme(), ...constantThemes])
  }, [theme.name, availableThemes, updateTheme])

  const setImportedTheme = useCallback(
    (themeInfo: ICustomThemeConfig): void => {
      // If fonts are coming from a URL, they need to be imported through the FontFaceDeclaration
      // component. So let's store them in state so we can pass them as props.
      if (themeInfo.fontFaces) {
        setFontFaces(themeInfo.fontFaces as object[])
      }

      const themeConfigProto = new CustomThemeConfig(themeInfo)
      const customTheme = createTheme(CUSTOM_THEME_NAME, themeConfigProto)
      updateTheme(customTheme)
    },
    [setFontFaces, updateTheme]
  )

  useEffect(() => {
    const mediaMatch = window.matchMedia("(prefers-color-scheme: dark)")
    mediaMatch.addEventListener("change", updateAutoTheme)
    // Browsers do not revert back to a dark theme after printing, so we
    // should check and update the theme after printing if necessary.
    window.addEventListener("afterprint", updateAutoTheme)
    return () => {
      window.removeEventListener("afterprint", updateAutoTheme)
      mediaMatch.removeEventListener("change", updateAutoTheme)
    }
  }, [theme, availableThemes, updateAutoTheme])

  return [
    {
      setTheme: updateTheme,
      activeTheme: theme,
      addThemes,
      availableThemes,
      setImportedTheme,
    },
    fontFaces,
  ]
}


================================================
File: /frontend/eslint-plugin-streamlit-custom/index.js
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const useStrictNullEqualityChecks = require("./use-strict-null-equality-checks")
const noHardcodedThemeValues = require("./no-hardcoded-theme-values")

module.exports = {
  rules: {
    "use-strict-null-equality-checks": useStrictNullEqualityChecks,
    "no-hardcoded-theme-values": noHardcodedThemeValues,
  },
}


================================================
File: /frontend/eslint-plugin-streamlit-custom/no-hardcoded-theme-values.js
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * This rule will disallow hardcoded theme values in styled-components / in all object expressions.
 * This includues:
 * - <div style={{ backgroundColor: 'red', width: '100px' }} />
 * - styled.div`background-color: red; width: 100px;`
 * - const foo = styled.div(() => { backgroundColor: 'red', width: '100px' })
 */
module.exports = {
  meta: {
    name: "no-hardcoded-theme-values",
    type: "error",
    docs: {
      description: "Disallow hardcoded theme values",
      category: "Best Practices",
      recommended: true,
    },
    fixable: "code",
    schema: [],
  },
  create(context) {
    // Properties to check for values not allowed byt the allowedValuesRegex. We check the whole set of CSS properties with the allowed values,
    // instead of checking for each property individually based on what they allow (e.g. only check 'background-color' for 'transparent'), since
    // we do not need more fine granular matching.
    const cssPropertiesToCheck =
      /^(.*color|width|height|margin.*|padding.*|lineHeight|line-height|border.*|.*radius|font.*|zIndex|z-index)$/i

    // Match and highlight as errors all values that either do not contain the word 'theme' or are not a CSS built-in value.
    // We also allow the value 0 because we use it extensively in our codebase.
    // Also allow %, em, vh, vw units after a number because they are relative and relative values are okay from our theming perspective. We don't allow 'rem'
    // though because its less fine-granular than 'em' and we use(d) it heavily to hardcode any kinds of values in our codebase.
    // The following font-related values are allowed: 'small-caps', 'italic', 'normal', 'liga'.
    // The part '(((-)?[0-9]+(\.[0-9]+)?(%|em|vh|vw)|0)\s?)+' allows for non-zero digits with a unit or 0, or a combination of both separated by whitespaces.
    const allowedValuesRegex =
      /^(?!.*theme)(?!('|")?(transparent|solid|initial|none|inherit|auto|unset|fit-content|collapse|separate|0|(((-)?[0-9]+(\.[0-9]+)?(%|em|vh|vw)|0)\s?)+|small-caps|italic|normal|liga)( !important)?('|")?$).*$/i

    return {
      ObjectExpression(node) {
        node.properties.map(property => {
          if (
            !property.key ||
            !property.key.name ||
            !property.value ||
            !property.value.raw
          ) {
            return
          }
          if (
            cssPropertiesToCheck.test(property.key.name) &&
            allowedValuesRegex.test(property.value.raw)
          ) {
            context.report({
              node: property,
              message:
                "Hardcoded theme values are not allowed. All values must start with 'theme' or be a CSS built-in value such as 'none'.",
            })
          }
        })
      },
      TaggedTemplateExpression(node) {
        // we only check templateExpressions in combination of the styled object,
        // e.g. styled.div`color: theme.colors.primary;`
        if (
          !node.tag.object ||
          node.tag.object.name !== "styled" ||
          !node.quasi
        ) {
          return
        }
        node.quasi.quasis.map(quasi => {
          if (quasi.type !== "TemplateElement") {
            return
          }

          const styleProperties = quasi.value.raw.split(";")
          for (const styleProperty of styleProperties) {
            const [property, value] = styleProperty.split(":")
            if (!property || !value) {
              continue
            }
            const trimmedProperty = property.trim()
            const trimmedValue = value.trim()
            if (
              cssPropertiesToCheck.test(trimmedProperty) &&
              allowedValuesRegex.test(trimmedValue) &&
              // when a function is passed, e.g. "width: ${({ theme }) => theme }px",
              // the trimmedValue is empty with the current parsing. We skip this for now to not
              // overcomplicate the parsing.
              trimmedValue !== ""
            ) {
              context.report({
                node: quasi,
                message:
                  "Hardcoded theme values are not allowed in template strings. All values must start with 'theme' or be a CSS built-in value such as 'none'. In general, please use the styled-object notation anyways.",
              })
            }
          }
        })
      },
    }
  },
}


================================================
File: /frontend/eslint-plugin-streamlit-custom/no-hardcoded-theme-values.test.js
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { RuleTester } = require("eslint")
const noHardcodedThemeValues = require("./no-hardcoded-theme-values")

const ruleTester = new RuleTester({
  parserOptions: {
    // its the same we have defined in our .eslintrc.js. For some reason,
    // we have to specify it again, otherwise the template string tests fail.
    ecmaVersion: 2018,
  },
})

ruleTester.run("no-hardcoded-theme-values", noHardcodedThemeValues, {
  valid: [
    {
      name: "theme value is allowed",
      code: "var a = { color: theme.colors.primary };",
    },
    {
      name: "zIndex is checked",
      code: "var a = { zIndex: theme.someZIndex };",
    },
    {
      name: "built-in values are allowed: 'auto'",
      code: "var a = { lineHeight: 'auto' };",
    },
    {
      name: "built-in values are allowed: 'transparent'",
      code: "var a = { lineHeight: 'transparent' };",
    },
    {
      name: "built-in values are allowed: 'solid'",
      code: "var a = { lineHeight: 'solid' };",
    },
    {
      name: "built-in values are allowed: 'initial'",
      code: "var a = { lineHeight: 'initial' };",
    },
    {
      name: "built-in values are allowed: 'none'",
      code: "var a = { lineHeight: 'none' };",
    },
    {
      name: "built-in values are allowed: 'collapse'",
      code: "var a = { border: 'collapse' };",
    },
    {
      name: "built-in values are allowed: 'fit-content'",
      code: "var a = { width: 'fit-content' };",
    },
    {
      name: "built-in values are allowed: 'inherit'",
      code: "var a = { lineHeight: 'inherit' };",
    },
    {
      name: "built-in values are allowed together with the '!important' directive: 'inherit !important'",
      code: "var a = { lineHeight: 'inherit !important' };",
    },
    {
      name: "number value of 0 is allowed",
      code: "var a = { color: theme.colors.primary, lineHeight: 0 };",
    },
    {
      name: "em, vh, vw, % units after numbers are allowed",
      code: "var a = { color: theme.colors.primary, height: '1em', maxHeight: '100vh', width: '42vw', maxWidth: '99%' };",
    },
    {
      name: "negative and decimal numbers with valid units are allowed",
      code: "var a = { color: theme.colors.primary, height: '1.0em', maxHeight: '0.09vh', width: '-4.2vw' };",
    },
    {
      name: "'small-caps' is allowed, which is used by fonts",
      code: "var a = { fontVariant: 'small-caps' };",
    },
    {
      name: "template strings with valid values are allowed",
      code: "var MyComponent = styled.div`color: theme.colors.primary; line-height: theme.lineHeights.body;`",
    },
    {
      name: "multiple numbers are allowed to account for shorthand assignment",
      code: "var a = { margin: '10em 0 30em 40em' };",
    },
  ],
  invalid: [
    {
      name: "color value should not be allowed",
      code: "var a = { color: 'red' };",
      errors: 1,
    },
    {
      name: "color value and line-height number should not be allowed",
      code: "var a = { color: 'red', lineHeight: 1.5 };",
      errors: 2,
    },
    {
      name: "color value should not be allowed, but line-height value is allowed",
      code: "var a = { color: 'red', lineHeight: 'inherit' };",
      errors: 1,
    },
    {
      name: "number should not be allowed",
      code: "var a = { margin: 40 };",
      errors: 1,
    },
    {
      name: "zIndex is not allowed to have a number",
      code: "var a = { zIndex: 100 };",
      errors: 1,
    },
    {
      name: "percentages in non-numbers are disallowed",
      code: "var a = { color: theme.colors.primary, lineHeight: 'sneaky-non-number%' };",
      errors: 1,
    },
    {
      name: "rem unit with number is disallowed",
      code: "var a = { lineHeight: '1rem' };",
      errors: 1,
    },
    {
      name: "hardcoded fonts are not allowed",
      code: "var a = { font: 'Helvetica, Calibri, Roboto, \"Open Sans\", Arial, sans-serif' };",
      errors: 1,
    },
    {
      name: "template strings with valid values are allowed",
      code: `var MyComponent = styled.div\`
        color: 1px;
        line-height: theme.lineHeights.body;
        \`
      `,
      errors: 1,
    },
  ],
})

console.log("All 'no-hardcoded-theme-values' tests passed!")


================================================
File: /frontend/eslint-plugin-streamlit-custom/package.json
================================================
{
  "name": "eslint-plugin-streamlit-custom",
  "license": "Apache-2.0",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "test": "node use-strict-null-equality-checks.test.js && node no-hardcoded-theme-values.test.js"
  }
}


================================================
File: /frontend/eslint-plugin-streamlit-custom/use-strict-null-equality-checks.js
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = {
  meta: {
    name: "use-strict-null-equality-checks",
    type: "suggestion",
    docs: {
      description: "Disallow == null and != null comparisons",
      category: "Best Practices",
      recommended: true,
    },
    fixable: "code",
    schema: [],
  },
  create(context) {
    return {
      BinaryExpression(node) {
        if (node.operator === "==" || node.operator === "!=") {
          if (
            (node.right.type === "Literal" && node.right.value === null) ||
            (node.right.type === "Identifier" &&
              node.right.name === "undefined")
          ) {
            context.report({
              node,
              message:
                "Use isNullOrUndefined or notNullOrUndefined instead of == null or != null",
              fix(fixer) {
                const isNegated = node.operator === "!="
                const replacement = isNegated
                  ? "notNullOrUndefined"
                  : "isNullOrUndefined"
                const sourceCode = context.getSourceCode()
                const leftText = sourceCode.getText(node.left)
                return fixer.replaceText(node, `${replacement}(${leftText})`)
              },
            })
          }
        }
      },
    }
  },
}


================================================
File: /frontend/eslint-plugin-streamlit-custom/use-strict-null-equality-checks.test.js
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

const { RuleTester } = require("eslint")
const useStrictNullEqualityChecks = require("./use-strict-null-equality-checks")

const ruleTester = new RuleTester({})

// Throws error if the tests do not pass
ruleTester.run(
  "use-strict-null-equality-checks",
  useStrictNullEqualityChecks,
  {
    valid: [
      {
        code: "isNullOrUndefined(foo)",
      },
      {
        code: "notNullOrUndefined(foo)",
      },
    ],
    invalid: [
      {
        code: "foo == null",
        output: "isNullOrUndefined(foo)",
        errors: 1,
      },
      {
        code: "foo != null",
        output: "notNullOrUndefined(foo)",
        errors: 1,
      },
      {
        code: "foo == undefined",
        output: "isNullOrUndefined(foo)",
        errors: 1,
      },
      {
        code: "foo != undefined",
        output: "notNullOrUndefined(foo)",
        errors: 1,
      },
    ],
  }
)

console.log("All tests passed!")


================================================
File: /frontend/lib/package.json
================================================
{
  "name": "@streamlit/lib",
  "version": "1.41.1",
  "private": true,
  "license": "Apache-2.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "sideEffects": [
    "**/vendor/bokeh/**"
  ],
  "files": [
    "dist"
  ],
  "scripts": {
    "build": "yarn build:src && yarn build:vendor && yarn build:assets && yarn build:proto && yarn build:lib-dev",
    "build:prod": "yarn build:src && yarn build:vendor && yarn build:assets && yarn build:proto && yarn build:lib-type-prod",
    "build:lib-type-prod": "tsc -p ./tsconfig.prod.json && tsc-alias -p ./tsconfig.prod.json",
    "build:lib-dev": "tsc -p ./tsconfig.json && tsc-alias -p ./tsconfig.json",
    "build:src": "env NODE_ENV=development vite build",
    "build:vendor": "rsync -av --exclude='*.ts' ./src/vendor/ ./dist/vendor",
    "build:assets": "cp -R ./src/assets ./dist",
    "build:proto": "cp ./src/proto* ./dist",
    "typecheck": "tsc",
    "test": "vitest run",
    "testWatch": "vitest",
    "lint": "eslint --ext .js --ext .jsx --ext .ts --ext .tsx --max-warnings 0 src"
  },
  "dependencies": {
    "@deck.gl/aggregation-layers": "^9.0.37",
    "@deck.gl/carto": "^9.0.37",
    "@deck.gl/core": "^9.0.37",
    "@deck.gl/geo-layers": "^9.0.37",
    "@deck.gl/json": "^9.0.37",
    "@deck.gl/layers": "^9.0.37",
    "@deck.gl/mesh-layers": "^9.0.37",
    "@deck.gl/react": "^9.0.37",
    "@emotion-icons/emotion-icon": "^4.1.0",
    "@emotion-icons/material-outlined": "^3.14.0",
    "@emotion-icons/material-rounded": "^3.14.0",
    "@emotion-icons/open-iconic": "^3.14.0",
    "@emotion/cache": "^11.13.5",
    "@emotion/is-prop-valid": "^1.2.0",
    "@emotion/react": "^11.13.5",
    "@emotion/styled": "^11.13.5",
    "@glideapps/glide-data-grid": "6.0.4-alpha8",
    "@glideapps/glide-data-grid-cells": "6.0.4-alpha8",
    "@glideapps/glide-data-grid-source": "6.0.4-alpha8",
    "@loaders.gl/core": "^4.2.5",
    "@loaders.gl/csv": "^4.2.5",
    "@loaders.gl/gltf": "^4.2.5",
    "@swc/plugin-emotion": "^3.0.9",
    "@vitejs/plugin-react-swc": "^3.6.0",
    "@wavesurfer/react": "^1.0.7",
    "apache-arrow": "^18.0.0",
    "axios": "^1.7.9",
    "baseui": "12.2.0",
    "camelcase": "^7.0.1",
    "classnames": "^2.3.2",
    "clipboard": "^2.0.11",
    "color2k": "^2.0.2",
    "d3": "^7.9.0",
    "d3-color": "^3.1.0",
    "d3-graphviz": "^5.6.0",
    "date-fns": "^2.6.0",
    "decamelize": "^6.0.0",
    "deck.gl": "^9.0.37",
    "dompurify": "^3.1.3",
    "fzy.js": "^0.4.1",
    "hoist-non-react-statics": "^3.3.2",
    "immer": "^9.0.19",
    "json5": "^2.2.3",
    "katex": "^0.16.10",
    "lodash": "^4.17.21",
    "mapbox-gl": "^1.13.2",
    "marked": "^4.2.12",
    "mdast-util-find-and-replace": "^2.2.2",
    "moment": "^2.30.1",
    "moment-duration-format": "^2.3.2",
    "moment-timezone": "^0.5.45",
    "native-file-system-adapter": "^3.0.1",
    "node-emoji": "^1.11.0",
    "numbro": "^2.5.0",
    "urlpattern-polyfill": "^10.0.0",
    "plotly.js": "^2.34.0",
    "protobufjs": "^7.2.5",
    "query-string": "^8.1.0",
    "re-resizable": "^6.10.1",
    "react-color": "^2.18.1",
    "react-debounce-render": "^8.0.2",
    "react-device-detect": "^2.2.2",
    "react-dropzone": "^12.1.0",
    "react-feather": "^2.0.10",
    "react-json-view": "^1.19.1",
    "react-map-gl": "^5.3.21",
    "react-markdown": "^8.0.7",
    "react-plotly.js": "^2.6.0",
    "react-responsive-carousel": "^3.2.23",
    "react-syntax-highlighter": "^15.5.0",
    "react-webcam": "7.1.1",
    "react-window": "^1.8.8",
    "rehype-katex": "^6.0.2",
    "rehype-raw": "^6.1.1",
    "remark-directive": "^2.0.1",
    "remark-emoji": "^3.1.0",
    "remark-gfm": "^3.0.1",
    "remark-math": "^5.1.1",
    "sprintf-js": "^1.1.3",
    "styletron-react": "^6.1.0",
    "typed-signals": "^2.5.0",
    "typescript": "^4.9.5",
    "unist-util-visit": "^4.1.2",
    "uuid": "^9.0.0",
    "vega": "^5.30.0",
    "vega-embed": "^6.26.0",
    "vega-interpreter": "^1.0.5",
    "vega-lite": "5.21.0",
    "vite": "^5.3.5",
    "vite-plugin-svgr": "^4.2.0",
    "vite-tsconfig-paths": "^4.3.1",
    "wavesurfer.js": "^7.8.10",
    "xxhashjs": "^0.2.2"
  },
  "peerDependencies": {
    "react": "^17.0.0 || ^18.0.0",
    "react-dom": "^17.0.0 || ^18.0.0"
  },
  "browserslist": [
    ">0.2%",
    "not dead",
    "not ie <= 11",
    "not op_mini all"
  ],
  "devDependencies": {
    "@testing-library/react": "^14.1.2",
    "@testing-library/jest-dom": "^6.6.3",
    "@testing-library/react-hooks": "^8.0.1",
    "@testing-library/user-event": "^14.4.3",
    "@types/d3": "^7.4.3",
    "@types/d3-color": "^3.1.3",
    "@types/d3-graphviz": "^2.6.10",
    "@types/dompurify": "^3.0.5",
    "@types/node-emoji": "^1.8.2",
    "@types/plotly.js": "^2.29.2",
    "@types/react": "^18.2.0",
    "@types/react-color": "^3.0.6",
    "@types/react-dom": "^18.2.0",
    "@types/react-plotly.js": "^2.6.3",
    "@types/react-syntax-highlighter": "^15.5.5",
    "@types/sprintf-js": "^1.1.4",
    "@types/uuid": "^9.0.2",
    "@types/wavesurfer.js": "^6.0.12",
    "@types/xxhashjs": "^0.2.2",
    "axios-mock-adapter": "^1.21.4",
    "eslint-plugin-streamlit-custom": "file:../eslint-plugin-streamlit-custom",
    "eslint-plugin-vitest": "^0.5.4",
    "node-fetch": "2.6.7",
    "patch-package": "^8.0.0",
    "postinstall-postinstall": "^2.1.0",
    "protobufjs-cli": "^1.1.0",
    "timezone-mock": "^1.3.6",
    "tsc-alias": "^1.8.5",
    "vitest": "^2.1.2",
    "vitest-canvas-mock": "^0.3.3",
    "vitest-fetch-mock": "^0.3.0"
  }
}


================================================
File: /frontend/lib/tsconfig.json
================================================
{
  "extends": "../tsconfig.dev.json",
  "compilerOptions": {
    "checkJs": false,
    "baseUrl": ".",
    "noEmit": false,
    "emitDeclarationOnly": true,
    "declaration": true,
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src", "declarations.d.ts"],
  "exclude": ["node_modules/**/*", "**/proto.js"]
}


================================================
File: /frontend/lib/tsconfig.prod.json
================================================
{
    "extends": "./tsconfig.json",
    "compilerOptions": {
      "paths": { "@streamlit/lib/src/*": ["src/*"] }
  }
}


================================================
File: /frontend/lib/vite-env.d.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="vite/client" />
/// <reference types="vitest/globals" />


================================================
File: /frontend/lib/vite.config.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { defineConfig } from "vite"
import react from "@vitejs/plugin-react-swc"
import viteTsconfigPaths from "vite-tsconfig-paths"

import path from "path"

// We do not explicitly set the DEV_BUILD in any of our processes
// This is a convenience for developers for debugging purposes
const DEV_BUILD = process.env.DEV_BUILD || false

// https://vitejs.dev/config/
export default defineConfig({
  base: "./",
  plugins: [
    react({
      jsxImportSource: "@emotion/react",
      plugins: [["@swc/plugin-emotion", {}]],
    }),
    viteTsconfigPaths(),
  ],
  build: {
    outDir: "dist",
    sourcemap: DEV_BUILD,
    rollupOptions: {
      input: "src/index.ts",
    },
  },
  resolve: {
    alias: {
      "@streamlit/lib/src": path.resolve(__dirname, "../lib/src"),
      "@streamlit/lib": path.resolve(__dirname, "../lib/src"),
    },
  },
  test: {
    globals: true,
    environment: "jsdom",
    css: true,
    reporters: ["verbose"],
    setupFiles: ["../vitest.setup.ts"],
    deps: {
      optimizer: {
        web: {
          include: ["vitest-canvas-mock"],
        },
      },
    },
    coverage: {
      reporter: ["text", "json", "html"],
      include: ["src/**/*"],
      exclude: [],
    },
  },
})


================================================
File: /frontend/lib/src/AppNode.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Writer } from "protobufjs"
import { MockInstance } from "vitest"

import { arrayFromVector } from "@streamlit/lib/src/test_util"
import { isNullOrUndefined } from "@streamlit/lib/src/util/utils"

import { AppNode, AppRoot, BlockNode, ElementNode } from "./AppNode"
import { UNICODE } from "./mocks/arrow"
import {
  ArrowNamedDataSet,
  Block as BlockProto,
  Delta as DeltaProto,
  Element,
  ForwardMsgMetadata,
  IArrowVegaLiteChart,
  Logo as LogoProto,
} from "./proto"

const NO_SCRIPT_RUN_ID = "NO_SCRIPT_RUN_ID"
const FAKE_SCRIPT_HASH = "fake_script_hash"
// prettier-ignore
const BLOCK = block([
  text("1"),
  block([
    text("2"),
  ]),
])

// Initialize new AppRoot with a main block node and three child block nodes - sidebar, events and bottom.
const ROOT = new AppRoot(
  FAKE_SCRIPT_HASH,
  new BlockNode(FAKE_SCRIPT_HASH, [
    BLOCK,
    new BlockNode(FAKE_SCRIPT_HASH),
    new BlockNode(FAKE_SCRIPT_HASH),
    new BlockNode(FAKE_SCRIPT_HASH),
  ])
)

describe("AppNode.getIn", () => {
  it("handles shallow paths", () => {
    const node = BLOCK.getIn([0])
    expect(node).toBeTextNode("1")
  })

  it("handles deep paths", () => {
    const node = BLOCK.getIn([1, 0])
    expect(node).toBeTextNode("2")
  })

  it("returns undefined for invalid paths", () => {
    const node = BLOCK.getIn([2, 3, 4])
    expect(node).toBeUndefined()
  })
})

describe("AppNode.setIn", () => {
  it("handles shallow paths", () => {
    const newBlock = BLOCK.setIn([0], text("new"), NO_SCRIPT_RUN_ID)
    expect(newBlock.getIn([0])).toBeTextNode("new")

    // Check BLOCK..newBlock diff is as expected.
    expect(newBlock).not.toStrictEqual(BLOCK)
    expect(newBlock.getIn([1])).toStrictEqual(BLOCK.getIn([1]))
  })

  it("handles deep paths", () => {
    const newBlock = BLOCK.setIn([1, 1], text("new"), NO_SCRIPT_RUN_ID)
    expect(newBlock.getIn([1, 1])).toBeTextNode("new")

    // Check BLOCK..newBlock diff is as expected
    expect(newBlock).not.toStrictEqual(BLOCK)
    expect(newBlock.getIn([0])).toStrictEqual(BLOCK.getIn([0]))
    expect(newBlock.getIn([1])).not.toStrictEqual(BLOCK.getIn([1]))
    expect(newBlock.getIn([1, 0])).toStrictEqual(BLOCK.getIn([1, 0]))
    expect(newBlock.getIn([1, 1])).not.toStrictEqual(BLOCK.getIn([1, 1]))
  })

  it("throws an error for invalid paths", () => {
    expect(() => BLOCK.setIn([1, 2], text("new"), NO_SCRIPT_RUN_ID)).toThrow(
      "Bad 'setIn' index 2 (should be between [0, 1])"
    )
  })
})

describe("ElementNode.quiverElement", () => {
  it("returns a quiverElement (arrowTable)", () => {
    const node = arrowTable()
    const q = node.quiverElement

    expect(arrayFromVector(q.indexData)).toEqual([["i1", "i2"]])
    expect(q.columnNames).toEqual([["c1", "c2"]])
    expect(q.data.toArray().map(a => a?.toArray())).toEqual([
      ["foo", "1"],
      ["bar", "2"],
    ])
    expect(q.columnTypes).toEqual({
      index: [
        {
          pandas_type: "unicode",
          numpy_type: "object",
          meta: null,
        },
      ],
      data: [
        {
          pandas_type: "unicode",
          numpy_type: "object",
          meta: null,
        },
        {
          pandas_type: "unicode",
          numpy_type: "object",
          meta: null,
        },
      ],
    })
  })

  it("returns a quiverElement (arrowDataFrame)", () => {
    const node = arrowDataFrame()
    const q = node.quiverElement

    expect(arrayFromVector(q.indexData)).toEqual([["i1", "i2"]])
    expect(q.columnNames).toEqual([["c1", "c2"]])
    expect(q.data.toArray().map(a => a?.toArray())).toEqual([
      ["foo", "1"],
      ["bar", "2"],
    ])
    expect(q.columnTypes).toEqual({
      index: [
        {
          pandas_type: "unicode",
          numpy_type: "object",
          meta: null,
        },
      ],
      data: [
        {
          pandas_type: "unicode",
          numpy_type: "object",
          meta: null,
        },
        {
          pandas_type: "unicode",
          numpy_type: "object",
          meta: null,
        },
      ],
    })
  })

  it("does not recompute its value (arrowTable)", () => {
    // accessing `quiverElement` twice should return the same instance.
    const node = arrowTable()
    expect(node.quiverElement).toStrictEqual(node.quiverElement)
  })

  it("does not recompute its value (arrowDataFrame)", () => {
    // accessing `quiverElement` twice should return the same instance.
    const node = arrowDataFrame()
    expect(node.quiverElement).toStrictEqual(node.quiverElement)
  })

  it("throws an error for other element types", () => {
    const node = text("foo")
    expect(() => node.quiverElement).toThrow(
      "elementType 'text' is not a valid Quiver element!"
    )
  })
})

describe("ElementNode.vegaLiteChartElement", () => {
  it("returns a vegaLiteChartElement (data)", () => {
    const MOCK_VEGA_LITE_CHART = {
      spec: JSON.stringify({
        mark: "circle",
        encoding: {
          x: { field: "a", type: "quantitative" },
          y: { field: "b", type: "quantitative" },
          size: { field: "c", type: "quantitative" },
          color: { field: "c", type: "quantitative" },
        },
      }),
      data: { data: UNICODE },
      datasets: [],
      useContainerWidth: true,
    }
    const node = arrowVegaLiteChart(MOCK_VEGA_LITE_CHART)
    const element = node.vegaLiteChartElement

    // spec
    expect(element.spec).toEqual(MOCK_VEGA_LITE_CHART.spec)

    // data
    expect(arrayFromVector(element.data?.indexData)).toEqual([["i1", "i2"]])
    expect(element.data?.columnNames).toEqual([["c1", "c2"]])
    expect(element.data?.data.toArray().map(a => a?.toArray())).toEqual([
      ["foo", "1"],
      ["bar", "2"],
    ])
    expect(element.data?.columnTypes).toEqual({
      index: [
        {
          pandas_type: "unicode",
          numpy_type: "object",
          meta: null,
        },
      ],
      data: [
        {
          pandas_type: "unicode",
          numpy_type: "object",
          meta: null,
        },
        {
          pandas_type: "unicode",
          numpy_type: "object",
          meta: null,
        },
      ],
    })

    // datasets
    expect(element.datasets.length).toEqual(0)

    // use container width
    expect(element.useContainerWidth).toEqual(
      MOCK_VEGA_LITE_CHART.useContainerWidth
    )
  })

  it("returns a vegaLiteChartElement (datasets)", () => {
    const MOCK_VEGA_LITE_CHART = {
      spec: JSON.stringify({
        mark: "circle",
        encoding: {
          x: { field: "a", type: "quantitative" },
          y: { field: "b", type: "quantitative" },
          size: { field: "c", type: "quantitative" },
          color: { field: "c", type: "quantitative" },
        },
      }),
      data: null,
      datasets: [{ hasName: true, name: "foo", data: { data: UNICODE } }],
      useContainerWidth: true,
    }
    const node = arrowVegaLiteChart(MOCK_VEGA_LITE_CHART)
    const element = node.vegaLiteChartElement

    // spec
    expect(element.spec).toEqual(MOCK_VEGA_LITE_CHART.spec)

    // data
    expect(element.data).toEqual(null)

    // datasets
    expect(element.datasets[0].hasName).toEqual(
      MOCK_VEGA_LITE_CHART.datasets[0].hasName
    )
    expect(element.datasets[0].name).toEqual(
      MOCK_VEGA_LITE_CHART.datasets[0].name
    )
    expect(arrayFromVector(element.datasets[0].data.indexData)).toEqual([
      ["i1", "i2"],
    ])
    expect(element.datasets[0].data.columnNames).toEqual([["c1", "c2"]])
    expect(
      element.datasets[0].data.data.toArray().map(a => a?.toArray())
    ).toEqual([
      ["foo", "1"],
      ["bar", "2"],
    ])
    expect(element.datasets[0].data.columnTypes).toEqual({
      index: [
        {
          pandas_type: "unicode",
          numpy_type: "object",
          meta: null,
        },
      ],
      data: [
        {
          pandas_type: "unicode",
          numpy_type: "object",
          meta: null,
        },
        {
          pandas_type: "unicode",
          numpy_type: "object",
          meta: null,
        },
      ],
    })

    // use container width
    expect(element.useContainerWidth).toEqual(
      MOCK_VEGA_LITE_CHART.useContainerWidth
    )
  })

  it("does not recompute its value", () => {
    const MOCK_VEGA_LITE_CHART = {
      spec: JSON.stringify({
        mark: "circle",
        encoding: {
          x: { field: "a", type: "quantitative" },
          y: { field: "b", type: "quantitative" },
          size: { field: "c", type: "quantitative" },
          color: { field: "c", type: "quantitative" },
        },
      }),
      data: { data: UNICODE },
      datasets: [],
      useContainerWidth: true,
    }
    // accessing `vegaLiteChartElement` twice should return the same instance.
    const node = arrowVegaLiteChart(MOCK_VEGA_LITE_CHART)
    expect(node.vegaLiteChartElement).toStrictEqual(node.vegaLiteChartElement)
  })

  it("throws an error for other element types", () => {
    const node = text("foo")
    expect(() => node.vegaLiteChartElement).toThrow(
      "elementType 'text' is not a valid VegaLiteChartElement!"
    )
  })
})

describe("ElementNode.arrowAddRows", () => {
  const MOCK_UNNAMED_DATASET = {
    hasName: false,
    name: "",
    data: { data: UNICODE },
  } as ArrowNamedDataSet
  const MOCK_NAMED_DATASET = {
    hasName: true,
    name: "foo",
    data: { data: UNICODE },
  } as ArrowNamedDataSet
  const MOCK_ANOTHER_NAMED_DATASET = {
    hasName: true,
    name: "bar",
    data: { data: UNICODE },
  } as ArrowNamedDataSet

  describe("arrowTable", () => {
    test("addRows can be called with an unnamed dataset", () => {
      const node = arrowTable()
      const newNode = node.arrowAddRows(MOCK_UNNAMED_DATASET, NO_SCRIPT_RUN_ID)
      const q = newNode.quiverElement

      expect(arrayFromVector(q.indexData)).toEqual([["i1", "i2", "i1", "i2"]])
      expect(q.columnNames).toEqual([["c1", "c2"]])
      expect(q.data.toArray().map(a => a?.toArray())).toEqual([
        ["foo", "1"],
        ["bar", "2"],
        ["foo", "1"],
        ["bar", "2"],
      ])
      expect(q.columnTypes).toEqual({
        index: [
          {
            pandas_type: "unicode",
            numpy_type: "object",
            meta: null,
          },
        ],
        data: [
          {
            pandas_type: "unicode",
            numpy_type: "object",
            meta: null,
          },
          {
            pandas_type: "unicode",
            numpy_type: "object",
            meta: null,
          },
        ],
      })
    })

    test("addRows throws an error when called with a named dataset", () => {
      const node = arrowTable()
      expect(() =>
        node.arrowAddRows(MOCK_NAMED_DATASET, NO_SCRIPT_RUN_ID)
      ).toThrow(
        "Add rows cannot be used with a named dataset for this element."
      )
    })
  })

  describe("arrowDataFrame", () => {
    test("addRows can be called with an unnamed dataset", () => {
      const node = arrowDataFrame()
      const newNode = node.arrowAddRows(MOCK_UNNAMED_DATASET, NO_SCRIPT_RUN_ID)
      const q = newNode.quiverElement

      expect(arrayFromVector(q.indexData)).toEqual([["i1", "i2", "i1", "i2"]])
      expect(q.columnNames).toEqual([["c1", "c2"]])
      expect(q.data.toArray().map(a => a?.toArray())).toEqual([
        ["foo", "1"],
        ["bar", "2"],
        ["foo", "1"],
        ["bar", "2"],
      ])
      expect(q.columnTypes).toEqual({
        index: [
          {
            pandas_type: "unicode",
            numpy_type: "object",
            meta: null,
          },
        ],
        data: [
          {
            pandas_type: "unicode",
            numpy_type: "object",
            meta: null,
          },
          {
            pandas_type: "unicode",
            numpy_type: "object",
            meta: null,
          },
        ],
      })
    })

    test("addRows throws an error when called with a named dataset", () => {
      const node = arrowDataFrame()
      expect(() =>
        node.arrowAddRows(MOCK_NAMED_DATASET, NO_SCRIPT_RUN_ID)
      ).toThrow(
        "Add rows cannot be used with a named dataset for this element."
      )
    })
  })

  describe("arrowVegaLiteChart", () => {
    const getVegaLiteChart = (
      datasets?: ArrowNamedDataSet[],
      data?: Uint8Array
    ): IArrowVegaLiteChart => ({
      datasets: datasets || [],
      data: data ? { data } : null,
      spec: JSON.stringify({
        mark: "circle",
        encoding: {
          x: { field: "a", type: "quantitative" },
          y: { field: "b", type: "quantitative" },
          size: { field: "c", type: "quantitative" },
          color: { field: "c", type: "quantitative" },
        },
      }),
      useContainerWidth: true,
    })

    describe("addRows is called with a named dataset", () => {
      test("element has one dataset -> append new rows to that dataset", () => {
        const node = arrowVegaLiteChart(
          getVegaLiteChart([MOCK_ANOTHER_NAMED_DATASET])
        )
        const newNode = node.arrowAddRows(MOCK_NAMED_DATASET, NO_SCRIPT_RUN_ID)
        const element = newNode.vegaLiteChartElement

        expect(arrayFromVector(element.datasets[0].data.indexData)).toEqual([
          ["i1", "i2", "i1", "i2"],
        ])
        expect(element.datasets[0].data.columnNames).toEqual([["c1", "c2"]])
        expect(
          element.datasets[0].data.data.toArray().map(a => a?.toArray())
        ).toEqual([
          ["foo", "1"],
          ["bar", "2"],
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(element.datasets[0].data.columnTypes).toEqual({
          index: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      test("element has a dataset with the given name -> append new rows to that dataset", () => {
        const node = arrowVegaLiteChart(
          getVegaLiteChart([MOCK_NAMED_DATASET, MOCK_ANOTHER_NAMED_DATASET])
        )
        const newNode = node.arrowAddRows(MOCK_NAMED_DATASET, NO_SCRIPT_RUN_ID)
        const element = newNode.vegaLiteChartElement

        expect(arrayFromVector(element.datasets[0].data.indexData)).toEqual([
          ["i1", "i2", "i1", "i2"],
        ])
        expect(element.datasets[0].data.columnNames).toEqual([["c1", "c2"]])
        expect(
          element.datasets[0].data.data.toArray().map(a => a?.toArray())
        ).toEqual([
          ["foo", "1"],
          ["bar", "2"],
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(element.datasets[0].data.columnTypes).toEqual({
          index: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      test("element doesn't have a matched dataset, but has data -> append new rows to data", () => {
        const node = arrowVegaLiteChart(getVegaLiteChart(undefined, UNICODE))
        const newNode = node.arrowAddRows(MOCK_NAMED_DATASET, NO_SCRIPT_RUN_ID)
        const element = newNode.vegaLiteChartElement

        expect(arrayFromVector(element.data?.indexData)).toEqual([
          ["i1", "i2", "i1", "i2"],
        ])
        expect(element.data?.columnNames).toEqual([["c1", "c2"]])
        expect(element.data?.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", "1"],
          ["bar", "2"],
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(element.data?.columnTypes).toEqual({
          index: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      test("element doesn't have a matched dataset or data -> use new rows as data", () => {
        const node = arrowVegaLiteChart(
          getVegaLiteChart([
            MOCK_ANOTHER_NAMED_DATASET,
            MOCK_ANOTHER_NAMED_DATASET,
          ])
        )
        const newNode = node.arrowAddRows(MOCK_NAMED_DATASET, NO_SCRIPT_RUN_ID)
        const element = newNode.vegaLiteChartElement

        expect(arrayFromVector(element.data?.indexData)).toEqual([
          ["i1", "i2"],
        ])
        expect(element.data?.columnNames).toEqual([["c1", "c2"]])
        expect(element.data?.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(element.data?.columnTypes).toEqual({
          index: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      test("element doesn't have any datasets or data -> use new rows as data", () => {
        const node = arrowVegaLiteChart(getVegaLiteChart())
        const newNode = node.arrowAddRows(MOCK_NAMED_DATASET, NO_SCRIPT_RUN_ID)
        const element = newNode.vegaLiteChartElement

        expect(arrayFromVector(element.data?.indexData)).toEqual([
          ["i1", "i2"],
        ])
        expect(element.data?.columnNames).toEqual([["c1", "c2"]])
        expect(element.data?.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(element.data?.columnTypes).toEqual({
          index: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })
    })

    describe("addRows is called with an unnamed dataset", () => {
      test("element has one dataset -> append new rows to that dataset", () => {
        const node = arrowVegaLiteChart(getVegaLiteChart([MOCK_NAMED_DATASET]))
        const newNode = node.arrowAddRows(
          MOCK_UNNAMED_DATASET,
          NO_SCRIPT_RUN_ID
        )
        const element = newNode.vegaLiteChartElement

        expect(arrayFromVector(element.datasets[0].data.indexData)).toEqual([
          ["i1", "i2", "i1", "i2"],
        ])
        expect(element.datasets[0].data.columnNames).toEqual([["c1", "c2"]])
        expect(
          element.datasets[0].data.data.toArray().map(a => a?.toArray())
        ).toEqual([
          ["foo", "1"],
          ["bar", "2"],
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(element.datasets[0].data.columnTypes).toEqual({
          index: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      test("element has data -> append new rows to data", () => {
        const node = arrowVegaLiteChart(getVegaLiteChart(undefined, UNICODE))
        const newNode = node.arrowAddRows(
          MOCK_UNNAMED_DATASET,
          NO_SCRIPT_RUN_ID
        )
        const element = newNode.vegaLiteChartElement

        expect(arrayFromVector(element.data?.indexData)).toEqual([
          ["i1", "i2", "i1", "i2"],
        ])
        expect(element.data?.columnNames).toEqual([["c1", "c2"]])
        expect(element.data?.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", "1"],
          ["bar", "2"],
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(element.data?.columnTypes).toEqual({
          index: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })

      test("element doesn't have any datasets or data -> use new rows as data", () => {
        const node = arrowVegaLiteChart(getVegaLiteChart())
        const newNode = node.arrowAddRows(
          MOCK_UNNAMED_DATASET,
          NO_SCRIPT_RUN_ID
        )
        const element = newNode.vegaLiteChartElement

        expect(arrayFromVector(element.data?.indexData)).toEqual([
          ["i1", "i2"],
        ])
        expect(element.data?.columnNames).toEqual([["c1", "c2"]])
        expect(element.data?.data.toArray().map(a => a?.toArray())).toEqual([
          ["foo", "1"],
          ["bar", "2"],
        ])
        expect(element.data?.columnTypes).toEqual({
          index: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
          data: [
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
            {
              pandas_type: "unicode",
              numpy_type: "object",
              meta: null,
            },
          ],
        })
      })
    })
  })

  it("throws an error for other element types", () => {
    const node = text("foo")
    expect(() =>
      node.arrowAddRows(MOCK_UNNAMED_DATASET, NO_SCRIPT_RUN_ID)
    ).toThrow("elementType 'text' is not a valid arrowAddRows target!")
  })
})

describe("AppRoot.empty", () => {
  let windowSpy: MockInstance

  beforeEach(() => {
    windowSpy = vi.spyOn(window, "window", "get")
  })

  afterEach(() => {
    windowSpy.mockRestore()
  })

  it("creates empty tree except for a skeleton", async () => {
    windowSpy.mockImplementation(() => ({
      location: {
        search: "",
      },
    }))
    const empty = AppRoot.empty(FAKE_SCRIPT_HASH)

    // The linter is misfiring here. We're not accessing a DOM node.
    // eslint-disable-next-line testing-library/no-node-access
    expect(empty.main.children.length).toBe(1)
    const child = empty.main.getIn([0]) as ElementNode
    expect(child.element.skeleton).not.toBeNull()

    expect(empty.sidebar.isEmpty).toBe(true)
  })

  it("sets the main script hash and active script hash", () => {
    windowSpy.mockImplementation(() => ({
      location: {
        search: "",
      },
    }))
    const empty = AppRoot.empty(FAKE_SCRIPT_HASH)

    expect(empty.mainScriptHash).toBe(FAKE_SCRIPT_HASH)
    expect(empty.main.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
    expect(empty.sidebar.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
    expect(empty.event.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
    expect(empty.bottom.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
    expect(empty.root.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
  })

  it("creates empty tree with no loading screen if query param is set", async () => {
    windowSpy.mockImplementation(() => ({
      location: {
        search: "?embed_options=hide_loading_screen",
      },
    }))

    const empty = AppRoot.empty(FAKE_SCRIPT_HASH)

    expect(empty.main.isEmpty).toBe(true)
    expect(empty.sidebar.isEmpty).toBe(true)
  })

  it("creates empty tree with v1 loading screen if query param is set", async () => {
    windowSpy.mockImplementation(() => ({
      location: {
        search: "?embed_options=show_loading_screen_v1",
      },
    }))

    const empty = AppRoot.empty(FAKE_SCRIPT_HASH)

    // The linter is misfiring here. We're not accessing a DOM node.
    // eslint-disable-next-line testing-library/no-node-access
    expect(empty.main.children.length).toBe(1)
    const child = empty.main.getIn([0]) as ElementNode
    expect(child.element.alert).toBeDefined()

    expect(empty.sidebar.isEmpty).toBe(true)
  })

  it("creates empty tree with v2 loading screen if query param is set", async () => {
    windowSpy.mockImplementation(() => ({
      location: {
        search: "?embed_options=show_loading_screen_v2",
      },
    }))

    const empty = AppRoot.empty(FAKE_SCRIPT_HASH)

    // The linter is misfiring here. We're not accessing a DOM node.
    // eslint-disable-next-line testing-library/no-node-access
    expect(empty.main.children.length).toBe(1)
    const child = empty.main.getIn([0]) as ElementNode
    expect(child.element.skeleton).not.toBeNull()

    expect(empty.sidebar.isEmpty).toBe(true)
  })

  it("creates empty tree with no loading screen if query param is v1 and it's not first load", async () => {
    windowSpy.mockImplementation(() => ({
      location: {
        search: "?embed_options=show_loading_screen_v1",
      },
    }))

    const empty = AppRoot.empty(FAKE_SCRIPT_HASH, false)

    expect(empty.main.isEmpty).toBe(true)
    expect(empty.sidebar.isEmpty).toBe(true)
  })

  it("passes logo to new Root if empty is called with logo", async () => {
    windowSpy.mockImplementation(() => ({
      location: {
        search: "",
      },
    }))
    const logo = LogoProto.create({
      image:
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png",
    })

    // Replicate .empty call on initial render
    const empty = AppRoot.empty("", true)
    expect(empty.logo).toBeNull()

    // Replicate .empty call in AppNav's clearPageElements for MPA V1
    const empty2 = AppRoot.empty(FAKE_SCRIPT_HASH, false, undefined, logo)
    expect(empty2.logo).not.toBeNull()
  })
})

describe("AppRoot.filterMainScriptElements", () => {
  it("does not clear nodes associated with main script hash", () => {
    // Add a new element and clear stale nodes
    const delta = makeProto(DeltaProto, {
      newElement: { text: { body: "newElement!" } },
    })
    const newRoot = ROOT.applyDelta(
      "new_session_id",
      delta,
      forwardMsgMetadata([0, 1, 1])
    ).filterMainScriptElements(FAKE_SCRIPT_HASH)

    // We should now only have a single element, inside a single block
    expect(newRoot.main.getIn([1, 1])).toBeTextNode("newElement!")
    expect(newRoot.getElements().size).toBe(3)
  })

  it("clears nodes not associated with main script hash", () => {
    // Add a new element and clear stale nodes
    const delta = makeProto(DeltaProto, {
      newElement: { text: { body: "newElement!" } },
    })
    const newRoot = ROOT.applyDelta(
      "new_session_id",
      delta,
      forwardMsgMetadata([0, 1, 1], "DIFFERENT_HASH")
    ).filterMainScriptElements(FAKE_SCRIPT_HASH)

    // We should now only have a single element, inside a single block
    expect(newRoot.main.getIn([1, 1])).toBeUndefined()
    expect(newRoot.getElements().size).toBe(2)
  })
})

describe("AppRoot.applyDelta", () => {
  it("handles 'newElement' deltas", () => {
    const delta = makeProto(DeltaProto, {
      newElement: { text: { body: "newElement!" } },
    })
    const newRoot = ROOT.applyDelta(
      "new_session_id",
      delta,
      forwardMsgMetadata([0, 1, 1])
    )

    const newNode = newRoot.main.getIn([1, 1]) as ElementNode
    expect(newNode).toBeTextNode("newElement!")

    // Check that our new scriptRunId has been set only on the touched nodes
    expect(newRoot.main.scriptRunId).toBe("new_session_id")
    expect(newRoot.main.fragmentId).toBe(undefined)
    expect(newRoot.main.deltaMsgReceivedAt).toBe(undefined)
    expect(newRoot.main.getIn([0])?.scriptRunId).toBe(NO_SCRIPT_RUN_ID)
    expect(newRoot.main.getIn([1])?.scriptRunId).toBe("new_session_id")
    expect(newRoot.main.getIn([1, 0])?.scriptRunId).toBe(NO_SCRIPT_RUN_ID)
    expect(newRoot.main.getIn([1, 1])?.scriptRunId).toBe("new_session_id")
    expect(newNode.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
    expect(newRoot.sidebar.scriptRunId).toBe(NO_SCRIPT_RUN_ID)
  })

  it("handles 'addBlock' deltas", () => {
    const delta = makeProto(DeltaProto, { addBlock: {} })
    const newRoot = ROOT.applyDelta(
      "new_session_id",
      delta,
      forwardMsgMetadata([0, 1, 1])
    )

    const newNode = newRoot.main.getIn([1, 1]) as BlockNode
    expect(newNode).toBeDefined()

    // Check that our new scriptRunId has been set only on the touched nodes
    expect(newRoot.main.scriptRunId).toBe("new_session_id")
    expect(newRoot.main.fragmentId).toBe(undefined)
    expect(newRoot.main.deltaMsgReceivedAt).toBe(undefined)
    expect(newRoot.main.getIn([0])?.scriptRunId).toBe(NO_SCRIPT_RUN_ID)
    expect(newRoot.main.getIn([1])?.scriptRunId).toBe("new_session_id")
    expect(newRoot.main.getIn([1, 0])?.scriptRunId).toBe(NO_SCRIPT_RUN_ID)
    expect(newRoot.main.getIn([1, 1])?.scriptRunId).toBe("new_session_id")
    expect(newNode.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
    expect(newRoot.sidebar.scriptRunId).toBe(NO_SCRIPT_RUN_ID)
  })

  it("removes a block's children if the block type changes for the same delta path", () => {
    const newRoot = ROOT.applyDelta(
      "script_run_id",
      makeProto(DeltaProto, {
        addBlock: {
          expandable: {
            expanded: true,
            label: "label",
            icon: "",
          },
        },
      }),
      forwardMsgMetadata([0, 1, 1])
    ).applyDelta(
      "script_run_id",
      makeProto(DeltaProto, {
        newElement: { text: { body: "newElement!" } },
      }),
      forwardMsgMetadata([0, 1, 1, 0])
    )

    const newNode = newRoot.main.getIn([1, 1]) as BlockNode
    expect(newNode).toBeDefined()
    expect(newNode.deltaBlock.type).toBe("expandable")
    expect(newNode.children.length).toBe(1)

    const newRoot2 = newRoot.applyDelta(
      "new_script_run_id",
      makeProto(DeltaProto, {
        addBlock: {
          tabContainer: {},
        },
      }),
      forwardMsgMetadata([0, 1, 1])
    )

    const replacedBlock = newRoot2.main.getIn([1, 1]) as BlockNode
    expect(replacedBlock).toBeDefined()
    expect(replacedBlock.deltaBlock.type).toBe("tabContainer")
    expect(replacedBlock.children.length).toBe(0)
  })

  it("will not remove a block's children if the block type is the same for the same delta path", () => {
    const newRoot = ROOT.applyDelta(
      "script_run_id",
      makeProto(DeltaProto, {
        addBlock: {
          expandable: {
            expanded: true,
            label: "label",
            icon: "",
          },
        },
      }),
      forwardMsgMetadata([0, 1, 1])
    ).applyDelta(
      "script_run_id",
      makeProto(DeltaProto, {
        newElement: { text: { body: "newElement!" } },
      }),
      forwardMsgMetadata([0, 1, 1, 0])
    )

    const newNode = newRoot.main.getIn([1, 1]) as BlockNode
    expect(newNode).toBeDefined()
    expect(newNode.deltaBlock.type).toBe("expandable")
    expect(newNode.children.length).toBe(1)

    const newRoot2 = newRoot.applyDelta(
      "new_script_run_id",
      makeProto(DeltaProto, {
        addBlock: {
          expandable: {
            expanded: true,
            label: "other label",
            icon: "",
          },
        },
      }),
      forwardMsgMetadata([0, 1, 1])
    )

    const replacedBlock = newRoot2.main.getIn([1, 1]) as BlockNode
    expect(replacedBlock).toBeDefined()
    expect(replacedBlock.deltaBlock.type).toBe("expandable")
    expect(replacedBlock.children.length).toBe(1)
  })

  it("specifies active script hash on 'newElement' deltas", () => {
    const delta = makeProto(DeltaProto, {
      newElement: { text: { body: "newElement!" } },
    })
    const NEW_FAKE_SCRIPT_HASH = "new_fake_script_hash"
    const newRoot = ROOT.applyDelta(
      "new_session_id",
      delta,
      forwardMsgMetadata([0, 1, 1], NEW_FAKE_SCRIPT_HASH)
    )

    const newNode = newRoot.main.getIn([1, 1]) as ElementNode
    expect(newNode).toBeDefined()

    // Check that our new other nodes are not affected by the new script hash
    expect(newRoot.main.getIn([1, 0])?.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
    expect(newNode.activeScriptHash).toBe(NEW_FAKE_SCRIPT_HASH)
  })

  it("specifies active script hash on 'addBlock' deltas", () => {
    const delta = makeProto(DeltaProto, { addBlock: {} })
    const NEW_FAKE_SCRIPT_HASH = "new_fake_script_hash"
    const newRoot = ROOT.applyDelta(
      "new_session_id",
      delta,
      forwardMsgMetadata([0, 1, 1], NEW_FAKE_SCRIPT_HASH)
    )

    const newNode = newRoot.main.getIn([1, 1]) as BlockNode
    expect(newNode).toBeDefined()

    // Check that our new scriptRunId has been set only on the touched nodes
    expect(newRoot.main.getIn([1, 0])?.activeScriptHash).toBe(FAKE_SCRIPT_HASH)
    expect(newNode.activeScriptHash).toBe(NEW_FAKE_SCRIPT_HASH)
  })

  it("can set fragmentId in 'newElement' deltas", () => {
    const delta = makeProto(DeltaProto, {
      newElement: { text: { body: "newElement!" } },
      fragmentId: "myFragmentId",
    })
    const newRoot = ROOT.applyDelta(
      "new_session_id",
      delta,
      forwardMsgMetadata([0, 1, 1])
    )

    const newNode = newRoot.main.getIn([1, 1]) as ElementNode
    expect(newNode.fragmentId).toBe("myFragmentId")
  })

  it("can set fragmentId in 'addBlock' deltas", () => {
    const delta = makeProto(DeltaProto, {
      addBlock: {},
      fragmentId: "myFragmentId",
    })
    const newRoot = ROOT.applyDelta(
      "new_session_id",
      delta,
      forwardMsgMetadata([0, 1, 1])
    )

    const newNode = newRoot.main.getIn([1, 1]) as BlockNode
    expect(newNode.fragmentId).toBe("myFragmentId")
  })

  it("timestamp is set on BlockNode as message id", () => {
    const timestamp = new Date(Date.UTC(2017, 1, 14)).valueOf()
    Date.now = vi.fn(() => timestamp)
    const delta = makeProto(DeltaProto, {
      addBlock: {},
    })
    const newRoot = ROOT.applyDelta(
      "new_session_id",
      delta,
      forwardMsgMetadata([0, 1, 1])
    )

    const newNode = newRoot.main.getIn([1, 1]) as BlockNode
    expect(newNode.deltaMsgReceivedAt).toBe(timestamp)
  })
})

describe("AppRoot.clearStaleNodes", () => {
  it("clears stale nodes", () => {
    // Add a new element and clear stale nodes
    const delta = makeProto(DeltaProto, {
      newElement: { text: { body: "newElement!" } },
    })
    const newRoot = ROOT.applyDelta(
      "new_session_id",
      delta,
      forwardMsgMetadata([0, 1, 1])
    ).clearStaleNodes("new_session_id", [])

    // We should now only have a single element, inside a single block
    expect(newRoot.main.getIn([0, 0])).toBeTextNode("newElement!")
    expect(newRoot.getElements().size).toBe(1)
  })

  it("clears a stale logo", () => {
    const logo = LogoProto.create({
      image:
        "https://global.discourse-cdn.com/business7/uploads/streamlit/original/2X/8/8cb5b6c0e1fe4e4ebfd30b769204c0d30c332fec.png",
    })
    const newRoot = ROOT.appRootWithLogo(logo, {
      activeScriptHash: "hash",
      scriptRunId: "script_run_id",
    })
    expect(newRoot.logo).not.toBeNull()

    const newNewRoot = newRoot.clearStaleNodes("new_script_run_id", [])
    expect(newNewRoot.logo).toBeNull()
  })

  it("handles currentFragmentId correctly", () => {
    const tabContainerProto = makeProto(DeltaProto, {
      addBlock: { tabContainer: {}, allowEmpty: false },
      fragmentId: "my_fragment_id",
    })
    const tab1 = makeProto(DeltaProto, {
      addBlock: { tab: { label: "tab1" }, allowEmpty: true },
      fragmentId: "my_fragment_id",
    })
    const tab2 = makeProto(DeltaProto, {
      addBlock: { tab: { label: "tab2" }, allowEmpty: true },
      fragmentId: "my_fragment_id",
    })

    // const BLOCK = block([text("1"), block([text("2")])])
    const root = AppRoot.empty(FAKE_SCRIPT_HASH)
      // Block not corresponding to my_fragment_id. Should be preserved.
      .applyDelta(
        "old_session_id",
        makeProto(DeltaProto, { addBlock: { allowEmpty: true } }),
        forwardMsgMetadata([0, 0])
      )
      // Element in block unrelated to my_fragment_id. Should be preserved.
      .applyDelta(
        "old_session_id",
        makeProto(DeltaProto, {
          newElement: { text: { body: "oldElement!" } },
        }),
        forwardMsgMetadata([0, 0, 0])
      )
      // Another element in block unrelated to my_fragment_id. Should be preserved.
      .applyDelta(
        "old_session_id",
        makeProto(DeltaProto, {
          newElement: { text: { body: "oldElement2!" } },
          fragmentId: "other_fragment_id",
        }),
        forwardMsgMetadata([0, 0, 1])
      )
      // Old element related to my_fragment_id but in an unrelated block. Should be preserved.
      .applyDelta(
        "old_session_id",
        makeProto(DeltaProto, {
          newElement: { text: { body: "oldElement4!" } },
          fragmentId: "my_fragment_id",
        }),
        forwardMsgMetadata([0, 0, 2])
      )
      // Block corresponding to my_fragment_id
      .applyDelta(
        "new_session_id",
        makeProto(DeltaProto, {
          addBlock: { allowEmpty: false },
          fragmentId: "my_fragment_id",
        }),
        forwardMsgMetadata([0, 1])
      )
      // Old element related to my_fragment_id. Should be pruned.
      .applyDelta(
        "old_session_id",
        makeProto(DeltaProto, {
          newElement: { text: { body: "oldElement3!" } },
          fragmentId: "my_fragment_id",
        }),
        forwardMsgMetadata([0, 1, 0])
      )
      // New element related to my_fragment_id. Should be preserved.
      .applyDelta(
        "new_session_id",
        makeProto(DeltaProto, {
          newElement: { text: { body: "newElement!" } },
          fragmentId: "my_fragment_id",
        }),
        forwardMsgMetadata([0, 1, 1])
      )
      // New element container related to my_fragment_id, having children which will be handled individually
      // Create a tab container with two tabs in the old session; then send new delta with the container and
      // only one tab. The second tab with the old_session_id should be pruned.
      .applyDelta(
        "old_session_id",
        tabContainerProto,
        forwardMsgMetadata([0, 2])
      )
      .applyDelta("old_session_id", tab1, forwardMsgMetadata([0, 2, 0]))
      .applyDelta("old_session_id", tab2, forwardMsgMetadata([0, 2, 1]))
      .applyDelta(
        "new_session_id",
        tabContainerProto,
        forwardMsgMetadata([0, 2])
      )
      .applyDelta("new_session_id", tab1, forwardMsgMetadata([0, 2, 0]))

    const pruned = root.clearStaleNodes("new_session_id", ["my_fragment_id"])

    expect(pruned.main.getIn([0])).toBeInstanceOf(BlockNode)
    expect((pruned.main.getIn([0]) as BlockNode).children).toHaveLength(3)
    expect(pruned.main.getIn([0, 0])).toBeTextNode("oldElement!")
    expect(pruned.main.getIn([0, 1])).toBeTextNode("oldElement2!")
    expect(pruned.main.getIn([0, 2])).toBeTextNode("oldElement4!")

    expect(pruned.main.getIn([1])).toBeInstanceOf(BlockNode)
    expect((pruned.main.getIn([1]) as BlockNode).children).toHaveLength(1)
    expect(pruned.main.getIn([1, 0])).toBeTextNode("newElement!")

    expect(pruned.main.getIn([2])).toBeInstanceOf(BlockNode)
    expect((pruned.main.getIn([2]) as BlockNode).children).toHaveLength(1)
    expect(
      (pruned.main.getIn([2, 0]) as BlockNode).deltaBlock.tab?.label
    ).toContain("tab1")
  })

  it("clear childNodes of a block node in fragment run", () => {
    // Add a new element and clear stale nodes
    const delta = makeProto(DeltaProto, {
      newElement: { text: { body: "newElement!" } },
      fragmentId: "my_fragment_id",
    })
    const newRoot = AppRoot.empty(FAKE_SCRIPT_HASH)
      // Block corresponding to my_fragment_id
      .applyDelta(
        "new_session_id",
        makeProto(DeltaProto, {
          addBlock: { vertical: {}, allowEmpty: false },
          fragmentId: "my_fragment_id",
        }),
        forwardMsgMetadata([0, 0])
      )
      .applyDelta("new_session_id", delta, forwardMsgMetadata([0, 0, 0]))
      // Block with child where scriptRunId is different
      .applyDelta(
        "new_session_id",
        makeProto(DeltaProto, {
          addBlock: { vertical: {}, allowEmpty: false },
          fragmentId: "my_fragment_id",
        }),
        forwardMsgMetadata([0, 1])
      )
      .applyDelta("new_session_id", delta, forwardMsgMetadata([0, 1, 0]))
      .applyDelta("new_session_id", delta, forwardMsgMetadata([0, 1, 1]))
      // this child is a nested fragment_id from an old run and should be pruned
      .applyDelta(
        "old_session_id",
        makeProto(DeltaProto, {
          newElement: { text: { body: "oldElement!" } },
          fragmentId: "my_nested_fragment_id",
        }),
        forwardMsgMetadata([0, 1, 2])
      )
      // this child is a nested fragment_id from the same run and should be preserved
      .applyDelta(
        "new_session_id",
        makeProto(DeltaProto, {
          newElement: { text: { body: "newElement!" } },
          fragmentId: "my_nested_fragment_id",
        }),
        forwardMsgMetadata([0, 1, 3])
      )

    expect((newRoot.main.getIn([1]) as BlockNode).children).toHaveLength(4)

    const pruned = newRoot.clearStaleNodes("new_session_id", [
      "my_fragment_id",
    ])

    expect(pruned.main.getIn([0])).toBeInstanceOf(BlockNode)
    expect((pruned.main.getIn([0]) as BlockNode).children).toHaveLength(1)
    expect(pruned.main.getIn([1])).toBeInstanceOf(BlockNode)
    // the stale nested fragment child should have been pruned
    expect((pruned.main.getIn([1]) as BlockNode).children).toHaveLength(3)
  })
})

describe("AppRoot.getElements", () => {
  it("returns all elements", () => {
    // We have elements at main.[0] and main.[1, 0]
    expect(ROOT.getElements()).toEqual(
      new Set([
        (ROOT.main.getIn([0]) as ElementNode).element,
        (ROOT.main.getIn([1, 0]) as ElementNode).element,
      ])
    )
  })
})

/** Create a `Text` element node with the given properties. */
function text(text: string, scriptRunId = NO_SCRIPT_RUN_ID): ElementNode {
  const element = makeProto(Element, { text: { body: text } })
  return new ElementNode(
    element,
    ForwardMsgMetadata.create(),
    scriptRunId,
    FAKE_SCRIPT_HASH
  )
}

/** Create a BlockNode with the given properties. */
function block(
  children: AppNode[] = [],
  scriptRunId = NO_SCRIPT_RUN_ID
): BlockNode {
  return new BlockNode(
    FAKE_SCRIPT_HASH,
    children,
    makeProto(BlockProto, {}),
    scriptRunId
  )
}

/** Create an arrowTable element node with the given properties. */
function arrowTable(scriptRunId = NO_SCRIPT_RUN_ID): ElementNode {
  const element = makeProto(Element, { arrowTable: { data: UNICODE } })
  return new ElementNode(
    element,
    ForwardMsgMetadata.create(),
    scriptRunId,
    FAKE_SCRIPT_HASH
  )
}

/** Create an arrowDataFrame element node with the given properties. */
function arrowDataFrame(scriptRunId = NO_SCRIPT_RUN_ID): ElementNode {
  const element = makeProto(Element, { arrowDataFrame: { data: UNICODE } })
  return new ElementNode(
    element,
    ForwardMsgMetadata.create(),
    scriptRunId,
    FAKE_SCRIPT_HASH
  )
}

/** Create an arrowVegaLiteChart element node with the given properties. */
function arrowVegaLiteChart(
  data: IArrowVegaLiteChart,
  scriptRunId = NO_SCRIPT_RUN_ID
): ElementNode {
  const element = makeProto(Element, { arrowVegaLiteChart: data })
  return new ElementNode(
    element,
    ForwardMsgMetadata.create(),
    scriptRunId,
    FAKE_SCRIPT_HASH
  )
}

/** Create a ForwardMsgMetadata with the given container and path */
function forwardMsgMetadata(
  deltaPath: number[],
  activeScriptHash = FAKE_SCRIPT_HASH
): ForwardMsgMetadata {
  expect(deltaPath.length).toBeGreaterThanOrEqual(2)
  return makeProto(ForwardMsgMetadata, { deltaPath, activeScriptHash })
}

/**
 * Make a "fully concrete" instance of a protobuf message.
 * This function constructs a message and then encodes and decodes it as
 * if it had arrived on the wire. This ensures that that it has all its
 * 'oneOfs' and 'defaults' set.
 */
function makeProto<Type, Props>(
  MessageType: {
    new (props: Props): Type
    encode: (message: Type, writer: Writer) => Writer
    decode: (bytes: Uint8Array) => Type
  },
  properties: Props
): Type {
  const message = new MessageType(properties)
  const bytes = MessageType.encode(message, Writer.create()).finish()
  return MessageType.decode(bytes)
}

// Custom Jest matchers for dealing with AppNodes
declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace vi {
    interface Matchers<R> {
      toBeTextNode(text: string): R
    }
  }
}

interface CustomMatchers<R = unknown> {
  toBeTextNode(text: string): R
}

declare module "vitest" {
  interface Assertion<T = any> extends CustomMatchers<T> {}
  interface AsymmetricMatchersContaining extends CustomMatchers {}
}

expect.extend({
  toBeTextNode(received, text): any {
    const elementNode = received as ElementNode
    if (isNullOrUndefined(elementNode)) {
      return {
        message: () => `expected ${received} to be an instance of ElementNode`,
        pass: false,
      }
    }

    const { type } = elementNode.element
    if (type !== "text") {
      return {
        message: () =>
          `expected ${received}.element.type to be 'text', but it was ${type}`,
        pass: false,
      }
    }

    const textBody = elementNode.element.text?.body
    return {
      message: () =>
        `expected ${received}.element.text.body to be "${text}", but it was "${textBody}"`,
      pass: textBody === text,
    }
  },
})


================================================
File: /frontend/lib/src/AppNode.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { produce } from "immer"

import {
  getLoadingScreenType,
  isNullOrUndefined,
  LoadingScreenType,
  makeAppSkeletonElement,
  makeElementWithErrorText,
  makeElementWithInfoText,
  notUndefined,
} from "@streamlit/lib/src/util/utils"

import {
  ArrowNamedDataSet,
  Arrow as ArrowProto,
  ArrowVegaLiteChart as ArrowVegaLiteChartProto,
  Block as BlockProto,
  Delta,
  Element,
  ForwardMsgMetadata,
  IArrow,
  IArrowNamedDataSet,
  Logo,
} from "./proto"
import {
  VegaLiteChartElement,
  WrappedNamedDataset,
} from "./components/elements/ArrowVegaLiteChart"
import { Quiver } from "./dataframes/Quiver"
import { ensureError } from "./util/ErrorHandling"

const NO_SCRIPT_RUN_ID = "NO_SCRIPT_RUN_ID"

interface LogoMetadata {
  // Associated scriptHash that created the logo
  activeScriptHash: string

  // Associated scriptRunId that created the logo
  scriptRunId: string
}
interface AppLogo extends LogoMetadata {
  logo: Logo
}

/**
 * An immutable node of the "App Data Tree".
 *
 * Trees are composed of `ElementNode` leaves, which contain data about
 * a single visual element, and `BlockNode` branches, which determine the
 * layout of a group of children nodes.
 *
 * A simple tree might look like this:
 *
 *   AppRoot
 *    BlockNode ("main")
 *       ElementNode (text: "Ahoy, Streamlit!")
 *       ElementNode (button: "Don't Push This")
 *    BlockNode ("sidebar")
 *        ElementNode (checkbox: "Batten The Hatches")
 *
 * To build this tree, the frontend receives `Delta` messages from Python,
 * each of which corresponds to a tree mutation ("add an element",
 * "add a block", "add rows to an existing element"). The frontend builds the
 * tree bit by bit in response to these `Delta`s.
 *
 * To render the app, the `AppView` class walks this tree and outputs
 * a corresponding DOM structure, using React, that's essentially a mapping
 * of `AppElement` -> `ReactNode`. This rendering happens "live" - that is,
 * the app is re-rendered each time a new `Delta` is received.
 *
 * Because the app gets re-rendered frequently, updates need to be fast.
 * Our React components - the building blocks of the app - are "pure"
 * (see https://reactjs.org/docs/react-api.html#reactpurecomponent), which
 * means that React uses shallow comparison to determine which ReactNodes to
 * update.
 *
 * Thus, each node in our tree is _immutable_ - any change to a `AppNode`
 * actually results in a *new* `AppNode` instance. This occurs recursively,
 * so inserting a new `ElementNode` into the tree will also result in new
 * `BlockNode`s for each of that Element's ancestors, all the way up to the
 * root node. Then, when React re-renders the app, it will re-traverse the new
 * nodes that have been created, and rebuild just the bits of the app that
 * have changed.
 */
export interface AppNode {
  /**
   * The ID of the script run this node was generated in. When a script finishes
   * running, the app prunes all stale nodes.
   */
  readonly scriptRunId: string

  /**
   * The ID of the fragment that sent the Delta creating this AppNode. If this
   * AppNode was not created by a fragment, this field is falsy.
   */
  readonly fragmentId?: string

  /**
   * The hash of the script that created this node.
   */
  readonly activeScriptHash?: string

  // A timestamp indicating based on which delta message the node was created.
  // If the node was created without a delta message, this field is undefined.
  // This helps us to update React components based on a new backend message even though other
  // props have not changed; this can happen for UI-only interactions such as dimissing a dialog.
  readonly deltaMsgReceivedAt?: number

  /**
   * Return the AppNode for the given index path, or undefined if the path
   * is invalid.
   */
  getIn(path: number[]): AppNode | undefined

  /**
   * Return a copy of this node with a new element set at the given index
   * path. Throws an error if the path is invalid.
   */
  setIn(path: number[], node: AppNode, scriptRunId: string): AppNode

  /**
   * Recursively remove children nodes whose activeScriptHash is no longer
   * associated with the mainScriptHash.
   */
  filterMainScriptElements(mainScriptHash: string): AppNode | undefined

  /**
   * Recursively remove children nodes whose scriptRunId is no longer current.
   * If this node should no longer exist, return undefined.
   */
  clearStaleNodes(
    currentScriptRunId: string,
    fragmentIdsThisRun?: Array<string>,
    fragmentIdOfBlock?: string
  ): AppNode | undefined

  /**
   * Return a Set of all the Elements contained in the tree.
   * If an existing Set is passed in, that Set will be mutated and returned.
   * Otherwise, a new Set will be created and will be returned.
   */
  getElements(elementSet?: Set<Element>): Set<Element>
}

/**
 * A leaf AppNode. Contains a single element to render.
 */
export class ElementNode implements AppNode {
  public readonly element: Element

  public readonly metadata: ForwardMsgMetadata

  public readonly scriptRunId: string

  public readonly fragmentId?: string

  private lazyQuiverElement?: Quiver

  private lazyVegaLiteChartElement?: VegaLiteChartElement

  // The hash of the script that created this element.
  public readonly activeScriptHash: string

  /** Create a new ElementNode. */
  public constructor(
    element: Element,
    metadata: ForwardMsgMetadata,
    scriptRunId: string,
    activeScriptHash: string,
    fragmentId?: string
  ) {
    this.element = element
    this.metadata = metadata
    this.scriptRunId = scriptRunId
    this.activeScriptHash = activeScriptHash
    this.fragmentId = fragmentId
  }

  public get quiverElement(): Quiver {
    if (this.lazyQuiverElement !== undefined) {
      return this.lazyQuiverElement
    }

    if (
      this.element.type !== "arrowTable" &&
      this.element.type !== "arrowDataFrame"
    ) {
      throw new Error(
        `elementType '${this.element.type}' is not a valid Quiver element!`
      )
    }

    const toReturn = new Quiver(this.element[this.element.type] as ArrowProto)
    // TODO (lukasmasuch): Delete element from proto object?
    this.lazyQuiverElement = toReturn
    return toReturn
  }

  public get vegaLiteChartElement(): VegaLiteChartElement {
    if (this.lazyVegaLiteChartElement !== undefined) {
      return this.lazyVegaLiteChartElement
    }

    if (this.element.type !== "arrowVegaLiteChart") {
      throw new Error(
        `elementType '${this.element.type}' is not a valid VegaLiteChartElement!`
      )
    }

    const proto = this.element.arrowVegaLiteChart as ArrowVegaLiteChartProto
    const modifiedData = proto.data ? new Quiver(proto.data) : null
    const modifiedDatasets =
      proto.datasets.length > 0 ? wrapDatasets(proto.datasets) : []

    const toReturn = {
      data: modifiedData,
      spec: proto.spec,
      datasets: modifiedDatasets,
      useContainerWidth: proto.useContainerWidth,
      vegaLiteTheme: proto.theme,
      id: proto.id,
      selectionMode: proto.selectionMode,
      formId: proto.formId,
    }

    this.lazyVegaLiteChartElement = toReturn
    return toReturn
  }

  // eslint-disable-next-line class-methods-use-this
  public getIn(): AppNode | undefined {
    return undefined
  }

  // eslint-disable-next-line class-methods-use-this
  public setIn(): AppNode {
    throw new Error("'setIn' cannot be called on an ElementNode")
  }

  public filterMainScriptElements(
    mainScriptHash: string
  ): AppNode | undefined {
    if (this.activeScriptHash !== mainScriptHash) {
      return undefined
    }

    return this
  }

  public clearStaleNodes(
    currentScriptRunId: string,
    fragmentIdsThisRun?: Array<string>,
    fragmentIdOfBlock?: string
  ): ElementNode | undefined {
    if (fragmentIdsThisRun && fragmentIdsThisRun.length) {
      // If we're currently running a fragment, nodes unrelated to the fragment
      // shouldn't be cleared. This can happen when,
      //   1. This element doesn't correspond to a fragment at all.
      //   2. This element is a fragment but is in no path that was modified.
      //   3. This element belongs to a path that was modified, but it was modified in the same run.
      if (
        !this.fragmentId ||
        !fragmentIdOfBlock ||
        this.scriptRunId === currentScriptRunId
      ) {
        return this
      }
    }
    return this.scriptRunId === currentScriptRunId ? this : undefined
  }

  public getElements(elements?: Set<Element>): Set<Element> {
    if (isNullOrUndefined(elements)) {
      elements = new Set<Element>()
    }
    elements.add(this.element)
    return elements
  }

  public arrowAddRows(
    namedDataSet: ArrowNamedDataSet,
    scriptRunId: string
  ): ElementNode {
    const elementType = this.element.type
    const newNode = new ElementNode(
      this.element,
      this.metadata,
      scriptRunId,
      this.activeScriptHash,
      this.fragmentId
    )

    switch (elementType) {
      case "arrowTable":
      case "arrowDataFrame": {
        newNode.lazyQuiverElement = ElementNode.quiverAddRowsHelper(
          this.quiverElement,
          namedDataSet
        )
        break
      }
      case "arrowVegaLiteChart": {
        newNode.lazyVegaLiteChartElement =
          ElementNode.vegaLiteChartAddRowsHelper(
            this.vegaLiteChartElement,
            namedDataSet
          )
        break
      }
      default: {
        // This should never happen!
        throw new Error(
          `elementType '${this.element.type}' is not a valid arrowAddRows target!`
        )
      }
    }

    return newNode
  }

  private static quiverAddRowsHelper(
    element: Quiver,
    namedDataSet: ArrowNamedDataSet
  ): Quiver {
    if (namedDataSet.hasName) {
      throw new Error(
        "Add rows cannot be used with a named dataset for this element."
      )
    }

    const newQuiver = new Quiver(namedDataSet.data as IArrow)
    return element.addRows(newQuiver)
  }

  private static vegaLiteChartAddRowsHelper(
    element: VegaLiteChartElement,
    namedDataSet: ArrowNamedDataSet
  ): VegaLiteChartElement {
    const newDataSetName = namedDataSet.hasName ? namedDataSet.name : null
    const newDataSetQuiver = new Quiver(namedDataSet.data as IArrow)

    return produce(element, (draft: VegaLiteChartElement) => {
      const existingDataSet = getNamedDataSet(draft.datasets, newDataSetName)
      if (existingDataSet) {
        existingDataSet.data = existingDataSet.data.addRows(newDataSetQuiver)
      } else {
        draft.data = draft.data
          ? draft.data.addRows(newDataSetQuiver)
          : newDataSetQuiver
      }
    })
  }
}

/**
 * If there is only one NamedDataSet, return it.
 * If there is a NamedDataset that matches the given name, return it.
 * Otherwise, return `undefined`.
 */
function getNamedDataSet(
  namedDataSets: WrappedNamedDataset[],
  name: string | null
): WrappedNamedDataset | undefined {
  if (namedDataSets.length === 1) {
    return namedDataSets[0]
  }

  return namedDataSets.find(
    (dataset: WrappedNamedDataset) => dataset.hasName && dataset.name === name
  )
}

/**
 * A container AppNode that holds children.
 */
export class BlockNode implements AppNode {
  public readonly children: AppNode[]

  public readonly deltaBlock: BlockProto

  public readonly scriptRunId: string

  public readonly fragmentId?: string

  public readonly deltaMsgReceivedAt?: number

  // The hash of the script that created this block.
  public readonly activeScriptHash: string

  public constructor(
    activeScriptHash: string,
    children?: AppNode[],
    deltaBlock?: BlockProto,
    scriptRunId?: string,
    fragmentId?: string,
    deltaMsgReceivedAt?: number
  ) {
    this.activeScriptHash = activeScriptHash
    this.children = children ?? []
    this.deltaBlock = deltaBlock ?? new BlockProto({})
    this.scriptRunId = scriptRunId ?? NO_SCRIPT_RUN_ID
    this.fragmentId = fragmentId
    this.deltaMsgReceivedAt = deltaMsgReceivedAt
  }

  /** True if this Block has no children. */
  public get isEmpty(): boolean {
    return this.children.length === 0
  }

  public getIn(path: number[]): AppNode | undefined {
    if (path.length === 0) {
      return undefined
    }

    const childIndex = path[0]
    if (childIndex < 0 || childIndex >= this.children.length) {
      return undefined
    }

    if (path.length === 1) {
      return this.children[childIndex]
    }

    return this.children[childIndex].getIn(path.slice(1))
  }

  public setIn(path: number[], node: AppNode, scriptRunId: string): BlockNode {
    if (path.length === 0) {
      throw new Error(`empty path!`)
    }

    const childIndex = path[0]
    if (childIndex < 0 || childIndex > this.children.length) {
      throw new Error(
        `Bad 'setIn' index ${childIndex} (should be between [0, ${this.children.length}])`
      )
    }

    const newChildren = this.children.slice()
    if (path.length === 1) {
      // Base case
      newChildren[childIndex] = node
    } else {
      // Pop the current element off our path, and recurse into our children
      newChildren[childIndex] = newChildren[childIndex].setIn(
        path.slice(1),
        node,
        scriptRunId
      )
    }

    return new BlockNode(
      this.activeScriptHash,
      newChildren,
      this.deltaBlock,
      scriptRunId,
      this.fragmentId,
      this.deltaMsgReceivedAt
    )
  }

  filterMainScriptElements(mainScriptHash: string): AppNode | undefined {
    if (this.activeScriptHash !== mainScriptHash) {
      return undefined
    }

    // Recursively clear our children.
    const newChildren = this.children
      .map(child => child.filterMainScriptElements(mainScriptHash))
      .filter(notUndefined)

    return new BlockNode(
      this.activeScriptHash,
      newChildren,
      this.deltaBlock,
      this.scriptRunId,
      this.fragmentId,
      this.deltaMsgReceivedAt
    )
  }

  public clearStaleNodes(
    currentScriptRunId: string,
    fragmentIdsThisRun?: Array<string>,
    fragmentIdOfBlock?: string
  ): BlockNode | undefined {
    if (!fragmentIdsThisRun || !fragmentIdsThisRun.length) {
      // If we're not currently running a fragment, then we can remove any blocks
      // that don't correspond to currentScriptRunId.
      if (this.scriptRunId !== currentScriptRunId) {
        return undefined
      }
    } else {
      // Otherwise, we are currently running a fragment, and our behavior
      // depends on the fragmentId of this BlockNode.

      // The parent block was modified but this element wasn't, so it's stale.
      if (fragmentIdOfBlock && this.scriptRunId !== currentScriptRunId) {
        return undefined
      }

      // This block is modified by the current run, so we indicate this to our children in case
      // they were not modified by the current run, which means they are stale.
      if (
        this.fragmentId &&
        fragmentIdsThisRun.includes(this.fragmentId) &&
        this.scriptRunId === currentScriptRunId
      ) {
        fragmentIdOfBlock = this.fragmentId
      }
    }

    // Recursively clear our children.
    const newChildren = this.children
      .map(child => {
        return child.clearStaleNodes(
          currentScriptRunId,
          fragmentIdsThisRun,
          fragmentIdOfBlock
        )
      })
      .filter(notUndefined)

    return new BlockNode(
      this.activeScriptHash,
      newChildren,
      this.deltaBlock,
      currentScriptRunId,
      this.fragmentId,
      this.deltaMsgReceivedAt
    )
  }

  public getElements(elementSet?: Set<Element>): Set<Element> {
    if (isNullOrUndefined(elementSet)) {
      elementSet = new Set<Element>()
    }

    for (const child of this.children) {
      child.getElements(elementSet)
    }

    return elementSet
  }
}

/**
 * The root of our data tree. It contains the app's top-level BlockNodes.
 */
export class AppRoot {
  readonly root: BlockNode

  /* The hash of the main script that creates this AppRoot. */
  readonly mainScriptHash: string

  readonly appLogo: AppLogo | null

  /**
   * Create an empty AppRoot with a placeholder "skeleton" element.
   */
  public static empty(
    mainScriptHash = "",
    isInitialRender = true,
    sidebarElements?: BlockNode | undefined,
    logo?: Logo | null
  ): AppRoot {
    const mainNodes: AppNode[] = []

    let waitElement: Element | undefined

    switch (getLoadingScreenType()) {
      case LoadingScreenType.NONE:
        break

      case LoadingScreenType.V1:
        // Only show the v1 loading state when it's the initial render.
        // This is how v1 used to work, and we don't want any backward
        // incompatibility.
        if (isInitialRender) {
          waitElement = makeElementWithInfoText("Please wait...")
        }
        break

      default:
        waitElement = makeAppSkeletonElement()
    }

    if (waitElement) {
      mainNodes.push(
        new ElementNode(
          waitElement,
          ForwardMsgMetadata.create({}),
          NO_SCRIPT_RUN_ID,
          mainScriptHash
        )
      )
    }

    const main = new BlockNode(
      mainScriptHash,
      mainNodes,
      new BlockProto({ allowEmpty: true }),
      NO_SCRIPT_RUN_ID
    )

    const sidebar =
      sidebarElements ||
      new BlockNode(
        mainScriptHash,
        [],
        new BlockProto({ allowEmpty: true }),
        NO_SCRIPT_RUN_ID
      )

    const event = new BlockNode(
      mainScriptHash,
      [],
      new BlockProto({ allowEmpty: true }),
      NO_SCRIPT_RUN_ID
    )

    const bottom = new BlockNode(
      mainScriptHash,
      [],
      new BlockProto({ allowEmpty: true }),
      NO_SCRIPT_RUN_ID
    )

    // Persist logo between pages to avoid flicker (MPA V1 - Issue #8815)
    const appLogo = logo
      ? {
          logo,
          activeScriptHash: mainScriptHash,
          scriptRunId: NO_SCRIPT_RUN_ID,
        }
      : null

    return new AppRoot(
      mainScriptHash,
      new BlockNode(mainScriptHash, [main, sidebar, event, bottom]),
      appLogo
    )
  }

  public constructor(
    mainScriptHash: string,
    root: BlockNode,
    appLogo: AppLogo | null = null
  ) {
    this.mainScriptHash = mainScriptHash
    this.root = root
    this.appLogo = appLogo

    // Verify that our root node has exactly 4 children: a 'main' block,
    // a 'sidebar' block, a `bottom` block and an 'event' block.
    if (
      this.root.children.length !== 4 ||
      isNullOrUndefined(this.main) ||
      isNullOrUndefined(this.sidebar) ||
      isNullOrUndefined(this.event) ||
      isNullOrUndefined(this.bottom)
    ) {
      throw new Error(`Invalid root node children! ${root}`)
    }
  }

  public get main(): BlockNode {
    const [main] = this.root.children
    return main as BlockNode
  }

  public get sidebar(): BlockNode {
    const [, sidebar] = this.root.children
    return sidebar as BlockNode
  }

  public get event(): BlockNode {
    const [, , event] = this.root.children
    return event as BlockNode
  }

  public get bottom(): BlockNode {
    const [, , , bottom] = this.root.children
    return bottom as BlockNode
  }

  public get logo(): Logo | null {
    return this.appLogo?.logo ?? null
  }

  public appRootWithLogo(logo: Logo, metadata: LogoMetadata): AppRoot {
    return new AppRoot(this.mainScriptHash, this.root, {
      logo,
      ...metadata,
    })
  }

  public applyDelta(
    scriptRunId: string,
    delta: Delta,
    metadata: ForwardMsgMetadata
  ): AppRoot {
    // The full path to the AppNode within the element tree.
    // Used to find and update the element node specified by this Delta.
    const { deltaPath, activeScriptHash } = metadata
    switch (delta.type) {
      case "newElement": {
        const element = delta.newElement as Element
        return this.addElement(
          deltaPath,
          scriptRunId,
          element,
          metadata,
          activeScriptHash,
          delta.fragmentId
        )
      }

      case "addBlock": {
        const deltaMsgReceivedAt = Date.now()
        return this.addBlock(
          deltaPath,
          delta.addBlock as BlockProto,
          scriptRunId,
          activeScriptHash,
          delta.fragmentId,
          deltaMsgReceivedAt
        )
      }

      case "arrowAddRows": {
        try {
          return this.arrowAddRows(
            deltaPath,
            delta.arrowAddRows as ArrowNamedDataSet,
            scriptRunId
          )
        } catch (error) {
          const errorElement = makeElementWithErrorText(
            ensureError(error).message
          )
          return this.addElement(
            deltaPath,
            scriptRunId,
            errorElement,
            metadata,
            activeScriptHash
          )
        }
      }

      default: {
        throw new Error(`Unrecognized deltaType: '${delta.type}'`)
      }
    }
  }

  filterMainScriptElements(mainScriptHash: string): AppRoot {
    // clears all nodes that are not associated with the mainScriptHash
    // Get the current script run id from one of the children
    const currentScriptRunId = this.main.scriptRunId
    const main =
      this.main.filterMainScriptElements(mainScriptHash) ||
      new BlockNode(mainScriptHash)
    const sidebar =
      this.sidebar.filterMainScriptElements(mainScriptHash) ||
      new BlockNode(mainScriptHash)
    const event =
      this.event.filterMainScriptElements(mainScriptHash) ||
      new BlockNode(mainScriptHash)
    const bottom =
      this.bottom.filterMainScriptElements(mainScriptHash) ||
      new BlockNode(mainScriptHash)
    const appLogo =
      this.appLogo?.activeScriptHash === mainScriptHash ? this.appLogo : null

    return new AppRoot(
      mainScriptHash,
      new BlockNode(
        mainScriptHash,
        [main, sidebar, event, bottom],
        new BlockProto({ allowEmpty: true }),
        currentScriptRunId
      ),
      appLogo
    )
  }

  public clearStaleNodes(
    currentScriptRunId: string,
    fragmentIdsThisRun?: Array<string>
  ): AppRoot {
    const main =
      this.main.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||
      new BlockNode(this.mainScriptHash)
    const sidebar =
      this.sidebar.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||
      new BlockNode(this.mainScriptHash)
    const event =
      this.event.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||
      new BlockNode(this.mainScriptHash)
    const bottom =
      this.bottom.clearStaleNodes(currentScriptRunId, fragmentIdsThisRun) ||
      new BlockNode(this.mainScriptHash)

    const appLogo =
      this.appLogo?.scriptRunId === currentScriptRunId ? this.appLogo : null

    return new AppRoot(
      this.mainScriptHash,
      new BlockNode(
        this.mainScriptHash,
        [main, sidebar, event, bottom],
        new BlockProto({ allowEmpty: true }),
        currentScriptRunId
      ),
      appLogo
    )
  }

  /** Return a Set containing all Elements in the tree. */
  public getElements(): Set<Element> {
    const elements = new Set<Element>()
    this.main.getElements(elements)
    this.sidebar.getElements(elements)
    this.event.getElements(elements)
    this.bottom.getElements(elements)
    return elements
  }

  private addElement(
    deltaPath: number[],
    scriptRunId: string,
    element: Element,
    metadata: ForwardMsgMetadata,
    activeScriptHash: string,
    fragmentId?: string
  ): AppRoot {
    const elementNode = new ElementNode(
      element,
      metadata,
      scriptRunId,
      activeScriptHash,
      fragmentId
    )
    return new AppRoot(
      this.mainScriptHash,
      this.root.setIn(deltaPath, elementNode, scriptRunId),
      this.appLogo
    )
  }

  private addBlock(
    deltaPath: number[],
    block: BlockProto,
    scriptRunId: string,
    activeScriptHash: string,
    fragmentId?: string,
    deltaMsgReceivedAt?: number
  ): AppRoot {
    const existingNode = this.root.getIn(deltaPath)

    // If we're replacing an existing Block of the same type, this new Block
    // inherits the existing Block's children. This preserves two things:
    //  1. Widget State
    //  2. React state of all elements
    let children: AppNode[] = []
    if (
      existingNode instanceof BlockNode &&
      existingNode.deltaBlock.type === block.type
    ) {
      children = existingNode.children
    }

    const blockNode = new BlockNode(
      activeScriptHash,
      children,
      block,
      scriptRunId,
      fragmentId,
      deltaMsgReceivedAt
    )
    return new AppRoot(
      this.mainScriptHash,
      this.root.setIn(deltaPath, blockNode, scriptRunId),
      this.appLogo
    )
  }

  private arrowAddRows(
    deltaPath: number[],
    namedDataSet: ArrowNamedDataSet,
    scriptRunId: string
  ): AppRoot {
    const existingNode = this.root.getIn(deltaPath) as ElementNode
    if (isNullOrUndefined(existingNode)) {
      throw new Error(`Can't arrowAddRows: invalid deltaPath: ${deltaPath}`)
    }

    const elementNode = existingNode.arrowAddRows(namedDataSet, scriptRunId)
    return new AppRoot(
      this.mainScriptHash,
      this.root.setIn(deltaPath, elementNode, scriptRunId),
      this.appLogo
    )
  }
}

/** Iterates over datasets and converts data to Quiver. */
function wrapDatasets(datasets: IArrowNamedDataSet[]): WrappedNamedDataset[] {
  return datasets.map((dataset: IArrowNamedDataSet) => {
    return {
      hasName: dataset.hasName as boolean,
      name: dataset.name as string,
      data: new Quiver(dataset.data as IArrow),
    }
  })
}


================================================
File: /frontend/lib/src/FileUploadClient.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Mock } from "vitest"

import { FileUploadClient } from "./FileUploadClient"
import { mockSessionInfo } from "./mocks/mocks"

const MOCK_FILE_ID = -111
const MOCK_FILE = new File(["file1"], "file1.txt")

describe("FileUploadClient Upload", () => {
  let formsWithPendingRequestsChanged: Mock
  let requestFileURLs: Mock
  let uploadFileUploaderFile: Mock
  let uploader: FileUploadClient

  beforeEach(() => {
    formsWithPendingRequestsChanged = vi.fn()
    uploadFileUploaderFile = vi.fn()
    requestFileURLs = vi.fn()

    uploader = new FileUploadClient({
      sessionInfo: mockSessionInfo(),
      endpoints: {
        buildComponentURL: vi.fn(),
        buildMediaURL: vi.fn(),
        buildFileUploadURL: vi.fn(),
        buildAppPageURL: vi.fn(),
        uploadFileUploaderFile: uploadFileUploaderFile,
        deleteFileAtURL: vi.fn(),
        fetchCachedForwardMsg: vi.fn(),
      },
      formsWithPendingRequestsChanged,
      requestFileURLs,
    })
  })

  it("uploads files outside a form", async () => {
    uploadFileUploaderFile.mockResolvedValue(MOCK_FILE_ID)

    await expect(
      uploader.uploadFile(
        { id: "widgetId", formId: "" },
        "/_stcore/upload_file/file_1",
        MOCK_FILE
      )
    ).resolves.toBe(MOCK_FILE_ID)

    expect(formsWithPendingRequestsChanged).not.toHaveBeenCalled()
  })

  it("uploads files inside a form", async () => {
    uploadFileUploaderFile.mockResolvedValue(MOCK_FILE_ID)

    // Upload a file with an attached form ID.
    const uploadFilePromise = uploader.uploadFile(
      { id: "widgetId", formId: "mockFormId" },
      "/_stcore/upload_file/file_1",
      MOCK_FILE
    )

    // `formsWithPendingRequestsChanged` should be called with our mockFormId
    // when the upload kicks off.
    expect(formsWithPendingRequestsChanged).toHaveBeenCalledTimes(1)
    expect(formsWithPendingRequestsChanged).toHaveBeenLastCalledWith(
      new Set(["mockFormId"])
    )

    // Wait for the upload to complete
    await expect(uploadFilePromise).resolves.toBeDefined()

    // `formsWithPendingRequestsChanged` should be called a second time, with
    // an empty set
    expect(formsWithPendingRequestsChanged).toHaveBeenCalledTimes(2)
    expect(formsWithPendingRequestsChanged).toHaveBeenLastCalledWith(new Set())
  })

  it("handles errors outside a form", async () => {
    uploadFileUploaderFile.mockRejectedValue(new Error("oh no!"))

    await expect(
      uploader.uploadFile(
        { id: "widgetId", formId: "" },
        "/_stcore/upload_file/file_1",
        MOCK_FILE
      )
    ).rejects.toEqual(new Error("oh no!"))

    expect(formsWithPendingRequestsChanged).not.toHaveBeenCalled()
  })

  it("handles errors inside a form", async () => {
    uploadFileUploaderFile.mockRejectedValue(new Error("oh no!"))

    // Upload a file with an attached form ID.
    const uploadFilePromise = uploader.uploadFile(
      { id: "widgetId", formId: "mockFormId" },
      "/_stcore/upload_file/file_1",
      MOCK_FILE
    )

    // `formsWithPendingRequestsChanged` should be called with our mockFormId
    // when the upload kicks off.
    expect(formsWithPendingRequestsChanged).toHaveBeenCalledTimes(1)
    expect(formsWithPendingRequestsChanged).toHaveBeenLastCalledWith(
      new Set(["mockFormId"])
    )

    // Wait for the upload to error
    await expect(uploadFilePromise).rejects.toBeDefined()

    // `formsWithPendingRequestsChanged` should be called a second time, with
    // an empty set
    expect(formsWithPendingRequestsChanged).toHaveBeenCalledTimes(2)
    expect(formsWithPendingRequestsChanged).toHaveBeenLastCalledWith(new Set())
  })

  it("fetchFileURLs calls requestFileURLs and returns a promise", () => {
    const fileURLsPromise = uploader.fetchFileURLs([])
    expect(requestFileURLs).toHaveBeenCalledTimes(1)

    // @ts-expect-error
    const pendingReqs = uploader.pendingFileURLsRequests
    expect(pendingReqs.size).toBe(1)

    const reqId = pendingReqs.keys().next().value

    expect(pendingReqs.get(reqId)?.promise).toBe(fileURLsPromise)
  })

  it("onFileURLsResponse rejects promise on errorMsg", async () => {
    uploader.fetchFileURLs([])

    // @ts-expect-error
    const pendingReqs = uploader.pendingFileURLsRequests
    const reqId = pendingReqs.keys().next().value
    const promise = pendingReqs.get(reqId)?.promise

    uploader.onFileURLsResponse({
      responseId: reqId,
      errorMsg: "kaboom",
    })

    await expect(promise).rejects.toBe("kaboom")
  })

  it("onFileURLsResponse resolves promise on success", async () => {
    uploader.fetchFileURLs([])

    // @ts-expect-error
    const pendingReqs = uploader.pendingFileURLsRequests
    const reqId = pendingReqs.keys().next().value
    const promise = pendingReqs.get(reqId)?.promise

    uploader.onFileURLsResponse({
      responseId: reqId,
      fileUrls: [],
    })

    await expect(promise).resolves.toEqual([])
  })

  it("onFileURLsResponse does not error when given an invalid responseId", () => {
    // No need to do anything other than check that no error is thrown.
    expect(() => {
      uploader.onFileURLsResponse({
        responseId: "noCorrespondingId",
        fileUrls: [],
      })
    }).not.toThrow()
  })
})


================================================
File: /frontend/lib/src/FileUploadClient.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { CancelToken } from "axios"
import isEqual from "lodash/isEqual"
import { v4 as uuidv4 } from "uuid"

import { IFileURLs, IFileURLsResponse } from "@streamlit/lib/src/proto"

import { SessionInfo } from "./SessionInfo"
import { StreamlitEndpoints } from "./StreamlitEndpoints"
import { logWarning } from "./util/log"
import Resolver from "./util/Resolver"
import { isValidFormId } from "./util/utils"

/** Common widget protobuf fields that are used by the FileUploadClient. */
interface WidgetInfo {
  id: string
  formId: string
}

interface Props {
  /** The app's SessionInfo instance. */
  sessionInfo: SessionInfo
  endpoints: StreamlitEndpoints
  formsWithPendingRequestsChanged: (formIds: Set<string>) => void
  requestFileURLs?: (requestId: string, files: File[]) => void
}

/**
 * Handles operations related to the widgets that require file uploading.
 */
export class FileUploadClient {
  private readonly sessionInfo: SessionInfo

  private readonly endpoints: StreamlitEndpoints

  /**
   * Map of <formId: number of outstanding requests>. Updated whenever
   * a widget in a form creates are completes a request.
   */
  private readonly formsWithPendingRequests = new Map<string, number>()

  /**
   * Called when the set of forms that have pending file requests changes.
   */
  private readonly pendingFormUploadsChanged: (formIds: Set<string>) => void

  /**
   * Function to ask the app to request file URLs for getting/uploading/deleting
   * files. Currently, this is only done by App.tsx via a BackMsg sent over the
   * browser tab's websocket connection, but the FileUploadClient is
   * indifferent to the exact mechanism used.
   *
   * Upon receiving the requested file URLs, the app should call this class'
   * onFileURLsResponse method.
   */
  private readonly requestFileURLs?: (requestId: string, files: File[]) => void

  /**
   * A map from request ID (a uuidv4) to the Resolver that should resolve once
   * the requested file URLs are received.
   */
  private readonly pendingFileURLsRequests = new Map<
    string,
    Resolver<IFileURLs[]>
  >()

  public constructor(props: Props) {
    this.sessionInfo = props.sessionInfo
    this.endpoints = props.endpoints
    this.pendingFormUploadsChanged = props.formsWithPendingRequestsChanged
    this.requestFileURLs = props.requestFileURLs
  }

  /**
   * Upload a file to the given URL. It will be associated with this browser's
   * sessionID.
   *
   * @param widget: the FileUploader widget that's doing the upload.
   * @param fileUploadUrl: the URL to upload the file to.
   * @param file: the files to upload.
   * @param onUploadProgress: an optional function that will be called repeatedly with progress events during the upload.
   * @param cancelToken: an optional axios CancelToken that can be used to cancel the in-progress upload.
   *
   * @return a Promise<void> that resolves with a void promise when the upload is complete.
   */
  public async uploadFile(
    widget: WidgetInfo,
    fileUploadUrl: string,
    file: File,
    onUploadProgress?: (progressEvent: any) => void,
    cancelToken?: CancelToken
  ): Promise<void> {
    this.offsetPendingRequestCount(widget.formId, 1)
    return this.endpoints
      .uploadFileUploaderFile(
        fileUploadUrl,
        file,
        this.sessionInfo.current.sessionId,
        onUploadProgress,
        cancelToken
      )
      .finally(() => this.offsetPendingRequestCount(widget.formId, -1))
  }

  /**
   * Request that the file at the given URL is deleted.
   * @param fileUrl: the URL of the file to delete.
   */
  public deleteFile(fileUrl: string): Promise<void> {
    return this.endpoints.deleteFileAtURL
      ? this.endpoints.deleteFileAtURL(
          fileUrl,
          this.sessionInfo.current.sessionId
        )
      : Promise.resolve()
  }

  /**
   * Request that the app fetch URLs to upload/delete/get the given files. Once
   * this is done, the app should call this class' onFileURLsResponse to
   * signify completion.
   *
   * @param files: An array of files.
   *
   * @return a Promise<FileURLsResponse.IFileURLs[]> resolving to a list of
   * URLs for uploading and deleting the given files.
   */
  public fetchFileURLs(files: File[]): Promise<IFileURLs[]> {
    if (!this.requestFileURLs) {
      return Promise.resolve([])
    }

    const resolver = new Resolver<IFileURLs[]>()

    const requestId = uuidv4()
    this.pendingFileURLsRequests.set(requestId, resolver)
    this.requestFileURLs(requestId, files)

    return resolver.promise
  }

  /**
   * Callback to be called by the app once the file URLs corresponding to a
   * call to this.requestFileURLs has been received.
   *
   * @param resp: the FileURLsResponse corresponding to a call to
   * this.requestFileURLs.
   */
  public onFileURLsResponse(resp: IFileURLsResponse): void {
    const id = resp.responseId as string
    const resolver = this.pendingFileURLsRequests.get(id)
    if (resolver) {
      if (resp.errorMsg) {
        resolver.reject(resp.errorMsg)
      } else {
        resolver.resolve(resp.fileUrls || [])
      }
      this.pendingFileURLsRequests.delete(id)
    } else {
      logWarning(
        "fileURLsResponse received for nonexistent request, ignoring."
      )
    }
  }

  private getFormIdSet(): Set<string> {
    return new Set(this.formsWithPendingRequests.keys())
  }

  private offsetPendingRequestCount(formId: string, offset: number): void {
    if (offset === 0) {
      return
    }

    if (!isValidFormId(formId)) {
      return
    }

    const curCount = this.formsWithPendingRequests.get(formId) ?? 0
    const newCount = curCount + offset
    if (newCount < 0) {
      throw new Error(
        `Can't offset pendingRequestCount below 0 (formId=${formId}, curCount=${curCount}, offset=${offset})`
      )
    }

    const prevWidgetIds = this.getFormIdSet()

    if (newCount === 0) {
      this.formsWithPendingRequests.delete(formId)
    } else {
      this.formsWithPendingRequests.set(formId, newCount)
    }

    const newWidgetIds = this.getFormIdSet()
    if (!isEqual(newWidgetIds, prevWidgetIds)) {
      this.pendingFormUploadsChanged(newWidgetIds)
    }
  }
}


================================================
File: /frontend/lib/src/ForwardMessageCache.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Mock } from "vitest"

import { ForwardMsg } from "./proto"
import { ForwardMsgCache } from "./ForwardMessageCache"

interface MockCache {
  cache: ForwardMsgCache
  getCachedMessage: (hash: string) => ForwardMsg | undefined
  mockFetchCachedForwardMsg: Mock
}

function createCache(): MockCache {
  const mockFetchCachedForwardMsg = vi.fn()

  const cache = new ForwardMsgCache({
    buildComponentURL: vi.fn(),
    buildMediaURL: vi.fn(),
    buildFileUploadURL: vi.fn(),
    buildAppPageURL: vi.fn(),
    uploadFileUploaderFile: vi.fn(),
    deleteFileAtURL: vi.fn(),
    fetchCachedForwardMsg: mockFetchCachedForwardMsg,
  })

  const getCachedMessage = (hash: string): ForwardMsg | undefined =>
    // @ts-expect-error (accessing internals for testing)
    cache.getCachedMessage(hash, false)

  return { cache, getCachedMessage, mockFetchCachedForwardMsg }
}

/**
 * Create a mock ForwardMsg with the given hash
 */
function createForwardMsg(hash: string, cacheable = true): ForwardMsg {
  return ForwardMsg.fromObject({
    hash,
    metadata: { cacheable, deltaId: 0 },
  })
}

/**
 * Create a mock reference ForwardMsg
 */
function createRefMsg(msg: ForwardMsg): ForwardMsg {
  return ForwardMsg.fromObject({
    hash: "reference",
    metadata: msg.metadata,
    refHash: msg.hash,
  })
}

test("caches messages correctly", async () => {
  const { cache, getCachedMessage } = createCache()

  // Cacheable messages should be cached
  const msg1 = createForwardMsg("Cacheable", true)
  const encodedMsg1 = ForwardMsg.encode(msg1).finish()
  await cache.processMessagePayload(msg1, encodedMsg1)
  expect(getCachedMessage("Cacheable")).toEqual(msg1)

  // Uncacheable ones shouldn't!
  const msg2 = createForwardMsg("Uncacheable", false)
  const encodedMsg2 = ForwardMsg.encode(msg2).finish()
  await cache.processMessagePayload(msg2, encodedMsg2)
  expect(getCachedMessage("Uncacheable")).toBeUndefined()

  // Ref messages should never be cached
  const msg3 = createForwardMsg("Cacheable", true)
  if (msg3.metadata) {
    msg3.metadata.deltaPath = [2]
  }
  const ref = createRefMsg(msg3)
  const encodedRefMsg = ForwardMsg.encode(ref).finish()
  const unreferenced = await cache.processMessagePayload(ref, encodedRefMsg)
  expect(getCachedMessage(ref.hash)).toBeUndefined()
  expect(unreferenced).toEqual(msg3)

  // Test that our uncached messages are copies
  expect(unreferenced).not.toBe(msg3)
})

test("caches messages as a deep copy", async () => {
  const { cache, getCachedMessage } = createCache()

  const msg = ForwardMsg.fromObject({
    hash: "Cacheable",
    delta: { newElement: { text: { body: "test" } } },
    metadata: { cacheable: true, deltaPath: [2] },
  })

  const encodedMsg = ForwardMsg.encode(msg).finish()

  await cache.processMessagePayload(msg, encodedMsg)

  // Check if message is correctly cached
  expect(getCachedMessage("Cacheable")).toEqual(msg)

  // Modify specific values inside the message structure:
  // eslint-disable-next-line  @typescript-eslint/no-non-null-assertion
  msg.delta!.newElement!.text!.body = "foo"
  // eslint-disable-next-line  @typescript-eslint/no-non-null-assertion
  msg.metadata!.deltaPath = [10]

  // Check that it does not impact the cached message
  expect(getCachedMessage("Cacheable")?.delta?.newElement?.text?.body).toEqual(
    "test"
  )
  expect(getCachedMessage("Cacheable")?.metadata?.deltaPath).toEqual([2])
  // It should not be equal to the changed message
  expect(getCachedMessage("Cacheable")).not.toEqual(msg)
})

test("fetches uncached messages from server", async () => {
  const msg = createForwardMsg("Cacheable", true)
  const refMsg = createRefMsg(msg)
  const encodedRefMsg = ForwardMsg.encode(refMsg).finish()

  const { cache, getCachedMessage, mockFetchCachedForwardMsg } = createCache()
  mockFetchCachedForwardMsg.mockResolvedValue(
    new Uint8Array(ForwardMsg.encode(msg).finish())
  )

  // processMessagePayload on a reference message whose
  // original version does *not* exist in our local cache. We
  // should hit the server's /message endpoint to fetch it.
  await expect(
    cache.processMessagePayload(refMsg, encodedRefMsg)
  ).resolves.toEqual(msg)

  // The fetched message should now be cached
  expect(getCachedMessage("Cacheable")).toEqual(msg)
})

test("errors when uncached message is not on server", async () => {
  const msg = createForwardMsg("Cacheable", true)
  const refMsg = createRefMsg(msg)
  const encodedRefMsg = ForwardMsg.encode(refMsg).finish()

  const { cache, mockFetchCachedForwardMsg } = createCache()
  mockFetchCachedForwardMsg.mockRejectedValue(new Error("404"))

  await expect(
    cache.processMessagePayload(refMsg, encodedRefMsg)
  ).rejects.toThrow()
})

test("removes expired messages", () => {
  const { cache, getCachedMessage } = createCache()
  const msg = createForwardMsg("Cacheable", true)
  const encodedMsg = ForwardMsg.encode(msg).finish()

  // Add the message to the cache
  // @ts-expect-error accessing into internals for testing
  cache.maybeCacheMessage(msg, encodedMsg)
  expect(getCachedMessage(msg.hash)).toEqual(msg)

  // Increment our age. Our message should still exist.
  cache.incrementRunCount(1)
  expect(getCachedMessage(msg.hash)).toEqual(msg)

  // Bump our age over the expiration threshold.
  cache.incrementRunCount(1)
  expect(getCachedMessage(msg.hash)).toBeUndefined()
})


================================================
File: /frontend/lib/src/ForwardMessageCache.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  isNullOrUndefined,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

import { ForwardMsg } from "./proto"
import { logMessage } from "./util/log"
import { ensureError } from "./util/ErrorHandling"
import { StreamlitEndpoints } from "./StreamlitEndpoints"

class CacheEntry {
  public readonly encodedMsg: Uint8Array

  public scriptRunCount = 0

  public getAge(curScriptRunCount: number): number {
    return curScriptRunCount - this.scriptRunCount
  }

  constructor(encodedMsg: Uint8Array, scriptRunCount: number) {
    this.encodedMsg = encodedMsg
    this.scriptRunCount = scriptRunCount
  }
}

/**
 * Handles ForwardMsg caching for WebsocketConnection.
 */
export class ForwardMsgCache {
  private readonly messages = new Map<string, CacheEntry>()

  private readonly endpoints: StreamlitEndpoints

  /**
   * A counter that tracks the number of times the underlying script
   * has been run. We use this to expire our cache entries.
   */
  private scriptRunCount = 0

  constructor(endpoints: StreamlitEndpoints) {
    this.endpoints = endpoints
  }

  /**
   * Increment our scriptRunCount, and remove all entries from the cache
   * that have expired. This should be called after the script has finished
   * running.
   *
   * @param maxMessageAge Max age of a message in the cache.
   * The "age" of a message is defined by how many times the underlying script
   * has finished running (without a compile error) since the message was
   * last accessed.
   */
  public incrementRunCount(maxMessageAge: number): void {
    this.scriptRunCount += 1

    // It is safe to delete from a map during forEach iteration:
    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map/forEach#Description
    this.messages.forEach((entry, hash) => {
      if (entry.getAge(this.scriptRunCount) > maxMessageAge) {
        logMessage(`Removing expired ForwardMsg [hash=${hash}]`)
        this.messages.delete(hash)
      }
    })
  }

  /**
   * Process a ForwardMsg, "de-referencing" it if it's a reference to
   * a cached message.
   *
   * - If the message is cacheable, store it in the cache and return it
   *   unmodified.
   * - If the message is instead a reference to another message, look for
   *   the referenced message in the cache, and return it.
   * - If the referenced message isn't in our cache, request it from the
   *   server, cache it, and return it.
   */
  public async processMessagePayload(
    msg: ForwardMsg,
    encodedMsg: Uint8Array
  ): Promise<ForwardMsg> {
    this.maybeCacheMessage(msg, encodedMsg)

    if (msg.type !== "refHash") {
      return msg
    }

    let newMsg = this.getCachedMessage(msg.refHash as string, true)
    if (notNullOrUndefined(newMsg)) {
      logMessage(`Cached ForwardMsg HIT [hash=${msg.refHash}]`)
    } else {
      // Cache miss: fetch from the server
      logMessage(`Cached ForwardMsg MISS [hash=${msg.refHash}]`)
      const encodedNewMsg = await this.endpoints.fetchCachedForwardMsg(
        msg.refHash as string
      )
      try {
        newMsg = ForwardMsg.decode(encodedNewMsg)
      } catch (e) {
        throw new Error(
          `Failed to decode ForwardMsg (hash=${msg.refHash}): ${
            ensureError(e).message
          }`
        )
      }

      this.maybeCacheMessage(newMsg, encodedNewMsg)
    }

    // Copy the metadata from the refMsg into our new message
    if (!msg.metadata) {
      throw new Error("ForwardMsg has no metadata")
    }
    newMsg.metadata = ForwardMsg.decode(encodedMsg).metadata
    return newMsg
  }

  /**
   * Add a new message to the cache if appropriate.
   */
  private maybeCacheMessage(msg: ForwardMsg, encodedMsg: Uint8Array): void {
    if (msg.type === "refHash") {
      // We never cache reference messages. These messages
      // may have `metadata.cacheable` set, but this is
      // only because they carry the metadata for the messages
      // they refer to.
      return
    }

    if (!msg.metadata || !msg.metadata.cacheable) {
      // Don't cache messages that the server hasn't marked as cacheable.
      return
    }

    if (this.getCachedMessage(msg.hash, true) !== undefined) {
      // We've already cached this message; don't need to do
      // anything more. (Using getCachedMessage() here ensures
      // that the message's scriptRunCount value gets updated as
      // expected.)
      return
    }

    logMessage(`Caching ForwardMsg [hash=${msg.hash}]`)
    this.messages.set(
      msg.hash,
      new CacheEntry(encodedMsg, this.scriptRunCount)
    )
  }

  /**
   * Return a new copy of the ForwardMsg with the given hash
   * from the cache, or undefined if no such message exists.
   *
   * If the message's entry exists, its scriptRunCount will be
   * updated to the current value.
   */
  private getCachedMessage(
    hash: string,
    updateScriptRunCount: boolean
  ): ForwardMsg | undefined {
    const cached = this.messages.get(hash)
    if (isNullOrUndefined(cached)) {
      return undefined
    }

    if (updateScriptRunCount) {
      cached.scriptRunCount = this.scriptRunCount
    }
    return ForwardMsg.decode(cached.encodedMsg)
  }
}


================================================
File: /frontend/lib/src/RootStyleProvider.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { BaseProvider } from "baseui"
import createCache from "@emotion/cache"
import {
  CacheProvider,
  ThemeProvider as EmotionThemeProvider,
  Global,
} from "@emotion/react"

import { globalStyles, ThemeConfig } from "./theme"

export interface RootStyleProviderProps {
  theme: ThemeConfig
  children: React.ReactNode
}

const nonce = document.currentScript?.nonce || ""
const cache = createCache({
  // The key field is required but only matters if there's more than one
  // emotion cache in use. This will probably never be true for us, so we just
  // set it arbitrarily.
  key: "st-emotion-cache",
  ...(nonce && { nonce }),
})

export function RootStyleProvider(
  props: RootStyleProviderProps
): ReactElement {
  const { children, theme } = props
  return (
    <BaseProvider
      theme={theme.basewebTheme}
      zIndex={theme.emotion.zIndices.popupMenu}
    >
      <CacheProvider value={cache}>
        <EmotionThemeProvider theme={theme.emotion}>
          <Global styles={globalStyles} />
          {children}
        </EmotionThemeProvider>
      </CacheProvider>
    </BaseProvider>
  )
}


================================================
File: /frontend/lib/src/ScriptRunState.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export enum ScriptRunState {
  // TODO: Add INITIAL state here and clean up data-test-script-state in App.tsx.
  // But before we do this, we need to make sure Snowflake hosts that use this
  // state will not break. And that's a bigger project...
  //INITIAL = "initial",
  NOT_RUNNING = "notRunning",
  RUNNING = "running",
  RERUN_REQUESTED = "rerunRequested", // script *not* running, but user requested it be re-run
  STOP_REQUESTED = "stopRequested", // script *is* running, but user requested it be stopped
  COMPILATION_ERROR = "compilationError", // script failed with a compilation error
}


================================================
File: /frontend/lib/src/SessionInfo.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { SessionInfo } from "./SessionInfo"
import { NewSession } from "./proto"
import { mockSessionInfoProps } from "./mocks/mocks"

test("Throws an error when used before initialization", () => {
  const sessionInfo = new SessionInfo()
  expect(() => sessionInfo.current).toThrow()
})

describe("SessionInfo.setCurrent", () => {
  test("copies props to `current`", () => {
    const sessionInfo = new SessionInfo()
    sessionInfo.setCurrent(mockSessionInfoProps())

    expect(sessionInfo.isSet).toBe(true)
    expect(sessionInfo.current).toEqual(mockSessionInfoProps())
  })

  test("copies previous props to `last`", () => {
    const sessionInfo = new SessionInfo()
    sessionInfo.setCurrent(mockSessionInfoProps())
    expect(sessionInfo.last).toBeUndefined()

    sessionInfo.setCurrent(mockSessionInfoProps({ appId: "newValue" }))
    expect(sessionInfo.current).toEqual(
      mockSessionInfoProps({ appId: "newValue" })
    )
    expect(sessionInfo.last).toEqual(mockSessionInfoProps())
  })
})

describe("SessionInfo.isHello", () => {
  test("is true only when `isHello` is true in current SessionInfo", () => {
    const sessionInfo = new SessionInfo()
    expect(sessionInfo.isHello).toBe(false)

    sessionInfo.setCurrent(mockSessionInfoProps({ isHello: true }))
    expect(sessionInfo.isHello).toBe(true)

    sessionInfo.setCurrent(mockSessionInfoProps({ isHello: false }))
    expect(sessionInfo.isHello).toBe(false)
  })
})

test("Props can be initialized from a protobuf", () => {
  const MESSAGE = new NewSession({
    config: {
      gatherUsageStats: false,
      maxCachedMessageAge: 31,
      mapboxToken: "mapboxToken",
      allowRunOnSave: false,
    },
    initialize: {
      userInfo: {
        installationId: "installationId",
        installationIdV3: "installationIdV3",
      },
      environmentInfo: {
        streamlitVersion: "streamlitVersion",
        pythonVersion: "pythonVersion",
      },
      sessionStatus: {
        runOnSave: false,
        scriptIsRunning: false,
      },
      sessionId: "sessionId",
      isHello: false,
    },
  })

  const props = SessionInfo.propsFromNewSessionMessage(MESSAGE)
  expect(props.sessionId).toEqual("sessionId")
  expect(props.streamlitVersion).toEqual("streamlitVersion")
  expect(props.pythonVersion).toEqual("pythonVersion")
  expect(props.installationId).toEqual("installationId")
  expect(props.installationIdV3).toEqual("installationIdV3")
  expect(props.maxCachedMessageAge).toEqual(31)
  expect(props.commandLine).toBeUndefined()
  expect(props.isHello).toBeFalsy()
})


================================================
File: /frontend/lib/src/SessionInfo.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  Config,
  EnvironmentInfo,
  Initialize,
  NewSession,
  UserInfo,
} from "./proto"
import { hashString, notNullOrUndefined } from "./util/utils"

/**
 * SessionInfo properties. These don't change during the lifetime of a session.
 */
export interface Props {
  readonly appId: string
  readonly sessionId: string
  readonly streamlitVersion: string
  readonly pythonVersion: string
  readonly installationId: string
  readonly installationIdV3: string
  readonly maxCachedMessageAge: number
  readonly commandLine?: string // Unused, but kept around for compatibility
  readonly isHello: boolean
}

export class SessionInfo {
  /** Our current SessionInfo properties.*/
  private _current?: Props

  /**
   * Our last SessionInfo props if there is no currently active session, or
   * undefined if there is one.
   */
  private _last?: Props

  /** Return the current SessionInfo props. Throw an error if the props are undefined. */
  public get current(): Props {
    if (!this._current) {
      throw new Error("Tried to use SessionInfo before it was initialized")
    }
    return this._current
  }

  /** Return the previous SessionInfo props. They may be undefined! */
  public get last(): Props | undefined {
    return this._last
  }

  /**
   * Initialize `SessionInfo.current` with the given props and copy its
   * previous props to `SessionInfo.last`.
   */
  public setCurrent(props?: Props): void {
    this._last = notNullOrUndefined(this._current)
      ? { ...this._current }
      : undefined
    this._current = notNullOrUndefined(props) ? { ...props } : undefined
  }

  /** Clear `SessionInfo.current` and copy its previous props to `SessionInfo.last`. */
  public clearCurrent(): void {
    this.setCurrent(undefined)
  }

  /** True if `SessionInfo.current` exists. */
  public get isSet(): boolean {
    return notNullOrUndefined(this._current)
  }

  /** True if `SessionInfo.current` refers to a "streamlit hello" session. */
  public get isHello(): boolean {
    return notNullOrUndefined(this._current) && this._current.isHello
  }

  /** Create SessionInfo Props from the relevant bits of an initialize message. */
  public static propsFromNewSessionMessage(newSession: NewSession): Props {
    const initialize = newSession.initialize as Initialize
    const config = newSession.config as Config
    const userInfo = initialize.userInfo as UserInfo
    const environmentInfo = initialize.environmentInfo as EnvironmentInfo
    return {
      appId: hashString(userInfo.installationIdV3 + newSession.mainScriptPath),
      sessionId: initialize.sessionId,
      streamlitVersion: environmentInfo.streamlitVersion,
      pythonVersion: environmentInfo.pythonVersion,
      installationId: userInfo.installationId,
      installationIdV3: userInfo.installationIdV3,
      maxCachedMessageAge: config.maxCachedMessageAge,
      isHello: initialize.isHello,
    }
  }
}


================================================
File: /frontend/lib/src/StreamlitEndpoints.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { CancelToken } from "axios"

import { IAppPage } from "./proto"

export type FileUploadClientConfig = {
  prefix: string
  headers: Record<string, string>
}

/** Exposes non-websocket endpoints used by the frontend. */
export interface StreamlitEndpoints {
  /**
   * Return a URL to fetch data for the given custom component.
   * @param componentName The registered name of the component.
   * @param path The path of the component resource to fetch, e.g. "index.html".
   */
  buildComponentURL(componentName: string, path: string): string

  /**
   * Construct a URL for a media file.
   * @param url a relative or absolute URL. If `url` is absolute, it will be
   * returned unchanged. Otherwise, the return value will be a URL for fetching
   * the media file from the connected Streamlit instance.
   */
  buildMediaURL(url: string): string

  /**
   * Construct a URL for uploading a file.
   * @param url a relative or absolute URL. If `url` is absolute, it will be
   * returned unchanged. Otherwise, the return value will be a URL for fetching
   * the media file from the connected Streamlit instance.
   */
  buildFileUploadURL?(url: string): string

  /**
   * Construct a URL for an app page in a multi-page app.
   * @param pageLinkBaseURL the optional pageLinkBaseURL set by the host communication layer.
   * @param page the page's AppPage protobuf properties
   * @param pageIndex the page's zero-based index
   */
  buildAppPageURL(pageLinkBaseURL: string | undefined, page: IAppPage): string

  /**
   * Upload a file to the FileUploader endpoint.
   *
   * @param fileUploadUrl The URL to upload the file to.
   * @param file The file to upload.
   * @param sessionId the current sessionID. The file will be associated with this ID.
   * @param onUploadProgress optional function that will be called repeatedly with progress events during the upload.
   * @param cancelToken optional axios CancelToken that can be used to cancel the in-progress upload.
   *
   * @return a Promise<number> that resolves with the file's unique ID, as assigned by the server.
   */
  uploadFileUploaderFile(
    fileUploadUrl: string,
    file: File,
    sessionId: string,
    onUploadProgress?: (progressEvent: any) => void,
    cancelToken?: CancelToken
  ): Promise<void>

  /**
   * Request that the file at the given URL be deleted.
   *
   * @param fileUrl: The URL of the file to delete.
   * @param sessionId the current sessionID.
   */
  deleteFileAtURL?(fileUrl: string, sessionId: string): Promise<void>

  /**
   * Fetch a cached ForwardMsg from the server.
   *
   * This is called when the ForwardMessageCache has a cache miss - that is, when
   * the server sends a ForwardMsg reference and we don't have the original message
   * in our local cache.
   *
   * @param hash the message's hash
   *
   * @return a Promise<Uint8Array> that resolves with the serialized ForwardMsg data returned
   * from the server. Callers can use `ForwardMsg.decode` to deserialize the data.
   */
  fetchCachedForwardMsg(hash: string): Promise<Uint8Array>

  /**
   * setFileUploadClientConfig.
   * @param config the object that contains prefix and headers object
   */
  setFileUploadClientConfig?(config: FileUploadClientConfig): void
}


================================================
File: /frontend/lib/src/WidgetStateManager.test.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Mock } from "vitest"
import { enableAllPlugins } from "immer"

import {
  ArrowTable as ArrowTableProto,
  Button as ButtonProto,
  FileUploaderState as FileUploaderStateProto,
  UploadedFileInfo as UploadedFileInfoProto,
} from "./proto"
import {
  createFormsData,
  FormsData,
  WidgetInfo,
  WidgetStateDict,
  WidgetStateManager,
} from "./WidgetStateManager"

const MOCK_ARROW_TABLE = new ArrowTableProto({
  data: new Uint8Array(),
  index: new Uint8Array(),
  columns: new Uint8Array(),
})

const MOCK_BYTES = new Uint8Array([0, 1, 2, 3])

const MOCK_JSON = { foo: "bar", baz: "qux" }

const MOCK_WIDGET = {
  id: "mockWidgetId",
  formId: "",
}

const MOCK_FORM_WIDGET = {
  id: "mockFormWidgetId",
  formId: "mockFormId",
}

const MOCK_FILE_UPLOADER_STATE = new FileUploaderStateProto({
  maxFileId: 42,
  uploadedFileInfo: [
    new UploadedFileInfoProto({
      id: 4,
      name: "bob",
      size: 5,
    }),

    new UploadedFileInfoProto({
      id: 42,
      name: "linus",
      size: 9001,
    }),
  ],
})

// Required by ImmerJS
enableAllPlugins()

describe("Widget State Manager", () => {
  let sendBackMsg: Mock
  let widgetMgr: WidgetStateManager
  let formsData: FormsData
  let onFormsDataChanged: Mock

  beforeEach(() => {
    formsData = createFormsData()
    sendBackMsg = vi.fn()
    onFormsDataChanged = vi.fn(newData => {
      formsData = newData
    })
    widgetMgr = new WidgetStateManager({
      sendRerunBackMsg: sendBackMsg,
      formsDataChanged: onFormsDataChanged,
    })
  })

  /** Select the mock WidgetInfo to use for a test. */
  const getWidget = ({ insideForm }: { insideForm: boolean }): WidgetInfo => {
    return insideForm ? MOCK_FORM_WIDGET : MOCK_WIDGET
  }

  /** Assert calls of our callback functions. */
  const assertCallbacks = ({ insideForm }: { insideForm: boolean }): void => {
    if (insideForm) {
      expect(sendBackMsg).not.toHaveBeenCalled()
    } else {
      expect(sendBackMsg).toHaveBeenCalledTimes(1)
      expect(sendBackMsg).toHaveBeenCalledWith(
        expect.anything(),
        undefined, // fragmentId
        undefined,
        undefined
      )
    }
  }

  it.each([false, true])(
    "sets string value correctly (insideForm=%p)",
    insideForm => {
      const widget = getWidget({ insideForm })
      widgetMgr.setStringValue(
        widget,
        "mockStringValue",
        { fromUi: true },
        undefined
      )
      expect(widgetMgr.getStringValue(widget)).toBe("mockStringValue")
      assertCallbacks({ insideForm })
    }
  )

  it.each([false, true])(
    "sets boolean value correctly (insideForm=%p)",
    insideForm => {
      const widget = getWidget({ insideForm })
      widgetMgr.setBoolValue(widget, true, { fromUi: true }, undefined)
      expect(widgetMgr.getBoolValue(widget)).toBe(true)
      assertCallbacks({ insideForm })
    }
  )

  it.each([false, true])(
    "sets int value correctly (insideForm=%p)",
    insideForm => {
      const widget = getWidget({ insideForm })
      widgetMgr.setIntValue(widget, 100, { fromUi: true }, undefined)
      expect(widgetMgr.getIntValue(widget)).toBe(100)
      assertCallbacks({ insideForm })
    }
  )

  it.each([false, true])(
    "sets float value correctly (insideForm=%p)",
    insideForm => {
      const widget = getWidget({ insideForm })
      widgetMgr.setDoubleValue(widget, 3.14, { fromUi: true }, undefined)
      expect(widgetMgr.getDoubleValue(widget)).toBe(3.14)
      assertCallbacks({ insideForm })
    }
  )

  /**
   * Buttons (which set trigger values) can't be used within forms, so this test
   * is not parameterized on insideForm.
   */
  it("sets trigger value correctly", async () => {
    const widget = getWidget({ insideForm: false })
    await widgetMgr.setTriggerValue(widget, { fromUi: true }, undefined)

    // @ts-expect-error
    expect(widgetMgr.getWidgetState(widget)).toBe(undefined)
    assertCallbacks({ insideForm: false })
  })

  /**
   * String Triggers can't be used within forms, so this test
   * is not parameterized on insideForm.
   */
  it("sets string trigger value correctly", async () => {
    const widget = getWidget({ insideForm: false })
    await widgetMgr.setStringTriggerValue(
      widget,
      "sample string",
      { fromUi: true },
      undefined
    )
    // @ts-expect-error
    expect(widgetMgr.getWidgetState(widget)).toBe(undefined)
    assertCallbacks({ insideForm: false })
  })

  it.each([false, true])(
    "sets string array value correctly (insideForm=%p)",
    insideForm => {
      const widget = getWidget({ insideForm })
      widgetMgr.setStringArrayValue(
        widget,
        ["foo", "bar", "baz"],
        {
          fromUi: true,
        },
        undefined
      )
      expect(widgetMgr.getStringArrayValue(widget)).toEqual([
        "foo",
        "bar",
        "baz",
      ])
      assertCallbacks({ insideForm })
    }
  )

  it.each([false, true])(
    "sets int array value correctly (insideForm=%p)",
    insideForm => {
      const widget = getWidget({ insideForm })
      widgetMgr.setIntArrayValue(
        widget,
        [4, 5, 6],
        { fromUi: true },
        undefined
      )
      expect(widgetMgr.getIntArrayValue(widget)).toEqual([4, 5, 6])
      assertCallbacks({ insideForm })
    }
  )

  it.each([false, true])(
    "sets float array value correctly (insideForm=%p)",
    insideForm => {
      const widget = getWidget({ insideForm })
      widgetMgr.setDoubleArrayValue(
        widget,
        [1.1, 2.2, 3.3],
        {
          fromUi: true,
        },
        undefined
      )
      expect(widgetMgr.getDoubleArrayValue(widget)).toEqual([1.1, 2.2, 3.3])
      assertCallbacks({ insideForm })
    }
  )

  it.each([false, true])(
    "sets ArrowTable value correctly (insideForm=%p)",
    insideForm => {
      const widget = getWidget({ insideForm })
      widgetMgr.setArrowValue(
        widget,
        MOCK_ARROW_TABLE,
        { fromUi: true },
        undefined
      )
      expect(widgetMgr.getArrowValue(widget)).toEqual(MOCK_ARROW_TABLE)
      assertCallbacks({ insideForm })
    }
  )

  it.each([false, true])(
    "sets JSON value correctly (insideForm=%p)",
    insideForm => {
      const widget = getWidget({ insideForm })
      widgetMgr.setJsonValue(
        widget,
        MOCK_JSON,
        {
          fromUi: true,
        },
        undefined
      )
      expect(widgetMgr.getJsonValue(widget)).toBe(JSON.stringify(MOCK_JSON))
      assertCallbacks({ insideForm })
    }
  )

  it.each([false, true])(
    "sets bytes value correctly (insideForm=%p)",
    insideForm => {
      const widget = getWidget({ insideForm })
      widgetMgr.setBytesValue(widget, MOCK_BYTES, { fromUi: true }, undefined)
      expect(widgetMgr.getBytesValue(widget)).toEqual(MOCK_BYTES)
      assertCallbacks({ insideForm })
    }
  )

  it.each([false, true])(
    "sets FileUploaderState value correctly (insideForm=%p)",
    insideForm => {
      const widget = getWidget({ insideForm })
      widgetMgr.setFileUploaderStateValue(
        widget,
        MOCK_FILE_UPLOADER_STATE,
        {
          fromUi: true,
        },
        undefined
      )
      expect(widgetMgr.getFileUploaderStateValue(widget)).toEqual(
        MOCK_FILE_UPLOADER_STATE
      )
      assertCallbacks({ insideForm })
    }
  )

  it("setIntValue can handle MIN_ and MAX_SAFE_INTEGER", () => {
    widgetMgr.setIntValue(
      MOCK_WIDGET,
      Number.MAX_SAFE_INTEGER,
      {
        fromUi: true,
      },
      undefined
    )

    expect(widgetMgr.getIntValue(MOCK_WIDGET)).toBe(Number.MAX_SAFE_INTEGER)

    widgetMgr.setIntValue(
      MOCK_WIDGET,
      Number.MIN_SAFE_INTEGER,
      {
        fromUi: true,
      },
      undefined
    )

    expect(widgetMgr.getIntValue(MOCK_WIDGET)).toBe(Number.MIN_SAFE_INTEGER)
  })

  it("setIntArrayValue can handle MIN_ and MAX_SAFE_INTEGER", () => {
    const values = [Number.MAX_SAFE_INTEGER, Number.MIN_SAFE_INTEGER]
    widgetMgr.setIntArrayValue(
      MOCK_WIDGET,
      values,
      {
        fromUi: true,
      },
      undefined
    )

    expect(widgetMgr.getIntArrayValue(MOCK_WIDGET)).toStrictEqual(values)
  })

  describe("can set fragmentId in setter methods", () => {
    it.each([
      {
        setterMethod: "setStringTriggerValue",
        value: "Hello world",
      },
      {
        setterMethod: "setBoolValue",
        value: true,
      },
      {
        setterMethod: "setIntValue",
        value: 42,
      },
      {
        setterMethod: "setDoubleValue",
        value: 42.0,
      },
      {
        setterMethod: "setStringValue",
        value: "Hello world",
      },
      {
        setterMethod: "setStringArrayValue",
        value: ["Hello", "world"],
      },
      {
        setterMethod: "setDoubleArrayValue",
        value: [40.0, 2.0],
      },
      {
        setterMethod: "setIntArrayValue",
        value: [40, 2],
      },
      {
        setterMethod: "setJsonValue",
        value: MOCK_JSON,
      },
      {
        setterMethod: "setArrowValue",
        value: MOCK_ARROW_TABLE,
      },
      {
        setterMethod: "setBytesValue",
        value: MOCK_BYTES,
      },
      {
        setterMethod: "setFileUploaderStateValue",
        value: MOCK_FILE_UPLOADER_STATE,
      },
    ])("%p", async ({ setterMethod, value }) => {
      // @ts-expect-error
      await widgetMgr[setterMethod](
        MOCK_WIDGET,
        value,
        {
          fromUi: true,
        },
        "myFragmentId"
      )
      expect(sendBackMsg).toHaveBeenCalledWith(
        expect.anything(),
        "myFragmentId",
        undefined,
        undefined
      )
    })

    // This test isn't parameterized like the ones above because setTriggerValue
    // has a slightly different signature from the other setter methods.
    it("can set fragmentId in setTriggerValue", async () => {
      await widgetMgr.setTriggerValue(
        MOCK_WIDGET,
        {
          fromUi: true,
        },
        "myFragmentId"
      )
      expect(sendBackMsg).toHaveBeenCalledWith(
        expect.anything(),
        "myFragmentId",
        undefined,
        undefined
      )
    })
  })

  describe("Primitive types as JSON values", () => {
    it("sets string value as JSON correctly", () => {
      widgetMgr.setJsonValue(
        MOCK_WIDGET,
        "mockStringValue",
        { fromUi: true },
        undefined
      )
      expect(widgetMgr.getJsonValue(MOCK_WIDGET)).toBe(
        JSON.stringify("mockStringValue")
      )
    })

    it("sets int value as JSON correctly", () => {
      widgetMgr.setJsonValue(MOCK_WIDGET, 45, { fromUi: true }, undefined)
      expect(widgetMgr.getJsonValue(MOCK_WIDGET)).toBe(JSON.stringify(45))
    })

    it("sets float value as JSON correctly", () => {
      widgetMgr.setJsonValue(MOCK_WIDGET, 3.14, { fromUi: true }, undefined)
      expect(widgetMgr.getJsonValue(MOCK_WIDGET)).toBe(JSON.stringify(3.14))
    })

    it("sets string array value as JSON correctly", () => {
      widgetMgr.setJsonValue(
        MOCK_WIDGET,
        ["foo", "bar", "baz"],
        {
          fromUi: true,
        },
        undefined
      )
      expect(widgetMgr.getJsonValue(MOCK_WIDGET)).toBe(
        JSON.stringify(["foo", "bar", "baz"])
      )
    })

    it("sets int array value as JSON correctly", () => {
      widgetMgr.setJsonValue(
        MOCK_WIDGET,
        [5, 6, 7],
        { fromUi: true },
        undefined
      )
      expect(widgetMgr.getJsonValue(MOCK_WIDGET)).toBe(
        JSON.stringify([5, 6, 7])
      )
    })

    it("sets float array value as JSON correctly", () => {
      widgetMgr.setJsonValue(
        MOCK_WIDGET,
        [1.1, 2.2, 3.3],
        { fromUi: true },
        undefined
      )
      expect(widgetMgr.getJsonValue(MOCK_WIDGET)).toBe(
        JSON.stringify([1.1, 2.2, 3.3])
      )
    })
  })

  // Other FormsData-related tests
  describe("formsData", () => {
    it("updates submitButtons Array", () => {
      const newButtonMock = new ButtonProto()
      const secondButtonMock = new ButtonProto({ id: "newId" })
      expect(formsData.submitButtons.get("form")).not.toBeDefined()
      widgetMgr.addSubmitButton("form", newButtonMock)
      expect(formsData.submitButtons.get("form")?.length).toEqual(1)
      widgetMgr.addSubmitButton("form", secondButtonMock)
      expect(formsData.submitButtons.get("form")?.length).toEqual(2)
      widgetMgr.removeSubmitButton("form", newButtonMock)
      expect(formsData.submitButtons.get("form")?.length).toEqual(1)
      widgetMgr.removeSubmitButton("form", secondButtonMock)
      expect(formsData.submitButtons.get("form")?.length).toEqual(0)
    })

    it("updates formsWithUploads", () => {
      widgetMgr.setFormsWithUploadsInProgress(new Set(["three", "four"]))
      expect(onFormsDataChanged).toHaveBeenCalledTimes(1)
      expect(formsData.formsWithUploads.has("one")).toBe(false)
      expect(formsData.formsWithUploads.has("two")).toBe(false)
      expect(formsData.formsWithUploads.has("three")).toBe(true)
      expect(formsData.formsWithUploads.has("four")).toBe(true)
    })

    it("creates frozen FormsData instances", () => {
      // Our sets are readonly, but that doesn't prevent mutating functions
      // from being called on them. Immer will detect these calls at runtime
      // and throw errors.

      // It's sufficient to check just a single FormsData member for this test;
      // Immer imposes this immutability guarantee on all of an object's
      // sets, maps, and arrays.
      widgetMgr.setFormsWithUploadsInProgress(new Set(["one", "two"]))
      expect(Object.isFrozen(formsData.formsWithUploads)).toBe(true)
    })
  })

  describe("submitForm", () => {
    it("calls sendBackMsg with expected data", () => {
      const formId = "mockFormId"
      widgetMgr.addSubmitButton(
        formId,
        new ButtonProto({ id: "submitButton" })
      )

      // Populate a form
      widgetMgr.setStringValue(
        { id: "widget1", formId },
        "foo",
        {
          fromUi: true,
        },
        undefined
      )
      widgetMgr.setStringValue(
        { id: "widget2", formId },
        "bar",
        {
          fromUi: true,
        },
        undefined
      )

      // We have a single pending form.
      expect(formsData.formsWithPendingChanges).toEqual(new Set([formId]))

      widgetMgr.submitForm(formId, undefined)

      // Our backMsg should be populated with our two widget values,
      // plus the submitButton's value.
      expect(sendBackMsg).toHaveBeenCalledWith(
        {
          widgets: [
            { id: "submitButton", triggerValue: true },
            { id: "widget1", stringValue: "foo" },
            { id: "widget2", stringValue: "bar" },
          ],
        },
        undefined, // fragmentId
        undefined,
        undefined
      )

      // We have no more pending form.
      expect(formsData.formsWithPendingChanges).toEqual(new Set())
    })

    it("calls sendBackMsg with fragmentId", () => {
      const formId = "mockFormId"
      widgetMgr.addSubmitButton(
        formId,
        new ButtonProto({ id: "submitButton" })
      )

      // Populate a form
      widgetMgr.setStringValue(
        { id: "widget1", formId },
        "foo",
        {
          fromUi: true,
        },
        undefined
      )

      widgetMgr.submitForm(formId, "myFragmentId", undefined)

      // Our backMsg should be populated with our two widget values,
      // plus the submitButton's value.
      expect(sendBackMsg).toHaveBeenCalledWith(
        {
          widgets: [
            { id: "submitButton", triggerValue: true },
            { id: "widget1", stringValue: "foo" },
          ],
        },
        "myFragmentId",
        undefined,
        undefined
      )

      // We have no more pending form.
      expect(formsData.formsWithPendingChanges).toEqual(new Set())
    })

    it("throws on invalid formId", () => {
      expect(() =>
        widgetMgr.submitForm(MOCK_WIDGET.formId, undefined)
      ).toThrow(`invalid formID ${MOCK_WIDGET.formId}`)
    })

    it("submits the form for the first submitButton if an actualSubmitButton proto is not passed", () => {
      const formId = "mockFormId"
      widgetMgr.addSubmitButton(
        formId,
        new ButtonProto({ id: "firstSubmitButton" })
      )
      widgetMgr.addSubmitButton(
        formId,
        new ButtonProto({ id: "secondSubmitButton" })
      )
      widgetMgr.submitForm(formId, undefined)

      expect(sendBackMsg).toHaveBeenCalledWith(
        {
          widgets: [{ id: "firstSubmitButton", triggerValue: true }],
        },
        undefined,
        undefined,
        undefined
      )
    })

    it("submits the form for the actualSubmitButton when passed", () => {
      const formId = "mockFormId"
      widgetMgr.addSubmitButton(
        formId,
        new ButtonProto({ id: "firstSubmitButton" })
      )
      const actualSubmitButton = new ButtonProto({
        id: "secondSubmitButton",
        isFormSubmitter: true,
      })
      widgetMgr.addSubmitButton(formId, actualSubmitButton)
      widgetMgr.submitForm(formId, undefined, actualSubmitButton)

      expect(sendBackMsg).toHaveBeenCalledWith(
        {
          widgets: [{ id: "secondSubmitButton", triggerValue: true }],
        },
        undefined,
        undefined,
        undefined
      )
    })
  })

  describe("allowFormEnterToSubmit", () => {
    it("returns true for a valid formId with 1st submit button enabled", () => {
      // Create form with a submit button
      const formId = "mockFormId"

      widgetMgr.addSubmitButton(
        formId,
        new ButtonProto({ id: "submitButton" })
      )
      widgetMgr.setStringValue(
        { id: "widget1", formId },
        "foo",
        {
          fromUi: true,
        },
        undefined
      )

      // Form should exist & allow submission on Enter
      // @ts-expect-error - checking that form exists via internal state
      expect(widgetMgr.forms.get(formId)).toBeTruthy()
      expect(widgetMgr.allowFormEnterToSubmit(formId)).toBe(true)
    })

    it("returns false for an invalid formId", () => {
      // Create form with a submit button
      const formId = "mockFormId"

      widgetMgr.addSubmitButton(
        formId,
        new ButtonProto({ id: "submitButton" })
      )
      widgetMgr.setStringValue(
        { id: "widget1", formId },
        "foo",
        {
          fromUi: true,
        },
        undefined
      )

      // @ts-expect-error - Created form should exist
      expect(widgetMgr.forms.get(formId)).toBeTruthy()

      // @ts-expect-error - Other form should NOT exist & should not allow submit on Enter
      expect(widgetMgr.forms.get("INVALID_FORM_ID")).toBeFalsy()
      expect(widgetMgr.allowFormEnterToSubmit("INVALID_FORM_ID")).toBe(false)
    })

    it("returns false for a valid formId with no submit buttons", () => {
      // Create form with a submit button
      const formId = "mockFormId"

      widgetMgr.setStringValue(
        { id: "widget1", formId },
        "foo",
        {
          fromUi: true,
        },
        undefined
      )

      // @ts-expect-error - Created form should exist, but no allow submit on Enter
      expect(widgetMgr.forms.get(formId)).toBeTruthy()
      expect(widgetMgr.allowFormEnterToSubmit(formId)).toBe(false)
    })

    it("returns false if the 1st submit button disabled", () => {
      // Create form with a submit button
      const formId = "mockFormId"

      widgetMgr.addSubmitButton(
        formId,
        new ButtonProto({ id: "submitButton", disabled: true })
      )
      widgetMgr.setStringValue(
        { id: "widget1", formId },
        "foo",
        {
          fromUi: true,
        },
        undefined
      )

      // @ts-expect-error - Created form should exist, but no allow submit on Enter
      expect(widgetMgr.forms.get(formId)).toBeTruthy()
      expect(widgetMgr.allowFormEnterToSubmit(formId)).toBe(false)
    })

    it("returns true if the 1st submit button enabled, others disabled", () => {
      // Create form with a submit button
      const formId = "mockFormId"

      widgetMgr.addSubmitButton(
        formId,
        new ButtonProto({ id: "submitButton" })
      )
      widgetMgr.addSubmitButton(
        formId,
        new ButtonProto({ id: "submitButton2", disabled: true })
      )
      widgetMgr.setStringValue(
        { id: "widget1", formId },
        "foo",
        {
          fromUi: true,
        },
        undefined
      )

      // @ts-expect-error - Created form should exist and allow submit on Enter
      expect(widgetMgr.forms.get(formId)).toBeTruthy()
      expect(widgetMgr.allowFormEnterToSubmit(formId)).toBe(true)
    })

    it("returns false if form created with enter_to_submit=False", () => {
      // Create form with a submit button
      const formId = "mockFormId"

      // Create form with enter_to_submit=False
      widgetMgr.setFormSubmitBehaviors(formId, false, false)

      widgetMgr.addSubmitButton(
        formId,
        new ButtonProto({ id: "submitButton" })
      )
      widgetMgr.setStringValue(
        { id: "widget1", formId },
        "foo",
        {
          fromUi: true,
        },
        undefined
      )

      // @ts-expect-error - Created form should exist, but no allow submit on Enter
      expect(widgetMgr.forms.get(formId)).toBeTruthy()
      expect(widgetMgr.allowFormEnterToSubmit(formId)).toBe(false)
    })
  })

  describe("Forms don't interfere with each other", () => {
    const FORM_1 = {
      id: "NOT_A_REAL_WIDGET_ID_1",
      formId: "NOT_A_REAL_FORM_ID_1",
    }
    const FORM_2 = {
      id: "NOT_A_REAL_WIDGET_ID_2",
      formId: "NOT_A_REAL_FORM_ID_2",
    }

    beforeEach(() => {
      // Set widget value for the first form.
      widgetMgr.setStringValue(
        FORM_1,
        "foo",
        {
          fromUi: true,
        },
        undefined
      )

      // Set widget value for the second form.
      widgetMgr.setStringValue(
        FORM_2,
        "bar",
        {
          fromUi: true,
        },
        undefined
      )
    })

    it("checks that there are two pending forms", () => {
      expect(formsData.formsWithPendingChanges).toEqual(
        new Set([FORM_1.formId, FORM_2.formId])
      )
    })

    it("calls sendBackMsg with the first form data", () => {
      widgetMgr.addSubmitButton(
        FORM_1.formId,
        new ButtonProto({ id: "submitButton" })
      )

      // Submit the first form.
      widgetMgr.submitForm(FORM_1.formId, undefined)

      // Our backMsg should be populated with the first form widget value,
      // plus the first submitButton's triggerValue.
      expect(sendBackMsg).toHaveBeenCalledWith(
        {
          widgets: [
            { id: "submitButton", triggerValue: true },
            { id: FORM_1.id, stringValue: "foo" },
          ],
        },
        undefined,
        undefined,
        undefined
      )
    })

    it("checks that only the second form is pending after the first is submitted", () => {
      widgetMgr.submitForm(FORM_1.formId, undefined)
      expect(formsData.formsWithPendingChanges).toEqual(
        new Set([FORM_2.formId])
      )
    })

    it("calls sendBackMsg with data from both forms", () => {
      // Submit the first form and then the second form.
      widgetMgr.submitForm(FORM_1.formId, undefined)
      widgetMgr.submitForm(
        FORM_2.formId,
        undefined,
        new ButtonProto({ id: "submitButton2" })
      )

      // Our most recent backMsg should be populated with the both forms' widget values,
      // plus the second submitButton's fromSubmitValue.
      expect(sendBackMsg).toHaveBeenLastCalledWith(
        {
          widgets: [
            { id: FORM_1.id, stringValue: "foo" },
            { id: "submitButton2", triggerValue: true },
            { id: FORM_2.id, stringValue: "bar" },
          ],
        },
        undefined,
        undefined,
        undefined
      )
    })

    it("checks that no more pending forms exist after both are submitted", () => {
      widgetMgr.submitForm(FORM_1.formId, undefined)
      widgetMgr.submitForm(FORM_2.formId, undefined)
      expect(formsData.formsWithPendingChanges).toEqual(new Set())
    })

    it("supports two submit buttons and can submitForm on the second one", () => {
      widgetMgr.addSubmitButton(
        FORM_1.formId,
        new ButtonProto({ id: "submitButton" })
      )
      widgetMgr.addSubmitButton(
        FORM_2.formId,
        new ButtonProto({ id: "submitButton2" })
      )

      // Submit the second form.
      widgetMgr.submitForm(
        FORM_2.formId,
        undefined,
        new ButtonProto({ id: "submitButton2" })
      )

      expect(sendBackMsg).toHaveBeenCalledWith(
        {
          widgets: [
            { id: "submitButton2", triggerValue: true },
            { id: FORM_2.id, stringValue: "bar" },
          ],
        },
        undefined,
        undefined,
        undefined
      )
    })
  })

  describe("manages element state values", () => {
    it("sets extra widget information properly", () => {
      widgetMgr.setElementState("id", "color", "red")
      // @ts-expect-error
      expect(widgetMgr.elementStates.get("id")?.get("color")).toEqual("red")
    })

    it("returns extra widget information when id exists and key exists", () => {
      // @ts-expect-error
      widgetMgr.elementStates.set("id", new Map([["color", "red"]]))
      expect(widgetMgr.getElementState("id", "color")).toEqual("red")
    })

    it("returns undefined when when id does not exist", () => {
      expect(widgetMgr.getElementState("id", "color")).toEqual(undefined)
    })

    it("returns undefined when when id exists and key does not exist", () => {
      // @ts-expect-error
      widgetMgr.elementStates.set("id", new Map([["text", "red"]]))
      expect(widgetMgr.getElementState("id", "color")).toEqual(undefined)
    })

    it("deletes a value for the key if set", () => {
      // @ts-expect-error
      widgetMgr.elementStates.set("id", new Map([["text", "red"]]))
      widgetMgr.deleteElementState("id", "color")
      expect(widgetMgr.getElementState("id", "color")).toEqual(undefined)
    })

    it("does not error when deleting for the key if not set", () => {
      widgetMgr.deleteElementState("id", "color")
      expect(widgetMgr.getElementState("id", "color")).toEqual(undefined)
    })
  })

  it("cleans up widget & element states on removeInactive", () => {
    const widgetId1 = "TEST_ID_1"
    const widgetId2 = "TEST_ID_2"
    const widgetId3 = "TEST_ID_3"
    const widgetId4 = "TEST_ID_4"
    const elementId1 = "TEST_ID_5"
    const elementId2 = "TEST_ID_6"
    widgetMgr.setStringValue(
      { id: widgetId1 },
      "widgetState1",
      {
        fromUi: false,
      },
      undefined
    )
    widgetMgr.setStringValue(
      { id: widgetId2 },
      "widgetState2",
      {
        fromUi: false,
      },
      undefined
    )
    widgetMgr.setStringValue(
      { id: widgetId3 },
      "widgetState3",
      {
        fromUi: false,
      },
      undefined
    )
    widgetMgr.setStringValue(
      { id: widgetId4 },
      "widgetState4",
      {
        fromUi: false,
      },
      undefined
    )

    widgetMgr.setElementState(elementId1, "key1", "elementState1")
    widgetMgr.setElementState(elementId2, "key2", "elementState2")

    const activeIds = new Set([widgetId3, widgetId4, elementId2])
    widgetMgr.removeInactive(activeIds)

    expect(widgetMgr.getStringValue({ id: widgetId1 })).toBeUndefined()
    expect(widgetMgr.getStringValue({ id: widgetId2 })).toBeUndefined()
    expect(widgetMgr.getStringValue({ id: widgetId3 })).toEqual("widgetState3")
    expect(widgetMgr.getStringValue({ id: widgetId4 })).toEqual("widgetState4")
    expect(widgetMgr.getElementState(elementId1, "key1")).toBeUndefined()
    expect(widgetMgr.getElementState(elementId2, "key2")).toEqual(
      "elementState2"
    )
  })
})

describe("WidgetStateDict", () => {
  let widgetStateDict: WidgetStateDict
  const widgetId = "TEST_ID"

  beforeEach(() => {
    widgetStateDict = new WidgetStateDict()
  })

  it("creates a new state with the given widget id", () => {
    widgetStateDict.createState(widgetId)

    expect(widgetStateDict.getState(widgetId)).toEqual({ id: widgetId })
  })

  it("deletes a state with the given widget id", () => {
    widgetStateDict.createState(widgetId)
    widgetStateDict.deleteState(widgetId)

    expect(widgetStateDict.getState(widgetId)).toBeUndefined()
  })

  it("checks that widget state dict is empty after creation", () => {
    expect(widgetStateDict.isEmpty).toBeTruthy()
  })

  it("checks that widget state dict is not empty if there is at least one element in it", () => {
    widgetStateDict.createState(widgetId)

    expect(widgetStateDict.isEmpty).toBeFalsy()
  })

  it("checks that widget state dict is empty if all elements have been deleted", () => {
    widgetStateDict.createState(widgetId)
    widgetStateDict.deleteState(widgetId)

    expect(widgetStateDict.isEmpty).toBeTruthy()
  })

  it("cleans states of widgets that are not contained in `activeIds`", () => {
    const widgetId1 = "TEST_ID_1"
    const widgetId2 = "TEST_ID_2"
    const widgetId3 = "TEST_ID_3"
    const widgetId4 = "TEST_ID_4"
    widgetStateDict.createState(widgetId1)
    widgetStateDict.createState(widgetId2)
    widgetStateDict.createState(widgetId3)
    widgetStateDict.createState(widgetId4)

    const activeIds = new Set([widgetId3, widgetId4])
    widgetStateDict.removeInactive(activeIds)

    expect(widgetStateDict.getState(widgetId1)).toBeUndefined()
    expect(widgetStateDict.getState(widgetId2)).toBeUndefined()
    expect(widgetStateDict.getState(widgetId3)).toEqual({ id: widgetId3 })
    expect(widgetStateDict.getState(widgetId4)).toEqual({ id: widgetId4 })
  })

  it("creates widget state message", () => {
    widgetStateDict.createState(widgetId)
    const msg = widgetStateDict.createWidgetStatesMsg()

    expect(msg.widgets).toEqual([{ id: widgetId }])
  })

  it("copies the contents of another WidgetStateDict into the given one, overwriting any values with duplicate keys", () => {
    const widgetId1 = "TEST_ID_1"
    const widgetId2 = "TEST_ID_2"
    const widgetId3 = "TEST_ID_3"

    widgetStateDict.createState(widgetId1)
    widgetStateDict.createState(widgetId2)

    // NOTE: `widgetId2` is used in both dicts.
    const newWidgetDict = new WidgetStateDict()
    newWidgetDict.createState(widgetId2)
    newWidgetDict.createState(widgetId3)

    widgetStateDict.copyFrom(newWidgetDict)

    expect(widgetStateDict.getState(widgetId1)).toEqual({ id: widgetId1 })
    expect(widgetStateDict.getState(widgetId2)).toEqual({ id: widgetId2 })
    expect(widgetStateDict.getState(widgetId3)).toEqual({ id: widgetId3 })
  })

  it("supplies WidgetStates with for active widgets based on input", () => {
    const widgetStateManager = new WidgetStateManager({
      sendRerunBackMsg: vi.fn(),
      formsDataChanged: vi.fn(),
    })

    widgetStateManager.setStringValue(
      { id: "widget1" },
      "foo",
      {
        fromUi: false,
      },
      undefined
    )
    widgetStateManager.setStringValue(
      { id: "widget2" },
      "bar",
      {
        fromUi: false,
      },
      undefined
    )

    const activeIds = new Set(["widget2"])
    const widgetStates = widgetStateManager.getActiveWidgetStates(activeIds)

    expect(widgetStates).toEqual({
      widgets: [
        {
          id: "widget2",
          stringValue: "bar",
        },
      ],
    })
  })
})


================================================
File: /frontend/lib/src/WidgetStateManager.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Draft, default as produce } from "immer"
import { Long, util } from "protobufjs"
import { Signal, SignalConnection } from "typed-signals"

import {
  isValidFormId,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"

import {
  DoubleArray,
  IArrowTable,
  IFileUploaderState,
  SInt64Array,
  StringArray,
  StringTriggerValue,
  Button as SubmitButtonProto,
  WidgetState,
  WidgetStates,
} from "./proto"

export interface Source {
  fromUi: boolean
}

/** Common widget protobuf fields that are used by the WidgetStateManager. */
export interface WidgetInfo {
  id: string
  formId?: string
}

/**
 * Immutable structure that exposes public data about all the forms in the app.
 * WidgetStateManager produces new instances of this type when forms data
 * changes.
 */
export interface FormsData {
  /** Forms that have unsubmitted changes. */
  readonly formsWithPendingChanges: Set<string>

  /** Forms that have in-progress file uploads. */
  readonly formsWithUploads: Set<string>

  /**
   * Mapping of formID:numberOfSubmitButtons. (Most forms will have only one,
   * but it's not an error to have multiple.)
   */
  readonly submitButtons: Map<string, Array<SubmitButtonProto>>
}

/** Create an empty FormsData instance. */
export function createFormsData(): FormsData {
  return {
    formsWithPendingChanges: new Set(),
    formsWithUploads: new Set(),
    submitButtons: new Map(),
  }
}

/**
 * A Dictionary that maps widgetID -> WidgetState, and provides some utility
 * functions.
 */
export class WidgetStateDict {
  private readonly widgetStates = new Map<string, WidgetState>()

  /**
   * Create a new WidgetState proto for the widget with the given ID,
   * overwriting any that currently exists.
   */
  public createState(widgetId: string): WidgetState {
    const state = new WidgetState({ id: widgetId })
    this.widgetStates.set(widgetId, state)
    return state
  }

  /** Return the WidgetState for the given widgetID if it exists. */
  public getState(widgetId: string): WidgetState | undefined {
    return this.widgetStates.get(widgetId)
  }

  /** Remove the WidgetState proto with the given id, if it exists. */
  public deleteState(widgetId: string): void {
    this.widgetStates.delete(widgetId)
  }

  /** Remove the state of widgets that are not contained in `activeIds`. */
  public removeInactive(activeIds: Set<string>): void {
    this.widgetStates.forEach((value, key) => {
      if (!activeIds.has(key)) {
        this.widgetStates.delete(key)
      }
    })
  }

  /** Remove all widget states. */
  public clear(): void {
    this.widgetStates.clear()
  }

  public get isEmpty(): boolean {
    return this.widgetStates.size === 0
  }

  public createWidgetStatesMsg(): WidgetStates {
    const msg = new WidgetStates()
    this.widgetStates.forEach(value => msg.widgets.push(value))
    return msg
  }

  /**
   * Copy the contents of another WidgetStateDict into this one, overwriting
   * any values with duplicate keys.
   */
  public copyFrom(other: WidgetStateDict): void {
    other.widgetStates.forEach((state, widgetId) => {
      this.widgetStates.set(widgetId, state)
    })
  }

  /** Call a function for each value in the dict. */
  public forEach(callbackfn: (value: WidgetState) => void): void {
    this.widgetStates.forEach(callbackfn)
  }
}

/** Stores private data about a single form. */
class FormState {
  public readonly widgetStates = new WidgetStateDict()

  /** True if the form was created with the clear_on_submit flag. */
  public clearOnSubmit = false

  /** True if the form was created with the enter_to_submit flag. */
  public enterToSubmit = true

  /** Signal emitted when the form is cleared. */
  public readonly formCleared = new Signal()

  /** True if the form has a non-empty WidgetStateDict. */
  public get hasPendingChanges(): boolean {
    return !this.widgetStates.isEmpty
  }
}

interface Props {
  /** Callback to deliver a message to the server */
  sendRerunBackMsg: (
    widgetStates: WidgetStates,
    fragmentId: string | undefined,
    pageScriptHash: string | undefined,
    isAutoRerun: boolean | undefined
  ) => void

  /**
   * Callback invoked whenever our FormsData changed. (Because FormsData
   * is immutable, any changes to it result in a new instance being created.)
   */
  formsDataChanged: (formsData: FormsData) => void
}

/**
 * Manages widget values, and sends widget update messages back to the server.
 */
export class WidgetStateManager {
  private readonly props: Props

  // Top-level widget state dictionary.
  private readonly widgetStates = new WidgetStateDict()

  // Internal state for each form we're managing.
  private readonly forms = new Map<string, FormState>()

  // External data about all forms.
  private formsData: FormsData

  // A dictionary that maps elementId -> element state keys -> element state values.
  // This is used to store frontend-only state for elements.
  // This state is not never sent to the server.
  private readonly elementStates = new Map<string, Map<string, any>>()

  constructor(props: Props) {
    this.props = props
    this.formsData = createFormsData()
  }

  /**
   * Register a function that will be called when the given form is cleared.
   * Returns an object that can be used to de-register the listener.
   */
  public addFormClearedListener(
    formId: string,
    listener: () => void
  ): SignalConnection {
    return this.getOrCreateFormState(formId).formCleared.connect(listener)
  }

  /**
   * Register a Form, and assign its clearOnSubmit & enterToSubmit values.
   * The `Form` element calls this when it's first mounted.
   */
  public setFormSubmitBehaviors(
    formId: string,
    clearOnSubmit: boolean,
    enterToSubmit = true
  ): void {
    const form = this.getOrCreateFormState(formId)
    form.clearOnSubmit = clearOnSubmit
    form.enterToSubmit = enterToSubmit
  }

  /**
   * Commit pending changes for widgets that belong to the given form,
   * and send a rerunBackMsg to the server.
   */
  public submitForm(
    formId: string,
    fragmentId: string | undefined,
    actualSubmitButton?: WidgetInfo
  ): void {
    if (!isValidFormId(formId)) {
      // This should never get thrown - only FormSubmitButton calls this
      // function.
      throw new Error(`invalid formID '${formId}'`)
    }

    const form = this.getOrCreateFormState(formId)

    const submitButtons = this.formsData.submitButtons.get(formId)

    let selectedSubmitButton

    if (actualSubmitButton !== undefined) {
      selectedSubmitButton = actualSubmitButton
    }
    // can have an empty list of submitButtons
    else if (submitButtons !== undefined && submitButtons.length > 0) {
      // click the first submit button. We can choose any so we just choose first.
      selectedSubmitButton = submitButtons[0]
    }

    if (selectedSubmitButton) {
      this.createWidgetState(selectedSubmitButton, {
        fromUi: true,
      }).triggerValue = true
    }

    // Copy the form's values into widgetStates, delete the form's pending
    // changes, and send our widgetStates back to the server.
    this.widgetStates.copyFrom(form.widgetStates)
    form.widgetStates.clear()

    this.sendUpdateWidgetsMessage(fragmentId)
    this.syncFormsWithPendingChanges()

    if (selectedSubmitButton) {
      this.deleteWidgetState(selectedSubmitButton.id)
    }

    // If the form has the clearOnSubmit flag, we emit a signal to all widgets
    // in the form. Each widget that handles this signal will reset to their
    // default values, and submit those new default values to the WidgetStateManager
    // in their signal handlers. (Because all of these widgets are in a form,
    // none of these value submissions will trigger re-run requests.)
    if (form.clearOnSubmit) {
      form.formCleared.emit()
    }
  }

  /* Sometimes users change an input field and directly click on a button - which uses the trigger value -
   * to trigger a rerun. We wrap the code that sends the trigger update in `setTimeout` so that trigger-based
   * updates will be executed at the end of JavaScript's event loop. Callbacks for other elements, for example,
   * the onBlur event of an input field, will be deterministically executed first in the event loop since they
   * were encountered first in the sequential execution and will be executed FIFO from the task queue.
   *
   * Returns a promise that is resolved as soon as the timeout was triggered, mainly to make this easier to test.
   * in our unit tests.
   */
  private setTriggerValueAtEndOfEventLoop(
    widget: WidgetInfo,
    source: Source,
    fragmentId: string | undefined
  ): Promise<void> {
    return new Promise(resolve => {
      setTimeout(() => {
        this.onWidgetValueChanged(widget.formId, source, fragmentId)
        this.deleteWidgetState(widget.id)
        resolve()
      }, 0)
    })
  }

  /**
   * Sets the string trigger value for the given widget ID to a string value,
   * sends a rerunScript message to the server, and then immediately unsets the
   * string trigger value to None/null.
   */
  public setStringTriggerValue(
    widget: WidgetInfo,
    value: string,
    source: Source,
    fragmentId: string | undefined
  ): Promise<void> {
    this.createWidgetState(widget, source).stringTriggerValue =
      new StringTriggerValue({ data: value })
    return this.setTriggerValueAtEndOfEventLoop(widget, source, fragmentId)
  }

  /**
   * Sets the trigger value for the given widget ID to true, sends a rerunScript message
   * to the server, and then immediately unsets the trigger value.
   */
  public setTriggerValue(
    widget: WidgetInfo,
    source: Source,
    fragmentId: string | undefined
  ): Promise<void> {
    this.createWidgetState(widget, source).triggerValue = true
    return this.setTriggerValueAtEndOfEventLoop(widget, source, fragmentId)
  }

  public getBoolValue(widget: WidgetInfo): boolean | undefined {
    const state = this.getWidgetState(widget)
    if (notNullOrUndefined(state) && state.value === "boolValue") {
      return state.boolValue as boolean
    }

    return undefined
  }

  public setBoolValue(
    widget: WidgetInfo,
    value: boolean,
    source: Source,
    fragmentId: string | undefined
  ): void {
    this.createWidgetState(widget, source).boolValue = value
    this.onWidgetValueChanged(widget.formId, source, fragmentId)
  }

  public getIntValue(widget: WidgetInfo): number | undefined {
    const state = this.getWidgetState(widget)
    if (notNullOrUndefined(state) && state.value === "intValue") {
      return requireNumberInt(state.intValue as number)
    }

    return undefined
  }

  public setIntValue(
    widget: WidgetInfo,
    value: number | null,
    source: Source,
    fragmentId: string | undefined
  ): void {
    this.createWidgetState(widget, source).intValue = value
    this.onWidgetValueChanged(widget.formId, source, fragmentId)
  }

  public getDoubleValue(widget: WidgetInfo): number | undefined {
    const state = this.getWidgetState(widget)
    if (notNullOrUndefined(state) && state.value === "doubleValue") {
      return state.doubleValue as number
    }

    return undefined
  }

  public setDoubleValue(
    widget: WidgetInfo,
    value: number | null,
    source: Source,
    fragmentId: string | undefined
  ): void {
    this.createWidgetState(widget, source).doubleValue = value
    this.onWidgetValueChanged(widget.formId, source, fragmentId)
  }

  public getStringValue(widget: WidgetInfo): string | undefined {
    const state = this.getWidgetState(widget)
    if (notNullOrUndefined(state) && state.value === "stringValue") {
      return state.stringValue as string
    }

    return undefined
  }

  public setStringValue(
    widget: WidgetInfo,
    value: string | null,
    source: Source,
    fragmentId: string | undefined
  ): void {
    this.createWidgetState(widget, source).stringValue = value
    this.onWidgetValueChanged(widget.formId, source, fragmentId)
  }

  public setStringArrayValue(
    widget: WidgetInfo,
    value: string[],
    source: Source,
    fragmentId: string | undefined
  ): void {
    this.createWidgetState(widget, source).stringArrayValue = new StringArray({
      data: value,
    })
    this.onWidgetValueChanged(widget.formId, source, fragmentId)
  }

  public getStringArrayValue(widget: WidgetInfo): string[] | undefined {
    const state = this.getWidgetState(widget)
    if (
      notNullOrUndefined(state) &&
      state.value === "stringArrayValue" &&
      notNullOrUndefined(state.stringArrayValue) &&
      notNullOrUndefined(state.stringArrayValue.data)
    ) {
      return state.stringArrayValue.data
    }

    return undefined
  }

  public getDoubleArrayValue(widget: WidgetInfo): number[] | undefined {
    const state = this.getWidgetState(widget)
    if (
      notNullOrUndefined(state) &&
      state.value === "doubleArrayValue" &&
      notNullOrUndefined(state.doubleArrayValue) &&
      notNullOrUndefined(state.doubleArrayValue.data)
    ) {
      return state.doubleArrayValue.data
    }

    return undefined
  }

  public setDoubleArrayValue(
    widget: WidgetInfo,
    value: number[],
    source: Source,
    fragmentId: string | undefined
  ): void {
    this.createWidgetState(widget, source).doubleArrayValue = new DoubleArray({
      data: value,
    })
    this.onWidgetValueChanged(widget.formId, source, fragmentId)
  }

  public getIntArrayValue(widget: WidgetInfo): number[] | undefined {
    const state = this.getWidgetState(widget)
    if (
      notNullOrUndefined(state) &&
      state.value === "intArrayValue" &&
      notNullOrUndefined(state.intArrayValue) &&
      notNullOrUndefined(state.intArrayValue.data)
    ) {
      return state.intArrayValue.data.map(requireNumberInt)
    }

    return undefined
  }

  public setIntArrayValue(
    widget: WidgetInfo,
    value: number[],
    source: Source,
    fragmentId: string | undefined
  ): void {
    this.createWidgetState(widget, source).intArrayValue = new SInt64Array({
      data: value,
    })
    this.onWidgetValueChanged(widget.formId, source, fragmentId)
  }

  public getJsonValue(widget: WidgetInfo): string | undefined {
    const state = this.getWidgetState(widget)
    if (notNullOrUndefined(state) && state.value === "jsonValue") {
      return state.jsonValue as string
    }

    return undefined
  }

  public setJsonValue(
    widget: WidgetInfo,
    value: any,
    source: Source,
    fragmentId: string | undefined
  ): void {
    this.createWidgetState(widget, source).jsonValue = JSON.stringify(value)
    this.onWidgetValueChanged(widget.formId, source, fragmentId)
  }

  public setArrowValue(
    widget: WidgetInfo,
    value: IArrowTable,
    source: Source,
    fragmentId: string | undefined
  ): void {
    this.createWidgetState(widget, source).arrowValue = value
    this.onWidgetValueChanged(widget.formId, source, fragmentId)
  }

  public getArrowValue(widget: WidgetInfo): IArrowTable | undefined {
    const state = this.getWidgetState(widget)
    if (
      notNullOrUndefined(state) &&
      state.value === "arrowValue" &&
      notNullOrUndefined(state.arrowValue)
    ) {
      return state.arrowValue
    }

    return undefined
  }

  public setBytesValue(
    widget: WidgetInfo,
    value: Uint8Array,
    source: Source,
    fragmentId: string | undefined
  ): void {
    this.createWidgetState(widget, source).bytesValue = value
    this.onWidgetValueChanged(widget.formId, source, fragmentId)
  }

  public getBytesValue(widget: WidgetInfo): Uint8Array | undefined {
    const state = this.getWidgetState(widget)
    if (notNullOrUndefined(state) && state.value === "bytesValue") {
      return state.bytesValue as Uint8Array
    }

    return undefined
  }

  public setFileUploaderStateValue(
    widget: WidgetInfo,
    value: IFileUploaderState,
    source: Source,
    fragmentId: string | undefined
  ): void {
    this.createWidgetState(widget, source).fileUploaderStateValue = value
    this.onWidgetValueChanged(widget.formId, source, fragmentId)
  }

  public getFileUploaderStateValue(
    widget: WidgetInfo
  ): IFileUploaderState | undefined {
    const state = this.getWidgetState(widget)
    if (
      notNullOrUndefined(state) &&
      state.value === "fileUploaderStateValue"
    ) {
      return state.fileUploaderStateValue as IFileUploaderState
    }

    return undefined
  }

  /**
   * Perform housekeeping every time a widget value changes.
   * - If the widget does not belong to a form, and the value update came from
   *   a user action, send the "updateWidgets" message
   * - If the widget belongs to a form, dispatch the "pendingFormsChanged"
   *   callback if needed.
   *
   * Called by every "setValue" function.
   */
  private onWidgetValueChanged(
    formId: string | undefined,
    source: Source,
    fragmentId: string | undefined
  ): void {
    if (isValidFormId(formId)) {
      this.syncFormsWithPendingChanges()
    } else if (source.fromUi) {
      this.sendUpdateWidgetsMessage(fragmentId)
    }
  }

  /**
   * Update FormsData.formsWithPendingChanges with the current set of forms
   * that have pending changes. This is called after widget values are updated.
   */
  private syncFormsWithPendingChanges(): void {
    const pendingFormIds = new Set<string>()
    this.forms.forEach((form, formId) => {
      if (form.hasPendingChanges) {
        pendingFormIds.add(formId)
      }
    })

    this.updateFormsData(draft => {
      draft.formsWithPendingChanges = pendingFormIds
    })
  }

  public sendUpdateWidgetsMessage(
    fragmentId: string | undefined,
    isAutoRerun: boolean | undefined = undefined
  ): void {
    this.props.sendRerunBackMsg(
      this.widgetStates.createWidgetStatesMsg(),
      fragmentId,
      undefined,
      isAutoRerun
    )
  }

  public getActiveWidgetStates(activeIds: Set<string>): WidgetStates {
    const msg = new WidgetStates()
    this.widgetStates.forEach(widgetState => {
      if (activeIds.has(widgetState.id)) {
        msg.widgets.push(widgetState)
      }
    })
    return msg
  }

  /**
   * Remove the state of widgets that are not contained in `activeIds`.
   * This is called when a script finishes running, so that we don't retain
   * data for widgets that have been removed from the app.
   */
  public removeInactive(activeIds: Set<string>): void {
    this.widgetStates.removeInactive(activeIds)
    this.forms.forEach(form => form.widgetStates.removeInactive(activeIds))
    this.elementStates.forEach((_, elementId) => {
      if (!activeIds.has(elementId)) {
        this.deleteElementState(elementId)
      }
    })
  }

  /**
   * Create and return a new WidgetState proto for the given widget ID,
   * overwriting any that currently exists. If the widget belongs to a form,
   * the WidgetState will be created inside the form's WidgetStateDict.
   */
  private createWidgetState(widget: WidgetInfo, source: Source): WidgetState {
    const addToForm = isValidFormId(widget.formId) && source.fromUi
    const widgetStateDict = addToForm
      ? this.getOrCreateFormState(widget.formId as string).widgetStates
      : this.widgetStates

    return widgetStateDict.createState(widget.id)
  }

  /**
   * Get the WidgetState proto for the given widget ID, if it exists.
   */
  private getWidgetState(widget: WidgetInfo): WidgetState | undefined {
    // If the widget belongs to a form, try its form value first.
    if (isValidFormId(widget.formId)) {
      const formState = this.forms
        .get(widget.formId)
        ?.widgetStates.getState(widget.id)

      if (notNullOrUndefined(formState)) {
        return formState
      }
    }

    return this.widgetStates.getState(widget.id)
  }

  /**
   * Remove the WidgetState proto with the given id, if it exists
   */
  private deleteWidgetState(widgetId: string): void {
    this.widgetStates.deleteState(widgetId)
  }

  /** Return the FormState for the given form. Create it if it doesn't exist. */
  private getOrCreateFormState(formId: string): FormState {
    let form = this.forms.get(formId)
    if (notNullOrUndefined(form)) {
      return form
    }

    form = new FormState()
    this.forms.set(formId, form)
    return form
  }

  /** Store the IDs of all forms with in-progress uploads. */
  public setFormsWithUploadsInProgress(formsWithUploads: Set<string>): void {
    this.updateFormsData(draft => {
      draft.formsWithUploads = formsWithUploads
    })
  }

  /**
   * Helper function to determine whether a form allows enter to submit
   * for input elements (st.number_input, st.text_input, etc.)
   * If in form, checks form's enterToSubmit paramf first, otherwise default
   * behavior: Must have 1st submit button enabled to allow
   */
  public allowFormEnterToSubmit(formId: string): boolean {
    // Don't allow if not in form
    if (!isValidFormId(formId)) return false

    // Check if user-set enterToSubmit param is false (in FormState)
    const form = this.forms.get(formId)
    if (form && !form.enterToSubmit) return false

    // Otherwise, use default behavior
    const submitButtons = this.formsData.submitButtons.get(formId)
    const firstSubmitButton = submitButtons?.[0]

    // If no submit buttons for the formId, invalid form
    if (!firstSubmitButton) return false

    // Allow form submit on enter as long as 1st submit button is not disabled
    return !firstSubmitButton.disabled
  }

  /**
   * Called by FormSubmitButton on creation. Add the SubmitButtonProto for
   * the given form and update FormsData.
   */
  public addSubmitButton(
    formId: string,
    submitButtonProto: SubmitButtonProto
  ): void {
    const submitButtons = this.formsData.submitButtons.get(formId)
    if (submitButtons === undefined) {
      this.setSubmitButtons(formId, [submitButtonProto])
    } else {
      const copySubmitButtons = Object.assign([], submitButtons)
      copySubmitButtons.push(submitButtonProto)
      this.setSubmitButtons(formId, copySubmitButtons)
    }
  }

  /**
   * Called by FormSubmitButton on creation. Remove the SubmitButtonProto for
   * the given form, and update FormsData.
   */
  public removeSubmitButton(
    formId: string,
    submitButtonProto: SubmitButtonProto
  ): void {
    const submitButtons = this.formsData.submitButtons.get(formId)
    if (submitButtons !== undefined) {
      const copySubmitButtons = Object.assign([], submitButtons)
      const index = copySubmitButtons.indexOf(submitButtonProto, 0)
      if (index > -1) {
        copySubmitButtons.splice(index, 1)
      }
      this.setSubmitButtons(formId, copySubmitButtons)
    }
  }

  private setSubmitButtons(
    formId: string,
    submitButtons: Array<SubmitButtonProto>
  ): void {
    if (submitButtons.length < 0) {
      throw new Error(
        `Bad submitButtons length ${submitButtons.length} (must be >= 0)`
      )
    }

    this.updateFormsData(draft => {
      draft.submitButtons.set(formId, submitButtons)
    })
  }

  /**
   * Produce a new FormsData with the given recipe, and fire off the
   * formsDataChanged callback with that new data.
   */
  private updateFormsData(recipe: (draft: Draft<FormsData>) => void): void {
    const newData = produce(this.formsData, recipe)
    if (this.formsData !== newData) {
      this.formsData = newData
      this.props.formsDataChanged(this.formsData)
    }
  }

  /**
   * Get the element state value for the given element ID and key, if it exists.
   * This is a frontend-only state that is never sent to the server.
   */
  public getElementState(elementId: string, key: string): any {
    return this.elementStates.get(elementId)?.get(key)
  }

  /**
   * Sets the state of an element identified by its ID and its key.
   * This is a frontend-only state that is never sent to the server.
   * It can be used to store element state to restore the state
   * of an element in situations where an element is removed and re-added.
   *
   * @param {string} elementId - The unique identifier of the element.
   * @param {string} key - The key to set
   * @param {any} value - The value to set for the element's state.
   * @returns {void}
   */
  public setElementState(elementId: string, key: string, value: any): void {
    if (!this.elementStates.has(elementId)) {
      this.elementStates.set(elementId, new Map<string, any>())
    }

    // It's expected here that there is always an initialized map for an elementId
    ;(this.elementStates.get(elementId) as Map<string, any>).set(key, value)
  }

  /**
   * Deletes the state associated with a specific element by ID. If a key is provided,
   * only the state corresponding to that key is removed. If no key is specified, all states
   * associated with the element ID are removed.
   */
  public deleteElementState(elementId: string, key?: string): void {
    if (notNullOrUndefined(key)) {
      this.elementStates.get(elementId)?.delete(key)
    } else {
      this.elementStates.delete(elementId)
    }
  }
}

/**
 * Coerce a `number | Long` to a `number`.
 *
 * Our "intValue" and "intArrayValue" widget protobuf fields represent their
 * values with sint64, because sint32 is too small to represent the full range
 * of JavaScript int values. Protobufjs uses `number | Long` to represent
 * sint64. However, we're never putting Longs *into* int and intArrays -
 * because none of our widgets use Longs - so we'll never get a Long back out.
 *
 * If the given value cannot be converted to `number` without a loss of
 * precision (which should not be possible!), throw an error instead.
 */
function requireNumberInt(value: number | Long): number {
  if (typeof value === "number") {
    return value
  }

  const longNumber = util.LongBits.from(value).toNumber()
  if (Number.isSafeInteger(longNumber)) {
    return longNumber
  }

  throw new Error(
    `value ${value} cannot be converted to number without a loss of precision!`
  )
}


================================================
File: /frontend/lib/src/baseconsts.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * When in dev mode, this is the port used to connect to the web server that is
 * serving the current page (i.e. the actual web page server, not the API
 * server, which in dev are actually different servers.)
 */
export const WWW_PORT_DEV = 3000

/**
 * This is the port used to connect to the server web socket when in dev.
 * IMPORTANT: If changed, also change config.py
 */
export const WEBSOCKET_PORT_DEV = 8501

/**
 * True when in development mode. We disable if we are testing to ensure
 * production conditions.
 */
export const IS_DEV_ENV = import.meta.env.MODE === "development"

/**
 * Parameters for our fetch() requests.
 */
export const FETCH_PARAMS: RequestInit = {
  redirect: "follow",
  credentials: "same-origin",
  mode: "cors",
}


================================================
File: /frontend/lib/src/declarations.d.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare module "@loaders.gl/core"

declare module "@loaders.gl/csv"

declare module "@loaders.gl/gltf"

declare module "native-file-system-adapter"

declare module "fzy.js" {
  export function score(pattern: string, subject: string): number
  export function positions(pattern: string, subject: string): Array<number>
  export function hasMatch(pattern: string, subject: string): boolean
}


================================================
File: /frontend/lib/src/index.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// These imports are each exported specifically in order to minimize public apis.
export { AppRoot, BlockNode, ElementNode } from "./AppNode"
export { IS_DEV_ENV, WEBSOCKET_PORT_DEV } from "./baseconsts"
export { default as VerticalBlock } from "./components/core/Block"
export type { BlockPropsWithoutWidth } from "./components/core/Block"
export { default as ElementNodeRenderer } from "./components/core/Block/ElementNodeRenderer"
export type { ElementNodeRendererProps } from "./components/core/Block/ElementNodeRenderer"
export { default as IsDialogContext } from "./components/core/IsDialogContext"
export { default as IsSidebarContext } from "./components/core/IsSidebarContext"
export { LibContext } from "./components/core/LibContext"
export type { LibConfig, LibContextProps } from "./components/core/LibContext"
export { PortalProvider } from "./components/core/Portal/PortalProvider"
export { default as ThemeProvider } from "./components/core/ThemeProvider"
export { default as AlertElement } from "./components/elements/AlertElement"
export { default as StreamlitSyntaxHighlighter } from "./components/elements/CodeBlock/StreamlitSyntaxHighlighter"
export { handleFavicon } from "./components/elements/Favicon"
export { default as TextElement } from "./components/elements/TextElement"
export {
  default as BaseButton,
  BaseButtonKind,
} from "./components/shared/BaseButton"
export { default as BaseColorPicker } from "./components/shared/BaseColorPicker"
export { default as UISelectbox } from "./components/shared/Dropdown/Selectbox"
export {
  DynamicIcon,
  EmojiIcon,
  default as Icon,
} from "./components/shared/Icon"
export {
  default as Modal,
  ModalBody,
  ModalButton,
  ModalFooter,
  ModalHeader,
} from "./components/shared/Modal"
export { CircularBuffer, Profiler } from "./components/shared/Profiler"
export { default as StreamlitMarkdown } from "./components/shared/StreamlitMarkdown"
export { Placement, default as Tooltip } from "./components/shared/Tooltip"
export { WindowDimensionsProvider } from "./components/shared/WindowDimensions/Provider"
export { ComponentRegistry } from "./components/widgets/CustomComponent"
export { Quiver } from "./dataframes/Quiver"
export { FileUploadClient } from "./FileUploadClient"
export { ForwardMsgCache } from "./ForwardMessageCache"
export { default as useScrollToBottom } from "./hooks/useScrollToBottom"
export { default as HostCommunicationManager } from "./hostComm"
export { HOST_COMM_VERSION } from "./hostComm/HostCommunicationManager"
export type {
  AppConfig,
  DeployedAppMetadata,
  IGuestToHostMessage,
  IHostConfigResponse,
  IMenuItem,
  IToolbarItem,
} from "./hostComm/types"
export {
  mockEndpoints,
  mockSessionInfo,
  mockSessionInfoProps,
} from "./mocks/mocks"
export { mockTheme } from "./mocks/mockTheme"
export { PerformanceEvents } from "./profiler/PerformanceEvents"
export * from "./proto"
export { RootStyleProvider } from "./RootStyleProvider"
export { ScriptRunState } from "./ScriptRunState"
export { SessionInfo } from "./SessionInfo"
export type {
  FileUploadClientConfig,
  StreamlitEndpoints,
} from "./StreamlitEndpoints"
export {
  customRenderLibContext,
  mockWindowLocation,
  render,
} from "./test_util"
export {
  AUTO_THEME_NAME,
  CUSTOM_THEME_NAME,
  baseTheme,
  createAutoTheme,
  createPresetThemes,
  createTheme,
  darkTheme,
  getCachedTheme,
  getDefaultTheme,
  getHostSpecifiedTheme,
  globalStyles,
  hasLightBackgroundColor,
  isPresetTheme,
  lightTheme,
  removeCachedTheme,
  setCachedTheme,
  toExportedTheme,
  toThemeInput,
} from "./theme"
export type { EmotionTheme, PresetThemeName, ThemeConfig } from "./theme"
export { default as emotionLightTheme } from "./theme/emotionLightTheme"
export { fonts, spacing } from "./theme/primitives"
export { ensureError } from "./util/ErrorHandling"
export { useIsOverflowing } from "./util/Hooks"
export { logAlways, logError, logMessage, logWarning } from "./util/log"
export { default as Resolver } from "./util/Resolver"
export { LocalStore, localStorageAvailable } from "./util/storageUtils"
export { Timer } from "./util/Timer"
export {
  buildHttpUri,
  buildWsUri,
  getPossibleBaseUris,
  makePath,
} from "./util/UriUtil"
export type { BaseUriParts } from "./util/UriUtil"
export {
  extractPageNameFromPathName,
  generateUID,
  getCookie,
  getElementId,
  getEmbeddingIdClassName,
  getIFrameEnclosingApp,
  hashString,
  isColoredLineDisplayed,
  isDarkThemeInQueryParams,
  isEmbed,
  isInChildFrame,
  isLightThemeInQueryParams,
  isNullOrUndefined,
  isPaddingDisplayed,
  isScrollingHidden,
  isToolbarDisplayed,
  makeElementWithInfoText,
  notNullOrUndefined,
  notUndefined,
  preserveEmbedQueryParams,
  setCookie,
} from "./util/utils"
export { WidgetStateManager, createFormsData } from "./WidgetStateManager"
export type { FormsData } from "./WidgetStateManager"
export {
  mark,
  measure,
  type StPerformanceMetric,
  type StPerformanceMark,
} from "./util/performance"


================================================
File: /frontend/lib/src/react-app-env.d.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/// <reference types="react-scripts" />


================================================
File: /frontend/lib/src/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledApp = styled.div(({ theme }) => ({
  position: "absolute",
  background: theme.colors.bgColor,
  color: theme.colors.bodyText,
  top: theme.spacing.none,
  left: theme.spacing.none,
  right: theme.spacing.none,
  bottom: theme.spacing.none,
  overflow: "hidden",
  "@media print": {
    float: "none",
    height: theme.sizes.full,
    position: "static",
    overflow: "visible",
  },
}))

/**
 * The glide-data-grid requires one root level portal element for rendering the cell overlays:
 * https://github.com/glideapps/glide-data-grid/blob/main/packages/core/API.md#htmlcss-prerequisites
 * This is added to the body in ThemedApp.
 */
export const StyledDataFrameOverlay = styled.div(({ theme }) => ({
  position: "fixed",
  top: 0,
  left: 0,
  zIndex: theme.zIndices.tablePortal,
  lineHeight: "100%",
}))


================================================
File: /frontend/lib/src/test_util.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/* eslint-disable import/no-extraneous-dependencies */
import React, { FC, PropsWithChildren, ReactElement } from "react"

import { Vector } from "apache-arrow"
import {
  render as reactTestingLibraryRender,
  RenderOptions,
  RenderResult,
} from "@testing-library/react"

/* eslint-enable */
import ThemeProvider from "./components/core/ThemeProvider"
import { baseTheme } from "./theme"
import { mockTheme } from "./mocks/mockTheme"
import { LibContext, LibContextProps } from "./components/core/LibContext"
import { WindowDimensionsProvider } from "./components/shared/WindowDimensions/Provider"

export const TestAppWrapper: FC<PropsWithChildren> = ({ children }) => {
  return (
    <ThemeProvider theme={mockTheme.emotion}>
      <WindowDimensionsProvider>{children}</WindowDimensionsProvider>
    </ThemeProvider>
  )
}

/**
 * Use react-testing-library to render a ReactElement. The element will be
 * wrapped in our ThemeProvider.
 */
export function render(
  ui: ReactElement,
  options?: Omit<RenderOptions, "queries">
): RenderResult {
  return reactTestingLibraryRender(ui, {
    wrapper: ({ children }) => <TestAppWrapper>{children}</TestAppWrapper>,
    ...options,
    // TODO: Remove this to have RTL run on React 18
    // react-18-upgrade
    legacyRoot: true,
  })
}

export function mockWindowLocation(hostname: string): void {
  // Mock window.location by creating a new object
  // Source: https://www.benmvp.com/blog/mocking-window-location-methods-jest-jsdom/
  // @ts-expect-error
  delete window.location

  // @ts-expect-error
  window.location = {
    assign: vi.fn(),
    hostname: hostname,
  }
}

/**
 * Use react-testing-library to render a ReactElement. The element will be
 * wrapped in our LibContext.Provider.
 */
export const customRenderLibContext = (
  component: ReactElement,
  overrideLibContextProps: Partial<LibContextProps>
): RenderResult => {
  const defaultLibContextProps = {
    isFullScreen: false,
    setFullScreen: vi.fn(),
    addScriptFinishedHandler: vi.fn(),
    removeScriptFinishedHandler: vi.fn(),
    activeTheme: baseTheme,
    setTheme: vi.fn(),
    availableThemes: [],
    addThemes: vi.fn(),
    onPageChange: vi.fn(),
    currentPageScriptHash: "",
    libConfig: {},
    fragmentIdsThisRun: [],
    locale: "en-US",
  }

  return reactTestingLibraryRender(component, {
    wrapper: ({ children }) => (
      <ThemeProvider theme={baseTheme.emotion}>
        <WindowDimensionsProvider>
          <LibContext.Provider
            value={{ ...defaultLibContextProps, ...overrideLibContextProps }}
          >
            {children}
          </LibContext.Provider>
        </WindowDimensionsProvider>
      </ThemeProvider>
    ),
  })
}

export function arrayFromVector(vector: any): any {
  if (Array.isArray(vector)) {
    return vector.map(arrayFromVector)
  }

  if (vector instanceof Vector) {
    return Array.from(vector)
  }

  return vector
}


================================================
File: /frontend/lib/src/urls.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export const STREAMLIT_HOME_URL = "https://streamlit.io"
export const DEPLOY_URL = "https://share.streamlit.io/deploy"
export const STREAMLIT_CLOUD_URL = "https://streamlit.io/cloud"
export const ONLINE_DOCS_URL = "https://docs.streamlit.io"
export const COMMUNITY_URL = "https://discuss.streamlit.io"

/** The URL customers are directed to for troubleshooting components. */
export const COMPONENT_DEVELOPER_URL =
  "https://docs.streamlit.io/develop/concepts/custom-components"

/** The URL customers are directed to for troubleshooting camera permissions. */
export const CAMERA_PERMISSION_URL =
  "https://docs.streamlit.io/knowledge-base/using-streamlit/enable-camera"

