    "&:active,&:visited,&:hover": {
      textDecoration: "none",
    },

    "&:focus": {
      outline: "none",
    },

    "&:focus-visible": {
      backgroundColor: theme.colors.darkenedBgMix15,
    },

    [`@media print`]: {
      paddingLeft: theme.spacing.none,
    },

    ...(disabled
      ? {
          borderColor: theme.colors.borderColor,
          backgroundColor: theme.colors.transparent,
          color: theme.colors.fadedText40,
          cursor: "not-allowed",
          "&:hover": {
            color: theme.colors.fadedText40,
            backgroundColor: theme.colors.transparent,
          },
        }
      : {}),
  })
)

export interface StyledNavLinkTextProps {
  disabled: boolean
}

export const StyledNavLinkText = styled.span<StyledNavLinkTextProps>(
  ({ disabled, theme }) => ({
    color: theme.colors.bodyText,
    overflow: "hidden",
    whiteSpace: "nowrap",
    textOverflow: "ellipsis",
    display: "table-cell",

    ...(disabled
      ? {
          borderColor: theme.colors.borderColor,
          backgroundColor: theme.colors.transparent,
          color: theme.colors.fadedText40,
          cursor: "not-allowed",
        }
      : {}),
  })
)


================================================
File: /frontend/lib/src/components/elements/Particles/Particles.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC } from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import Particles, { ParticleProps, Props } from "./Particles"

const DummyParticle: FC<React.PropsWithChildren<ParticleProps>> = () => (
  <span />
)

const getProps = (): Props => ({
  className: "particles",
  numParticles: 10,
  numParticleTypes: 5,
  ParticleComponent: DummyParticle,
  scriptRunId: "51522269",
})

describe("Particles element", () => {
  vi.useFakeTimers()

  beforeEach(() => {
    vi.clearAllMocks()
    vi.clearAllTimers()
  })

  it("renders without crashing", () => {
    const props = getProps()
    render(<Particles {...props} />)

    const particleElement = screen.getByTestId("particles")
    expect(particleElement).toBeInTheDocument()
    expect(particleElement).toHaveClass("particles")

    // eslint-disable-next-line testing-library/no-node-access
    const particleComponents = particleElement.children
    expect(particleComponents.length).toBe(10)
  })
})


================================================
File: /frontend/lib/src/components/elements/Particles/Particles.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, memo } from "react"

import range from "lodash/range"

import { StyledParticles } from "./styled-components"

export interface ParticleProps {
  particleType: number
}

export interface Props {
  className: string
  scriptRunId: string
  numParticles: number
  numParticleTypes: number
  ParticleComponent: FC<React.PropsWithChildren<ParticleProps>>
}

const Particles: FC<React.PropsWithChildren<Props>> = ({
  className,
  scriptRunId,
  numParticles,
  numParticleTypes,
  ParticleComponent,
}: Props) => (
  // Keys should be unique each time, so React replaces the images in the DOM and their animations
  // actually rerun.
  <StyledParticles className={className} data-testid={className}>
    {range(numParticles).map(i => {
      const randNum = Math.floor(Math.random() * numParticleTypes)

      return <ParticleComponent key={scriptRunId + i} particleType={randNum} />
    })}
  </StyledParticles>
)

export default memo(Particles)


================================================
File: /frontend/lib/src/components/elements/Particles/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Particles"


================================================
File: /frontend/lib/src/components/elements/Particles/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledParticles = styled.div({
  "@media print": {
    display: "none",
  },
})


================================================
File: /frontend/lib/src/components/elements/PlotlyChart/CustomTheme.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import merge from "lodash/merge"

import {
  convertRemToPx,
  EmotionTheme,
  getBlue80,
  getCategoricalColorsArray,
  getDecreasingRed,
  getDivergingColorsArray,
  getGray30,
  getGray70,
  getGray90,
  getIncreasingGreen,
  getSequentialColorsArray,
} from "@streamlit/lib/src/theme"
import { ensureError } from "@streamlit/lib/src/util/ErrorHandling"
import { logError } from "@streamlit/lib/src/util/log"

/**
 * This applies general layout changes to things such as x axis,
 * y axis, legends, titles, grid changes, background, etc.
 * @param layout - spec.layout.template.layout
 * @param theme - Theme from useTheme()
 */
export function applyStreamlitThemeTemplateLayout(
  layout: any,
  theme: EmotionTheme
): void {
  const { genericFonts, colors, fontSizes } = theme

  const streamlitTheme = {
    font: {
      color: getGray70(theme),
      family: genericFonts.bodyFont,
      size: fontSizes.twoSmPx,
    },
    title: {
      color: colors.headingColor,
      subtitleColor: colors.bodyText,
      font: {
        family: genericFonts.headingFont,
        size: convertRemToPx(fontSizes.md),
        color: colors.headingColor,
      },
      pad: {
        l: convertRemToPx(theme.spacing.twoXS),
      },
      xanchor: "left",
      x: 0,
    },
    legend: {
      title: {
        font: {
          size: fontSizes.twoSmPx,
          color: getGray70(theme),
        },
        side: "top",
      },
      valign: "top",
      bordercolor: colors.transparent,
      borderwidth: 0,
      font: {
        size: fontSizes.twoSmPx,
        color: getGray90(theme),
      },
    },
    paper_bgcolor: colors.bgColor,
    plot_bgcolor: colors.bgColor,
    yaxis: {
      ticklabelposition: "outside",
      zerolinecolor: getGray30(theme),
      title: {
        font: {
          color: getGray70(theme),
          size: fontSizes.smPx,
        },
        standoff: convertRemToPx(theme.spacing.twoXL),
      },
      tickcolor: getGray30(theme),
      tickfont: {
        color: getGray70(theme),
        size: fontSizes.twoSmPx,
      },
      gridcolor: getGray30(theme),
      minor: {
        gridcolor: getGray30(theme),
      },
      automargin: true,
    },
    xaxis: {
      zerolinecolor: getGray30(theme),
      gridcolor: getGray30(theme),
      showgrid: false,
      tickfont: {
        color: getGray70(theme),
        size: fontSizes.twoSmPx,
      },
      tickcolor: getGray30(theme),
      title: {
        font: {
          color: getGray70(theme),
          size: fontSizes.smPx,
        },
        standoff: convertRemToPx(theme.spacing.xl),
      },
      minor: {
        gridcolor: getGray30(theme),
      },
      zeroline: false,
      automargin: true,
      rangeselector: {
        bgcolor: colors.bgColor,
        bordercolor: getGray30(theme),
        // eslint-disable-next-line streamlit-custom/no-hardcoded-theme-values
        borderwidth: 1,
        x: 0,
      },
    },
    margin: {
      pad: convertRemToPx(theme.spacing.sm),
      r: 0,
      l: 0,
    },
    hoverlabel: {
      bgcolor: colors.bgColor,
      bordercolor: colors.borderColor,
      font: {
        color: getGray70(theme),
        family: genericFonts.bodyFont,
        size: fontSizes.twoSmPx,
      },
    },
    coloraxis: {
      colorbar: {
        thickness: 16,
        xpad: convertRemToPx(theme.spacing.twoXL),
        ticklabelposition: "outside",
        outlinecolor: colors.transparent,
        outlinewidth: 8,
        len: 0.75,
        y: 0.5745,
        title: {
          font: {
            color: getGray70(theme),
            size: fontSizes.smPx,
          },
        },
        tickfont: {
          color: getGray70(theme),
          size: fontSizes.twoSmPx,
        },
      },
    },
    // specifically for the ternary graph
    ternary: {
      gridcolor: getGray70(theme),
      bgcolor: colors.bgColor,
      title: {
        font: {
          family: genericFonts.bodyFont,
          size: fontSizes.smPx,
        },
      },
      color: getGray70(theme),
      aaxis: {
        gridcolor: getGray70(theme),
        linecolor: getGray70(theme),
        tickfont: {
          family: genericFonts.bodyFont,
          size: fontSizes.twoSmPx,
        },
      },
      baxis: {
        linecolor: getGray70(theme),
        gridcolor: getGray70(theme),
        tickfont: {
          family: genericFonts.bodyFont,
          size: fontSizes.twoSmPx,
        },
      },
      caxis: {
        linecolor: getGray70(theme),
        gridcolor: getGray70(theme),
        tickfont: {
          family: genericFonts.bodyFont,
          size: fontSizes.twoSmPx,
        },
      },
    },
  }

  merge(layout, streamlitTheme)
}

/**
 * Replace the colors that we are using from streamlit_plotly_theme.py.
 * This is done so that we change colors based on the background color
 * as the backend has no idea of the background color.
 * @param spec the spec that we want to update
 * @param theme
 * @param elementTheme element.theme
 * @returns the updated spec with the correct theme colors
 */
function replaceCategoricalColors(
  spec: string,
  theme: EmotionTheme,
  elementTheme: string
): string {
  // All the placeholder constants defined here are matching the placeholders in the python implementation.
  const CATEGORY_0 = "#000001"
  const CATEGORY_1 = "#000002"
  const CATEGORY_2 = "#000003"
  const CATEGORY_3 = "#000004"
  const CATEGORY_4 = "#000005"
  const CATEGORY_5 = "#000006"
  const CATEGORY_6 = "#000007"
  const CATEGORY_7 = "#000008"
  const CATEGORY_8 = "#000009"
  const CATEGORY_9 = "#000010"

  if (elementTheme === "streamlit") {
    const categoryColors = getCategoricalColorsArray(theme)
    spec = spec.replaceAll(CATEGORY_0, categoryColors[0])
    spec = spec.replaceAll(CATEGORY_1, categoryColors[1])
    spec = spec.replaceAll(CATEGORY_2, categoryColors[2])
    spec = spec.replaceAll(CATEGORY_3, categoryColors[3])
    spec = spec.replaceAll(CATEGORY_4, categoryColors[4])
    spec = spec.replaceAll(CATEGORY_5, categoryColors[5])
    spec = spec.replaceAll(CATEGORY_6, categoryColors[6])
    spec = spec.replaceAll(CATEGORY_7, categoryColors[7])
    spec = spec.replaceAll(CATEGORY_8, categoryColors[8])
    spec = spec.replaceAll(CATEGORY_9, categoryColors[9])
  } else {
    // Default plotly colors
    spec = spec.replaceAll(CATEGORY_0, "#636efa")
    spec = spec.replaceAll(CATEGORY_1, "#EF553B")
    spec = spec.replaceAll(CATEGORY_2, "#00cc96")
    spec = spec.replaceAll(CATEGORY_3, "#ab63fa")
    spec = spec.replaceAll(CATEGORY_4, "#FFA15A")
    spec = spec.replaceAll(CATEGORY_5, "#19d3f3")
    spec = spec.replaceAll(CATEGORY_6, "#FF6692")
    spec = spec.replaceAll(CATEGORY_7, "#B6E880")
    spec = spec.replaceAll(CATEGORY_8, "#FF97FF")
    spec = spec.replaceAll(CATEGORY_9, "#FECB52")
  }
  return spec
}

function replaceSequentialColors(
  spec: string,
  theme: EmotionTheme,
  elementTheme: string
): string {
  // All the placeholder constants defined here are matching the placeholders in the python implementation.
  const SEQUENTIAL_0 = "#000011"
  const SEQUENTIAL_1 = "#000012"
  const SEQUENTIAL_2 = "#000013"
  const SEQUENTIAL_3 = "#000014"
  const SEQUENTIAL_4 = "#000015"
  const SEQUENTIAL_5 = "#000016"
  const SEQUENTIAL_6 = "#000017"
  const SEQUENTIAL_7 = "#000018"
  const SEQUENTIAL_8 = "#000019"
  const SEQUENTIAL_9 = "#000020"

  if (elementTheme === "streamlit") {
    const sequentialColors = getSequentialColorsArray(theme)
    spec = spec.replaceAll(SEQUENTIAL_0, sequentialColors[0])
    spec = spec.replaceAll(SEQUENTIAL_1, sequentialColors[1])
    spec = spec.replaceAll(SEQUENTIAL_2, sequentialColors[2])
    spec = spec.replaceAll(SEQUENTIAL_3, sequentialColors[3])
    spec = spec.replaceAll(SEQUENTIAL_4, sequentialColors[4])
    spec = spec.replaceAll(SEQUENTIAL_5, sequentialColors[5])
    spec = spec.replaceAll(SEQUENTIAL_6, sequentialColors[6])
    spec = spec.replaceAll(SEQUENTIAL_7, sequentialColors[7])
    spec = spec.replaceAll(SEQUENTIAL_8, sequentialColors[8])
    spec = spec.replaceAll(SEQUENTIAL_9, sequentialColors[9])
  } else {
    // Default plotly colors
    spec = spec.replaceAll(SEQUENTIAL_0, "#0d0887")
    spec = spec.replaceAll(SEQUENTIAL_1, "#46039f")
    spec = spec.replaceAll(SEQUENTIAL_2, "#7201a8")
    spec = spec.replaceAll(SEQUENTIAL_3, "#9c179e")
    spec = spec.replaceAll(SEQUENTIAL_4, "#bd3786")
    spec = spec.replaceAll(SEQUENTIAL_5, "#d8576b")
    spec = spec.replaceAll(SEQUENTIAL_6, "#ed7953")
    spec = spec.replaceAll(SEQUENTIAL_7, "#fb9f3a")
    spec = spec.replaceAll(SEQUENTIAL_8, "#fdca26")
    spec = spec.replaceAll(SEQUENTIAL_9, "#f0f921")
  }
  return spec
}

function replaceDivergingColors(
  spec: string,
  theme: EmotionTheme,
  elementTheme: string
): string {
  // All the placeholder constants defined here are matching the placeholders in the python implementation.
  const DIVERGING_0 = "#000021"
  const DIVERGING_1 = "#000022"
  const DIVERGING_2 = "#000023"
  const DIVERGING_3 = "#000024"
  const DIVERGING_4 = "#000025"
  const DIVERGING_5 = "#000026"
  const DIVERGING_6 = "#000027"
  const DIVERGING_7 = "#000028"
  const DIVERGING_8 = "#000029"
  const DIVERGING_9 = "#000030"
  const DIVERGING_10 = "#000031"

  if (elementTheme === "streamlit") {
    const divergingColors = getDivergingColorsArray(theme)
    spec = spec.replaceAll(DIVERGING_0, divergingColors[0])
    spec = spec.replaceAll(DIVERGING_1, divergingColors[1])
    spec = spec.replaceAll(DIVERGING_2, divergingColors[2])
    spec = spec.replaceAll(DIVERGING_3, divergingColors[3])
    spec = spec.replaceAll(DIVERGING_4, divergingColors[4])
    spec = spec.replaceAll(DIVERGING_5, divergingColors[5])
    spec = spec.replaceAll(DIVERGING_6, divergingColors[6])
    spec = spec.replaceAll(DIVERGING_7, divergingColors[7])
    spec = spec.replaceAll(DIVERGING_8, divergingColors[8])
    spec = spec.replaceAll(DIVERGING_9, divergingColors[9])
    spec = spec.replaceAll(DIVERGING_10, divergingColors[10])
  } else {
    // Default plotly colors
    spec = spec.replaceAll(DIVERGING_0, "#8e0152")
    spec = spec.replaceAll(DIVERGING_1, "#c51b7d")
    spec = spec.replaceAll(DIVERGING_2, "#de77ae")
    spec = spec.replaceAll(DIVERGING_3, "#f1b6da")
    spec = spec.replaceAll(DIVERGING_4, "#fde0ef")
    spec = spec.replaceAll(DIVERGING_5, "#f7f7f7")
    spec = spec.replaceAll(DIVERGING_6, "#e6f5d0")
    spec = spec.replaceAll(DIVERGING_7, "#b8e186")
    spec = spec.replaceAll(DIVERGING_8, "#7fbc41")
    spec = spec.replaceAll(DIVERGING_9, "#4d9221")
    spec = spec.replaceAll(DIVERGING_10, "#276419")
  }
  return spec
}

/**
 * Because Template.layout doesn't affect the go(plotly.graph_objects) graphs,
 * we use this method to specifically replace these graph properties.
 * */
function replaceGOSpecificColors(spec: string, theme: EmotionTheme): string {
  // All the placeholder constants defined here are matching the placeholders in the python implementation.
  const INCREASING = "#000032"
  const DECREASING = "#000033"
  const TOTAL = "#000034"

  const GRAY_30 = "#000035"
  const GRAY_70 = "#000036"
  const GRAY_90 = "#000037"
  const BG_COLOR = "#000038"
  const FADED_TEXT_05 = "#000039"
  const BG_MIX = "#000040"

  spec = spec.replaceAll(INCREASING, getIncreasingGreen(theme))
  spec = spec.replaceAll(DECREASING, getDecreasingRed(theme))
  spec = spec.replaceAll(TOTAL, getBlue80(theme))

  spec = spec.replaceAll(GRAY_30, getGray30(theme))
  spec = spec.replaceAll(GRAY_70, getGray70(theme))
  spec = spec.replaceAll(GRAY_90, getGray90(theme))

  spec = spec.replaceAll(BG_COLOR, theme.colors.bgColor)
  spec = spec.replaceAll(FADED_TEXT_05, theme.colors.fadedText05)
  spec = spec.replaceAll(BG_MIX, theme.colors.bgMix)
  return spec
}

export function replaceTemporaryColors(
  spec: string,
  theme: EmotionTheme,
  elementTheme: string
): string {
  spec = replaceGOSpecificColors(spec, theme)
  spec = replaceCategoricalColors(spec, theme, elementTheme)
  spec = replaceSequentialColors(spec, theme, elementTheme)
  spec = replaceDivergingColors(spec, theme, elementTheme)
  return spec
}

/**
 * Applies the Streamlit theme by overriding properties in
 * spec.data, spec.layout.template.data, and spec.layout.template.layout
 * @param spec - spec
 */
export function applyStreamlitTheme(spec: any, theme: EmotionTheme): void {
  try {
    applyStreamlitThemeTemplateLayout(spec.layout.template.layout, theme)
  } catch (e) {
    const err = ensureError(e)
    logError(err)
  }
  if ("title" in spec.layout) {
    spec.layout.title = merge(spec.layout.title, {
      text: `<b>${spec.layout.title.text}</b>`,
    })
  }
}

/**
 * Apply minimum changes to graph to fit streamlit
 * @param layout - spec.layout
 * @param theme - theme from useTheme()
 * @returns modified spec.layout
 */
export function layoutWithThemeDefaults(
  layout: any,
  theme: EmotionTheme
): any {
  const { colors, genericFonts } = theme

  const themeDefaults = {
    font: {
      color: colors.bodyText,
      family: genericFonts.bodyFont,
    },
    paper_bgcolor: colors.bgColor,
    plot_bgcolor: colors.secondaryBg,
  }

  // Fill in theme defaults where the user didn't specify layout options.
  return {
    ...layout,
    font: {
      ...themeDefaults.font,
      ...layout.font,
    },
    paper_bgcolor: layout.paper_bgcolor || themeDefaults.paper_bgcolor,
    plot_bgcolor: layout.plot_bgcolor || themeDefaults.plot_bgcolor,
  }
}


================================================
File: /frontend/lib/src/components/elements/PlotlyChart/PlotlyChart.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { PlotlyChart as PlotlyChartProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import { mockTheme } from "@streamlit/lib/src/mocks/mockTheme"

import { applyStreamlitTheme, layoutWithThemeDefaults } from "./CustomTheme"
import {
  applyTheming,
  handleSelection,
  parseBoxSelection,
  parseLassoPath,
  sendEmptySelection,
} from "./PlotlyChart"

vi.mock("./CustomTheme", () => ({
  replaceTemporaryColors: vi.fn().mockReturnValue("{}"),
  applyStreamlitTheme: vi.fn(),
  layoutWithThemeDefaults: vi.fn().mockReturnValue({}),
}))

/**
 * PlotlyChart.test.tsx does not contain any React-testing-library tests because Plotly doesn't support it
 * https://github.com/plotly/react-plotly.js/issues/176
 */

describe("parsePlotlySelections", () => {
  describe("parseLassoPath", () => {
    it("parses a simple lasso path string into x and y coordinates", () => {
      const pathData = "M100,150L200,250L300,350Z"
      const result = parseLassoPath(pathData)
      expect(result).toEqual({
        x: [100, 200, 300],
        y: [150, 250, 350],
      })
    })

    it("does not error with an empty string", () => {
      const result = parseLassoPath("")
      expect(result).toEqual({
        x: [],
        y: [],
      })
    })

    it("handles path with only one point", () => {
      const pathData = "M100,150Z"
      const result = parseLassoPath(pathData)
      expect(result).toEqual({
        x: [100],
        y: [150],
      })
    })
  })

  describe("parseBoxSelection", () => {
    it("parses a box selection into x and y ranges", () => {
      const selection = { x0: 100, y0: 150, x1: 200, y1: 250 }
      const result = parseBoxSelection(selection)
      expect(result).toEqual({
        x: [100, 200],
        y: [150, 250],
      })
    })

    it("returns an object of empty x and y", () => {
      const selection = {}
      const result = parseBoxSelection(selection)
      expect(result).toEqual({
        x: [],
        y: [],
      })
    })
  })
})

const getWidgetMgr = (): WidgetStateManager => {
  const sendRerunBackMsg = vi.fn()
  const formsDataChanged = vi.fn()
  return new WidgetStateManager({
    sendRerunBackMsg,
    formsDataChanged,
  })
}

describe("sendEmptySelection", () => {
  it("sends a rerun msg if widget_state is empty", () => {
    const widgetMgr = getWidgetMgr()
    vi.spyOn(widgetMgr, "setStringValue")

    sendEmptySelection(
      widgetMgr,
      { id: "plotly_chart" } as PlotlyChartProto,
      undefined
    )

    expect(widgetMgr.setStringValue).toHaveBeenCalledTimes(1)
  })

  it("does not send a rerun msg if widget_state is empty", () => {
    const widgetMgr = getWidgetMgr()
    vi.spyOn(widgetMgr, "setStringValue")

    const plotlyProto = { id: "plotly_chart" } as PlotlyChartProto

    widgetMgr.setStringValue(
      plotlyProto,
      '{"selection":{"points":[],"point_indices":[],"box":[],"lasso":[]}}',
      { fromUi: true },
      undefined
    )

    sendEmptySelection(
      widgetMgr,
      { id: "plotly_chart" } as PlotlyChartProto,
      undefined
    )

    // setStringValue is not called again
    expect(widgetMgr.setStringValue).toHaveBeenCalledTimes(1)
  })
})

describe("handleSelection", () => {
  const mockFragmentId = "testFragment"
  const proto = {
    id: "plotly_chart",
    selectionMode: [0, 1, 2],
  } as PlotlyChartProto

  it("should return early if no event is provided", () => {
    const widgetMgr = getWidgetMgr()
    vi.spyOn(widgetMgr, "setStringValue")

    // @ts-expect-error
    handleSelection(undefined, widgetMgr, proto, mockFragmentId)
    expect(widgetMgr.setStringValue).not.toHaveBeenCalled()
  })

  it("should handle an event with no points or selections", () => {
    const event = { points: undefined, selections: undefined } as any
    const widgetMgr = getWidgetMgr()

    vi.spyOn(widgetMgr, "setStringValue")

    handleSelection(event, widgetMgr, proto, mockFragmentId)
    expect(widgetMgr.setStringValue).toHaveBeenCalledTimes(1)
  })

  it("should process events with points correctly", () => {
    const event = {
      points: [
        { pointIndex: 1, data: { legendgroup: "group1" }, pointIndices: [1] },
      ],
    } as any
    const widgetMgr = getWidgetMgr()

    vi.spyOn(widgetMgr, "setStringValue")

    handleSelection(event, widgetMgr, proto, mockFragmentId)
    expect(widgetMgr.setStringValue).toHaveBeenCalledWith(
      { id: "plotly_chart", selectionMode: [0, 1, 2] },
      '{"selection":{"points":[{"point_index":1,"point_indices":[1],"legendgroup":"group1"}],"point_indices":[1],"box":[],"lasso":[]}}',
      { fromUi: true },
      "testFragment"
    )
  })

  it("should process box selections correctly", () => {
    const event = {
      selections: [
        {
          type: "rect",
          xref: "x",
          yref: "y",
          x0: "0",
          x1: "1",
          y0: "0",
          y1: "1",
        },
      ],
    } as any
    const widgetMgr = getWidgetMgr()

    vi.spyOn(widgetMgr, "setStringValue")

    handleSelection(event, widgetMgr, proto, undefined)
    expect(widgetMgr.setStringValue).toHaveBeenCalledWith(
      { id: "plotly_chart", selectionMode: [0, 1, 2] },
      '{"selection":{"points":[],"point_indices":[],"box":[{"xref":"x","yref":"y","x":["0","1"],"y":["0","1"]}],"lasso":[]}}',
      { fromUi: true },
      undefined
    )
  })

  it("should process lasso selections correctly", () => {
    const event = {
      selections: [
        { type: "path", xref: "x", yref: "y", path: "M4.0,8.0L4.0,7.8Z" },
      ],
    } as any
    const widgetMgr = getWidgetMgr()

    vi.spyOn(widgetMgr, "setStringValue")

    handleSelection(event, widgetMgr, proto, mockFragmentId)
    expect(widgetMgr.setStringValue).toHaveBeenCalledWith(
      { id: "plotly_chart", selectionMode: [0, 1, 2] },
      '{"selection":{"points":[],"point_indices":[],"box":[],"lasso":[{"xref":"x","yref":"y","x":[4,4],"y":[8,7.8]}]}}',
      { fromUi: true },
      "testFragment"
    )
  })

  it("should not rerun if lasso selection is present but has no lasso selection mode", () => {
    const event = {
      selections: [
        { type: "path", xref: "x", yref: "y", path: "M4.0,8.0L4.0,7.8Z" },
      ],
    } as any
    const widgetMgr = getWidgetMgr()

    vi.spyOn(widgetMgr, "setStringValue")

    handleSelection(
      event,
      widgetMgr,
      // @ts-expect-error
      { ...proto, selectionMode: [] },
      mockFragmentId
    )
    expect(widgetMgr.setStringValue).not.toHaveBeenCalled()
  })

  it("should not rerun if box selection is present but has no box selection mode", () => {
    const event = {
      selections: [
        {
          type: "rect",
          xref: "x",
          yref: "y",
          x0: "0",
          x1: "1",
          y0: "0",
          y1: "1",
        },
      ],
    } as any
    const widgetMgr = getWidgetMgr()

    vi.spyOn(widgetMgr, "setStringValue")

    handleSelection(
      event,
      widgetMgr,
      // @ts-expect-error
      { ...proto, selectionMode: [] },
      mockFragmentId
    )
    expect(widgetMgr.setStringValue).not.toHaveBeenCalled()
  })

  it("should not rerun if the return value is the same", () => {
    const event = {
      points: [],
      selections: [],
    } as any
    const widgetMgr = getWidgetMgr()

    vi.spyOn(widgetMgr, "setStringValue")

    widgetMgr.setStringValue(
      proto,
      '{"selection":{"points":[],"point_indices":[],"box":[],"lasso":[]}}',
      { fromUi: true },
      undefined
    )

    handleSelection(event, widgetMgr, proto, mockFragmentId)
    expect(widgetMgr.setStringValue).toHaveBeenCalledTimes(1)
  })

  it('should rerun if there is a lasso select and a box select when selection_mode=["box", "lasso"]', () => {
    const boxEvent = {
      points: [
        {
          pointIndex: 0,
          data: { legendgroup: "group2" },
          pointIndices: [0],
          x: 0,
          y: 0,
        },
      ],
      selections: [
        {
          type: "rect",
          xref: "x",
          yref: "y",
          x0: "0",
          x1: "1",
          y0: "0",
          y1: "1",
        },
      ],
    } as any

    const widgetMgr = getWidgetMgr()

    vi.spyOn(widgetMgr, "setStringValue")
    handleSelection(
      boxEvent,
      widgetMgr,
      { ...proto, selectionMode: [1, 2] } as PlotlyChartProto,
      undefined
    )
    expect(widgetMgr.setStringValue).toHaveBeenCalledTimes(1)

    const lassoEventAndBoxEvent = {
      points: [
        {
          pointIndex: 1,
          data: { legendgroup: "group1" },
          pointIndices: [1],
          x: 1,
          y: 1,
        },
        {
          pointIndex: 0,
          data: { legendgroup: "group2" },
          pointIndices: [0],
          x: 0,
          y: 0,
        },
      ],
      selections: [
        { type: "path", xref: "x", yref: "y", path: "M4.0,8.0L4.0,7Z" },
        {
          type: "rect",
          xref: "x",
          yref: "y",
          x0: "0",
          x1: "1",
          y0: "0",
          y1: "1",
        },
      ],
    } as any

    handleSelection(
      lassoEventAndBoxEvent,
      widgetMgr,
      { ...proto, selectionMode: [1, 2] } as PlotlyChartProto,
      undefined
    )
    expect(widgetMgr.setStringValue).toHaveBeenCalledTimes(2)
    expect(widgetMgr.setStringValue).toHaveBeenLastCalledWith(
      { id: "plotly_chart", selectionMode: [1, 2] },
      '{"selection":{"points":[{"point_index":1,"point_indices":[1],"x":1,"y":1,"legendgroup":"group1"},{"point_index":0,"point_indices":[0],"x":0,"y":0,"legendgroup":"group2"}],"point_indices":[1,0],"box":[{"xref":"x","yref":"y","x":["0","1"],"y":["0","1"]}],"lasso":[{"xref":"x","yref":"y","x":[4,4],"y":[8,7]}]}}',
      { fromUi: true },
      undefined
    )
  })
})

describe("applyTheming", () => {
  it("applies Streamlit theme when theme is streamlit", () => {
    const mockPlotlyFigure = { data: [{}], layout: {}, frames: [] }
    const chartTheme = "streamlit"

    applyTheming(mockPlotlyFigure, chartTheme, mockTheme.emotion)

    expect(applyStreamlitTheme).toHaveBeenCalled()
  })

  it("applies default theme when not using the default plotly theme", () => {
    const mockPlotlyFigure = { data: [{}], layout: {}, frames: [] }
    const chartTheme = "default"

    applyTheming(mockPlotlyFigure, chartTheme, mockTheme.emotion)

    expect(layoutWithThemeDefaults).toHaveBeenCalled()
  })
})


================================================
File: /frontend/lib/src/components/elements/PlotlyChart/PlotlyChart.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  ReactElement,
  useCallback,
  useEffect,
  useMemo,
  useState,
} from "react"

import { useTheme } from "@emotion/react"
import Plot, { Figure as PlotlyFigureType } from "react-plotly.js"

import { EmotionTheme } from "@streamlit/lib/src/theme"
import { PlotlyChart as PlotlyChartProto } from "@streamlit/lib/src/proto"
import { WidgetStateManager } from "@streamlit/lib/src/WidgetStateManager"
import {
  keysToSnakeCase,
  notNullOrUndefined,
} from "@streamlit/lib/src/util/utils"
import { FormClearHelper } from "@streamlit/lib/src/components/widgets/Form/FormClearHelper"
import { ElementFullscreenContext } from "@streamlit/lib/src/components/shared/ElementFullscreen/ElementFullscreenContext"
import { useRequiredContext } from "@streamlit/lib/src/hooks/useRequiredContext"
import { withFullScreenWrapper } from "@streamlit/lib/src/components/shared/FullScreenWrapper"

import {
  applyStreamlitTheme,
  layoutWithThemeDefaults,
  replaceTemporaryColors,
} from "./CustomTheme"

// Copied and Pasted from Plotly type def
export interface SelectionRange {
  x: number[]
  y: number[]
}

export interface PlotlySelection extends SelectionRange {
  xref: string
  yref: string
}

// This is the state that is sent to the backend
// This needs to be the same structure that is also defined
// in the Python code. Uses snake case to be compatible with the
// Python naming conventions.
export interface PlotlyWidgetState {
  selection: {
    points: Array<any>
    point_indices: number[]
    box: PlotlySelection[]
    lasso: PlotlySelection[]
  }
}

// Minimum width for Plotly charts
const MIN_WIDTH = 150

// Custom icon used in the fullscreen expand toolbar button:
/* eslint-disable streamlit-custom/no-hardcoded-theme-values */
const FULLSCREEN_EXPAND_ICON = {
  width: 600,
  height: 470,
  name: "fullscreen-expand",
  // https://fontawesome.com/icons/expand?f=classic&s=solid
  path: "M32 32C14.3 32 0 46.3 0 64v96c0 17.7 14.3 32 32 32s32-14.3 32-32V96h64c17.7 0 32-14.3 32-32s-14.3-32-32-32H32zM64 352c0-17.7-14.3-32-32-32s-32 14.3-32 32v96c0 17.7 14.3 32 32 32h96c17.7 0 32-14.3 32-32s-14.3-32-32-32H64V352zM320 32c-17.7 0-32 14.3-32 32s14.3 32 32 32h64v64c0 17.7 14.3 32 32 32s32-14.3 32-32V64c0-17.7-14.3-32-32-32H320zM448 352c0-17.7-14.3-32-32-32s-32 14.3-32 32v64H320c-17.7 0-32 14.3-32 32s14.3 32 32 32h96c17.7 0 32-14.3 32-32V352z",
}
const FULLSCREEN_COLLAPSE_ICON = {
  width: 600,
  height: 470,
  name: "fullscreen-collapse",
  // https://fontawesome.com/icons/compress?f=classic&s=solid
  path: "M160 64c0-17.7-14.3-32-32-32s-32 14.3-32 32v64H32c-17.7 0-32 14.3-32 32s14.3 32 32 32h96c17.7 0 32-14.3 32-32V64zM32 320c-17.7 0-32 14.3-32 32s14.3 32 32 32H96v64c0 17.7 14.3 32 32 32s32-14.3 32-32V352c0-17.7-14.3-32-32-32H32zM352 64c0-17.7-14.3-32-32-32s-32 14.3-32 32v96c0 17.7 14.3 32 32 32h96c17.7 0 32-14.3 32-32s-14.3-32-32-32H352V64zM320 320c-17.7 0-32 14.3-32 32v96c0 17.7 14.3 32 32 32s32-14.3 32-32V384h64c17.7 0 32-14.3 32-32s-14.3-32-32-32H320z",
}
/* eslint-enable streamlit-custom/no-hardcoded-theme-values */

/**
 * Parses an SVG path string into separate x and y coordinates.
 *
 * The function takes a single SVG path string as input. This path string should start with 'M'
 * (move to command), followed by pairs of x and y coordinates separated by commas, and optionally
 * end with 'Z' to close the path. Each pair of coordinates is separated by 'L' (line to command).
 *
 * Example Input:
 * "M4.016412414518674,8.071685352641575L4.020620725933719,7.8197516509841165Z"
 *
 * Example Output:
 * {
 *   x: [4.016412414518674, 4.020620725933719],
 *   y: [8.071685352641575, 7.8197516509841165]
 * }
 *
 * @param {string} pathData - The SVG path string to be parsed.
 * @returns {SelectionRange} An object containing two arrays: `x` for all x coordinates and `y` for all y coordinates.
 */
export function parseLassoPath(pathData: string): SelectionRange {
  if (pathData === "") {
    return {
      x: [],
      y: [],
    }
  }
  const points = pathData.replace("M", "").replace("Z", "").split("L")

  const x: number[] = []
  const y: number[] = []

  points.forEach(point => {
    const [xVal, yVal] = point.split(",").map(Number)
    x.push(xVal)
    y.push(yVal)
  })

  return { x, y }
}

/**
 * Parses a box selection object into separate x and y coordinates.
 *
 * The function takes a box selection object as input. This object should contain the following
 * fields: x0, x1, y0, y1. These fields represent the x and y coordinates of the box selection
 * in the plotly chart.
 *
 * Example Input:
 * {
 *   x0: 0.1,
 *   x1: 0.2,
 *   y0: 0.3,
 *   y1: 0.4
 * }
 *
 * Example Output:
 * {
 *   x: [0.1, 0.2],
 *   y: [0.3, 0.4]
 * }
 *
 * @param {Object} selection - The box selection object to be parsed.
 * @returns {SelectionRange} An object containing two arrays: `x` for all x coordinates and `y` for all y coordinates.
 */
export function parseBoxSelection(selection: any): SelectionRange {
  const hasRequiredFields =
    "x0" in selection &&
    "x1" in selection &&
    "y0" in selection &&
    "y1" in selection

  if (!hasRequiredFields) {
    return { x: [], y: [] }
  }

  const x: number[] = [selection.x0, selection.x1]
  const y: number[] = [selection.y0, selection.y1]
  return { x, y }
}

/**
 * Apply theming to the Plotly figure.
 *
 * @param plotlyFigure The Plotly figure to apply theming to
 * @param chartTheme The theme of the chart (streamlit or empty string)
 * @param theme The current theme of the app
 * @returns The Plotly figure with theming applied
 */
export function applyTheming(
  plotlyFigure: PlotlyFigureType,
  chartTheme: string,
  theme: EmotionTheme
): PlotlyFigureType {
  const spec = JSON.parse(
    replaceTemporaryColors(JSON.stringify(plotlyFigure), theme, chartTheme)
  )
  if (chartTheme === "streamlit") {
    applyStreamlitTheme(spec, theme)
  } else {
    // Apply minor theming improvements to work better with Streamlit
    spec.layout = layoutWithThemeDefaults(spec.layout, theme)
  }
  return spec
}

/**
 * Handles the selection event from Plotly and sends the selection state to the backend.
 * The selection state is sent as a stringified JSON object.
 *
 * @param event The Plotly selection event
 * @param widgetMgr The widget manager
 * @param element The PlotlyChartProto element
 * @param fragmentId The fragment id
 */
export function handleSelection(
  event: Readonly<Plotly.PlotSelectionEvent>,
  widgetMgr: WidgetStateManager,
  element: PlotlyChartProto,
  fragmentId: string | undefined
): void {
  if (!event) {
    return
  }

  const selectionState: PlotlyWidgetState = {
    selection: {
      points: [],
      point_indices: [],
      box: [],
      lasso: [],
    },
  }
  // Use a set for point indices since all numbers should be unique:
  const selectedPointIndices = new Set<number>()
  const selectedBoxes: PlotlySelection[] = []
  const selectedLassos: PlotlySelection[] = []
  const selectedPoints: Array<any> = []

  // event.selections doesn't show up in the PlotSelectionEvent
  // @ts-expect-error
  const { selections, points } = event

  if (points) {
    points.forEach(function (point: any) {
      selectedPoints.push({
        ...point,
        legendgroup: point.data.legendgroup || undefined,
        // Remove data and full data as they have been deemed to be unnecessary data overhead
        data: undefined,
        fullData: undefined,
      })
      if (notNullOrUndefined(point.pointIndex)) {
        selectedPointIndices.add(point.pointIndex)
      }

      // If pointIndices is present (e.g. selection on histogram chart),
      // add all of them to the set
      if (
        notNullOrUndefined(point.pointIndices) &&
        point.pointIndices.length > 0
      ) {
        point.pointIndices.forEach((item: number) =>
          selectedPointIndices.add(item)
        )
      }
    })
  }

  if (selections) {
    selections.forEach((selection: any) => {
      // box selection
      if (selection.type === "rect") {
        const xAndy = parseBoxSelection(selection)
        const returnSelection: PlotlySelection = {
          xref: selection.xref,
          yref: selection.yref,
          x: xAndy.x,
          y: xAndy.y,
        }
        selectedBoxes.push(returnSelection)
      }
      // lasso selection
      if (selection.type === "path") {
        const xAndy = parseLassoPath(selection.path)
        const returnSelection: PlotlySelection = {
          xref: selection.xref,
          yref: selection.yref,
          x: xAndy.x,
          y: xAndy.y,
        }
        selectedLassos.push(returnSelection)
      }
    })
  }

  selectionState.selection.point_indices = Array.from(selectedPointIndices)
  selectionState.selection.points = selectedPoints.map((point: any) =>
    keysToSnakeCase(point)
  )

  selectionState.selection.box = selectedBoxes
  selectionState.selection.lasso = selectedLassos

  if (
    selectionState.selection.box.length > 0 &&
    !element.selectionMode.includes(PlotlyChartProto.SelectionMode.BOX)
  ) {
    // If box selection is not activated, we don't want
    // to send any box selection related updates to the frontend
    return
  }

  if (
    selectionState.selection.lasso.length > 0 &&
    !element.selectionMode.includes(PlotlyChartProto.SelectionMode.LASSO)
  ) {
    // If lasso selection is not activated, we don't want
    // to send any lasso selection related updates to the frontend
    return
  }

  const currentSelectionState = widgetMgr.getStringValue(element)
  const newSelectionState = JSON.stringify(selectionState)
  if (currentSelectionState !== newSelectionState) {
    // Only update the widget state if it has changed
    widgetMgr.setStringValue(
      element,
      newSelectionState,
      { fromUi: true },
      fragmentId
    )
  }
}

/**
 * Sends an empty selection state to the backend.
 * This is used to reset the selection state in the widget.
 *
 * @param widgetMgr The widget manager
 * @param element The PlotlyChartProto element
 * @param fragmentId The fragment id
 */
export function sendEmptySelection(
  widgetMgr: WidgetStateManager,
  element: PlotlyChartProto,
  fragmentId: string | undefined
): void {
  const emptySelectionState: PlotlyWidgetState = {
    // We use snake case here since this is the widget state
    // that is sent and used in the backend. Therefore, it should
    // conform with the Python naming conventions.
    selection: {
      points: [],
      point_indices: [],
      box: [],
      lasso: [],
    },
  }
  const currentSelectionState = widgetMgr.getStringValue(element)
  const newSelectionState = JSON.stringify(emptySelectionState)
  if (currentSelectionState !== newSelectionState) {
    // Only update the widget state if it has changed
    widgetMgr.setStringValue(
      element,
      newSelectionState,
      { fromUi: true },
      fragmentId
    )
  }
}

export interface PlotlyChartProps {
  element: PlotlyChartProto
  widgetMgr: WidgetStateManager
  disabled: boolean
  fragmentId?: string
  disableFullscreenMode?: boolean
  width: number
}

export function PlotlyChart({
  element,
  widgetMgr,
  disabled,
  fragmentId,
  disableFullscreenMode,
}: Readonly<PlotlyChartProps>): ReactElement {
  const theme: EmotionTheme = useTheme()
  const {
    expanded: isFullScreen,
    width,
    height,
    expand,
    collapse,
  } = useRequiredContext(ElementFullscreenContext)

  // Load the initial figure spec from the element message
  const initialFigureSpec = useMemo<PlotlyFigureType>(() => {
    if (!element.spec) {
      return {
        layout: {},
        data: [],
        frames: undefined,
      }
    }

    return JSON.parse(element.spec)
    // We want to reload the initialFigureSpec object whenever the element id changes
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [element.id, element.spec])

  const [plotlyFigure, setPlotlyFigure] = useState<PlotlyFigureType>(() => {
    // If there was already a state with a figure using the same id,
    // use that to recover the state. This happens in some situations
    // where a component un-mounts and mounts again.
    const initialFigureState = widgetMgr.getElementState(element.id, "figure")
    if (initialFigureState) {
      return initialFigureState
    }
    return applyTheming(initialFigureSpec, element.theme, theme)
  })

  const isSelectionActivated = element.selectionMode.length > 0 && !disabled
  const isLassoSelectionActivated =
    isSelectionActivated &&
    element.selectionMode.includes(PlotlyChartProto.SelectionMode.LASSO)
  const isBoxSelectionActivated =
    isSelectionActivated &&
    element.selectionMode.includes(PlotlyChartProto.SelectionMode.BOX)
  const isPointsSelectionActivated =
    isSelectionActivated &&
    element.selectionMode.includes(PlotlyChartProto.SelectionMode.POINTS)

  const plotlyConfig = useMemo(() => {
    if (!element.config) {
      // If there is no config, return an empty object
      return {}
    }

    const config = JSON.parse(element.config)

    // Customize the plotly toolbar:
    if (!disableFullscreenMode) {
      // Add a fullscreen button to the plotly toolbar:
      config.modeBarButtonsToAdd = [
        {
          name: isFullScreen ? "Close fullscreen" : "Fullscreen",
          icon: isFullScreen
            ? FULLSCREEN_COLLAPSE_ICON
            : FULLSCREEN_EXPAND_ICON,
          click: () => {
            if (isFullScreen && collapse) {
              collapse()
            } else if (expand) {
              expand()
            }
          },
        },
        ...(config.modeBarButtonsToAdd ?? []),
      ]
    }

    if (!config.modeBarButtonsToRemove) {
      // Only modify the mode bar buttons if it's not already set
      // in the config provided by the user.

      // Hide the logo by default
      config.displaylogo = false

      const modeBarButtonsToRemove = ["sendDataToCloud"]

      if (!isSelectionActivated) {
        // Remove lasso & select buttons in read-only charts:
        modeBarButtonsToRemove.push("lasso2d", "select2d")
      } else {
        if (!isLassoSelectionActivated) {
          // Remove the lasso button if lasso selection is not activated
          modeBarButtonsToRemove.push("lasso2d")
        }

        if (!isBoxSelectionActivated) {
          // Remove the box select button if box selection is not activated
          modeBarButtonsToRemove.push("select2d")
        }
      }

      config.modeBarButtonsToRemove = modeBarButtonsToRemove
    }
    return config
    // We want to reload the plotlyConfig object whenever the element id changes
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    element.id,
    element.config,
    isFullScreen,
    disableFullscreenMode,
    isSelectionActivated,
    isLassoSelectionActivated,
    isBoxSelectionActivated,
    collapse,
    expand,
  ])

  useEffect(() => {
    // If the theme changes, we need to reapply the theming to the figure
    setPlotlyFigure((prevState: PlotlyFigureType) => {
      return applyTheming(prevState, element.theme, theme)
    })
  }, [element.id, theme, element.theme])

  useEffect(() => {
    let updatedClickMode: typeof initialFigureSpec.layout.clickmode =
      initialFigureSpec.layout.clickmode
    let updatedHoverMode: typeof initialFigureSpec.layout.hovermode =
      initialFigureSpec.layout.hovermode
    let updatedDragMode: typeof initialFigureSpec.layout.dragmode =
      initialFigureSpec.layout.dragmode

    if (disabled) {
      updatedClickMode = "none"
      updatedDragMode = "pan"
    } else if (isSelectionActivated) {
      if (!initialFigureSpec.layout.clickmode) {
        // If the user has already set the clickmode, we don't want to override it here.
        // Otherwise, we are selecting the best clickmode based on the selection modes.
        if (isPointsSelectionActivated) {
          // https://plotly.com/javascript/reference/layout/#layout-clickmode
          // This allows single point selections and shift click to add / remove selections
          updatedClickMode = "event+select"
        } else {
          // If points selection is not activated, we set the clickmode to none (no single item clicks)
          updatedClickMode = "none"
        }
      }

      if (!initialFigureSpec.layout.hovermode) {
        // If the user has already set the hovermode, we don't want to override it here.
        updatedHoverMode = "closest"
      }

      if (!initialFigureSpec.layout.dragmode) {
        // If the user has already set the dragmode, we don't want to override it here.
        // If not, we are selecting the best drag mode based on the selection modes.
        if (isPointsSelectionActivated) {
          // Pan drag mode has priority in case points selection is activated
          updatedDragMode = "pan"
        } else if (isBoxSelectionActivated) {
          // Configure select (box selection) as the activated drag mode:
          updatedDragMode = "select"
        } else if (isLassoSelectionActivated) {
          // Configure lasso (lasso selection) as the activated drag mode:
          updatedDragMode = "lasso"
        } else {
          updatedDragMode = "pan"
        }
      }
    }

    setPlotlyFigure((prevState: PlotlyFigureType) => {
      if (
        prevState.layout.clickmode === updatedClickMode &&
        prevState.layout.hovermode === updatedHoverMode &&
        prevState.layout.dragmode === updatedDragMode
      ) {
        // Nothing has changed, just return the previous state
        return prevState
      }

      return {
        ...prevState,
        layout: {
          ...prevState.layout,
          clickmode: updatedClickMode,
          hovermode: updatedHoverMode,
          dragmode: updatedDragMode,
        },
      }
    })
    // We want to reload these options whenever the element id changes
    // or the selection modes change.
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [
    element.id,
    isSelectionActivated,
    isPointsSelectionActivated,
    isBoxSelectionActivated,
    isLassoSelectionActivated,
    disabled,
  ])

  let calculatedWidth =
    width === -1
      ? // In some situations - e.g. initial loading of tabs - the width is set to -1
        // before its able to determine the real width. We want to keep the previous
        // width in this case.
        plotlyFigure.layout?.width
      : Math.max(
          element.useContainerWidth
            ? width
            : Math.min(initialFigureSpec.layout.width ?? width, width),
          // Apply a min width to prevent the chart running into issues with negative
          // width values if the browser window is too small:
          MIN_WIDTH
        )

  let calculatedHeight = initialFigureSpec.layout.height

  if (isFullScreen) {
    calculatedWidth = width
    calculatedHeight = height
  }

  if (
    plotlyFigure.layout.height !== calculatedHeight ||
    plotlyFigure.layout.width !== calculatedWidth
  ) {
    // Update the figure with the new height and width (if they have changed)
    setPlotlyFigure((prevFigure: PlotlyFigureType) => {
      return {
        ...prevFigure,
        layout: {
          ...prevFigure.layout,
          height: calculatedHeight,
          width: calculatedWidth,
        },
      }
    })
  }

  /**
   * Callback to handle selections on the plotly chart.
   */
  const handleSelectionCallback = useCallback(
    (event: Readonly<Plotly.PlotSelectionEvent>): void => {
      handleSelection(event, widgetMgr, element, fragmentId)
    },
    // We are using element.id here instead of element since we don't
    // shallow reference equality will not work correctly for element.
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [element.id, widgetMgr, fragmentId]
  )

  /**
   * Callback resets selections in the chart and
   * sends out an empty selection state.
   */
  const resetSelectionsCallback = useCallback(
    (resetSelectionInFigure = true): void => {
      sendEmptySelection(widgetMgr, element, fragmentId)

      if (resetSelectionInFigure) {
        // We need to do this reset with a short timeout, because otherwise
        // the onUpdate callback seems to overwrite the selection state
        // that we set here. The timeout will make sure that this is executed
        // after the onUpdate callback.
        setTimeout(() => {
          // Reset the selection info within the plotly figure
          setPlotlyFigure((prevFigure: PlotlyFigureType) => {
            return {
              ...prevFigure,
              data: prevFigure.data.map((trace: any) => {
                return {
                  ...trace,
                  // Set to null to clear the selection an empty
                  // array here would still show everything as opaque
                  selectedpoints: null,
                }
              }),
              layout: {
                ...prevFigure.layout,
                // selections is not part of the plotly typing:
                selections: [],
              },
            }
          })
        }, 50)
      }
    },
    // We are using element.id here instead of element since we don't
    // shallow reference equality will not work correctly for element.
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [element.id, widgetMgr, fragmentId]
  )

  // This is required for the form clearing functionality:
  useEffect(() => {
    if (!element.formId || !isSelectionActivated) {
      // We don't need the form clear functionality if its not in a form
      // or if selections are not activated.
      return
    }

    const formClearHelper = new FormClearHelper()
    // On form clear, reset the selections (in chart & widget state)
    formClearHelper.manageFormClearListener(
      widgetMgr,
      element.formId,
      resetSelectionsCallback
    )

    return () => {
      formClearHelper.disconnect()
    }
  }, [
    element.formId,
    widgetMgr,
    isSelectionActivated,
    resetSelectionsCallback,
  ])

  useEffect(() => {
    if (!isSelectionActivated) {
      return
    }
    // The point selection during the lasso or box selection seems
    // to be a bit buggy. Sometimes, points gets unselected without
    // triggering an onDeselect event.
    // Therefore, we are deactivating the event+select clickmode
    // if the dragmode is set to select or lasso.
    let clickmode: "event+select" | "event" | "none"
    if (
      plotlyFigure.layout?.dragmode === "select" ||
      plotlyFigure.layout?.dragmode === "lasso"
    ) {
      clickmode = "event"
    } else {
      // Reset to either none or event+select based on if points selection mode
      // is activated or not.
      clickmode = isPointsSelectionActivated ? "event+select" : "none"
    }

    if (plotlyFigure.layout?.clickmode !== clickmode) {
      setPlotlyFigure((prevFigure: PlotlyFigureType) => {
        return {
          ...prevFigure,
          layout: {
            ...prevFigure.layout,
            clickmode: clickmode,
          },
        }
      })
    }
    // We only want to trigger this effect if the dragmode changes.
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [plotlyFigure.layout?.dragmode])

  return (
    <div className="stPlotlyChart" data-testid="stPlotlyChart">
      <Plot
        key={isFullScreen ? "fullscreen" : "original"}
        data={plotlyFigure.data}
        layout={plotlyFigure.layout}
        config={plotlyConfig}
        frames={plotlyFigure.frames ?? undefined}
        style={{
          // Hide the plotly chart if the width is not defined yet
          // to prevent flickering issues.
          visibility:
            plotlyFigure.layout?.width === undefined ? "hidden" : undefined,
        }}
        onSelected={isSelectionActivated ? handleSelectionCallback : () => {}}
        // Double click is needed to make it easier to the user to
        // reset the selection. The default handling can be a bit annoying
        // sometimes.
        onDoubleClick={
          isSelectionActivated ? () => resetSelectionsCallback() : undefined
        }
        onDeselect={
          isSelectionActivated
            ? () => {
                // Plotly is also resetting the UI state already for
                // deselect events. So, we don't need to do it on our side.
                // Thats why the flag is false.
                resetSelectionsCallback(false)
              }
            : undefined
        }
        onInitialized={figure => {
          widgetMgr.setElementState(element.id, "figure", figure)
        }}
        // Update the figure state on every change to the figure itself:
        onUpdate={figure => {
          // Save the updated figure state to allow it to be recovered
          widgetMgr.setElementState(element.id, "figure", figure)
          setPlotlyFigure(figure)
        }}
      />
    </div>
  )
}

export default withFullScreenWrapper(PlotlyChart)


================================================
File: /frontend/lib/src/components/elements/PlotlyChart/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./PlotlyChart"


================================================
File: /frontend/lib/src/components/elements/Popover/Popover.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { Block as BlockProto } from "@streamlit/lib/src/proto"

import Popover, { PopoverProps } from "./Popover"

const getProps = (
  elementProps: Partial<BlockProto.Popover> = {},
  props: Partial<PopoverProps> = {}
): PopoverProps => ({
  element: BlockProto.Popover.create({
    label: "label",
    useContainerWidth: false,
    disabled: false,
    help: "",
    ...elementProps,
  }),
  empty: false,
  width: 100,
  ...props,
})

describe("Popover container", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(
      <Popover {...props}>
        <div>test</div>
      </Popover>
    )
    const popoverButton = screen.getByTestId("stPopover")
    expect(popoverButton).toBeInTheDocument()
    expect(popoverButton).toHaveClass("stPopover")
  })

  it("renders label on the popover", () => {
    const props = getProps()
    render(
      <Popover {...props}>
        <div>test</div>
      </Popover>
    )

    const popover = screen.getByRole("button", {
      name: `${props.element.label}`,
    })
    expect(popover).toBeInTheDocument()
  })

  it("should render the text when opened", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(
      <Popover {...props}>
        <div>test</div>
      </Popover>
    )

    await user.click(screen.getByText("label"))
    // Text should be visible now
    expect(screen.queryByText("test")).toBeVisible()
  })
})


================================================
File: /frontend/lib/src/components/elements/Popover/Popover.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { useTheme } from "@emotion/react"
import { ExpandLess, ExpandMore } from "@emotion-icons/material-outlined"
import { PLACEMENT, TRIGGER_TYPE, Popover as UIPopover } from "baseui/popover"

import { hasLightBackgroundColor } from "@streamlit/lib/src/theme"
import { StyledIcon } from "@streamlit/lib/src/components/shared/Icon"
import { Block as BlockProto } from "@streamlit/lib/src/proto"
import BaseButton, {
  BaseButtonKind,
  BaseButtonSize,
  BaseButtonTooltip,
  DynamicButtonLabel,
} from "@streamlit/lib/src/components/shared/BaseButton"
import IsSidebarContext from "@streamlit/lib/src/components/core/IsSidebarContext"

import { StyledPopoverButtonIcon } from "./styled-components"

export interface PopoverProps {
  element: BlockProto.Popover
  empty: boolean
  width: number
}

const Popover: React.FC<React.PropsWithChildren<PopoverProps>> = ({
  element,
  empty,
  width,
  children,
}): ReactElement => {
  const [open, setOpen] = React.useState(false)
  const isInSidebar = React.useContext(IsSidebarContext)

  const theme = useTheme()
  const lightBackground = hasLightBackgroundColor(theme)

  // When useContainerWidth true & has help tooltip,
  // we need to pass the container width down to the button
  const fluidButtonWidth = element.help ? width : true

  return (
    <div data-testid="stPopover" className="stPopover">
      <UIPopover
        triggerType={TRIGGER_TYPE.click}
        placement={PLACEMENT.bottomLeft}
        content={() => children}
        isOpen={open}
        onClickOutside={() => setOpen(false)}
        // We need to handle the click here as well to allow closing the
        // popover when the user clicks next to the button in the available
        // width in the surrounding container.
        onClick={() => (open ? setOpen(false) : undefined)}
        onEsc={() => setOpen(false)}
        ignoreBoundary={isInSidebar}
        // TODO(lukasmasuch): We currently use renderAll to have a consistent
        // width during the first and subsequent opens of the popover. Once we ,
        // support setting an explicit width we should reconsider turning this to
        // false for a better performance.
        renderAll={true}
        overrides={{
          Body: {
            props: {
              "data-testid": "stPopoverBody",
            },
            style: () => ({
              marginRight: theme.spacing.lg,
              marginBottom: theme.spacing.lg,

              maxHeight: "70vh",
              overflow: "auto",
              maxWidth: `calc(${theme.sizes.contentMaxWidth} - 2*${theme.spacing.lg})`,
              minWidth: element.useContainerWidth
                ? // If use_container_width==True, we use the container width as minimum:
                  `${Math.max(width, 160)}px` // 10rem ~= 160px
                : theme.sizes.minPopupWidth,
              [`@media (max-width: ${theme.breakpoints.sm})`]: {
                maxWidth: `calc(100% - ${theme.spacing.threeXL})`,
              },
              borderTopLeftRadius: theme.radii.xl,
              borderTopRightRadius: theme.radii.xl,
              borderBottomRightRadius: theme.radii.xl,
              borderBottomLeftRadius: theme.radii.xl,

              borderLeftWidth: theme.sizes.borderWidth,
              borderRightWidth: theme.sizes.borderWidth,
              borderTopWidth: theme.sizes.borderWidth,
              borderBottomWidth: theme.sizes.borderWidth,

              paddingRight: `calc(${theme.spacing.twoXL} - ${theme.sizes.borderWidth})`, // 1px to account for border.
              paddingLeft: `calc(${theme.spacing.twoXL} - ${theme.sizes.borderWidth})`,
              paddingBottom: `calc(${theme.spacing.twoXL} - ${theme.sizes.borderWidth})`,
              paddingTop: `calc(${theme.spacing.twoXL} - ${theme.sizes.borderWidth})`,

              borderLeftStyle: "solid",
              borderRightStyle: "solid",
              borderTopStyle: "solid",
              borderBottomStyle: "solid",

              borderLeftColor: theme.colors.borderColor,
              borderRightColor: theme.colors.borderColor,
              borderTopColor: theme.colors.borderColor,
              borderBottomColor: theme.colors.borderColor,

              boxShadow: lightBackground
                ? "0px 4px 16px rgba(0, 0, 0, 0.16)"
                : "0px 4px 16px rgba(0, 0, 0, 0.7)",
            }),
          },
        }}
      >
        {/* This needs to be wrapped into a div, otherwise
        the BaseWeb popover implementation will not work correctly. */}
        <div>
          <BaseButtonTooltip help={element.help}>
            <BaseButton
              data-testid="stPopoverButton"
              kind={BaseButtonKind.SECONDARY}
              size={BaseButtonSize.SMALL}
              disabled={empty || element.disabled}
              fluidWidth={element.useContainerWidth ? fluidButtonWidth : false}
              onClick={() => setOpen(!open)}
            >
              <DynamicButtonLabel icon={element.icon} label={element.label} />
              <StyledPopoverButtonIcon>
                <StyledIcon
                  as={open ? ExpandLess : ExpandMore}
                  color="inherit"
                  aria-hidden="true"
                  size="lg"
                  margin={theme.spacing.none}
                  padding={theme.spacing.none}
                />
              </StyledPopoverButtonIcon>
            </BaseButton>
          </BaseButtonTooltip>
        </div>
      </UIPopover>
    </div>
  )
}

export default Popover


================================================
File: /frontend/lib/src/components/elements/Popover/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Popover"
export type { PopoverProps } from "./Popover"


================================================
File: /frontend/lib/src/components/elements/Popover/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledPopoverButtonIcon = styled.div(({ theme }) => ({
  marginLeft: theme.spacing.threeXS,
  // This is a hacky way to offset the "padding" of the expansion svg
  // icon. Reason is that we want to use the same padding to the right side
  // as the text on the left side. The alternative would be to overwrite the
  // right padding of the button, which would also be hacky and involve slightly
  // more logic.
  // If the padding of the icon changes, this value needs to be adjusted.
  // Also, if we want to apply the same adjustment for other elements, we should
  // consider putting this into a theme variable or creating a shared styled component.
  // The SVG icon we are using seems to have an internal padding of around 25%.
  marginRight: `calc(-${theme.iconSizes.lg} * 0.25)`,
}))


================================================
File: /frontend/lib/src/components/elements/Progress/Progress.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { Progress as ProgressProto } from "@streamlit/lib/src/proto"

import Progress, { ProgressProps } from "./Progress"

const getProps = (
  propOverrides: Partial<ProgressProps> = {}
): ProgressProps => ({
  element: ProgressProto.create({
    value: 50,
  }),
  width: 0,
  ...propOverrides,
})

describe("Progress component", () => {
  it("renders without crashing", () => {
    render(<Progress {...getProps()} />)

    const progressElement = screen.getByTestId("stProgress")
    expect(progressElement).toBeInTheDocument()
    expect(progressElement).toHaveClass("stProgress")
  })

  it("sets the value correctly", () => {
    render(<Progress {...getProps({ width: 100 })} />)

    expect(screen.getByTestId("stProgress")).toBeInTheDocument()
    expect(screen.getByRole("progressbar")).toHaveAttribute(
      "aria-valuenow",
      "50"
    )
  })
})


================================================
File: /frontend/lib/src/components/elements/Progress/Progress.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { Progress as ProgressProto } from "@streamlit/lib/src/proto"
import ProgressBar from "@streamlit/lib/src/components/shared/ProgressBar"
import { StyledCaptionText } from "@streamlit/lib/src/components/elements/Progress/styled-components"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"

export interface ProgressProps {
  width: number
  element: ProgressProto
}

function Progress({ element, width }: Readonly<ProgressProps>): ReactElement {
  return (
    <div className="stProgress" data-testid="stProgress">
      <StyledCaptionText>
        <StreamlitMarkdown source={element.text} allowHTML={false} isLabel />
      </StyledCaptionText>

      <ProgressBar value={element.value} width={width} />
    </div>
  )
}

export default Progress


================================================
File: /frontend/lib/src/components/elements/Progress/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Progress"


================================================
File: /frontend/lib/src/components/elements/Progress/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

import { getGray90 } from "@streamlit/lib/src/theme"

export const StyledCaptionText = styled.div(({ theme }) => ({
  paddingBottom: theme.spacing.sm,
  lineHeight: "normal",
  color: getGray90(theme),
}))


================================================
File: /frontend/lib/src/components/elements/Skeleton/AppSkeleton.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import { AppSkeleton } from "./AppSkeleton"

describe("AppSkeleton element", () => {
  it("renders after a delay", async () => {
    render(<AppSkeleton />)

    // At first, the skeleton should not appear on screen.
    expect(screen.queryAllByTestId("stAppSkeleton")).toEqual([])

    // Then, a few ms later (500ms at time of writing) we show the skeleton.
    const appSkeleton = await screen.findByTestId("stAppSkeleton")
    expect(appSkeleton).toBeVisible()
    expect(appSkeleton).toHaveClass("stAppSkeleton")
  })
})


================================================
File: /frontend/lib/src/components/elements/Skeleton/AppSkeleton.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, memo, useEffect, useState } from "react"

import {
  ParagraphSkeleton,
  SquareSkeleton,
  StyledSkeleton,
  TextLineSkeleton,
  TitleSkeleton,
} from "./styled-components"

const SHOW_DELAY_MS = 500

const RawAppSkeleton: FC<React.PropsWithChildren<unknown>> = () => {
  const [visible, setVisible] = useState(false)

  useEffect(() => {
    const timer = setTimeout(() => {
      setVisible(true)
    }, SHOW_DELAY_MS)

    return () => {
      clearTimeout(timer)
    }
  }, [])

  if (!visible) return <></>

  return (
    <StyledSkeleton className="stAppSkeleton" data-testid="stAppSkeleton">
      <TitleSkeleton />
      <ParagraphSkeleton>
        <TextLineSkeleton width="98%" />
        <TextLineSkeleton width="100%" />
        <TextLineSkeleton width="96%" />
        <TextLineSkeleton width="65%" />
      </ParagraphSkeleton>
      <SquareSkeleton width="75%" height="9rem" />
    </StyledSkeleton>
  )
}

export const AppSkeleton = memo(RawAppSkeleton)


================================================
File: /frontend/lib/src/components/elements/Skeleton/Skeleton.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { Skeleton as SkeletonProto } from "@streamlit/lib/src/proto"

import { Skeleton } from "./Skeleton"

describe("Skeleton element", () => {
  it("renders without delay", () => {
    const props = SkeletonProto.create()
    render(<Skeleton element={props} />)

    // Render the skeleton immediately, without any sort of delay.
    // (This is normal React behavior, but different from AppSkeleton, so I'm
    // writing a very trivial test for it.)
    const skeletonElement = screen.getByTestId("stSkeleton")
    expect(skeletonElement).toBeVisible()
    expect(skeletonElement).toHaveClass("stSkeleton")
  })

  it("converts properties appropriately", () => {
    const props = SkeletonProto.create({ height: 5 })

    render(<Skeleton element={props} />)

    const testSkeleton = screen.getByTestId("stSkeleton")
    expect(testSkeleton).toHaveAttribute("height", "5px")
    expect(testSkeleton).not.toHaveAttribute("width")
  })

  it("renders app skeleton", async () => {
    const props = SkeletonProto.create({
      style: SkeletonProto.SkeletonStyle.APP,
    })
    render(<Skeleton element={props} />)

    // Await the skeleton to appear.
    expect(await screen.findByTestId("stAppSkeleton")).toBeVisible()
  })
})


================================================
File: /frontend/lib/src/components/elements/Skeleton/Skeleton.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, memo } from "react"

import { Skeleton as SkeletonProto } from "@streamlit/lib/src/proto"

import { SquareSkeleton } from "./styled-components"

import { AppSkeleton } from "."

const RawSkeleton: FC<React.PropsWithChildren<{ element: SkeletonProto }>> = ({
  element,
}) => {
  if (element.style == SkeletonProto.SkeletonStyle.APP) {
    return <AppSkeleton /> // internal-only, does not use any of the element properties
  }

  return (
    <SquareSkeleton
      className="stSkeleton"
      data-testid="stSkeleton"
      height={element?.height ? element.height + "px" : undefined}
    />
  )
}

export const Skeleton = memo(RawSkeleton)


================================================
File: /frontend/lib/src/components/elements/Skeleton/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { AppSkeleton } from "./AppSkeleton"
export { Skeleton } from "./Skeleton"


================================================
File: /frontend/lib/src/components/elements/Skeleton/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { keyframes } from "@emotion/react"
import styled from "@emotion/styled"

const pulseAnimation = keyframes`
  0%, 100% {
    opacity: 0.5;
  }

  50% {
    opacity: 1;
  }
`

const ANIMATION_STYLES = {
  animationDuration: "750ms",
  animationName: pulseAnimation,
  animationTimingFunction: "ease-in",
  animationDirection: "normal",
  animationIterationCount: "infinite",
}

export const StyledSkeleton = styled.div(({ theme }) => ({
  display: "flex",
  flexDirection: "column",
  gap: theme.spacing.lg,
}))

export const TitleSkeleton = styled.div(({ theme }) => ({
  height: theme.fontSizes.fourXL,
  width: `calc(${theme.sizes.contentMaxWidth} * 0.37)`, // Picked because it looks good.
  maxWidth: "75%", // Picked because it looks good.
  background:
    theme.colors.skeletonBackgroundColor || theme.colors.darkenedBgMix15,
  borderRadius: theme.radii.default,
  ...ANIMATION_STYLES,
}))

export const ParagraphSkeleton = styled.div(({ theme }) => ({
  display: "flex",
  flexDirection: "column",
  gap: theme.spacing.sm, // Picked because it looks good.
}))

export interface TextLineSkeletonProps {
  width: string
}

export const TextLineSkeleton = styled.div<TextLineSkeletonProps>(
  ({ theme, width }) => ({
    height: theme.fontSizes.md,
    width,
    background:
      theme.colors.skeletonBackgroundColor || theme.colors.darkenedBgMix15,
    borderRadius: theme.radii.default,
    ...ANIMATION_STYLES,
  })
)

export interface SquareSkeletonProps {
  height?: string
  width?: string
}

export const SquareSkeleton = styled.div<SquareSkeletonProps>(
  ({ theme, height, width }) => ({
    height: height ?? theme.fontSizes.fourXL,
    width: width ?? "100%",
    background:
      theme.colors.skeletonBackgroundColor || theme.colors.darkenedBgMix15,
    borderRadius: theme.radii.default,
    ...ANIMATION_STYLES,
  })
)


================================================
File: /frontend/lib/src/components/elements/Snow/Snow.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import Snow, {
  NUM_FLAKES,
  SnowProps,
} from "@streamlit/lib/src/components/elements/Snow/index"

const getProps = (): SnowProps => ({
  scriptRunId: "51522269",
})

describe("Snow element", () => {
  vi.useFakeTimers()

  beforeEach(() => {
    vi.clearAllMocks()
    vi.clearAllTimers()
  })

  it("renders without crashing", () => {
    const props = getProps()
    render(<Snow {...props} />)

    const snowElement = screen.getByTestId("stSnow")
    expect(snowElement).toBeInTheDocument()

    const snowImages = screen.getAllByRole("img")
    expect(snowImages.length).toBe(NUM_FLAKES)

    snowImages.forEach(node => {
      expect(node).toHaveAttribute("src")
    })
  })

  it("uses correct top-level class", () => {
    const props = getProps()
    render(<Snow {...props} />)

    const snowElement = screen.getByTestId("stSnow")
    expect(snowElement).toHaveClass("stSnow")
  })
})


================================================
File: /frontend/lib/src/components/elements/Snow/Snow.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { FC, memo } from "react"

/*
 * IMPORTANT: If you change the asset imports below, make sure they still work if Streamlit is
 * served from a subpath.
 */
import Flake0 from "@streamlit/lib/src/assets/img/snow/flake-0.png"
import Flake1 from "@streamlit/lib/src/assets/img/snow/flake-1.png"
import Flake2 from "@streamlit/lib/src/assets/img/snow/flake-2.png"
import Particles from "@streamlit/lib/src/components/elements/Particles"
import { ParticleProps } from "@streamlit/lib/src/components/elements/Particles/Particles"
import { RenderInPortalIfExists } from "@streamlit/lib/src/components/core/Portal/RenderInPortalIfExists"

import { StyledFlake } from "./styled-components"

export const NUM_FLAKES = 100

const FLAKE_IMAGES: string[] = [Flake0, Flake1, Flake2]

const NUM_FLAKE_TYPES = FLAKE_IMAGES.length

export interface Props {
  scriptRunId: string
}

const Flake: FC<React.PropsWithChildren<ParticleProps>> = ({
  particleType,
}) => <StyledFlake src={FLAKE_IMAGES[particleType]} />

const Snow: FC<React.PropsWithChildren<Props>> = function Snow({
  scriptRunId,
}) {
  // Keys should be unique each time, so React replaces the images in the DOM and their animations
  // actually rerun.
  return (
    <RenderInPortalIfExists>
      <Particles
        className="stSnow"
        data-testid="stSnow"
        scriptRunId={scriptRunId}
        numParticleTypes={NUM_FLAKE_TYPES}
        numParticles={NUM_FLAKES}
        ParticleComponent={Flake}
      />
    </RenderInPortalIfExists>
  )
}

export default memo(Snow)


================================================
File: /frontend/lib/src/components/elements/Snow/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Props } from "./Snow"

export type SnowProps = Props
export { default, NUM_FLAKES } from "./Snow"


================================================
File: /frontend/lib/src/components/elements/Snow/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { keyframes, Keyframes } from "@emotion/react"
import styled from "@emotion/styled"

const IMAGE_HEIGHT = 150
const IMAGE_WIDTH = 150
const POS_MIN_VW = 10
const POS_MAX_VW = 90
const DELAY_MAX_MS = 4000

const rand = (max: number, min = 0): number =>
  Math.random() * (max - min) + min

const moveDown = (): Keyframes => keyframes`
  from {
    transform:
      translateY(0)
      rotateX(${rand(360)}deg)
      rotateY(${rand(360)}deg)
      rotateZ(${rand(360)}deg);
  }

  to {
    transform:
      translateY(calc(100vh + ${IMAGE_HEIGHT}px))
      rotateX(0)
      rotateY(0)
      rotateZ(0);
  }
`

export const StyledFlake = styled.img(({ theme }) => ({
  position: "fixed",
  top: `${-IMAGE_HEIGHT}px`,
  marginLeft: `${-IMAGE_WIDTH / 2}px`,
  zIndex: theme.zIndices.balloons,
  left: `${rand(POS_MAX_VW, POS_MIN_VW)}vw`,
  animationDelay: `${rand(DELAY_MAX_MS)}ms`,
  height: `${IMAGE_HEIGHT}px`,
  width: `${IMAGE_WIDTH}px`,
  pointerEvents: "none",

  animationDuration: "3000ms",
  animationName: moveDown(),
  animationTimingFunction: "ease-in",
  animationDirection: "normal",
  animationIterationCount: 1,
  opacity: 1,
}))


================================================
File: /frontend/lib/src/components/elements/Spinner/Spinner.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { BaseProvider, LightTheme } from "baseui"
import { screen } from "@testing-library/react"

import { Spinner as SpinnerProto } from "@streamlit/lib/src/proto"
import { render } from "@streamlit/lib/src/test_util"

import Spinner, { formatTime, SpinnerProps } from "./Spinner"

const getProps = (
  propOverrides: Partial<SpinnerProps> = {},
  elementOverrides: Partial<SpinnerProto> = {}
): SpinnerProps => ({
  element: SpinnerProto.create({
    text: "Loading...",
    ...elementOverrides,
  }),
  width: 0,
  ...propOverrides,
})

describe("Spinner component", () => {
  it("renders without crashing", () => {
    render(
      <BaseProvider theme={LightTheme}>
        <Spinner {...getProps()} />
      </BaseProvider>
    )

    const spinnerContainer = screen.getByTestId("stSpinner")
    expect(spinnerContainer).toBeInTheDocument()
    expect(spinnerContainer).toHaveClass("stSpinner")
  })

  it("sets the text and width correctly", () => {
    render(
      <BaseProvider theme={LightTheme}>
        <Spinner {...getProps({ width: 100 })} />
      </BaseProvider>
    )

    const markdownText = screen.getByText("Loading...")
    expect(markdownText).toBeInTheDocument()

    // For the width, as it's a style attribute, we can test it this way:
    const spinnerElement = screen.getByTestId("stSpinner")
    expect(spinnerElement).toHaveStyle(`width: 100px`)
  })

  it("sets additional className/CSS for caching spinner", () => {
    render(
      <BaseProvider theme={LightTheme}>
        <Spinner {...getProps({}, { cache: true })} />
      </BaseProvider>
    )

    const spinnerContainer = screen.getByTestId("stSpinner")
    expect(spinnerContainer).toBeInTheDocument()

    expect(spinnerContainer).toHaveClass("stSpinner")
    expect(spinnerContainer).toHaveClass("stCacheSpinner")
    expect(spinnerContainer).toHaveStyle("paddingBottom: 1rem")
  })

  it("shows timer when showTime is true", () => {
    render(
      <BaseProvider theme={LightTheme}>
        <Spinner {...getProps({}, { showTime: true })} />
      </BaseProvider>
    )

    const spinnerContainer = screen.getByTestId("stSpinner")
    expect(spinnerContainer).toBeInTheDocument()
    expect(screen.getByText("(0.0 seconds)")).toBeInTheDocument()
  })
})

describe("formatTime", () => {
  it.each([
    [0, "(0.0 seconds)"],
    [1.5, "(1.5 seconds)"],
    [45.2, "(45.2 seconds)"],
    [60, "(1 minute)"],
    [61.5, "(1 minute, 1.5 seconds)"],
    [122.2, "(2 minutes, 2.2 seconds)"],
    [3600, "(1 hour)"],
    [3660, "(1 hour, 1 minute)"],
    [3661.5, "(1 hour, 1 minute, 1.5 seconds)"],
    [7384.2, "(2 hours, 3 minutes, 4.2 seconds)"],
  ])("formats %s to %s", (value, expected) => {
    expect(formatTime(value)).toEqual(expected)
  })
})


================================================
File: /frontend/lib/src/components/elements/Spinner/Spinner.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import classNames from "classnames"

import { isPresetTheme } from "@streamlit/lib/src/theme"
import { Spinner as SpinnerProto } from "@streamlit/lib/src/proto"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"
import { LibContext } from "@streamlit/lib/src/components/core/LibContext"

import {
  StyledSpinner,
  StyledSpinnerContainer,
  StyledSpinnerTimer,
  ThemedStyledSpinner,
} from "./styled-components"

export interface SpinnerProps {
  width: number
  element: SpinnerProto
}

/**
 * Formats a duration in seconds into a human-readable string.
 *
 * @param seconds - The duration in seconds to format
 * @returns A formatted string representation of the duration in parentheses
 *
 * @example
 * formatTime(1.1)    // "(1.1 seconds)"
 * formatTime(65.3)   // "(1 minute, 5.3 seconds)"
 * formatTime(3661.1) // "(1 hour, 1 minute, 1.1 seconds)"
 *
 * TODO: In the future, we might want to replace this with `Intl.DurationFormat` (see
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DurationFormat).
 * But that API is not available on Firefox yet.
 */
export const formatTime = (seconds: number): string => {
  const hours = Math.floor(seconds / 3600)
  const mins = Math.floor((seconds % 3600) / 60)
  const secs = seconds % 60

  if (hours === 0 && mins === 0) {
    return `(${secs.toFixed(1)} seconds)`
  }

  if (hours === 0) {
    const minText = `${mins} minute${mins === 1 ? "" : "s"}`
    const secText = secs === 0 ? "" : `, ${secs.toFixed(1)} seconds`
    return `(${minText}${secText})`
  }

  const hourText = `${hours} hour${hours === 1 ? "" : "s"}`
  const minText = mins === 0 ? "" : `, ${mins} minute${mins === 1 ? "" : "s"}`
  const secText = secs === 0 ? "" : `, ${secs.toFixed(1)} seconds`
  return `(${hourText}${minText}${secText})`
}

function Spinner({ width, element }: Readonly<SpinnerProps>): ReactElement {
  const { activeTheme } = React.useContext(LibContext)
  const usingCustomTheme = !isPresetTheme(activeTheme)
  const { cache, showTime } = element
  const [elapsedTime, setElapsedTime] = React.useState(0)

  React.useEffect(() => {
    if (!showTime) return

    const timer = setInterval(() => {
      setElapsedTime(prev => prev + 0.1)
    }, 100)

    return () => clearInterval(timer)
  }, [showTime])

  return (
    <StyledSpinner
      className={classNames({ stSpinner: true, stCacheSpinner: cache })}
      data-testid="stSpinner"
      width={width}
      cache={cache}
    >
      <StyledSpinnerContainer>
        <ThemedStyledSpinner usingCustomTheme={usingCustomTheme} />
        <StreamlitMarkdown source={element.text} allowHTML={false} />
        {showTime && (
          <StyledSpinnerTimer>{formatTime(elapsedTime)}</StyledSpinnerTimer>
        )}
      </StyledSpinnerContainer>
    </StyledSpinner>
  )
}

export default Spinner


================================================
File: /frontend/lib/src/components/elements/Spinner/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Spinner"


================================================
File: /frontend/lib/src/components/elements/Spinner/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import isPropValid from "@emotion/is-prop-valid"
import styled from "@emotion/styled"
import { Spinner } from "baseui/spinner"
interface ThemedStyledSpinnerProps {
  usingCustomTheme: boolean
}

export const ThemedStyledSpinner = styled(Spinner, {
  shouldForwardProp: isPropValid,
})<ThemedStyledSpinnerProps>(({ theme, usingCustomTheme }) => {
  return {
    fontSize: theme.fontSizes.sm,
    width: theme.sizes.spinnerSize,
    height: theme.sizes.spinnerSize,
    borderWidth: theme.sizes.spinnerThickness,
    radius: theme.radii.md,
    justifyContents: "center",
    padding: theme.spacing.none,
    margin: theme.spacing.none,
    borderColor: theme.colors.borderColor,
    borderTopColor: usingCustomTheme
      ? theme.colors.primary
      : theme.colors.blue70,
    flexGrow: 0,
    flexShrink: 0,
  }
})

interface StyledSpinnerProps {
  width: number
  cache: boolean
}

export const StyledSpinner = styled.div<StyledSpinnerProps>(
  ({ theme, width, cache }) => ({
    width: width,
    ...(cache
      ? {
          paddingBottom: theme.spacing.lg,
          background: `linear-gradient(to bottom, ${theme.colors.bgColor} 0%, ${theme.colors.bgColor} 80%, transparent 100%)`,
        }
      : null),
  })
)

// TODO: Maybe move this to `theme/consts.ts`, see
// https://github.com/streamlit/streamlit/pull/10085/files#diff-a5cce939bf6c73209a258132c71ccb368a3a1fd57b68b373d242736adb920093
export const StyledSpinnerTimer = styled.div(({ theme }) => ({
  opacity: 0.6,
  fontSize: theme.fontSizes.sm,
}))

export const StyledSpinnerContainer = styled.div(({ theme }) => ({
  display: "flex",
  gap: theme.spacing.sm,
  alignItems: "center",
  width: "100%",
}))


================================================
File: /frontend/lib/src/components/elements/Tabs/Tabs.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen, within } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { BlockNode } from "@streamlit/lib/src/AppNode"
import { Block as BlockProto } from "@streamlit/lib/src/proto"

import Tabs, { TabProps } from "./Tabs"

const FAKE_SCRIPT_HASH = "fake_script_hash"

function makeTab(label: string, children: BlockNode[] = []): BlockNode {
  return new BlockNode(
    FAKE_SCRIPT_HASH,
    children,
    new BlockProto({ allowEmpty: true, tab: { label } })
  )
}

function makeTabsNode(tabs: number): BlockNode {
  return new BlockNode(
    FAKE_SCRIPT_HASH,
    Array.from({ length: tabs }, (_element, index) => makeTab(`Tab ${index}`)),
    new BlockProto({ allowEmpty: true })
  )
}

const getProps = (props?: Partial<TabProps>): TabProps =>
  Object({
    widgetsDisabled: false,
    node: makeTabsNode(5),
    isStale: false,
    ...props,
    renderTabContent: vi.fn(),
  })

describe("st.tabs", () => {
  it("renders without crashing", () => {
    render(<Tabs {...getProps()} />)

    const tabsElement = screen.getByTestId("stTabs")
    expect(tabsElement).toBeInTheDocument()
    expect(tabsElement).toHaveClass("stTabs")

    const tabsContainer = screen.getByRole("tablist")
    expect(tabsContainer).toBeInTheDocument()
    const tabs = within(tabsContainer).getAllByRole("tab")
    expect(tabs).toHaveLength(5)
  })

  it("sets the tab labels correctly", () => {
    render(<Tabs {...getProps()} />)
    const tabs = screen.getAllByRole("tab")
    expect(tabs).toHaveLength(5)

    tabs.forEach((tab, index) => {
      expect(tab).toHaveTextContent(`Tab ${index}`)
    })
  })

  it("can be disabled", () => {
    render(<Tabs {...getProps({ widgetsDisabled: true })} />)
    const tabs = screen.getAllByRole("tab")

    tabs.forEach((_, index) => {
      // the selected tab does not have the disabled prop as true in baseweb
      if (index == 0) {
        return
      }
      expect(tabs[index]).toBeDisabled()
    })
  })
})


================================================
File: /frontend/lib/src/components/elements/Tabs/Tabs.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  ReactElement,
  useContext,
  useEffect,
  useRef,
  useState,
} from "react"

import { useTheme } from "@emotion/react"
import { Tab as UITab, Tabs as UITabs } from "baseui/tabs-motion"

import { AppNode, BlockNode } from "@streamlit/lib/src/AppNode"
import { BlockPropsWithoutWidth } from "@streamlit/lib/src/components/core/Block"
import { isElementStale } from "@streamlit/lib/src/components/core/Block/utils"
import { LibContext } from "@streamlit/lib/src/components/core/LibContext"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"
import { STALE_STYLES } from "@streamlit/lib/src/theme"

import { StyledTabContainer } from "./styled-components"

export interface TabProps extends BlockPropsWithoutWidth {
  widgetsDisabled: boolean
  node: BlockNode
  isStale: boolean
  renderTabContent: (childProps: any) => ReactElement
}

function Tabs(props: Readonly<TabProps>): ReactElement {
  const { widgetsDisabled, node, isStale, scriptRunState, scriptRunId } = props
  const { fragmentIdsThisRun } = useContext(LibContext)

  let allTabLabels: string[] = []
  const [activeTabKey, setActiveTabKey] = useState<React.Key>(0)
  const [activeTabName, setActiveTabName] = useState<string>(
    // @ts-expect-error
    node.children[0].deltaBlock.tab.label || "0"
  )

  const tabListRef = useRef<HTMLUListElement>(null)
  const theme = useTheme()

  const [isOverflowing, setIsOverflowing] = useState(false)

  // Reconciles active key & tab name
  useEffect(() => {
    const newTabKey = allTabLabels.indexOf(activeTabName)
    if (newTabKey === -1) {
      setActiveTabKey(0)
      setActiveTabName(allTabLabels[0])
    }
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [allTabLabels])

  useEffect(() => {
    if (tabListRef.current) {
      const { scrollWidth, clientWidth } = tabListRef.current
      setIsOverflowing(scrollWidth > clientWidth)
    }

    // If tab # changes, match the selected tab label, otherwise default to first tab
    const newTabKey = allTabLabels.indexOf(activeTabName)
    if (newTabKey !== -1) {
      setActiveTabKey(newTabKey)
      setActiveTabName(allTabLabels[newTabKey])
    } else {
      setActiveTabKey(0)
      setActiveTabName(allTabLabels[0])
    }

    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [node.children.length])

  const TAB_HEIGHT = theme.sizes.tabHeight
  const TAB_BORDER_HEIGHT = theme.spacing.threeXS
  return (
    <StyledTabContainer
      className="stTabs"
      data-testid="stTabs"
      isOverflowing={isOverflowing}
      tabHeight={TAB_HEIGHT}
    >
      <UITabs
        activateOnFocus
        activeKey={activeTabKey}
        onChange={({ activeKey }) => {
          setActiveTabKey(activeKey)
          setActiveTabName(allTabLabels[activeKey as number])
        }}
        /* renderAll on UITabs should always be set to true to avoid scrolling issue
           https://github.com/streamlit/streamlit/issues/5069
         */
        renderAll={true}
        disabled={widgetsDisabled}
        overrides={{
          TabHighlight: {
            style: () => ({
              backgroundColor: widgetsDisabled
                ? theme.colors.fadedText40
                : theme.colors.primary,
              height: TAB_BORDER_HEIGHT,
            }),
          },
          TabBorder: {
            style: () => ({
              backgroundColor: theme.colors.borderColorLight,
              height: TAB_BORDER_HEIGHT,
            }),
          },
          TabList: {
            props: { ref: tabListRef },
            style: () => ({
              gap: theme.spacing.lg,
              marginBottom: `-${TAB_BORDER_HEIGHT}`,
              paddingBottom: TAB_BORDER_HEIGHT,
              overflowY: "hidden",
              ...(isStale && STALE_STYLES),
            }),
          },
          Root: {
            style: () => ({
              // resetting transform to fix full screen wrapper
              transform: "none",
            }),
          },
        }}
      >
        {node.children.map((appNode: AppNode, index: number): ReactElement => {
          // Reset available tab labels when rerendering
          if (index === 0) {
            allTabLabels = []
          }

          // If the tab is stale, disable it
          const isStaleTab = isElementStale(
            appNode,
            scriptRunState,
            scriptRunId,
            fragmentIdsThisRun
          )

          // Ensure stale tab's elements are also marked stale/disabled
          const childProps = {
            ...props,
            isStale: isStale || isStaleTab,
            widgetsDisabled,
            node: appNode as BlockNode,
          }
          let nodeLabel = index.toString()
          if (childProps.node.deltaBlock?.tab?.label) {
            nodeLabel = childProps.node.deltaBlock.tab.label
          }
          allTabLabels[index] = nodeLabel

          const isSelected = activeTabKey.toString() === index.toString()
          const isLast = index === node.children.length - 1

          return (
            <UITab
              data-testid="stTab"
              title={
                <StreamlitMarkdown
                  source={nodeLabel}
                  allowHTML={false}
                  isLabel
                />
              }
              key={index}
              disabled={widgetsDisabled}
              overrides={{
                TabPanel: {
                  style: () => ({
                    paddingLeft: theme.spacing.none,
                    paddingRight: theme.spacing.none,
                    paddingBottom: theme.spacing.none,
                    paddingTop: theme.spacing.lg,
                  }),
                },
                Tab: {
                  style: () => ({
                    height: TAB_HEIGHT,
                    whiteSpace: "nowrap",
                    paddingLeft: theme.spacing.none,
                    paddingRight: theme.spacing.none,
                    paddingTop: theme.spacing.none,
                    paddingBottom: theme.spacing.none,
                    fontSize: theme.fontSizes.sm,
                    background: "transparent",
                    color: widgetsDisabled
                      ? theme.colors.fadedText40
                      : theme.colors.bodyText,
                    ":focus": {
                      outline: "none",
                      color: widgetsDisabled
                        ? theme.colors.fadedText40
                        : theme.colors.primary,
                      background: "none",
                    },
                    ":hover": {
                      color: widgetsDisabled
                        ? theme.colors.fadedText40
                        : theme.colors.primary,
                      background: "none",
                    },
                    ...(isSelected
                      ? {
                          color: widgetsDisabled
                            ? theme.colors.fadedText40
                            : theme.colors.primary,
                        }
                      : {}),
                    // Add minimal required padding to hide the overscroll gradient
                    // This is calculated based on the width of the gradient (spacing.lg)
                    ...(isOverflowing && isLast
                      ? {
                          paddingRight: `calc(${theme.spacing.lg} * 0.6)`,
                        }
                      : {}),
                    // Apply stale effect if only this specific
                    // tab is stale but not the entire tab container.
                    ...(!isStale && isStaleTab && STALE_STYLES),
                  }),
                },
              }}
            >
              {props.renderTabContent(childProps)}
            </UITab>
          )
        })}
      </UITabs>
    </StyledTabContainer>
  )
}

export default Tabs


================================================
File: /frontend/lib/src/components/elements/Tabs/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Tabs"
export type { TabProps } from "./Tabs"


================================================
File: /frontend/lib/src/components/elements/Tabs/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"
import { transparentize } from "color2k"

export interface StyledTabContainerProps {
  isOverflowing: boolean
  tabHeight: string
}

export const StyledTabContainer = styled.div<StyledTabContainerProps>(
  ({ theme, isOverflowing, tabHeight }) => ({
    ...(isOverflowing
      ? {
          position: "relative",
          "::after": {
            content: `" "`,
            position: "absolute",
            zIndex: theme.zIndices.priority,
            top: 0,
            right: 0,
            pointerEvents: "none",
            backgroundImage: `linear-gradient(to right, ${transparentize(
              theme.colors.bgColor,
              1
            )}, ${theme.colors.bgColor})`,
            width: theme.spacing.lg,
            height: tabHeight,
          },
        }
      : {}),
  })
)


================================================
File: /frontend/lib/src/components/elements/TextElement/TextElement.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { Text as TextProto } from "@streamlit/lib/src/proto"

import TextElement, { TextProps } from "./TextElement"

const getProps = (elementProps: Partial<TextProto> = {}): TextProps => ({
  element: TextProto.create({
    body: "some plain text",
    ...elementProps,
  }),
  width: 100,
})

describe("TextElement element", () => {
  it("renders preformatted text as expected", () => {
    const props = getProps()
    render(<TextElement {...props} />)

    const textElement = screen.getByTestId("stText")
    expect(textElement).toBeInTheDocument()
    expect(screen.getByText("some plain text")).toBeInTheDocument()
    expect(textElement).toHaveClass("stText")
  })

  it("renders text with help tooltip", async () => {
    const props = getProps({ help: "help text" })
    render(<TextElement {...props} />)
    const tooltip = screen.getByTestId("stTooltipHoverTarget")
    expect(tooltip).toBeInTheDocument()
    await userEvent.hover(tooltip)

    const helpText = await screen.findAllByText("help text")
    expect(helpText[0].textContent).toBe("help text")
  })
})


================================================
File: /frontend/lib/src/components/elements/TextElement/TextElement.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { Text as TextProto } from "@streamlit/lib/src/proto"
import {
  InlineTooltipIcon,
  StyledLabelHelpWrapper,
} from "@streamlit/lib/src/components/shared/TooltipIcon"

import { StyledText } from "./styled-components"

export interface TextProps {
  width: number
  element: TextProto
}

/**
 * Functional element representing preformatted (plain) text.
 */
export default function TextElement({
  width,
  element,
}: Readonly<TextProps>): ReactElement {
  const styleProp = { width }
  return (
    <StyledLabelHelpWrapper
      style={styleProp}
      className="stText"
      data-testid="stText"
    >
      <StyledText>{element.body}</StyledText>
      {element.help && <InlineTooltipIcon content={element.help} />}
    </StyledLabelHelpWrapper>
  )
}


================================================
File: /frontend/lib/src/components/elements/TextElement/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./TextElement"


================================================
File: /frontend/lib/src/components/elements/TextElement/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledText = styled.div(({ theme }) => ({
  fontFamily: theme.genericFonts.bodyFont,
  color: theme.colors.bodyText,
  whiteSpace: "pre-line",
  whiteSpaceCollapse: "preserve",
  wordBreak: "break-word",
}))


================================================
File: /frontend/lib/src/components/elements/Toast/Toast.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { RenderResult, screen, waitFor, within } from "@testing-library/react"
import { PLACEMENT, ToasterContainer } from "baseui/toast"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { Toast as ToastProto } from "@streamlit/lib/src/proto"
import { EmotionTheme } from "@streamlit/lib/src/theme"
import { mockTheme } from "@streamlit/lib/src/mocks/mockTheme"

import { shortenMessage, Toast, ToastProps } from "./Toast"

// A Toaster Container is required to render Toasts
// Don't import the actual one from EventContainer as that lives on app side
const createContainer = (): ReactElement => (
  <ToasterContainer
    placement={PLACEMENT.bottomRight}
    // increasing autoHideDuration to 10s to avoid test flakiness
    autoHideDuration={10000}
    overrides={{
      Root: {
        props: {
          "data-testid": "stToastContainer",
        },
      },
    }}
  />
)

const getProps = (
  elementProps: Partial<ToastProto> = {},
  themeProps: Partial<EmotionTheme> = {}
): ToastProps => ({
  body: "This is a toast message",
  icon: "",
  theme: {
    ...mockTheme.emotion,
    ...themeProps,
  },
  width: 0,
  ...elementProps,
})

const renderComponent = (props: ToastProps): RenderResult =>
  render(
    <>
      {createContainer()}
      <Toast {...props} />
    </>
  )

describe("Toast Component", () => {
  test("renders default toast", () => {
    const props = getProps()
    renderComponent(props)

    const toast = screen.getByRole("alert")
    const closeButton = screen.getByRole("button", { name: "Close" })
    const expandButton = screen.queryByRole("button", { name: "view more" })

    expect(toast).toBeInTheDocument()
    expect(toast).toHaveTextContent("")
    expect(toast).toHaveTextContent("This is a toast message")
    expect(closeButton).toBeInTheDocument()
    expect(expandButton).not.toBeInTheDocument()

    const toastElement = screen.getByTestId("stToast")
    expect(toastElement).toBeInTheDocument()
    expect(toastElement).toHaveClass("stToast")
  })

  test("renders long toast messages with expand option", () => {
    const props = getProps({
      icon: "",
      body: "Random toast message that is a really really really really really really really really really long message, going way past the 3 line limit",
    })
    renderComponent(props)

    const toast = screen.getByRole("alert")
    const toastText = within(toast).getByTestId("stMarkdownContainer")

    const expandButton = screen.getByRole("button", { name: "view more" })
    expect(toast).toBeInTheDocument()
    expect(toastText).toHaveTextContent(
      "Random toast message that is a really really really really really really really really really long"
    )
    expect(toast).toContainElement(expandButton)
  })

  test("can expand to see the full toast message & collapse to truncate", async () => {
    const user = userEvent.setup()
    const props = getProps({
      icon: "",
      body: "Random toast message that is a really really really really really really really really really long message, going way past the 3 line limit",
    })
    renderComponent(props)

    const toast = screen.getByRole("alert")
    const toastText = within(toast).getByTestId("stMarkdownContainer")
    const expandButton = screen.getByRole("button", { name: "view more" })
    // Initial state
    expect(toast).toBeInTheDocument()
    expect(toastText).toHaveTextContent(
      "Random toast message that is a really really really really really really really really really long"
    )
    expect(toast).toContainElement(expandButton)

    // Click view more button & expand the message
    await user.click(expandButton)
    expect(toast).toHaveTextContent(
      "Random toast message that is a really really really really really really really really really long message, going way past the 3 line limit"
    )

    // Click view less button & collapse the message
    const collapseButton = screen.getByRole("button", { name: "view less" })
    expect(toast).toContainElement(collapseButton)
    await user.click(collapseButton)
    expect(toastText).toHaveTextContent(
      "Random toast message that is a really really really really really really really really really long"
    )
    expect(toast).toContainElement(expandButton)
  })

  test("can close toast", async () => {
    const user = userEvent.setup()
    const props = getProps()
    renderComponent(props)

    const toast = screen.getByRole("alert")
    const closeButton = screen.getByRole("button", { name: "Close" })
    expect(toast).toBeInTheDocument()
    expect(closeButton).toBeInTheDocument()
    // Click close button
    await user.click(closeButton)
    // Wait for toast to be removed from DOM
    await waitFor(() => expect(toast).not.toBeInTheDocument())
  })

  test("throws an error when called via st.sidebar.toast", async () => {
    const props = getProps({}, { inSidebar: true })
    renderComponent(props)

    const toastError = screen.getByRole("alert")
    expect(toastError).toBeInTheDocument()
    expect(toastError).toHaveTextContent("Streamlit API Error")
  })

  test("shortenMessage does not truncate messages under the character limit", () => {
    const shortMessage = "This message should not be truncated."
    const props = getProps({ body: shortMessage })
    renderComponent(props)

    const toast = screen.getByRole("alert")
    expect(toast).toHaveTextContent(shortMessage)
  })

  test("shortenMessage truncates messages over the character limit without cutting words", () => {
    const longMessage =
      "This is a very long message meant to test the functionality of the shortenMessage function, ensuring it truncates properly without cutting words and respects the character limit."
    const expectedTruncatedMessage = shortenMessage(longMessage)
    const props = getProps({ icon: "", body: longMessage })
    renderComponent(props)

    // Get the text content of the toast, excluding the "view more" and "Close" buttons
    const toastText = screen
      .getByRole("alert")
      ?.textContent?.replace("view moreClose", "")

    expect(toastText).toEqual(expectedTruncatedMessage)
    expect(toastText).toHaveLength(expectedTruncatedMessage.length)
  })

  test("shortenMessage handles explicit line breaks correctly", () => {
    const messageWithBreaks =
      "First line of the message.\nSecond line of the message, which is meant to test how explicit line breaks are handled.\nThird line, which should not be visible."
    const expectedTruncatedMessage = shortenMessage(messageWithBreaks)
    const props = getProps({ icon: "", body: messageWithBreaks })
    renderComponent(props)

    const toastText = screen
      .getByRole("alert")
      ?.textContent?.replace("view moreClose", "")
    expect(toastText).toEqual(expectedTruncatedMessage)
    expect(toastText).toHaveLength(expectedTruncatedMessage.length)
  })

  test("expands and collapses long messages with explicit line breaks correctly", async () => {
    const user = userEvent.setup()
    const messageWithBreaks =
      "First line of the message.\nSecond line of the message, which is very long and meant to test the expand and collapse functionality.\nThird line, which should initially be hidden."
    const expectedTruncatedMessage = shortenMessage(messageWithBreaks)
    const props = getProps({ icon: "", body: messageWithBreaks })
    renderComponent(props)

    const expandButton = screen.getByRole("button", { name: "view more" })
    await user.click(expandButton) // Expand

    const toastExpanded = screen
      .getByRole("alert")
      ?.textContent?.replace("view lessClose", "")
    expect(toastExpanded).toEqual(messageWithBreaks) // Check full message is displayed

    const collapseButton = screen.getByRole("button", { name: "view less" })
    await user.click(collapseButton) // Collapse

    const toastCollapsed = screen
      .getByRole("alert")
      ?.textContent?.replace("view moreClose", "")
    expect(toastCollapsed).toEqual(expectedTruncatedMessage) // Check message is truncated again
  })
})


================================================
File: /frontend/lib/src/components/elements/Toast/Toast.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, {
  ReactElement,
  useCallback,
  useEffect,
  useMemo,
  useState,
} from "react"

import { withTheme } from "@emotion/react"
import { toaster, ToastOverrides } from "baseui/toast"

import {
  EmotionTheme,
  hasLightBackgroundColor,
} from "@streamlit/lib/src/theme"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"
import { Kind } from "@streamlit/lib/src/components/shared/AlertContainer"
import AlertElement from "@streamlit/lib/src/components/elements/AlertElement/AlertElement"
import { DynamicIcon } from "@streamlit/lib/src/components/shared/Icon"

import {
  StyledMessageWrapper,
  StyledToastWrapper,
  StyledViewButton,
} from "./styled-components"

export interface ToastProps {
  theme: EmotionTheme
  body: string
  icon?: string
  width: number
}

function generateToastOverrides(theme: EmotionTheme): ToastOverrides {
  const lightBackground = hasLightBackgroundColor(theme)
  return {
    Body: {
      props: {
        "data-testid": "stToast",
        className: "stToast",
      },
      style: {
        display: "flex",
        flexDirection: "row",
        gap: theme.spacing.md,
        width: theme.sizes.toastWidth,
        marginTop: theme.spacing.sm,
        // Warnings logged if you use shorthand property here:
        borderTopLeftRadius: theme.radii.default,
        borderTopRightRadius: theme.radii.default,
        borderBottomLeftRadius: theme.radii.default,
        borderBottomRightRadius: theme.radii.default,
        paddingTop: theme.spacing.lg,
        paddingBottom: theme.spacing.lg,
        paddingLeft: theme.spacing.twoXL,
        paddingRight: theme.spacing.twoXL,
        backgroundColor: lightBackground
          ? theme.colors.gray10
          : theme.colors.gray90,
        color: theme.colors.bodyText,
        // Take standard BaseWeb shadow and adjust for dark backgrounds
        boxShadow: lightBackground
          ? "0px 4px 16px rgba(0, 0, 0, 0.16)"
          : "0px 4px 16px rgba(0, 0, 0, 0.7)",
      },
    },
    CloseIcon: {
      style: {
        color: theme.colors.fadedText40,
        width: theme.fontSizes.lg,
        height: theme.fontSizes.lg,
        marginRight: `calc(-1 * ${theme.spacing.lg} / 2)`,
        ":hover": {
          color: theme.colors.bodyText,
        },
      },
    },
  }
}

// Function used to truncate toast messages that are longer than three lines.
export function shortenMessage(fullMessage: string): string {
  const characterLimit = 104

  if (fullMessage.length > characterLimit) {
    let message = fullMessage.replace(/^(.{104}[^\s]*).*/, "$1")

    if (message.length > characterLimit) {
      message = message
        .substring(0, characterLimit)
        .split(" ")
        .slice(0, -1)
        .join(" ")
    }

    return message.trim()
  }

  return fullMessage
}

export function Toast({
  theme,
  body,
  icon,
  width,
}: Readonly<ToastProps>): ReactElement {
  const displayMessage = shortenMessage(body)
  const shortened = body !== displayMessage

  const [expanded, setExpanded] = useState(!shortened)
  const [toastKey, setToastKey] = useState<React.Key>(0)

  const handleClick = useCallback((): void => {
    setExpanded(!expanded)
  }, [expanded])

  const styleOverrides = useMemo(() => generateToastOverrides(theme), [theme])

  const toastContent = useMemo(
    () => (
      <StyledToastWrapper expanded={expanded}>
        {icon && (
          <DynamicIcon
            iconValue={icon}
            size="xl"
            testid="stToastDynamicIcon"
          />
        )}
        <StyledMessageWrapper>
          <StreamlitMarkdown
            source={expanded ? body : displayMessage}
            allowHTML={false}
            isToast
          />
          {shortened && (
            <StyledViewButton
              data-testid="stToastViewButton"
              onClick={handleClick}
            >
              {expanded ? "view less" : "view more"}
            </StyledViewButton>
          )}
        </StyledMessageWrapper>
      </StyledToastWrapper>
    ),
    [shortened, expanded, body, icon, displayMessage, handleClick]
  )

  useEffect(() => {
    // Handles the error case where st.sidebar.toast is called since
    // baseweb would throw error anyway (no toast container in sidebar)
    if (theme.inSidebar) {
      return
    }

    // Uses toaster utility to create toast on mount and generate unique key
    // to reference that toast for update/removal
    const newKey = toaster.info(toastContent, {
      overrides: { ...styleOverrides },
    })
    setToastKey(newKey)

    return () => {
      // Disable transition so toast doesn't flicker on removal
      toaster.update(newKey, {
        overrides: { Body: { style: { transitionDuration: 0 } } },
      })
      // Remove toast on unmount
      toaster.clear(newKey)
    }

    // Array must be empty to run as mount/cleanup
    // TODO: Update to match React best practices
    // eslint-disable-next-line react-compiler/react-compiler
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [])

  useEffect(() => {
    // Handles expand/collapse button behavior for long toast messages
    toaster.update(toastKey, {
      children: toastContent,
      overrides: { ...styleOverrides },
    })
  }, [toastKey, toastContent, styleOverrides])

  const sidebarErrorMessage = (
    <AlertElement
      kind={Kind.ERROR}
      body="Streamlit API Error: `st.toast` cannot be called directly on the sidebar with `st.sidebar.toast`.
        See our `st.toast` API [docs](https://docs.streamlit.io/develop/api-reference/status/st.toast) for more information."
      width={width}
    />
  )
  return (
    // Shows error if toast is called on st.sidebar
    <>{theme.inSidebar && sidebarErrorMessage}</>
  )
}

export default withTheme(Toast)


================================================
File: /frontend/lib/src/components/elements/Toast/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Toast"


================================================
File: /frontend/lib/src/components/elements/Toast/styled-components.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledViewButton = styled.button(({ theme }) => ({
  fontSize: theme.fontSizes.sm,
  lineHeight: theme.lineHeights.base,
  color: theme.colors.fadedText60,
  backgroundColor: theme.colors.transparent,
  fontFamily: "inherit",
  margin: theme.spacing.none,
  border: "none",
  boxShadow: "none",
  padding: theme.spacing.none,
  "&:hover, &:active, &:focus": {
    border: "none",
    outline: "none",
    boxShadow: "none",
  },
  "&:hover": {
    color: theme.colors.primary,
  },
}))

interface StyledToastMessageProps {
  expanded: boolean
}

export const StyledToastWrapper = styled.div<StyledToastMessageProps>(
  ({ theme }) => ({
    display: "flex",
    flexDirection: "row",
    gap: theme.spacing.lg,

    "> span": {
      marginTop: theme.spacing.twoXS,
    },
  })
)

export const StyledIcon = styled.div(({ theme }) => ({
  fontSize: theme.fontSizes.xl,
}))

export const StyledMessageWrapper = styled.div(({ theme }) => ({
  display: "flex",
  flexDirection: "column",
  gap: theme.spacing.sm,
  alignItems: "start",
  // Align text to the center of the icon when only 1 line.
  justifyContent: "center",
  overflow: "hidden",
  minHeight: "100%",
  fontSize: theme.fontSizes.sm,
  lineHeight: theme.lineHeights.base,
  div: {
    display: "inline-flex",
  },
}))


================================================
File: /frontend/lib/src/components/elements/Video/Video.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import { Video as VideoProto } from "@streamlit/lib/src/proto"
import { mockEndpoints } from "@streamlit/lib/src/mocks/mocks"
import { WidgetStateManager as ElementStateManager } from "@streamlit/lib/src/WidgetStateManager"

import Video, { VideoProps } from "./Video"

describe("Video Element", () => {
  const buildMediaURL = vi.fn().mockReturnValue("https://mock.media.url")

  const mockSetElementState = vi.fn()
  const mockGetElementState = vi.fn()
  const elementMgrMock = {
    setElementState: mockSetElementState,
    getElementState: mockGetElementState,
    sendRerunBackMsg: vi.fn(),
    formsDataChanged: vi.fn(),
  }

  const getProps = (elementProps: Partial<VideoProto> = {}): VideoProps => ({
    element: VideoProto.create({
      url: "https://www.w3schools.com/html/mov_bbb.mp4",
      type: VideoProto.Type.UNUSED,
      startTime: 0,
      ...elementProps,
    }),
    endpoints: mockEndpoints({ buildMediaURL: buildMediaURL }),
    width: 0,
    elementMgr: elementMgrMock as unknown as ElementStateManager,
  })

  beforeEach(() => {
    vi.clearAllMocks()
  })

  it("renders without crashing", () => {
    const props = getProps()
    render(<Video {...props} />)

    const videoElement = screen.getByTestId("stVideo")
    expect(videoElement).toBeInTheDocument()
    expect(videoElement).toHaveClass("stVideo")
  })

  it("has correct style", () => {
    const props = getProps()
    render(<Video {...props} />)
    const video = screen.getByTestId("stVideo")

    expect(video).toHaveAttribute("class", "stVideo")
    expect(video).toHaveStyle("width: 0px; height: 528px;")
  })

  it("has controls", () => {
    const props = getProps()
    render(<Video {...props} />)

    expect(screen.getByTestId("stVideo")).toHaveAttribute("controls")
  })

  it("creates its `src` attribute using buildMediaURL", () => {
    render(<Video {...getProps({ url: "/media/mockVideoFile.mp4" })} />)
    expect(buildMediaURL).toHaveBeenCalledWith("/media/mockVideoFile.mp4")
    expect(screen.getByTestId("stVideo")).toHaveAttribute(
      "src",
      "https://mock.media.url"
    )
  })

  beforeEach(() => {
    vi.clearAllMocks()
    mockGetElementState.mockReturnValue(false) // By default, assume autoplay is not prevented
  })

  it("does not autoplay if preventAutoplay is set", () => {
    mockGetElementState.mockReturnValueOnce(true) // Autoplay should be prevented
    const props = getProps({ autoplay: true, id: "uniqueVideoId" })
    render(<Video {...props} />)
    const audioElement = screen.getByTestId("stVideo")
    expect(audioElement).not.toHaveAttribute("autoPlay")
  })

  it("autoplays if preventAutoplay is not set and autoplay is true", () => {
    mockGetElementState.mockReturnValueOnce(false) // Autoplay is not prevented
    const props = getProps({ autoplay: true, id: "uniqueVideoId" })
    render(<Video {...props} />)
    const audioElement = screen.getByTestId("stVideo")
    expect(audioElement).toHaveAttribute("autoPlay")
  })

  it("calls setElementState to prevent future autoplay on first autoplay", () => {
    mockGetElementState.mockReturnValueOnce(false) // Autoplay is not prevented initially
    const props = getProps({ autoplay: true, id: "uniqueVideoId" })
    render(<Video {...props} />)
    expect(mockSetElementState).toHaveBeenCalledTimes(1)
    expect(mockSetElementState).toHaveBeenCalledWith(
      props.element.id,
      "preventAutoplay",
      true
    )
  })

  // Test to ensure that setElementState is not called again if autoplay is already prevented
  it("does not call setElementState again if autoplay is already prevented", () => {
    mockGetElementState.mockReturnValueOnce(true) // Autoplay is already prevented
    const props = getProps({ autoplay: true, id: "uniqueVideoId" })
    render(<Video {...props} />)
    expect(mockSetElementState).not.toHaveBeenCalled()
  })

  describe("YouTube", () => {
    it("renders a youtube iframe", () => {
      const props = getProps({
        type: VideoProto.Type.YOUTUBE_IFRAME,
      })
      render(<Video {...props} />)
      const videoElement = screen.getByTestId("stVideo")
      expect(videoElement).toBeInstanceOf(HTMLIFrameElement)
      expect(videoElement).toHaveAttribute(
        "src",
        "https://www.w3schools.com/html/mov_bbb.mp4"
      )
    })

    it("renders a youtube iframe with an starting time", () => {
      const props = getProps({
        type: VideoProto.Type.YOUTUBE_IFRAME,
        startTime: 10,
      })
      render(<Video {...props} />)
      const videoElement = screen.getByTestId("stVideo")
      expect(videoElement).toBeInstanceOf(HTMLIFrameElement)
      expect(videoElement).toHaveAttribute(
        "src",
        "https://www.w3schools.com/html/mov_bbb.mp4?start=10"
      )
    })
  })

  describe("updateTime", () => {
    const props = getProps()

    it("sets the current time to startTime on render", () => {
      render(<Video {...props} />)
      const videoElement = screen.getByTestId("stVideo") as HTMLMediaElement
      expect(videoElement.currentTime).toBe(0)
    })

    it("updates the current time when startTime is changed", () => {
      const { rerender } = render(<Video {...props} />)
      const videoElement = screen.getByTestId("stVideo") as HTMLMediaElement
      expect(videoElement.currentTime).toBe(0)

      rerender(<Video {...getProps({ startTime: 10 })} />)
      expect(videoElement.currentTime).toBe(10)
    })
  })
})


================================================
File: /frontend/lib/src/components/elements/Video/Video.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, useEffect, useMemo, useRef } from "react"

import { ISubtitleTrack, Video as VideoProto } from "@streamlit/lib/src/proto"
import { StreamlitEndpoints } from "@streamlit/lib/src/StreamlitEndpoints"
import { IS_DEV_ENV } from "@streamlit/lib/src/baseconsts"
import { WidgetStateManager as ElementStateManager } from "@streamlit/lib/src/WidgetStateManager"

import { StyledVideoIframe } from "./styled-components"

const DEFAULT_HEIGHT = 528

export interface VideoProps {
  endpoints: StreamlitEndpoints
  width: number
  element: VideoProto
  elementMgr: ElementStateManager
}

export interface Subtitle {
  label: string
  url: string
}

export default function Video({
  element,
  width,
  endpoints,
  elementMgr,
}: Readonly<VideoProps>): ReactElement {
  const videoRef = useRef<HTMLVideoElement>(null)

  /* Element may contain "url" or "data" property. */
  const { type, url, startTime, subtitles, endTime, loop, autoplay, muted } =
    element

  const preventAutoplay = useMemo<boolean>(() => {
    if (!element.id) {
      // Elements without an ID should never autoplay
      return true
    }

    // Recover the state in case this component got unmounted
    // and mounted again for the same element.
    const preventAutoplay = elementMgr.getElementState(
      element.id,
      "preventAutoplay"
    )

    if (!preventAutoplay) {
      // Set the state to prevent autoplay in case there is an unmount + mount
      // for the same element.
      elementMgr.setElementState(element.id, "preventAutoplay", true)
    }
    return preventAutoplay ?? false
  }, [element.id, elementMgr])

  // Handle startTime changes
  useEffect(() => {
    if (videoRef.current) {
      videoRef.current.currentTime = startTime
    }
  }, [startTime])

  useEffect(() => {
    const videoNode = videoRef.current

    const setStartTime: () => void = () => {
      if (videoNode) {
        videoNode.currentTime = element.startTime
      }
    }

    if (videoNode) {
      videoNode.addEventListener("loadedmetadata", setStartTime)
    }

    return () => {
      if (videoNode) {
        videoNode.removeEventListener("loadedmetadata", setStartTime)
      }
    }
  }, [element])

  // Stop the video at 'endTime' and handle loop
  useEffect(() => {
    const videoNode = videoRef.current
    if (!videoNode) {
      return
    }

    // Flag to avoid calling 'videoNode.pause()' multiple times
    let stoppedByEndTime = false

    const handleTimeUpdate = (): void => {
      if (endTime > 0 && videoNode.currentTime >= endTime) {
        if (loop) {
          // If loop is true and we reached 'endTime', reset to 'startTime'
          videoNode.currentTime = startTime || 0
          videoNode.play()
        } else if (!stoppedByEndTime) {
          stoppedByEndTime = true
          videoNode.pause()
        }
      }
    }

    if (endTime > 0) {
      videoNode.addEventListener("timeupdate", handleTimeUpdate)
    }

    return () => {
      if (videoNode && endTime > 0) {
        videoNode.removeEventListener("timeupdate", handleTimeUpdate)
      }
    }
  }, [endTime, loop, startTime])

  // Handle looping the video
  useEffect(() => {
    const videoNode = videoRef.current
    if (!videoNode) {
      return
    }

    // Loop the video when it has ended
    const handleVideoEnd = (): void => {
      if (loop) {
        videoNode.currentTime = startTime || 0 // Reset to startTime or to the start if not specified
        videoNode.play()
      }
    }

    videoNode.addEventListener("ended", handleVideoEnd)

    return () => {
      if (videoNode) {
        videoNode.removeEventListener("ended", handleVideoEnd)
      }
    }
  }, [loop, startTime])

  const getYoutubeSrc = (url: string): string => {
    const { startTime, endTime, loop, autoplay, muted } = element
    const youtubeUrl = new URL(url)

    if (startTime && !isNaN(startTime)) {
      youtubeUrl.searchParams.append("start", startTime.toString())
    }

    if (endTime && !isNaN(endTime)) {
      youtubeUrl.searchParams.append("end", endTime.toString())
    }

    if (loop) {
      youtubeUrl.searchParams.append("loop", "1")
      // When using the loop parameter, YouTube requires the playlist parameter to be set to the same video ID
      const videoId = youtubeUrl.pathname.split("/").pop()

      if (videoId) {
        youtubeUrl.searchParams.append("playlist", videoId)
      }
    }

    if (autoplay) {
      youtubeUrl.searchParams.append("autoplay", "1")
    }

    if (muted) {
      youtubeUrl.searchParams.append("mute", "1")
    }

    return youtubeUrl.toString()
  }

  // Is this a YouTube link? If so we need a fancier tag.
  // NOTE: This part assumes the URL is already an "embed" link.
  if (type === VideoProto.Type.YOUTUBE_IFRAME) {
    return (
      <StyledVideoIframe
        className="stVideo"
        data-testid="stVideo"
        title={url}
        src={getYoutubeSrc(url)}
        allow="autoplay; encrypted-media"
        allowFullScreen
      />
    )
  }

  // Only in dev mode we set crossOrigin to "anonymous" to avoid CORS issues
  // when streamlit frontend and backend are running on different ports
  return (
    <video
      className="stVideo"
      data-testid="stVideo"
      ref={videoRef}
      controls
      muted={muted}
      autoPlay={autoplay && !preventAutoplay}
      src={endpoints.buildMediaURL(url)}
      style={{ width, height: width === 0 ? DEFAULT_HEIGHT : undefined }}
      crossOrigin={
        IS_DEV_ENV && subtitles.length > 0 ? "anonymous" : undefined
      }
    >
      {subtitles &&
        subtitles.map((subtitle: ISubtitleTrack, idx: number) => (
          <track
            key={idx}
            kind="captions"
            src={endpoints.buildMediaURL(`${subtitle.url}`)}
            label={`${subtitle.label}`}
            default={idx === 0}
          />
        ))}
    </video>
  )
}


================================================
File: /frontend/lib/src/components/elements/Video/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./Video"


================================================
File: /frontend/lib/src/components/elements/Video/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledVideoIframe = styled.iframe(({ theme }) => ({
  colorScheme: "normal",
  border: "none",
  padding: theme.spacing.none,
  margin: theme.spacing.none,
  width: "100%",
  aspectRatio: "16 / 9",
}))


================================================
File: /frontend/lib/src/components/shared/AlertContainer/AlertContainer.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import AlertContainer, { AlertContainerProps, Kind } from "./AlertContainer"

const getProps = (
  propOverrides: Partial<AlertContainerProps> = {}
): AlertContainerProps => ({
  kind: Kind.INFO,
  width: 100,
  children: null,
  ...propOverrides,
})

describe("AlertContainer element", () => {
  it("renders a Notification", () => {
    render(<AlertContainer {...getProps()} />)
    const alertContainer = screen.getByTestId("stAlertContainer")
    expect(alertContainer).toBeInTheDocument()
    expect(alertContainer).toHaveClass("stAlertContainer")
  })

  it("renders its children", () => {
    render(
      <AlertContainer {...getProps()}>
        <div className="foo" data-testid="foo" />
      </AlertContainer>
    )

    expect(screen.getByTestId("foo")).toBeInTheDocument()
  })
})


================================================
File: /frontend/lib/src/components/shared/AlertContainer/AlertContainer.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement, ReactNode } from "react"

import { KIND, Notification } from "baseui/notification"
import { useTheme } from "@emotion/react"

import { EmotionTheme } from "@streamlit/lib/src/theme"

import { StyledAlertContent } from "./styled-components"

export enum Kind {
  ERROR = "error",
  INFO = "info",
  SUCCESS = "success",
  WARNING = "warning",
}

function getNotificationKind(
  kind: Kind
):
  | typeof KIND.negative
  | typeof KIND.info
  | typeof KIND.positive
  | typeof KIND.warning {
  switch (kind) {
    case Kind.ERROR:
      return KIND.negative
    case Kind.INFO:
      return KIND.info
    case Kind.SUCCESS:
      return KIND.positive
    case Kind.WARNING:
      return KIND.warning
    default:
      throw new Error(`Unexpected alert type: ${kind}`)
  }
}

export interface AlertContainerProps {
  width?: number
  kind: Kind
  children: ReactNode
}

/**
 * Provides Base Styles for any Alert Type UI. Used in the following cases:
 *   * Alert is the Streamlit specific alert component that users can use with
 *     any Markdown. Users have API access to generate these.
 *   * ExceptionElement is a special type of alert that formats an exception
 *     with a stack trace provided. Users have API access to generate these.
 *   * ErrorElement is an alert for an internal exception happening in
 *     Streamlit (likely a JS exception happening at runtime). Users do NOT
 *     have API access to generate these.
 */
export default function AlertContainer({
  kind,
  width,
  children,
}: AlertContainerProps): ReactElement {
  const theme: EmotionTheme = useTheme()

  const testid = kind.charAt(0).toUpperCase() + kind.slice(1)
  return (
    <Notification
      kind={getNotificationKind(kind)}
      overrides={{
        Body: {
          style: {
            marginTop: theme.spacing.none,
            marginBottom: theme.spacing.none,
            marginLeft: theme.spacing.none,
            marginRight: theme.spacing.none,
            width: width ? width.toString() : undefined,
            border: 0,
            borderTopRightRadius: theme.radii.default,
            borderBottomRightRadius: theme.radii.default,
            borderTopLeftRadius: theme.radii.default,
            borderBottomLeftRadius: theme.radii.default,
            paddingTop: theme.spacing.lg,
            paddingBottom: theme.spacing.lg,
            paddingRight: theme.spacing.lg,
            paddingLeft: theme.spacing.lg,
          },
          props: {
            "data-testid": "stAlertContainer",
            className: `stAlertContainer`,
          },
        },
        InnerContainer: {
          style: {
            width: "100%",
            lineHeight: theme.lineHeights.small,
          },
        },
      }}
    >
      <StyledAlertContent data-testid={`stAlertContent${testid}`}>
        {children}
      </StyledAlertContent>
    </Notification>
  )
}


================================================
File: /frontend/lib/src/components/shared/AlertContainer/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default, Kind } from "./AlertContainer"


================================================
File: /frontend/lib/src/components/shared/AlertContainer/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export const StyledAlertContent = styled.div(({ theme }) => ({
  pre: {
    backgroundColor: theme.colors.transparent,
    paddingTop: theme.spacing.lg,
    paddingBottom: theme.spacing.lg,
    paddingRight: theme.spacing.lg,
    paddingLeft: theme.spacing.lg,
    border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,

    "pre, code": {
      backgroundColor: theme.colors.transparent,
      color: "inherit",
    },
  },

  code: {
    backgroundColor: theme.colors.transparent,
    padding: theme.spacing.none,
  },

  "pre, code": {
    color: "inherit",
  },

  a: {
    color: "inherit",
    textDecoration: "underline",
  },
}))


================================================
File: /frontend/lib/src/components/shared/BaseButton/BaseButton.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { lightTheme } from "@streamlit/lib/src/theme"

import BaseButton, {
  BaseButtonKind,
  BaseButtonProps,
  BaseButtonSize,
} from "./BaseButton"

const getProps = (
  propOverrides: Partial<BaseButtonProps> = {}
): BaseButtonProps => ({
  kind: BaseButtonKind.SECONDARY,
  size: BaseButtonSize.MEDIUM,
  onClick: () => {},
  disabled: false,
  fluidWidth: false,
  children: null,
  ...propOverrides,
})

describe("Button element", () => {
  Object.keys(BaseButtonKind).forEach(key => {
    const kind: BaseButtonKind =
      BaseButtonKind[key as keyof typeof BaseButtonKind]

    it(`renders ${kind} buttons correctly`, () => {
      render(<BaseButton {...getProps({ kind })}>Hello</BaseButton>)

      const buttonWidget = screen.getByTestId(`stBaseButton-${kind}`)

      expect(buttonWidget).toBeInTheDocument()
    })

    it(`renders disabled ${kind} correctly`, () => {
      render(
        <BaseButton {...getProps({ kind, disabled: true })}>Hello</BaseButton>
      )

      const buttonWidget = screen.getByTestId(`stBaseButton-${kind}`)
      expect(buttonWidget).toBeDisabled()
    })
  })

  Object.keys(BaseButtonSize).forEach(key => {
    const size: BaseButtonSize =
      BaseButtonSize[key as keyof typeof BaseButtonSize]

    it(`renders ${size} buttons correctly`, () => {
      render(<BaseButton {...getProps({ size })}>Hello</BaseButton>)

      const { spacing } = lightTheme.emotion
      const expectedPadding = {
        [BaseButtonSize.XSMALL]: `${spacing.twoXS} ${spacing.sm}`,
        [BaseButtonSize.SMALL]: `${spacing.twoXS} ${spacing.md}`,
        [BaseButtonSize.LARGE]: `${spacing.md} ${spacing.md}`,
        [BaseButtonSize.MEDIUM]: `${spacing.xs} ${spacing.md}`,
      }

      const buttonWidget = screen.getByRole("button")
      expect(buttonWidget).toHaveStyle(`padding: ${expectedPadding[size]}`)
    })
  })

  it("renders disabled buttons correctly", () => {
    render(<BaseButton {...getProps({ disabled: true })}>Hello</BaseButton>)

    const buttonWidget = screen.getByRole("button")
    expect(buttonWidget).toBeDisabled()
  })

  it("calls onClick when button is clicked", async () => {
    const user = userEvent.setup()
    const onClick = vi.fn()
    render(<BaseButton {...getProps({ onClick })}>Hello</BaseButton>)
    const buttonWidget = screen.getByRole("button")
    await user.click(buttonWidget)

    expect(onClick).toHaveBeenCalled()
  })

  it("does not use container width by default", () => {
    render(<BaseButton {...getProps()}>Hello</BaseButton>)

    const buttonWidget = screen.getByRole("button")
    expect(buttonWidget).toHaveStyle("width: auto")
  })

  it("renders use container width buttons correctly", () => {
    render(<BaseButton {...getProps({ fluidWidth: true })}>Hello</BaseButton>)

    const buttonWidget = screen.getByRole("button")
    expect(buttonWidget).toHaveStyle("width: 100%")
  })

  it("renders use container width buttons correctly when explicit width passed", () => {
    // Fluid width is a number when the button has a help tooltip
    // (need to pass explicit width down otherwise tooltip breaks use_container_width=True)
    render(<BaseButton {...getProps({ fluidWidth: 250 })}>Hello</BaseButton>)

    const buttonWidget = screen.getByRole("button")
    expect(buttonWidget).toHaveStyle("width: 250px")
  })
})


================================================
File: /frontend/lib/src/components/shared/BaseButton/BaseButton.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import {
  BaseButtonKind,
  BaseButtonProps as BaseButtonPropsT,
  BaseButtonSize,
  StyledBorderlessIconButton,
  StyledBorderlessIconButtonActive,
  StyledElementToolbarButton,
  StyledGhostButton,
  StyledHeaderButton,
  StyledHeaderNoPaddingButton,
  StyledIconButton,
  StyledLinkButton,
  StyledMinimalButton,
  StyledPillsButton,
  StyledPillsButtonActive,
  StyledPrimaryButton,
  StyledPrimaryFormSubmitButton,
  StyledSecondaryButton,
  StyledSecondaryFormSubmitButton,
  StyledSegmentedControlButton,
  StyledSegmentedControlButtonActive,
  StyledTertiaryButton,
  StyledTertiaryFormSubmitButton,
} from "./styled-components"

function BaseButton(props: Readonly<BaseButtonPropsT>): ReactElement {
  const { kind, size, disabled, onClick, fluidWidth, children, autoFocus } =
    props

  let ComponentType = StyledPrimaryButton

  if (kind === BaseButtonKind.SECONDARY) {
    ComponentType = StyledSecondaryButton
  } else if (kind === BaseButtonKind.TERTIARY) {
    ComponentType = StyledTertiaryButton
  } else if (kind === BaseButtonKind.GHOST) {
    ComponentType = StyledGhostButton
  } else if (kind === BaseButtonKind.LINK) {
    ComponentType = StyledLinkButton
  } else if (kind === BaseButtonKind.ICON) {
    ComponentType = StyledIconButton
  } else if (kind === BaseButtonKind.PILLS) {
    ComponentType = StyledPillsButton
  } else if (kind === BaseButtonKind.PILLS_ACTIVE) {
    ComponentType = StyledPillsButtonActive
  } else if (kind === BaseButtonKind.SEGMENTED_CONTROL) {
    ComponentType = StyledSegmentedControlButton
  } else if (kind === BaseButtonKind.SEGMENTED_CONTROL_ACTIVE) {
    ComponentType = StyledSegmentedControlButtonActive
  } else if (kind === BaseButtonKind.BORDERLESS_ICON) {
    ComponentType = StyledBorderlessIconButton
  } else if (kind === BaseButtonKind.BORDERLESS_ICON_ACTIVE) {
    ComponentType = StyledBorderlessIconButtonActive
  } else if (kind === BaseButtonKind.MINIMAL) {
    ComponentType = StyledMinimalButton
  } else if (kind === BaseButtonKind.PRIMARY_FORM_SUBMIT) {
    ComponentType = StyledPrimaryFormSubmitButton
  } else if (kind === BaseButtonKind.SECONDARY_FORM_SUBMIT) {
    ComponentType = StyledSecondaryFormSubmitButton
  } else if (kind === BaseButtonKind.TERTIARY_FORM_SUBMIT) {
    ComponentType = StyledTertiaryFormSubmitButton
  } else if (kind === BaseButtonKind.HEADER_BUTTON) {
    ComponentType = StyledHeaderButton
  } else if (kind === BaseButtonKind.HEADER_NO_PADDING) {
    ComponentType = StyledHeaderNoPaddingButton
  } else if (kind === BaseButtonKind.ELEMENT_TOOLBAR) {
    ComponentType = StyledElementToolbarButton
  }

  return (
    <ComponentType
      kind={kind}
      size={size ?? BaseButtonSize.MEDIUM}
      fluidWidth={fluidWidth || false}
      disabled={disabled || false}
      onClick={onClick || (() => {})}
      autoFocus={autoFocus || false}
      data-testid={props["data-testid"] ?? `stBaseButton-${kind}`}
      aria-label={props["aria-label"] ?? ""}
    >
      {children}
    </ComponentType>
  )
}
export type BaseButtonProps = BaseButtonPropsT
export { BaseButtonKind, BaseButtonSize }
export default BaseButton


================================================
File: /frontend/lib/src/components/shared/BaseButton/BaseButtonTooltip.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"

import { StyledTooltipMobile, StyledTooltipNormal } from "./styled-components"

interface Props {
  children: ReactElement
  help?: string
  placement?: Placement
}

export function BaseButtonTooltip({
  children,
  help,
  placement,
}: Props): ReactElement {
  if (!help) {
    return children
  }
  return (
    <>
      <StyledTooltipNormal>
        <TooltipIcon content={help} placement={placement || Placement.TOP}>
          {children}
        </TooltipIcon>
      </StyledTooltipNormal>
      <StyledTooltipMobile>{children}</StyledTooltipMobile>
    </>
  )
}


================================================
File: /frontend/lib/src/components/shared/BaseButton/DynamicButtonLabel.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"

import {
  DynamicButtonLabel,
  DynamicButtonLabelProps,
} from "./DynamicButtonLabel"

const getProps = (
  propOverrides: Partial<DynamicButtonLabelProps> = {}
): DynamicButtonLabelProps => ({
  icon: "",
  label: "Button Label",
  ...propOverrides,
})

describe("DynamicButtonLabel", () => {
  it("renders without crashing", () => {
    render(<DynamicButtonLabel {...getProps()} />)
    const buttonLabel = screen.getByText("Button Label")
    expect(buttonLabel).toBeInTheDocument()
  })

  it("renders label with no icon", () => {
    render(<DynamicButtonLabel {...getProps({ icon: "" })} />)
    expect(screen.getByTestId("stMarkdownContainer")).toHaveTextContent(
      "Button Label"
    )
    expect(screen.queryByTestId("stIconEmoji")).toBeNull()
  })

  it("renders icon with no label", () => {
    render(<DynamicButtonLabel {...getProps({ label: "" })} />)
    expect(screen.getByTestId("stIconEmoji")).toHaveTextContent("")
    expect(screen.queryByTestId("stMarkdownContainer")).toBeNull()
  })

  it("renders an emoji icon", () => {
    render(<DynamicButtonLabel {...getProps()} />)

    const icon = screen.getByTestId("stIconEmoji")
    expect(icon).toHaveTextContent("")
  })

  it("renders a material icon", () => {
    render(
      <DynamicButtonLabel {...getProps({ icon: ":material/thumb_up:" })} />
    )

    const icon = screen.getByTestId("stIconMaterial")
    expect(icon).toHaveTextContent("thumb_up")
  })

  it("renders icon with no margin, if there is no label", () => {
    render(<DynamicButtonLabel {...getProps({ label: "" })} />)

    expect(screen.getByTestId("stIconEmoji")).toHaveStyle("margin: 0")
  })
})


================================================
File: /frontend/lib/src/components/shared/BaseButton/DynamicButtonLabel.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { DynamicIcon } from "@streamlit/lib/src/components/shared/Icon"
import StreamlitMarkdown from "@streamlit/lib/src/components/shared/StreamlitMarkdown"
import { IconSize } from "@streamlit/lib/src/theme"

export interface DynamicButtonLabelProps {
  icon?: string
  label?: string
  iconSize?: IconSize
}

export const DynamicButtonLabel = ({
  icon,
  label,
  iconSize,
}: DynamicButtonLabelProps): React.ReactElement | null => {
  const isMaterialIcon = icon?.startsWith(":material")
  const iconMargin = isMaterialIcon ? "0 sm 0 0" : "0 md 0 0"
  // Material icons need to be larger to render similar size of emojis, emojis need addtl margin
  const dynamicIconSize = iconSize ?? (isMaterialIcon ? "lg" : "base")

  return (
    <>
      {icon && (
        <DynamicIcon
          size={dynamicIconSize}
          margin={label ? iconMargin : "0"}
          color="inherit"
          iconValue={icon}
        />
      )}
      {label && (
        <StreamlitMarkdown
          source={label}
          allowHTML={false}
          isLabel
          largerLabel
          disableLinks
        />
      )}
    </>
  )
}


================================================
File: /frontend/lib/src/components/shared/BaseButton/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { BaseButtonProps as BaseButtonPropsT } from "./BaseButton"

export { DynamicButtonLabel } from "./DynamicButtonLabel"
export { default, BaseButtonKind, BaseButtonSize } from "./BaseButton"
export { BaseButtonTooltip as BaseButtonTooltip } from "./BaseButtonTooltip"
export type BaseButtonProps = BaseButtonPropsT


================================================
File: /frontend/lib/src/components/shared/BaseButton/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { MouseEvent, ReactNode } from "react"

import styled, { CSSObject } from "@emotion/styled"
import { darken, transparentize } from "color2k"

import { EmotionTheme } from "@streamlit/lib/src/theme"

export enum BaseButtonKind {
  PRIMARY = "primary",
  SECONDARY = "secondary",
  TERTIARY = "tertiary",
  GHOST = "ghost",
  LINK = "link",
  ICON = "icon",
  BORDERLESS_ICON = "borderlessIcon",
  BORDERLESS_ICON_ACTIVE = "borderlessIconActive",
  MINIMAL = "minimal",
  PRIMARY_FORM_SUBMIT = "primaryFormSubmit",
  SECONDARY_FORM_SUBMIT = "secondaryFormSubmit",
  TERTIARY_FORM_SUBMIT = "tertiaryFormSubmit",
  HEADER_BUTTON = "header",
  HEADER_NO_PADDING = "headerNoPadding",
  ELEMENT_TOOLBAR = "elementToolbar",
  PILLS = "pills",
  PILLS_ACTIVE = "pillsActive",
  SEGMENTED_CONTROL = "segmented_control",
  SEGMENTED_CONTROL_ACTIVE = "segmented_controlActive",
}

export enum BaseButtonSize {
  XSMALL = "xsmall",
  SMALL = "small",
  MEDIUM = "medium",
  LARGE = "large",
}

export interface BaseButtonProps {
  kind: BaseButtonKind
  size?: BaseButtonSize
  onClick?: (event: MouseEvent<HTMLButtonElement>) => any
  disabled?: boolean
  // If true or number, the button should take up container's full width
  fluidWidth?: boolean | number
  children: ReactNode
  autoFocus?: boolean
  "data-testid"?: string
  "aria-label"?: string
}

type RequiredBaseButtonProps = Required<BaseButtonProps>

function getSizeStyle(size: BaseButtonSize, theme: EmotionTheme): CSSObject {
  switch (size) {
    case BaseButtonSize.XSMALL:
      return {
        padding: `${theme.spacing.twoXS} ${theme.spacing.sm}`,
        fontSize: theme.fontSizes.sm,
      }
    case BaseButtonSize.SMALL:
      return {
        padding: `${theme.spacing.twoXS} ${theme.spacing.md}`,
      }
    case BaseButtonSize.LARGE:
      return {
        padding: `${theme.spacing.md} ${theme.spacing.md}`,
      }
    default:
      return {
        padding: `${theme.spacing.xs} ${theme.spacing.md}`,
      }
  }
}

export const StyledBaseButton = styled.button<RequiredBaseButtonProps>(
  ({ fluidWidth, size, theme }) => {
    const buttonWidth =
      typeof fluidWidth == "number" ? `${fluidWidth}px` : "100%"

    return {
      display: "inline-flex",
      alignItems: "center",
      justifyContent: "center",
      fontWeight: theme.fontWeights.normal,
      padding: `${theme.spacing.xs} ${theme.spacing.md}`,
      borderRadius: theme.radii.default,
      minHeight: theme.sizes.minElementHeight,
      margin: theme.spacing.none,
      lineHeight: theme.lineHeights.base,
      textTransform: "none",
      fontSize: "inherit",
      fontFamily: "inherit",
      color: "inherit",
      width: fluidWidth ? buttonWidth : "auto",
      cursor: "pointer",
      userSelect: "none",
      "&:focus": {
        outline: "none",
      },
      "&:focus-visible": {
        boxShadow: `0 0 0 0.2rem ${transparentize(theme.colors.primary, 0.5)}`,
      },
      ...getSizeStyle(size, theme),
    }
  }
)

export const StyledPrimaryButton = styled(
  StyledBaseButton
)<RequiredBaseButtonProps>(({ theme }) => ({
  backgroundColor: theme.colors.primary,
  color: theme.colors.white,
  border: `${theme.sizes.borderWidth} solid ${theme.colors.primary}`,
  "&:hover": {
    backgroundColor: darken(theme.colors.primary, 0.05),
  },
  "&:active": {
    backgroundColor: "transparent",
    color: theme.colors.primary,
  },
  "&:disabled, &:disabled:hover, &:disabled:active": {
    borderColor: theme.colors.borderColor,
    backgroundColor: theme.colors.transparent,
    color: theme.colors.fadedText40,
    cursor: "not-allowed",
  },
}))

export const StyledSecondaryButton = styled(
  StyledBaseButton
)<RequiredBaseButtonProps>(({ theme }) => ({
  backgroundColor: theme.colors.lightenedBg05,
  border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
  "&:hover": {
    borderColor: theme.colors.primary,
    color: theme.colors.primary,
  },
  "&:active": {
    color: theme.colors.white,
    borderColor: theme.colors.primary,
    backgroundColor: theme.colors.primary,
  },
  "&:focus:not(:active)": {
    borderColor: theme.colors.primary,
    color: theme.colors.primary,
  },
  "&:disabled, &:disabled:hover, &:disabled:active": {
    borderColor: theme.colors.borderColor,
    backgroundColor: theme.colors.transparent,
    color: theme.colors.fadedText40,
    cursor: "not-allowed",
  },
}))

export const StyledTertiaryButton = styled(
  StyledBaseButton
)<RequiredBaseButtonProps>(({ theme }) => {
  return {
    padding: theme.spacing.none,
    backgroundColor: theme.colors.transparent,
    border: "none",

    "&:active": {
      color: theme.colors.primary,
    },
    "&:focus": {
      outline: "none",
    },
    "&:focus-visible": {
      color: theme.colors.primary,
      boxShadow: `0 0 0 0.2rem ${transparentize(theme.colors.primary, 0.5)}`,
    },
    "&:hover": {
      color: theme.colors.primary,
    },
    "&:disabled, &:disabled:hover, &:disabled:active": {
      backgroundColor: theme.colors.transparent,
      color: theme.colors.fadedText40,
      cursor: "not-allowed",
    },
  }
})

export const StyledGhostButton = styled(
  StyledBaseButton
)<RequiredBaseButtonProps>(({ theme }) => ({
  backgroundColor: theme.colors.transparent,
  border: `${theme.sizes.borderWidth} solid ${theme.colors.transparent}`,
  "&:hover": {
    borderColor: theme.colors.transparent,
    color: theme.colors.primary,
  },
  "&:active": {
    color: theme.colors.primary,
    borderColor: theme.colors.transparent,
    backgroundColor: theme.colors.transparent,
  },
  "&:focus:not(:active)": {
    borderColor: theme.colors.transparent,
    color: theme.colors.primary,
  },
  "&:disabled, &:disabled:hover, &:disabled:active": {
    backgroundColor: theme.colors.lightGray,
    borderColor: theme.colors.transparent,
    color: theme.colors.gray,
  },
}))

export const StyledLinkButton = styled(
  StyledBaseButton
)<RequiredBaseButtonProps>(({ theme }) => ({
  backgroundColor: theme.colors.transparent,
  padding: theme.spacing.none,
  border: "none",
  color: theme.colors.primary,
  "&:hover": {
    textDecoration: "underline",
  },
  "&:active": {
    backgroundColor: theme.colors.transparent,
    color: theme.colors.primary,
    textDecoration: "underline",
  },
  "&:disabled, &:disabled:hover, &:disabled:active": {
    backgroundColor: theme.colors.lightGray,
    borderColor: theme.colors.transparent,
    color: theme.colors.gray,
  },
}))

export const StyledMinimalButton = styled(
  StyledBaseButton
)<RequiredBaseButtonProps>(({ theme }) => ({
  backgroundColor: theme.colors.transparent,
  border: "none",
  boxShadow: "none",
  padding: theme.spacing.none,
  "&:hover, &:active, &:focus-visible": {
    color: theme.colors.primary,
  },
}))

export const StyledPrimaryFormSubmitButton =
  styled(StyledPrimaryButton)<RequiredBaseButtonProps>()

export const StyledSecondaryFormSubmitButton = styled(
  StyledSecondaryButton
)<RequiredBaseButtonProps>()

export const StyledTertiaryFormSubmitButton = styled(
  StyledTertiaryButton
)<RequiredBaseButtonProps>()

export const StyledIconButton = styled(
  StyledBaseButton
)<RequiredBaseButtonProps>(({ theme }) => {
  return {
    backgroundColor: theme.colors.transparent,
    border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
    flex: "1 1 0",
    padding: 0,

    "&:hover": {
      borderColor: theme.colors.primary,
      color: theme.colors.primary,
    },
    "&:active": {
      backgroundColor: theme.colors.primary,
      borderColor: theme.colors.primary,
      color: theme.colors.white,
    },
    "&:not(:active)": {
      boxShadow: "none",
    },
    "&:disabled, &:disabled:hover, &:disabled:active": {
      backgroundColor: theme.colors.lightGray,
      borderColor: theme.colors.transparent,
      color: theme.colors.gray,
      cursor: "not-allowed",
    },
  }
})

export const StyledIconButtonActive = styled(
  StyledIconButton
)<RequiredBaseButtonProps>(({ theme }) => {
  return {
    backgroundColor: theme.colors.primary,
    borderColor: theme.colors.primary,
    color: theme.colors.white,
    "&:hover": {
      backgroundColor: theme.colors.transparent,
      borderColor: theme.colors.primary,
      color: theme.colors.primary,
    },
  }
})

const StyledButtonGroupBaseButton = styled(
  StyledBaseButton
)<RequiredBaseButtonProps>(({ theme }) => {
  return {
    background: theme.colors.bgColor,
    color: theme.colors.text,
    border: `${theme.sizes.borderWidth} solid ${theme.colors.borderColor}`,
    fontSize: theme.fontSizes.sm,
    lineHeight: theme.lineHeights.base,
    fontWeight: theme.fontWeights.normal,
    height: theme.sizes.largeLogoHeight,
    minHeight: theme.sizes.largeLogoHeight,
    maxWidth: theme.sizes.contentMaxWidth,

    // show pills with long text in single line and use ellipsis for overflow
    whiteSpace: "nowrap",
    overflow: "hidden",
    textOverflow: "ellipsis",

    "&:hover": {
      borderColor: theme.colors.primary,
      color: theme.colors.primary,
    },
    "&:disabled, &:disabled:hover, &:disabled:active": {
      color: theme.colors.fadedText20,
      borderColor: theme.colors.fadedText20,
      cursor: "not-allowed",
    },

    "& div": {
      textOverflow: "ellipsis",
      overflow: "hidden",
    },
    "& p": {
      fontSize: theme.fontSizes.sm,
      textOverflow: "ellipsis",
      overflow: "hidden",
    },
  }
})

export const StyledPillsButton = styled(
  StyledButtonGroupBaseButton
)<RequiredBaseButtonProps>(({ theme }) => {
  return {
    borderRadius: theme.radii.full,
    padding: `${theme.spacing.twoXS} ${theme.spacing.md}`,
  }
})

export const StyledPillsButtonActive = styled(
  StyledPillsButton
)<RequiredBaseButtonProps>(({ theme }) => {
  return {
    backgroundColor: transparentize(theme.colors.primary, 0.9),
    borderColor: theme.colors.primary,
    color: theme.colors.primary,
    "&:hover": {
      backgroundColor: transparentize(theme.colors.primary, 0.8),
      borderColor: theme.colors.primary,
      color: theme.colors.primary,
    },
  }
})

export const StyledSegmentedControlButton = styled(
  StyledButtonGroupBaseButton
)<RequiredBaseButtonProps>(({ theme }) => {
  return {
    padding: `${theme.spacing.twoXS} ${theme.spacing.lg}`,
    borderRadius: "0",
    flex: "1 0 fit-content",
    maxWidth: "100%",
    marginRight: `-${theme.sizes.borderWidth}`, // Add negative margin to overlap borders

    "&:first-child": {
      borderTopLeftRadius: theme.radii.default,
      borderBottomLeftRadius: theme.radii.default,
    },
    "&:last-child": {
      borderTopRightRadius: theme.radii.default,
      borderBottomRightRadius: theme.radii.default,
      marginRight: theme.spacing.none, // Reset margin for the last child
    },
    "&:hover": {
      zIndex: theme.zIndices.priority, // Make sure overlapped borders are visible
    },
  }
})

export const StyledSegmentedControlButtonActive = styled(
  StyledSegmentedControlButton
)<RequiredBaseButtonProps>(({ theme }) => {
  return {
    backgroundColor: transparentize(theme.colors.primary, 0.9),
    borderColor: theme.colors.primary,
    color: theme.colors.primary,
    zIndex: theme.zIndices.priority,
    "&:hover": {
      backgroundColor: transparentize(theme.colors.primary, 0.8),
    },
  }
})

export const StyledHeaderButton = styled(
  StyledBaseButton
)<RequiredBaseButtonProps>(({ theme }) => {
  return {
    backgroundColor: theme.colors.transparent,
    border: "none",
    padding: theme.spacing.sm,
    fontSize: theme.fontSizes.sm,
    marginLeft: theme.spacing.threeXS,
    marginRight: theme.spacing.threeXS,

    lineHeight: theme.lineHeights.none,

    // Override buttons min width and height, to ensure the hover state for icon buttons on the header is square
    minWidth: theme.spacing.threeXL,
    minHeight: theme.spacing.threeXL,

    "&:focus": {
      outline: "none",
    },
    "&:focus-visible": {
      boxShadow: `0 0 0 0.2rem ${transparentize(theme.colors.gray90, 0.8)}`,
    },
    "&:hover": {
      backgroundColor: theme.colors.darkenedBgMix25,
    },
    "&:disabled, &:disabled:hover, &:disabled:active": {
      backgroundColor: theme.colors.lightGray,
      borderColor: theme.colors.transparent,
      color: theme.colors.gray,
    },
  }
})

// Take out padding for this specific button, so we can ensure it's 32x32px like other buttons in Community Cloud
export const StyledHeaderNoPaddingButton = styled(
  StyledHeaderButton
)<RequiredBaseButtonProps>(() => {
  return {
    padding: 0,
  }
})

export const StyledBorderlessIconButton = styled(
  StyledBaseButton
)<RequiredBaseButtonProps>(({ size, theme }) => {
  const iconPadding: Record<BaseButtonSize, string> = {
    [BaseButtonSize.XSMALL]: theme.spacing.threeXS,
    [BaseButtonSize.SMALL]: theme.spacing.twoXS,
    [BaseButtonSize.MEDIUM]: theme.spacing.md,
    [BaseButtonSize.LARGE]: theme.spacing.lg,
  }

  return {
    backgroundColor: theme.colors.transparent,
    color: theme.colors.fadedText60,
    padding: iconPadding[size],
    marginLeft: theme.spacing.none,
    marginRight: theme.spacing.none,

    border: "none",
    display: "flex",
    minHeight: "unset",

    "&:focus": {
      boxShadow: "none",
      outline: "none",
    },
    "&:hover": {
      color: theme.colors.text,
    },
    "&:disabled, &:disabled:hover, &:disabled:active": {
      color: theme.colors.fadedText10,
      cursor: "not-allowed",

      // For image content
      img: {
        opacity: 0.4,
      },
    },
  }
})

export const StyledBorderlessIconButtonActive = styled(
  StyledBorderlessIconButton
)<RequiredBaseButtonProps>(({ theme }) => {
  return {
    color: theme.colors.bodyText,
    "&:disabled, &:disabled:hover, &:disabled:active": {
      color: theme.colors.fadedText40,
    },
  }
})

export const StyledTooltipNormal = styled.div(({ theme }) => ({
  display: "block",
  [`@media (max-width: ${theme.breakpoints.sm})`]: {
    display: "none",
  },
}))

export const StyledTooltipMobile = styled.div(({ theme }) => ({
  display: "none",
  [`@media (max-width: ${theme.breakpoints.sm})`]: {
    display: "block",
  },
}))

export const StyledElementToolbarButton = styled(
  StyledBaseButton
)<RequiredBaseButtonProps>(({ theme }) => {
  return {
    backgroundColor: theme.colors.transparent,
    border: "none",
    padding: theme.spacing.xs,
    fontSize: theme.fontSizes.twoSm,
    marginLeft: theme.spacing.none,
    marginRight: theme.spacing.none,
    display: "flex",
    gap: theme.spacing.xs,
    alignItems: "center",
    minHeight: "unset",
    // line height should be the same as the icon size
    lineHeight: theme.iconSizes.md,

    "&:focus": {
      outline: "none",
      border: "none",
      boxShadow: "none",
    },
    "&:focus-visible": {
      outline: "none",
      border: "none",
      boxShadow: "none",
      backgroundColor: theme.colors.darkenedBgMix25,
    },
    "&:hover": {
      backgroundColor: theme.colors.darkenedBgMix25,
    },
    "&:disabled, &:disabled:hover, &:disabled:active": {
      backgroundColor: theme.colors.lightGray,
      borderColor: theme.colors.transparent,
      color: theme.colors.gray,
    },
  }
})


================================================
File: /frontend/lib/src/components/shared/BaseColorPicker/BaseColorPicker.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { fireEvent, screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { LabelVisibilityOptions } from "@streamlit/lib/src/util/utils"

import BaseColorPicker, { BaseColorPickerProps } from "./BaseColorPicker"

const getProps = (
  props: Partial<BaseColorPickerProps> = {}
): BaseColorPickerProps => ({
  label: "Label",
  value: "#000000",
  width: 0,
  disabled: false,
  onChange: vi.fn(),
  ...props,
})

describe("ColorPicker widget", () => {
  it("renders without crashing", () => {
    const props = getProps()
    render(<BaseColorPicker {...props} />)
    const colorPicker = screen.getByTestId("stColorPicker")
    expect(colorPicker).toBeInTheDocument()
    expect(colorPicker).toHaveClass("stColorPicker")
  })

  it("should render a label in the title", () => {
    const props = getProps()
    render(<BaseColorPicker {...props} />)
    const widgetLabel = screen.queryByText(`${props.label}`)
    expect(widgetLabel).toBeInTheDocument()
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when hidden", () => {
    const props = getProps({
      labelVisibility: LabelVisibilityOptions.Hidden,
    })
    render(<BaseColorPicker {...props} />)

    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle(
      "visibility: hidden"
    )
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when collapsed", () => {
    const props = getProps({
      labelVisibility: LabelVisibilityOptions.Collapsed,
    })
    render(<BaseColorPicker {...props} />)

    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle("display: none")
  })

  it("should have correct style", () => {
    const props = getProps()
    render(<BaseColorPicker {...props} />)
    const colorPicker = screen.getByTestId("stColorPicker")

    expect(colorPicker).toHaveStyle(`width: ${props.width}px`)
  })

  it("should render a default color in the preview and the color picker", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<BaseColorPicker {...props} />)

    const colorBlock = screen.getByTestId("stColorPickerBlock")
    await user.click(colorBlock)

    expect(colorBlock).toHaveStyle("background-color: #000000")

    const colorInput = screen.getByRole("textbox")
    expect(colorInput).toHaveValue("#000000")
  })

  it("supports hex shorthand", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<BaseColorPicker {...props} />)

    const colorBlock = screen.getByTestId("stColorPickerBlock")
    await user.click(colorBlock)

    const colorInput = screen.getByRole("textbox")
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.change(colorInput, { target: { value: "#333" } })

    expect(colorInput).toHaveValue("#333333")
    expect(colorBlock).toHaveStyle("background-color: #333333")
  })

  it("should update the widget value when it's changed", async () => {
    const user = userEvent.setup()
    const props = getProps()
    render(<BaseColorPicker {...props} />)

    const newColor = "#E91E63"
    const colorBlock = screen.getByTestId("stColorPickerBlock")
    await user.click(colorBlock)

    const colorInput = screen.getByRole("textbox")
    await user.clear(colorInput)
    await user.type(colorInput, newColor)

    expect(colorInput).toHaveValue(newColor)
    expect(colorBlock).toHaveStyle(`background-color: ${newColor}`)
  })

  describe("ColorPicker widget with optional params", () => {
    it("renders with showValue", () => {
      const props = getProps({ showValue: true })
      render(<BaseColorPicker {...props} />)
      const colorLabel = screen.getByText("#000000")
      expect(colorLabel).toBeInTheDocument()
    })

    it("renders without showValue", () => {
      const props = getProps()
      render(<BaseColorPicker {...props} />)
      const colorLabel = screen.queryByText("#000000")
      expect(colorLabel).not.toBeInTheDocument()
    })

    it("should render TooltipIcon if help text provided", () => {
      const props = getProps({ help: "help text" })
      render(<BaseColorPicker {...props} />)
      const tooltipIcon = screen.getByTestId("stTooltipIcon")
      expect(tooltipIcon).toBeInTheDocument()
    })
  })
})


================================================
File: /frontend/lib/src/components/shared/BaseColorPicker/BaseColorPicker.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { StatefulPopover as UIPopover } from "baseui/popover"
import { ChromePicker, ColorResult } from "react-color"

import {
  StyledWidgetLabelHelpInline,
  WidgetLabel,
} from "@streamlit/lib/src/components/widgets/BaseWidget"
import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"
import { LabelVisibilityOptions } from "@streamlit/lib/src/util/utils"
import { logWarning } from "@streamlit/lib/src/util/log"

import {
  StyledChromePicker,
  StyledColorBlock,
  StyledColorPicker,
  StyledColorPreview,
  StyledColorValue,
} from "./styled-components"

export interface BaseColorPickerProps {
  disabled: boolean
  width?: number
  value: string
  showValue?: boolean
  label: string
  labelVisibility?: LabelVisibilityOptions
  onChange: (value: string) => any
  help?: string
}

interface State {
  /**
   * The value specified by the user via the UI. If the user didn't touch this
   * widget's UI, the default value is used.
   */
  value: string
}

class BaseColorPicker extends React.PureComponent<
  BaseColorPickerProps,
  State
> {
  public state: State = {
    value: this.props.value,
  }

  public componentDidUpdate(prevProps: BaseColorPickerProps): void {
    if (
      prevProps.value !== this.props.value &&
      this.props.value !== this.state.value
    ) {
      this.setState((_, prevProps) => {
        return { value: prevProps.value }
      })
    }
  }

  // Note: This is a "local" onChange handler used to update the color preview
  // (allowing the user to click and drag). this.props.onChange is only called
  // when the ColorPicker popover is closed.
  private onColorChange = (color: ColorResult): void => {
    this.setState({ value: color.hex })
  }

  private onColorClose = (): void => {
    this.props.onChange(this.state.value)
  }

  // eslint-disable-next-line class-methods-use-this
  public componentDidCatch(error: Error): void {
    if (error?.name === "SecurityError") {
      // 2021.06.30 - on Streamlit Sharing, ColorPicker throws a cross-origin
      // error when its popover window is closed. There's an issue open in the
      // react-color repo https://github.com/casesandberg/react-color/issues/806 -
      // but it's months old and hasn't had a developer response.
      logWarning(
        `Swallowing ColorPicker SecurityError '${error.name}: ${error.message}'`
      )

      // We force an update after this error, to re-mount the UIPopover -
      // because the error sometimes cause it to be unmounted. This is an
      // unfortunate hack.
      this.forceUpdate()
    } else {
      throw error
    }
  }

  public render(): React.ReactNode {
    const { width, showValue, label, labelVisibility, help, disabled } =
      this.props
    const { value } = this.state

    return (
      <StyledColorPicker
        className="stColorPicker"
        data-testid="stColorPicker"
        width={width}
        disabled={disabled}
      >
        <WidgetLabel
          label={label}
          disabled={disabled}
          labelVisibility={labelVisibility}
        >
          {help && (
            <StyledWidgetLabelHelpInline>
              <TooltipIcon content={help} placement={Placement.TOP_RIGHT} />
            </StyledWidgetLabelHelpInline>
          )}
        </WidgetLabel>
        <UIPopover
          onClose={this.onColorClose}
          content={() => (
            <StyledChromePicker data-testid="stColorPickerPopover">
              <ChromePicker
                color={value}
                onChange={this.onColorChange}
                disableAlpha={true}
              />
            </StyledChromePicker>
          )}
        >
          <StyledColorPreview disabled={disabled}>
            <StyledColorBlock
              data-testid="stColorPickerBlock"
              backgroundColor={value}
              disabled={disabled}
            />
            {showValue && (
              <StyledColorValue>{value.toUpperCase()}</StyledColorValue>
            )}
          </StyledColorPreview>
        </UIPopover>
      </StyledColorPicker>
    )
  }
}

export default BaseColorPicker


================================================
File: /frontend/lib/src/components/shared/BaseColorPicker/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default } from "./BaseColorPicker"


================================================
File: /frontend/lib/src/components/shared/BaseColorPicker/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import styled from "@emotion/styled"

export interface StyledColorPickerProps {
  disabled: boolean
  width: number | undefined
}

export const StyledColorPicker = styled.div<StyledColorPickerProps>(
  ({ disabled, width, theme }) => ({
    fontFamily: theme.genericFonts.bodyFont,
    display: "flex",
    flexDirection: "column",
    alignItems: "flex-start",
    cursor: disabled ? "not-allowed" : "default",
    width,
  })
)

// We need this to override the default font-family: 'Menlo' rule,
// Which causes the font to change to a serif one in Windows
export const StyledChromePicker = styled.div(({ theme }) => ({
  div: {
    fontFamily: `${theme.genericFonts.bodyFont} !important`,
  },
}))

export interface StyledColorPreviewProps {
  disabled: boolean
}

export const StyledColorPreview = styled.div<StyledColorPreviewProps>(
  ({ disabled, theme }) => ({
    height: theme.sizes.minElementHeight,
    borderRadius: theme.radii.default,
    borderColor: theme.colors.borderColor,
    cursor: disabled ? "not-allowed" : "pointer",
    pointerEvents: disabled ? "none" : "auto",
    boxShadow: "none",
    lineHeight: theme.lineHeights.base,
    gap: theme.spacing.md,
    "&:focus": {
      outline: "none",
    },
    display: "flex",
  })
)

export interface StyledColorBlockProps {
  disabled: boolean
  backgroundColor: string
}

export const StyledColorBlock = styled.div<StyledColorBlockProps>(
  ({ backgroundColor, disabled, theme }) => ({
    width: theme.sizes.minElementHeight,
    height: theme.sizes.minElementHeight,
    borderRadius: theme.radii.default,
    borderColor: theme.colors.borderColor,
    borderWidth: theme.sizes.borderWidth,
    opacity: disabled ? "0.4" : "",
    backgroundColor,
    borderStyle: "solid",
    cursor: "pointer",
    lineHeight: theme.lineHeights.base,
    "&:focus": {
      outline: "none",
    },
  })
)

export const StyledColorValue = styled.div({
  display: "flex",
  alignItems: "center",
})


================================================
File: /frontend/lib/src/components/shared/Dropdown/Selectbox.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React from "react"

import { fireEvent, screen } from "@testing-library/react"
import { userEvent } from "@testing-library/user-event"

import { render } from "@streamlit/lib/src/test_util"
import { LabelVisibilityOptions } from "@streamlit/lib/src/util/utils"
import * as Utils from "@streamlit/lib/src/theme/utils"
import { mockConvertRemToPx } from "@streamlit/lib/src/mocks/mocks"

import Selectbox, { fuzzyFilterSelectOptions, Props } from "./Selectbox"

vi.mock("@streamlit/lib/src/WidgetStateManager")

const getProps = (props: Partial<Props> = {}): Props => ({
  value: 0,
  label: "Label",
  options: ["a", "b", "c"],
  width: 0,
  disabled: false,
  onChange: vi.fn(),
  placeholder: "Select...",
  ...props,
})

describe("Selectbox widget", () => {
  let props: Props

  afterEach(() => {
    vi.restoreAllMocks()
  })

  beforeEach(() => {
    vi.spyOn(Utils, "convertRemToPx").mockImplementation(mockConvertRemToPx)
    props = getProps()
  })

  it("renders without crashing", () => {
    render(<Selectbox {...props} />)
    expect(screen.getByRole("combobox")).toBeInTheDocument()
  })

  it("has correct className and style", () => {
    render(<Selectbox {...props} />)
    const selectbox = screen.getByTestId("stSelectbox")
    expect(selectbox).toHaveClass("stSelectbox")
    expect(selectbox).toHaveStyle(`width: ${props.width}px`)
  })

  it("renders a label", () => {
    render(<Selectbox {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveTextContent(
      `${props.label}`
    )
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when hidden", () => {
    const props = getProps({
      labelVisibility: LabelVisibilityOptions.Hidden,
    })
    render(<Selectbox {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle(
      "visibility: hidden"
    )
  })

  it("pass labelVisibility prop to StyledWidgetLabel correctly when collapsed", () => {
    const props = getProps({
      labelVisibility: LabelVisibilityOptions.Collapsed,
    })
    render(<Selectbox {...props} />)
    expect(screen.getByTestId("stWidgetLabel")).toHaveStyle("display: none")
  })

  it("pass placeholder prop correctly", () => {
    props = getProps({
      value: undefined,
      placeholder: "Please select",
    })
    render(<Selectbox {...props} />)
    expect(screen.getByText("Please select")).toBeInTheDocument()
  })

  it("renders a placeholder with empty options", () => {
    props = getProps({
      options: [],
    })
    render(<Selectbox {...props} />)

    expect(screen.getByText("No options to select.")).toBeInTheDocument()
    expect(screen.getByRole("combobox")).toBeDisabled()
  })

  it("renders options", async () => {
    const user = userEvent.setup()
    render(<Selectbox {...props} />)
    const selectbox = screen.getByRole("combobox")
    await user.click(selectbox)
    const options = screen.getAllByRole("option")

    expect(options).toHaveLength(props.options.length)
    options.forEach((option, index) => {
      expect(option).toHaveTextContent(props.options[index])
    })
  })

  it("could be disabled", () => {
    props = getProps({
      disabled: true,
    })
    render(<Selectbox {...props} />)
    expect(screen.getByRole("combobox")).toBeDisabled()
  })

  it("is able to select an option", async () => {
    const user = userEvent.setup()
    render(<Selectbox {...props} />)
    const selectbox = screen.getByRole("combobox")
    // Open the dropdown
    await user.click(selectbox)
    const options = screen.getAllByRole("option")
    // TODO: Utilize user-event instead of fireEvent
    // eslint-disable-next-line testing-library/prefer-user-event
    fireEvent.click(options[2])

    expect(props.onChange).toHaveBeenCalledWith(2)
    expect(screen.getByText(props.options[2])).toBeInTheDocument()
  })

  it("doesn't filter options based on index", async () => {
    const user = userEvent.setup()
    render(<Selectbox {...props} />)

    await user.type(screen.getByRole("combobox"), "1")
    expect(screen.getByText("No results")).toBeInTheDocument()
  })

  it("filters options based on label with case insensitive", async () => {
    const user = userEvent.setup()
    render(<Selectbox {...props} />)
    const selectbox = screen.getByRole("combobox")

    await user.type(selectbox, "b")
    let options = screen.getAllByRole("option")
    expect(options).toHaveLength(1)
    expect(options[0]).toHaveTextContent("b")

    await user.clear(selectbox)
    await user.type(selectbox, "B")
    options = screen.getAllByRole("option")
    expect(options).toHaveLength(1)
    expect(options[0]).toHaveTextContent("b")
  })

  it("fuzzy filters options correctly", () => {
    // This test just makes sure the filter algorithm works correctly. The e2e
    // test actually types something in the selectbox and makes sure that it
    // shows the right options.

    const options = [
      { label: "e2e/scripts/components_iframe.py", value: "" },
      { label: "e2e/scripts/st_warning.py", value: "" },
      { label: "e2e/scripts/st_container.py", value: "" },
      { label: "e2e/scripts/st_dataframe_sort_column.py", value: "" },
      { label: "e2e/scripts/app_hotkeys.py", value: "" },
      { label: "e2e/scripts/st_info.py", value: "" },
      { label: "e2e/scripts/st_echo.py", value: "" },
      { label: "e2e/scripts/st_json.py", value: "" },
      { label: "e2e/scripts/st_experimental_get_query_params.py", value: "" },
      { label: "e2e/scripts/st_markdown.py", value: "" },
      { label: "e2e/scripts/st_color_picker.py", value: "" },
      { label: "e2e/scripts/st_expander.py", value: "" },
    ]

    const results1 = fuzzyFilterSelectOptions(options, "esstm")
    expect(results1.map(it => it.label)).toEqual([
      "e2e/scripts/st_markdown.py",
      "e2e/scripts/st_dataframe_sort_column.py",
      "e2e/scripts/st_experimental_get_query_params.py",
      "e2e/scripts/components_iframe.py",
    ])

    const results2 = fuzzyFilterSelectOptions(options, "eseg")
    expect(results2.map(it => it.label)).toEqual([
      "e2e/scripts/st_experimental_get_query_params.py",
    ])
  })

  it("updates value if new value provided from parent", () => {
    const { rerender } = render(<Selectbox {...props} />)
    // Original value passed is 0
    expect(screen.getByText(props.options[0])).toBeInTheDocument()

    props = getProps({ value: 1 })
    rerender(<Selectbox {...props} />)
    expect(screen.getByText(props.options[1])).toBeInTheDocument()
  })
})

describe("Selectbox widget with optional props", () => {
  // This goes against the previous solution to bug #3220, but that's on purpose.
  it("renders no label element if no text provided", () => {
    const props = getProps({ label: undefined })
    render(<Selectbox {...props} />)

    expect(screen.queryByTestId("stWidgetLabel")).not.toBeInTheDocument()
  })

  it("renders TooltipIcon if help text provided", () => {
    const props = getProps({ help: "help text" })
    render(<Selectbox {...props} />)

    expect(screen.getByTestId("stTooltipIcon")).toBeInTheDocument()
  })
})


================================================
File: /frontend/lib/src/components/shared/Dropdown/Selectbox.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { memo, useCallback, useEffect, useState } from "react"

import { isMobile } from "react-device-detect"
import { ChevronDown } from "baseui/icon"
import { OnChangeParams, Option, Select as UISelect } from "baseui/select"
import { useTheme } from "@emotion/react"
import { hasMatch, score } from "fzy.js"
import sortBy from "lodash/sortBy"

import VirtualDropdown from "@streamlit/lib/src/components/shared/Dropdown/VirtualDropdown"
import {
  isNullOrUndefined,
  LabelVisibilityOptions,
} from "@streamlit/lib/src/util/utils"
import { Placement } from "@streamlit/lib/src/components/shared/Tooltip"
import TooltipIcon from "@streamlit/lib/src/components/shared/TooltipIcon"
import {
  StyledWidgetLabelHelp,
  WidgetLabel,
} from "@streamlit/lib/src/components/widgets/BaseWidget"
import { EmotionTheme } from "@streamlit/lib/src/theme"

const NO_OPTIONS_MSG = "No options to select."

export interface Props {
  disabled: boolean
  width?: number
  value: number | null
  onChange: (value: number | null) => void
  options: any[]
  label?: string | null
  labelVisibility?: LabelVisibilityOptions
  help?: string
  placeholder?: string
  clearable?: boolean
}

interface SelectOption {
  label: string
  value: string
}

// Add a custom filterOptions method to filter options only based on labels.
// The baseweb default method filters based on labels or indices
// More details: https://github.com/streamlit/streamlit/issues/1010
// Also filters using fuzzy search powered by fzy.js. Automatically handles
// upper/lowercase.
export function fuzzyFilterSelectOptions(
  options: SelectOption[],
  pattern: string
): readonly SelectOption[] {
  if (!pattern) {
    return options
  }

  const filteredOptions = options.filter((opt: SelectOption) =>
    hasMatch(pattern, opt.label)
  )
  return sortBy(filteredOptions, (opt: SelectOption) =>
    score(pattern, opt.label)
  ).reverse()
}

const Selectbox: React.FC<Props> = ({
  disabled,
  width,
  value: propValue,
  onChange,
  options: propOptions,
  label,
  labelVisibility,
  help,
  placeholder,
  clearable,
}) => {
  const theme: EmotionTheme = useTheme()
  const [value, setValue] = useState<number | null>(propValue)

  // Update the value whenever the value provided by the props changes
  // TODO: Find a better way to handle this to prevent unneeded re-renders
  useEffect(() => {
    setValue(propValue)
  }, [propValue])

  const handleChange = useCallback(
    (params: OnChangeParams): void => {
      if (params.value.length === 0) {
        setValue(null)
        onChange(null)
        return
      }

      const [selected] = params.value
      const newValue = parseInt(selected.value, 10)
      setValue(newValue)
      onChange(newValue)
    },
    [onChange]
  )

  const filterOptions = useCallback(
    (options: readonly Option[], filterValue: string): readonly Option[] =>
      fuzzyFilterSelectOptions(options as SelectOption[], filterValue),
    []
  )

  let selectDisabled = disabled
  let options = propOptions

  let selectValue: Option[] = []

  if (!isNullOrUndefined(value)) {
    selectValue = [
      {
        label: options.length > 0 ? options[value] : NO_OPTIONS_MSG,
        value: value.toString(),
      },
    ]
  }

  if (options.length === 0) {
    options = [NO_OPTIONS_MSG]
    selectDisabled = true
  }

  const selectOptions: SelectOption[] = options.map(
    (option: string, index: number) => ({
      label: option,
      value: index.toString(),
    })
  )

  // Check if we have more than 10 options in the selectbox.
  // If that's true, we show the keyboard on mobile. If not, we hide it.
  const showKeyboardOnMobile = options.length > 10

  return (
    <div className="stSelectbox" data-testid="stSelectbox" style={{ width }}>
      <WidgetLabel
        label={label}
        labelVisibility={labelVisibility}
        disabled={selectDisabled}
      >
        {help && (
          <StyledWidgetLabelHelp>
            <TooltipIcon content={help} placement={Placement.TOP_RIGHT} />
          </StyledWidgetLabelHelp>
        )}
      </WidgetLabel>
      <UISelect
        disabled={selectDisabled}
        labelKey="label"
        aria-label={label || ""}
        onChange={handleChange}
        options={selectOptions}
        filterOptions={filterOptions}
        clearable={clearable || false}
        escapeClearsValue={clearable || false}
        value={selectValue}
        valueKey="value"
        placeholder={placeholder}
        overrides={{
          Root: {
            style: () => ({
              lineHeight: theme.lineHeights.inputWidget,
            }),
          },
          Dropdown: { component: VirtualDropdown },
          ClearIcon: {
            props: {
              overrides: {
                Svg: {
                  style: {
                    color: theme.colors.darkGray,
                    // Setting this width and height makes the clear-icon align with dropdown arrows
                    padding: theme.spacing.threeXS,
                    height: theme.sizes.clearIconSize,
                    width: theme.sizes.clearIconSize,
                    ":hover": {
                      fill: theme.colors.bodyText,
                    },
                  },
                },
              },
            },
          },
          ControlContainer: {
            style: () => ({
              height: theme.sizes.minElementHeight,
              // Baseweb requires long-hand props, short-hand leads to weird bugs & warnings.
              borderLeftWidth: theme.sizes.borderWidth,
              borderRightWidth: theme.sizes.borderWidth,
              borderTopWidth: theme.sizes.borderWidth,
              borderBottomWidth: theme.sizes.borderWidth,
            }),
          },
          IconsContainer: {
            style: () => ({
              paddingRight: theme.spacing.sm,
            }),
          },
          ValueContainer: {
            style: () => ({
              // Baseweb requires long-hand props, short-hand leads to weird bugs & warnings.
              paddingRight: theme.spacing.sm,
              paddingLeft: theme.spacing.sm,
              paddingBottom: theme.spacing.sm,
              paddingTop: theme.spacing.sm,
            }),
          },
          Input: {
            props: {
              // Change the 'readonly' prop to hide the mobile keyboard if options < 10
              readOnly: isMobile && !showKeyboardOnMobile ? "readonly" : null,
            },
            style: () => ({
              lineHeight: theme.lineHeights.inputWidget,
            }),
          },
          // Nudge the dropdown menu by 1px so the focus state doesn't get cut off
          Popover: {
            props: {
              overrides: {
                Body: {
                  style: () => ({
                    marginTop: theme.spacing.px,
                  }),
                },
              },
            },
          },
          SelectArrow: {
            component: ChevronDown,
            props: {
              overrides: {
                Svg: {
                  style: () => ({
                    width: theme.iconSizes.xl,
                    height: theme.iconSizes.xl,
                  }),
                },
              },
            },
          },
        }}
      />
    </div>
  )
}

export default memo(Selectbox)


================================================
File: /frontend/lib/src/components/shared/Dropdown/VirtualDropdown.test.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { screen } from "@testing-library/react"

import { render } from "@streamlit/lib/src/test_util"
import * as Utils from "@streamlit/lib/src/theme/utils"
import { mockConvertRemToPx } from "@streamlit/lib/src/mocks/mocks"

import VirtualDropdown from "./VirtualDropdown"

interface OptionProps {
  item?: { value: string }
}

function Option(props: OptionProps): ReactElement {
  return <span className={props.item ? props.item.value : "nothing"} />
}

describe("VirtualDropdown element", () => {
  afterEach(() => {
    vi.restoreAllMocks()
  })

  beforeEach(() => {
    vi.spyOn(Utils, "convertRemToPx").mockImplementation(mockConvertRemToPx)
  })

  it("renders a StyledEmptyState when it has no children", () => {
    render(<VirtualDropdown />)

    expect(
      screen.getByTestId("stSelectboxVirtualDropdownEmpty")
    ).toBeInTheDocument()
  })

  it("renders a StyledEmptyState when it has children with no item", () => {
    render(
      <VirtualDropdown>
        <Option />
      </VirtualDropdown>
    )

    expect(
      screen.getByTestId("stSelectboxVirtualDropdownEmpty")
    ).toBeInTheDocument()
  })

  it("renders a FixedSizeList when it has children", () => {
    render(
      <VirtualDropdown>
        <Option item={{ value: "abc" }} />
      </VirtualDropdown>
    )

    expect(
      screen.getByTestId("stSelectboxVirtualDropdown")
    ).toBeInTheDocument()

    // each option will have a tooltip attached to it
    expect(screen.getAllByTestId("stTooltipHoverTarget")).toHaveLength(1)
  })
})


================================================
File: /frontend/lib/src/components/shared/Dropdown/VirtualDropdown.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import React, { ReactElement } from "react"

import { OptionListProps, StyledEmptyState, StyledList } from "baseui/menu"
import { FixedSizeList } from "react-window"
import { useTheme } from "@emotion/react"

import {
  OverflowTooltip,
  Placement,
} from "@streamlit/lib/src/components/shared/Tooltip"
import { convertRemToPx } from "@streamlit/lib/src/theme/utils"

import { ThemedStyledDropdownListItem } from "./styled-components"

/*
 * A component that renders a large dropdown to render only a fixed amount of
 * options at a time. Overall, the dropdown improves performance for
 * [Multi]Select components to display a practically large number of options.
 */
interface FixedSizeListItemProps {
  data: { props: OptionListProps }[]
  index: number
  style: React.CSSProperties
}

function FixedSizeListItem(props: FixedSizeListItemProps): ReactElement {
  const { data, index, style } = props
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const { item, overrides, ...restChildProps } = data[index].props
  return (
    <ThemedStyledDropdownListItem
      key={item.value}
      style={style}
      {...restChildProps}
    >
      <OverflowTooltip content={item.label} placement={Placement.AUTO}>
        {item.label}
      </OverflowTooltip>
    </ThemedStyledDropdownListItem>
  )
}

const VirtualDropdown = React.forwardRef<any, any>((props, ref) => {
  const theme = useTheme()
  const children = React.Children.toArray(props.children) as ReactElement[]

  if (!children[0] || !children[0].props.item) {
    const childrenProps = children[0] ? children[0].props : {}
    return (
      <StyledList
        $style={{
          height: theme.sizes.emptyDropdownHeight,
          paddingBottom: theme.spacing.none,
          paddingTop: theme.spacing.none,
          paddingLeft: theme.spacing.none,
          paddingRight: theme.spacing.none,
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
        }}
        ref={ref}
        data-testid="stSelectboxVirtualDropdownEmpty"
      >
        <StyledEmptyState
          $style={{
            paddingBottom: theme.spacing.none,
            paddingTop: theme.spacing.none,
            paddingLeft: theme.spacing.none,
            paddingRight: theme.spacing.none,
            color: theme.colors.fadedText60,
          }}
          {...childrenProps}
        />
      </StyledList>
    )
  }

  const height = Math.min(
    convertRemToPx(theme.sizes.maxDropdownHeight),
    children.length * convertRemToPx(theme.sizes.dropdownItemHeight)
  )

  return (
    <StyledList
      ref={ref}
      $style={{ paddingTop: 0, paddingBottom: 0 }}
      data-testid="stSelectboxVirtualDropdown"
    >
      <FixedSizeList
        width="100%"
        height={height}
        itemCount={children.length}
        itemData={children}
        itemKey={(index: number, data: { props: OptionListProps }[]) =>
          data[index].props.item.value
        }
        itemSize={convertRemToPx(theme.sizes.dropdownItemHeight)}
      >
        {FixedSizeListItem}
      </FixedSizeList>
    </StyledList>
  )
})

VirtualDropdown.displayName = "VirtualDropdown"

export default VirtualDropdown


================================================
File: /frontend/lib/src/components/shared/Dropdown/index.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { default as VirtualDropdown } from "./VirtualDropdown"
export { default } from "./Selectbox"


================================================
File: /frontend/lib/src/components/shared/Dropdown/styled-components.ts
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import isPropValid from "@emotion/is-prop-valid"
import styled from "@emotion/styled"
import { StyledDropdownListItem } from "baseui/select"

export const ThemedStyledDropdownListItem = styled(StyledDropdownListItem, {
  shouldForwardProp: isPropValid,
})(({ theme, $isHighlighted }) => {
  const backgroundColor = theme.inSidebar
    ? theme.colors.bgColor
    : theme.colors.secondaryBg
  return {
    display: "flex",
    alignItems: "center",
    paddingTop: theme.spacing.none,
    paddingBottom: theme.spacing.none,
    paddingLeft: theme.spacing.lg,
    paddingRight: theme.spacing.lg,
    background: $isHighlighted ? backgroundColor : undefined,

    // Override the default itemSize set on the component's JSX
    // on mobile, so we can make list items taller and scrollable
    [`@media (max-width: ${theme.breakpoints.md})`]: {
      minHeight: theme.sizes.dropdownItemHeight,
      height: "auto !important",
    },
    "&:hover, &:active, &:focus-visible": {
      background: backgroundColor,
    },
  }
})


================================================
File: /frontend/lib/src/components/shared/ElementFullscreen/ElementFullscreenContext.tsx
================================================
/**
 * Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
