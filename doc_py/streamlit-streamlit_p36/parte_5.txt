        "🧰 General widgets",
        "📊 Charts",
        "🌇 Images",
        "🎥 Video",
        "📝 Text",
        "This is a very long text 📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝📝, yes, long long long long text",
    ],
    key="segmented_control_multi_selection",
    selection_mode="multi",
    default=default,
    help="You can choose multiple options",
)
st.write(f"Multi selection: {selection}")


st.header("Single Select - Segmented Control", anchor="single-select-segmented-control")
selection = st.segmented_control(
    "Select an option",
    [
        ":material/star: Hello there!",
        "Foobar",
        "Icon in the end: :material/rocket:",
    ],
    key="segmented_control_single_selection",
    selection_mode="single",
)
st.write(f"Single selection: {selection}")

option_to_icon_map = {
    0: ":material/add:",
    1: ":material/zoom_in:",
    2: ":material/zoom_out:",
    3: ":material/zoom_out_map:",
}

st.header(
    "Icon-only button group - Segmented Control",
    anchor="icon-only-button-group-segmented-control",
)
selection = st.segmented_control(
    "select an icon",
    options=[0, 1, 2, 3],
    format_func=lambda option: option_to_icon_map[option],
    key="segmented_control_single_icon_selection",
    selection_mode="single",
)
st.write(f"Single icon selection: {selection}")


st.header(
    "on_change callback - Segmented Control",
    anchor="on-change-callback-segmented-control",
)
st.segmented_control(
    "Select an emotion:",
    ["Joy", "Sadness", "Anger", "Disgust"],
    key="segmented_control_on_change",
    on_change=lambda: st.write(
        f"on_change selection: {st.session_state.segmented_control_on_change}"
    ),
)


st.header(
    "Disabled - Segmented Control (label collapsed)",
    anchor="disabled-segmented-control",
)
selection = st.segmented_control(
    "Select an emotion:",
    ["Joy", "Sadness", "Anger", "Disgust"],
    key="segmented_control_disabled",
    disabled=True,
    label_visibility="collapsed",
)
st.write("segmented-control-disabled:", str(selection))


st.header("Segmented Control in form", anchor="segmented-control-in-form")
with st.form(key="my_form", clear_on_submit=True):
    selection = st.segmented_control(
        "Select an emotion:",
        ["Joy", "Sadness", "Anger", "Disgust"],
        key="segmented_control_in_form",
        selection_mode="multi",
    )
    st.form_submit_button("Submit")
st.write(
    "segmented-control-in-form:",
    str(st.session_state.segmented_control_in_form)
    if "segmented_control_in_form" in st.session_state
    else None,
)


st.header("Segmented Control in fragment", anchor="segmented-control-in-fragment")


@st.experimental_fragment()
def test_fragment():
    selection = st.segmented_control(
        "Select an emotion:",
        ["Joy", "Sadness", "Anger", "Disgust"],
        key="segmented_control_in_fragment",
    )
    st.write("segmented-control-in-fragment:", str(selection))


test_fragment()


st.header("Unmounted - Segmented Control", anchor="unmounted-segmented-control")
if st.button("Create some elements to unmount component"):
    for _ in range(2):
        # The sleep here is needed, because it won't unmount the
        # component if this is too fast.
        time.sleep(1)
        st.write("Another element")

selection = st.segmented_control(
    "Select an emotion:",
    ["Joy", "Sadness", "Anger", "Disgust"],
    key="segmented_control_after_sleep",
)
st.write("segmented-control-after-sleep:", str(selection))


if "runs" not in st.session_state:
    st.session_state.runs = 0
st.session_state.runs += 1
st.write("Runs:", st.session_state.runs)


================================================
File: /e2e_playwright/st_segmented_control_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

from playwright.sync_api import Locator, Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_button,
    click_checkbox,
    click_form_button,
    expect_help_tooltip,
    expect_markdown,
    get_element_by_key,
    get_markdown,
)


def get_button_group(app: Page, key: str) -> Locator:
    return get_element_by_key(app, key).get_by_test_id("stButtonGroup").first


def get_segment_button(locator: Locator, text: str) -> Locator:
    return locator.get_by_test_id(
        re.compile("stBaseButton-segmented_control(Active)?")
    ).filter(has_text=text)


def test_click_multiple_segmented_control_button_and_take_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test multi-select segmented control and take a screenshot.

    Click on the same button multiple times to test unselect.
    """

    segmented_control = get_button_group(
        themed_app, "segmented_control_multi_selection"
    )
    get_segment_button(segmented_control, "Foobar").click()
    wait_for_app_run(themed_app)

    # click on second element to test multiselect
    get_segment_button(segmented_control, "Charts").click()
    wait_for_app_run(themed_app)
    expect_markdown(themed_app, "Multi selection: ['Foobar', '📊 Charts']")

    # click on same element to test unselect
    get_segment_button(segmented_control, "Charts").click()
    wait_for_app_run(themed_app)
    expect_markdown(themed_app, "Multi selection: ['Foobar']")

    # click on same element and take screenshot of multiple selected segmented control buttons
    get_segment_button(segmented_control, "Charts").click()
    # take away hover focus of button
    themed_app.get_by_test_id("stApp").click(position={"x": 0, "y": 0})
    wait_for_app_run(themed_app)
    expect_markdown(themed_app, "Multi selection: ['Foobar', '📊 Charts']")

    assert_snapshot(segmented_control, name="st_segmented_control-multiselect")


def test_click_single_segment_and_take_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test single select segmented control and take a screenshot.

    Click on same element to test unselect.
    Click on two different elements to validate single select.
    """

    segmented_control = get_button_group(
        themed_app, "segmented_control_single_selection"
    )
    get_segment_button(segmented_control, "Foobar").click()
    text = get_markdown(themed_app, "Single selection: Foobar")
    expect(text).to_be_visible()

    assert_snapshot(segmented_control, name="st_segmented_control-singleselect")

    # take away hover focus of button
    themed_app.get_by_test_id("stApp").click(position={"x": 0, "y": 0})
    wait_for_app_run(themed_app)
    text = get_markdown(themed_app, "Single selection: Foobar")
    expect(text).to_be_visible()

    # test unselect in single-select mode
    get_segment_button(segmented_control, "Foobar").click()
    text = get_markdown(themed_app, "Single selection: None")
    expect(text).to_be_visible()


def test_click_single_icon_segment_and_take_snapshot(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test icon only segmented control (via format_func) and take a screenshot.

    Click on same element to test unselect.
    Click on two different elements to validate single select.
    """
    segmented_control = get_button_group(
        themed_app, "segmented_control_single_icon_selection"
    )

    # the icon's span element has the respective text
    # (e.g. :material/zoom_out_map: -> zoom_out_map)
    get_segment_button(segmented_control, "zoom_out_map").click()
    text = get_markdown(themed_app, "Single icon selection: 3")
    expect(text).to_be_visible()

    get_segment_button(segmented_control, "zoom_in").click()
    text = get_markdown(themed_app, "Single icon selection: 1")
    expect(text).to_be_visible()

    assert_snapshot(
        segmented_control, name="st_segmented_control-singleselect_icon_only"
    )

    # take away hover focus of button
    themed_app.get_by_test_id("stApp").click(position={"x": 0, "y": 0})
    wait_for_app_run(themed_app)
    text = get_markdown(themed_app, "Single icon selection: 1")
    expect(text).to_be_visible()

    # test unselect in single-select mode
    get_segment_button(segmented_control, "zoom_in").click()
    text = get_markdown(themed_app, "Single icon selection: None")
    expect(text).to_be_visible()


def test_pass_default_selections(app: Page):
    """Test that passed defaults are rendered correctly."""
    expect_markdown(app, "Multi selection: []")

    click_checkbox(app, "Set default values")
    wait_for_app_run(app)
    expect_markdown(
        app,
        "Multi selection: ['Foobar', '🧰 General widgets']",
    )

    click_checkbox(app, "Set default values")
    wait_for_app_run(app)
    expect_markdown(app, "Multi selection: []")


def test_selection_via_on_change_callback(app: Page):
    """Test that the on_change callback is triggered when a segmented control butoon is clicked."""
    segmented_control = get_button_group(app, "segmented_control_on_change")
    get_segment_button(segmented_control, "Sadness").click()
    wait_for_app_run(app)
    expect_markdown(app, "on_change selection: Sadness")
    expect(segmented_control.get_by_text("Select an emotion:")).to_be_visible()


def test_segmented_control_are_disabled_and_label_collapsed(app: Page):
    segmented_control = get_button_group(app, "segmented_control_disabled")
    for button in segmented_control.locator("button").all():
        expect(button).to_have_js_property("disabled", True)
    selected_button = get_segment_button(segmented_control, "Sadness")
    selected_button.click(force=True)
    wait_for_app_run(app)
    expect(selected_button).not_to_have_css(
        "color", re.compile("rgb\\(\\d+, \\d+, \\d+\\)")
    )
    expect_markdown(app, "segmented-control-disabled: None")
    expect(segmented_control.get_by_text("Select an emotion:")).not_to_be_visible()


def test_segmented_control_work_in_forms(app: Page):
    expect_markdown(app, "segmented-control-in-form: []")
    segmented_control = get_button_group(app, "segmented_control_in_form")
    get_segment_button(segmented_control, "Sadness").click()
    click_form_button(app, "Submit")
    wait_for_app_run(app)
    expect_markdown(app, "segmented-control-in-form: ['Sadness']")


def test_segmented_control_work_with_fragments(app: Page):
    expect_markdown(app, "segmented-control-in-fragment: None")
    segmented_control = get_button_group(app, "segmented_control_in_fragment")
    get_segment_button(segmented_control, "Sadness").click()
    wait_for_app_run(app)
    expect_markdown(app, "segmented-control-in-fragment: Sadness")
    expect(app.get_by_text("Runs: 1")).to_be_visible()


def test_segmented_control_remount_keep_value(app: Page):
    expect_markdown(app, "segmented-control-after-sleep: None")
    segmented_control = get_button_group(app, "segmented_control_after_sleep")
    selected_button = get_segment_button(segmented_control, "Sadness")
    selected_button.click()
    wait_for_app_run(app)
    expect_markdown(app, "segmented-control-after-sleep: Sadness")
    click_button(app, "Create some elements to unmount component")
    expect_markdown(app, "segmented-control-after-sleep: Sadness")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stButtonGroup")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "segmented_control_multi_selection")).to_be_visible()


def test_help_tooltip(app: Page):
    expect_help_tooltip(
        app,
        get_button_group(app, "segmented_control_multi_selection"),
        "You can choose multiple options",
    )


================================================
File: /e2e_playwright/st_select_slider.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import numpy as np
import pandas as pd

import streamlit as st
from streamlit import runtime


def format_option(option):
    return f"Color: {option}"


w1 = st.select_slider(
    "Label 1 (format_func with key and help)",
    value=("orange", "blue"),
    options=["red", "orange", "yellow", "green", "blue", "indigo", "violet"],
    format_func=format_option,
    key="first_select_slider",
    help="Help in a select slider",
)
if "first_select_slider" in st.session_state:
    st.write("Value 1:", st.session_state.first_select_slider)
st.write("Value 1:", w1)

w2 = st.select_slider(
    "Label 2 (no default)",
    options=np.array([1, 2, 3, 4, 5]),
)
st.write("Value 2:", w2)

w3 = st.select_slider(
    "Label 3 (default with ints and series)",
    value=[2, 5],
    options=pd.Series([1, 2, 3, 4, 5, 6, 7, 8, 9]),
)
st.write("Value 3:", w3)

w4 = st.select_slider(
    "Label 4 (default with pandas df)",
    value=5,
    options=pd.DataFrame(
        {
            "first column": [1, 2, 3, 4, 5],
            "second column": [10, 20, 30, 40, 50],
        }
    ),
)
st.write("Value 4:", w4)

w5 = st.select_slider(
    "Label 5 (disabled)",
    value=("orange", "blue"),
    options=["red", "orange", "yellow", "green", "blue", "indigo", "violet"],
    disabled=True,
)
st.write("Value 5:", w5)

w6 = st.select_slider(
    "Label 6 (hidden visibility)",
    options=["red", "orange", "yellow", "green", "blue", "indigo", "violet"],
    label_visibility="hidden",
)

st.write("Value 6:", w6)


w7 = st.select_slider(
    "Label 7 (collapsed visibility)",
    options=["red", "orange", "yellow", "green", "blue", "indigo", "violet"],
    label_visibility="collapsed",
)

st.write("Value 7:", w7)

if runtime.exists():

    def on_change():
        st.session_state.select_slider_changed = True
        st.write("Hello world")

    st.select_slider(
        "Label 8 (on change)",
        options=np.array([1, 2, 3, 4, 5]),
        key="select_slider8",
        on_change=on_change,
    )
    st.write("Value 8:", st.session_state.select_slider8)
    st.write("Select slider changed:", "select_slider_changed" in st.session_state)

with st.expander("Expander", expanded=True):
    w9 = st.select_slider(
        label="Label 9 (expander)",
        options=["foo", "bar", "baz", "This is a very, very long option"],
        value="This is a very, very long option",
    )

    st.write("Value 9:", w9)

with st.form(key="my_form", clear_on_submit=True):
    selection = st.select_slider(
        label="Label 10 (form)",
        options=np.array([1, 2, 3, 4, 5]),
    )
    st.form_submit_button("Submit")

st.write("select_slider-in-form selection:", str(selection))


@st.fragment
def test_fragment():
    selection = st.select_slider(
        label="Label 11 (fragment)",
        options=np.array([1, 2, 3, 4, 5]),
    )
    st.write("select_slider-in-fragment selection:", str(selection))


test_fragment()

if "runs" not in st.session_state:
    st.session_state.runs = 0
st.session_state.runs += 1
st.write("Runs:", st.session_state.runs)


================================================
File: /e2e_playwright/st_select_slider_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_form_button,
    expect_help_tooltip,
    get_element_by_key,
)


def test_select_slider_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    st_select_sliders = themed_app.get_by_test_id("stSlider")
    expect(st_select_sliders).to_have_count(11)

    assert_snapshot(
        st_select_sliders.nth(0),
        name="st_select_slider-regular_with_help_and_format_func",
    )
    assert_snapshot(st_select_sliders.nth(4), name="st_select_slider-disabled")
    assert_snapshot(st_select_sliders.nth(5), name="st_select_slider-hidden_label")
    assert_snapshot(st_select_sliders.nth(6), name="st_select_slider-label_collapsed")


def test_help_tooltip_works(app: Page):
    element_with_help = app.get_by_test_id("stSlider").nth(0)
    expect_help_tooltip(app, element_with_help, "Help in a select slider")


def test_select_slider_contains_correct_format_func_value_and_in_session_state(
    app: Page,
):
    expect(app.get_by_text("Value 1: ('orange', 'blue')")).to_have_count(2)
    first_slider = app.get_by_test_id("stSlider").nth(0)
    first_slider.hover()
    # click in middle
    app.mouse.down()

    # Move mouse to 500, 0 pixels on the screen to simulate dragging left
    app.mouse.move(500, 0)
    app.mouse.up()
    wait_for_app_run(app)

    expect(app.get_by_text("Value 1: ('orange', 'yellow')")).to_have_count(2)


def test_using_arrow_keys_on_select_slider_produces_correct_values(app: Page):
    expect(app.get_by_text("Value 1: ('orange', 'blue')")).to_have_count(2)
    first_slider = app.get_by_test_id("stSlider").nth(0)
    first_slider.hover()
    # click in middle
    app.mouse.down()

    # Move slider once to right
    app.keyboard.press("ArrowRight")
    wait_for_app_run(app)
    expect(app.get_by_text("Value 1: ('orange', 'blue')")).to_have_count(2)

    # Move slider once to left
    app.keyboard.press("ArrowLeft")
    wait_for_app_run(app)

    expect(app.get_by_text("Value 1: ('orange', 'green')")).to_have_count(2)


def test_select_slider_calls_callback(app: Page):
    expect(app.get_by_text("Value 8: 1")).to_be_visible()
    expect(app.get_by_text("Select slider changed: False")).to_be_visible()
    slider = app.get_by_test_id("stSlider").nth(7)
    slider.hover()
    # click in middle
    app.mouse.down()

    wait_for_app_run(app)
    expect(app.get_by_text("Hello world")).to_be_visible()
    expect(app.get_by_text("Value 8: 3")).to_be_visible()
    expect(app.get_by_text("Select slider changed: True")).to_be_visible()


def test_select_slider_label_realigns_when_expander_opens(app: Page):
    app.get_by_test_id("stExpander").locator("summary").click()
    app.get_by_test_id("stExpander").locator("summary").click()
    expect(app.get_by_test_id("stSliderThumbValue").nth(11)).not_to_have_css(
        "left", "0px"
    )


def test_select_slider_works_in_forms(app: Page):
    expect(app.get_by_text("select_slider-in-form selection: 1")).to_be_visible()
    slider = app.get_by_test_id("stSlider").nth(9)
    slider.hover()
    # click in middle
    app.mouse.down()

    # The value is not submitted so the value should not have changed yet
    expect(app.get_by_text("select_slider-in-form selection: 1")).to_be_visible()

    # need to wait for the actual component value to update and then submit
    app.wait_for_timeout(200)
    click_form_button(app, "Submit")

    expect(app.get_by_text("select_slider-in-form selection: 3")).to_be_visible()


def test_select_slider_works_with_fragments(app: Page):
    expect(app.get_by_text("Runs: 1")).to_be_visible()
    expect(app.get_by_text("select_slider-in-fragment selection: 1")).to_be_visible()
    slider = app.get_by_test_id("stSlider").nth(10)
    slider.hover()
    # click in middle
    app.mouse.down()

    wait_for_app_run(app)
    expect(app.get_by_text("select_slider-in-fragment selection: 3")).to_be_visible()
    expect(app.get_by_text("Runs: 1")).to_be_visible()


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stSlider")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "select_slider8")).to_be_visible()


================================================
File: /e2e_playwright/st_selectbox.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pandas as pd

import streamlit as st
from streamlit import runtime

options = ("male", "female")
v1 = st.selectbox("selectbox 1 (default)", options)
st.write("value 1:", v1)

v2 = st.selectbox(
    "selectbox 2 (formatted options)", options, 1, format_func=lambda x: x.capitalize()
)
st.write("value 2:", v2)

v3 = st.selectbox("selectbox 3 (no options)", [])
st.write("value 3:", v3)

more_options = [
    "e2e/scripts/components_iframe.py",
    "e2e/scripts/st_warning.py",
    "This is a very very very long option label that should be truncated when it is showing in the dropdown menu.",
    "e2e/scripts/st_container.py",
    "e2e/scripts/st_dataframe_sort_column.py",
    "e2e/scripts/app_hotkeys.py",
    "e2e/scripts/st_info.py",
    "e2e/scripts/st_echo.py",
    "e2e/scripts/st_json.py",
    "e2e/scripts/st_experimental_get_query_params.py",
    "e2e/scripts/st_markdown.py",
    "e2e/scripts/st_color_picker.py",
    "e2e/scripts/st_expander.py",
]
v4 = st.selectbox("selectbox 4 (more options)", more_options, 0)
st.write("value 4:", v4)

v5 = st.selectbox("selectbox 5 (disabled)", options, disabled=True)
st.write("value 5:", v5)

v6 = st.selectbox("selectbox 6 (hidden label)", options, label_visibility="hidden")
st.write("value 6:", v6)

v7 = st.selectbox(
    "selectbox 7 (collapsed label)", options, label_visibility="collapsed"
)
st.write("value 7:", v7)

if runtime.exists():

    def on_change():
        st.session_state.selectbox_changed = True
        st.text("Selectbox widget callback triggered")

    st.selectbox(
        "selectbox 8 (with callback, help)",
        options,
        1,
        key="selectbox8",
        on_change=on_change,
        help="Help text",
    )
    st.write("value 8:", st.session_state.selectbox8)
    st.write("selectbox changed:", st.session_state.get("selectbox_changed") is True)
    # Reset to False:
    st.session_state.selectbox_changed = False

v9 = st.selectbox("selectbox 9 (empty selection)", options, index=None)
st.write("value 9:", v9)

v10 = st.selectbox(
    "selectbox 10 (empty, custom placeholder)",
    options,
    index=None,
    placeholder="Select one of the options...",
)
st.write("value 10:", v10)

v11 = st.selectbox(
    "selectbox 11 (options from dataframe)", pd.DataFrame({"foo": list(options)})
)
st.write("value 11:", v11)

if "selectbox_12" not in st.session_state:
    st.session_state["selectbox_12"] = "female"

v12 = st.selectbox(
    "selectbox 12 (empty, value from state)", options, index=None, key="selectbox_12"
)
st.write("value 12:", v12)


================================================
File: /e2e_playwright/st_selectbox_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class, get_element_by_key


def test_selectbox_widget_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the selectbox widgets are correctly rendered via screenshot matching."""
    selectbox_widgets = themed_app.get_by_test_id("stSelectbox")
    expect(selectbox_widgets).to_have_count(12)

    assert_snapshot(selectbox_widgets.nth(0), name="st_selectbox-default")
    assert_snapshot(selectbox_widgets.nth(1), name="st_selectbox-formatted_options")
    assert_snapshot(selectbox_widgets.nth(2), name="st_selectbox-no_options")
    assert_snapshot(selectbox_widgets.nth(3), name="st_selectbox-more_options")
    assert_snapshot(selectbox_widgets.nth(4), name="st_selectbox-disabled")
    assert_snapshot(selectbox_widgets.nth(5), name="st_selectbox-hidden_label")
    assert_snapshot(selectbox_widgets.nth(6), name="st_selectbox-collapsed_label")
    assert_snapshot(selectbox_widgets.nth(7), name="st_selectbox-callback_help")
    assert_snapshot(selectbox_widgets.nth(8), name="st_selectbox-empty_selection")
    assert_snapshot(
        selectbox_widgets.nth(9), name="st_selectbox-empty_selection_placeholder"
    )
    assert_snapshot(selectbox_widgets.nth(10), name="st_selectbox-dataframe_options")
    assert_snapshot(selectbox_widgets.nth(11), name="st_selectbox-value_from_state")


def test_selectbox_has_correct_initial_values(app: Page):
    """Test that st.selectbox returns the correct initial values."""
    markdown_elements = app.get_by_test_id("stMarkdown")
    expect(markdown_elements).to_have_count(13)

    expected = [
        "value 1: male",
        "value 2: female",
        "value 3: None",
        "value 4: e2e/scripts/components_iframe.py",
        "value 5: male",
        "value 6: male",
        "value 7: male",
        "value 8: female",
        "selectbox changed: False",
        "value 9: None",
        "value 10: None",
        "value 11: male",
        "value 12: female",
    ]

    for markdown_element, expected_text in zip(markdown_elements.all(), expected):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_handles_option_selection(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that selection of an option via the dropdown works correctly."""
    app.get_by_test_id("stSelectbox").nth(3).locator("input").click()

    # Take a snapshot of the selection dropdown:
    selection_dropdown = app.locator('[data-baseweb="popover"]').first
    assert_snapshot(selection_dropdown, name="st_selectbox-selection_dropdown")
    # Select last option:
    selection_dropdown.locator("li").nth(1).click()
    # Check that selection worked:
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text(
        "value 4: e2e/scripts/st_warning.py", use_inner_text=True
    )


def test_handles_option_selection_via_typing(app: Page):
    """Test that selection of an option via typing works correctly."""
    selectbox_input = app.get_by_test_id("stSelectbox").nth(3).locator("input")

    # Type an option:
    selectbox_input.type("e2e/scripts/st_warning.py")
    selectbox_input.press("Enter")

    # Check that selection worked:
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text(
        "value 4: e2e/scripts/st_warning.py", use_inner_text=True
    )


def test_shows_correct_options_via_fuzzy_search(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the fuzzy matching of options via typing works correctly."""
    selectbox_input = app.get_by_test_id("stSelectbox").nth(3).locator("input")

    # Start typing:
    selectbox_input.type("exp")

    # Check filtered options
    selection_dropdown = app.locator('[data-baseweb="popover"]').first
    assert_snapshot(selection_dropdown, name="st_selectbox-fuzzy_matching")


def test_empty_selectbox_behaves_correctly(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.selectbox behaves correctly when empty (no initial selection)."""
    empty_selectbox_input = app.get_by_test_id("stSelectbox").locator("input").nth(8)

    # Type an option:
    empty_selectbox_input.type("male")
    empty_selectbox_input.press("Enter")

    expect(app.get_by_test_id("stMarkdown").nth(9)).to_have_text(
        "value 9: male", use_inner_text=True
    )

    assert_snapshot(
        app.get_by_test_id("stSelectbox").nth(8), name="st_selectbox-clearable_input"
    )

    empty_selectbox_input.focus()
    empty_selectbox_input.press("Escape")

    # Should be empty again:
    expect(app.get_by_test_id("stMarkdown").nth(9)).to_have_text(
        "value 9: None", use_inner_text=True
    )


def test_keeps_value_on_selection_close(app: Page):
    """Test that the selection is kept when the dropdown is closed."""
    app.get_by_test_id("stSelectbox").nth(3).locator("input").click()

    # Take a snapshot of the selection dropdown:
    expect(app.locator('[data-baseweb="popover"]').first).to_be_visible()

    # Click outside to close the dropdown:
    app.get_by_test_id("stMarkdown").first.click()

    # Check if value is still initial value:
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text(
        "value 4: e2e/scripts/components_iframe.py", use_inner_text=True
    )


def test_handles_callback_on_change_correctly(app: Page):
    """Test that it correctly calls the callback on change."""
    # Check initial state:
    expect(app.get_by_test_id("stMarkdown").nth(7)).to_have_text(
        "value 8: female", use_inner_text=True
    )
    expect(app.get_by_test_id("stMarkdown").nth(8)).to_have_text(
        "selectbox changed: False", use_inner_text=True
    )

    app.get_by_test_id("stSelectbox").nth(7).locator("input").click()

    # Select last option:
    selection_dropdown = app.locator('[data-baseweb="popover"]').first
    selection_dropdown.locator("li").first.click()

    # Check that selection worked:
    expect(app.get_by_test_id("stMarkdown").nth(7)).to_have_text(
        "value 8: male", use_inner_text=True
    )
    expect(app.get_by_test_id("stMarkdown").nth(8)).to_have_text(
        "selectbox changed: True", use_inner_text=True
    )

    # Change different input to trigger delta path change
    empty_selectbox_input = app.get_by_test_id("stSelectbox").locator("input").first

    # Type an option:
    empty_selectbox_input.type("female")
    empty_selectbox_input.press("Enter")

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "value 1: female", use_inner_text=True
    )
    expect(app.get_by_test_id("stMarkdown").nth(7)).to_have_text(
        "value 8: male", use_inner_text=True
    )
    expect(app.get_by_test_id("stMarkdown").nth(8)).to_have_text(
        "selectbox changed: False", use_inner_text=True
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stSelectbox")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "selectbox8")).to_be_visible()


================================================
File: /e2e_playwright/st_session_state.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit import runtime

if runtime.exists():
    if "checkbox1" not in st.session_state:
        st.session_state.checkbox1 = True

    def on_checkbox_change(changed_checkbox_number):
        if changed_checkbox_number == 1:
            st.session_state.checkbox2 = False
        elif changed_checkbox_number == 2:
            st.session_state.checkbox1 = False

    st.checkbox(
        label="Checkbox1", key="checkbox1", on_change=on_checkbox_change, args=(1,)
    )
    st.checkbox(
        label="Checkbox2", key="checkbox2", on_change=on_checkbox_change, args=(2,)
    )

    if "initialized" not in st.session_state:
        st.session_state["item_counter"] = 0
        st.session_state.attr_counter = 0

        st.session_state.initialized = True

    if st.button("inc_item_counter"):
        st.session_state["item_counter"] += 1

    if st.button("inc_attr_counter"):
        st.session_state.attr_counter += 1

    if st.button("del_item_counter"):
        del st.session_state["item_counter"]

    if st.button("del_attr_counter"):
        del st.session_state.attr_counter

    if "item_counter" in st.session_state:
        st.write(f"item_counter: {st.session_state['item_counter']}")

    if "attr_counter" in st.session_state:
        st.write(f"attr_counter: {st.session_state.attr_counter}")

    st.write(f"len(st.session_state): {len(st.session_state)}")
    st.write(st.session_state)


================================================
File: /e2e_playwright/st_session_state_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.shared.app_utils import click_button, click_checkbox, get_checkbox


def test_checking_checkbox_unchecks_other(app: Page):
    """Test that checking one checkbox unchecks the other by using callbacks."""
    first_checkbox = get_checkbox(app, "Checkbox1")
    second_checkbox = get_checkbox(app, "Checkbox2")

    expect(first_checkbox.locator("input")).to_have_attribute("aria-checked", "true")
    expect(second_checkbox.locator("input")).to_have_attribute("aria-checked", "false")

    click_checkbox(app, "Checkbox2")

    expect(first_checkbox.locator("input")).to_have_attribute("aria-checked", "false")
    expect(second_checkbox.locator("input")).to_have_attribute("aria-checked", "true")


def test_has_correct_starting_values(app: Page):
    expect(app.get_by_text("item_counter: 0")).to_have_count(1)
    expect(app.get_by_text("attr_counter: 0")).to_have_count(1)
    expect(app.get_by_text("len(st.session_state): 5")).to_have_count(1)
    expect(app.get_by_test_id("stJson")).to_be_visible()


def test_can_do_CRUD_for_session_state_items(app: Page):
    expect(app.get_by_text("item_counter: 0")).to_have_count(1)
    expect(app.get_by_text("attr_counter: 0")).to_have_count(1)

    click_button(app, "inc_item_counter")

    expect(app.get_by_text("item_counter: 1")).to_have_count(1)
    expect(app.get_by_text("attr_counter: 0")).to_have_count(1)

    click_button(app, "inc_item_counter")

    expect(app.get_by_text("item_counter: 2")).to_have_count(1)
    expect(app.get_by_text("attr_counter: 0")).to_have_count(1)

    click_button(app, "del_item_counter")

    expect(app.get_by_text("item_counter: 2")).to_have_count(0)
    expect(app.get_by_text("attr_counter: 0")).to_have_count(1)
    expect(app.get_by_text("len(st.session_state): 4")).to_have_count(1)


def test_can_do_CRUD_for_session_state_attributes(app: Page):
    expect(app.get_by_text("item_counter: 0")).to_have_count(1)
    expect(app.get_by_text("attr_counter: 0")).to_have_count(1)

    click_button(app, "inc_attr_counter")

    expect(app.get_by_text("item_counter: 0")).to_have_count(1)
    expect(app.get_by_text("attr_counter: 1")).to_have_count(1)

    click_button(app, "inc_attr_counter")

    expect(app.get_by_text("item_counter: 0")).to_have_count(1)
    expect(app.get_by_text("attr_counter: 2")).to_have_count(1)

    click_button(app, "del_attr_counter")

    expect(app.get_by_text("item_counter: 0")).to_have_count(1)
    expect(app.get_by_text("attr_counter: 2")).to_have_count(0)
    expect(app.get_by_text("len(st.session_state): 4")).to_have_count(1)


================================================
File: /e2e_playwright/st_set_page_config.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from pathlib import Path

import streamlit as st

# Construct test assets path relative to this script file to
# allow its execution with different working directories.
TEST_ASSETS_DIR = Path(__file__).parent / "test_assets"
ICON_PATH = TEST_ASSETS_DIR / "favicon.ico"

st.sidebar.button("Sidebar!")
st.markdown("Main!")
with st.expander("Expander in main"):
    st.write("Text in expander")


def preceding_command_in_callback():
    st.balloons()
    st.set_page_config(page_title="Allows preceding command in callback")


st.button("Preceding Command in Callback", on_click=preceding_command_in_callback)


def collapsed_sidebar():
    st.set_page_config(
        page_title="Collapsed Sidebar", initial_sidebar_state="collapsed"
    )


st.button("Collapsed Sidebar", on_click=collapsed_sidebar)


def expanded_sidebar():
    st.set_page_config(page_title="Expanded Sidebar", initial_sidebar_state="expanded")


st.button("Expanded Sidebar", on_click=expanded_sidebar)


def wide_layout():
    st.set_page_config(page_title="Wide Layout", layout="wide")


st.button("Wide Layout", on_click=wide_layout)


def centered_layout():
    st.set_page_config(page_title="Centered Layout", layout="centered")


st.button("Centered Layout", on_click=centered_layout)


def double_set_page_config():
    st.set_page_config(page_title="Page Config 1")
    st.set_page_config(page_title="Page Config 2")


st.button("Double Set Page Config", on_click=double_set_page_config)


def page_config_with_emoji_shortcode():
    st.set_page_config(
        page_title="With Emoji Shortcode",
        page_icon=":shark:",
    )


st.button("Page Config With Emoji Shortcode", on_click=page_config_with_emoji_shortcode)


def page_config_with_emoji_symbol():
    st.set_page_config(
        page_title="With Emoji Symbol",
        page_icon="🐙",
    )


st.button("Page Config With Emoji Symbol", on_click=page_config_with_emoji_symbol)


def page_config_with_local_icon_str():
    st.set_page_config(
        page_title="With Local Icon Str",
        page_icon=str(ICON_PATH),
    )


st.button("Page Config With Local Icon Str", on_click=page_config_with_local_icon_str)


def page_config_with_local_icon_path():
    st.set_page_config(
        page_title="With Local Icon Path",
        page_icon=ICON_PATH,
    )


st.button("Page Config With Local Icon Path", on_click=page_config_with_local_icon_path)


def page_config_with_material_icon():
    st.set_page_config(
        page_title="With Material Icon",
        page_icon=":material/thumb_up:",
    )


st.button("Page Config With Material Icon", on_click=page_config_with_material_icon)

# The menu_items parameter is covered by the `main_menu.py` script
# initial_sidebar_state = auto is covered by the `st_sidebar.py` script


================================================
File: /e2e_playwright/st_set_page_config_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import re

from playwright.sync_api import Page, expect

from e2e_playwright.shared.app_utils import (
    click_button,
    expect_exception,
    expect_no_exception,
    get_expander,
)


def test_wide_layout(app: Page):
    app_view_container = app.get_by_test_id("stAppViewContainer")
    # The default layout is "centered":
    expect(app_view_container).to_have_attribute("data-layout", "narrow")

    expander_container = get_expander(app, "Expander in main")
    expect(expander_container).to_be_visible()
    expander_dimensions = expander_container.bounding_box()
    assert expander_dimensions is not None
    narrow_expander_width = expander_dimensions["width"]

    click_button(app, "Wide Layout")
    expect(app).to_have_title("Wide Layout")
    expect(app_view_container).to_have_attribute("data-layout", "wide")

    expect(expander_container).to_be_visible()

    expander_dimensions = expander_container.bounding_box()
    assert expander_dimensions is not None

    # Its fine to use assert here since we don't need to wait for this to be true:
    assert narrow_expander_width < expander_dimensions["width"]


def test_wide_layout_with_small_viewport(app: Page):
    """Test that the wide layout is using the same width as the centered layout
    when the viewport is narrow."""

    app.set_viewport_size({"width": 640, "height": 800})

    app_view_container = app.get_by_test_id("stAppViewContainer")
    # The default layout is "centered":
    expect(app_view_container).to_have_attribute("data-layout", "narrow")

    expander_container = get_expander(app, "Expander in main")
    expect(expander_container).to_be_visible()
    expander_dimensions = expander_container.bounding_box()
    assert expander_dimensions is not None
    narrow_expander_width = expander_dimensions["width"]

    click_button(app, "Wide Layout")
    expect(app).to_have_title("Wide Layout")
    app_view_container = app.get_by_test_id("stAppViewContainer")
    expect(app_view_container).to_have_attribute("data-layout", "wide")
    expander_dimensions = expander_container.bounding_box()
    assert expander_dimensions is not None

    # Its fine to use assert here since we don't need to wait for this to be true:
    assert narrow_expander_width == expander_dimensions["width"]


def test_centered_layout(app: Page):
    click_button(app, "Centered Layout")
    expect(app).to_have_title("Centered Layout")
    app_view_container = app.get_by_test_id("stAppViewContainer")
    expect(app_view_container).to_have_attribute("data-layout", "narrow")


def test_allows_preceding_command_in_callback(app: Page):
    """Should not display an error when st.set_page_config is used after an st.*
    command in a callback.
    """
    click_button(app, "Preceding Command in Callback")
    expect(app).to_have_title("Allows preceding command in callback")
    expect_no_exception(app)


def test_double_set_page_config(app: Page):
    """Should display an error when st.set_page_config is called
    multiple times in a callback."""
    click_button(app, "Double Set Page Config")
    expect_exception(app, "set_page_config() can only be called once per app page")
    expect(app).to_have_title("Page Config 1")


def test_with_collapsed_sidebar(app: Page):
    click_button(app, "Collapsed Sidebar")
    expect(app).to_have_title("Collapsed Sidebar")
    sidebar = app.get_by_test_id("stSidebar")
    expect(sidebar).to_have_attribute("aria-expanded", "false")
    expect_no_exception(app)


def test_with_expanded_sidebar(app: Page):
    click_button(app, "Expanded Sidebar")
    expect(app).to_have_title("Expanded Sidebar")
    sidebar = app.get_by_test_id("stSidebar")
    expect(sidebar).to_have_attribute("aria-expanded", "true")
    expect_no_exception(app)


def test_page_icon_with_emoji_shortcode(app: Page):
    click_button(app, "Page Config With Emoji Shortcode")
    expect(app).to_have_title("With Emoji Shortcode")
    favicon = app.locator("link[rel='shortcut icon']")
    expect(favicon).to_have_attribute(
        "href",
        "https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/1f988.png",
    )
    expect_no_exception(app)


def test_page_icon_with_emoji_symbol(app: Page):
    click_button(app, "Page Config With Emoji Symbol")
    expect(app).to_have_title("With Emoji Symbol")
    favicon = app.locator("link[rel='shortcut icon']")
    expect(favicon).to_have_attribute(
        "href",
        "https://cdn.jsdelivr.net/gh/twitter/twemoji@14.0.2/assets/72x72/1f419.png",
    )


def test_page_icon_with_local_icon_str(app: Page):
    click_button(app, "Page Config With Local Icon Str")
    expect(app).to_have_title("With Local Icon Str")
    favicon_element = app.locator("link[rel='shortcut icon']")
    expect(favicon_element).to_have_count(1)
    expect(favicon_element).to_have_attribute("href", re.compile(r".*\.png$"))
    expect_no_exception(app)


def test_page_icon_with_local_icon(app: Page):
    click_button(app, "Page Config With Local Icon Path")
    expect(app).to_have_title("With Local Icon Path")
    favicon_element = app.locator("link[rel='shortcut icon']")
    expect(favicon_element).to_have_count(1)
    expect(favicon_element).to_have_attribute("href", re.compile(r".*\.png$"))
    expect_no_exception(app)


def test_page_icon_with_material_icon(app: Page):
    click_button(app, "Page Config With Material Icon")
    expect(app).to_have_title("With Material Icon")
    favicon = app.locator("link[rel='shortcut icon']")
    expect(favicon).to_have_attribute(
        "href",
        "https://fonts.gstatic.com/s/i/short-term/release/materialsymbolsrounded/thumb_up/default/24px.svg",
    )
    expect_no_exception(app)


================================================
File: /e2e_playwright/st_sidebar.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from datetime import date, datetime

import numpy as np
import pandas as pd

import streamlit as st

np.random.seed(0)
data = np.random.randint(low=0, high=20, size=(20, 3))

w1 = st.sidebar.date_input("Label 1", date(1970, 1, 1))
st.write("Value 1:", w1)

w2 = st.sidebar.date_input("Label 2", datetime(2019, 7, 6, 21, 15))
st.write("Value 2:", w2)

x = st.sidebar.text("overwrite me")
x.text("overwritten")
y = st.sidebar.text_input("type here")

with st.sidebar:
    st.header("hello world")
    st.markdown("hello world")
    st.bar_chart(pd.DataFrame(data, columns=["a", "b", "c"]))


================================================
File: /e2e_playwright/st_sidebar_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class


def test_sidebar_displays_correctly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    sidebar = themed_app.get_by_test_id("stSidebar")
    assert_snapshot(sidebar, name="st_sidebar-display")


def test_sidebar_date_input_popover(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Handles z-index of date input popover correctly."""
    date_inputs = themed_app.get_by_test_id("stSidebar").get_by_test_id("stDateInput")
    expect(date_inputs).to_have_count(2)

    date_inputs.first.click()
    assert_snapshot(
        themed_app.get_by_test_id("stSidebar"), name="st_sidebar-date_popover"
    )


def test_sidebar_overwriting_elements(app: Page):
    sidebar_text = app.get_by_test_id("stSidebar").get_by_test_id("stText")
    expect(sidebar_text).to_contain_text("overwritten")


def test_sidebar_collapse_on_mobile_resize(app: Page):
    app.set_viewport_size({"width": 800, "height": 400})
    sidebar = app.get_by_test_id("stSidebar")
    expect(sidebar).to_have_attribute("aria-expanded", "true")

    app.set_viewport_size({"width": 400, "height": 800})
    expect(sidebar).to_have_attribute("aria-expanded", "false")


def test_sidebar_no_collapse_on_text_input_mobile(app: Page):
    app.set_viewport_size({"width": 400, "height": 800})

    # Expand the sidebar on mobile
    app.get_by_test_id("stSidebarCollapsedControl").locator("button").click()

    app.get_by_test_id("stSidebar").get_by_test_id("stTextInput").locator(
        "input"
    ).click()

    sidebar = app.get_by_test_id("stSidebar")
    expect(sidebar).to_have_attribute("aria-expanded", "true")


def test_sidebar_chart_and_toolbar(app: Page):
    sidebar = app.get_by_test_id("stSidebar")
    # Check for the chart & tooltip
    chart = sidebar.get_by_test_id("stVegaLiteChart")
    chart.hover(position={"x": 60, "y": 220})
    tooltip = app.locator("#vg-tooltip-element")
    expect(tooltip).to_be_visible()


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stSidebar")


================================================
File: /e2e_playwright/st_slider.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from datetime import date, time

import streamlit as st
from streamlit import runtime

# Slider 0
s1 = st.sidebar.slider("Label A", 0, 12345678, 12345678)
st.sidebar.write("Value A:", s1)

# Slider 1
r1 = st.sidebar.slider("Range A", 10000, 25000, [10000, 25000])
st.sidebar.write("Range Value A:", r1)

with st.sidebar.expander("Expander", expanded=True):
    # Slider 2
    s2 = st.slider("Label B", 10000, 25000, 10000)
    st.write("Value B:", s2)

    # Slider 3
    r2 = st.slider("Range B", 10000, 25000, [10000, 25000])
    st.write("Range Value B:", r2)

# Slider 4
w1 = st.slider(
    "Label 1",
    min_value=date(2019, 8, 1),
    max_value=date(2021, 6, 4),
    value=(date(2019, 8, 1), date(2019, 9, 1)),
    format="ddd, hA",
    help="This is some help tooltip!",
)
st.write("Value 1:", w1)

# Slider 5
w2 = st.slider("Label 2", 0.0, 100.0, (25.0, 75.0), 0.5)
st.write("Value 2:", w2)

# Slider 6
w3 = st.slider(
    "Label 3 - This is a very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very very long label",
    0,
    100,
    1,
    1,
)
st.write("Value 3:", w3)

# Slider 7
w4 = st.slider("Label 4", 10000, 25000, 10000, disabled=True)
st.write("Value 4:", w4)

# Slider 8
w5 = st.slider("Label 5", 0, 100, 25, 1, label_visibility="hidden")
st.write("Value 5:", w5)

# Slider 9
w6 = st.slider("Label 6", 0, 100, 36, label_visibility="collapsed")
st.write("Value 6:", w6)

# Slider 10
dates = st.slider(
    "Label 7",
    min_value=date(2019, 8, 1),
    max_value=date(2021, 6, 4),
    value=(date(2019, 8, 1), date(2019, 9, 1)),
)
st.write("Value 7:", dates[0], dates[1])

if runtime.exists():

    def on_change():
        st.session_state.slider_changed = True

    # Slider 11
    st.slider(
        "Label 8",
        min_value=0,
        max_value=100,
        value=25,
        step=1,
        key="slider8",
        on_change=on_change,
    )
    st.write("Value 8:", st.session_state.slider8)
    st.write("Slider changed:", "slider_changed" in st.session_state)

with st.form(key="my_form", clear_on_submit=True):
    # Slider 12
    selection = st.slider(
        "Label 9",
        min_value=0,
        max_value=100,
        value=25,
        step=1,
        key="slider9",
    )
    st.form_submit_button("Submit")

st.write("slider-in-form selection:", str(selection))


@st.fragment
def test_fragment():
    # Slider 13
    selection = st.slider(
        "Label 10",
        min_value=0,
        max_value=100,
        value=25,
        step=1,
        key="slider10",
        on_change=on_change,
    )
    st.write("slider-in-fragment selection:", str(selection))


test_fragment()

if "runs" not in st.session_state:
    st.session_state.runs = 0
st.session_state.runs += 1
st.write("Runs:", st.session_state.runs)

# Slider 14
slider_11_value = st.slider(
    "Slider 11 (formatted float)", value=0.05, step=0.2, format="%f%%"
)
st.write("Slider 11:", slider_11_value)

# Slider 15
slider_12_value = st.slider("Slider 12 (time-value)", value=time(12, 0))
st.write("Slider 12:", slider_12_value)

# Slider 16
st.slider(
    "Label 13 - Overlapping on the left",
    min_value=1e6 + 0,
    max_value=1e6 + 100,
    value=(1e6 + 0, 1e6 + 4),
)

# Slider 17
st.slider(
    "Label 14 - Overlapping near the left",
    min_value=1e6 + 0,
    max_value=1e6 + 100,
    value=(1e6 + 10, 1e6 + 14),
)

# Slider 18
st.slider(
    "Label 15 - Overlapping on the right",
    min_value=1e6 + 0,
    max_value=1e6 + 100,
    value=(1e6 + 96, 1e6 + 100),
)

# Slider 19
st.slider(
    "Label 16 - Overlapping near the right",
    min_value=1e6 + 0,
    max_value=1e6 + 100,
    value=(1e6 + 86, 1e6 + 90),
)

# Slider 20
st.slider(
    "Label 17 - Overlapping near the center",
    min_value=1e6 + 0,
    max_value=1e6 + 100,
    value=(1e6 + 48, 1e6 + 52),
)


================================================
File: /e2e_playwright/st_slider_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import (
    ImageCompareFunction,
    wait_for_app_run,
)
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_form_button,
    expect_help_tooltip,
    get_element_by_key,
)


def test_slider_rendering(themed_app: Page, assert_snapshot: ImageCompareFunction):
    st_sliders = themed_app.get_by_test_id("stSlider")
    expect(st_sliders).to_have_count(21)

    assert_snapshot(st_sliders.nth(4), name="st_slider-regular_with_format")
    assert_snapshot(st_sliders.nth(7), name="st_slider-disabled")
    assert_snapshot(st_sliders.nth(8), name="st_slider-hidden_label")
    assert_snapshot(st_sliders.nth(9), name="st_slider-label_collapsed")
    assert_snapshot(st_sliders.nth(10), name="st_slider-labels_overlap_slider")
    assert_snapshot(st_sliders.nth(15), name="st_slider-time_value")
    assert_snapshot(st_sliders.nth(16), name="st_slider-overlap_left")
    assert_snapshot(st_sliders.nth(17), name="st_slider-overlap_near_left")
    assert_snapshot(st_sliders.nth(18), name="st_slider-overlap_right")
    assert_snapshot(st_sliders.nth(19), name="st_slider-overlap_near_right")
    assert_snapshot(st_sliders.nth(20), name="st_slider-overlap_near_center")


def test_help_tooltip_works(app: Page):
    st_sliders = app.get_by_test_id("stSlider")
    expect_help_tooltip(app, st_sliders.nth(4), "This is some help tooltip!")


def test_slider_in_expander(app: Page, assert_snapshot: ImageCompareFunction):
    expect(app.get_by_text("Value B: 10000")).to_have_count(1)
    expect(app.get_by_text("Range Value B: (10000, 25000)")).to_have_count(1)
    first_slider_in_expander = app.get_by_test_id("stSlider").nth(2)
    second_slider_in_expander = app.get_by_test_id("stSlider").nth(3)

    first_slider_in_expander.hover()
    # click in middle
    app.mouse.down()

    second_slider_in_expander.hover()
    # click in middle
    app.mouse.down()

    expect(app.get_by_text("Value B: 17500")).to_have_count(1)
    expect(app.get_by_text("Range Value B: (17500, 25000)")).to_have_count(1)

    assert_snapshot(first_slider_in_expander, name="st_slider-in_expander_regular")
    assert_snapshot(second_slider_in_expander, name="st_slider-in_expander_range")


def test_slider_contains_correct_format_func_value_and_in_session_state(
    app: Page,
):
    expect(
        app.get_by_text(
            "Value 1: (datetime.date(2019, 8, 1), datetime.date(2019, 9, 1))"
        )
    ).to_have_count(1)
    slider = app.get_by_test_id("stSlider").nth(4)
    slider.hover()
    # click in middle
    app.mouse.down()

    # Move mouse to 0, 0 pixels on the screen to simulate dragging left
    app.mouse.move(0, 0)
    app.mouse.up()
    wait_for_app_run(app)

    expect(
        app.get_by_text(
            "Value 1: (datetime.date(2019, 8, 1), datetime.date(2019, 8, 1))"
        )
    ).to_have_count(1)


def test_using_arrow_keys_on_slider_produces_correct_values(app: Page):
    expect(
        app.get_by_text(
            "Value 1: (datetime.date(2019, 8, 1), datetime.date(2019, 9, 1))"
        )
    ).to_have_count(1)
    slider = app.get_by_test_id("stSlider").nth(4)
    slider.hover()
    # click in middle
    app.mouse.down()

    # Move slider once to right
    app.keyboard.press("ArrowRight")
    wait_for_app_run(app)
    expect(
        app.get_by_text(
            "Value 1: (datetime.date(2019, 8, 1), datetime.date(2020, 7, 3))"
        )
    ).to_have_count(1)

    # Move slider once to left
    app.keyboard.press("ArrowLeft")
    wait_for_app_run(app)

    expect(
        app.get_by_text(
            "Value 1: (datetime.date(2019, 8, 1), datetime.date(2020, 7, 2))"
        )
    ).to_have_count(1)


def test_slider_calls_callback(app: Page):
    expect(app.get_by_text("Value 8: 25")).to_be_visible()
    expect(app.get_by_text("Slider changed: False")).to_be_visible()
    slider = app.get_by_test_id("stSlider").nth(11)
    slider.hover()
    # click in middle
    app.mouse.down()

    wait_for_app_run(app)
    expect(app.get_by_text("Value 8: 50")).to_be_visible()
    expect(app.get_by_text("Slider changed: True")).to_be_visible()


def test_slider_works_in_forms(app: Page):
    expect(app.get_by_text("slider-in-form selection: 25")).to_be_visible()
    slider = app.get_by_test_id("stSlider").nth(12)
    slider.hover()
    # click in middle
    app.mouse.down()

    # The value is not submitted so the value should not have changed yet
    expect(app.get_by_text("slider-in-form selection: 25")).to_be_visible()

    # need to wait for the actual component value to update and then submit
    app.wait_for_timeout(200)
    click_form_button(app, "Submit")

    expect(app.get_by_text("slider-in-form selection: 50")).to_be_visible()


def test_slider_works_with_fragments(app: Page):
    expect(app.get_by_text("Runs: 1")).to_be_visible()
    expect(app.get_by_text("slider-in-fragment selection: 25")).to_be_visible()
    slider = app.get_by_test_id("stSlider").nth(13)
    slider.hover()
    # click in middle
    app.mouse.down()

    wait_for_app_run(app)
    expect(app.get_by_text("slider-in-fragment selection: 50")).to_be_visible()
    expect(app.get_by_text("Runs: 1")).to_be_visible()


def test_slider_with_float_formatting(app: Page, assert_snapshot: ImageCompareFunction):
    slider = app.get_by_test_id("stSlider").nth(14)
    slider.hover()
    # click in middle
    app.mouse.down()

    # Move slider once to right
    app.keyboard.press("ArrowRight")
    wait_for_app_run(app)
    expect(app.get_by_text("Slider 11: 0.8")).to_be_visible()
    assert_snapshot(slider, name="st_slider-float_formatting")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stSlider")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "slider8")).to_be_visible()


@pytest.mark.performance
def test_slider_interaction_performance(app: Page):
    """
    Test a simple interaction with a slider to ensure it is performant.
    As of writing, a simple slider interaction effectively causes a full page
    re-render.
    """
    slider = app.get_by_test_id("stSlider").nth(8)
    slider.hover()
    # click in middle
    app.mouse.down()

    # Move mouse to 0, 0 pixels on the screen to simulate dragging left
    app.mouse.move(0, 0)
    app.mouse.up()
    wait_for_app_run(app)
    expect(app.get_by_text("Value 5: 0")).to_be_visible()


================================================
File: /e2e_playwright/st_snow.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.snow()


================================================
File: /e2e_playwright/st_snow_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.shared.app_utils import check_top_level_class


def test_snow_is_present_on_page(app: Page):
    expect(app.get_by_test_id("stSnow")).to_have_count(1)
    check_top_level_class(app, "stSnow")


================================================
File: /e2e_playwright/st_spinner.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time

import streamlit as st

# A spinner always requires a computation to run for a certain time
# Therefore, we add a button to allow triggering the spinner during the test execution.
if st.button("Run spinner basic"):
    with st.spinner("Loading..."):
        time.sleep(2)

if st.button("Run spinner with time"):
    with st.spinner("Loading...", show_time=True):
        time.sleep(2)


================================================
File: /e2e_playwright/st_spinner_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.shared.app_utils import check_top_level_class, get_button


def test_spinner_execution(app: Page):
    # Can't use `click_button` here because that waits until the app finishes running,
    # which makes the spinner disappear.
    get_button(app, "Run spinner basic").click()
    expect(app.get_by_test_id("stSpinner")).to_have_text("Loading...")
    check_top_level_class(app, "stSpinner")


def test_spinner_time(app: Page):
    # Can't use `click_button` here because that waits until the app finishes running,
    # which makes the spinner disappear.
    get_button(app, "Run spinner with time").click()
    expect(app.get_by_test_id("stSpinner")).to_contain_text("Loading...")
    expect(app.get_by_test_id("stSpinner")).to_contain_text("seconds")
    check_top_level_class(app, "stSpinner")

    # Check that the timer text changes.
    # We're not doing any exact text matching of the time here since that might be flaky.
    initial_text = app.get_by_test_id("stSpinner").text_content()
    app.wait_for_timeout(200)
    updated_text = app.get_by_test_id("stSpinner").text_content()
    assert initial_text != updated_text


================================================
File: /e2e_playwright/st_status.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit.runtime.scriptrunner import get_script_run_ctx

ctx = get_script_run_ctx()
if ctx is None:
    import sys

    # This script is not compatible with running it in "bare" mode (e.g. `python script.py`)
    # The reason is that the mutable container is not correctly returned if
    # the runtime doesn't exist.
    print("This test script does not support bare script execution.")
    sys.exit(0)


running_status = st.status("Running status", expanded=True)
running_status.write("Doing some work...")

with st.status("Completed status", expanded=True, state="complete"):
    st.write("Hello world")

with st.status("Error status", expanded=True, state="error"):
    st.error("Oh no, something went wrong!")

with st.status("Collapsed", state="complete"):
    st.write("Hello world")

with st.status("About to change label...", state="complete") as status:
    st.write("Hello world")
    status.update(label="Changed label")

status = st.status("Without context manager", state="complete")
status.write("Hello world")
status.update(state="error", expanded=True)

with st.status("Collapse via update...", state="complete", expanded=True) as status:
    st.write("Hello world")
    status.update(label="Collapsed", expanded=False)

st.status("Empty state...", state="complete")

try:
    with st.status("Uncaught exception"):
        st.write("Hello world")
        raise Exception("Error!")
except Exception:
    pass


================================================
File: /e2e_playwright/st_status_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_status_container_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.status renders correctly via screenshots."""
    status_containers = themed_app.get_by_test_id("stExpander")
    expect(status_containers).to_have_count(9)

    # Don't check screenshot for first element,
    # since we cannot reliably screenshot test the spinner icon.

    assert_snapshot(status_containers.nth(1), name="st_status-complete_state")
    assert_snapshot(status_containers.nth(2), name="st_status-error_state")
    assert_snapshot(status_containers.nth(3), name="st_status-collapsed")
    assert_snapshot(status_containers.nth(4), name="st_status-changed_label")
    assert_snapshot(status_containers.nth(5), name="st_status-without_cm")
    assert_snapshot(status_containers.nth(6), name="st_status-collapsed_via_update")
    assert_snapshot(status_containers.nth(7), name="st_status-empty_state")
    assert_snapshot(status_containers.nth(8), name="st_status-uncaught_exception")


def test_running_state(app: Page):
    """Test that st.status renders a spinner when in running state."""
    running_status = app.get_by_test_id("stExpander").nth(0)
    # Check if it has a spinner icon:
    expect(running_status.get_by_test_id("stExpanderIconSpinner")).to_be_visible()


def test_status_collapses_and_expands(app: Page):
    """Test that a status collapses and expands."""
    expander_content = "Doing some work..."
    running_status = app.get_by_test_id("stExpander").nth(0)
    # Starts expanded:
    expect(running_status.get_by_text(expander_content)).to_be_visible()

    expander_header = running_status.locator("summary")
    # Collapse:
    expander_header.click()
    expect(running_status.get_by_text(expander_content)).not_to_be_visible()
    # Expand:
    expander_header.click()
    expect(running_status.get_by_text(expander_content)).to_be_visible()


================================================
File: /e2e_playwright/st_stop.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit import runtime

st.text("Text before stop")

# Since st.stop() throws an intentional exception, we want this to run
# only in streamlit
if runtime.exists():
    st.stop()

st.text("Text after stop")


================================================
File: /e2e_playwright/st_stop_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect


def test_st_stop_stops_script(app: Page):
    expect(app.get_by_test_id("stText")).to_have_count(1)

    expect(app.get_by_test_id("stText")).to_have_text("Text before stop")


================================================
File: /e2e_playwright/st_table.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import random

import numpy as np
import pandas as pd

import streamlit as st
from shared.data_mocks import (
    BASE_TYPES_DF,
    DATETIME_TYPES_DF,
    INTERVAL_TYPES_DF,
    LIST_TYPES_DF,
    NUMBER_TYPES_DF,
    PERIOD_TYPES_DF,
    SPECIAL_TYPES_DF,
    UNSUPPORTED_TYPES_DF,
)

np.random.seed(0)
random.seed(0)

st.set_page_config(layout="wide")

st.header("Empty tables")
st.table()
st.table([])
st.table(np.array(0))
st.table(pd.DataFrame([]))
st.table(np.array([]))
st.table(pd.DataFrame({"lat": [], "lon": []}))

st.header("Column types")

st.subheader("Base types")
st.table(BASE_TYPES_DF)

st.subheader("Number types")
st.table(NUMBER_TYPES_DF)

st.subheader("Date, time and datetime types")
st.table(DATETIME_TYPES_DF)

st.subheader("List types")
st.table(LIST_TYPES_DF)

st.subheader("Interval dtypes in pd.DataFrame")
st.table(INTERVAL_TYPES_DF)

st.subheader("Period dtypes in pd.DataFrame")
st.table(PERIOD_TYPES_DF)

st.subheader("Special types")
st.table(SPECIAL_TYPES_DF)

st.subheader("Unsupported types (by Arrow)")
st.table(UNSUPPORTED_TYPES_DF)

st.header("Index types")

st.subheader("String Index (pd.Index)")
st.table(BASE_TYPES_DF.set_index("string"))

st.subheader("Float64 Index (pd.Float64Index)")
st.table(NUMBER_TYPES_DF.set_index("float64"))

st.subheader("Int64 Index (pd.Int64Index)")
st.table(NUMBER_TYPES_DF.set_index("int64"))

st.subheader("Uint64 Index (pd.UInt64Index)")
st.table(NUMBER_TYPES_DF.set_index("uint64"))

st.subheader("Datetime Index (pd.DatetimeIndex)")
st.table(DATETIME_TYPES_DF.set_index("datetime"))

st.subheader("Date Index (pd.Index)")
st.table(DATETIME_TYPES_DF.set_index("date"))

st.subheader("Time Index (pd.Index)")
st.table(DATETIME_TYPES_DF.set_index("time"))

st.subheader("Interval Index (pd.IntervalIndex)")
st.table(INTERVAL_TYPES_DF.set_index("int64_both"))

st.subheader("List Index (pd.Index)")
st.table(LIST_TYPES_DF.set_index("string_list"))

st.subheader("Multi Index (pd.MultiIndex)")
st.table(BASE_TYPES_DF.set_index(["string", "int64"]))

st.subheader("Categorical Index (pd.CategoricalIndex)")
st.table(SPECIAL_TYPES_DF.set_index("categorical"))

st.subheader("Period Index (pd.PeriodIndex)")
st.table(PERIOD_TYPES_DF.set_index("D"))

st.subheader("Timedelta Index (pd.TimedeltaIndex)")
st.table(SPECIAL_TYPES_DF.set_index("timedelta"))

st.header("Pandas Styler Support")

st.subheader("Pandas Styler: Value formatting")
df = pd.DataFrame({"test": [3.1423424, 3.1]})
st.table(df.style.format({"test": "{:.2f}"}))

st.subheader("Pandas Styler: Background color")


def highlight_first(value):
    return "background-color: yellow" if value == 0 else ""


df = pd.DataFrame(np.arange(0, 100, 1).reshape(10, 10))
st.table(df.style.map(highlight_first))

st.subheader("Pandas Styler: Background and font styling")

df = pd.DataFrame(np.random.randn(10, 4), columns=["A", "B", "C", "D"])


def style_negative(v, props=""):
    return props if v < 0 else None


def highlight_max(s, props=""):
    return np.where(s == np.nanmax(s.values), props, "")


# Passing style values w/ all color formats to test css-style-string parsing robustness.
styled_df = df.style.map(style_negative, props="color:#FF0000;").map(
    lambda v: "opacity: 20%;" if (v < 0.3) and (v > -0.3) else None
)

styled_df.apply(
    highlight_max, props="color:white;background-color:rgb(255, 0, 0)", axis=0
)

styled_df.apply(
    highlight_max, props="color:white;background-color:hsl(273, 98%, 60%);", axis=1
).apply(highlight_max, props="color:white;background-color:purple", axis=None)

st.table(styled_df)

st.subheader("Pandas Styler: Gradient Styling + Caption")

weather_df = pd.DataFrame(
    np.random.rand(10, 2) * 5,
    index=pd.date_range(start="2021-01-01", periods=10),
    columns=["Tokyo", "Beijing"],
)


def rain_condition(v):
    if v < 1.75:
        return "Dry"
    elif v < 2.75:
        return "Rain"
    return "Heavy Rain"


def make_pretty(styler):
    styler.set_caption("Weather Conditions")
    styler.format(rain_condition)
    styler.background_gradient(axis=None, vmin=1, vmax=5, cmap="YlGnBu")
    return styler


styled_df = weather_df.style.pipe(make_pretty)

st.table(styled_df)


================================================
File: /e2e_playwright/st_table_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class

TOTAL_TABLE_ELEMENTS = 31


def test_table_rendering(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.table renders correctly via snapshot testing."""
    table_elements = app.get_by_test_id("stTable")
    expect(table_elements).to_have_count(TOTAL_TABLE_ELEMENTS)

    for i, element in enumerate(table_elements.all()):
        assert_snapshot(element, name=f"st_table-{i}")


def test_themed_table_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.table renders correctly with different theming."""
    table_elements = themed_app.get_by_test_id("stTable")
    expect(table_elements).to_have_count(TOTAL_TABLE_ELEMENTS)

    # Only test a single table element to ensure theming is applied correctly:
    assert_snapshot(table_elements.nth(30), name="st_table-themed")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stTable")


================================================
File: /e2e_playwright/st_tabs.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

tab1, tab2, tab3 = st.tabs(["Tab 1", "Tab 2", "Tab 3"])

with tab1:
    st.write("tab1")
    st.text_input("Text input")

with tab2:
    st.write("tab2")
    st.number_input("Number input")

with tab3:
    st.write("tab3")
    st.date_input("Date input")

with st.expander("Expander", expanded=True):
    many_tabs = st.tabs([f"Tab {i}" for i in range(25)])

sidebar_tab1, sidebar_tab2 = st.sidebar.tabs(["Foo", "Bar"])
sidebar_tab1.write("I am in the sidebar")
sidebar_tab2.write("I'm also in the sidebar")


================================================
File: /e2e_playwright/st_tabs_selection.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.subheader("Control Panel", divider="blue")

if "tabs" not in st.session_state:
    st.session_state["tabs"] = ["Tab 1", "Tab 2"]
if "add_tab" not in st.session_state:
    st.session_state["add_tab"] = False
if "remove_1" not in st.session_state:
    st.session_state["remove_1"] = False
if "remove_2" not in st.session_state:
    st.session_state["remove_2"] = False
if "change" not in st.session_state:
    st.session_state["change"] = False


def on_click_1():
    st.session_state.add_tab = True


def on_click_2():
    st.session_state.remove_1 = True


def on_click_3():
    st.session_state.remove_2 = True


def on_click_4():
    st.session_state.change = True
    on_click_1()
    on_click_2()
    on_click_3()


def on_click_5():
    on_click_4()


def reset():
    st.session_state.clear()


col1, col2, col3, col4, col5 = st.columns([0.8, 1, 1, 1.2, 1], gap="small")
with col1:
    add_tab = st.button(
        "Add Tab 3",
        on_click=on_click_1,
        disabled=st.session_state.add_tab,
        use_container_width=True,
    )
with col2:
    remove_1 = st.button(
        "Remove Tab 1",
        on_click=on_click_2,
        disabled=st.session_state.remove_1,
        use_container_width=True,
    )
with col3:
    remove_2 = st.button(
        "Remove Tab 2",
        on_click=on_click_3,
        disabled=st.session_state.remove_2,
        use_container_width=True,
    )
with col4:
    change_some = st.button(
        "Change Tab 1 & 3",
        on_click=on_click_4,
        disabled=st.session_state.change,
        use_container_width=True,
    )
    change = st.button(
        "Change All Tabs",
        on_click=on_click_5,
        disabled=st.session_state.change,
        use_container_width=True,
    )
with col5:
    st.button("**Reset Tabs**", on_click=reset)

st.subheader("Tabs Example", divider="green")

if add_tab:
    st.session_state.tabs.append("Tab 3")

if remove_1:
    index = st.session_state.tabs.index("Tab 1")
    st.session_state.tabs.pop(index)

if remove_2:
    index = st.session_state.tabs.index("Tab 2")
    st.session_state.tabs.pop(index)

if change:
    if "Tab 1" in st.session_state.tabs:
        st.session_state.tabs[st.session_state.tabs.index("Tab 1")] = "Tab A"
    if "Tab 2" in st.session_state.tabs:
        st.session_state.tabs[st.session_state.tabs.index("Tab 2")] = "Tab B"
    if "Tab 3" in st.session_state.tabs:
        st.session_state.tabs[st.session_state.tabs.index("Tab 3")] = "Tab C"

if change_some:
    if "Tab 1" in st.session_state.tabs:
        st.session_state.tabs[st.session_state.tabs.index("Tab 1")] = "Tab A"
    if "Tab 3" in st.session_state.tabs:
        st.session_state.tabs[st.session_state.tabs.index("Tab 3")] = "Tab C"


tabs = st.tabs(st.session_state.tabs)

for tabs_index, tab in enumerate(tabs):
    with tab:
        st.write(f"You are in Tab {tabs_index + 1}")
        st.slider(f"Slider {tabs_index + 1}", 0, 10, 5, key=tab)


================================================
File: /e2e_playwright/st_tabs_selection_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import click_button

EXPANDER_HEADER_IDENTIFIER = ".streamlit-expanderHeader"


def test_default_selection_first_tab(app: Page, assert_snapshot: ImageCompareFunction):
    """Test st.tabs has first tab selected as default."""
    assert_snapshot(app.get_by_test_id("stTabs"), name="st_tabs-default")


def test_maintains_selection_when_other_tab_added(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test st.tabs maintains selected tab if additional tab added."""
    tab_buttons = app.get_by_test_id("stTabs").locator("button[role=tab]")
    # Select Tab 2
    tab_buttons.nth(1).click()

    click_button(app, "Add Tab 3")

    # Wait for tabs to properly load
    wait_for_app_run(app, wait_delay=500)
    assert_snapshot(app.get_by_test_id("stTabs"), name="st_tabs-selection_add_tab")


def test_maintains_selection_when_other_tab_removed(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test st.tabs maintains selected tab if non-selected tab removed."""
    click_button(app, "Reset Tabs")
    click_button(app, "Add Tab 3")

    # Select Tab 3
    tab_buttons = app.get_by_test_id("stTabs").locator("button[role=tab]")
    tab_buttons.nth(2).click()

    click_button(app, "Remove Tab 1")

    # Wait for tabs to properly load
    wait_for_app_run(app, wait_delay=500)
    assert_snapshot(app.get_by_test_id("stTabs"), name="st_tabs-selection_remove_tab")


def test_resets_selection_when_selected_tab_removed(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test st.tabs resets selected tab to 1 if previously selected tab removed."""
    # Reset Tabs
    click_button(app, "Reset Tabs")

    wait_for_app_run(app)
    # Select Tab 2
    tab_buttons = app.get_by_test_id("stTabs").locator("button[role=tab]")
    tab_buttons.nth(1).click()

    click_button(app, "Remove Tab 2")

    # Wait for tabs to properly load
    wait_for_app_run(app, wait_delay=500)
    assert_snapshot(app.get_by_test_id("stTabs"), name="st_tabs-remove_selected")


def test_maintains_selection_when_same_name_exists(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test when tabs names change, keep selected tab if matching label still exists."""

    click_button(app, "Reset Tabs")
    click_button(app, "Add Tab 3")

    tab_buttons = app.get_by_test_id("stTabs").locator("button[role=tab]")
    tab_buttons.nth(1).click()

    # Ensure that the click worked and the highlight animation finished
    # to avoid issues with the snapshot later. The 'tab-highlight' element
    # is always visible for the selected tab and its always the same element
    # that simply changes the position using CSS transform.
    expect(tab_buttons.nth(1)).to_have_attribute("aria-selected", "true")
    tab_highlight_element = app.locator("[data-baseweb='tab-highlight']")
    expect(tab_highlight_element).to_be_visible()
    tab_highlight_element.evaluate(
        """
        element => Promise.all(
                element.getAnimations().map((animation) => animation.finished)
            )
        """
    )

    # Change Tab 1 & 3 Names
    click_button(app, "Change Tab 1 & 3")
    # Wait for tabs to properly load
    wait_for_app_run(app, wait_delay=500)
    assert_snapshot(app.get_by_test_id("stTabs"), name="st_tabs-change_some_names")


def test_resets_selection_when_tab_names_change(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test when tabs names change, reset selected tab if no matching label exists."""
    # Reset Tabs
    click_button(app, "Reset Tabs")

    wait_for_app_run(app)
    # Select Tab 2
    tab_buttons = app.get_by_test_id("stTabs").locator("button[role=tab]")
    tab_buttons.nth(1).click()

    click_button(app, "Change All Tabs")

    # Wait for tabs to properly load
    wait_for_app_run(app, wait_delay=500)
    assert_snapshot(app.get_by_test_id("stTabs"), name="st_tabs-change_all_names")


================================================
File: /e2e_playwright/st_tabs_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class, get_expander


def test_tabs_render_correctly(themed_app: Page, assert_snapshot: ImageCompareFunction):
    st_tabs = themed_app.get_by_test_id("stTabs")
    expect(st_tabs).to_have_count(3)

    assert_snapshot(st_tabs.nth(0), name="st_tabs-sidebar")
    assert_snapshot(st_tabs.nth(1), name="st_tabs-text_input")
    assert_snapshot(st_tabs.nth(2), name="st_tabs-many")


def test_displays_correctly_in_sidebar(app: Page):
    expect(app.get_by_test_id("stSidebar").get_by_test_id("stTab")).to_have_count(2)
    expect(app.get_by_text("I am in the sidebar")).to_have_count(1)
    expect(app.get_by_text("I am in the sidebarI'm also in the sidebar")).to_have_count(
        1
    )


def test_contains_all_tabs_when_overflowing(app: Page):
    expect(get_expander(app, "Expander").get_by_test_id("stTab")).to_have_count(25)


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stTabs")


================================================
File: /e2e_playwright/st_text.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.text("This text is awesome!")
st.text("_This text is **awesome**!_")
st.text("Text with a help tooltip", help="This is a help tooltip!")
st.text("Lorem\n\n\n\nipsum\ndolor\nsit\namet")
st.text("Lorem\\nipsum")
st.text("Lorem      ipsum\tdolor\t\tsit amet")
st.text(
    "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum."
)


================================================
File: /e2e_playwright/st_text_area.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit import runtime
from streamlit.errors import StreamlitAPIException

v1 = st.text_area("text area 1 (default)")
st.write("value 1:", v1)

v2 = st.text_area("text area 2 (value='some text')", "some text")
st.write("value 2:", v2)

v3 = st.text_area("text area 3 (value=1234)", 1234)
st.write("value 3:", v3)

v4 = st.text_area("text area 4 (value=None)", None)
st.write("value 4:", v4)

v5 = st.text_area("text area 5 (placeholder)", placeholder="Placeholder")
st.write("value 5:", v5)

v6 = st.text_area("text area 6 (disabled)", "default text", disabled=True)
st.write("value 6:", v6)

v7 = st.text_area(
    "text area 7 (hidden label)", "default text", label_visibility="hidden"
)
st.write("value 7:", v7)

v8 = st.text_area(
    "text area 8 (collapsed label)", "default text", label_visibility="collapsed"
)
st.write("value 8:", v8)

if runtime.exists():

    def on_change():
        st.session_state.text_area_changed = True
        st.text("text area changed callback")

    st.text_area(
        "text area 9 (callback, help)",
        key="text_area9",
        on_change=on_change,
        help="Help text",
    )
    st.write("value 9:", st.session_state.text_area9)
    st.write("text area changed:", st.session_state.get("text_area_changed") is True)
    # Reset to False:
    st.session_state.text_area_changed = False

v10 = st.text_area("text area 10 (max_chars=5)", "1234", max_chars=5)
st.write("value 10:", v10)

v11 = st.text_area("text area 11 (height=250)", "default text", height=250)
st.write("value 11:", v11)

v12 = st.text_area("text area 12 (height=75)", "default text", height=75)
st.write("value 12:", v12)

# Error case: height < 68px
try:
    st.text_area("text area 13 (height=65)", "default text", height=65)
except StreamlitAPIException as ex:
    st.exception(ex)

if "text_area_13" not in st.session_state:
    st.session_state["text_area_13"] = "xyz"

v13 = st.text_area(
    "text area 13 (value from state)",
    value=None,
    key="text_area_13",
)
st.write("text area 13 (value from state) - value: ", v13)

with st.form("form"):
    st.text_area("text area 14 (value from form)", key="text_area_14")
    st.form_submit_button("submit")

form_value = (
    st.session_state["text_area_14"] if "text_area_14" in st.session_state else None
)
st.write("text area 14 (value from form) - value: ", form_value)


================================================
File: /e2e_playwright/st_text_area_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    expect_exception,
    expect_help_tooltip,
    get_element_by_key,
)


def test_text_area_widget_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the st.text_area widgets are correctly rendered via screenshot matching."""
    text_area_widgets = themed_app.get_by_test_id("stTextArea")
    expect(text_area_widgets).to_have_count(14)

    assert_snapshot(text_area_widgets.nth(0), name="st_text_area-default")
    assert_snapshot(text_area_widgets.nth(1), name="st_text_area-value_some_text")
    assert_snapshot(text_area_widgets.nth(2), name="st_text_area-value_1234")
    assert_snapshot(text_area_widgets.nth(3), name="st_text_area-value_None")
    assert_snapshot(text_area_widgets.nth(4), name="st_text_area-placeholder")
    assert_snapshot(text_area_widgets.nth(5), name="st_text_area-disabled")
    assert_snapshot(text_area_widgets.nth(6), name="st_text_area-hidden_label")
    assert_snapshot(text_area_widgets.nth(7), name="st_text_area-collapsed_label")
    assert_snapshot(text_area_widgets.nth(8), name="st_text_area-callback_help")
    assert_snapshot(text_area_widgets.nth(9), name="st_text_area-max_chars_5")
    assert_snapshot(text_area_widgets.nth(10), name="st_text_area-height_250")
    assert_snapshot(text_area_widgets.nth(11), name="st_text_area-height_75")


def test_help_tooltip_works(app: Page):
    element_with_help = app.get_by_test_id("stTextArea").nth(8)
    expect_help_tooltip(app, element_with_help, "Help text")


def test_text_area_has_correct_initial_values(app: Page):
    """Test that st.text_area has the correct initial values."""
    markdown_elements = app.get_by_test_id("stMarkdown")
    expect(markdown_elements).to_have_count(15)

    expected = [
        "value 1: ",
        "value 2: some text",
        "value 3: 1234",
        "value 4: None",
        "value 5: ",
        "value 6: default text",
        "value 7: default text",
        "value 8: default text",
        "value 9: ",
        "text area changed: False",
        "value 10: 1234",
        "value 11: default text",
        "value 12: default text",
        "text area 13 (value from state) - value: xyz",
        "text area 14 (value from form) - value: ",
    ]

    for markdown_element, expected_text in zip(markdown_elements.all(), expected):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_text_area_shows_state_value(app: Page):
    expect(
        app.get_by_test_id("stTextArea").nth(12).locator("textarea").first
    ).to_have_text("xyz")


def test_text_area_shows_instructions_when_dirty(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.text_area shows the instructions correctly when dirty."""
    text_area = app.get_by_test_id("stTextArea").nth(9)

    text_area_field = text_area.locator("textarea").first
    text_area_field.fill("123")

    assert_snapshot(text_area, name="st_text_area-input_instructions")


def test_text_area_limits_input_via_max_chars(app: Page):
    """Test that st.text_area correctly limits the number of characters via max_chars."""
    text_area_field = app.get_by_test_id("stTextArea").nth(9).locator("textarea").first
    # Try typing in char by char:
    text_area_field.clear()
    text_area_field.type("12345678")
    text_area_field.press("Control+Enter")

    expect(app.get_by_test_id("stMarkdown").nth(10)).to_have_text(
        "value 10: 12345", use_inner_text=True
    )

    # Try filling in everything at once:
    text_area_field.focus()
    text_area_field.fill("12345678")
    text_area_field.press("Control+Enter")

    expect(app.get_by_test_id("stMarkdown").nth(10)).to_have_text(
        "value 10: 12345", use_inner_text=True
    )


def test_text_area_has_correct_value_on_blur(app: Page):
    """Test that st.text_area has the correct value on blur."""

    first_text_area_field = (
        app.get_by_test_id("stTextArea").first.locator("textarea").first
    )
    first_text_area_field.focus()
    first_text_area_field.fill("hello world")
    first_text_area_field.blur()

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "value 1: hello world", use_inner_text=True
    )


@pytest.mark.skip_browser(
    "firefox"  # The meta key + enter press doesn't work in the playwright firefox test
)
def test_text_area_has_correct_value_on_enter(app: Page):
    """Test that st.text_area has the correct value on enter."""

    first_text_area_field = (
        app.get_by_test_id("stTextArea").first.locator("textarea").first
    )
    # Test control + enter:
    first_text_area_field.focus()
    first_text_area_field.fill("hello world")
    first_text_area_field.press("Control+Enter")

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "value 1: hello world", use_inner_text=True
    )

    # Test command (Meta key) + enter:
    first_text_area_field.focus()
    first_text_area_field.fill("different value")
    first_text_area_field.press("Meta+Enter")

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "value 1: different value", use_inner_text=True
    )


def test_text_area_has_correct_value_on_click_outside(app: Page):
    """Test that st.text_area has the correct value on click outside."""

    first_text_area_field = (
        app.get_by_test_id("stTextArea").first.locator("textarea").first
    )
    first_text_area_field.focus()
    first_text_area_field.fill("hello world")
    app.get_by_test_id("stMarkdown").first.click()

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "value 1: hello world", use_inner_text=True
    )


def test_empty_text_area_behaves_correctly(app: Page):
    """Test that st.text_area behaves correctly when empty."""
    # Should return None as value:
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text(
        "value 4: None", use_inner_text=True
    )

    # Enter value in the empty widget:
    empty_text_area = app.get_by_test_id("stTextArea").nth(3)
    empty_text_area_field = empty_text_area.locator("textarea").first
    empty_text_area_field.fill("hello world")
    empty_text_area_field.press("Control+Enter")

    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text(
        "value 4: hello world", use_inner_text=True
    )

    # Press escape to clear value:
    empty_text_area_field.focus()
    empty_text_area_field.clear()
    empty_text_area_field.press("Control+Enter")

    # Should be set to empty string (we don't clear to None for text area):
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text(
        "value 4: ", use_inner_text=True
    )


def test_calls_callback_on_change(app: Page):
    """Test that it correctly calls the callback on change."""
    text_area_field = app.get_by_test_id("stTextArea").nth(8).locator("textarea").first

    text_area_field.fill("hello world")
    text_area_field.press("Control+Enter")

    expect(app.get_by_test_id("stMarkdown").nth(8)).to_have_text(
        "value 9: hello world",
        use_inner_text=True,
    )
    expect(app.get_by_test_id("stMarkdown").nth(9)).to_have_text(
        "text area changed: True",
        use_inner_text=True,
    )

    # Change different widget to trigger delta path change
    first_text_area_field = (
        app.get_by_test_id("stTextArea").first.locator("textarea").first
    )
    first_text_area_field.fill("hello world")
    first_text_area_field.press("Control+Enter")

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "value 1: hello world", use_inner_text=True
    )

    # Test if value is still correct after delta path change
    expect(app.get_by_test_id("stMarkdown").nth(8)).to_have_text(
        "value 9: hello world",
        use_inner_text=True,
    )
    expect(app.get_by_test_id("stMarkdown").nth(9)).to_have_text(
        "text area changed: False",
        use_inner_text=True,
    )


def test_text_area_in_form_with_submit_by_enter(app: Page):
    """Test that text area in form can be submitted by pressing Command+Enter"""
    text_area_field = app.get_by_test_id("stTextArea").nth(13).locator("textarea").first
    text_area_field.fill("hello world")
    text_area_field.press("Control+Enter")
    expect(app.get_by_test_id("stMarkdown").nth(14)).to_have_text(
        "text area 14 (value from form) - value: hello world",
        use_inner_text=True,
    )


def test_invalid_height(app: Page):
    """Test that it raises an error when passed an invalid height."""
    expect_exception(
        app,
        "StreamlitAPIException: Invalid height 65px for st.text_area - must be at least 68 pixels.",
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stTextArea")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "text_area9")).to_be_visible()


================================================
File: /e2e_playwright/st_text_input.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit import runtime

v1 = st.text_input("text input 1 (default)")
st.write("value 1:", v1)

v2 = st.text_input("text input 2 (value='some text')", "some text")
st.write("value 2:", v2)

v3 = st.text_input("text input 3 (value=1234)", 1234)
st.write("value 3:", v3)

v4 = st.text_input("text input 4 (value=None)", None)
st.write("value 4:", v4)

v5 = st.text_input("text input 5 (placeholder)", placeholder="Placeholder")
st.write("value 5:", v5)

v6 = st.text_input("text input 6 (disabled)", "default text", disabled=True)
st.write("value 6:", v6)

v7 = st.text_input(
    "text input 7 (hidden label)", "default text", label_visibility="hidden"
)
st.write("value 7:", v7)

v8 = st.text_input(
    "text input 8 (collapsed label)", "default text", label_visibility="collapsed"
)
st.write("value 8:", v8)

if runtime.exists():

    def on_change():
        st.session_state.text_input_changed = True
        st.text("Text input changed callback")

    st.text_input(
        "text input 9 (callback, help)",
        key="text_input_9",
        on_change=on_change,
        help="Help text",
    )
    st.write("value 9:", st.session_state.text_input_9)
    st.write("text input changed:", st.session_state.get("text_input_changed") is True)
    st.session_state.text_input_changed = False

v10 = st.text_input("text input 10 (max_chars=5)", "1234", max_chars=5)
st.write("value 10:", v10)

v11 = st.text_input("text input 11 (type=password)", "my password", type="password")
st.write("value 11:", v11)

if "text_input_12" not in st.session_state:
    st.session_state["text_input_12"] = "xyz"

v12 = st.text_input(
    "text input 12 (value from state)",
    value=None,
    key="text_input_12",
)
st.write("text input 12 (value from state) - value: ", v12)

with st.form("form"):
    st.text_input("text input 13 (value from form)", key="text_input_13")
    st.form_submit_button("submit")

form_value = (
    st.session_state["text_input_13"] if "text_input_13" in st.session_state else None
)
st.write("text input 13 (value from form) - value: ", form_value)


if "rerun_counter" not in st.session_state:
    st.session_state.rerun_counter = 0

st.session_state.rerun_counter += 1
st.write("Rerun counter:", st.session_state.rerun_counter)


================================================
File: /e2e_playwright/st_text_input_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    expect_help_tooltip,
    get_element_by_key,
)


def test_text_input_widget_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the st.text_input widgets are correctly rendered via screenshot matching."""
    text_input_widgets = themed_app.get_by_test_id("stTextInput")
    expect(text_input_widgets).to_have_count(13)

    assert_snapshot(text_input_widgets.nth(0), name="st_text_input-default")
    assert_snapshot(text_input_widgets.nth(1), name="st_text_input-value_some_text")
    assert_snapshot(text_input_widgets.nth(2), name="st_text_input-value_1234")
    assert_snapshot(text_input_widgets.nth(3), name="st_text_input-value_None")
    assert_snapshot(text_input_widgets.nth(4), name="st_text_input-placeholder")
    assert_snapshot(text_input_widgets.nth(5), name="st_text_input-disabled")
    assert_snapshot(text_input_widgets.nth(6), name="st_text_input-hidden_label")
    assert_snapshot(text_input_widgets.nth(7), name="st_text_input-collapsed_label")
    assert_snapshot(text_input_widgets.nth(8), name="st_text_input-callback_help")
    assert_snapshot(text_input_widgets.nth(9), name="st_text_input-max_chars_5")
    assert_snapshot(text_input_widgets.nth(10), name="st_text_input-type_password")


def test_text_input_has_correct_initial_values(app: Page):
    """Test that st.text_input has the correct initial values."""
    markdown_elements = app.get_by_test_id("stMarkdown")
    expect(markdown_elements).to_have_count(15)

    expected = [
        "value 1: ",
        "value 2: some text",
        "value 3: 1234",
        "value 4: None",
        "value 5: ",
        "value 6: default text",
        "value 7: default text",
        "value 8: default text",
        "value 9: ",
        "text input changed: False",
        "value 10: 1234",
        "value 11: my password",
    ]

    for markdown_element, expected_text in zip(markdown_elements.all(), expected):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_text_input_shows_instructions_when_dirty(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.text_input shows the instructions correctly when dirty."""
    text_input = app.get_by_test_id("stTextInput").nth(9)

    text_input_field = text_input.locator("input").first
    text_input_field.fill("123")

    assert_snapshot(text_input, name="st_text_input-input_instructions")


def test_text_input_limits_input_via_max_chars(app: Page):
    """Test that st.text_input correctly limits the number of characters via max_chars."""
    text_input_field = app.get_by_test_id("stTextInput").nth(9).locator("input").first
    # Try typing in char by char:
    text_input_field.clear()
    text_input_field.type("12345678")
    text_input_field.press("Enter")

    expect(app.get_by_test_id("stMarkdown").nth(10)).to_have_text(
        "value 10: 12345", use_inner_text=True
    )

    # Try filling in everything at once:
    text_input_field.focus()
    text_input_field.fill("12345678")
    text_input_field.press("Enter")

    expect(app.get_by_test_id("stMarkdown").nth(10)).to_have_text(
        "value 10: 12345", use_inner_text=True
    )


def test_text_input_has_correct_value_on_blur(app: Page):
    """Test that st.text_input has the correct value on blur."""

    first_text_input_field = (
        app.get_by_test_id("stTextInput").first.locator("input").first
    )
    first_text_input_field.focus()
    first_text_input_field.fill("hello world")
    first_text_input_field.blur()

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "value 1: hello world", use_inner_text=True
    )


def test_text_input_has_correct_value_on_enter(app: Page):
    """Test that st.text_input has the correct value on enter."""

    first_text_input_field = (
        app.get_by_test_id("stTextInput").first.locator("input").first
    )
    first_text_input_field.focus()
    first_text_input_field.fill("hello world")
    first_text_input_field.press("Enter")

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "value 1: hello world", use_inner_text=True
    )


def test_text_input_has_correct_value_on_click_outside(app: Page):
    """Test that st.text_input has the correct value on click outside."""

    first_text_input_field = (
        app.get_by_test_id("stTextInput").first.locator("input").first
    )
    first_text_input_field.focus()
    first_text_input_field.fill("hello world")
    app.get_by_test_id("stMarkdown").first.click()

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "value 1: hello world", use_inner_text=True
    )


def test_text_input_does_not_trigger_rerun_when_value_does_not_change_and_click_outside(
    app: Page,
):
    """Test that st.text_input has the correct value on click outside."""

    expect(
        app.get_by_test_id("stMarkdown").filter(has_text="Rerun counter: 1")
    ).to_be_attached()

    first_text_input_field = (
        app.get_by_test_id("stTextInput").first.locator("input").first
    )
    first_text_input_field.focus()
    first_text_input_field.fill("hello world")
    app.get_by_test_id("stMarkdown").first.click()

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "value 1: hello world", use_inner_text=True
    )
    expect(
        app.get_by_test_id("stMarkdown").filter(has_text="Rerun counter: 2")
    ).to_be_attached()

    first_text_input_field.focus()
    app.get_by_test_id("stMarkdown").first.click()
    expect(
        app.get_by_test_id("stMarkdown").filter(has_text="Rerun counter: 2")
    ).to_be_attached()


def test_empty_text_input_behaves_correctly(app: Page):
    """Test that st.text_input behaves correctly when empty."""
    # Should return None as value:
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text(
        "value 4: None", use_inner_text=True
    )

    # Enter value in the empty widget:
    empty_text_input = app.get_by_test_id("stTextInput").nth(3)
    empty_text_input_field = empty_text_input.locator("input").first
    empty_text_input_field.fill("hello world")
    empty_text_input_field.press("Enter")

    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text(
        "value 4: hello world", use_inner_text=True
    )

    # Press escape to clear value:
    empty_text_input_field.focus()
    empty_text_input_field.clear()
    empty_text_input_field.press("Enter")

    # Should be set to empty string (we don't clear to None for text input):
    expect(app.get_by_test_id("stMarkdown").nth(3)).to_have_text(
        "value 4: ", use_inner_text=True
    )


def test_text_input_shows_state_value(app: Page):
    expect(app.get_by_test_id("stTextInput").nth(11).locator("input")).to_have_value(
        "xyz"
    )


def test_calls_callback_on_change(app: Page):
    """Test that it correctly calls the callback on change."""
    text_input_field = app.get_by_test_id("stTextInput").nth(8).locator("input").first

    text_input_field.fill("hello world")
    text_input_field.press("Enter")

    expect(app.get_by_test_id("stMarkdown").nth(8)).to_have_text(
        "value 9: hello world",
        use_inner_text=True,
    )
    expect(app.get_by_test_id("stMarkdown").nth(9)).to_have_text(
        "text input changed: True",
        use_inner_text=True,
    )

    # Change differentwidget to trigger delta path change
    first_text_input_field = (
        app.get_by_test_id("stTextInput").first.locator("input").first
    )
    first_text_input_field.fill("hello world")
    first_text_input_field.press("Enter")

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "value 1: hello world", use_inner_text=True
    )

    # Test if value is still correct after delta path change
    expect(app.get_by_test_id("stMarkdown").nth(8)).to_have_text(
        "value 9: hello world",
        use_inner_text=True,
    )
    expect(app.get_by_test_id("stMarkdown").nth(9)).to_have_text(
        "text input changed: False",
        use_inner_text=True,
    )


def test_text_input_in_form_with_submit_by_enter(app: Page):
    """Test that text area in form can be submitted by pressing Command+Enter"""
    text_area_field = app.get_by_test_id("stTextInput").nth(12).locator("input").first
    text_area_field.fill("hello world")
    text_area_field.press("Enter")
    expect(app.get_by_test_id("stMarkdown").nth(13)).to_have_text(
        "text input 13 (value from form) - value: hello world",
        use_inner_text=True,
    )


def test_help_tooltip_works(app: Page):
    """Test that the help tooltip is displayed on hover."""
    element_with_help = app.get_by_test_id("stTextInput").nth(8)
    expect_help_tooltip(app, element_with_help, "Help text")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stTextInput")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "text_input_9")).to_be_visible()


================================================
File: /e2e_playwright/st_text_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import check_top_level_class, expect_help_tooltip


def test_st_text_rendering(app: Page, assert_snapshot: ImageCompareFunction):
    assert_snapshot(app.get_by_test_id("stVerticalBlock"), name="st_text-rendering")


def test_st_text_shows_correct_text(app: Page):
    expect(app.get_by_test_id("stText").nth(0)).to_have_text("This text is awesome!")


def test_st_text_doesnt_apply_formatting(
    app: Page, assert_snapshot: ImageCompareFunction
):
    assert_snapshot(
        app.get_by_test_id("stText").nth(1), name="st_text-no_formatting_applied"
    )


def test_help_tooltip_works(app: Page):
    """Test that the help tooltip is displayed on hover."""
    text_with_help = app.get_by_test_id("stText").nth(2)
    expect_help_tooltip(app, text_with_help, "This is a help tooltip!")


def test_multiline_text(app: Page):
    """Test that multi-line text is displayed correctly."""
    multiline_text = app.get_by_test_id("stText").nth(3)
    expect(multiline_text).not_to_contain_text("\\n")

    # check that the text is displayed as multiline with its div's height > width
    bounding_box = multiline_text.locator("div").bounding_box()
    assert bounding_box is not None and bounding_box["height"] > bounding_box["width"]


def test_singleline_text_with_escape_char(app: Page):
    """Test that single-line text with escape char is displayed correctly."""
    singleline_text = app.get_by_test_id("stText").nth(4)
    expect(singleline_text).to_contain_text("\\n")


def test_no_scrollbar_for_long_text(app: Page):
    """Test that no scrollbar is shown for long text."""
    text_element = app.get_by_test_id("stText").nth(5)
    expect(text_element).not_to_have_class("scrollbar")


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stText")


================================================
File: /e2e_playwright/st_time_input.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from datetime import datetime, time

import streamlit as st
from streamlit import runtime

v1 = st.time_input("Time input 1 (8:45)", time(8, 45))
st.write("Value 1:", v1)

v2 = st.time_input(
    "Time input 2 (21:15, help)", datetime(2019, 7, 6, 21, 15), help="Help text"
)
st.write("Value 2:", v2)

v3 = st.time_input("Time input 3 (disabled)", time(8, 45), disabled=True)
st.write("Value 3:", v3)

v4 = st.time_input(
    "Time input 4 (hidden label)", time(8, 45), label_visibility="hidden"
)
st.write("Value 4:", v4)

v5 = st.time_input(
    "Time input 5 (collapsed label)", time(8, 45), label_visibility="collapsed"
)
st.write("Value 5:", v5)

if runtime.exists():

    def on_change():
        st.session_state.time_input_changed = True
        st.text("Time input callback triggered")

    st.time_input(
        "Time input 6 (with callback)",
        time(8, 45),
        key="time_input_6",
        on_change=on_change,
    )

    st.write("Value 6:", st.session_state.time_input_6)
    st.write("time input changed:", st.session_state.get("time_input_changed") is True)
    # Reset to False:
    st.session_state.time_input_changed = False

v7 = st.time_input("Time input 7 (step=60)", time(8, 45), step=60)
st.write("Value 7:", v7)


v8 = st.time_input("Time input 8 (empty)", value=None)
st.write("Value 8:", v8)

if "time_input_9" not in st.session_state:
    st.session_state["time_input_9"] = time(8, 50)

v9 = st.time_input(
    "Time input 9 (empty, from state)",
    value=None,
    key="time_input_9",
)
st.write("Value 9:", v9)


================================================
File: /e2e_playwright/st_time_input_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    expect_help_tooltip,
    get_element_by_key,
)


def test_time_input_widget_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the time input widgets are correctly rendered via screenshot matching."""
    time_input_widgets = themed_app.get_by_test_id("stTimeInput")
    expect(time_input_widgets).to_have_count(9)

    assert_snapshot(time_input_widgets.nth(0), name="st_time_input-8_45")
    assert_snapshot(time_input_widgets.nth(1), name="st_time_input-21_15_help")
    assert_snapshot(time_input_widgets.nth(2), name="st_time_input-disabled")
    assert_snapshot(time_input_widgets.nth(3), name="st_time_input-hidden_label")
    assert_snapshot(time_input_widgets.nth(4), name="st_time_input-collapsed_label")
    assert_snapshot(time_input_widgets.nth(5), name="st_time_input-callback")
    assert_snapshot(time_input_widgets.nth(6), name="st_time_input-step_60")
    assert_snapshot(time_input_widgets.nth(7), name="st_time_input-empty")
    assert_snapshot(time_input_widgets.nth(8), name="st_time_input-value_from_state")


def test_help_tooltip_works(app: Page):
    expect_help_tooltip(app, app.get_by_test_id("stTimeInput").nth(1), "Help text")


def test_time_input_has_correct_initial_values(app: Page):
    """Test that st.time_input returns the correct initial values."""
    markdown_elements = app.get_by_test_id("stMarkdown")
    expect(markdown_elements).to_have_count(10)

    expected = [
        "Value 1: 08:45:00",
        "Value 2: 21:15:00",
        "Value 3: 08:45:00",
        "Value 4: 08:45:00",
        "Value 5: 08:45:00",
        "Value 6: 08:45:00",
        "time input changed: False",
        "Value 7: 08:45:00",
        "Value 8: None",
        "Value 9: 08:50:00",
    ]
    for markdown_element, expected_text in zip(markdown_elements.all(), expected):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_handles_time_selection(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that selection of a time via the dropdown works correctly."""
    app.get_by_test_id("stTimeInput").nth(0).locator("input").click()

    # Take a snapshot of the time selection dropdown:
    selection_dropdown = app.locator('[data-baseweb="popover"]').first
    assert_snapshot(selection_dropdown, name="st_time_input-selection_dropdown")
    # Select the first option:
    selection_dropdown.locator("li").nth(0).click()
    # Check that selection worked:
    expect(app.get_by_test_id("stMarkdown").nth(0)).to_have_text(
        "Value 1: 00:00:00", use_inner_text=True
    )


def test_correct_menu_font_colors(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that it uses the correct colors in the popover menu."""
    themed_app.get_by_test_id("stTimeInput").nth(0).locator("input").click()

    # Take a snapshot of the time selection dropdown:
    selection_dropdown = themed_app.locator('[data-baseweb="popover"]').first

    # Hover over another option:
    selection_dropdown.get_by_text("08:30").hover()

    # Take a sceenshot
    assert_snapshot(selection_dropdown, name="st_time_input-menu_colors")


def test_handles_step_correctly(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that the step parameter is correctly applied."""
    app.get_by_test_id("stTimeInput").nth(6).locator("input").click()

    # Take a snapshot of the time selection dropdown:
    selection_dropdown = app.locator('[data-baseweb="popover"]').first
    assert_snapshot(selection_dropdown, name="st_time_input-step_60_dropdown")
    # Select the second option:
    selection_dropdown.locator("li").nth(1).click()
    # Check that selection worked:
    expect(app.get_by_test_id("stMarkdown").nth(7)).to_have_text(
        "Value 7: 00:01:00", use_inner_text=True
    )


def test_handles_time_selection_via_typing(app: Page):
    """Test that selection of a time via typing works correctly."""
    time_input_field = app.get_by_test_id("stTimeInput").first.locator("input")

    # Type an option:
    time_input_field.type("00:15")
    time_input_field.press("Enter")

    # Check that selection worked:
    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "Value 1: 00:15:00", use_inner_text=True
    )

    # Type an another option that doesn't exist in the dropdown:
    time_input_field.type("00:16")
    time_input_field.press("Enter")

    # Check that selection worked:
    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "Value 1: 00:16:00", use_inner_text=True
    )


def test_empty_time_input_behaves_correctly(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that st.time_input behaves correctly when empty (no initial value)."""
    empty_time_input = app.get_by_test_id("stTimeInput").nth(7)
    empty_time_input_field = empty_time_input.locator("input")

    # Type an option:
    empty_time_input_field.type("00:15")
    empty_time_input_field.press("Enter")

    expect(app.get_by_test_id("stMarkdown").nth(8)).to_have_text(
        "Value 8: 00:15:00", use_inner_text=True
    )

    assert_snapshot(empty_time_input, name="st_time_input-clearable_input")

    # Clear the input:
    empty_time_input.get_by_test_id("stTimeInputClearButton").click()

    # Should be empty again:
    expect(app.get_by_test_id("stMarkdown").nth(8)).to_have_text(
        "Value 8: None", use_inner_text=True
    )


def test_keeps_value_on_selection_close(app: Page):
    """Test that the selection is kept when the dropdown is closed."""
    app.get_by_test_id("stTimeInput").first.locator("input").click()

    # Check if popover is visible:
    expect(app.locator('[data-baseweb="popover"]').first).to_be_visible()

    # Click outside to close the dropdown:
    app.get_by_test_id("stApp").click(position={"x": 0, "y": 0})

    # Check if value is still initial value:
    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "Value 1: 08:45:00", use_inner_text=True
    )


def test_handles_callback_on_change_correctly(app: Page):
    """Test that it correctly calls the callback on change."""
    # Check initial state:
    expect(app.get_by_test_id("stMarkdown").nth(5)).to_have_text(
        "Value 6: 08:45:00", use_inner_text=True
    )
    expect(app.get_by_test_id("stMarkdown").nth(6)).to_have_text(
        "time input changed: False", use_inner_text=True
    )

    app.get_by_test_id("stTimeInput").nth(5).locator("input").click()

    # Select last option:
    time_dropdown = app.locator('[data-baseweb="popover"]').first
    time_dropdown.locator("li").first.click()

    # Check that selection worked:
    expect(app.get_by_test_id("stMarkdown").nth(5)).to_have_text(
        "Value 6: 00:00:00", use_inner_text=True
    )
    expect(app.get_by_test_id("stMarkdown").nth(6)).to_have_text(
        "time input changed: True", use_inner_text=True
    )

    # Change different input to trigger delta path change
    empty_time_input_field = app.get_by_test_id("stTimeInput").locator("input").first

    # Type an option:
    empty_time_input_field.type("00:15")
    empty_time_input_field.press("Enter")

    expect(app.get_by_test_id("stMarkdown").first).to_have_text(
        "Value 1: 00:15:00", use_inner_text=True
    )
    expect(app.get_by_test_id("stMarkdown").nth(5)).to_have_text(
        "Value 6: 00:00:00", use_inner_text=True
    )
    # The flag should be reset to False:
    expect(app.get_by_test_id("stMarkdown").nth(6)).to_have_text(
        "time input changed: False", use_inner_text=True
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stTimeInput")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "time_input_6")).to_be_visible()


================================================
File: /e2e_playwright/st_toast.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.set_page_config(layout="wide")
st.chat_input("input here")
st.toast("This is a default toast message", icon="🐶")
st.toast(
    "Random toast message that is a really really really really really really really long message, going way past the 3 line limit",
    icon="🦄",
)

st.toast("Your edited image was saved!", icon=":material/cabin:")


================================================
File: /e2e_playwright/st_toast_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_loaded


def test_default_toast_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that toasts are correctly rendered."""
    themed_app.keyboard.press("r")
    wait_for_app_loaded(themed_app)
    themed_app.wait_for_timeout(250)

    toasts = themed_app.get_by_test_id("stToast")
    expect(toasts).to_have_count(3)
    toasts.nth(2).hover()

    expect(toasts.nth(2)).to_contain_text("🐶This is a default toast message")
    assert_snapshot(toasts.nth(2), name="toast-default")


def test_collapsed_toast_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test collapsed long toasts are correctly rendered."""
    themed_app.keyboard.press("r")
    wait_for_app_loaded(themed_app)
    themed_app.wait_for_timeout(250)

    toasts = themed_app.get_by_test_id("stToast")
    expect(toasts).to_have_count(3)
    toasts.nth(1).hover()

    expect(toasts.nth(1)).to_contain_text(
        "🦄Random toast message that is a really really really really really really really long message, going wayview moreClose"
    )
    assert_snapshot(toasts.nth(1), name="toast-collapsed")


def test_expanded_toast_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test expanded long toasts are correctly rendered."""
    themed_app.keyboard.press("r")
    wait_for_app_loaded(themed_app)
    themed_app.wait_for_timeout(250)

    toasts = themed_app.get_by_test_id("stToast")
    expect(toasts).to_have_count(3)
    toasts.nth(1).hover()

    expand = themed_app.get_by_text("view more")
    expect(expand).to_have_count(1)
    expand.click()

    expect(toasts.nth(1)).to_contain_text(
        "🦄Random toast message that is a really really really really really really really long message, going way past the 3 line limitview lessClose"
    )
    assert_snapshot(toasts.nth(1), name="toast-expanded")


def test_toast_with_material_icon_rendering(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that toasts with material icons are correctly rendered."""
    themed_app.keyboard.press("r")
    wait_for_app_loaded(themed_app)
    themed_app.wait_for_timeout(250)

    toasts = themed_app.get_by_test_id("stToast")
    expect(toasts).to_have_count(3)
    toasts.nth(0).hover()

    expect(toasts.nth(0)).to_contain_text("cabinYour edited image was saved!Close")
    assert_snapshot(toasts.nth(0), name="toast-material-icon")


================================================
File: /e2e_playwright/st_toggle.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st
from streamlit import runtime

i1 = st.toggle("toggle 1 (True)", True)
st.write("toggle 1 - value:", i1)

i2 = st.toggle("toggle 2 (False)", False)
st.write("toggle 2 - value:", i2)

i3 = st.toggle(
    "toggle 3: This is a really really really really long label that should wrap eventually if we keep addding more text to it "
)
st.write("toggle 3 - value:", i3)

if runtime.exists():

    def on_change():
        st.session_state.toggle_clicked = True

    st.toggle("toggle 4 (with callback)", key="toggle4", on_change=on_change)
    st.write("toggle 4 - value:", st.session_state.toggle4)
    st.write("toggle 4 - clicked:", "toggle_clicked" in st.session_state)

i5 = st.toggle("toggle 5 (False, disabled)", disabled=True)
st.write("toggle 5 - value:", i5)

i6 = st.toggle("toggle 6 (True, disabled)", value=True, disabled=True)
st.write("toggle 6 - value:", i6)

i7 = st.toggle("toggle 7 (label hidden)", label_visibility="hidden")
st.write("toggle 7 - value:", i7)

i8 = st.toggle("toggle 8 (label collapsed)", label_visibility="collapsed")
st.write("toggle 8 - value:", i8)

with st.expander("Grouped toggles", expanded=True):
    st.toggle("toggle group - 1")
    st.toggle("toggle group - 2")
    st.toggle("toggle group - 3")
    st.text("A non-toggle element")


================================================
File: /e2e_playwright/st_toggle_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    get_element_by_key,
    get_expander,
)

TOGGLE_ELEMENTS = 11


def test_toggle_widget_display(themed_app: Page, assert_snapshot: ImageCompareFunction):
    """Test that st.toggle renders correctly."""
    toggle_elements = themed_app.get_by_test_id("stCheckbox")
    expect(toggle_elements).to_have_count(TOGGLE_ELEMENTS)

    assert_snapshot(toggle_elements.nth(0), name="st_toggle-true")
    assert_snapshot(toggle_elements.nth(1), name="st_toggle-false")
    assert_snapshot(toggle_elements.nth(2), name="st_toggle-long_label")
    assert_snapshot(toggle_elements.nth(3), name="st_toggle-callback")
    assert_snapshot(toggle_elements.nth(4), name="st_toggle-false_disabled")
    assert_snapshot(toggle_elements.nth(5), name="st_toggle-true_disabled")
    assert_snapshot(toggle_elements.nth(6), name="st_toggle-hidden_label")
    assert_snapshot(toggle_elements.nth(7), name="st_toggle-collapsed_label")


def test_toggle_initial_values(app: Page):
    """Test that st.toggle has the correct initial values."""
    markdown_elements = app.get_by_test_id("stMarkdown")
    expect(markdown_elements).to_have_count(9)

    expected = [
        "toggle 1 - value: True",
        "toggle 2 - value: False",
        "toggle 3 - value: False",
        "toggle 4 - value: False",
        "toggle 4 - clicked: False",
        "toggle 5 - value: False",
        "toggle 6 - value: True",
        "toggle 7 - value: False",
        "toggle 8 - value: False",
    ]

    for markdown_element, expected_text in zip(markdown_elements.all(), expected):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_toggle_values_on_click(app: Page):
    """Test that st.toggle updates values correctly when user clicks."""
    toggle_elements = app.get_by_test_id("stCheckbox")
    expect(toggle_elements).to_have_count(TOGGLE_ELEMENTS)

    for toggle_element in toggle_elements.all():
        # Not sure if this is needed, but somehow it is slightly
        # flaky with the last toggle without it.
        # It seems that it sometimes fails to click,
        # and in these cases the toggle was not scrolled into view.
        # So, maybe thats the reason why it fails to click it.
        # But this is just a guess.
        toggle_element.scroll_into_view_if_needed()
        toggle_element.locator("label").click(delay=50, force=True)
        wait_for_app_run(app)

    markdown_elements = app.get_by_test_id("stMarkdown")
    expected = [
        "toggle 1 - value: False",
        "toggle 2 - value: True",
        "toggle 3 - value: True",
        "toggle 4 - value: True",
        "toggle 4 - clicked: True",
        "toggle 5 - value: False",
        "toggle 6 - value: True",
        "toggle 7 - value: True",
        "toggle 8 - value: True",
    ]

    for markdown_element, expected_text in zip(markdown_elements.all(), expected):
        expect(markdown_element).to_have_text(expected_text, use_inner_text=True)


def test_grouped_toggles_height(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that grouped toggles have the correct height."""

    expander_details = get_expander(app, "Grouped toggles").get_by_test_id(
        "stExpanderDetails"
    )
    expect(expander_details.get_by_test_id("stCheckbox")).to_have_count(3)
    assert_snapshot(expander_details, name="st_toggle-grouped_styling")
    expect(expander_details.get_by_test_id("stCheckbox").nth(0)).to_have_css(
        "height", "24px"
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stCheckbox")


def test_custom_css_class_via_key(app: Page):
    """Test that the element can have a custom css class via the key argument."""
    expect(get_element_by_key(app, "toggle4")).to_be_visible()


================================================
File: /e2e_playwright/st_vega_lite_chart.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import numpy as np
import pandas as pd

import streamlit as st

np.random.seed(0)
data = np.random.randn(200, 3)
df = pd.DataFrame(data, columns=["a", "b", "c"])
spec = {
    "mark": "circle",
    "encoding": {
        "x": {"field": "a", "type": "quantitative"},
        "y": {"field": "b", "type": "quantitative"},
        "size": {"field": "c", "type": "quantitative"},
        "color": {"field": "c", "type": "quantitative"},
    },
}

spec_with_width = {
    "mark": "circle",
    "encoding": {
        "x": {"field": "a", "type": "quantitative"},
        "y": {"field": "b", "type": "quantitative"},
        "size": {"field": "c", "type": "quantitative"},
        "color": {"field": "c", "type": "quantitative"},
    },
    "width": "500",
}

interactive_spec = {
    "data": {
        "values": [
            {"a": "A", "b": 28},
            {"a": "B", "b": 55},
            {"a": "C", "b": 43},
            {"a": "D", "b": 91},
            {"a": "E", "b": 81},
            {"a": "F", "b": 53},
            {"a": "G", "b": 19},
            {"a": "H", "b": 87},
            {"a": "I", "b": 52},
        ]
    },
    "params": [
        {"name": "highlight", "select": {"type": "point", "on": "mouseover"}},
        {"name": "select", "select": "point"},
    ],
    "mark": {"type": "bar", "fill": "#4C78A8", "stroke": "black", "cursor": "pointer"},
    "encoding": {
        "x": {"field": "a", "type": "ordinal"},
        "y": {"field": "b", "type": "quantitative"},
        "fillOpacity": {"condition": {"param": "select", "value": 1}, "value": 0.3},
        "strokeWidth": {
            "condition": [
                {"param": "select", "empty": False, "value": 2},
                {"param": "highlight", "empty": False, "value": 1},
            ],
            "value": 0,
        },
    },
    "config": {"scale": {"bandPaddingInner": 0.2}},
}

st.vega_lite_chart(df, spec)
st.vega_lite_chart(df, spec)
st.vega_lite_chart(df, spec, use_container_width=False)
st.vega_lite_chart(df, spec_with_width, use_container_width=False)
st.vega_lite_chart(interactive_spec, None, use_container_width=False)

# Screenshot comparison

st.header("Different ways to get the exact same plot")

df = pd.DataFrame([["A", "B", "C", "D"], [28, 55, 43, 91]], index=["a", "b"]).T

st.write("Using a top-level `df` and a `spec` dict:")

st.vega_lite_chart(
    df,
    {
        "mark": "bar",
        "encoding": {
            "x": {"field": "a", "type": "ordinal"},
            "y": {"field": "b", "type": "quantitative"},
        },
    },
    use_container_width=True,
)

st.write("Using a top-level `df` and keywords as a spec:")

st.vega_lite_chart(
    df,
    mark="bar",
    x_field="a",
    x_type="ordinal",
    y_field="b",
    y_type="quantitative",
    use_container_width=True,
)

st.write("Putting the `df` inside the spec, as a `dataset`:")

st.vega_lite_chart(
    {
        "datasets": {"foo": df},
        "data": {"name": "foo"},
        "mark": "bar",
        "encoding": {
            "x": {"field": "a", "type": "ordinal"},
            "y": {"field": "b", "type": "quantitative"},
        },
    },
    use_container_width=True,
)

st.write("Putting the `df` inside the spec, as inline `data`:")

st.vega_lite_chart(
    {
        "data": df,
        "mark": "bar",
        "encoding": {
            "x": {"field": "a", "type": "ordinal"},
            "y": {"field": "b", "type": "quantitative"},
        },
    },
    use_container_width=True,
)

st.write("Putting the `df` inside the spec, as inline `data` (different notation):")

st.vega_lite_chart(
    {
        "data": {"values": df},
        "mark": "bar",
        "encoding": {
            "x": {"field": "a", "type": "ordinal"},
            "y": {"field": "b", "type": "quantitative"},
        },
    }
)

df = pd.DataFrame(data, columns=["a", "b", "c"])

st.write("Show streamlit theme:")
st.vega_lite_chart(df, spec, use_container_width=True, theme="streamlit")

st.write("Show default theme:")
st.vega_lite_chart(df, spec, use_container_width=True, theme=None)

st.write("Show custom colors:")
st.vega_lite_chart(
    df,
    {
        "mark": "bar",
        "encoding": {
            "x": {"field": "a", "type": "ordinal"},
            "y": {"field": "b", "type": "quantitative"},
        },
        "config": {"background": "purple", "axis": {"labelColor": "blue"}},
    },
    use_container_width=True,
)

spec = {
    "mark": "line",
    "encoding": {
        "x": {"field": "a", "type": "quantitative"},
        "y": {"field": "b", "type": "quantitative"},
    },
}

# empty chart
st.vega_lite_chart(spec, use_container_width=True)

data1 = {"VALUE": [420, 380, 390], "DATE": [50, 60, 70]}
data = pd.DataFrame(data1)

data2 = {
    "VALUE": [420, 380, 600, 390],
    "DATE": [50, 60, 70, 80],
}


if st.button(label="change"):
    data = pd.DataFrame(data2)

st.dataframe(data)
st.vega_lite_chart(
    data=data,
    spec={
        "autosize": {
            "type": "fit",
            "contains": "padding",
            "resize": True,
        },
        "title": "test",
        "layer": [
            {
                "layer": [
                    {
                        "mark": "line",
                    },
                ],
                "encoding": {
                    "x": {
                        "field": "DATE",
                        "title": "",
                        "type": "quantitative",
                    },
                    "y": {
                        "field": "VALUE",
                        "title": "",
                        "type": "quantitative",
                    },
                },
            },
        ],
    },
    use_container_width=True,
    theme="streamlit",
)


================================================
File: /e2e_playwright/st_vega_lite_chart_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import check_top_level_class, get_button

VEGA_LITE_CHART_COUNT = 15


def test_vega_lite_chart(app: Page):
    """Tests that it displays charts on the DOM"""
    vega_lite_charts = app.get_by_test_id("stVegaLiteChart")
    expect(vega_lite_charts).to_have_count(VEGA_LITE_CHART_COUNT)

    for idx in range(VEGA_LITE_CHART_COUNT):
        chart = vega_lite_charts.nth(idx)
        canvas = chart.locator("canvas").nth(0)
        expect(canvas).to_be_visible()
        expect(canvas).to_have_class("marks")


def test_vega_lite_chart_sets_chart_width(themed_app: Page):
    """Tests that it sets the correct chart width"""
    vega_lite_charts = themed_app.get_by_test_id("stVegaLiteChart")

    expect(vega_lite_charts.nth(0).locator("canvas").nth(0)).to_have_css(
        "width", "704px"
    )
    expect(vega_lite_charts.nth(1).locator("canvas").nth(0)).to_have_css(
        "width", "704px"
    )
    expect(vega_lite_charts.nth(2).locator("canvas").nth(0)).to_have_css(
        "width", "400px"
    )
    expect(vega_lite_charts.nth(3).locator("canvas").nth(0)).to_have_css(
        "width", "500px"
    )


def test_vega_lite_chart_displays_interactive_charts(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Tests that it displays interactive charts on the DOM"""
    vega_lite_charts = themed_app.get_by_test_id("stVegaLiteChart")
    # expect statement here so that snapshots are taken properly
    expect(vega_lite_charts).to_have_count(VEGA_LITE_CHART_COUNT)
    expect(vega_lite_charts.nth(4)).to_be_visible()
    assert_snapshot(
        vega_lite_charts.nth(4),
        name="st_vega_lite_chart-interactive",
    )


def test_vega_lite_chart_same_plot_different_ways(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Tests that it displays the same plot in different ways"""
    vega_lite_charts = themed_app.get_by_test_id("stVegaLiteChart")
    # expect statement here so that snapshots are taken properly
    expect(vega_lite_charts).to_have_count(VEGA_LITE_CHART_COUNT)

    for idx in range(5, 9):
        assert_snapshot(vega_lite_charts.nth(idx), name=f"st_vega_lite_chart-{idx}")


def test_vega_lite_chart_streamlit_theme(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Tests that st.vega_lite_chart supports the Streamlit theme"""
    vega_lite_charts = themed_app.get_by_test_id("stVegaLiteChart")
    # expect statement here so that snapshots are taken properly
    expect(vega_lite_charts).to_have_count(VEGA_LITE_CHART_COUNT)

    for idx in range(9, 11):
        assert_snapshot(
            vega_lite_charts.nth(idx), name=f"st_vega_lite_chart-theming_{idx}"
        )


def test_vega_lite_chart_default_theme(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Tests that st.vega_lite_chart supports the default theme"""
    vega_lite_charts = themed_app.get_by_test_id("stVegaLiteChart")
    # expect statement here so that snapshots are taken properly
    expect(vega_lite_charts).to_have_count(VEGA_LITE_CHART_COUNT)

    assert_snapshot(vega_lite_charts.nth(11), name="st_vega_lite_chart-default_theming")


def test_vega_lite_chart_user_supplied_colors(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Tests that st.vega_lite_chart respects user configuration"""
    vega_lite_charts = themed_app.get_by_test_id("stVegaLiteChart")
    # expect statement here so that snapshots are taken properly
    expect(vega_lite_charts).to_have_count(VEGA_LITE_CHART_COUNT)

    assert_snapshot(
        vega_lite_charts.nth(12),
        name="st_vega_lite_chart-user_supplied_colors",
    )


def test_empty_vega_lite_chart(app: Page, assert_snapshot: ImageCompareFunction):
    vega_lite_charts = app.get_by_test_id("stVegaLiteChart")
    # expect statement here so that snapshots are taken properly
    expect(vega_lite_charts).to_have_count(VEGA_LITE_CHART_COUNT)

    assert_snapshot(
        vega_lite_charts.nth(13),
        name="st_vega_lite_chart-empty",
    )


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    check_top_level_class(app, "stVegaLiteChart")


def test_vega_lite_chart_updates_with_slightly_different_data(
    app: Page, assert_snapshot: ImageCompareFunction
):
    """Tests that it displays interactive charts on the DOM"""
    vega_lite_charts = app.get_by_test_id("stVegaLiteChart")
    # expect statement here so that snapshots are taken properly
    expect(vega_lite_charts).to_have_count(VEGA_LITE_CHART_COUNT)
    expect(vega_lite_charts.nth(14)).to_be_visible()
    assert_snapshot(
        vega_lite_charts.nth(14),
        name="st_vega_lite_chart-before_update",
    )

    get_button(app, "change").click()
    wait_for_app_run(app)

    expect(vega_lite_charts).to_have_count(VEGA_LITE_CHART_COUNT)
    expect(vega_lite_charts.nth(14)).to_be_visible()
    assert_snapshot(
        vega_lite_charts.nth(14),
        name="st_vega_lite_chart-after_update",
    )


================================================
File: /e2e_playwright/st_video.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time
from pathlib import Path

import streamlit as st

# Construct test assets path relative to this script file to
# allow its execution with different working directories.
TEST_ASSETS_DIR = Path(__file__).parent / "test_assets"

WEBM_VIDEO_PATH = TEST_ASSETS_DIR / "sintel-short.webm"
MP4_VIDEO_PATH = TEST_ASSETS_DIR / "sintel-short.mp4"
VTT_EN_PATH = TEST_ASSETS_DIR / "sintel-en.vtt"
VTT_DE_PATH = TEST_ASSETS_DIR / "sintel-de.vtt"

mp4_video = "mp4 video"
mp4_video_with_subtitles = "mp4 video with subtitles"
webm_video_with_subtitles = "webm video with subtitles"
webm_video_with_end_time = "webm video with end time"
mp4_video_with_end_time = "mp4 video with end time"
webm_video_with_end_time_and_loop = "webm video with end time and loop"
mp4_video_with_end_time_and_loop = "mp4 video with end time and loop"
webm_video_with_autoplay = "webm video with autoplay"
webm_video_muted = "webm video muted"

video_to_show = st.radio(
    "Choose a video to show",
    [
        "None",
        mp4_video,
        mp4_video_with_subtitles,
        webm_video_with_subtitles,
        webm_video_with_end_time,
        mp4_video_with_end_time,
        webm_video_with_end_time_and_loop,
        mp4_video_with_end_time_and_loop,
        webm_video_with_autoplay,
        webm_video_muted,
    ],
    index=0,
)

if video_to_show == mp4_video:
    # Test local file with video
    st.video(str(MP4_VIDEO_PATH), start_time=17)
    st.video(MP4_VIDEO_PATH, start_time=17)

if video_to_show == mp4_video_with_subtitles:
    # Test subtitle with video
    st.video(
        str(MP4_VIDEO_PATH),
        start_time=31,
        subtitles={
            "English": VTT_EN_PATH,
            "Deutsch": VTT_DE_PATH,
        },
    )

if video_to_show == webm_video_with_subtitles:
    # Test subtitle with webm video
    st.video(
        str(WEBM_VIDEO_PATH),
        start_time=25,
        subtitles={
            "English": VTT_EN_PATH,
            "Deutsch": VTT_DE_PATH,
        },
    )

if video_to_show == webm_video_with_end_time:
    # Test end time webm video
    st.video(
        str(WEBM_VIDEO_PATH),
        start_time=31,
        end_time=33,
    )

if video_to_show == mp4_video_with_end_time:
    # Test end time mp4 video
    st.video(
        str(MP4_VIDEO_PATH),
        start_time=31,
        end_time=33,
    )

if video_to_show == webm_video_with_end_time_and_loop:
    # Test end time and loop webm video
    st.video(str(WEBM_VIDEO_PATH), start_time=35, end_time=39, loop=True)

if video_to_show == mp4_video_with_end_time_and_loop:
    # Test end time and loop mp4 video
    st.video(str(MP4_VIDEO_PATH), start_time=35, end_time=39, loop=True)

if video_to_show == webm_video_with_autoplay:
    # Test autoplay with video
    autoplay = st.checkbox("Autoplay", value=False)

    if st.button("Create some elements to unmount component"):
        for _ in range(3):
            # The sleep here is needed, because it won't unmount the
            # component if this is too fast.
            time.sleep(1)
            st.write("Another element")

    st.video(
        str(WEBM_VIDEO_PATH),
        autoplay=autoplay,
    )

if video_to_show == webm_video_muted:
    # Test muted with video
    st.video(
        str(WEBM_VIDEO_PATH),
        autoplay=True,
        muted=True,
    )


================================================
File: /e2e_playwright/st_video_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
import re

import pytest
from playwright.sync_api import Locator, Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_until
from e2e_playwright.shared.app_utils import (
    check_top_level_class,
    click_button,
    click_checkbox,
    click_radio_button,
)

VIDEO_ELEMENTS_COUNT = 12


def _select_video_to_show(app: Page, label: str) -> Locator:
    click_radio_button(app, re.compile(f"^{label}$"))
    video_element = app.get_by_test_id("stVideo").first
    # Prevent flakiness: we move the mouse before scrolling to prevent the cursor
    # hovering over a video element and, thereby, changing how the video interface is
    # rendered (e.g. without the controls in the bottom which are hidden)
    app.mouse.move(0, 0)
    video_element.scroll_into_view_if_needed()
    expect(video_element).to_be_visible()
    return video_element


def _wait_until_video_has_data(app: Page, video_element: Locator):
    # To prevent flakiness, we wait for the video to load and start playing
    # The readyState is defined in https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/readyState
    # 3 means there is some data to play now and few frames for the future. On webkit
    # this seems to be flaky, so we check also the duration of the video.
    wait_until(
        app,
        lambda: video_element.evaluate("el => el.readyState >= 3 || el.duration > 0")
        is True,
        timeout=15000,
    )


# Chromium miss codecs required to play that mp3 videos
# https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/
@pytest.mark.skip_browser("chromium")
def test_video_rendering(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that `st.video` renders correctly via screenshots matching."""

    video_element = _select_video_to_show(app, "mp4 video")
    _wait_until_video_has_data(app, video_element)
    assert_snapshot(
        video_element,
        name="video_element_first",
        image_threshold=0.1,
    )

    video_element = _select_video_to_show(app, "mp4 video with subtitles")
    _wait_until_video_has_data(app, video_element)

    assert_snapshot(
        video_element,
        name="video_element_with_subtitles",
        image_threshold=0.1,
    )


@pytest.mark.skip_browser("webkit")
def test_video_rendering_webm(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that `st.video` renders correctly webm video via screenshots matching."""

    video_element = _select_video_to_show(app, "webm video with subtitles")
    _wait_until_video_has_data(app, video_element)

    assert_snapshot(
        video_element,
        name="video_element_webm_with_subtitles",
        image_threshold=0.1,
    )


def test_displays_a_video_player(app: Page):
    video_element = _select_video_to_show(app, "mp4 video")
    # src here is a generated by streamlit url since we pass a file content
    expect(video_element).to_have_attribute("src", re.compile(r".*media.*.mp4"))


@pytest.mark.parametrize(
    "video_option_label",
    [
        pytest.param(
            "webm video with end time", marks=pytest.mark.skip_browser("webkit")
        ),
        pytest.param(
            "mp4 video with end time", marks=pytest.mark.skip_browser("chromium")
        ),
    ],
)
def test_video_end_time(app: Page, video_option_label: str):
    """Test that `st.video` with end_time works correctly."""

    video_element = _select_video_to_show(app, video_option_label)
    _wait_until_video_has_data(app, video_element)
    video_element.evaluate("el => el.play()")
    # Wait until video will reach end_time
    app.wait_for_timeout(3000)
    expect(video_element).to_have_js_property("paused", True)
    wait_until(app, lambda: int(video_element.evaluate("el => el.currentTime")) == 33)


@pytest.mark.parametrize(
    "video_option_label",
    [
        pytest.param(
            "webm video with end time and loop",
            marks=pytest.mark.skip_browser("webkit"),
        ),
        pytest.param(
            "mp4 video with end time and loop",
            marks=pytest.mark.skip_browser("chromium"),
        ),
    ],
)
def test_video_end_time_loop(app: Page, video_option_label: str):
    """Test that `st.video` with end_time and loop works correctly."""
    video_element = _select_video_to_show(app, video_option_label)
    _wait_until_video_has_data(app, video_element)

    video_element.evaluate("el => el.play()")
    # According to the element definition looks like this:
    # start_time=35, end_time=39, loop=True
    # We wait for 6 seconds, which mean the current time should be approximately 37:
    # 4 seconds until end_time and 2 seconds starting from start time
    app.wait_for_timeout(6000)
    expect(video_element).to_have_js_property("paused", False)
    wait_until(app, lambda: 36 < video_element.evaluate("el => el.currentTime") < 38)


@pytest.mark.flaky(reruns=3)  # Some flakiness with the js properties in webkit
def test_video_autoplay(app: Page):
    """Test that `st.video` autoplay property works correctly."""
    video_element = _select_video_to_show(app, "webm video with autoplay")
    expect(video_element).to_have_js_property("paused", True)
    expect(video_element).to_have_js_property("autoplay", False)

    click_checkbox(app, "Autoplay")

    _wait_until_video_has_data(app, video_element)
    expect(video_element).to_have_js_property("autoplay", True)
    expect(video_element).to_have_js_property("paused", False)


def test_video_muted_autoplay(app: Page):
    """Test that `st.video` muted and autoplay properties work correctly."""
    video_element = _select_video_to_show(app, "webm video muted")
    _wait_until_video_has_data(app, video_element)

    expect(video_element).to_have_js_property("muted", True)
    expect(video_element).to_have_js_property("autoplay", True)
    expect(video_element).to_have_js_property("paused", False)


@pytest.mark.flaky(reruns=3)  # Some flakiness with the js properties in webkit
def test_video_remount_no_autoplay(app: Page):
    """Test that `st.video` remounts correctly without autoplay."""
    video_element = _select_video_to_show(app, "webm video with autoplay")
    _wait_until_video_has_data(app, video_element)

    expect(video_element).to_have_js_property("paused", True)
    expect(video_element).to_have_js_property("autoplay", False)

    click_checkbox(app, "Autoplay")

    expect(video_element).to_have_js_property("autoplay", True)
    expect(video_element).to_have_js_property("paused", False)

    click_checkbox(app, "Autoplay")
    click_button(app, "Create some elements to unmount component")

    expect(video_element).to_have_js_property("autoplay", False)
    expect(video_element).to_have_js_property("paused", True)


def test_check_top_level_class(app: Page):
    """Check that the top level class is correctly set."""
    _select_video_to_show(app, "webm video with autoplay")
    check_top_level_class(app, "stVideo")


================================================
File: /e2e_playwright/st_write_charts.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


import altair as alt
import graphviz
import numpy as np
import pandas as pd
import plotly.express as px
import pydeck as pdk

import streamlit as st

np.random.seed(0)


st.subheader("st.write(altair)")

df = pd.DataFrame(np.random.randn(50, 3), columns=["a", "b", "c"])
chart = alt.Chart(df).mark_circle().encode(x="a", y="b", size="c", color="c")
st.write(chart)

st.subheader("st.write(plotly)")

fig = px.scatter(df, x="a", y="b")
st.write(fig)

st.subheader("st.write(graphviz)")

graph = graphviz.Digraph()
graph.edge("run", "intr")
graph.edge("intr", "runbl")
graph.edge("runbl", "run")

st.write(graph)

# Simple pydeck chart:

st.subheader("st.write(pydeck)")

st.write(
    pdk.Deck(
        map_style=None,
        initial_view_state=pdk.ViewState(
            latitude=37.76,
            longitude=-122.4,
            zoom=11,
            pitch=50,
        ),
    )
)


================================================
File: /e2e_playwright/st_write_charts_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect


def test_display_altair(app: Page):
    """Test that st.write displays altair charts."""
    altair_elements = app.get_by_test_id("stVegaLiteChart")
    expect(altair_elements).to_have_count(1)


def test_display_plotly(app: Page):
    """Test that st.write displays plotly charts."""
    plotly_elements = app.get_by_test_id("stPlotlyChart")
    expect(plotly_elements).to_have_count(1)


def test_display_graphviz(app: Page):
    """Test that st.write displays graphviz charts."""
    plotly_elements = app.get_by_test_id("stGraphVizChart")
    expect(plotly_elements).to_have_count(1)


def test_display_pydeck_chart(app: Page):
    """Test that st.write displays pydeck charts."""
    pydeck_elements = app.get_by_test_id("stDeckGlJsonChart")
    # The pydeck chart takes a while to load so check that
    # it gets attached with an increased timeout.
    expect(pydeck_elements).to_have_count(1, timeout=15000)


================================================
File: /e2e_playwright/st_write_images.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import matplotlib.pyplot as plt
import numpy as np
from PIL import Image

import streamlit as st

np.random.seed(0)


st.subheader("st.write(Image)")

st.write(Image.new("L", (10, 10), "black"))


st.subheader("st.write(matplotlib)")

fig, ax = plt.subplots()
ax.hist(np.random.normal(1, 1, size=100), bins=20)

st.write(fig)


================================================
File: /e2e_playwright/st_write_images_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect


def test_display_images(app: Page):
    """Test that st.write displays images (matplotlib is served as image)."""
    image_elements = app.get_by_test_id("stImage")
    expect(image_elements).to_have_count(2)


================================================
File: /e2e_playwright/st_write_markdown.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import io
from datetime import datetime

import numpy as np

import streamlit as st

st.subheader("st.write(markdown)")

st.write("Hello", "World")

st.write("This **markdown** is awesome! :sunglasses:")

st.write("This <b>HTML tag</b> is escaped!")

st.write("This <b>HTML tag</b> is not escaped!", unsafe_allow_html=True)


st.write(100)

st.write(None)

st.write(datetime(2021, 1, 1))

st.write(np.float64(1.0))


class SomeObject1:
    def __str__(self):
        return "1 * 2 - 3 = 4 `ok` !"


st.write(SomeObject1())  # escaped single line string


class SomeObject2:
    def __str__(self):
        return "1 * 2\n - 3\n ``` = \n````\n4 `ok` !"


st.write(SomeObject2())  # escaped multiline string

string_io = io.StringIO()
string_io.write("This is a string IO object!")

st.write(string_io)


def stream_text():
    yield "This is "
    yield "streamed text"


st.subheader("st.write(generator)")

st.write(stream_text)

st.write(stream_text())


================================================
File: /e2e_playwright/st_write_markdown_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_displays_markdown(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that markdown is displayed correctly."""

    markdown_elements = app.get_by_test_id("stMarkdown")
    expect(markdown_elements).to_have_count(13)

    expect(markdown_elements.nth(0)).to_contain_text("Hello World")
    expect(markdown_elements.nth(1)).to_contain_text("This markdown is awesome! 😎")
    expect(markdown_elements.nth(2)).to_contain_text("This <b>HTML tag</b> is escaped!")
    expect(markdown_elements.nth(3)).to_contain_text("This HTML tag is not escaped!")
    expect(markdown_elements.nth(4)).to_contain_text("100")
    expect(markdown_elements.nth(5)).to_contain_text("None")
    expect(markdown_elements.nth(6)).to_contain_text("2021-01-01 00:00:00")
    expect(markdown_elements.nth(7)).to_contain_text("1.0")

    expect(markdown_elements.nth(8)).to_contain_text("1 * 2 - 3 = 4 `ok` !")
    expect(markdown_elements.nth(9)).to_contain_text(
        "1 * 2\n - 3\n ``` = \n````\n4 `ok` !"
    )
    assert_snapshot(markdown_elements.nth(4), name="write_int")
    assert_snapshot(markdown_elements.nth(5), name="write_none")
    assert_snapshot(markdown_elements.nth(6), name="write_datetime")
    assert_snapshot(markdown_elements.nth(7), name="write_np_float")
    assert_snapshot(markdown_elements.nth(8), name="write_single_line_monospace_block")
    assert_snapshot(markdown_elements.nth(9), name="write_multi_line_monospace_block")

    expect(markdown_elements.nth(10)).to_contain_text("This is a string IO object!")
    expect(markdown_elements.nth(11)).to_contain_text("This is streamed text")
    expect(markdown_elements.nth(12)).to_contain_text("This is streamed text")


================================================
File: /e2e_playwright/st_write_objects.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from dataclasses import dataclass
from typing import NamedTuple

import numpy as np
import pandas as pd

import streamlit as st

np.random.seed(0)


st.subheader("st.write(dataframe-like)")

st.write(pd.DataFrame(np.random.randn(25, 3), columns=["a", "b", "c"]))

st.write(pd.Series([1, 2, 3]))

st.write(
    pd.DataFrame(np.random.randn(25, 3), columns=["a", "b", "c"]).style.format("{:.2%}")
)

st.write(np.arange(25).reshape(5, 5))

st.subheader("st.write(json-like)")

st.write(["foo", "bar"])

st.write({"foo": "bar"})

st.write(st.session_state)
st.write(st.experimental_user)
st.write(st.query_params)


class Point(NamedTuple):
    x: int
    y: int


st.write(Point(1, 2))

st.subheader("st.write(help)")

st.write(st.dataframe)


@dataclass
class ExampleClass:
    name: str
    age: int


st.write(ExampleClass)

st.subheader("st.write(reprhtmlable)")


class ClassWithReprHtml:
    def _repr_html_(self):
        return "This is an <b>HTML tag</b>!"


# Shows as st.help because this is just an object.
st.write(ClassWithReprHtml())

# Shows as HTML.
st.write(ClassWithReprHtml(), unsafe_allow_html=True)

st.subheader("st.write(exception)")

st.write(Exception("This is an exception!"))


================================================
File: /e2e_playwright/st_write_objects_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect


def test_display_dataframe(app: Page):
    """Test that st.write displays dataframe compatible objects via st.dataframe."""

    dataframe_element = app.get_by_test_id("stDataFrame")
    expect(dataframe_element).to_have_count(4)


def test_display_json(app: Page):
    """Test that st.write displays dicts and arrays as json data."""
    json_elements = app.get_by_test_id("stJson")
    expect(json_elements).to_have_count(6)


def test_display_help(app: Page):
    help_elements = app.get_by_test_id("stHelp")
    """Test that st.write displays objects via st.help."""
    expect(help_elements).to_have_count(3)


def test_displays_reprhtml(app: Page):
    """Test that repr_html is displayed correctly."""

    html_elements = app.get_by_test_id("stHtml")
    expect(html_elements).to_have_count(1)
    expect(html_elements.first).to_contain_text("This is an HTML tag!")


def test_display_exception(app: Page):
    """Test that st.write displays exceptions via st.exception."""
    exception_elements = app.get_by_test_id("stException")
    expect(exception_elements).to_have_count(1)


================================================
File: /e2e_playwright/st_write_stream.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import asyncio
import time

import numpy as np
import pandas as pd

import streamlit as st

np.random.seed(0)


_LOREM_IPSUM = """
Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut
labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco
laboris nisi ut aliquip ex ea commodo consequat.
"""


button_group = st.container()
stream_output = st.container(key="stream-output")

# Replay the last output:
if "written_content" in st.session_state:
    stream_output.write(st.session_state["written_content"])


def stream_example():
    for word in _LOREM_IPSUM.split():
        yield word + " "
        time.sleep(0.02)

    yield pd.DataFrame(
        np.random.randn(5, 10),
        columns=["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"],
    )

    for word in "This is the end of the stream.".split():
        yield word + " "
        time.sleep(0.02)


async def async_generator():
    for word in _LOREM_IPSUM.split():
        yield word + " "
        await asyncio.sleep(0.02)
    yield pd.DataFrame(
        np.random.randn(5, 10),
        columns=["a", "b", "c", "d", "e", "f", "g", "h", "i", "j"],
    )

    for word in "This is the end of the stream.".split():
        yield word + " "
        await asyncio.sleep(0.02)


if button_group.button("Stream data"):
    st.session_state["written_content"] = stream_output.write_stream(stream_example)

if button_group.button("Stream async data"):
    st.session_state["written_content"] = stream_output.write_stream(async_generator)


================================================
File: /e2e_playwright/st_write_stream_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, rerun_app
from e2e_playwright.shared.app_utils import (
    click_button,
    expect_markdown,
    get_element_by_key,
)


def test_stream_generator(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that `st.write_stream` can correctly streams content.
    This also tests that the return value can be rendered via `st.write`.
    """

    click_button(app, "Stream data")
    expect_markdown(app, "This is the end of the stream.")
    # There should be two markdown elements on the page:
    expect(app.get_by_test_id("stMarkdown")).to_have_count(2)

    # Check that the dataframe is visible:
    expect(app.get_by_test_id("stDataFrame")).to_be_visible()

    stream_output = get_element_by_key(app, "stream-output")
    assert_snapshot(stream_output, name="st_write_stream-generator_output")

    # Test that the rerun will output the same elements via st.write:
    rerun_app(app)

    expect_markdown(app, "This is the end of the stream.")
    # There should be two markdown elements on the page:
    expect(app.get_by_test_id("stMarkdown")).to_have_count(2)

    # Check that the dataframe is visible:
    expect(app.get_by_test_id("stDataFrame")).to_be_visible()

    # Test with the same snapshot name to make sure the output is the same:
    stream_output = get_element_by_key(app, "stream-output")
    assert_snapshot(stream_output, name="st_write_stream-generator_output")


def test_async_generator(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that `st.write_stream` correctly streams content from an async generator."""

    click_button(app, "Stream async data")
    expect_markdown(app, "This is the end of the stream.")
    # There should be two markdown elements on the page:
    expect(app.get_by_test_id("stMarkdown")).to_have_count(2)

    # Check that the dataframe is visible:
    expect(app.get_by_test_id("stDataFrame")).to_be_visible()

    stream_output = get_element_by_key(app, "stream-output")
    assert_snapshot(stream_output, name="st_write_stream-async_generator_output")

    # Test that the rerun will output the same elements via st.write:
    rerun_app(app)

    expect_markdown(app, "This is the end of the stream.")
    # There should be two markdown elements on the page:
    expect(app.get_by_test_id("stMarkdown")).to_have_count(2)

    # Check that the dataframe is visible:
    expect(app.get_by_test_id("stDataFrame")).to_be_visible()

    # Test with the same snapshot name to make sure the output is the same:
    stream_output = get_element_by_key(app, "stream-output")
    assert_snapshot(stream_output, name="st_write_stream-async_generator_output")


================================================
File: /e2e_playwright/websocket_disconnect.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from datetime import date, time

import streamlit as st

options = ("female", "male")

w1 = st.checkbox("I am human", True)

w2 = st.slider("Age", 0, 100, 25, 1)
st.write("Value 1:", w2)

w3 = st.text_area("Comments", "Streamlit is awesomeness!")

w4 = st.button("Click me")

w5 = st.radio("Gender", options, 1)

w6 = st.text_input("Text input widget", "i iz input")

w7 = st.selectbox("Options", options, 1)

w8 = st.time_input("Set an alarm for", time(8, 45))

w9 = st.date_input("A date to celebrate", date(2019, 7, 6))


================================================
File: /e2e_playwright/websocket_disconnect_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction


def test_disconnected_states(app: Page, assert_snapshot: ImageCompareFunction):
    # Abort all requests to simulate runtime shutdown
    app.route("**", lambda route, request: route.abort())

    expect(app.get_by_test_id("stButton").locator("button")).not_to_have_attribute(
        "disabled", ""
    )
    expect(app.get_by_test_id("stMarkdown").first).to_contain_text("Value 1: 25")

    expect(app.get_by_test_id("stConnectionStatus")).not_to_be_visible()

    # disconnect the websocket connection
    app.evaluate("window.streamlitDebug.disconnectWebsocket()")

    expect(app.get_by_test_id("stConnectionStatus")).to_contain_text("Connecting")

    expect(app.get_by_test_id("stButton").locator("button")).to_have_attribute(
        "disabled", ""
    )
    expect(app.get_by_test_id("stCheckbox").locator("input")).to_have_attribute(
        "disabled", ""
    )
    expect(app.get_by_test_id("stDateInput").locator("input")).to_have_attribute(
        "disabled", ""
    )
    expect(app.get_by_test_id("stRadio").locator("input").first).to_have_attribute(
        "disabled", ""
    )
    expect(app.get_by_test_id("stSelectbox").locator("input")).to_have_attribute(
        "disabled", ""
    )
    expect(app.get_by_test_id("stTextArea").locator("textarea")).to_have_attribute(
        "disabled", ""
    )
    expect(app.get_by_test_id("stTextInput").locator("input")).to_have_attribute(
        "disabled", ""
    )
    expect(app.get_by_test_id("stTimeInput").locator("input")).to_have_attribute(
        "disabled", ""
    )

    app.get_by_test_id("stSlider").nth(0).hover()
    # click in middle
    app.mouse.down()

    expect(app.get_by_test_id("stMarkdown").first).to_contain_text("Value 1: 25")

    # After some time the disconnected dialog will appear.
    # It would be nicer to have this in a separate function, but we can't do that easily
    # because the runtime is shutdown for all test functions. We would need to start the
    # runtime again somehow or move this to a separate file.
    dialog = app.get_by_role("dialog")
    # the dialog might need a moment to appear after shutting down the runtime
    expect(dialog).to_be_visible(timeout=20000)
    # make sure that the close-x button is not focused
    dialog.blur(timeout=0)
    assert_snapshot(dialog, name="websocket_connection-disconnected_dialog")


================================================
File: /e2e_playwright/websocket_reconnects.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time

import streamlit as st

# st.session_state can only be accessed while running with streamlit
if "counter" not in st.session_state:
    st.session_state.counter = 0
    st.session_state.slow_operations_attempted = 0

if st.button("click me!"):
    st.session_state.counter += 1

if st.checkbox("do something slow"):
    st.session_state.slow_operations_attempted += 1
    time.sleep(5)

st.write(f"count: {st.session_state.counter}")
st.write(f"slow operations attempted: {st.session_state.slow_operations_attempted}")

if f := st.file_uploader("Upload a file"):
    st.text(f.read())

if img := st.camera_input("Take a picture"):
    st.image(img)


================================================
File: /e2e_playwright/websocket_reconnects_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from typing import Final

import pytest
from playwright.sync_api import FilePayload, Page, expect

from e2e_playwright.shared.app_utils import (
    click_button,
    expect_connection_status,
    expect_markdown,
    get_checkbox,
    wait_for_app_run,
)

INCREMENTS_PER_DISCONNECT: Final[int] = 3
NUM_DISCONNECTS: Final[int] = 15

DISCONNECT_WEBSOCKET_ACTION: Final = "window.streamlitDebug.disconnectWebsocket();"


def test_dont_observe_invalid_status(
    app: Page,
):
    """Test that unknown status is not observed and raises an error."""
    with pytest.raises(AssertionError) as e:
        expect_connection_status(app, "Connecting2", DISCONNECT_WEBSOCKET_ACTION)
    assert "timeout: did not observe status 'Connecting2'" in e.value.args


def test_retain_session_state_when_websocket_connection_drops_and_reconnects(
    app: Page,
):
    expected_count = 0
    for _ in range(NUM_DISCONNECTS):
        expected_count += INCREMENTS_PER_DISCONNECT

        # click disconnect button
        for _ in range(INCREMENTS_PER_DISCONNECT):
            click_button(app, "click me!")

        # disconnect and wait for status to change
        expect_connection_status(app, "CONNECTING", DISCONNECT_WEBSOCKET_ACTION)

        wait_for_app_run(app)
        expect_markdown(app, f"count: {expected_count}")


def test_reruns_script_when_interrupted_by_websocket_disconnect(
    app: Page,
):
    # Click on the checkbox, but don't wait for the app to finish running.
    get_checkbox(app, "do something slow").locator("label").click()

    expect_connection_status(app, "CONNECTING", DISCONNECT_WEBSOCKET_ACTION)

    wait_for_app_run(app)
    expect_markdown(app, "slow operations attempted: 2")


def test_retain_uploaded_files_when_websocket_connection_drops_and_reconnects(
    app: Page,
):
    file_name = "file1.txt"
    file_content = b"blob"

    app.get_by_test_id("stFileUploaderDropzoneInput").set_input_files(
        [
            FilePayload(name=file_name, buffer=file_content, mimeType="text/plain"),
        ],
    )

    expect(app.get_by_test_id("stFileUploaderFileName")).to_have_text(file_name)
    expect(app.get_by_test_id("stText").first).to_have_text(str(file_content))
    wait_for_app_run(app)

    # Disconnect
    expect_connection_status(app, "CONNECTING", DISCONNECT_WEBSOCKET_ACTION)

    # Wait until re-connected
    expect(app.get_by_test_id("stStatusWidget")).not_to_be_attached()

    # Confirm that our uploaded file is still there.
    expect(app.get_by_test_id("stText").first).to_have_text(str(file_content))


# skip webkit because the camera permission cannot be set programmatically
@pytest.mark.skip_browser("webkit")
def test_retain_captured_pictures_when_websocket_connection_drops_and_reconnects(
    app: Page, app_port: int
):
    # wait for the media call that is made when the image is returned
    with app.expect_event(
        "response",
        predicate=lambda response: response.url.startswith(
            f"http://localhost:{app_port}/media/"
        ),
    ):
        expect(app.get_by_test_id("stToolbar")).to_be_attached()
        camera_input_button = app.get_by_test_id("stCameraInputButton").nth(0)
        expect(camera_input_button).to_be_visible()
        expect(camera_input_button).to_contain_text("Take Photo")
        camera_input_button.click()

    app.wait_for_function("document.querySelectorAll('img').length == 2")
    expect(app.get_by_test_id("stImage")).to_have_count(1)

    # Wait for the image to be displayed
    expect(app.get_by_test_id("stImage")).to_be_visible()

    # Disconnect
    expect_connection_status(app, "CONNECTING", DISCONNECT_WEBSOCKET_ACTION)

    # Wait until re-connected
    expect(app.get_by_test_id("stStatusWidget")).not_to_be_attached()

    # Confirm that our picture is still there.
    expect(app.get_by_test_id("stImage")).to_have_count(1)


================================================
File: /e2e_playwright/widget_state.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import time

import streamlit as st

st.header("Widget State - Heavy Usage Test")
# Test for https://github.com/streamlit/streamlit/issues/4836

number = st.number_input("test", value=0, step=1)
st.write(number)

if number:
    time.sleep(1)

st.header("Widget State - Redisplayed Widget Test")
# Test for https://github.com/streamlit/streamlit/issues/3512

if st.checkbox("Display widgets"):
    if st.checkbox("Show hello"):
        st.write("hello")

    if st.checkbox("Show goodbye", key="c3"):
        st.write("goodbye")

st.header("Test for input change & button click in one motion")
# Test for https://github.com/streamlit/streamlit/issues/10007


def btn_callback():
    st.write("Input: " + st.session_state["key1"])


st.text_area("Type something into the text area", key="key1")
st.button("Submit text_area", on_click=btn_callback)


================================================
File: /e2e_playwright/widget_state_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.shared.app_utils import (
    click_button,
    click_checkbox,
    expect_markdown,
)


def test_clicking_a_lot_still_keeps_state(app: Page):
    """Test the the widget state is correctly handled on very fast clicks.
    Related to: https://github.com/streamlit/streamlit/issues/4836
    """
    number_input_down_button = app.get_by_test_id("stNumberInput").get_by_test_id(
        "stNumberInputStepUp"
    )
    for _ in range(40):
        number_input_down_button.click()

    expect_markdown(app, "40")


def test_doesnt_save_widget_state_on_redisplay(app: Page):
    """Test that widget state is not saved when a widget is redisplayed
    after a rerun.

    Related to: https://github.com/streamlit/streamlit/issues/3512
    """
    click_checkbox(app, "Display widgets")
    click_checkbox(app, "Show hello")
    expect_markdown(app, "hello")

    # Hide widgets:
    click_checkbox(app, "Display widgets")

    # Show widgets again:
    click_checkbox(app, "Display widgets")

    # Should not show hello again -> the widget state was not saved
    markdown_el = app.get_by_test_id("stMarkdown").filter(has_text="hello")
    expect(markdown_el).not_to_be_attached()


def test_doesnt_save_widget_state_on_redisplay_with_keyed_widget(app: Page):
    """Test that widget state is not saved when a keyed widget is redisplayed
    after a rerun.

    Related to: https://github.com/streamlit/streamlit/issues/3512
    """
    click_checkbox(app, "Display widgets")
    click_checkbox(app, "Show goodbye")
    expect_markdown(app, "goodbye")

    # Hide widgets:
    click_checkbox(app, "Display widgets")

    # Show widgets again:
    click_checkbox(app, "Display widgets")

    # Should not show goodbye again -> the widget state was not saved
    markdown_el = app.get_by_test_id("stMarkdown").filter(has_text="goodbye")
    expect(markdown_el).not_to_be_attached()


def test_click_button_after_input_change_without_losing_focus_first(app: Page):
    """Test that the input value is correctly updated when clicking a button
    right after changing the input value without losing focus first.

    Related to: https://github.com/streamlit/streamlit/issues/10007"""

    text_area = app.get_by_test_id("stTextArea")
    text_area_field = text_area.locator("textarea").first
    new_text = "new text_area value"
    text_area_field.fill(new_text)

    click_button(app, "Submit text_area")

    expect_markdown(app, f"Input: {new_text}")


================================================
File: /e2e_playwright/.gitignore
================================================
performance-results/**


================================================
File: /e2e_playwright/custom_components/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /e2e_playwright/custom_components/popular_components.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Test the components logic and that custom components work.

This test app includes some component actions as well as the top N most popular custom components based on our usage metrics.
The function for the component is imported when the respective option is selected in the selection-widget.
Also, some example action is executed on the component.
If the component cannot be imported or the component itself has some issue, e.g. some transitive import does not work,
an exception is shown.
This is some guard for us to detect potential issues in case of refactorings etc.

Following actions/components are tested:
- components.html (this function and its import is popularily documented in some places)
- extra-streamlit-components (CookieManager)
- streamlit-ace
- streamlit-antd-components
- streamlit-aggrid
- streamlit-autorefresh
- streamlit-chat
- streamlit-echarts
- streamlit-folium
- streamlit-option-menu
- streamlit-url-fragment
"""

from __future__ import annotations

from typing import Callable

import streamlit as st


def use_components_html():
    # note that we import streamlit before and so this `components.html` working
    # might be coincidental; this is the reason why we have dedicated tests for this kind of imports in the `st_components_v1_*` files
    import streamlit.components.v1 as components

    components.html("<div>Hello World!</div>")


def use_components_iframe():
    # note that we import streamlit before and so this `components.html` working
    # might be coincidental; this is the reason why we have dedicated tests for this kind of imports in the `st_components_v1_*` files
    import streamlit.components.v1 as components

    st.write(str(components.iframe))


def use_components_declare_component():
    import streamlit.components.v1 as components

    st.write(str(components.declare_component))


# Different custom components:
def use_streamlit_ace():
    from streamlit_ace import st_ace

    ## Spawn a new Ace editor
    content = st_ace()
    st.write(content)


def use_aggrid():
    import numpy as np
    import pandas as pd
    from st_aggrid import AgGrid

    np.random.seed(0)
    df = pd.DataFrame(
        np.random.choice(100, size=(100, 4)), columns=["A", "B", "C", "D"]
    )
    AgGrid(df, height=200)


def use_antd():
    import streamlit_antd_components as sac

    btn = sac.buttons(
        items=["button1", "button2", "button3"],
        index=0,
        format_func="title",
        align="center",
        direction="horizontal",
        radius="lg",
        return_index=False,
    )
    st.write(f"The selected button label is: {btn}")


def use_autorefresh():
    from streamlit_autorefresh import st_autorefresh

    ## Run the autorefresh about every 2000 milliseconds (2 seconds) and stop
    ## after it's been refreshed 100 times.
    count = st_autorefresh(interval=2000, limit=100, key="fizzbuzzcounter")
    ## The function returns a counter for number of refreshes. This allows the
    ## ability to make special requests at different intervals based on the count
    if count == 0:
        st.write("Count is zero")
    elif count % 3 == 0 and count % 5 == 0:
        st.write("FizzBuzz")
    elif count % 3 == 0:
        st.write("Fizz")
    elif count % 5 == 0:
        st.write("Buzz")
    else:
        st.write(f"Count: {count}")


def use_chat():
    from streamlit_chat import message

    message("My message")
    message("Hello bot!", is_user=True)  # align's the message to the right


def use_echarts():
    from streamlit_echarts import st_echarts

    options = {
        "xAxis": {
            "type": "category",
            "data": ["Mon", "Tue", "Wed", "Thu", "Fri", "Sat", "Sun"],
        },
        "yAxis": {"type": "value"},
        "series": [{"data": [820, 932, 901, 934, 1290, 1330, 1320], "type": "line"}],
    }
    st_echarts(options=options)


def use_extra_streamlit_components():
    from extra_streamlit_components import CookieManager

    CookieManager()


def use_folium():
    import folium
    from streamlit_folium import st_folium

    ## center on Liberty Bell, add marker
    m = folium.Map(location=[39.949610, -75.150282], zoom_start=16)
    folium.Marker(
        [39.949610, -75.150282], popup="Liberty Bell", tooltip="Liberty Bell"
    ).add_to(m)
    ## call to render Folium map in Streamlit
    st_data = st_folium(m, width=725)
    st.write(st_data)


def use_option_menu():
    from streamlit_option_menu import option_menu

    key = "my_option_menu"

    # TODO: uncomment the on_change callback as soon as streamlit-option-menu is updated and uses the new on_change callback
    # def on_change():
    #     selection = st.session_state[key]
    #     st.write(f"Selection changed to {selection}")

    with st.sidebar:
        selected = option_menu(
            "Main Menu",
            ["Home", "Settings"],
            icons=["house", "gear"],
            menu_icon="cast",
            default_index=1,
            key=key,
            # on_change=on_change,
        )
        st.write(selected)


def use_url_fragment():
    from streamlit_url_fragment import get_fragment

    current_value = get_fragment()
    st.write(f"Current value: {current_value!r}")


# ---

options: dict[str, Callable] = {
    "componentsHtml": use_components_html,
    "componentsIframe": use_components_iframe,
    "componentsDeclareComponent": use_components_declare_component,
    "ace": use_streamlit_ace,
    "aggrid": use_aggrid,
    "antd": use_antd,
    "autorefresh": use_autorefresh,
    "chat": use_chat,
    "echarts": use_echarts,
    "extraStreamlitComponents": use_extra_streamlit_components,
    "folium": use_folium,
    "optionMenu": use_option_menu,
    "urlFragment": use_url_fragment,
}
component_selection = st.selectbox("ComponentSelections", options=options.keys())
if component_selection:
    options[component_selection]()


================================================
File: /e2e_playwright/custom_components/popular_components_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import re

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import wait_for_app_run


def _select_component(app: Page, component: str):
    selectbox_input = app.get_by_test_id("stSelectbox").locator("input")

    # Type an option (defined in the test app):
    selectbox_input.type(component)
    selectbox_input.press("Enter")
    wait_for_app_run(app)


def _expect_no_exception(app: Page):
    """If there is an issue with importing / using the custom component, Streamlit throws an exception. So, expect that no exception was thrown."""
    expect(app.get_by_test_id("stException")).not_to_be_visible()


def _expect_iframe_attached(app: Page):
    """Expect the CustomComponent iframe to be attached to the DOM."""
    expect(app.locator("iframe").first).to_be_attached()


def test_components_html(app: Page):
    """Test that components.html can be imported and used"""
    _select_component(app, "componentsHtml")
    _expect_no_exception(app)
    _expect_iframe_attached(app)
    iframe = app.frame_locator("iframe")
    div = iframe.locator("div")
    expect(div).to_have_text("Hello World!")


@pytest.mark.parametrize(
    ("name", "expected_text"),
    [
        ("componentsIframe", "bound method IframeMixin._iframe of DeltaGenerator()"),
        ("componentsDeclareComponent", "function declare_component at"),
    ],
)
def test_components_import(app: Page, name: str, expected_text: str):
    """Test that components.iframe and components.declare_component can be imported and used.

    We only make sure that they are importable but do not call them, so we don't have an iframe element in the DOM.
    """
    _select_component(app, name)
    _expect_no_exception(app)
    div = app.get_by_test_id("stMarkdownContainer").filter(
        has_text=re.compile(f"<{expected_text}.*>")
    )
    expect(div).to_be_attached()


def test_ace(app: Page):
    """Test that the ace component renders"""
    _select_component(app, "ace")
    _expect_no_exception(app)
    _expect_iframe_attached(app)


def test_aggrid(app: Page):
    """Test that the aggrid component renders"""
    _select_component(app, "aggrid")
    _expect_no_exception(app)
    _expect_iframe_attached(app)


def test_antd(app: Page):
    """Test that the ace component renders"""
    _select_component(app, "antd")
    _expect_no_exception(app)
    _expect_iframe_attached(app)


def test_autorefresh(app: Page):
    """Test that the autorefresh component renders"""
    _select_component(app, "autorefresh")
    _expect_no_exception(app)


def test_chat(app: Page):
    """Test that the chat component renders"""
    _select_component(app, "chat")
    _expect_iframe_attached(app)


def test_echarts(app: Page):
    """Test that the echarts component renders"""
    _select_component(app, "echarts")
    _expect_no_exception(app)


def test_extra_streamlit_components(app: Page):
    """Test that the extra-strealit-components component renders"""
    _select_component(app, "extraStreamlitComponents")
    _expect_no_exception(app)
    _expect_iframe_attached(app)


def test_folium(app: Page):
    """Test that the folium component renders"""
    _select_component(app, "folium")
    _expect_no_exception(app)
    _expect_iframe_attached(app)


def test_option_menu(app: Page):
    """Test that the option-menu component renders"""
    _select_component(app, "optionMenu")
    _expect_no_exception(app)
    _expect_iframe_attached(app)

    # TODO: uncomment the on_change callback as soon as streamlit-option-menu is updated and uses the new on_change callback
    # frame_locator = app.frame_locator("iframe")
    # frame_locator.locator("a", has_text="Home").click()
    # expect(
    #     app.get_by_test_id("stMarkdown").filter(has_text="Selection changed to Home")
    # ).to_be_visible()


def test_url_fragment(app: Page):
    """Test that the url-fragment component renders"""
    _select_component(app, "urlFragment")
    _expect_no_exception(app)
    _expect_iframe_attached(app)


================================================
File: /e2e_playwright/multipage_apps/__init__.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


================================================
File: /e2e_playwright/multipage_apps/mpa_basics.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from pathlib import Path

import streamlit as st

st.header("Main Page")
st.slider("x")

st.write("Query Params:", st.query_params)

if st.button("`pages/02_page2.py`"):
    st.switch_page("pages/02_page2.py")

if st.button("`pages/08_slow_page.py`"):
    st.switch_page(Path("pages/08_slow_page.py"))


================================================
File: /e2e_playwright/multipage_apps/mpa_basics_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect

from e2e_playwright.conftest import (
    ImageCompareFunction,
    wait_for_app_loaded,
    wait_for_app_run,
)
from e2e_playwright.shared.app_utils import click_button


def test_loads_main_script_on_initial_page_load(app: Page):
    """Test that the main script is loaded on initial page load."""
    expect(app.get_by_test_id("stHeading")).to_contain_text("Main Page")


def test_renders_sidebar_nav_correctly(
    themed_app: Page, assert_snapshot: ImageCompareFunction
):
    """Test that the sidebar nav is rendered correctly."""
    assert_snapshot(themed_app.get_by_test_id("stSidebarNav"), name="mpa-sidebar_nav")


def test_can_switch_between_pages_by_clicking_on_sidebar_links(app: Page):
    """Test that we can switch between pages by clicking on sidebar links."""
    app.get_by_test_id("stSidebarNav").locator("a").nth(1).click()
    wait_for_app_run(app)
    expect(app.get_by_test_id("stHeading")).to_contain_text("Page 2")


def test_supports_navigating_to_page_directly_via_url(page: Page, app_port: int):
    """Test that we can navigate to a page directly via URL."""
    page.goto(f"http://localhost:{app_port}/page2")
    wait_for_app_loaded(page)

    expect(page.get_by_test_id("stHeading")).to_contain_text("Page 2")


def test_can_switch_between_pages_and_edit_widgets(app: Page):
    """Test that we can switch between pages and edit widgets."""
    slider = app.locator('.stSlider [role="slider"]')
    slider.click()
    slider.press("ArrowRight")
    wait_for_app_run(app, wait_delay=500)

    app.get_by_test_id("stSidebarNav").locator("a").nth(2).click()
    wait_for_app_run(app, wait_delay=1000)

    expect(app.get_by_test_id("stHeading")).to_contain_text("Page 3")
    expect(app.get_by_test_id("stMarkdown")).to_contain_text("x is 0")

    slider.click()
    slider.press("ArrowRight")
    wait_for_app_run(app)

    expect(app.get_by_test_id("stMarkdown")).to_contain_text("x is 1")


def test_can_switch_to_the_first_page_with_a_duplicate_name(app: Page):
    """Test that we can switch to the first page with a duplicate name."""
    app.get_by_test_id("stSidebarNav").locator("a").nth(3).click()
    wait_for_app_run(app)
    expect(app.get_by_test_id("stHeading")).to_contain_text("Page 4")


def test_can_switch_to_the_second_page_with_a_duplicate_name(app: Page):
    """Test that we can switch to the second page with a duplicate name."""
    app.get_by_test_id("stSidebarNav").locator("a").nth(4).click()
    wait_for_app_run(app)
    expect(app.get_by_test_id("stHeading")).to_contain_text("Page 5")


def test_runs_the_first_page_with_a_duplicate_name_if_navigating_via_url(
    page: Page, app_port: int
):
    """Test that we run the first page with a duplicate name if navigating via URL."""
    page.goto(f"http://localhost:{app_port}/page_with_duplicate_name")
    wait_for_app_loaded(page)

    expect(page.get_by_test_id("stHeading")).to_contain_text("Page 4")


def test_show_not_found_dialog(page: Page, app_port: int):
    """Test that we show a not found dialog if the page doesn't exist."""
    page.goto(f"http://localhost:{app_port}/not_a_page")
    wait_for_app_loaded(page)

    expect(page.locator('[role="dialog"]')).to_contain_text("Page not found")


def test_handles_expand_collapse_of_mpa_nav_correctly(
    page: Page, app_port: int, assert_snapshot: ImageCompareFunction
):
    """Test that we handle expand/collapse of MPA nav correctly."""

    page.goto(f"http://localhost:{app_port}/page_7")
    wait_for_app_loaded(page)

    view_button = page.get_by_test_id("stSidebarNavViewButton")

    expect(view_button).to_be_visible()

    # Expand the nav
    view_button.click(force=True)
    # We apply a quick timeout here so that the UI has some time to
    # adjust for the screenshot after the click
    page.wait_for_timeout(250)
    # move the mouse out of the way to avoid hover effects
    page.mouse.move(0, 0)
    assert_snapshot(
        page.get_by_test_id("stSidebarNav"), name="mpa-sidebar_nav_expanded"
    )

    # Collapse the nav
    view_button.click(force=True)
    page.wait_for_timeout(250)
    # move the mouse out of the way to avoid hover effects
    page.mouse.move(0, 0)
    assert_snapshot(
        page.get_by_test_id("stSidebarNav"), name="mpa-sidebar_nav_collapsed"
    )

    # Expand the nav again
    view_button.click(force=True)
    page.wait_for_timeout(250)
    # move the mouse out of the way to avoid hover effects
    page.mouse.move(0, 0)
    assert_snapshot(
        page.get_by_test_id("stSidebarNav"), name="mpa-sidebar_nav_expanded"
    )


def test_switch_page(app: Page):
    """Test that we can switch between pages by triggering st.switch_page."""

    # Click the button to trigger st.switch_page using relative path
    app.get_by_test_id("stButton").nth(0).locator("button").first.click()
    wait_for_app_run(app)

    # Check that we are on the correct page
    expect(app.get_by_test_id("stHeading")).to_contain_text("Page 2")

    # st.switch_page using relative path & leading /
    click_button(app, "pages/06_page_6.py")
    expect(app.get_by_test_id("stHeading")).to_contain_text("Page 6")

    # st.switch_page using relative path & leading ./
    click_button(app, "./mpa_basics.py")
    expect(app.get_by_test_id("stHeading")).to_contain_text("Main Page")


def test_switch_page_preserves_embed_params(page: Page, app_port: int):
    """Test that st.switch_page only preserves embed params."""

    # Start at main page with embed & other query params
    page.goto(
        f"http://localhost:{app_port}/?embed=true&embed_options=light_theme&bar=foo"
    )
    wait_for_app_loaded(page, embedded=True)
    expect(page.get_by_test_id("stJson")).to_contain_text('{"bar":"foo"}')

    # Trigger st.switch_page
    page.get_by_test_id("stButton").nth(0).locator("button").first.click()
    wait_for_app_loaded(page, embedded=True)

    # Check that only embed query params persist
    expect(page).to_have_url(
        f"http://localhost:{app_port}/page2?embed=true&embed_options=light_theme"
    )
    expect(page.get_by_test_id("stJson")).not_to_contain_text('{"bar":"foo"}')


def test_switch_page_removes_query_params(page: Page, app_port: int):
    """Test that query params are removed when navigating via st.switch_page"""

    # Start at main page with query params
    page.goto(f"http://localhost:{app_port}/?foo=bar")
    wait_for_app_loaded(page)

    # Trigger st.switch_page
    page.get_by_test_id("stButton").nth(0).locator("button").first.click()
    wait_for_app_loaded(page)
    # Check that query params don't persist
    expect(page).to_have_url(f"http://localhost:{app_port}/page2")


def test_switch_page_switches_immediately_if_second_page_is_slow(app: Page):
    app.get_by_test_id("stButton").nth(1).locator("button").first.click()

    # Wait for the view container and main menu to appear (like in wait_for_app_loaded),
    # but don't wait for the script to finish running.
    app.wait_for_selector(
        "[data-testid='stAppViewContainer']", timeout=30000, state="attached"
    )
    app.wait_for_selector("[data-testid='stMainMenu']", timeout=20000, state="attached")

    # We expect to see the page transition to the slow page by the time this call times
    # out in 5s. Otherwise, the page contents aren't being rendered until the script has
    # fully completed, and we've run into https://github.com/streamlit/streamlit/issues/7954
    expect(app.get_by_test_id("stHeading")).to_contain_text("Slow page")


def test_widget_state_reset_on_page_switch(app: Page):
    # Regression test for GH issue 7338

    # Page 3
    app.get_by_test_id("stSidebarNav").locator("a").nth(2).click()

    slider = app.locator('.stSlider [role="slider"]')
    slider.click()
    slider.press("ArrowRight")
    wait_for_app_run(app, wait_delay=500)
    expect(app.get_by_test_id("stMarkdown")).to_contain_text("x is 1")

    # Switch to the slow page
    app.get_by_test_id("stSidebarNav").locator("a").nth(7).click()

    # Wait for the view container and main menu to appear (like in wait_for_app_loaded),
    # but don't wait for the script to finish running.
    app.wait_for_selector(
        "[data-testid='stAppViewContainer']", timeout=30000, state="attached"
    )
    app.wait_for_selector("[data-testid='stMainMenu']", timeout=20000, state="attached")

    # Back to page 3
    app.get_by_test_id("stSidebarNav").locator("a").nth(2).click()
    wait_for_app_run(app, wait_delay=500)

    # Slider reset
    expect(app.get_by_test_id("stMarkdown")).to_contain_text("x is 0")


def test_removes_query_params_when_swapping_pages(page: Page, app_port: int):
    """Test that query params are removed when swapping pages"""

    page.goto(f"http://localhost:{app_port}/page_7?foo=bar")
    wait_for_app_loaded(page)

    page.get_by_test_id("stSidebarNav").locator("a").nth(2).click()
    wait_for_app_loaded(page)
    expect(page).to_have_url(f"http://localhost:{app_port}/page3")


def test_removes_non_embed_query_params_when_swapping_pages(page: Page, app_port: int):
    """Test that query params are removed when swapping pages"""

    page.goto(
        f"http://localhost:{app_port}/page_7?foo=bar&embed=True&embed_options=show_toolbar&embed_options=show_colored_line"
    )
    wait_for_app_loaded(page)

    page.get_by_test_id("stSidebarNav").locator("a").nth(2).click()
    wait_for_app_loaded(page)

    expect(page).to_have_url(
        f"http://localhost:{app_port}/page3?embed=true&embed_options=show_toolbar&embed_options=show_colored_line"
    )


def test_renders_logos(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that logos display properly in sidebar and main sections"""

    # Go to logo page & wait short moment for logo to appear
    app.get_by_test_id("stSidebarNav").locator("a").nth(8).click()
    wait_for_app_loaded(app)

    # Sidebar logo
    expect(app.get_by_test_id("stSidebarHeader").locator("a")).to_have_attribute(
        "href", "https://www.example.com"
    )
    assert_snapshot(app.get_by_test_id("stSidebar"), name="sidebar-logo")

    # Collapse the sidebar
    app.get_by_test_id("stSidebarContent").hover()
    app.get_by_test_id("stSidebarCollapseButton").locator("button").click()
    app.wait_for_timeout(500)

    # Collapsed logo
    expect(
        app.get_by_test_id("stSidebarCollapsedControl").locator("a")
    ).to_have_attribute("href", "https://www.example.com")
    assert_snapshot(
        app.get_by_test_id("stSidebarCollapsedControl"), name="collapsed-logo"
    )


def test_renders_small_logos(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that small logos display properly in sidebar and main sections"""

    # Go to small logo page & wait short moment for logo to appear
    app.get_by_test_id("stSidebarNav").locator("a").nth(9).click()
    wait_for_app_loaded(app)

    # Sidebar logo
    expect(app.get_by_test_id("stSidebarHeader").locator("a")).to_have_attribute(
        "href", "https://www.example.com"
    )
    assert_snapshot(app.get_by_test_id("stSidebar"), name="small-sidebar-logo")

    # Collapse the sidebar
    app.get_by_test_id("stSidebarContent").hover()
    app.get_by_test_id("stSidebarCollapseButton").locator("button").click()
    app.wait_for_timeout(500)

    # Collapsed logo
    expect(
        app.get_by_test_id("stSidebarCollapsedControl").locator("a")
    ).to_have_attribute("href", "https://www.example.com")
    assert_snapshot(
        app.get_by_test_id("stSidebarCollapsedControl"), name="small-collapsed-logo"
    )


def test_renders_large_logos(app: Page, assert_snapshot: ImageCompareFunction):
    """Test that large logos display properly in sidebar and main sections"""

    # Go to large logo page & wait short moment for logo to appear
    app.get_by_test_id("stSidebarNav").locator("a").nth(10).click()
    wait_for_app_loaded(app)

    # Sidebar logo
    expect(app.get_by_test_id("stSidebarHeader").locator("a")).to_have_attribute(
        "href", "https://www.example.com"
    )
    assert_snapshot(app.get_by_test_id("stSidebar"), name="large-sidebar-logo")

    # Collapse the sidebar
    app.get_by_test_id("stSidebarContent").hover()
    app.get_by_test_id("stSidebarCollapseButton").locator("button").click()
    app.wait_for_timeout(500)

    # Collapsed logo
    expect(
        app.get_by_test_id("stSidebarCollapsedControl").locator("a")
    ).to_have_attribute("href", "https://www.example.com")
    assert_snapshot(
        app.get_by_test_id("stSidebarCollapsedControl"), name="large-collapsed-logo"
    )


================================================
File: /e2e_playwright/multipage_apps/mpa_configure_sidebar.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import pathlib
from pathlib import Path

from PIL import Image

import streamlit as st

small_logo = Image.open(str(pathlib.Path(__file__).parent / "small-streamlit.png"))

logo = Image.open(str(pathlib.Path(__file__).parent / "full-streamlit.png"))

st.header("App with no sidebar")

st.subheader("Page Navigation:")

st.logo(logo, link="https://www.example.com", icon_image=small_logo)


colA, colB = st.container(key="page_link_container").columns(2)

with colA:
    st.page_link("mpa_configure_sidebar.py", label="Home", icon="🏠")
    st.page_link(Path("pages/02_page2.py"), label="Page 2", icon=":material/article:")
    st.page_link("pages/03_page3.py", label="Page 3", icon="📈", disabled=True)

with colB:
    st.page_link("pages/04_page_with_duplicate_name.py", label="Page 4", icon="🧪")
    st.page_link("pages/05_page_with_duplicate_name.py", label="Page 5", icon="🌎")


================================================
File: /e2e_playwright/multipage_apps/mpa_configure_sidebar_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os

import pytest
from playwright.sync_api import Page, expect

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_run
from e2e_playwright.shared.app_utils import get_element_by_key


@pytest.fixture(scope="module")
@pytest.mark.early
def configure_show_sidebar_nav():
    """Configure client.showSidebarNavigation=False."""
    # We need to do this in a package scope fixture to ensure that its applied
    # before the app server is started.
    os.environ["STREAMLIT_CLIENT_SHOW_SIDEBAR_NAVIGATION"] = "False"
    yield
    del os.environ["STREAMLIT_CLIENT_SHOW_SIDEBAR_NAVIGATION"]


def test_hides_sidebar_nav(app: Page, configure_show_sidebar_nav):
    """Test that client.showSidebarNavigation=False hides the sidebar."""
    expect(app.get_by_test_id("stSidebar")).not_to_be_attached()


def test_page_links_in_main(
    themed_app: Page, configure_show_sidebar_nav, assert_snapshot: ImageCompareFunction
):
    """Test that page link appears as expected in main."""
    expect(themed_app.get_by_test_id("stSidebar")).not_to_be_attached()
    page_links = themed_app.get_by_test_id("stPageLink-NavLink")
    expect(page_links).to_have_count(5)

    # Selected page
    assert_snapshot(page_links.nth(0), name="current-page-link")
    page_links.nth(0).hover()
    assert_snapshot(page_links.nth(0), name="current-page-link-hover")
    # Non-selected page
    assert_snapshot(page_links.nth(1), name="page-link")
    page_links.nth(1).hover()
    assert_snapshot(page_links.nth(1), name="page-link-hover")
    # Disabled page
    assert_snapshot(page_links.nth(2), name="page-link-disabled")


def test_page_links_use_correct_margin(
    app: Page, configure_show_sidebar_nav, assert_snapshot: ImageCompareFunction
):
    """Test that page links use the correct margin."""
    page_link_container = get_element_by_key(app, "page_link_container")
    assert_snapshot(page_link_container, name="st_page_link-correct_margin")


# Firefox seems to be a bit flaky here, it seems that sometimes the
# sidebar with the nav items is still shown.
@pytest.mark.skip_browser("firefox")
def test_page_links_in_sidebar(
    themed_app: Page, configure_show_sidebar_nav, assert_snapshot: ImageCompareFunction
):
    """Test that page link appears as expected in sidebar."""
    page_links = themed_app.get_by_test_id("stPageLink-NavLink")

    # Navigate to Page 4
    page_links.nth(3).click()
    wait_for_app_run(themed_app)

    page_links = themed_app.get_by_test_id("stPageLink-NavLink")
    expect(page_links).to_have_count(5)

    # Selected page
    assert_snapshot(page_links.nth(3), name="current-page-link-sidebar")
    page_links.nth(3).hover()
    assert_snapshot(page_links.nth(3), name="current-page-link-sidebar-hover")
    # Non-selected page
    assert_snapshot(page_links.nth(0), name="page-link-sidebar")
    page_links.nth(0).hover()
    assert_snapshot(page_links.nth(0), name="page-link-sidebar-hover")
    # Disabled page
    assert_snapshot(page_links.nth(4), name="page-link-sidebar-disabled")


def test_page_link_href(
    app: Page,
    configure_show_sidebar_nav,
):
    """Test that page link href set properly."""
    page_links = app.get_by_test_id("stPageLink-NavLink")

    expect(page_links.nth(0)).to_have_attribute("href", "mpa_configure_sidebar")
    expect(page_links.nth(1)).to_have_attribute("href", "page2")
    expect(page_links.nth(2)).to_have_attribute("href", "page3")
    expect(page_links.nth(3)).to_have_attribute("href", "page_with_duplicate_name")


# Firefox seems to be a bit flaky here, it seems that sometimes the
# sidebar with the nav items is still shown.
@pytest.mark.skip_browser("firefox")
def test_logo_no_sidebar(
    app: Page, configure_show_sidebar_nav, assert_snapshot: ImageCompareFunction
):
    """Test that logo renders properly with no sidebar."""
    expect(app.get_by_test_id("stSidebar")).not_to_be_attached()
    expect(
        app.get_by_test_id("stSidebarCollapsedControl").locator("a")
    ).to_have_attribute("href", "https://www.example.com")
    assert_snapshot(
        app.get_by_test_id("stSidebarCollapsedControl"), name="logo-no-sidebar"
    )


================================================
File: /e2e_playwright/multipage_apps/mpa_v2_custom_theme.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.header("📊 Random App Content")
st.radio("**Example Main Content**", ["Home", "About", "Contact"])
st.slider("**Example Slider**", 0, 100, 50)
st.divider()

with st.sidebar:
    st.subheader("Having fun yet?")
    st.slider("Amount of fun", 0, 1000, 450)

pg = st.navigation(
    {
        "Overview": [
            st.Page(
                "pages/02_page2.py",
                title="Home Page",
                default=True,
                icon=":material/home:",
            ),
            st.Page(
                "pages/03_page3.py", title="Plant Page", icon=":material/potted_plant:"
            ),
        ],
        "Random": [
            st.Page("pages/09_logo_page.py", title="Logo Page", icon=":material/star:"),
            st.Page(
                "pages/06_page_6.py",
                title="Star Page",
                icon=":material/star_border:",
            ),
            st.Page(
                "pages/07_page_7.py",
                title="Animal Page",
                icon=":material/pets:",
            ),
            st.Page(
                "pages/08_slow_page.py",
                title="Random Page",
                icon=":material/rocket_launch:",
            ),
            st.Page(
                "pages/04_page_with_duplicate_name.py",
                title="Time Page",
                icon=":material/access_time:",
            ),
            st.Page(
                "pages/05_page_with_duplicate_name.py",
                title="Events Page",
                url_path="events",
                icon=":material/emoji_events:",
            ),
        ],
    }
)

pg.run()

st.write("End of Main Page")


================================================
File: /e2e_playwright/multipage_apps/mpa_v2_custom_theme_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os

import pytest
from playwright.sync_api import Page

from e2e_playwright.conftest import ImageCompareFunction, wait_for_app_loaded


@pytest.fixture(scope="module")
@pytest.mark.early
def configure_custom_text_color():
    """Configure theme.textColor and theme.primaryColor."""
    # We need to do this in a package scope fixture to ensure that its applied
    # before the app server is started.
    os.environ["STREAMLIT_THEME_TEXT_COLOR"] = "#BB1010"
    os.environ["STREAMLIT_THEME_PRIMARY_COLOR"] = "#0E0E0E"
    yield
    del os.environ["STREAMLIT_THEME_TEXT_COLOR"]
    del os.environ["STREAMLIT_THEME_PRIMARY_COLOR"]


def test_custom_text_color(
    app: Page, configure_custom_text_color, assert_snapshot: ImageCompareFunction
):
    """Test that custom text color is applied correctly to SidebarNav."""
    app.get_by_text("Logo Page").click()
    wait_for_app_loaded(app)

    assert_snapshot(app.get_by_test_id("stSidebar"), name="sidebar-nav-custom-theme")


================================================
File: /e2e_playwright/multipage_apps/mpa_v2_transition.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.header("Main Page")

pg = st.navigation(
    [
        st.Page("pages/02_page2.py"),
        st.Page("pages/03_page3.py", default=True),
        st.Page("pages/09_logo_page.py"),
    ]
)

pg.run()

st.write("End of Main Page")


================================================
File: /e2e_playwright/multipage_apps/mpa_v2_transition_test.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from playwright.sync_api import Page, expect


def test_v1_to_v2_transition(app: Page):
    """Tests that Streamlit migrates from v1 to v2 progressively"""
    headings = app.get_by_test_id("stHeading")
    # expect the main page element to show in the beginning
    expect(headings.nth(0)).to_contain_text("Main Page")
    # expect the page 3 element to show
    # this also shows a different default page is written
    expect(headings.nth(1)).to_contain_text("Page 3")

    # expect the main page to continue running once the page completes
    markdowns = app.get_by_test_id("stMarkdown")
    expect(markdowns.nth(1)).to_contain_text("End of Main Page")


================================================
File: /e2e_playwright/multipage_apps/pages/02_page2.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.header("Page 2")

st.write("Query Params:", st.query_params)

page_6 = st.button("`pages/06_page_6.py`")
if page_6:
    st.switch_page("pages/06_page_6.py")


================================================
File: /e2e_playwright/multipage_apps/pages/03_page3.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.header("Page 3")
x = st.slider("x")
st.markdown(f"x is {x}")


================================================
File: /e2e_playwright/multipage_apps/pages/04_page_with_duplicate_name.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.header("Page 4")

with st.sidebar:
    st.page_link("mpa_configure_sidebar.py", label="Home", icon="🏠")
    st.page_link("pages/02_page2.py", label="Page 2", icon=":material/article:")
    st.page_link("pages/03_page3.py", label="Page 3", icon="📈")
    st.page_link("pages/04_page_with_duplicate_name.py", label="Page 4", icon="🧪")
    st.page_link(
        "pages/05_page_with_duplicate_name.py", label="Page 5", icon="🌎", disabled=True
    )


================================================
File: /e2e_playwright/multipage_apps/pages/05_page_with_duplicate_name.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import streamlit as st

st.header("Page 5")


================================================
File: /e2e_playwright/multipage_apps/pages/06_page_6.py
================================================
# Copyright (c) Streamlit Inc. (2018-2022) Snowflake Inc. (2022-2025)
#
# Licensed under the Apache License, Version 2.0 (the "License");
