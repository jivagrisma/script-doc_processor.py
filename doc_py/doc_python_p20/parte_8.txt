`Python 3.12 <https://docs.python.org/3.12/library/crypt.html>`_.


================================================
File: /Doc/library/crypto.rst
================================================
.. _crypto:

**********************
Cryptographic Services
**********************

.. index:: single: cryptography

The modules described in this chapter implement various algorithms of a
cryptographic nature.  They are available at the discretion of the installation.
Here's an overview:


.. toctree::

   hashlib.rst
   hmac.rst
   secrets.rst


================================================
File: /Doc/library/csv.rst
================================================
:mod:`!csv` --- CSV File Reading and Writing
============================================

.. module:: csv
   :synopsis: Write and read tabular data to and from delimited files.

.. sectionauthor:: Skip Montanaro <skip.montanaro@gmail.com>

**Source code:** :source:`Lib/csv.py`

.. index::
   single: csv
   pair: data; tabular

--------------

The so-called CSV (Comma Separated Values) format is the most common import and
export format for spreadsheets and databases.  CSV format was used for many
years prior to attempts to describe the format in a standardized way in
:rfc:`4180`.  The lack of a well-defined standard means that subtle differences
often exist in the data produced and consumed by different applications.  These
differences can make it annoying to process CSV files from multiple sources.
Still, while the delimiters and quoting characters vary, the overall format is
similar enough that it is possible to write a single module which can
efficiently manipulate such data, hiding the details of reading and writing the
data from the programmer.

The :mod:`csv` module implements classes to read and write tabular data in CSV
format.  It allows programmers to say, "write this data in the format preferred
by Excel," or "read data from this file which was generated by Excel," without
knowing the precise details of the CSV format used by Excel.  Programmers can
also describe the CSV formats understood by other applications or define their
own special-purpose CSV formats.

The :mod:`csv` module's :class:`reader` and :class:`writer` objects read and
write sequences.  Programmers can also read and write data in dictionary form
using the :class:`DictReader` and :class:`DictWriter` classes.

.. seealso::

   :pep:`305` - CSV File API
      The Python Enhancement Proposal which proposed this addition to Python.


.. _csv-contents:

Module Contents
---------------

The :mod:`csv` module defines the following functions:


.. index::
   single: universal newlines; csv.reader function

.. function:: reader(csvfile, dialect='excel', **fmtparams)

   Return a :ref:`reader object <reader-objects>` that will process
   lines from the given *csvfile*.  A csvfile must be an iterable of
   strings, each in the reader's defined csv format.
   A csvfile is most commonly a file-like object or list.
   If *csvfile* is a file object,
   it should be opened with ``newline=''``. [1]_  An optional
   *dialect* parameter can be given which is used to define a set of parameters
   specific to a particular CSV dialect.  It may be an instance of a subclass of
   the :class:`Dialect` class or one of the strings returned by the
   :func:`list_dialects` function.  The other optional *fmtparams* keyword arguments
   can be given to override individual formatting parameters in the current
   dialect.  For full details about the dialect and formatting parameters, see
   section :ref:`csv-fmt-params`.

   Each row read from the csv file is returned as a list of strings.  No
   automatic data type conversion is performed unless the ``QUOTE_NONNUMERIC`` format
   option is specified (in which case unquoted fields are transformed into floats).

   A short usage example::

      >>> import csv
      >>> with open('eggs.csv', newline='') as csvfile:
      ...     spamreader = csv.reader(csvfile, delimiter=' ', quotechar='|')
      ...     for row in spamreader:
      ...         print(', '.join(row))
      Spam, Spam, Spam, Spam, Spam, Baked Beans
      Spam, Lovely Spam, Wonderful Spam


.. function:: writer(csvfile, dialect='excel', **fmtparams)

   Return a writer object responsible for converting the user's data into delimited
   strings on the given file-like object.  *csvfile* can be any object with a
   :meth:`~io.TextIOBase.write` method.  If *csvfile* is a file object, it should be opened with
   ``newline=''`` [1]_.  An optional *dialect*
   parameter can be given which is used to define a set of parameters specific to a
   particular CSV dialect.  It may be an instance of a subclass of the
   :class:`Dialect` class or one of the strings returned by the
   :func:`list_dialects` function.  The other optional *fmtparams* keyword arguments
   can be given to override individual formatting parameters in the current
   dialect.  For full details about dialects and formatting parameters, see
   the :ref:`csv-fmt-params` section. To make it
   as easy as possible to interface with modules which implement the DB API, the
   value :const:`None` is written as the empty string.  While this isn't a
   reversible transformation, it makes it easier to dump SQL NULL data values to
   CSV files without preprocessing the data returned from a ``cursor.fetch*`` call.
   All other non-string data are stringified with :func:`str` before being written.

   A short usage example::

      import csv
      with open('eggs.csv', 'w', newline='') as csvfile:
          spamwriter = csv.writer(csvfile, delimiter=' ',
                                  quotechar='|', quoting=csv.QUOTE_MINIMAL)
          spamwriter.writerow(['Spam'] * 5 + ['Baked Beans'])
          spamwriter.writerow(['Spam', 'Lovely Spam', 'Wonderful Spam'])


.. function:: register_dialect(name[, dialect[, **fmtparams]])

   Associate *dialect* with *name*.  *name* must be a string. The
   dialect can be specified either by passing a sub-class of :class:`Dialect`, or
   by *fmtparams* keyword arguments, or both, with keyword arguments overriding
   parameters of the dialect. For full details about dialects and formatting
   parameters, see section :ref:`csv-fmt-params`.


.. function:: unregister_dialect(name)

   Delete the dialect associated with *name* from the dialect registry.  An
   :exc:`Error` is raised if *name* is not a registered dialect name.


.. function:: get_dialect(name)

   Return the dialect associated with *name*.  An :exc:`Error` is raised if
   *name* is not a registered dialect name.  This function returns an immutable
   :class:`Dialect`.

.. function:: list_dialects()

   Return the names of all registered dialects.


.. function:: field_size_limit([new_limit])

   Returns the current maximum field size allowed by the parser. If *new_limit* is
   given, this becomes the new limit.


The :mod:`csv` module defines the following classes:

.. class:: DictReader(f, fieldnames=None, restkey=None, restval=None, \
                      dialect='excel', *args, **kwds)

   Create an object that operates like a regular reader but maps the
   information in each row to a :class:`dict` whose keys are given by the
   optional *fieldnames* parameter.

   The *fieldnames* parameter is a :term:`sequence`.  If *fieldnames* is
   omitted, the values in the first row of file *f* will be used as the
   fieldnames and will be omitted from the results. If
   *fieldnames* is provided, they will be used and the first row will be
   included in the results.  Regardless of how the fieldnames are determined,
   the dictionary preserves their original ordering.

   If a row has more fields than fieldnames, the remaining data is put in a
   list and stored with the fieldname specified by *restkey* (which defaults
   to ``None``).  If a non-blank row has fewer fields than fieldnames, the
   missing values are filled-in with the value of *restval* (which defaults
   to ``None``).

   All other optional or keyword arguments are passed to the underlying
   :class:`reader` instance.

   If the argument passed to *fieldnames* is an iterator, it will be coerced to a :class:`list`.

   .. versionchanged:: 3.6
      Returned rows are now of type :class:`OrderedDict`.

   .. versionchanged:: 3.8
      Returned rows are now of type :class:`dict`.

   A short usage example::

       >>> import csv
       >>> with open('names.csv', newline='') as csvfile:
       ...     reader = csv.DictReader(csvfile)
       ...     for row in reader:
       ...         print(row['first_name'], row['last_name'])
       ...
       Eric Idle
       John Cleese

       >>> print(row)
       {'first_name': 'John', 'last_name': 'Cleese'}


.. class:: DictWriter(f, fieldnames, restval='', extrasaction='raise', \
                      dialect='excel', *args, **kwds)

   Create an object which operates like a regular writer but maps dictionaries
   onto output rows.  The *fieldnames* parameter is a :mod:`sequence
   <collections.abc>` of keys that identify the order in which values in the
   dictionary passed to the :meth:`~csvwriter.writerow` method are written to file
   *f*.  The optional *restval* parameter specifies the value to be
   written if the dictionary is missing a key in *fieldnames*.  If the
   dictionary passed to the :meth:`~csvwriter.writerow` method contains a key not found in
   *fieldnames*, the optional *extrasaction* parameter indicates what action to
   take.
   If it is set to ``'raise'``, the default value, a :exc:`ValueError`
   is raised.
   If it is set to ``'ignore'``, extra values in the dictionary are ignored.
   Any other optional or keyword arguments are passed to the underlying
   :class:`writer` instance.

   Note that unlike the :class:`DictReader` class, the *fieldnames* parameter
   of the :class:`DictWriter` class is not optional.

   If the argument passed to *fieldnames* is an iterator, it will be coerced to a :class:`list`.

   A short usage example::

       import csv

       with open('names.csv', 'w', newline='') as csvfile:
           fieldnames = ['first_name', 'last_name']
           writer = csv.DictWriter(csvfile, fieldnames=fieldnames)

           writer.writeheader()
           writer.writerow({'first_name': 'Baked', 'last_name': 'Beans'})
           writer.writerow({'first_name': 'Lovely', 'last_name': 'Spam'})
           writer.writerow({'first_name': 'Wonderful', 'last_name': 'Spam'})


.. class:: Dialect

   The :class:`Dialect` class is a container class whose attributes contain
   information for how to handle doublequotes, whitespace, delimiters, etc.
   Due to the lack of a strict CSV specification, different applications
   produce subtly different CSV data.  :class:`Dialect` instances define how
   :class:`reader` and :class:`writer` instances behave.

   All available :class:`Dialect` names are returned by :func:`list_dialects`,
   and they can be registered with specific :class:`reader` and :class:`writer`
   classes through their initializer (``__init__``) functions like this::

       import csv

       with open('students.csv', 'w', newline='') as csvfile:
           writer = csv.writer(csvfile, dialect='unix')


.. class:: excel()

   The :class:`excel` class defines the usual properties of an Excel-generated CSV
   file.  It is registered with the dialect name ``'excel'``.


.. class:: excel_tab()

   The :class:`excel_tab` class defines the usual properties of an Excel-generated
   TAB-delimited file.  It is registered with the dialect name ``'excel-tab'``.


.. class:: unix_dialect()

   The :class:`unix_dialect` class defines the usual properties of a CSV file
   generated on UNIX systems, i.e. using ``'\n'`` as line terminator and quoting
   all fields.  It is registered with the dialect name ``'unix'``.

   .. versionadded:: 3.2


.. class:: Sniffer()

   The :class:`Sniffer` class is used to deduce the format of a CSV file.

   The :class:`Sniffer` class provides two methods:

   .. method:: sniff(sample, delimiters=None)

      Analyze the given *sample* and return a :class:`Dialect` subclass
      reflecting the parameters found.  If the optional *delimiters* parameter
      is given, it is interpreted as a string containing possible valid
      delimiter characters.


   .. method:: has_header(sample)

      Analyze the sample text (presumed to be in CSV format) and return
      :const:`True` if the first row appears to be a series of column headers.
      Inspecting each column, one of two key criteria will be considered to
      estimate if the sample contains a header:

      - the second through n-th rows contain numeric values
      - the second through n-th rows contain strings where at least one value's
        length differs from that of the putative header of that column.

      Twenty rows after the first row are sampled; if more than half of columns +
      rows meet the criteria, :const:`True` is returned.

   .. note::

      This method is a rough heuristic and may produce both false positives and
      negatives.

An example for :class:`Sniffer` use::

   with open('example.csv', newline='') as csvfile:
       dialect = csv.Sniffer().sniff(csvfile.read(1024))
       csvfile.seek(0)
       reader = csv.reader(csvfile, dialect)
       # ... process CSV file contents here ...


.. _csv-constants:

The :mod:`csv` module defines the following constants:

.. data:: QUOTE_ALL

   Instructs :class:`writer` objects to quote all fields.


.. data:: QUOTE_MINIMAL

   Instructs :class:`writer` objects to only quote those fields which contain
   special characters such as *delimiter*, *quotechar* or any of the characters in
   *lineterminator*.


.. data:: QUOTE_NONNUMERIC

   Instructs :class:`writer` objects to quote all non-numeric fields.

   Instructs :class:`reader` objects to convert all non-quoted fields to type *float*.


.. data:: QUOTE_NONE

   Instructs :class:`writer` objects to never quote fields.  When the current
   *delimiter* occurs in output data it is preceded by the current *escapechar*
   character.  If *escapechar* is not set, the writer will raise :exc:`Error` if
   any characters that require escaping are encountered.

   Instructs :class:`reader` objects to perform no special processing of quote characters.

.. data:: QUOTE_NOTNULL

   Instructs :class:`writer` objects to quote all fields which are not
   ``None``.  This is similar to :data:`QUOTE_ALL`, except that if a
   field value is ``None`` an empty (unquoted) string is written.

   Instructs :class:`reader` objects to interpret an empty (unquoted) field
   as ``None`` and to otherwise behave as :data:`QUOTE_ALL`.

   .. versionadded:: 3.12

.. data:: QUOTE_STRINGS

   Instructs :class:`writer` objects to always place quotes around fields
   which are strings.  This is similar to :data:`QUOTE_NONNUMERIC`, except that if a
   field value is ``None`` an empty (unquoted) string is written.

   Instructs :class:`reader` objects to interpret an empty (unquoted) string as ``None`` and
   to otherwise behave as :data:`QUOTE_NONNUMERIC`.

   .. versionadded:: 3.12

The :mod:`csv` module defines the following exception:


.. exception:: Error

   Raised by any of the functions when an error is detected.

.. _csv-fmt-params:

Dialects and Formatting Parameters
----------------------------------

To make it easier to specify the format of input and output records, specific
formatting parameters are grouped together into dialects.  A dialect is a
subclass of the :class:`Dialect` class containing various attributes
describing the format of the CSV file.  When creating :class:`reader` or
:class:`writer` objects, the programmer can specify a string or a subclass of
the :class:`Dialect` class as the dialect parameter.  In addition to, or instead
of, the *dialect* parameter, the programmer can also specify individual
formatting parameters, which have the same names as the attributes defined below
for the :class:`Dialect` class.

Dialects support the following attributes:


.. attribute:: Dialect.delimiter

   A one-character string used to separate fields.  It defaults to ``','``.


.. attribute:: Dialect.doublequote

   Controls how instances of *quotechar* appearing inside a field should
   themselves be quoted.  When :const:`True`, the character is doubled. When
   :const:`False`, the *escapechar* is used as a prefix to the *quotechar*.  It
   defaults to :const:`True`.

   On output, if *doublequote* is :const:`False` and no *escapechar* is set,
   :exc:`Error` is raised if a *quotechar* is found in a field.


.. attribute:: Dialect.escapechar

   A one-character string used by the writer to escape the *delimiter* if *quoting*
   is set to :const:`QUOTE_NONE` and the *quotechar* if *doublequote* is
   :const:`False`. On reading, the *escapechar* removes any special meaning from
   the following character. It defaults to :const:`None`, which disables escaping.

   .. versionchanged:: 3.11
      An empty *escapechar* is not allowed.

.. attribute:: Dialect.lineterminator

   The string used to terminate lines produced by the :class:`writer`. It defaults
   to ``'\r\n'``.

   .. note::

      The :class:`reader` is hard-coded to recognise either ``'\r'`` or ``'\n'`` as
      end-of-line, and ignores *lineterminator*. This behavior may change in the
      future.


.. attribute:: Dialect.quotechar

   A one-character string used to quote fields containing special characters, such
   as the *delimiter* or *quotechar*, or which contain new-line characters.  It
   defaults to ``'"'``.

   .. versionchanged:: 3.11
      An empty *quotechar* is not allowed.

.. attribute:: Dialect.quoting

   Controls when quotes should be generated by the writer and recognised by the
   reader.  It can take on any of the :ref:`QUOTE_\* constants <csv-constants>`
   and defaults to :const:`QUOTE_MINIMAL`.


.. attribute:: Dialect.skipinitialspace

   When :const:`True`, spaces immediately following the *delimiter* are ignored.
   The default is :const:`False`.


.. attribute:: Dialect.strict

   When ``True``, raise exception :exc:`Error` on bad CSV input.
   The default is ``False``.

.. _reader-objects:

Reader Objects
--------------

Reader objects (:class:`DictReader` instances and objects returned by the
:func:`reader` function) have the following public methods:

.. method:: csvreader.__next__()

   Return the next row of the reader's iterable object as a list (if the object
   was returned from :func:`reader`) or a dict (if it is a :class:`DictReader`
   instance), parsed according to the current :class:`Dialect`.  Usually you
   should call this as ``next(reader)``.


Reader objects have the following public attributes:

.. attribute:: csvreader.dialect

   A read-only description of the dialect in use by the parser.


.. attribute:: csvreader.line_num

   The number of lines read from the source iterator. This is not the same as the
   number of records returned, as records can span multiple lines.


DictReader objects have the following public attribute:

.. attribute:: DictReader.fieldnames

   If not passed as a parameter when creating the object, this attribute is
   initialized upon first access or when the first record is read from the
   file.



Writer Objects
--------------

:class:`writer` objects (:class:`DictWriter` instances and objects returned by
the :func:`writer` function) have the following public methods.  A *row* must be
an iterable of strings or numbers for :class:`writer` objects and a dictionary
mapping fieldnames to strings or numbers (by passing them through :func:`str`
first) for :class:`DictWriter` objects.  Note that complex numbers are written
out surrounded by parens. This may cause some problems for other programs which
read CSV files (assuming they support complex numbers at all).


.. method:: csvwriter.writerow(row)

   Write the *row* parameter to the writer's file object, formatted according
   to the current :class:`Dialect`. Return the return value of the call to the
   *write* method of the underlying file object.

   .. versionchanged:: 3.5
      Added support of arbitrary iterables.

.. method:: csvwriter.writerows(rows)

   Write all elements in *rows* (an iterable of *row* objects as described
   above) to the writer's file object, formatted according to the current
   dialect.

Writer objects have the following public attribute:


.. attribute:: csvwriter.dialect

   A read-only description of the dialect in use by the writer.


DictWriter objects have the following public method:


.. method:: DictWriter.writeheader()

   Write a row with the field names (as specified in the constructor) to
   the writer's file object, formatted according to the current dialect. Return
   the return value of the :meth:`csvwriter.writerow` call used internally.

   .. versionadded:: 3.2
   .. versionchanged:: 3.8
      :meth:`writeheader` now also returns the value returned by
      the :meth:`csvwriter.writerow` method it uses internally.


.. _csv-examples:

Examples
--------

The simplest example of reading a CSV file::

   import csv
   with open('some.csv', newline='') as f:
       reader = csv.reader(f)
       for row in reader:
           print(row)

Reading a file with an alternate format::

   import csv
   with open('passwd', newline='') as f:
       reader = csv.reader(f, delimiter=':', quoting=csv.QUOTE_NONE)
       for row in reader:
           print(row)

The corresponding simplest possible writing example is::

   import csv
   with open('some.csv', 'w', newline='') as f:
       writer = csv.writer(f)
       writer.writerows(someiterable)

Since :func:`open` is used to open a CSV file for reading, the file
will by default be decoded into unicode using the system default
encoding (see :func:`locale.getencoding`).  To decode a file
using a different encoding, use the ``encoding`` argument of open::

   import csv
   with open('some.csv', newline='', encoding='utf-8') as f:
       reader = csv.reader(f)
       for row in reader:
           print(row)

The same applies to writing in something other than the system default
encoding: specify the encoding argument when opening the output file.

Registering a new dialect::

   import csv
   csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)
   with open('passwd', newline='') as f:
       reader = csv.reader(f, 'unixpwd')

A slightly more advanced use of the reader --- catching and reporting errors::

   import csv, sys
   filename = 'some.csv'
   with open(filename, newline='') as f:
       reader = csv.reader(f)
       try:
           for row in reader:
               print(row)
       except csv.Error as e:
           sys.exit('file {}, line {}: {}'.format(filename, reader.line_num, e))

And while the module doesn't directly support parsing strings, it can easily be
done::

   import csv
   for row in csv.reader(['one,two,three']):
       print(row)


.. rubric:: Footnotes

.. [1] If ``newline=''`` is not specified, newlines embedded inside quoted fields
   will not be interpreted correctly, and on platforms that use ``\r\n`` linendings
   on write an extra ``\r`` will be added.  It should always be safe to specify
   ``newline=''``, since the csv module does its own
   (:term:`universal <universal newlines>`) newline handling.


================================================
File: /Doc/library/curses.ascii.rst
================================================
:mod:`!curses.ascii` --- Utilities for ASCII characters
=======================================================

.. module:: curses.ascii
   :synopsis: Constants and set-membership functions for ASCII characters.

.. moduleauthor:: Eric S. Raymond <esr@thyrsus.com>
.. sectionauthor:: Eric S. Raymond <esr@thyrsus.com>

**Source code:** :source:`Lib/curses/ascii.py`

--------------

The :mod:`curses.ascii` module supplies name constants for ASCII characters and
functions to test membership in various ASCII character classes.  The constants
supplied are names for control characters as follows:

+---------------+----------------------------------------------+
| Name          | Meaning                                      |
+===============+==============================================+
| .. data:: NUL |                                              |
+---------------+----------------------------------------------+
| .. data:: SOH | Start of heading, console interrupt          |
+---------------+----------------------------------------------+
| .. data:: STX | Start of text                                |
+---------------+----------------------------------------------+
| .. data:: ETX | End of text                                  |
+---------------+----------------------------------------------+
| .. data:: EOT | End of transmission                          |
+---------------+----------------------------------------------+
| .. data:: ENQ | Enquiry, goes with :const:`ACK` flow control |
+---------------+----------------------------------------------+
| .. data:: ACK | Acknowledgement                              |
+---------------+----------------------------------------------+
| .. data:: BEL | Bell                                         |
+---------------+----------------------------------------------+
| .. data:: BS  | Backspace                                    |
+---------------+----------------------------------------------+
| .. data:: TAB | Tab                                          |
+---------------+----------------------------------------------+
| .. data:: HT  | Alias for :const:`TAB`: "Horizontal tab"     |
+---------------+----------------------------------------------+
| .. data:: LF  | Line feed                                    |
+---------------+----------------------------------------------+
| .. data:: NL  | Alias for :const:`LF`: "New line"            |
+---------------+----------------------------------------------+
| .. data:: VT  | Vertical tab                                 |
+---------------+----------------------------------------------+
| .. data:: FF  | Form feed                                    |
+---------------+----------------------------------------------+
| .. data:: CR  | Carriage return                              |
+---------------+----------------------------------------------+
| .. data:: SO  | Shift-out, begin alternate character set     |
+---------------+----------------------------------------------+
| .. data:: SI  | Shift-in, resume default character set       |
+---------------+----------------------------------------------+
| .. data:: DLE | Data-link escape                             |
+---------------+----------------------------------------------+
| .. data:: DC1 | XON, for flow control                        |
+---------------+----------------------------------------------+
| .. data:: DC2 | Device control 2, block-mode flow control    |
+---------------+----------------------------------------------+
| .. data:: DC3 | XOFF, for flow control                       |
+---------------+----------------------------------------------+
| .. data:: DC4 | Device control 4                             |
+---------------+----------------------------------------------+
| .. data:: NAK | Negative acknowledgement                     |
+---------------+----------------------------------------------+
| .. data:: SYN | Synchronous idle                             |
+---------------+----------------------------------------------+
| .. data:: ETB | End transmission block                       |
+---------------+----------------------------------------------+
| .. data:: CAN | Cancel                                       |
+---------------+----------------------------------------------+
| .. data:: EM  | End of medium                                |
+---------------+----------------------------------------------+
| .. data:: SUB | Substitute                                   |
+---------------+----------------------------------------------+
| .. data:: ESC | Escape                                       |
+---------------+----------------------------------------------+
| .. data:: FS  | File separator                               |
+---------------+----------------------------------------------+
| .. data:: GS  | Group separator                              |
+---------------+----------------------------------------------+
| .. data:: RS  | Record separator, block-mode terminator      |
+---------------+----------------------------------------------+
| .. data:: US  | Unit separator                               |
+---------------+----------------------------------------------+
| .. data:: SP  | Space                                        |
+---------------+----------------------------------------------+
| .. data:: DEL | Delete                                       |
+---------------+----------------------------------------------+

Note that many of these have little practical significance in modern usage.  The
mnemonics derive from teleprinter conventions that predate digital computers.

The module supplies the following functions, patterned on those in the standard
C library:


.. function:: isalnum(c)

   Checks for an ASCII alphanumeric character; it is equivalent to ``isalpha(c) or
   isdigit(c)``.


.. function:: isalpha(c)

   Checks for an ASCII alphabetic character; it is equivalent to ``isupper(c) or
   islower(c)``.


.. function:: isascii(c)

   Checks for a character value that fits in the 7-bit ASCII set.


.. function:: isblank(c)

   Checks for an ASCII whitespace character; space or horizontal tab.


.. function:: iscntrl(c)

   Checks for an ASCII control character (in the range 0x00 to 0x1f or 0x7f).


.. function:: isdigit(c)

   Checks for an ASCII decimal digit, ``'0'`` through ``'9'``.  This is equivalent
   to ``c in string.digits``.


.. function:: isgraph(c)

   Checks for ASCII any printable character except space.


.. function:: islower(c)

   Checks for an ASCII lower-case character.


.. function:: isprint(c)

   Checks for any ASCII printable character including space.


.. function:: ispunct(c)

   Checks for any printable ASCII character which is not a space or an alphanumeric
   character.


.. function:: isspace(c)

   Checks for ASCII white-space characters; space, line feed, carriage return, form
   feed, horizontal tab, vertical tab.


.. function:: isupper(c)

   Checks for an ASCII uppercase letter.


.. function:: isxdigit(c)

   Checks for an ASCII hexadecimal digit.  This is equivalent to ``c in
   string.hexdigits``.


.. function:: isctrl(c)

   Checks for an ASCII control character (ordinal values 0 to 31).


.. function:: ismeta(c)

   Checks for a non-ASCII character (ordinal values 0x80 and above).

These functions accept either integers or single-character strings; when the argument is a
string, it is first converted using the built-in function :func:`ord`.

Note that all these functions check ordinal bit values derived from the
character of the string you pass in; they do not actually know anything about
the host machine's character encoding.

The following two functions take either a single-character string or integer
byte value; they return a value of the same type.


.. function:: ascii(c)

   Return the ASCII value corresponding to the low 7 bits of *c*.


.. function:: ctrl(c)

   Return the control character corresponding to the given character (the character
   bit value is bitwise-anded with 0x1f).


.. function:: alt(c)

   Return the 8-bit character corresponding to the given ASCII character (the
   character bit value is bitwise-ored with 0x80).

The following function takes either a single-character string or integer value;
it returns a string.


.. index::
   single: ^ (caret); in curses module
   single: ! (exclamation); in curses module

.. function:: unctrl(c)

   Return a string representation of the ASCII character *c*.  If *c* is printable,
   this string is the character itself.  If the character is a control character
   (0x00--0x1f) the string consists of a caret (``'^'``) followed by the
   corresponding uppercase letter. If the character is an ASCII delete (0x7f) the
   string is ``'^?'``.  If the character has its meta bit (0x80) set, the meta bit
   is stripped, the preceding rules applied, and ``'!'`` prepended to the result.


.. data:: controlnames

   A 33-element string array that contains the ASCII mnemonics for the thirty-two
   ASCII control characters from 0 (NUL) to 0x1f (US), in order, plus the mnemonic
   ``SP`` for the space character.



================================================
File: /Doc/library/curses.panel.rst
================================================
:mod:`!curses.panel` --- A panel stack extension for curses
===========================================================

.. module:: curses.panel
   :synopsis: A panel stack extension that adds depth to  curses windows.

.. sectionauthor:: A.M. Kuchling <amk@amk.ca>

--------------

Panels are windows with the added feature of depth, so they can be stacked on
top of each other, and only the visible portions of each window will be
displayed.  Panels can be added, moved up or down in the stack, and removed.


.. _cursespanel-functions:

Functions
---------

The module :mod:`curses.panel` defines the following functions:


.. function:: bottom_panel()

   Returns the bottom panel in the panel stack.


.. function:: new_panel(win)

   Returns a panel object, associating it with the given window *win*. Be aware
   that you need to keep the returned panel object referenced explicitly.  If you
   don't, the panel object is garbage collected and removed from the panel stack.


.. function:: top_panel()

   Returns the top panel in the panel stack.


.. function:: update_panels()

   Updates the virtual screen after changes in the panel stack. This does not call
   :func:`curses.doupdate`, so you'll have to do this yourself.


.. _curses-panel-objects:

Panel Objects
-------------

Panel objects, as returned by :func:`new_panel` above, are windows with a
stacking order. There's always a window associated with a panel which determines
the content, while the panel methods are responsible for the window's depth in
the panel stack.

Panel objects have the following methods:


.. method:: Panel.above()

   Returns the panel above the current panel.


.. method:: Panel.below()

   Returns the panel below the current panel.


.. method:: Panel.bottom()

   Push the panel to the bottom of the stack.


.. method:: Panel.hidden()

   Returns ``True`` if the panel is hidden (not visible), ``False`` otherwise.


.. method:: Panel.hide()

   Hide the panel. This does not delete the object, it just makes the window on
   screen invisible.


.. method:: Panel.move(y, x)

   Move the panel to the screen coordinates ``(y, x)``.


.. method:: Panel.replace(win)

   Change the window associated with the panel to the window *win*.


.. method:: Panel.set_userptr(obj)

   Set the panel's user pointer to *obj*. This is used to associate an arbitrary
   piece of data with the panel, and can be any Python object.


.. method:: Panel.show()

   Display the panel (which might have been hidden).


.. method:: Panel.top()

   Push panel to the top of the stack.


.. method:: Panel.userptr()

   Returns the user pointer for the panel.  This might be any Python object.


.. method:: Panel.window()

   Returns the window object associated with the panel.



================================================
File: /Doc/library/custominterp.rst
================================================
.. _custominterp:

**************************
Custom Python Interpreters
**************************

The modules described in this chapter allow writing interfaces similar to
Python's interactive interpreter.  If you want a Python interpreter that
supports some special feature in addition to the Python language, you should
look at the :mod:`code` module.  (The :mod:`codeop` module is lower-level, used
to support compiling a possibly incomplete chunk of Python code.)

The full list of modules described in this chapter is:


.. toctree::

   code.rst
   codeop.rst


================================================
File: /Doc/library/dataclasses.rst
================================================
:mod:`!dataclasses` --- Data Classes
====================================

.. module:: dataclasses
    :synopsis: Generate special methods on user-defined classes.

.. moduleauthor:: Eric V. Smith <eric@trueblade.com>
.. sectionauthor:: Eric V. Smith <eric@trueblade.com>

**Source code:** :source:`Lib/dataclasses.py`

--------------

This module provides a decorator and functions for automatically
adding generated :term:`special methods <special method>` such as :meth:`~object.__init__` and
:meth:`~object.__repr__` to user-defined classes.  It was originally described
in :pep:`557`.

The member variables to use in these generated methods are defined
using :pep:`526` type annotations.  For example, this code::

  from dataclasses import dataclass

  @dataclass
  class InventoryItem:
      """Class for keeping track of an item in inventory."""
      name: str
      unit_price: float
      quantity_on_hand: int = 0

      def total_cost(self) -> float:
          return self.unit_price * self.quantity_on_hand

will add, among other things, a :meth:`!__init__` that looks like::

  def __init__(self, name: str, unit_price: float, quantity_on_hand: int = 0):
      self.name = name
      self.unit_price = unit_price
      self.quantity_on_hand = quantity_on_hand

Note that this method is automatically added to the class: it is not
directly specified in the :class:`!InventoryItem` definition shown above.

.. versionadded:: 3.7

Module contents
---------------

.. decorator:: dataclass(*, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False, weakref_slot=False)

   This function is a :term:`decorator` that is used to add generated
   :term:`special methods <special method>` to classes, as described below.

   The ``@dataclass`` decorator examines the class to find
   ``field``\s.  A ``field`` is defined as a class variable that has a
   :term:`type annotation <variable annotation>`.  With two
   exceptions described below, nothing in ``@dataclass``
   examines the type specified in the variable annotation.

   The order of the fields in all of the generated methods is the
   order in which they appear in the class definition.

   The ``@dataclass`` decorator will add various "dunder" methods to
   the class, described below.  If any of the added methods already
   exist in the class, the behavior depends on the parameter, as documented
   below. The decorator returns the same class that it is called on; no new
   class is created.

   If ``@dataclass`` is used just as a simple decorator with no parameters,
   it acts as if it has the default values documented in this
   signature.  That is, these three uses of ``@dataclass`` are
   equivalent::

     @dataclass
     class C:
         ...

     @dataclass()
     class C:
         ...

     @dataclass(init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False,
                match_args=True, kw_only=False, slots=False, weakref_slot=False)
     class C:
         ...

   The parameters to ``@dataclass`` are:

   - *init*: If true (the default), a :meth:`~object.__init__` method will be
     generated.

     If the class already defines :meth:`!__init__`, this parameter is
     ignored.

   - *repr*: If true (the default), a :meth:`~object.__repr__` method will be
     generated.  The generated repr string will have the class name and
     the name and repr of each field, in the order they are defined in
     the class.  Fields that are marked as being excluded from the repr
     are not included.  For example:
     ``InventoryItem(name='widget', unit_price=3.0, quantity_on_hand=10)``.

     If the class already defines :meth:`!__repr__`, this parameter is
     ignored.

   - *eq*: If true (the default), an :meth:`~object.__eq__` method will be
     generated.  This method compares the class as if it were a tuple
     of its fields, in order.  Both instances in the comparison must
     be of the identical type.

     If the class already defines :meth:`!__eq__`, this parameter is
     ignored.

   - *order*: If true (the default is ``False``), :meth:`~object.__lt__`,
     :meth:`~object.__le__`, :meth:`~object.__gt__`, and :meth:`~object.__ge__` methods will be
     generated.  These compare the class as if it were a tuple of its
     fields, in order.  Both instances in the comparison must be of the
     identical type.  If *order* is true and *eq* is false, a
     :exc:`ValueError` is raised.

     If the class already defines any of :meth:`!__lt__`,
     :meth:`!__le__`, :meth:`!__gt__`, or :meth:`!__ge__`, then
     :exc:`TypeError` is raised.

   - *unsafe_hash*: If ``False`` (the default), a :meth:`~object.__hash__` method
     is generated according to how *eq* and *frozen* are set.

     :meth:`!__hash__` is used by built-in :meth:`hash`, and when objects are
     added to hashed collections such as dictionaries and sets.  Having a
     :meth:`!__hash__` implies that instances of the class are immutable.
     Mutability is a complicated property that depends on the programmer's
     intent, the existence and behavior of :meth:`!__eq__`, and the values of
     the *eq* and *frozen* flags in the ``@dataclass`` decorator.

     By default, ``@dataclass`` will not implicitly add a :meth:`~object.__hash__`
     method unless it is safe to do so.  Neither will it add or change an
     existing explicitly defined :meth:`!__hash__` method.  Setting the class
     attribute ``__hash__ = None`` has a specific meaning to Python, as
     described in the :meth:`!__hash__` documentation.

     If :meth:`!__hash__` is not explicitly defined, or if it is set to ``None``,
     then ``@dataclass`` *may* add an implicit :meth:`!__hash__` method.
     Although not recommended, you can force ``@dataclass`` to create a
     :meth:`!__hash__` method with ``unsafe_hash=True``. This might be the case
     if your class is logically immutable but can still be mutated.
     This is a specialized use case and should be considered carefully.

     Here are the rules governing implicit creation of a :meth:`!__hash__`
     method.  Note that you cannot both have an explicit :meth:`!__hash__`
     method in your dataclass and set ``unsafe_hash=True``; this will result
     in a :exc:`TypeError`.

     If *eq* and *frozen* are both true, by default ``@dataclass`` will
     generate a :meth:`!__hash__` method for you.  If *eq* is true and
     *frozen* is false, :meth:`!__hash__` will be set to ``None``, marking it
     unhashable (which it is, since it is mutable).  If *eq* is false,
     :meth:`!__hash__` will be left untouched meaning the :meth:`!__hash__`
     method of the superclass will be used (if the superclass is
     :class:`object`, this means it will fall back to id-based hashing).

   - *frozen*: If true (the default is ``False``), assigning to fields will
     generate an exception.  This emulates read-only frozen instances.  If
     :meth:`~object.__setattr__` or :meth:`~object.__delattr__` is defined in the class, then
     :exc:`TypeError` is raised.  See the discussion below.

   - *match_args*: If true (the default is ``True``), the
     :attr:`~object.__match_args__` tuple will be created from the list of
     parameters to the generated :meth:`~object.__init__` method (even if
     :meth:`!__init__` is not generated, see above).  If false, or if
     :attr:`!__match_args__` is already defined in the class, then
     :attr:`!__match_args__` will not be generated.

    .. versionadded:: 3.10

   - *kw_only*: If true (the default value is ``False``), then all
     fields will be marked as keyword-only.  If a field is marked as
     keyword-only, then the only effect is that the :meth:`~object.__init__`
     parameter generated from a keyword-only field must be specified
     with a keyword when :meth:`!__init__` is called.  There is no
     effect on any other aspect of dataclasses.  See the
     :term:`parameter` glossary entry for details.  Also see the
     :const:`KW_ONLY` section.

    .. versionadded:: 3.10

   - *slots*: If true (the default is ``False``), :attr:`~object.__slots__` attribute
     will be generated and new class will be returned instead of the original one.
     If :attr:`!__slots__` is already defined in the class, then :exc:`TypeError`
     is raised.

    .. warning::
       Passing parameters to a base class :meth:`~object.__init_subclass__`
       when using ``slots=True`` will result in a :exc:`TypeError`.
       Either use ``__init_subclass__`` with no parameters
       or use default values as a workaround.
       See :gh:`91126` for full details.

    .. versionadded:: 3.10

    .. versionchanged:: 3.11
       If a field name is already included in the :attr:`!__slots__`
       of a base class, it will not be included in the generated :attr:`!__slots__`
       to prevent :ref:`overriding them <datamodel-note-slots>`.
       Therefore, do not use :attr:`!__slots__` to retrieve the field names of a
       dataclass. Use :func:`fields` instead.
       To be able to determine inherited slots,
       base class :attr:`!__slots__` may be any iterable, but *not* an iterator.


   - *weakref_slot*: If true (the default is ``False``), add a slot
     named "__weakref__", which is required to make an instance
     :func:`weakref-able <weakref.ref>`.
     It is an error to specify ``weakref_slot=True``
     without also specifying ``slots=True``.

    .. versionadded:: 3.11

   ``field``\s may optionally specify a default value, using normal
   Python syntax::

     @dataclass
     class C:
         a: int       # 'a' has no default value
         b: int = 0   # assign a default value for 'b'

   In this example, both :attr:`!a` and :attr:`!b` will be included in the added
   :meth:`~object.__init__` method, which will be defined as::

     def __init__(self, a: int, b: int = 0):

   :exc:`TypeError` will be raised if a field without a default value
   follows a field with a default value.  This is true whether this
   occurs in a single class, or as a result of class inheritance.

.. function:: field(*, default=MISSING, default_factory=MISSING, init=True, repr=True, hash=None, compare=True, metadata=None, kw_only=MISSING, doc=None)

   For common and simple use cases, no other functionality is
   required.  There are, however, some dataclass features that
   require additional per-field information.  To satisfy this need for
   additional information, you can replace the default field value
   with a call to the provided :func:`!field` function.  For example::

     @dataclass
     class C:
         mylist: list[int] = field(default_factory=list)

     c = C()
     c.mylist += [1, 2, 3]

   As shown above, the :const:`MISSING` value is a sentinel object used to
   detect if some parameters are provided by the user. This sentinel is
   used because ``None`` is a valid value for some parameters with
   a distinct meaning.  No code should directly use the :const:`MISSING` value.

   The parameters to :func:`!field` are:

   - *default*: If provided, this will be the default value for this
     field.  This is needed because the :func:`!field` call itself
     replaces the normal position of the default value.

   - *default_factory*: If provided, it must be a zero-argument
     callable that will be called when a default value is needed for
     this field.  Among other purposes, this can be used to specify
     fields with mutable default values, as discussed below.  It is an
     error to specify both *default* and *default_factory*.

   - *init*: If true (the default), this field is included as a
     parameter to the generated :meth:`~object.__init__` method.

   - *repr*: If true (the default), this field is included in the
     string returned by the generated :meth:`~object.__repr__` method.

   - *hash*: This can be a bool or ``None``.  If true, this field is
     included in the generated :meth:`~object.__hash__` method.  If ``None`` (the
     default), use the value of *compare*: this would normally be
     the expected behavior.  A field should be considered in the hash
     if it's used for comparisons.  Setting this value to anything
     other than ``None`` is discouraged.

     One possible reason to set ``hash=False`` but ``compare=True``
     would be if a field is expensive to compute a hash value for,
     that field is needed for equality testing, and there are other
     fields that contribute to the type's hash value.  Even if a field
     is excluded from the hash, it will still be used for comparisons.

   - *compare*: If true (the default), this field is included in the
     generated equality and comparison methods (:meth:`~object.__eq__`,
     :meth:`~object.__gt__`, et al.).

   - *metadata*: This can be a mapping or ``None``. ``None`` is treated as
     an empty dict.  This value is wrapped in
     :func:`~types.MappingProxyType` to make it read-only, and exposed
     on the :class:`Field` object. It is not used at all by Data
     Classes, and is provided as a third-party extension mechanism.
     Multiple third-parties can each have their own key, to use as a
     namespace in the metadata.

   - *kw_only*: If true, this field will be marked as keyword-only.
     This is used when the generated :meth:`~object.__init__` method's
     parameters are computed.

    .. versionadded:: 3.10

   - ``doc``: optional docstring for this field.

    .. versionadded:: 3.13

   If the default value of a field is specified by a call to
   :func:`!field`, then the class attribute for this field will be
   replaced by the specified *default* value.  If *default* is not
   provided, then the class attribute will be deleted.  The intent is
   that after the :func:`@dataclass <dataclass>` decorator runs, the class
   attributes will all contain the default values for the fields, just
   as if the default value itself were specified.  For example,
   after::

     @dataclass
     class C:
         x: int
         y: int = field(repr=False)
         z: int = field(repr=False, default=10)
         t: int = 20

   The class attribute :attr:`!C.z` will be ``10``, the class attribute
   :attr:`!C.t` will be ``20``, and the class attributes :attr:`!C.x` and
   :attr:`!C.y` will not be set.

.. class:: Field

   :class:`!Field` objects describe each defined field. These objects
   are created internally, and are returned by the :func:`fields`
   module-level method (see below).  Users should never instantiate a
   :class:`!Field` object directly.  Its documented attributes are:

   - :attr:`!name`: The name of the field.
   - :attr:`!type`: The type of the field.
   - :attr:`!default`, :attr:`!default_factory`, :attr:`!init`, :attr:`!repr`, :attr:`!hash`,
     :attr:`!compare`, :attr:`!metadata`, and :attr:`!kw_only` have the identical
     meaning and values as they do in the :func:`field` function.

   Other attributes may exist, but they are private and must not be
   inspected or relied on.

.. function:: fields(class_or_instance)

   Returns a tuple of :class:`Field` objects that define the fields for this
   dataclass.  Accepts either a dataclass, or an instance of a dataclass.
   Raises :exc:`TypeError` if not passed a dataclass or instance of one.
   Does not return pseudo-fields which are ``ClassVar`` or ``InitVar``.

.. function:: asdict(obj, *, dict_factory=dict)

   Converts the dataclass *obj* to a dict (by using the
   factory function *dict_factory*).  Each dataclass is converted
   to a dict of its fields, as ``name: value`` pairs.  dataclasses, dicts,
   lists, and tuples are recursed into.  Other objects are copied with
   :func:`copy.deepcopy`.

   Example of using :func:`!asdict` on nested dataclasses::

     @dataclass
     class Point:
          x: int
          y: int

     @dataclass
     class C:
          mylist: list[Point]

     p = Point(10, 20)
     assert asdict(p) == {'x': 10, 'y': 20}

     c = C([Point(0, 0), Point(10, 4)])
     assert asdict(c) == {'mylist': [{'x': 0, 'y': 0}, {'x': 10, 'y': 4}]}

   To create a shallow copy, the following workaround may be used::

     {field.name: getattr(obj, field.name) for field in fields(obj)}

   :func:`!asdict` raises :exc:`TypeError` if *obj* is not a dataclass
   instance.

.. function:: astuple(obj, *, tuple_factory=tuple)

   Converts the dataclass *obj* to a tuple (by using the
   factory function *tuple_factory*).  Each dataclass is converted
   to a tuple of its field values.  dataclasses, dicts, lists, and
   tuples are recursed into. Other objects are copied with
   :func:`copy.deepcopy`.

   Continuing from the previous example::

     assert astuple(p) == (10, 20)
     assert astuple(c) == ([(0, 0), (10, 4)],)

   To create a shallow copy, the following workaround may be used::

     tuple(getattr(obj, field.name) for field in dataclasses.fields(obj))

   :func:`!astuple` raises :exc:`TypeError` if *obj* is not a dataclass
   instance.

.. function:: make_dataclass(cls_name, fields, *, bases=(), namespace=None, init=True, repr=True, eq=True, order=False, unsafe_hash=False, frozen=False, match_args=True, kw_only=False, slots=False, weakref_slot=False, module=None, decorator=dataclass)

   Creates a new dataclass with name *cls_name*, fields as defined
   in *fields*, base classes as given in *bases*, and initialized
   with a namespace as given in *namespace*.  *fields* is an
   iterable whose elements are each either ``name``, ``(name, type)``,
   or ``(name, type, Field)``.  If just ``name`` is supplied,
   :data:`typing.Any` is used for ``type``.  The values of *init*,
   *repr*, *eq*, *order*, *unsafe_hash*, *frozen*,
   *match_args*, *kw_only*, *slots*, and *weakref_slot* have
   the same meaning as they do in :func:`@dataclass <dataclass>`.

   If *module* is defined, the :attr:`!__module__` attribute
   of the dataclass is set to that value.
   By default, it is set to the module name of the caller.

   The *decorator* parameter is a callable that will be used to create the dataclass.
   It should take the class object as a first argument and the same keyword arguments
   as :func:`@dataclass <dataclass>`. By default, the :func:`@dataclass <dataclass>`
   function is used.

   This function is not strictly required, because any Python
   mechanism for creating a new class with :attr:`!__annotations__` can
   then apply the :func:`@dataclass <dataclass>` function to convert that class to
   a dataclass.  This function is provided as a convenience.  For
   example::

     C = make_dataclass('C',
                        [('x', int),
                          'y',
                         ('z', int, field(default=5))],
                        namespace={'add_one': lambda self: self.x + 1})

   Is equivalent to::

     @dataclass
     class C:
         x: int
         y: 'typing.Any'
         z: int = 5

         def add_one(self):
             return self.x + 1

   .. versionadded:: 3.14
      Added the *decorator* parameter.

.. function:: replace(obj, /, **changes)

   Creates a new object of the same type as *obj*, replacing
   fields with values from *changes*.  If *obj* is not a Data
   Class, raises :exc:`TypeError`.  If keys in *changes* are not
   field names of the given dataclass, raises :exc:`TypeError`.

   The newly returned object is created by calling the :meth:`~object.__init__`
   method of the dataclass.  This ensures that
   :meth:`__post_init__`, if present, is also called.

   Init-only variables without default values, if any exist, must be
   specified on the call to :func:`!replace` so that they can be passed to
   :meth:`!__init__` and :meth:`__post_init__`.

   It is an error for *changes* to contain any fields that are
   defined as having ``init=False``.  A :exc:`ValueError` will be raised
   in this case.

   Be forewarned about how ``init=False`` fields work during a call to
   :func:`!replace`.  They are not copied from the source object, but
   rather are initialized in :meth:`__post_init__`, if they're
   initialized at all.  It is expected that ``init=False`` fields will
   be rarely and judiciously used.  If they are used, it might be wise
   to have alternate class constructors, or perhaps a custom
   :func:`!replace` (or similarly named) method which handles instance
   copying.

   Dataclass instances are also supported by generic function :func:`copy.replace`.

.. function:: is_dataclass(obj)

   Return ``True`` if its parameter is a dataclass (including subclasses of a
   dataclass) or an instance of one, otherwise return ``False``.

   If you need to know if a class is an instance of a dataclass (and
   not a dataclass itself), then add a further check for ``not
   isinstance(obj, type)``::

     def is_dataclass_instance(obj):
         return is_dataclass(obj) and not isinstance(obj, type)

.. data:: MISSING

   A sentinel value signifying a missing default or default_factory.

.. data:: KW_ONLY

   A sentinel value used as a type annotation.  Any fields after a
   pseudo-field with the type of :const:`!KW_ONLY` are marked as
   keyword-only fields.  Note that a pseudo-field of type
   :const:`!KW_ONLY` is otherwise completely ignored.  This includes the
   name of such a field.  By convention, a name of ``_`` is used for a
   :const:`!KW_ONLY` field.  Keyword-only fields signify
   :meth:`~object.__init__` parameters that must be specified as keywords when
   the class is instantiated.

   In this example, the fields ``y`` and ``z`` will be marked as keyword-only fields::

    @dataclass
    class Point:
        x: float
        _: KW_ONLY
        y: float
        z: float

    p = Point(0, y=1.5, z=2.0)

   In a single dataclass, it is an error to specify more than one
   field whose type is :const:`!KW_ONLY`.

   .. versionadded:: 3.10

.. exception:: FrozenInstanceError

   Raised when an implicitly defined :meth:`~object.__setattr__` or
   :meth:`~object.__delattr__` is called on a dataclass which was defined with
   ``frozen=True``. It is a subclass of :exc:`AttributeError`.

.. _post-init-processing:

Post-init processing
--------------------

.. function:: __post_init__()

   When defined on the class, it will be called by the generated
   :meth:`~object.__init__`, normally as :meth:`!self.__post_init__`.
   However, if any ``InitVar`` fields are defined, they will also be
   passed to :meth:`!__post_init__` in the order they were defined in the
   class.  If no :meth:`!__init__` method is generated, then
   :meth:`!__post_init__` will not automatically be called.

   Among other uses, this allows for initializing field values that
   depend on one or more other fields.  For example::

     @dataclass
     class C:
         a: float
         b: float
         c: float = field(init=False)

         def __post_init__(self):
             self.c = self.a + self.b

The :meth:`~object.__init__` method generated by :func:`@dataclass <dataclass>` does not call base
class :meth:`!__init__` methods. If the base class has an :meth:`!__init__` method
that has to be called, it is common to call this method in a
:meth:`__post_init__` method::

    class Rectangle:
        def __init__(self, height, width):
            self.height = height
            self.width = width

    @dataclass
    class Square(Rectangle):
        side: float

        def __post_init__(self):
            super().__init__(self.side, self.side)

Note, however, that in general the dataclass-generated :meth:`!__init__` methods
don't need to be called, since the derived dataclass will take care of
initializing all fields of any base class that is a dataclass itself.

See the section below on init-only variables for ways to pass
parameters to :meth:`!__post_init__`.  Also see the warning about how
:func:`replace` handles ``init=False`` fields.

.. _dataclasses-class-variables:

Class variables
---------------

One of the few places where :func:`@dataclass <dataclass>` actually inspects the type
of a field is to determine if a field is a class variable as defined
in :pep:`526`.  It does this by checking if the type of the field is
:data:`typing.ClassVar`.  If a field is a ``ClassVar``, it is excluded
from consideration as a field and is ignored by the dataclass
mechanisms.  Such ``ClassVar`` pseudo-fields are not returned by the
module-level :func:`fields` function.

.. _dataclasses-init-only-variables:

Init-only variables
-------------------

Another place where :func:`@dataclass <dataclass>` inspects a type annotation is to
determine if a field is an init-only variable.  It does this by seeing
if the type of a field is of type ``dataclasses.InitVar``.  If a field
is an ``InitVar``, it is considered a pseudo-field called an init-only
field.  As it is not a true field, it is not returned by the
module-level :func:`fields` function.  Init-only fields are added as
parameters to the generated :meth:`~object.__init__` method, and are passed to
the optional :meth:`__post_init__` method.  They are not otherwise used
by dataclasses.

For example, suppose a field will be initialized from a database, if a
value is not provided when creating the class::

  @dataclass
  class C:
      i: int
      j: int | None = None
      database: InitVar[DatabaseType | None] = None

      def __post_init__(self, database):
          if self.j is None and database is not None:
              self.j = database.lookup('j')

  c = C(10, database=my_database)

In this case, :func:`fields` will return :class:`Field` objects for :attr:`!i` and
:attr:`!j`, but not for :attr:`!database`.

.. _dataclasses-frozen:

Frozen instances
----------------

It is not possible to create truly immutable Python objects.  However,
by passing ``frozen=True`` to the :func:`@dataclass <dataclass>` decorator you can
emulate immutability.  In that case, dataclasses will add
:meth:`~object.__setattr__` and :meth:`~object.__delattr__` methods to the class.  These
methods will raise a :exc:`FrozenInstanceError` when invoked.

There is a tiny performance penalty when using ``frozen=True``:
:meth:`~object.__init__` cannot use simple assignment to initialize fields, and
must use :meth:`!object.__setattr__`.

.. Make sure to not remove "object" from "object.__setattr__" in the above markup!

.. _dataclasses-inheritance:

Inheritance
-----------

When the dataclass is being created by the :func:`@dataclass <dataclass>` decorator,
it looks through all of the class's base classes in reverse MRO (that
is, starting at :class:`object`) and, for each dataclass that it finds,
adds the fields from that base class to an ordered mapping of fields.
After all of the base class fields are added, it adds its own fields
to the ordered mapping.  All of the generated methods will use this
combined, calculated ordered mapping of fields.  Because the fields
are in insertion order, derived classes override base classes.  An
example::

  @dataclass
  class Base:
      x: Any = 15.0
      y: int = 0

  @dataclass
  class C(Base):
      z: int = 10
      x: int = 15

The final list of fields is, in order, :attr:`!x`, :attr:`!y`, :attr:`!z`.  The final
type of :attr:`!x` is :class:`int`, as specified in class :class:`!C`.

The generated :meth:`~object.__init__` method for :class:`!C` will look like::

  def __init__(self, x: int = 15, y: int = 0, z: int = 10):

Re-ordering of keyword-only parameters in :meth:`!__init__`
-----------------------------------------------------------

After the parameters needed for :meth:`~object.__init__` are computed, any
keyword-only parameters are moved to come after all regular
(non-keyword-only) parameters.  This is a requirement of how
keyword-only parameters are implemented in Python: they must come
after non-keyword-only parameters.

In this example, :attr:`!Base.y`, :attr:`!Base.w`, and :attr:`!D.t` are keyword-only
fields, and :attr:`!Base.x` and :attr:`!D.z` are regular fields::

  @dataclass
  class Base:
      x: Any = 15.0
      _: KW_ONLY
      y: int = 0
      w: int = 1

  @dataclass
  class D(Base):
      z: int = 10
      t: int = field(kw_only=True, default=0)

The generated :meth:`!__init__` method for :class:`!D` will look like::

  def __init__(self, x: Any = 15.0, z: int = 10, *, y: int = 0, w: int = 1, t: int = 0):

Note that the parameters have been re-ordered from how they appear in
the list of fields: parameters derived from regular fields are
followed by parameters derived from keyword-only fields.

The relative ordering of keyword-only parameters is maintained in the
re-ordered :meth:`!__init__` parameter list.


Default factory functions
-------------------------

If a :func:`field` specifies a *default_factory*, it is called with
zero arguments when a default value for the field is needed.  For
example, to create a new instance of a list, use::

  mylist: list = field(default_factory=list)

If a field is excluded from :meth:`~object.__init__` (using ``init=False``)
and the field also specifies *default_factory*, then the default
factory function will always be called from the generated
:meth:`!__init__` function.  This happens because there is no other
way to give the field an initial value.

Mutable default values
----------------------

Python stores default member variable values in class attributes.
Consider this example, not using dataclasses::

  class C:
      x = []
      def add(self, element):
          self.x.append(element)

  o1 = C()
  o2 = C()
  o1.add(1)
  o2.add(2)
  assert o1.x == [1, 2]
  assert o1.x is o2.x

Note that the two instances of class :class:`!C` share the same class
variable :attr:`!x`, as expected.

Using dataclasses, *if* this code was valid::

  @dataclass
  class D:
      x: list = []      # This code raises ValueError
      def add(self, element):
          self.x.append(element)

it would generate code similar to::

  class D:
      x = []
      def __init__(self, x=x):
          self.x = x
      def add(self, element):
          self.x.append(element)

  assert D().x is D().x

This has the same issue as the original example using class :class:`!C`.
That is, two instances of class :class:`!D` that do not specify a value
for :attr:`!x` when creating a class instance will share the same copy
of :attr:`!x`.  Because dataclasses just use normal Python class
creation they also share this behavior.  There is no general way
for Data Classes to detect this condition.  Instead, the
:func:`@dataclass <dataclass>` decorator will raise a :exc:`ValueError` if it
detects an unhashable default parameter.  The assumption is that if
a value is unhashable, it is mutable.  This is a partial solution,
but it does protect against many common errors.

Using default factory functions is a way to create new instances of
mutable types as default values for fields::

  @dataclass
  class D:
      x: list = field(default_factory=list)

  assert D().x is not D().x

.. versionchanged:: 3.11
   Instead of looking for and disallowing objects of type :class:`list`,
   :class:`dict`, or :class:`set`, unhashable objects are now not allowed as
   default values.  Unhashability is used to approximate
   mutability.

Descriptor-typed fields
-----------------------

Fields that are assigned :ref:`descriptor objects <descriptors>` as their
default value have the following special behaviors:

* The value for the field passed to the dataclass's :meth:`~object.__init__` method is
  passed to the descriptor's :meth:`~object.__set__` method rather than overwriting the
  descriptor object.

* Similarly, when getting or setting the field, the descriptor's
  :meth:`~object.__get__` or :meth:`!__set__` method is called rather than returning or
  overwriting the descriptor object.

* To determine whether a field contains a default value, :func:`@dataclass <dataclass>`
  will call the descriptor's :meth:`!__get__` method using its class access
  form: ``descriptor.__get__(obj=None, type=cls)``.  If the
  descriptor returns a value in this case, it will be used as the
  field's default. On the other hand, if the descriptor raises
  :exc:`AttributeError` in this situation, no default value will be
  provided for the field.

::

  class IntConversionDescriptor:
      def __init__(self, *, default):
          self._default = default

      def __set_name__(self, owner, name):
          self._name = "_" + name

      def __get__(self, obj, type):
          if obj is None:
              return self._default

          return getattr(obj, self._name, self._default)

      def __set__(self, obj, value):
          setattr(obj, self._name, int(value))

  @dataclass
  class InventoryItem:
      quantity_on_hand: IntConversionDescriptor = IntConversionDescriptor(default=100)

  i = InventoryItem()
  print(i.quantity_on_hand)   # 100
  i.quantity_on_hand = 2.5    # calls __set__ with 2.5
  print(i.quantity_on_hand)   # 2

Note that if a field is annotated with a descriptor type, but is not assigned
a descriptor object as its default value, the field will act like a normal
field.


================================================
File: /Doc/library/datatypes.rst
================================================
.. _datatypes:

**********
Data Types
**********

The modules described in this chapter provide a variety of specialized data
types such as dates and times, fixed-type arrays, heap queues, double-ended
queues, and enumerations.

Python also provides some built-in data types, in particular,
:class:`dict`, :class:`list`, :class:`set` and :class:`frozenset`, and
:class:`tuple`.  The :class:`str` class is used to hold
Unicode strings, and the :class:`bytes` and :class:`bytearray` classes are used
to hold binary data.

The following modules are documented in this chapter:


.. toctree::

   datetime.rst
   zoneinfo.rst
   calendar.rst
   collections.rst
   collections.abc.rst
   heapq.rst
   bisect.rst
   array.rst
   weakref.rst
   types.rst
   copy.rst
   pprint.rst
   reprlib.rst
   enum.rst
   graphlib.rst


================================================
File: /Doc/library/dbm.rst
================================================
:mod:`!dbm` --- Interfaces to Unix "databases"
==============================================

.. module:: dbm
   :synopsis: Interfaces to various Unix "database" formats.

**Source code:** :source:`Lib/dbm/__init__.py`

--------------

:mod:`dbm` is a generic interface to variants of the DBM database:

* :mod:`dbm.sqlite3`
* :mod:`dbm.gnu`
* :mod:`dbm.ndbm`

If none of these modules are installed, the
slow-but-simple implementation in module :mod:`dbm.dumb` will be used.  There
is a `third party interface <https://www.jcea.es/programacion/pybsddb.htm>`_ to
the Oracle Berkeley DB.

.. exception:: error

   A tuple containing the exceptions that can be raised by each of the supported
   modules, with a unique exception also named :exc:`dbm.error` as the first
   item --- the latter is used when :exc:`dbm.error` is raised.


.. function:: whichdb(filename)

   This function attempts to guess which of the several simple database modules
   available --- :mod:`dbm.sqlite3`, :mod:`dbm.gnu`, :mod:`dbm.ndbm`,
   or :mod:`dbm.dumb` --- should be used to open a given file.

   Return one of the following values:

   * ``None`` if the file can't be opened because it's unreadable or doesn't exist
   * the empty string (``''``) if the file's format can't be guessed
   * a string containing the required module name, such as ``'dbm.ndbm'`` or ``'dbm.gnu'``

   .. versionchanged:: 3.11
      *filename* accepts a :term:`path-like object`.

.. Substitutions for the open() flag param docs;
   all submodules use the same text.

.. |flag_r| replace::
   Open existing database for reading only.

.. |flag_w| replace::
   Open existing database for reading and writing.

.. |flag_c| replace::
   Open database for reading and writing, creating it if it doesn't exist.

.. |flag_n| replace::
   Always create a new, empty database, open for reading and writing.

.. |mode_param_doc| replace::
   The Unix file access mode of the file (default: octal ``0o666``),
   used only when the database has to be created.

.. function:: open(file, flag='r', mode=0o666)

   Open a database and return the corresponding database object.

   :param file:
      The database file to open.

      If the database file already exists, the :func:`whichdb` function is used to
      determine its type and the appropriate module is used; if it does not exist,
      the first submodule listed above that can be imported is used.
   :type file: :term:`path-like object`

   :param str flag:
      * ``'r'`` (default): |flag_r|
      * ``'w'``: |flag_w|
      * ``'c'``: |flag_c|
      * ``'n'``: |flag_n|

   :param int mode:
      |mode_param_doc|

   .. versionchanged:: 3.11
      *file* accepts a :term:`path-like object`.

The object returned by :func:`~dbm.open` supports the same basic functionality as a
:class:`dict`; keys and their corresponding values can be stored, retrieved, and
deleted, and the :keyword:`in` operator and the :meth:`!keys` method are
available, as well as :meth:`!get` and :meth:`!setdefault` methods.

Key and values are always stored as :class:`bytes`. This means that when
strings are used they are implicitly converted to the default encoding before
being stored.

These objects also support being used in a :keyword:`with` statement, which
will automatically close them when done.

.. versionchanged:: 3.2
   :meth:`!get` and :meth:`!setdefault` methods are now available for all
   :mod:`dbm` backends.

.. versionchanged:: 3.4
   Added native support for the context management protocol to the objects
   returned by :func:`~dbm.open`.

.. versionchanged:: 3.8
   Deleting a key from a read-only database raises a database module specific exception
   instead of :exc:`KeyError`.

The following example records some hostnames and a corresponding title,  and
then prints out the contents of the database::

   import dbm

   # Open database, creating it if necessary.
   with dbm.open('cache', 'c') as db:

       # Record some values
       db[b'hello'] = b'there'
       db['www.python.org'] = 'Python Website'
       db['www.cnn.com'] = 'Cable News Network'

       # Note that the keys are considered bytes now.
       assert db[b'www.python.org'] == b'Python Website'
       # Notice how the value is now in bytes.
       assert db['www.cnn.com'] == b'Cable News Network'

       # Often-used methods of the dict interface work too.
       print(db.get('python.org', b'not present'))

       # Storing a non-string key or value will raise an exception (most
       # likely a TypeError).
       db['www.yahoo.com'] = 4

   # db is automatically closed when leaving the with statement.


.. seealso::

   Module :mod:`shelve`
      Persistence module which stores non-string data.


The individual submodules are described in the following sections.

:mod:`dbm.sqlite3` --- SQLite backend for dbm
---------------------------------------------

.. module:: dbm.sqlite3
   :platform: All
   :synopsis: SQLite backend for dbm

.. versionadded:: 3.13

**Source code:** :source:`Lib/dbm/sqlite3.py`

--------------

This module uses the standard library :mod:`sqlite3` module to provide an
SQLite backend for the :mod:`dbm` module.
The files created by :mod:`dbm.sqlite3` can thus be opened by :mod:`sqlite3`,
or any other SQLite browser, including the SQLite CLI.

.. include:: ../includes/wasm-notavail.rst

.. function:: open(filename, /, flag="r", mode=0o666)

   Open an SQLite database.
   The returned object behaves like a :term:`mapping`,
   implements a :meth:`!close` method,
   and supports a "closing" context manager via the :keyword:`with` keyword.

   :param filename:
      The path to the database to be opened.
   :type filename: :term:`path-like object`

   :param str flag:

      * ``'r'`` (default): |flag_r|
      * ``'w'``: |flag_w|
      * ``'c'``: |flag_c|
      * ``'n'``: |flag_n|

   :param mode:
      The Unix file access mode of the file (default: octal ``0o666``),
      used only when the database has to be created.


:mod:`dbm.gnu` --- GNU database manager
---------------------------------------

.. module:: dbm.gnu
   :platform: Unix
   :synopsis: GNU database manager

**Source code:** :source:`Lib/dbm/gnu.py`

--------------

The :mod:`dbm.gnu` module provides an interface to the :abbr:`GDBM (GNU dbm)`
library, similar to the :mod:`dbm.ndbm` module, but with additional
functionality like crash tolerance.

.. note::

   The file formats created by :mod:`dbm.gnu` and :mod:`dbm.ndbm` are incompatible
   and can not be used interchangeably.

.. include:: ../includes/wasm-mobile-notavail.rst

.. exception:: error

   Raised on :mod:`dbm.gnu`-specific errors, such as I/O errors. :exc:`KeyError` is
   raised for general mapping errors like specifying an incorrect key.


.. function:: open(filename, flag="r", mode=0o666, /)

   Open a GDBM database and return a :class:`!gdbm` object.

   :param filename:
      The database file to open.
   :type filename: :term:`path-like object`

   :param str flag:
      * ``'r'`` (default): |flag_r|
      * ``'w'``: |flag_w|
      * ``'c'``: |flag_c|
      * ``'n'``: |flag_n|

      The following additional characters may be appended
      to control how the database is opened:

      * ``'f'``: Open the database in fast mode.
        Writes to the database will not be synchronized.
      * ``'s'``: Synchronized mode.
        Changes to the database will be written immediately to the file.
      * ``'u'``: Do not lock database.

      Not all flags are valid for all versions of GDBM.
      See the :data:`open_flags` member for a list of supported flag characters.

   :param int mode:
      |mode_param_doc|

   :raises error:
      If an invalid *flag* argument is passed.

   .. versionchanged:: 3.11
      *filename* accepts a :term:`path-like object`.

   .. data:: open_flags

      A string of characters the *flag* parameter of :meth:`~dbm.gnu.open` supports.

   :class:`!gdbm` objects behave similar to :term:`mappings <mapping>`,
   but :meth:`!items` and :meth:`!values` methods are not supported.
   The following methods are also provided:

   .. method:: gdbm.firstkey()

      It's possible to loop over every key in the database using this method  and the
      :meth:`nextkey` method.  The traversal is ordered by GDBM's internal
      hash values, and won't be sorted by the key values.  This method returns
      the starting key.

   .. method:: gdbm.nextkey(key)

      Returns the key that follows *key* in the traversal.  The following code prints
      every key in the database ``db``, without having to create a list in memory that
      contains them all::

         k = db.firstkey()
         while k is not None:
             print(k)
             k = db.nextkey(k)

   .. method:: gdbm.reorganize()

      If you have carried out a lot of deletions and would like to shrink the space
      used by the GDBM file, this routine will reorganize the database.  :class:`!gdbm`
      objects will not shorten the length of a database file except by using this
      reorganization; otherwise, deleted file space will be kept and reused as new
      (key, value) pairs are added.

   .. method:: gdbm.sync()

      When the database has been opened in fast mode, this method forces any
      unwritten data to be written to the disk.

   .. method:: gdbm.close()

      Close the GDBM database.

   .. method:: gdbm.clear()

      Remove all items from the GDBM database.

      .. versionadded:: 3.13


:mod:`dbm.ndbm` --- New Database Manager
----------------------------------------

.. module:: dbm.ndbm
   :platform: Unix
   :synopsis: The New Database Manager

**Source code:** :source:`Lib/dbm/ndbm.py`

--------------

The :mod:`dbm.ndbm` module provides an interface to the
:abbr:`NDBM (New Database Manager)` library.
This module can be used with the "classic" NDBM interface or the
:abbr:`GDBM (GNU dbm)` compatibility interface.

.. note::

   The file formats created by :mod:`dbm.gnu` and :mod:`dbm.ndbm` are incompatible
   and can not be used interchangeably.

.. warning::

   The NDBM library shipped as part of macOS has an undocumented limitation on the
   size of values, which can result in corrupted database files
   when storing values larger than this limit. Reading such corrupted files can
   result in a hard crash (segmentation fault).

.. include:: ../includes/wasm-mobile-notavail.rst

.. exception:: error

   Raised on :mod:`dbm.ndbm`-specific errors, such as I/O errors. :exc:`KeyError` is raised
   for general mapping errors like specifying an incorrect key.


.. data:: library

   Name of the NDBM implementation library used.


.. function:: open(filename, flag="r", mode=0o666, /)

   Open an NDBM database and return an :class:`!ndbm` object.

   :param filename:
      The basename of the database file
      (without the :file:`.dir` or :file:`.pag` extensions).
   :type filename: :term:`path-like object`

   :param str flag:
      * ``'r'`` (default): |flag_r|
      * ``'w'``: |flag_w|
      * ``'c'``: |flag_c|
      * ``'n'``: |flag_n|

   :param int mode:
      |mode_param_doc|

   :class:`!ndbm` objects behave similar to :term:`mappings <mapping>`,
   but :meth:`!items` and :meth:`!values` methods are not supported.
   The following methods are also provided:

   .. versionchanged:: 3.11
      Accepts :term:`path-like object` for filename.

   .. method:: ndbm.close()

      Close the NDBM database.

   .. method:: ndbm.clear()

      Remove all items from the NDBM database.

      .. versionadded:: 3.13


:mod:`dbm.dumb` --- Portable DBM implementation
-----------------------------------------------

.. module:: dbm.dumb
   :synopsis: Portable implementation of the simple DBM interface.

**Source code:** :source:`Lib/dbm/dumb.py`

.. index:: single: databases

.. note::

   The :mod:`dbm.dumb` module is intended as a last resort fallback for the
   :mod:`dbm` module when a more robust module is not available. The :mod:`dbm.dumb`
   module is not written for speed and is not nearly as heavily used as the other
   database modules.

--------------

The :mod:`dbm.dumb` module provides a persistent :class:`dict`-like
interface which is written entirely in Python.
Unlike other :mod:`dbm` backends, such as :mod:`dbm.gnu`, no
external library is required.

The :mod:`!dbm.dumb` module defines the following:

.. exception:: error

   Raised on :mod:`dbm.dumb`-specific errors, such as I/O errors.  :exc:`KeyError` is
   raised for general mapping errors like specifying an incorrect key.


.. function:: open(filename, flag="c", mode=0o666)

   Open a :mod:`!dbm.dumb` database.
   The returned database object behaves similar to a :term:`mapping`,
   in addition to providing :meth:`~dumbdbm.sync` and :meth:`~dumbdbm.close`
   methods.

   :param filename:
      The basename of the database file (without extensions).
      A new database creates the following files:

      - :file:`{filename}.dat`
      - :file:`{filename}.dir`
   :type database: :term:`path-like object`

   :param str flag:
      * ``'r'``: |flag_r|
      * ``'w'``: |flag_w|
      * ``'c'`` (default): |flag_c|
      * ``'n'``: |flag_n|

   :param int mode:
      |mode_param_doc|

   .. warning::
      It is possible to crash the Python interpreter when loading a database
      with a sufficiently large/complex entry due to stack depth limitations in
      Python's AST compiler.

   .. versionchanged:: 3.5
      :func:`~dbm.dumb.open` always creates a new database when *flag* is ``'n'``.

   .. versionchanged:: 3.8
      A database opened read-only if *flag* is ``'r'``.
      A database is not created if it does not exist if *flag* is ``'r'`` or ``'w'``.

   .. versionchanged:: 3.11
      *filename* accepts a :term:`path-like object`.

   In addition to the methods provided by the
   :class:`collections.abc.MutableMapping` class,
   the following methods are provided:

   .. method:: dumbdbm.sync()

      Synchronize the on-disk directory and data files.  This method is called
      by the :meth:`Shelve.sync` method.

   .. method:: dumbdbm.close()

      Close the database.


================================================
File: /Doc/library/debug.rst
================================================
***********************
Debugging and Profiling
***********************

These libraries help you with Python development: the debugger enables you to
step through code, analyze stack frames and set breakpoints etc., and the
profilers run code and give you a detailed breakdown of execution times,
allowing you to identify bottlenecks in your programs. Auditing events
provide visibility into runtime behaviors that would otherwise require
intrusive debugging or patching.

.. toctree::

   audit_events.rst
   bdb.rst
   faulthandler.rst
   pdb.rst
   profile.rst
   timeit.rst
   trace.rst
   tracemalloc.rst


================================================
File: /Doc/library/development.rst
================================================
.. _development:

*****************
Development Tools
*****************

The modules described in this chapter help you write software.  For example, the
:mod:`pydoc` module takes a module and generates documentation based on the
module's contents.  The :mod:`doctest` and :mod:`unittest` modules contains
frameworks for writing unit tests that automatically exercise code and verify
that the expected output is produced.

The list of modules described in this chapter is:


.. toctree::

   typing.rst
   pydoc.rst
   devmode.rst
   doctest.rst
   unittest.rst
   unittest.mock.rst
   unittest.mock-examples.rst
   test.rst


================================================
File: /Doc/library/devmode.rst
================================================
.. _devmode:

Python Development Mode
=======================

.. versionadded:: 3.7

The Python Development Mode introduces additional runtime checks that are too
expensive to be enabled by default. It should not be more verbose than the
default if the code is correct; new warnings are only emitted when an issue is
detected.

It can be enabled using the :option:`-X dev <-X>` command line option or by
setting the :envvar:`PYTHONDEVMODE` environment variable to ``1``.

See also :ref:`Python debug build <debug-build>`.

Effects of the Python Development Mode
--------------------------------------

Enabling the Python Development Mode is similar to the following command, but
with additional effects described below::

    PYTHONMALLOC=debug PYTHONASYNCIODEBUG=1 python -W default -X faulthandler

Effects of the Python Development Mode:

* Add ``default`` :ref:`warning filter <describing-warning-filters>`. The
  following warnings are shown:

  * :exc:`DeprecationWarning`
  * :exc:`ImportWarning`
  * :exc:`PendingDeprecationWarning`
  * :exc:`ResourceWarning`

  Normally, the above warnings are filtered by the default :ref:`warning
  filters <describing-warning-filters>`.

  It behaves as if the :option:`-W default <-W>` command line option is used.

  Use the :option:`-W error <-W>` command line option or set the
  :envvar:`PYTHONWARNINGS` environment variable to ``error`` to treat warnings
  as errors.

* Install debug hooks on memory allocators to check for:

  * Buffer underflow
  * Buffer overflow
  * Memory allocator API violation
  * Unsafe usage of the GIL

  See the :c:func:`PyMem_SetupDebugHooks` C function.

  It behaves as if the :envvar:`PYTHONMALLOC` environment variable is set to
  ``debug``.

  To enable the Python Development Mode without installing debug hooks on
  memory allocators, set the :envvar:`PYTHONMALLOC` environment variable to
  ``default``.

* Call :func:`faulthandler.enable` at Python startup to install handlers for
  the :const:`~signal.SIGSEGV`, :const:`~signal.SIGFPE`,
  :const:`~signal.SIGABRT`, :const:`~signal.SIGBUS` and
  :const:`~signal.SIGILL` signals to dump the Python traceback on a crash.

  It behaves as if the :option:`-X faulthandler <-X>` command line option is
  used or if the :envvar:`PYTHONFAULTHANDLER` environment variable is set to
  ``1``.

* Enable :ref:`asyncio debug mode <asyncio-debug-mode>`. For example,
  :mod:`asyncio` checks for coroutines that were not awaited and logs them.

  It behaves as if the :envvar:`PYTHONASYNCIODEBUG` environment variable is set
  to ``1``.

* Check the *encoding* and *errors* arguments for string encoding and decoding
  operations. Examples: :func:`open`, :meth:`str.encode` and
  :meth:`bytes.decode`.

  By default, for best performance, the *errors* argument is only checked at
  the first encoding/decoding error and the *encoding* argument is sometimes
  ignored for empty strings.

* The :class:`io.IOBase` destructor logs ``close()`` exceptions.
* Set the :attr:`~sys.flags.dev_mode` attribute of :data:`sys.flags` to
  ``True``.

The Python Development Mode does not enable the :mod:`tracemalloc` module by
default, because the overhead cost (to performance and memory) would be too
large. Enabling the :mod:`tracemalloc` module provides additional information
on the origin of some errors. For example, :exc:`ResourceWarning` logs the
traceback where the resource was allocated, and a buffer overflow error logs
the traceback where the memory block was allocated.

The Python Development Mode does not prevent the :option:`-O` command line
option from removing :keyword:`assert` statements nor from setting
:const:`__debug__` to ``False``.

The Python Development Mode can only be enabled at the Python startup. Its
value can be read from :data:`sys.flags.dev_mode <sys.flags>`.

.. versionchanged:: 3.8
   The :class:`io.IOBase` destructor now logs ``close()`` exceptions.

.. versionchanged:: 3.9
   The *encoding* and *errors* arguments are now checked for string encoding
   and decoding operations.


ResourceWarning Example
-----------------------

Example of a script counting the number of lines of the text file specified in
the command line::

    import sys

    def main():
        fp = open(sys.argv[1])
        nlines = len(fp.readlines())
        print(nlines)
        # The file is closed implicitly

    if __name__ == "__main__":
        main()

The script does not close the file explicitly. By default, Python does not emit
any warning. Example using README.txt, which has 269 lines:

.. code-block:: shell-session

    $ python script.py README.txt
    269

Enabling the Python Development Mode displays a :exc:`ResourceWarning` warning:

.. code-block:: shell-session

    $ python -X dev script.py README.txt
    269
    script.py:10: ResourceWarning: unclosed file <_io.TextIOWrapper name='README.rst' mode='r' encoding='UTF-8'>
      main()
    ResourceWarning: Enable tracemalloc to get the object allocation traceback

In addition, enabling :mod:`tracemalloc` shows the line where the file was
opened:

.. code-block:: shell-session

    $ python -X dev -X tracemalloc=5 script.py README.rst
    269
    script.py:10: ResourceWarning: unclosed file <_io.TextIOWrapper name='README.rst' mode='r' encoding='UTF-8'>
      main()
    Object allocated at (most recent call last):
      File "script.py", lineno 10
        main()
      File "script.py", lineno 4
        fp = open(sys.argv[1])

The fix is to close explicitly the file. Example using a context manager::

    def main():
        # Close the file explicitly when exiting the with block
        with open(sys.argv[1]) as fp:
            nlines = len(fp.readlines())
        print(nlines)

Not closing a resource explicitly can leave a resource open for way longer than
expected; it can cause severe issues upon exiting Python. It is bad in
CPython, but it is even worse in PyPy. Closing resources explicitly makes an
application more deterministic and more reliable.


Bad file descriptor error example
---------------------------------

Script displaying the first line of itself::

    import os

    def main():
        fp = open(__file__)
        firstline = fp.readline()
        print(firstline.rstrip())
        os.close(fp.fileno())
        # The file is closed implicitly

    main()

By default, Python does not emit any warning:

.. code-block:: shell-session

    $ python script.py
    import os

The Python Development Mode shows a :exc:`ResourceWarning` and logs a "Bad file
descriptor" error when finalizing the file object:

.. code-block:: shell-session

    $ python -X dev script.py
    import os
    script.py:10: ResourceWarning: unclosed file <_io.TextIOWrapper name='script.py' mode='r' encoding='UTF-8'>
      main()
    ResourceWarning: Enable tracemalloc to get the object allocation traceback
    Exception ignored in: <_io.TextIOWrapper name='script.py' mode='r' encoding='UTF-8'>
    Traceback (most recent call last):
      File "script.py", line 10, in <module>
        main()
    OSError: [Errno 9] Bad file descriptor

``os.close(fp.fileno())`` closes the file descriptor. When the file object
finalizer tries to close the file descriptor again, it fails with the ``Bad
file descriptor`` error. A file descriptor must be closed only once. In the
worst case scenario, closing it twice can lead to a crash (see :issue:`18748`
for an example).

The fix is to remove the ``os.close(fp.fileno())`` line, or open the file with
``closefd=False``.


================================================
File: /Doc/library/dialog.rst
================================================
Tkinter Dialogs
===============

:mod:`tkinter.simpledialog` --- Standard Tkinter input dialogs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. module:: tkinter.simpledialog
   :platform: Tk
   :synopsis: Simple dialog windows

**Source code:** :source:`Lib/tkinter/simpledialog.py`

--------------

The :mod:`tkinter.simpledialog` module contains convenience classes and
functions for creating simple modal dialogs to get a value from the user.


.. function:: askfloat(title, prompt, **kw)
              askinteger(title, prompt, **kw)
              askstring(title, prompt, **kw)

   The above three functions provide dialogs that prompt the user to enter a value
   of the desired type.

.. class:: Dialog(parent, title=None)

   The base class for custom dialogs.

   .. method:: body(master)

      Override to construct the dialog's interface and return the widget that
      should have initial focus.

   .. method:: buttonbox()

      Default behaviour adds OK and Cancel buttons. Override for custom button
      layouts.



:mod:`tkinter.filedialog` --- File selection dialogs
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. module:: tkinter.filedialog
   :platform: Tk
   :synopsis: Dialog classes for file selection

**Source code:** :source:`Lib/tkinter/filedialog.py`

--------------

The :mod:`tkinter.filedialog` module provides classes and factory functions for
creating file/directory selection windows.

Native Load/Save Dialogs
------------------------

The following classes and functions provide file dialog windows that combine a
native look-and-feel with configuration options to customize behaviour.
The following keyword arguments are applicable to the classes and functions
listed below:

 | *parent* - the window to place the dialog on top of

 | *title* - the title of the window

 | *initialdir* - the directory that the dialog starts in

 | *initialfile* - the file selected upon opening of the dialog

 | *filetypes* - a sequence of (label, pattern) tuples, '*' wildcard is allowed

 | *defaultextension* - default extension to append to file (save dialogs)

 | *multiple* - when true, selection of multiple items is allowed


**Static factory functions**

The below functions when called create a modal, native look-and-feel dialog,
wait for the user's selection, then return the selected value(s) or ``None`` to the
caller.

.. function:: askopenfile(mode="r", **options)
              askopenfiles(mode="r", **options)

   The above two functions create an :class:`Open` dialog and return the opened
   file object(s) in read-only mode.

.. function:: asksaveasfile(mode="w", **options)

   Create a :class:`SaveAs` dialog and return a file object opened in write-only mode.

.. function:: askopenfilename(**options)
              askopenfilenames(**options)

   The above two functions create an :class:`Open` dialog and return the
   selected filename(s) that correspond to existing file(s).

.. function:: asksaveasfilename(**options)

   Create a :class:`SaveAs` dialog and return the selected filename.

.. function:: askdirectory(**options)

 | Prompt user to select a directory.
 | Additional keyword option:
 |  *mustexist* - determines if selection must be an existing directory.

.. class:: Open(master=None, **options)
           SaveAs(master=None, **options)

   The above two classes provide native dialog windows for saving and loading
   files.

**Convenience classes**

The below classes are used for creating file/directory windows from scratch.
These do not emulate the native look-and-feel of the platform.

.. class:: Directory(master=None, **options)

   Create a dialog prompting the user to select a directory.

.. note::  The *FileDialog* class should be subclassed for custom event
   handling and behaviour.

.. class:: FileDialog(master, title=None)

   Create a basic file selection dialog.

   .. method:: cancel_command(event=None)

      Trigger the termination of the dialog window.

   .. method:: dirs_double_event(event)

      Event handler for double-click event on directory.

   .. method:: dirs_select_event(event)

      Event handler for click event on directory.

   .. method:: files_double_event(event)

      Event handler for double-click event on file.

   .. method:: files_select_event(event)

      Event handler for single-click event on file.

   .. method:: filter_command(event=None)

      Filter the files by directory.

   .. method:: get_filter()

      Retrieve the file filter currently in use.

   .. method:: get_selection()

      Retrieve the currently selected item.

   .. method:: go(dir_or_file=os.curdir, pattern="*", default="", key=None)

      Render dialog and start event loop.

   .. method:: ok_event(event)

      Exit dialog returning current selection.

   .. method:: quit(how=None)

      Exit dialog returning filename, if any.

   .. method:: set_filter(dir, pat)

      Set the file filter.

   .. method:: set_selection(file)

      Update the current file selection to *file*.


.. class:: LoadFileDialog(master, title=None)

   A subclass of FileDialog that creates a dialog window for selecting an
   existing file.

   .. method:: ok_command()

      Test that a file is provided and that the selection indicates an
      already existing file.

.. class:: SaveFileDialog(master, title=None)

   A subclass of FileDialog that creates a dialog window for selecting a
   destination file.

   .. method:: ok_command()

      Test whether or not the selection points to a valid file that is not a
      directory. Confirmation is required if an already existing file is
      selected.

:mod:`tkinter.commondialog` --- Dialog window templates
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

.. module:: tkinter.commondialog
   :platform: Tk
   :synopsis: Tkinter base class for dialogs

**Source code:** :source:`Lib/tkinter/commondialog.py`

--------------

The :mod:`tkinter.commondialog` module provides the :class:`Dialog` class that
is the base class for dialogs defined in other supporting modules.

.. class:: Dialog(master=None, **options)

   .. method:: show(color=None, **options)

      Render the Dialog window.


.. seealso::

   Modules :mod:`tkinter.messagebox`, :ref:`tut-files`


================================================
File: /Doc/library/difflib.rst
================================================
:mod:`!difflib` --- Helpers for computing deltas
================================================

.. module:: difflib
   :synopsis: Helpers for computing differences between objects.

.. moduleauthor:: Tim Peters <tim_one@users.sourceforge.net>
.. sectionauthor:: Tim Peters <tim_one@users.sourceforge.net>
.. Markup by Fred L. Drake, Jr. <fdrake@acm.org>

**Source code:** :source:`Lib/difflib.py`

.. testsetup::

   import sys
   from difflib import *

--------------

This module provides classes and functions for comparing sequences. It
can be used for example, for comparing files, and can produce information
about file differences in various formats, including HTML and context and unified
diffs. For comparing directories and files, see also, the :mod:`filecmp` module.


.. class:: SequenceMatcher
   :noindex:

   This is a flexible class for comparing pairs of sequences of any type, so long
   as the sequence elements are :term:`hashable`.  The basic algorithm predates, and is a
   little fancier than, an algorithm published in the late 1980's by Ratcliff and
   Obershelp under the hyperbolic name "gestalt pattern matching."  The idea is to
   find the longest contiguous matching subsequence that contains no "junk"
   elements; these "junk" elements are ones that are uninteresting in some
   sense, such as blank lines or whitespace.  (Handling junk is an
   extension to the Ratcliff and Obershelp algorithm.) The same
   idea is then applied recursively to the pieces of the sequences to the left and
   to the right of the matching subsequence.  This does not yield minimal edit
   sequences, but does tend to yield matches that "look right" to people.

   **Timing:** The basic Ratcliff-Obershelp algorithm is cubic time in the worst
   case and quadratic time in the expected case. :class:`SequenceMatcher` is
   quadratic time for the worst case and has expected-case behavior dependent in a
   complicated way on how many elements the sequences have in common; best case
   time is linear.

   **Automatic junk heuristic:** :class:`SequenceMatcher` supports a heuristic that
   automatically treats certain sequence items as junk. The heuristic counts how many
   times each individual item appears in the sequence. If an item's duplicates (after
   the first one) account for more than 1% of the sequence and the sequence is at least
   200 items long, this item is marked as "popular" and is treated as junk for
   the purpose of sequence matching. This heuristic can be turned off by setting
   the ``autojunk`` argument to ``False`` when creating the :class:`SequenceMatcher`.

   .. versionchanged:: 3.2
      Added the *autojunk* parameter.


.. class:: Differ

   This is a class for comparing sequences of lines of text, and producing
   human-readable differences or deltas.  Differ uses :class:`SequenceMatcher`
   both to compare sequences of lines, and to compare sequences of characters
   within similar (near-matching) lines.

   Each line of a :class:`Differ` delta begins with a two-letter code:

   +----------+-------------------------------------------+
   | Code     | Meaning                                   |
   +==========+===========================================+
   | ``'- '`` | line unique to sequence 1                 |
   +----------+-------------------------------------------+
   | ``'+ '`` | line unique to sequence 2                 |
   +----------+-------------------------------------------+
   | ``'  '`` | line common to both sequences             |
   +----------+-------------------------------------------+
   | ``'? '`` | line not present in either input sequence |
   +----------+-------------------------------------------+

   Lines beginning with '``?``' attempt to guide the eye to intraline differences,
   and were not present in either input sequence. These lines can be confusing if
   the sequences contain whitespace characters, such as spaces, tabs or line breaks.


.. class:: HtmlDiff

   This class can be used to create an HTML table (or a complete HTML file
   containing the table) showing a side by side, line by line comparison of text
   with inter-line and intra-line change highlights.  The table can be generated in
   either full or contextual difference mode.

   The constructor for this class is:


   .. method:: __init__(tabsize=8, wrapcolumn=None, linejunk=None, charjunk=IS_CHARACTER_JUNK)

      Initializes instance of :class:`HtmlDiff`.

      *tabsize* is an optional keyword argument to specify tab stop spacing and
      defaults to ``8``.

      *wrapcolumn* is an optional keyword to specify column number where lines are
      broken and wrapped, defaults to ``None`` where lines are not wrapped.

      *linejunk* and *charjunk* are optional keyword arguments passed into :func:`ndiff`
      (used by :class:`HtmlDiff` to generate the side by side HTML differences).  See
      :func:`ndiff` documentation for argument default values and descriptions.

   The following methods are public:

   .. method:: make_file(fromlines, tolines, fromdesc='', todesc='', context=False, \
                         numlines=5, *, charset='utf-8')

      Compares *fromlines* and *tolines* (lists of strings) and returns a string which
      is a complete HTML file containing a table showing line by line differences with
      inter-line and intra-line changes highlighted.

      *fromdesc* and *todesc* are optional keyword arguments to specify from/to file
      column header strings (both default to an empty string).

      *context* and *numlines* are both optional keyword arguments. Set *context* to
      ``True`` when contextual differences are to be shown, else the default is
      ``False`` to show the full files. *numlines* defaults to ``5``.  When *context*
      is ``True`` *numlines* controls the number of context lines which surround the
      difference highlights.  When *context* is ``False`` *numlines* controls the
      number of lines which are shown before a difference highlight when using the
      "next" hyperlinks (setting to zero would cause the "next" hyperlinks to place
      the next difference highlight at the top of the browser without any leading
      context).

      .. note::
         *fromdesc* and *todesc* are interpreted as unescaped HTML and should be
         properly escaped while receiving input from untrusted sources.

      .. versionchanged:: 3.5
         *charset* keyword-only argument was added.  The default charset of
         HTML document changed from ``'ISO-8859-1'`` to ``'utf-8'``.

   .. method:: make_table(fromlines, tolines, fromdesc='', todesc='', context=False, numlines=5)

      Compares *fromlines* and *tolines* (lists of strings) and returns a string which
      is a complete HTML table showing line by line differences with inter-line and
      intra-line changes highlighted.

      The arguments for this method are the same as those for the :meth:`make_file`
      method.



.. function:: context_diff(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\n')

   Compare *a* and *b* (lists of strings); return a delta (a :term:`generator`
   generating the delta lines) in context diff format.

   Context diffs are a compact way of showing just the lines that have changed plus
   a few lines of context.  The changes are shown in a before/after style.  The
   number of context lines is set by *n* which defaults to three.

   By default, the diff control lines (those with ``***`` or ``---``) are created
   with a trailing newline.  This is helpful so that inputs created from
   :func:`io.IOBase.readlines` result in diffs that are suitable for use with
   :func:`io.IOBase.writelines` since both the inputs and outputs have trailing
   newlines.

   For inputs that do not have trailing newlines, set the *lineterm* argument to
   ``""`` so that the output will be uniformly newline free.

   The context diff format normally has a header for filenames and modification
   times.  Any or all of these may be specified using strings for *fromfile*,
   *tofile*, *fromfiledate*, and *tofiledate*.  The modification times are normally
   expressed in the ISO 8601 format. If not specified, the
   strings default to blanks.

      >>> import sys
      >>> from difflib import *
      >>> s1 = ['bacon\n', 'eggs\n', 'ham\n', 'guido\n']
      >>> s2 = ['python\n', 'eggy\n', 'hamster\n', 'guido\n']
      >>> sys.stdout.writelines(context_diff(s1, s2, fromfile='before.py',
      ...                        tofile='after.py'))
      *** before.py
      --- after.py
      ***************
      *** 1,4 ****
      ! bacon
      ! eggs
      ! ham
        guido
      --- 1,4 ----
      ! python
      ! eggy
      ! hamster
        guido

   See :ref:`difflib-interface` for a more detailed example.


.. function:: get_close_matches(word, possibilities, n=3, cutoff=0.6)

   Return a list of the best "good enough" matches.  *word* is a sequence for which
   close matches are desired (typically a string), and *possibilities* is a list of
   sequences against which to match *word* (typically a list of strings).

   Optional argument *n* (default ``3``) is the maximum number of close matches to
   return; *n* must be greater than ``0``.

   Optional argument *cutoff* (default ``0.6``) is a float in the range [0, 1].
   Possibilities that don't score at least that similar to *word* are ignored.

   The best (no more than *n*) matches among the possibilities are returned in a
   list, sorted by similarity score, most similar first.

      >>> get_close_matches('appel', ['ape', 'apple', 'peach', 'puppy'])
      ['apple', 'ape']
      >>> import keyword
      >>> get_close_matches('wheel', keyword.kwlist)
      ['while']
      >>> get_close_matches('pineapple', keyword.kwlist)
      []
      >>> get_close_matches('accept', keyword.kwlist)
      ['except']


.. function:: ndiff(a, b, linejunk=None, charjunk=IS_CHARACTER_JUNK)

   Compare *a* and *b* (lists of strings); return a :class:`Differ`\ -style
   delta (a :term:`generator` generating the delta lines).

   Optional keyword parameters *linejunk* and *charjunk* are filtering functions
   (or ``None``):

   *linejunk*: A function that accepts a single string argument, and returns
   true if the string is junk, or false if not. The default is ``None``. There
   is also a module-level function :func:`IS_LINE_JUNK`, which filters out lines
   without visible characters, except for at most one pound character (``'#'``)
   -- however the underlying :class:`SequenceMatcher` class does a dynamic
   analysis of which lines are so frequent as to constitute noise, and this
   usually works better than using this function.

   *charjunk*: A function that accepts a character (a string of length 1), and
   returns if the character is junk, or false if not. The default is module-level
   function :func:`IS_CHARACTER_JUNK`, which filters out whitespace characters (a
   blank or tab; it's a bad idea to include newline in this!).

      >>> diff = ndiff('one\ntwo\nthree\n'.splitlines(keepends=True),
      ...              'ore\ntree\nemu\n'.splitlines(keepends=True))
      >>> print(''.join(diff), end="")
      - one
      ?  ^
      + ore
      ?  ^
      - two
      - three
      ?  -
      + tree
      + emu


.. function:: restore(sequence, which)

   Return one of the two sequences that generated a delta.

   Given a *sequence* produced by :meth:`Differ.compare` or :func:`ndiff`, extract
   lines originating from file 1 or 2 (parameter *which*), stripping off line
   prefixes.

   Example:

      >>> diff = ndiff('one\ntwo\nthree\n'.splitlines(keepends=True),
      ...              'ore\ntree\nemu\n'.splitlines(keepends=True))
      >>> diff = list(diff) # materialize the generated delta into a list
      >>> print(''.join(restore(diff, 1)), end="")
      one
      two
      three
      >>> print(''.join(restore(diff, 2)), end="")
      ore
      tree
      emu


.. function:: unified_diff(a, b, fromfile='', tofile='', fromfiledate='', tofiledate='', n=3, lineterm='\n')

   Compare *a* and *b* (lists of strings); return a delta (a :term:`generator`
   generating the delta lines) in unified diff format.

   Unified diffs are a compact way of showing just the lines that have changed plus
   a few lines of context.  The changes are shown in an inline style (instead of
   separate before/after blocks).  The number of context lines is set by *n* which
   defaults to three.

   By default, the diff control lines (those with ``---``, ``+++``, or ``@@``) are
   created with a trailing newline.  This is helpful so that inputs created from
   :func:`io.IOBase.readlines` result in diffs that are suitable for use with
   :func:`io.IOBase.writelines` since both the inputs and outputs have trailing
   newlines.

   For inputs that do not have trailing newlines, set the *lineterm* argument to
   ``""`` so that the output will be uniformly newline free.

   The unified diff format normally has a header for filenames and modification
   times.  Any or all of these may be specified using strings for *fromfile*,
   *tofile*, *fromfiledate*, and *tofiledate*.  The modification times are normally
   expressed in the ISO 8601 format. If not specified, the
   strings default to blanks.

      >>> s1 = ['bacon\n', 'eggs\n', 'ham\n', 'guido\n']
      >>> s2 = ['python\n', 'eggy\n', 'hamster\n', 'guido\n']
      >>> sys.stdout.writelines(unified_diff(s1, s2, fromfile='before.py', tofile='after.py'))
      --- before.py
      +++ after.py
      @@ -1,4 +1,4 @@
      -bacon
      -eggs
      -ham
      +python
      +eggy
      +hamster
       guido

   See :ref:`difflib-interface` for a more detailed example.

.. function:: diff_bytes(dfunc, a, b, fromfile=b'', tofile=b'', fromfiledate=b'', tofiledate=b'', n=3, lineterm=b'\n')

   Compare *a* and *b* (lists of bytes objects) using *dfunc*; yield a
   sequence of delta lines (also bytes) in the format returned by *dfunc*.
   *dfunc* must be a callable, typically either :func:`unified_diff` or
   :func:`context_diff`.

   Allows you to compare data with unknown or inconsistent encoding. All
   inputs except *n* must be bytes objects, not str. Works by losslessly
   converting all inputs (except *n*) to str, and calling ``dfunc(a, b,
   fromfile, tofile, fromfiledate, tofiledate, n, lineterm)``. The output of
   *dfunc* is then converted back to bytes, so the delta lines that you
   receive have the same unknown/inconsistent encodings as *a* and *b*.

   .. versionadded:: 3.5

.. function:: IS_LINE_JUNK(line)

   Return ``True`` for ignorable lines.  The line *line* is ignorable if *line* is
   blank or contains a single ``'#'``, otherwise it is not ignorable.  Used as a
   default for parameter *linejunk* in :func:`ndiff` in older versions.


.. function:: IS_CHARACTER_JUNK(ch)

   Return ``True`` for ignorable characters.  The character *ch* is ignorable if *ch*
   is a space or tab, otherwise it is not ignorable.  Used as a default for
   parameter *charjunk* in :func:`ndiff`.


.. seealso::

   `Pattern Matching: The Gestalt Approach <https://www.drdobbs.com/database/pattern-matching-the-gestalt-approach/184407970>`_
      Discussion of a similar algorithm by John W. Ratcliff and D. E. Metzener. This
      was published in `Dr. Dobb's Journal <https://www.drdobbs.com/>`_ in July, 1988.


.. _sequence-matcher:

SequenceMatcher Objects
-----------------------

The :class:`SequenceMatcher` class has this constructor:


.. class:: SequenceMatcher(isjunk=None, a='', b='', autojunk=True)

   Optional argument *isjunk* must be ``None`` (the default) or a one-argument
   function that takes a sequence element and returns true if and only if the
   element is "junk" and should be ignored. Passing ``None`` for *isjunk* is
   equivalent to passing ``lambda x: False``; in other words, no elements are ignored.
   For example, pass::

      lambda x: x in " \t"

   if you're comparing lines as sequences of characters, and don't want to synch up
   on blanks or hard tabs.

   The optional arguments *a* and *b* are sequences to be compared; both default to
   empty strings.  The elements of both sequences must be :term:`hashable`.

   The optional argument *autojunk* can be used to disable the automatic junk
   heuristic.

   .. versionchanged:: 3.2
      Added the *autojunk* parameter.

   SequenceMatcher objects get three data attributes: *bjunk* is the
   set of elements of *b* for which *isjunk* is ``True``; *bpopular* is the set of
   non-junk elements considered popular by the heuristic (if it is not
   disabled); *b2j* is a dict mapping the remaining elements of *b* to a list
   of positions where they occur. All three are reset whenever *b* is reset
   with :meth:`set_seqs` or :meth:`set_seq2`.

   .. versionadded:: 3.2
      The *bjunk* and *bpopular* attributes.

   :class:`SequenceMatcher` objects have the following methods:

   .. method:: set_seqs(a, b)

      Set the two sequences to be compared.

   :class:`SequenceMatcher` computes and caches detailed information about the
   second sequence, so if you want to compare one sequence against many
   sequences, use :meth:`set_seq2` to set the commonly used sequence once and
   call :meth:`set_seq1` repeatedly, once for each of the other sequences.


   .. method:: set_seq1(a)

      Set the first sequence to be compared.  The second sequence to be compared
      is not changed.


   .. method:: set_seq2(b)

      Set the second sequence to be compared.  The first sequence to be compared
      is not changed.


   .. method:: find_longest_match(alo=0, ahi=None, blo=0, bhi=None)

      Find longest matching block in ``a[alo:ahi]`` and ``b[blo:bhi]``.

      If *isjunk* was omitted or ``None``, :meth:`find_longest_match` returns
      ``(i, j, k)`` such that ``a[i:i+k]`` is equal to ``b[j:j+k]``, where ``alo
      <= i <= i+k <= ahi`` and ``blo <= j <= j+k <= bhi``. For all ``(i', j',
      k')`` meeting those conditions, the additional conditions ``k >= k'``, ``i
      <= i'``, and if ``i == i'``, ``j <= j'`` are also met. In other words, of
      all maximal matching blocks, return one that starts earliest in *a*, and
      of all those maximal matching blocks that start earliest in *a*, return
      the one that starts earliest in *b*.

         >>> s = SequenceMatcher(None, " abcd", "abcd abcd")
         >>> s.find_longest_match(0, 5, 0, 9)
         Match(a=0, b=4, size=5)

      If *isjunk* was provided, first the longest matching block is determined
      as above, but with the additional restriction that no junk element appears
      in the block.  Then that block is extended as far as possible by matching
      (only) junk elements on both sides. So the resulting block never matches
      on junk except as identical junk happens to be adjacent to an interesting
      match.

      Here's the same example as before, but considering blanks to be junk. That
      prevents ``' abcd'`` from matching the ``' abcd'`` at the tail end of the
      second sequence directly.  Instead only the ``'abcd'`` can match, and
      matches the leftmost ``'abcd'`` in the second sequence:

         >>> s = SequenceMatcher(lambda x: x==" ", " abcd", "abcd abcd")
         >>> s.find_longest_match(0, 5, 0, 9)
         Match(a=1, b=0, size=4)

      If no blocks match, this returns ``(alo, blo, 0)``.

      This method returns a :term:`named tuple` ``Match(a, b, size)``.

      .. versionchanged:: 3.9
         Added default arguments.


   .. method:: get_matching_blocks()

      Return list of triples describing non-overlapping matching subsequences.
      Each triple is of the form ``(i, j, n)``,
      and means that ``a[i:i+n] == b[j:j+n]``.  The
      triples are monotonically increasing in *i* and *j*.

      The last triple is a dummy, and has the value ``(len(a), len(b), 0)``.  It
      is the only triple with ``n == 0``.  If ``(i, j, n)`` and ``(i', j', n')``
      are adjacent triples in the list, and the second is not the last triple in
      the list, then ``i+n < i'`` or ``j+n < j'``; in other words, adjacent
      triples always describe non-adjacent equal blocks.

      .. XXX Explain why a dummy is used!

      .. doctest::

         >>> s = SequenceMatcher(None, "abxcd", "abcd")
         >>> s.get_matching_blocks()
         [Match(a=0, b=0, size=2), Match(a=3, b=2, size=2), Match(a=5, b=4, size=0)]


   .. method:: get_opcodes()

      Return list of 5-tuples describing how to turn *a* into *b*. Each tuple is
      of the form ``(tag, i1, i2, j1, j2)``.  The first tuple has ``i1 == j1 ==
      0``, and remaining tuples have *i1* equal to the *i2* from the preceding
      tuple, and, likewise, *j1* equal to the previous *j2*.

      The *tag* values are strings, with these meanings:

      +---------------+---------------------------------------------+
      | Value         | Meaning                                     |
      +===============+=============================================+
      | ``'replace'`` | ``a[i1:i2]`` should be replaced by          |
      |               | ``b[j1:j2]``.                               |
      +---------------+---------------------------------------------+
      | ``'delete'``  | ``a[i1:i2]`` should be deleted.  Note that  |
      |               | ``j1 == j2`` in this case.                  |
      +---------------+---------------------------------------------+
      | ``'insert'``  | ``b[j1:j2]`` should be inserted at          |
      |               | ``a[i1:i1]``. Note that ``i1 == i2`` in     |
      |               | this case.                                  |
      +---------------+---------------------------------------------+
      | ``'equal'``   | ``a[i1:i2] == b[j1:j2]`` (the sub-sequences |
      |               | are equal).                                 |
      +---------------+---------------------------------------------+

      For example::

        >>> a = "qabxcd"
        >>> b = "abycdf"
        >>> s = SequenceMatcher(None, a, b)
        >>> for tag, i1, i2, j1, j2 in s.get_opcodes():
        ...     print('{:7}   a[{}:{}] --> b[{}:{}] {!r:>8} --> {!r}'.format(
        ...         tag, i1, i2, j1, j2, a[i1:i2], b[j1:j2]))
        delete    a[0:1] --> b[0:0]      'q' --> ''
        equal     a[1:3] --> b[0:2]     'ab' --> 'ab'
        replace   a[3:4] --> b[2:3]      'x' --> 'y'
        equal     a[4:6] --> b[3:5]     'cd' --> 'cd'
        insert    a[6:6] --> b[5:6]       '' --> 'f'


   .. method:: get_grouped_opcodes(n=3)

      Return a :term:`generator` of groups with up to *n* lines of context.

      Starting with the groups returned by :meth:`get_opcodes`, this method
      splits out smaller change clusters and eliminates intervening ranges which
      have no changes.

      The groups are returned in the same format as :meth:`get_opcodes`.


   .. method:: ratio()

      Return a measure of the sequences' similarity as a float in the range [0,
      1].

      Where T is the total number of elements in both sequences, and M is the
      number of matches, this is 2.0\*M / T. Note that this is ``1.0`` if the
      sequences are identical, and ``0.0`` if they have nothing in common.

      This is expensive to compute if :meth:`get_matching_blocks` or
      :meth:`get_opcodes` hasn't already been called, in which case you may want
      to try :meth:`quick_ratio` or :meth:`real_quick_ratio` first to get an
      upper bound.

      .. note::

         Caution: The result of a :meth:`ratio` call may depend on the order of
         the arguments. For instance::

            >>> SequenceMatcher(None, 'tide', 'diet').ratio()
            0.25
            >>> SequenceMatcher(None, 'diet', 'tide').ratio()
            0.5


   .. method:: quick_ratio()

      Return an upper bound on :meth:`ratio` relatively quickly.


   .. method:: real_quick_ratio()

      Return an upper bound on :meth:`ratio` very quickly.


The three methods that return the ratio of matching to total characters can give
different results due to differing levels of approximation, although
:meth:`~SequenceMatcher.quick_ratio` and :meth:`~SequenceMatcher.real_quick_ratio`
are always at least as large as :meth:`~SequenceMatcher.ratio`:

   >>> s = SequenceMatcher(None, "abcd", "bcde")
   >>> s.ratio()
   0.75
   >>> s.quick_ratio()
   0.75
   >>> s.real_quick_ratio()
   1.0


.. _sequencematcher-examples:

SequenceMatcher Examples
------------------------

This example compares two strings, considering blanks to be "junk":

   >>> s = SequenceMatcher(lambda x: x == " ",
   ...                     "private Thread currentThread;",
   ...                     "private volatile Thread currentThread;")

:meth:`~SequenceMatcher.ratio` returns a float in [0, 1], measuring the similarity of the
sequences.  As a rule of thumb, a :meth:`~SequenceMatcher.ratio` value over 0.6 means the
sequences are close matches:

   >>> print(round(s.ratio(), 3))
   0.866

If you're only interested in where the sequences match,
:meth:`~SequenceMatcher.get_matching_blocks` is handy:

   >>> for block in s.get_matching_blocks():
   ...     print("a[%d] and b[%d] match for %d elements" % block)
   a[0] and b[0] match for 8 elements
   a[8] and b[17] match for 21 elements
   a[29] and b[38] match for 0 elements

Note that the last tuple returned by :meth:`~SequenceMatcher.get_matching_blocks`
is always a dummy, ``(len(a), len(b), 0)``, and this is the only case in which the last
tuple element (number of elements matched) is ``0``.

If you want to know how to change the first sequence into the second, use
:meth:`~SequenceMatcher.get_opcodes`:

   >>> for opcode in s.get_opcodes():
   ...     print("%6s a[%d:%d] b[%d:%d]" % opcode)
    equal a[0:8] b[0:8]
   insert a[8:8] b[8:17]
    equal a[8:29] b[17:38]

.. seealso::

   * The :func:`get_close_matches` function in this module which shows how
     simple code building on :class:`SequenceMatcher` can be used to do useful
     work.

   * `Simple version control recipe
     <https://code.activestate.com/recipes/576729-simple-version-control/>`_ for a small application
     built with :class:`SequenceMatcher`.


.. _differ-objects:

Differ Objects
--------------

Note that :class:`Differ`\ -generated deltas make no claim to be **minimal**
diffs. To the contrary, minimal diffs are often counter-intuitive, because they
synch up anywhere possible, sometimes accidental matches 100 pages apart.
Restricting synch points to contiguous matches preserves some notion of
locality, at the occasional cost of producing a longer diff.

The :class:`Differ` class has this constructor:


.. class:: Differ(linejunk=None, charjunk=None)
   :noindex:

   Optional keyword parameters *linejunk* and *charjunk* are for filter functions
   (or ``None``):

   *linejunk*: A function that accepts a single string argument, and returns true
   if the string is junk.  The default is ``None``, meaning that no line is
   considered junk.

   *charjunk*: A function that accepts a single character argument (a string of
   length 1), and returns true if the character is junk. The default is ``None``,
   meaning that no character is considered junk.

   These junk-filtering functions speed up matching to find
   differences and do not cause any differing lines or characters to
   be ignored.  Read the description of the
   :meth:`~SequenceMatcher.find_longest_match` method's *isjunk*
   parameter for an explanation.

   :class:`Differ` objects are used (deltas generated) via a single method:


   .. method:: Differ.compare(a, b)

      Compare two sequences of lines, and generate the delta (a sequence of lines).

      Each sequence must contain individual single-line strings ending with
      newlines.  Such sequences can be obtained from the
      :meth:`~io.IOBase.readlines` method of file-like objects.  The delta
      generated also consists of newline-terminated strings, ready to be
      printed as-is via the :meth:`~io.IOBase.writelines` method of a
      file-like object.


.. _differ-examples:

Differ Example
--------------

This example compares two texts. First we set up the texts, sequences of
individual single-line strings ending with newlines (such sequences can also be
obtained from the :meth:`~io.IOBase.readlines` method of file-like objects):

   >>> text1 = '''  1. Beautiful is better than ugly.
   ...   2. Explicit is better than implicit.
   ...   3. Simple is better than complex.
   ...   4. Complex is better than complicated.
   ... '''.splitlines(keepends=True)
   >>> len(text1)
   4
   >>> text1[0][-1]
   '\n'
   >>> text2 = '''  1. Beautiful is better than ugly.
   ...   3.   Simple is better than complex.
   ...   4. Complicated is better than complex.
   ...   5. Flat is better than nested.
   ... '''.splitlines(keepends=True)

Next we instantiate a Differ object:

   >>> d = Differ()

Note that when instantiating a :class:`Differ` object we may pass functions to
filter out line and character "junk."  See the :meth:`Differ` constructor for
details.

Finally, we compare the two:

   >>> result = list(d.compare(text1, text2))

``result`` is a list of strings, so let's pretty-print it:

   >>> from pprint import pprint
   >>> pprint(result)
   ['    1. Beautiful is better than ugly.\n',
    '-   2. Explicit is better than implicit.\n',
    '-   3. Simple is better than complex.\n',
    '+   3.   Simple is better than complex.\n',
    '?     ++\n',
    '-   4. Complex is better than complicated.\n',
    '?            ^                     ---- ^\n',
    '+   4. Complicated is better than complex.\n',
    '?           ++++ ^                      ^\n',
    '+   5. Flat is better than nested.\n']

As a single multi-line string it looks like this:

   >>> import sys
   >>> sys.stdout.writelines(result)
       1. Beautiful is better than ugly.
   -   2. Explicit is better than implicit.
   -   3. Simple is better than complex.
   +   3.   Simple is better than complex.
   ?     ++
   -   4. Complex is better than complicated.
   ?            ^                     ---- ^
   +   4. Complicated is better than complex.
   ?           ++++ ^                      ^
   +   5. Flat is better than nested.


.. _difflib-interface:

A command-line interface to difflib
-----------------------------------

This example shows how to use difflib to create a ``diff``-like utility.

.. literalinclude:: ../includes/diff.py

ndiff example
-------------

This example shows how to use :func:`difflib.ndiff`.

.. literalinclude:: ../includes/ndiff.py


================================================
File: /Doc/library/distribution.rst
================================================
***********************************
Software Packaging and Distribution
***********************************

These libraries help you with publishing and installing Python software.
While these modules are designed to work in conjunction with the
`Python Package Index <https://pypi.org>`__, they can also be used
with a local index server, or without any index server at all.

.. toctree::

   ensurepip.rst
   venv.rst
   zipapp.rst


================================================
File: /Doc/library/distutils.rst
================================================
:mod:`!distutils` --- Building and installing Python modules
============================================================

.. module:: distutils
   :synopsis: Removed in 3.12.
   :deprecated:

.. deprecated-removed:: 3.10 3.12

This module is no longer part of the Python standard library.
It was :ref:`removed in Python 3.12 <whatsnew312-removed-distutils>` after
being deprecated in Python 3.10.  The removal was decided in :pep:`632`,
which has `migration advice
<https://peps.python.org/pep-0632/#migration-advice>`_.

The last version of Python that provided the :mod:`!distutils` module was
`Python 3.11 <https://docs.python.org/3.11/library/distutils.html>`_.


================================================
File: /Doc/library/email.charset.rst
================================================
:mod:`!email.charset`: Representing character sets
--------------------------------------------------

.. module:: email.charset
   :synopsis: Character Sets

**Source code:** :source:`Lib/email/charset.py`

--------------

This module is part of the legacy (``Compat32``) email API.  In the new
API only the aliases table is used.

The remaining text in this section is the original documentation of the module.

This module provides a class :class:`Charset` for representing character sets
and character set conversions in email messages, as well as a character set
registry and several convenience methods for manipulating this registry.
Instances of :class:`Charset` are used in several other modules within the
:mod:`email` package.

Import this class from the :mod:`email.charset` module.


.. class:: Charset(input_charset=DEFAULT_CHARSET)

   Map character sets to their email properties.

   This class provides information about the requirements imposed on email for a
   specific character set.  It also provides convenience routines for converting
   between character sets, given the availability of the applicable codecs.  Given
   a character set, it will do its best to provide information on how to use that
   character set in an email message in an RFC-compliant way.

   Certain character sets must be encoded with quoted-printable or base64 when used
   in email headers or bodies.  Certain character sets must be converted outright,
   and are not allowed in email.

   Optional *input_charset* is as described below; it is always coerced to lower
   case.  After being alias normalized it is also used as a lookup into the
   registry of character sets to find out the header encoding, body encoding, and
   output conversion codec to be used for the character set.  For example, if
   *input_charset* is ``iso-8859-1``, then headers and bodies will be encoded using
   quoted-printable and no output conversion codec is necessary.  If
   *input_charset* is ``euc-jp``, then headers will be encoded with base64, bodies
   will not be encoded, but output text will be converted from the ``euc-jp``
   character set to the ``iso-2022-jp`` character set.

   :class:`Charset` instances have the following data attributes:

   .. attribute:: input_charset

      The initial character set specified.  Common aliases are converted to
      their *official* email names (e.g. ``latin_1`` is converted to
      ``iso-8859-1``).  Defaults to 7-bit ``us-ascii``.


   .. attribute:: header_encoding

      If the character set must be encoded before it can be used in an email
      header, this attribute will be set to ``charset.QP`` (for
      quoted-printable), ``charset.BASE64`` (for base64 encoding), or
      ``charset.SHORTEST`` for the shortest of QP or BASE64 encoding. Otherwise,
      it will be ``None``.


   .. attribute:: body_encoding

      Same as *header_encoding*, but describes the encoding for the mail
      message's body, which indeed may be different than the header encoding.
      ``charset.SHORTEST`` is not allowed for *body_encoding*.


   .. attribute:: output_charset

      Some character sets must be converted before they can be used in email
      headers or bodies.  If the *input_charset* is one of them, this attribute
      will contain the name of the character set output will be converted to.
      Otherwise, it will be ``None``.


   .. attribute:: input_codec

      The name of the Python codec used to convert the *input_charset* to
      Unicode.  If no conversion codec is necessary, this attribute will be
      ``None``.


   .. attribute:: output_codec

      The name of the Python codec used to convert Unicode to the
      *output_charset*.  If no conversion codec is necessary, this attribute
      will have the same value as the *input_codec*.


   :class:`Charset` instances also have the following methods:

   .. method:: get_body_encoding()

      Return the content transfer encoding used for body encoding.

      This is either the string ``quoted-printable`` or ``base64`` depending on
      the encoding used, or it is a function, in which case you should call the
      function with a single argument, the Message object being encoded.  The
      function should then set the :mailheader:`Content-Transfer-Encoding`
      header itself to whatever is appropriate.

      Returns the string ``quoted-printable`` if *body_encoding* is ``QP``,
      returns the string ``base64`` if *body_encoding* is ``BASE64``, and
      returns the string ``7bit`` otherwise.


   .. method:: get_output_charset()

      Return the output character set.

      This is the *output_charset* attribute if that is not ``None``, otherwise
      it is *input_charset*.


   .. method:: header_encode(string)

      Header-encode the string *string*.

      The type of encoding (base64 or quoted-printable) will be based on the
      *header_encoding* attribute.


   .. method:: header_encode_lines(string, maxlengths)

      Header-encode a *string* by converting it first to bytes.

      This is similar to :meth:`header_encode` except that the string is fit
      into maximum line lengths as given by the argument *maxlengths*, which
      must be an iterator: each element returned from this iterator will provide
      the next maximum line length.


   .. method:: body_encode(string)

      Body-encode the string *string*.

      The type of encoding (base64 or quoted-printable) will be based on the
      *body_encoding* attribute.

   The :class:`Charset` class also provides a number of methods to support
   standard operations and built-in functions.


   .. method:: __str__()

      Returns *input_charset* as a string coerced to lower
      case. :meth:`!__repr__` is an alias for :meth:`!__str__`.


   .. method:: __eq__(other)

      This method allows you to compare two :class:`Charset` instances for
      equality.


   .. method:: __ne__(other)

      This method allows you to compare two :class:`Charset` instances for
      inequality.

The :mod:`email.charset` module also provides the following functions for adding
new entries to the global character set, alias, and codec registries:


.. function:: add_charset(charset, header_enc=None, body_enc=None, output_charset=None)

   Add character properties to the global registry.

   *charset* is the input character set, and must be the canonical name of a
   character set.

   Optional *header_enc* and *body_enc* is either ``charset.QP`` for
   quoted-printable, ``charset.BASE64`` for base64 encoding,
   ``charset.SHORTEST`` for the shortest of quoted-printable or base64 encoding,
   or ``None`` for no encoding.  ``SHORTEST`` is only valid for
   *header_enc*. The default is ``None`` for no encoding.

   Optional *output_charset* is the character set that the output should be in.
   Conversions will proceed from input charset, to Unicode, to the output charset
   when the method :meth:`Charset.convert` is called.  The default is to output in
   the same character set as the input.

   Both *input_charset* and *output_charset* must have Unicode codec entries in the
   module's character set-to-codec mapping; use :func:`add_codec` to add codecs the
   module does not know about.  See the :mod:`codecs` module's documentation for
   more information.

   The global character set registry is kept in the module global dictionary
   ``CHARSETS``.


.. function:: add_alias(alias, canonical)

   Add a character set alias.  *alias* is the alias name, e.g. ``latin-1``.
   *canonical* is the character set's canonical name, e.g. ``iso-8859-1``.

   The global charset alias registry is kept in the module global dictionary
   ``ALIASES``.


.. function:: add_codec(charset, codecname)

   Add a codec that map characters in the given character set to and from Unicode.

   *charset* is the canonical name of a character set. *codecname* is the name of a
   Python codec, as appropriate for the second argument to the :class:`str`'s
   :meth:`~str.encode` method.



================================================
File: /Doc/library/email.compat32-message.rst
================================================
.. _compat32_message:

:mod:`email.message.Message`: Representing an email message using the :data:`~email.policy.compat32` API
--------------------------------------------------------------------------------------------------------

.. module:: email.message
   :synopsis: The base class representing email messages in a fashion
              backward compatible with Python 3.2
   :noindex:
   :no-index:


The :class:`Message` class is very similar to the
:class:`~email.message.EmailMessage` class, without the methods added by that
class, and with the default behavior of certain other methods being slightly
different.  We also document here some methods that, while supported by the
:class:`~email.message.EmailMessage` class, are not recommended unless you are
dealing with legacy code.

The philosophy and structure of the two classes is otherwise the same.

This document describes the behavior under the default (for :class:`Message`)
policy :attr:`~email.policy.Compat32`.  If you are going to use another policy,
you should be using the :class:`~email.message.EmailMessage` class instead.

An email message consists of *headers* and a *payload*.  Headers must be
:rfc:`5322` style names and values, where the field name and value are
separated by a colon.  The colon is not part of either the field name or the
field value.  The payload may be a simple text message, or a binary object, or
a structured sequence of sub-messages each with their own set of headers and
their own payload.  The latter type of payload is indicated by the message
having a MIME type such as :mimetype:`multipart/\*` or
:mimetype:`message/rfc822`.

The conceptual model provided by a :class:`Message` object is that of an
ordered dictionary of headers with additional methods for accessing both
specialized information from the headers, for accessing the payload, for
generating a serialized version of the message, and for recursively walking
over the object tree.  Note that duplicate headers are supported but special
methods must be used to access them.

The :class:`Message` pseudo-dictionary is indexed by the header names, which
must be ASCII values.  The values of the dictionary are strings that are
supposed to contain only ASCII characters; there is some special handling for
non-ASCII input, but it doesn't always produce the correct results.  Headers
are stored and returned in case-preserving form, but field names are matched
case-insensitively.  There may also be a single envelope header, also known as
the *Unix-From* header or the ``From_`` header.  The *payload* is either a
string or bytes, in the case of simple message objects, or a list of
:class:`Message` objects, for MIME container documents (e.g.
:mimetype:`multipart/\*` and :mimetype:`message/rfc822`).

Here are the methods of the :class:`Message` class:


.. class:: Message(policy=compat32)

   If *policy* is specified (it must be an instance of a :mod:`~email.policy`
   class) use the rules it specifies to update and serialize the representation
   of the message.  If *policy* is not set, use the :class:`compat32
   <email.policy.Compat32>` policy, which maintains backward compatibility with
   the Python 3.2 version of the email package.  For more information see the
   :mod:`~email.policy` documentation.

   .. versionchanged:: 3.3 The *policy* keyword argument was added.


   .. method:: as_string(unixfrom=False, maxheaderlen=0, policy=None)

      Return the entire message flattened as a string.  When optional *unixfrom*
      is true, the envelope header is included in the returned string.
      *unixfrom* defaults to ``False``.  For backward compatibility reasons,
      *maxheaderlen* defaults to ``0``, so if you want a different value you
      must override it explicitly (the value specified for *max_line_length* in
      the policy will be ignored by this method).  The *policy* argument may be
      used to override the default policy obtained from the message instance.
      This can be used to control some of the formatting produced by the
      method, since the specified *policy* will be passed to the ``Generator``.

      Flattening the message may trigger changes to the :class:`Message` if
      defaults need to be filled in to complete the transformation to a string
      (for example, MIME boundaries may be generated or modified).

      Note that this method is provided as a convenience and may not always
      format the message the way you want.  For example, by default it does
      not do the mangling of lines that begin with ``From`` that is
      required by the Unix mbox format.  For more flexibility, instantiate a
      :class:`~email.generator.Generator` instance and use its
      :meth:`~email.generator.Generator.flatten` method directly.  For example::

         from io import StringIO
         from email.generator import Generator
         fp = StringIO()
         g = Generator(fp, mangle_from_=True, maxheaderlen=60)
         g.flatten(msg)
         text = fp.getvalue()

      If the message object contains binary data that is not encoded according
      to RFC standards, the non-compliant data will be replaced by unicode
      "unknown character" code points.  (See also :meth:`.as_bytes` and
      :class:`~email.generator.BytesGenerator`.)

      .. versionchanged:: 3.4 the *policy* keyword argument was added.


   .. method:: __str__()

      Equivalent to :meth:`.as_string`.  Allows ``str(msg)`` to produce a
      string containing the formatted message.


   .. method:: as_bytes(unixfrom=False, policy=None)

      Return the entire message flattened as a bytes object.  When optional
      *unixfrom* is true, the envelope header is included in the returned
      string.  *unixfrom* defaults to ``False``.  The *policy* argument may be
      used to override the default policy obtained from the message instance.
      This can be used to control some of the formatting produced by the
      method, since the specified *policy* will be passed to the
      ``BytesGenerator``.

      Flattening the message may trigger changes to the :class:`Message` if
      defaults need to be filled in to complete the transformation to a string
      (for example, MIME boundaries may be generated or modified).

      Note that this method is provided as a convenience and may not always
      format the message the way you want.  For example, by default it does
      not do the mangling of lines that begin with ``From`` that is
      required by the Unix mbox format.  For more flexibility, instantiate a
      :class:`~email.generator.BytesGenerator` instance and use its
      :meth:`~email.generator.BytesGenerator.flatten` method directly.
      For example::

         from io import BytesIO
         from email.generator import BytesGenerator
         fp = BytesIO()
         g = BytesGenerator(fp, mangle_from_=True, maxheaderlen=60)
         g.flatten(msg)
         text = fp.getvalue()

      .. versionadded:: 3.4


   .. method:: __bytes__()

      Equivalent to :meth:`.as_bytes`.  Allows ``bytes(msg)`` to produce a
      bytes object containing the formatted message.

      .. versionadded:: 3.4


   .. method:: is_multipart()

      Return ``True`` if the message's payload is a list of
      sub-\ :class:`Message` objects, otherwise return ``False``.  When
      :meth:`is_multipart` returns ``False``, the payload should be a string
      object (which might be a CTE encoded binary payload).  (Note that
      :meth:`is_multipart` returning ``True`` does not necessarily mean that
      "msg.get_content_maintype() == 'multipart'" will return the ``True``.
      For example, ``is_multipart`` will return ``True`` when the
      :class:`Message` is of type ``message/rfc822``.)


   .. method:: set_unixfrom(unixfrom)

      Set the message's envelope header to *unixfrom*, which should be a string.


   .. method:: get_unixfrom()

      Return the message's envelope header.  Defaults to ``None`` if the
      envelope header was never set.


   .. method:: attach(payload)

      Add the given *payload* to the current payload, which must be ``None`` or
      a list of :class:`Message` objects before the call. After the call, the
      payload will always be a list of :class:`Message` objects.  If you want to
      set the payload to a scalar object (e.g. a string), use
      :meth:`set_payload` instead.

      This is a legacy method.  On the
      :class:`~email.emailmessage.EmailMessage` class its functionality is
      replaced by :meth:`~email.message.EmailMessage.set_content` and the
      related ``make`` and ``add`` methods.


   .. method:: get_payload(i=None, decode=False)

      Return the current payload, which will be a list of
      :class:`Message` objects when :meth:`is_multipart` is ``True``, or a
      string when :meth:`is_multipart` is ``False``.  If the payload is a list
      and you mutate the list object, you modify the message's payload in place.

      With optional argument *i*, :meth:`get_payload` will return the *i*-th
      element of the payload, counting from zero, if :meth:`is_multipart` is
      ``True``.  An :exc:`IndexError` will be raised if *i* is less than 0 or
      greater than or equal to the number of items in the payload.  If the
      payload is a string (i.e.  :meth:`is_multipart` is ``False``) and *i* is
      given, a :exc:`TypeError` is raised.

      Optional *decode* is a flag indicating whether the payload should be
      decoded or not, according to the :mailheader:`Content-Transfer-Encoding`
      header. When ``True`` and the message is not a multipart, the payload will
      be decoded if this header's value is ``quoted-printable`` or ``base64``.
      If some other encoding is used, or :mailheader:`Content-Transfer-Encoding`
      header is missing, the payload is
      returned as-is (undecoded).  In all cases the returned value is binary
      data.  If the message is a multipart and the *decode* flag is ``True``,
      then ``None`` is returned.  If the payload is base64 and it was not
      perfectly formed (missing padding, characters outside the base64
      alphabet), then an appropriate defect will be added to the message's
      defect property (:class:`~email.errors.InvalidBase64PaddingDefect` or
      :class:`~email.errors.InvalidBase64CharactersDefect`, respectively).

      When *decode* is ``False`` (the default) the body is returned as a string
      without decoding the :mailheader:`Content-Transfer-Encoding`.  However,
      for a :mailheader:`Content-Transfer-Encoding` of 8bit, an attempt is made
      to decode the original bytes using the ``charset`` specified by the
      :mailheader:`Content-Type` header, using the ``replace`` error handler.
      If no ``charset`` is specified, or if the ``charset`` given is not
      recognized by the email package, the body is decoded using the default
      ASCII charset.

      This is a legacy method.  On the
      :class:`~email.emailmessage.EmailMessage` class its functionality is
      replaced by :meth:`~email.message.EmailMessage.get_content` and
      :meth:`~email.message.EmailMessage.iter_parts`.


   .. method:: set_payload(payload, charset=None)

      Set the entire message object's payload to *payload*.  It is the client's
      responsibility to ensure the payload invariants.  Optional *charset* sets
      the message's default character set; see :meth:`set_charset` for details.

      This is a legacy method.  On the
      :class:`~email.emailmessage.EmailMessage` class its functionality is
      replaced by :meth:`~email.message.EmailMessage.set_content`.


   .. method:: set_charset(charset)

      Set the character set of the payload to *charset*, which can either be a
      :class:`~email.charset.Charset` instance (see :mod:`email.charset`), a
      string naming a character set, or ``None``.  If it is a string, it will
      be converted to a :class:`~email.charset.Charset` instance.  If *charset*
      is ``None``, the ``charset`` parameter will be removed from the
      :mailheader:`Content-Type` header (the message will not be otherwise
      modified).  Anything else will generate a :exc:`TypeError`.

      If there is no existing :mailheader:`MIME-Version` header one will be
      added.  If there is no existing :mailheader:`Content-Type` header, one
      will be added with a value of :mimetype:`text/plain`.  Whether the
      :mailheader:`Content-Type` header already exists or not, its ``charset``
      parameter will be set to *charset.output_charset*.   If
      *charset.input_charset* and *charset.output_charset* differ, the payload
      will be re-encoded to the *output_charset*.  If there is no existing
      :mailheader:`Content-Transfer-Encoding` header, then the payload will be
      transfer-encoded, if needed, using the specified
      :class:`~email.charset.Charset`, and a header with the appropriate value
      will be added.  If a :mailheader:`Content-Transfer-Encoding` header
      already exists, the payload is assumed to already be correctly encoded
      using that :mailheader:`Content-Transfer-Encoding` and is not modified.

      This is a legacy method.  On the
      :class:`~email.emailmessage.EmailMessage` class its functionality is
      replaced by the *charset* parameter of the
      :meth:`email.emailmessage.EmailMessage.set_content` method.


   .. method:: get_charset()

      Return the :class:`~email.charset.Charset` instance associated with the
      message's payload.

      This is a legacy method.  On the
      :class:`~email.emailmessage.EmailMessage` class it always returns
      ``None``.


   The following methods implement a mapping-like interface for accessing the
   message's :rfc:`2822` headers.  Note that there are some semantic differences
   between these methods and a normal mapping (i.e. dictionary) interface.  For
   example, in a dictionary there are no duplicate keys, but here there may be
   duplicate message headers.  Also, in dictionaries there is no guaranteed
   order to the keys returned by :meth:`keys`, but in a :class:`Message` object,
   headers are always returned in the order they appeared in the original
   message, or were added to the message later.  Any header deleted and then
   re-added are always appended to the end of the header list.

   These semantic differences are intentional and are biased toward maximal
   convenience.

   Note that in all cases, any envelope header present in the message is not
   included in the mapping interface.

   In a model generated from bytes, any header values that (in contravention of
   the RFCs) contain non-ASCII bytes will, when retrieved through this
   interface, be represented as :class:`~email.header.Header` objects with
   a charset of ``unknown-8bit``.


   .. method:: __len__()

      Return the total number of headers, including duplicates.


   .. method:: __contains__(name)

      Return ``True`` if the message object has a field named *name*. Matching is
      done case-insensitively and *name* should not include the trailing colon.
      Used for the ``in`` operator, e.g.::

           if 'message-id' in myMessage:
              print('Message-ID:', myMessage['message-id'])


   .. method:: __getitem__(name)

      Return the value of the named header field.  *name* should not include the
      colon field separator.  If the header is missing, ``None`` is returned; a
      :exc:`KeyError` is never raised.

      Note that if the named field appears more than once in the message's
      headers, exactly which of those field values will be returned is
      undefined.  Use the :meth:`get_all` method to get the values of all the
      extant named headers.


   .. method:: __setitem__(name, val)

      Add a header to the message with field name *name* and value *val*.  The
      field is appended to the end of the message's existing fields.

      Note that this does *not* overwrite or delete any existing header with the same
      name.  If you want to ensure that the new header is the only one present in the
      message with field name *name*, delete the field first, e.g.::

         del msg['subject']
         msg['subject'] = 'Python roolz!'


   .. method:: __delitem__(name)

      Delete all occurrences of the field with name *name* from the message's
      headers.  No exception is raised if the named field isn't present in the
      headers.


   .. method:: keys()

      Return a list of all the message's header field names.


   .. method:: values()

      Return a list of all the message's field values.


   .. method:: items()

      Return a list of 2-tuples containing all the message's field headers and
      values.


   .. method:: get(name, failobj=None)

      Return the value of the named header field.  This is identical to
      :meth:`~object.__getitem__` except that optional *failobj* is returned if the
      named header is missing (defaults to ``None``).

   Here are some additional useful methods:


   .. method:: get_all(name, failobj=None)

      Return a list of all the values for the field named *name*. If there are
      no such named headers in the message, *failobj* is returned (defaults to
      ``None``).


   .. method:: add_header(_name, _value, **_params)

      Extended header setting.  This method is similar to :meth:`__setitem__`
      except that additional header parameters can be provided as keyword
      arguments.  *_name* is the header field to add and *_value* is the
      *primary* value for the header.

      For each item in the keyword argument dictionary *_params*, the key is
      taken as the parameter name, with underscores converted to dashes (since
      dashes are illegal in Python identifiers).  Normally, the parameter will
      be added as ``key="value"`` unless the value is ``None``, in which case
      only the key will be added.  If the value contains non-ASCII characters,
      it can be specified as a three tuple in the format
      ``(CHARSET, LANGUAGE, VALUE)``, where ``CHARSET`` is a string naming the
      charset to be used to encode the value, ``LANGUAGE`` can usually be set
      to ``None`` or the empty string (see :rfc:`2231` for other possibilities),
      and ``VALUE`` is the string value containing non-ASCII code points.  If
      a three tuple is not passed and the value contains non-ASCII characters,
      it is automatically encoded in :rfc:`2231` format using a ``CHARSET``
      of ``utf-8`` and a ``LANGUAGE`` of ``None``.

      Here's an example::

         msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')

      This will add a header that looks like ::

         Content-Disposition: attachment; filename="bud.gif"

      An example with non-ASCII characters::

         msg.add_header('Content-Disposition', 'attachment',
                        filename=('iso-8859-1', '', 'Fußballer.ppt'))

      Which produces ::

         Content-Disposition: attachment; filename*="iso-8859-1''Fu%DFballer.ppt"


   .. method:: replace_header(_name, _value)

      Replace a header.  Replace the first header found in the message that
      matches *_name*, retaining header order and field name case.  If no
      matching header was found, a :exc:`KeyError` is raised.


   .. method:: get_content_type()

      Return the message's content type.  The returned string is coerced to
      lower case of the form :mimetype:`maintype/subtype`.  If there was no
      :mailheader:`Content-Type` header in the message the default type as given
      by :meth:`get_default_type` will be returned.  Since according to
      :rfc:`2045`, messages always have a default type, :meth:`get_content_type`
      will always return a value.

      :rfc:`2045` defines a message's default type to be :mimetype:`text/plain`
      unless it appears inside a :mimetype:`multipart/digest` container, in
      which case it would be :mimetype:`message/rfc822`.  If the
      :mailheader:`Content-Type` header has an invalid type specification,
      :rfc:`2045` mandates that the default type be :mimetype:`text/plain`.


   .. method:: get_content_maintype()

      Return the message's main content type.  This is the :mimetype:`maintype`
      part of the string returned by :meth:`get_content_type`.


   .. method:: get_content_subtype()

      Return the message's sub-content type.  This is the :mimetype:`subtype`
      part of the string returned by :meth:`get_content_type`.


   .. method:: get_default_type()

      Return the default content type.  Most messages have a default content
      type of :mimetype:`text/plain`, except for messages that are subparts of
      :mimetype:`multipart/digest` containers.  Such subparts have a default
      content type of :mimetype:`message/rfc822`.


   .. method:: set_default_type(ctype)

      Set the default content type.  *ctype* should either be
      :mimetype:`text/plain` or :mimetype:`message/rfc822`, although this is not
      enforced.  The default content type is not stored in the
      :mailheader:`Content-Type` header.


   .. method:: get_params(failobj=None, header='content-type', unquote=True)

      Return the message's :mailheader:`Content-Type` parameters, as a list.
      The elements of the returned list are 2-tuples of key/value pairs, as
      split on the ``'='`` sign.  The left hand side of the ``'='`` is the key,
      while the right hand side is the value.  If there is no ``'='`` sign in
      the parameter the value is the empty string, otherwise the value is as
      described in :meth:`get_param` and is unquoted if optional *unquote* is
      ``True`` (the default).

      Optional *failobj* is the object to return if there is no
      :mailheader:`Content-Type` header.  Optional *header* is the header to
      search instead of :mailheader:`Content-Type`.

      This is a legacy method.  On the
      :class:`~email.emailmessage.EmailMessage` class its functionality is
      replaced by the *params* property of the individual header objects
      returned by the header access methods.


   .. method:: get_param(param, failobj=None, header='content-type', unquote=True)

      Return the value of the :mailheader:`Content-Type` header's parameter
      *param* as a string.  If the message has no :mailheader:`Content-Type`
      header or if there is no such parameter, then *failobj* is returned
      (defaults to ``None``).

      Optional *header* if given, specifies the message header to use instead of
      :mailheader:`Content-Type`.

      Parameter keys are always compared case insensitively.  The return value
      can either be a string, or a 3-tuple if the parameter was :rfc:`2231`
      encoded.  When it's a 3-tuple, the elements of the value are of the form
      ``(CHARSET, LANGUAGE, VALUE)``.  Note that both ``CHARSET`` and
      ``LANGUAGE`` can be ``None``, in which case you should consider ``VALUE``
      to be encoded in the ``us-ascii`` charset.  You can usually ignore
      ``LANGUAGE``.

      If your application doesn't care whether the parameter was encoded as in
      :rfc:`2231`, you can collapse the parameter value by calling
      :func:`email.utils.collapse_rfc2231_value`, passing in the return value
      from :meth:`get_param`.  This will return a suitably decoded Unicode
      string when the value is a tuple, or the original string unquoted if it
      isn't.  For example::

         rawparam = msg.get_param('foo')
         param = email.utils.collapse_rfc2231_value(rawparam)

      In any case, the parameter value (either the returned string, or the
      ``VALUE`` item in the 3-tuple) is always unquoted, unless *unquote* is set
      to ``False``.

      This is a legacy method.  On the
      :class:`~email.emailmessage.EmailMessage` class its functionality is
      replaced by the *params* property of the individual header objects
      returned by the header access methods.


   .. method:: set_param(param, value, header='Content-Type', requote=True, \
                         charset=None, language='', replace=False)

      Set a parameter in the :mailheader:`Content-Type` header.  If the
      parameter already exists in the header, its value will be replaced with
      *value*.  If the :mailheader:`Content-Type` header as not yet been defined
      for this message, it will be set to :mimetype:`text/plain` and the new
      parameter value will be appended as per :rfc:`2045`.

      Optional *header* specifies an alternative header to
      :mailheader:`Content-Type`, and all parameters will be quoted as necessary
      unless optional *requote* is ``False`` (the default is ``True``).

      If optional *charset* is specified, the parameter will be encoded
      according to :rfc:`2231`. Optional *language* specifies the RFC 2231
      language, defaulting to the empty string.  Both *charset* and *language*
      should be strings.

      If *replace* is ``False`` (the default) the header is moved to the
      end of the list of headers.  If *replace* is ``True``, the header
      will be updated in place.

      .. versionchanged:: 3.4 ``replace`` keyword was added.


   .. method:: del_param(param, header='content-type', requote=True)

      Remove the given parameter completely from the :mailheader:`Content-Type`
      header.  The header will be re-written in place without the parameter or
      its value.  All values will be quoted as necessary unless *requote* is
      ``False`` (the default is ``True``).  Optional *header* specifies an
      alternative to :mailheader:`Content-Type`.


   .. method:: set_type(type, header='Content-Type', requote=True)

      Set the main type and subtype for the :mailheader:`Content-Type`
      header. *type* must be a string in the form :mimetype:`maintype/subtype`,
      otherwise a :exc:`ValueError` is raised.

      This method replaces the :mailheader:`Content-Type` header, keeping all
      the parameters in place.  If *requote* is ``False``, this leaves the
      existing header's quoting as is, otherwise the parameters will be quoted
      (the default).

      An alternative header can be specified in the *header* argument. When the
      :mailheader:`Content-Type` header is set a :mailheader:`MIME-Version`
      header is also added.

      This is a legacy method.  On the
      :class:`~email.emailmessage.EmailMessage` class its functionality is
      replaced by the ``make_`` and ``add_`` methods.


   .. method:: get_filename(failobj=None)

      Return the value of the ``filename`` parameter of the
      :mailheader:`Content-Disposition` header of the message.  If the header
      does not have a ``filename`` parameter, this method falls back to looking
      for the ``name`` parameter on the :mailheader:`Content-Type` header.  If
      neither is found, or the header is missing, then *failobj* is returned.
      The returned string will always be unquoted as per
      :func:`email.utils.unquote`.


   .. method:: get_boundary(failobj=None)

      Return the value of the ``boundary`` parameter of the
      :mailheader:`Content-Type` header of the message, or *failobj* if either
      the header is missing, or has no ``boundary`` parameter.  The returned
      string will always be unquoted as per :func:`email.utils.unquote`.


   .. method:: set_boundary(boundary)

      Set the ``boundary`` parameter of the :mailheader:`Content-Type` header to
      *boundary*.  :meth:`set_boundary` will always quote *boundary* if
      necessary.  A :exc:`~email.errors.HeaderParseError` is raised if the
      message object has no :mailheader:`Content-Type` header.

      Note that using this method is subtly different than deleting the old
      :mailheader:`Content-Type` header and adding a new one with the new
      boundary via :meth:`add_header`, because :meth:`set_boundary` preserves
      the order of the :mailheader:`Content-Type` header in the list of
      headers. However, it does *not* preserve any continuation lines which may
      have been present in the original :mailheader:`Content-Type` header.


   .. method:: get_content_charset(failobj=None)

      Return the ``charset`` parameter of the :mailheader:`Content-Type` header,
      coerced to lower case.  If there is no :mailheader:`Content-Type` header, or if
      that header has no ``charset`` parameter, *failobj* is returned.

      Note that this method differs from :meth:`get_charset` which returns the
      :class:`~email.charset.Charset` instance for the default encoding of the message body.


   .. method:: get_charsets(failobj=None)

      Return a list containing the character set names in the message.  If the
      message is a :mimetype:`multipart`, then the list will contain one element
      for each subpart in the payload, otherwise, it will be a list of length 1.

      Each item in the list will be a string which is the value of the
      ``charset`` parameter in the :mailheader:`Content-Type` header for the
      represented subpart.  However, if the subpart has no
      :mailheader:`Content-Type` header, no ``charset`` parameter, or is not of
      the :mimetype:`text` main MIME type, then that item in the returned list
      will be *failobj*.


   .. method:: get_content_disposition()

      Return the lowercased value (without parameters) of the message's
      :mailheader:`Content-Disposition` header if it has one, or ``None``.  The
      possible values for this method are *inline*, *attachment* or ``None``
      if the message follows :rfc:`2183`.

      .. versionadded:: 3.5

   .. method:: walk()

      The :meth:`walk` method is an all-purpose generator which can be used to
      iterate over all the parts and subparts of a message object tree, in
      depth-first traversal order.  You will typically use :meth:`walk` as the
      iterator in a ``for`` loop; each iteration returns the next subpart.

      Here's an example that prints the MIME type of every part of a multipart
      message structure:

      .. testsetup::

         import email
         from email import message_from_binary_file
         from os.path import join, dirname
         lib_dir = dirname(dirname(email.__file__))
         file_path = join(lib_dir, 'test/test_email/data/msg_16.txt')
         with open(file_path, 'rb') as f:
             msg = message_from_binary_file(f)
         from email.iterators import _structure

      .. doctest::

         >>> for part in msg.walk():
         ...     print(part.get_content_type())
         multipart/report
         text/plain
         message/delivery-status
         text/plain
         text/plain
         message/rfc822
         text/plain

      ``walk`` iterates over the subparts of any part where
      :meth:`is_multipart` returns ``True``, even though
      ``msg.get_content_maintype() == 'multipart'`` may return ``False``.  We
      can see this in our example by making use of the ``_structure`` debug
      helper function:

      .. doctest::

         >>> for part in msg.walk():
         ...     print(part.get_content_maintype() == 'multipart',
         ...           part.is_multipart())
         True True
         False False
         False True
         False False
         False False
         False True
         False False
         >>> _structure(msg)
         multipart/report
             text/plain
             message/delivery-status
                 text/plain
                 text/plain
             message/rfc822
                 text/plain

      Here the ``message`` parts are not ``multiparts``, but they do contain
      subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends
      into the subparts.


   :class:`Message` objects can also optionally contain two instance attributes,
   which can be used when generating the plain text of a MIME message.


   .. attribute:: preamble

      The format of a MIME document allows for some text between the blank line
      following the headers, and the first multipart boundary string. Normally,
      this text is never visible in a MIME-aware mail reader because it falls
      outside the standard MIME armor.  However, when viewing the raw text of
      the message, or when viewing the message in a non-MIME aware reader, this
      text can become visible.

      The *preamble* attribute contains this leading extra-armor text for MIME
      documents.  When the :class:`~email.parser.Parser` discovers some text
      after the headers but before the first boundary string, it assigns this
      text to the message's *preamble* attribute.  When the
      :class:`~email.generator.Generator` is writing out the plain text
      representation of a MIME message, and it finds the
      message has a *preamble* attribute, it will write this text in the area
      between the headers and the first boundary.  See :mod:`email.parser` and
      :mod:`email.generator` for details.

      Note that if the message object has no preamble, the *preamble* attribute
      will be ``None``.


   .. attribute:: epilogue

      The *epilogue* attribute acts the same way as the *preamble* attribute,
      except that it contains text that appears between the last boundary and
      the end of the message.

      You do not need to set the epilogue to the empty string in order for the
      :class:`~email.generator.Generator` to print a newline at the end of the
      file.


   .. attribute:: defects

      The *defects* attribute contains a list of all the problems found when
      parsing this message.  See :mod:`email.errors` for a detailed description
      of the possible parsing defects.


================================================
File: /Doc/library/email.contentmanager.rst
================================================
:mod:`!email.contentmanager`: Managing MIME Content
---------------------------------------------------

.. module:: email.contentmanager
   :synopsis: Storing and Retrieving Content from MIME Parts

.. moduleauthor:: R. David Murray <rdmurray@bitdance.com>
.. sectionauthor:: R. David Murray <rdmurray@bitdance.com>

**Source code:** :source:`Lib/email/contentmanager.py`

------------

.. versionadded:: 3.6 [1]_


.. class:: ContentManager()

   Base class for content managers.  Provides the standard registry mechanisms
   to register converters between MIME content and other representations, as
   well as the ``get_content`` and ``set_content`` dispatch methods.


   .. method:: get_content(msg, *args, **kw)

      Look up a handler function based on the ``mimetype`` of *msg* (see next
      paragraph), call it, passing through all arguments, and return the result
      of the call.  The expectation is that the handler will extract the
      payload from *msg* and return an object that encodes information about
      the extracted data.

      To find the handler, look for the following keys in the registry,
      stopping with the first one found:

      * the string representing the full MIME type (``maintype/subtype``)
      * the string representing the ``maintype``
      * the empty string

      If none of these keys produce a handler, raise a :exc:`KeyError` for the
      full MIME type.


   .. method:: set_content(msg, obj, *args, **kw)

      If the ``maintype`` is ``multipart``, raise a :exc:`TypeError`; otherwise
      look up a handler function based on the type of *obj* (see next
      paragraph), call :meth:`~email.message.EmailMessage.clear_content` on the
      *msg*, and call the handler function, passing through all arguments.  The
      expectation is that the handler will transform and store *obj* into
      *msg*, possibly making other changes to *msg* as well, such as adding
      various MIME headers to encode information needed to interpret the stored
      data.

      To find the handler, obtain the type of *obj* (``typ = type(obj)``), and
      look for the following keys in the registry, stopping with the first one
      found:

      * the type itself (``typ``)
      * the type's fully qualified name (``typ.__module__ + '.' +
        typ.__qualname__``).
      * the type's :attr:`qualname <type.__qualname__>` (``typ.__qualname__``)
      * the type's :attr:`name <type.__name__>` (``typ.__name__``).

      If none of the above match, repeat all of the checks above for each of
      the types in the :term:`MRO` (:attr:`typ.__mro__ <type.__mro__>`).
      Finally, if no other key
      yields a handler, check for a handler for the key ``None``.  If there is
      no handler for ``None``, raise a :exc:`KeyError` for the fully
      qualified name of the type.

      Also add a :mailheader:`MIME-Version` header if one is not present (see
      also :class:`.MIMEPart`).


   .. method:: add_get_handler(key, handler)

      Record the function *handler* as the handler for *key*.  For the possible
      values of *key*, see :meth:`get_content`.


   .. method:: add_set_handler(typekey, handler)

      Record *handler* as the function to call when an object of a type
      matching *typekey* is passed to :meth:`set_content`.  For the possible
      values of *typekey*, see :meth:`set_content`.


Content Manager Instances
~~~~~~~~~~~~~~~~~~~~~~~~~

Currently the email package provides only one concrete content manager,
:data:`raw_data_manager`, although more may be added in the future.
:data:`raw_data_manager` is the
:attr:`~email.policy.EmailPolicy.content_manager` provided by
:attr:`~email.policy.EmailPolicy` and its derivatives.


.. data:: raw_data_manager

   This content manager provides only a minimum interface beyond that provided
   by :class:`~email.message.Message` itself:  it deals only with text, raw
   byte strings, and :class:`~email.message.Message` objects.  Nevertheless, it
   provides significant advantages compared to the base API: ``get_content`` on
   a text part will return a unicode string without the application needing to
   manually decode it, ``set_content`` provides a rich set of options for
   controlling the headers added to a part and controlling the content transfer
   encoding, and it enables the use of the various ``add_`` methods, thereby
   simplifying the creation of multipart messages.

   .. method:: get_content(msg, errors='replace')

      Return the payload of the part as either a string (for ``text`` parts), an
      :class:`~email.message.EmailMessage` object (for ``message/rfc822``
      parts), or a ``bytes`` object (for all other non-multipart types).  Raise
      a :exc:`KeyError` if called on a ``multipart``.  If the part is a
      ``text`` part and *errors* is specified, use it as the error handler when
      decoding the payload to unicode.  The default error handler is
      ``replace``.

   .. method:: set_content(msg, <'str'>, subtype="plain", charset='utf-8', \
                           cte=None, \
                           disposition=None, filename=None, cid=None, \
                           params=None, headers=None)
               set_content(msg, <'bytes'>, maintype, subtype, cte="base64", \
                           disposition=None, filename=None, cid=None, \
                           params=None, headers=None)
               set_content(msg, <'EmailMessage'>, cte=None, \
                           disposition=None, filename=None, cid=None, \
                           params=None, headers=None)

       Add headers and payload to *msg*:

       Add a :mailheader:`Content-Type` header with a ``maintype/subtype``
       value.

       * For ``str``, set the MIME ``maintype`` to ``text``, and set the
         subtype to *subtype* if it is specified, or ``plain`` if it is not.
       * For ``bytes``, use the specified *maintype* and *subtype*, or
         raise a :exc:`TypeError` if they are not specified.
       * For :class:`~email.message.EmailMessage` objects, set the maintype
         to ``message``, and set the subtype to *subtype* if it is
         specified or ``rfc822`` if it is not.  If *subtype* is
         ``partial``, raise an error (``bytes`` objects must be used to
         construct ``message/partial`` parts).

       If *charset* is provided (which is valid only for ``str``), encode the
       string to bytes using the specified character set.  The default is
       ``utf-8``.  If the specified *charset* is a known alias for a standard
       MIME charset name, use the standard charset instead.

       If *cte* is set, encode the payload using the specified content transfer
       encoding, and set the :mailheader:`Content-Transfer-Encoding` header to
       that value.  Possible values for *cte* are ``quoted-printable``,
       ``base64``, ``7bit``, ``8bit``, and ``binary``.  If the input cannot be
       encoded in the specified encoding (for example, specifying a *cte* of
       ``7bit`` for an input that contains non-ASCII values), raise a
       :exc:`ValueError`.

       * For ``str`` objects, if *cte* is not set use heuristics to
         determine the most compact encoding.
       * For :class:`~email.message.EmailMessage`, per :rfc:`2046`, raise
         an error if a *cte* of ``quoted-printable`` or ``base64`` is
         requested for *subtype* ``rfc822``, and for any *cte* other than
         ``7bit`` for *subtype* ``external-body``.  For
         ``message/rfc822``, use ``8bit`` if *cte* is not specified.  For
         all other values of *subtype*, use ``7bit``.

       .. note:: A *cte* of ``binary`` does not actually work correctly yet.
          The ``EmailMessage`` object as modified by ``set_content`` is
          correct, but :class:`~email.generator.BytesGenerator` does not
          serialize it correctly.

       If *disposition* is set, use it as the value of the
       :mailheader:`Content-Disposition` header.  If not specified, and
       *filename* is specified, add the header with the value ``attachment``.
       If *disposition* is not specified and *filename* is also not specified,
       do not add the header.  The only valid values for *disposition* are
       ``attachment`` and ``inline``.

       If *filename* is specified, use it as the value of the ``filename``
       parameter of the :mailheader:`Content-Disposition` header.

       If *cid* is specified, add a :mailheader:`Content-ID` header with
       *cid* as its value.

       If *params* is specified, iterate its ``items`` method and use the
       resulting ``(key, value)`` pairs to set additional parameters on the
       :mailheader:`Content-Type` header.

       If *headers* is specified and is a list of strings of the form
       ``headername: headervalue`` or a list of ``header`` objects
       (distinguished from strings by having a ``name`` attribute), add the
       headers to *msg*.


.. rubric:: Footnotes

.. [1] Originally added in 3.4 as a :term:`provisional module <provisional
       package>`


================================================
File: /Doc/library/email.encoders.rst
================================================
:mod:`!email.encoders`: Encoders
--------------------------------

.. module:: email.encoders
   :synopsis: Encoders for email message payloads.

**Source code:** :source:`Lib/email/encoders.py`

--------------

This module is part of the legacy (``Compat32``) email API.  In the
new API the functionality is provided by the *cte* parameter of
the :meth:`~email.message.EmailMessage.set_content` method.

This module is deprecated in Python 3.  The functions provided here
should not be called explicitly since the :class:`~email.mime.text.MIMEText`
class sets the content type and CTE header using the *_subtype* and *_charset*
values passed during the instantiation of that class.

The remaining text in this section is the original documentation of the module.

When creating :class:`~email.message.Message` objects from scratch, you often
need to encode the payloads for transport through compliant mail servers. This
is especially true for :mimetype:`image/\*` and :mimetype:`text/\*` type messages
containing binary data.

The :mod:`email` package provides some convenient encoders in its
:mod:`~email.encoders` module.  These encoders are actually used by the
:class:`~email.mime.audio.MIMEAudio` and :class:`~email.mime.image.MIMEImage`
class constructors to provide default encodings.  All encoder functions take
exactly one argument, the message object to encode.  They usually extract the
payload, encode it, and reset the payload to this newly encoded value.  They
should also set the :mailheader:`Content-Transfer-Encoding` header as appropriate.

Note that these functions are not meaningful for a multipart message.  They
must be applied to individual subparts instead, and will raise a
:exc:`TypeError` if passed a message whose type is multipart.

Here are the encoding functions provided:


.. function:: encode_quopri(msg)

   Encodes the payload into quoted-printable form and sets the
   :mailheader:`Content-Transfer-Encoding` header to ``quoted-printable`` [#]_.
   This is a good encoding to use when most of your payload is normal printable
   data, but contains a few unprintable characters.


.. function:: encode_base64(msg)

   Encodes the payload into base64 form and sets the
   :mailheader:`Content-Transfer-Encoding` header to ``base64``.  This is a good
   encoding to use when most of your payload is unprintable data since it is a more
   compact form than quoted-printable.  The drawback of base64 encoding is that it
   renders the text non-human readable.


.. function:: encode_7or8bit(msg)

   This doesn't actually modify the message's payload, but it does set the
   :mailheader:`Content-Transfer-Encoding` header to either ``7bit`` or ``8bit`` as
   appropriate, based on the payload data.


.. function:: encode_noop(msg)

   This does nothing; it doesn't even set the
   :mailheader:`Content-Transfer-Encoding` header.

.. rubric:: Footnotes

.. [#] Note that encoding with :meth:`encode_quopri` also encodes all tabs and space
   characters in the data.



================================================
File: /Doc/library/email.errors.rst
================================================
:mod:`!email.errors`: Exception and Defect classes
--------------------------------------------------

.. module:: email.errors
   :synopsis: The exception classes used by the email package.

**Source code:** :source:`Lib/email/errors.py`

--------------

The following exception classes are defined in the :mod:`email.errors` module:


.. exception:: MessageError()

   This is the base class for all exceptions that the :mod:`email` package can
   raise.  It is derived from the standard :exc:`Exception` class and defines no
   additional methods.


.. exception:: MessageParseError()

   This is the base class for exceptions raised by the
   :class:`~email.parser.Parser` class.  It is derived from
   :exc:`MessageError`.  This class is also used internally by the parser used
   by :mod:`~email.headerregistry`.


.. exception:: HeaderParseError()

   Raised under some error conditions when parsing the :rfc:`5322` headers of a
   message, this class is derived from :exc:`MessageParseError`.  The
   :meth:`~email.message.EmailMessage.set_boundary` method will raise this
   error if the content type is unknown when the method is called.
   :class:`~email.header.Header` may raise this error for certain base64
   decoding errors, and when an attempt is made to create a header that appears
   to contain an embedded header (that is, there is what is supposed to be a
   continuation line that has no leading whitespace and looks like a header).


.. exception:: BoundaryError()

   Deprecated and no longer used.


.. exception:: MultipartConversionError()

   Raised when a payload is added to a :class:`~email.message.Message` object
   using :meth:`add_payload`, but the payload is already a scalar and the
   message's :mailheader:`Content-Type` main type is not either
   :mimetype:`multipart` or missing.  :exc:`MultipartConversionError` multiply
   inherits from :exc:`MessageError` and the built-in :exc:`TypeError`.

   Since :meth:`Message.add_payload` is deprecated, this exception is rarely
   raised in practice.  However the exception may also be raised if the
   :meth:`~email.message.Message.attach`
   method is called on an instance of a class derived from
   :class:`~email.mime.nonmultipart.MIMENonMultipart` (e.g.
   :class:`~email.mime.image.MIMEImage`).


.. exception:: HeaderWriteError()

   Raised when an error occurs when the :mod:`~email.generator` outputs
   headers.


.. exception:: MessageDefect()

   This is the base class for all defects found when parsing email messages.
   It is derived from :exc:`ValueError`.

.. exception:: HeaderDefect()

   This is the base class for all defects found when parsing email headers.
   It is derived from :exc:`MessageDefect`.

Here is the list of the defects that the :class:`~email.parser.FeedParser`
can find while parsing messages.  Note that the defects are added to the message
where the problem was found, so for example, if a message nested inside a
:mimetype:`multipart/alternative` had a malformed header, that nested message
object would have a defect, but the containing messages would not.

All defect classes are subclassed from :class:`email.errors.MessageDefect`.

* :class:`NoBoundaryInMultipartDefect` -- A message claimed to be a multipart,
  but had no :mimetype:`boundary` parameter.

* :class:`StartBoundaryNotFoundDefect` -- The start boundary claimed in the
  :mailheader:`Content-Type` header was never found.

* :class:`CloseBoundaryNotFoundDefect` -- A start boundary was found, but
  no corresponding close boundary was ever found.

  .. versionadded:: 3.3

* :class:`FirstHeaderLineIsContinuationDefect` -- The message had a continuation
  line as its first header line.

* :class:`MisplacedEnvelopeHeaderDefect` - A "Unix From" header was found in the
  middle of a header block.

* :class:`MissingHeaderBodySeparatorDefect` - A line was found while parsing
  headers that had no leading white space but contained no ':'.  Parsing
  continues assuming that the line represents the first line of the body.

  .. versionadded:: 3.3

* :class:`MalformedHeaderDefect` -- A header was found that was missing a colon,
  or was otherwise malformed.

  .. deprecated:: 3.3
     This defect has not been used for several Python versions.

* :class:`MultipartInvariantViolationDefect` -- A message claimed to be a
  :mimetype:`multipart`, but no subparts were found.  Note that when a message
  has this defect, its :meth:`~email.message.Message.is_multipart` method may
  return ``False`` even though its content type claims to be :mimetype:`multipart`.

* :class:`InvalidBase64PaddingDefect` -- When decoding a block of base64
  encoded bytes, the padding was not correct.  Enough padding is added to
  perform the decode, but the resulting decoded bytes may be invalid.

* :class:`InvalidBase64CharactersDefect` -- When decoding a block of base64
  encoded bytes, characters outside the base64 alphabet were encountered.
  The characters are ignored, but the resulting decoded bytes may be invalid.

* :class:`InvalidBase64LengthDefect` -- When decoding a block of base64 encoded
  bytes, the number of non-padding base64 characters was invalid (1 more than
  a multiple of 4).  The encoded block was kept as-is.

* :class:`InvalidDateDefect` -- When decoding an invalid or unparsable date field.
  The original value is kept as-is.


================================================
File: /Doc/library/email.examples.rst
================================================
.. _email-examples:

:mod:`email`: Examples
----------------------

Here are a few examples of how to use the :mod:`email` package to read, write,
and send simple email messages, as well as more complex MIME messages.

First, let's see how to create and send a simple text message (both the
text content and the addresses may contain unicode characters):

.. literalinclude:: ../includes/email-simple.py


Parsing :rfc:`822` headers can easily be done by the using the classes
from the :mod:`~email.parser` module:

.. literalinclude:: ../includes/email-headers.py


Here's an example of how to send a MIME message containing a bunch of family
pictures that may be residing in a directory:

.. literalinclude:: ../includes/email-mime.py


Here's an example of how to send the entire contents of a directory as an email
message: [1]_

.. literalinclude:: ../includes/email-dir.py


Here's an example of how to unpack a MIME message like the one
above, into a directory of files:

.. literalinclude:: ../includes/email-unpack.py


Here's an example of how to create an HTML message with an alternative plain
text version.  To make things a bit more interesting, we include a related
image in the html part, and we save a copy of what we are going to send to
disk, as well as sending it.

.. literalinclude:: ../includes/email-alternative.py


If we were sent the message from the last example, here is one way we could
process it:

.. literalinclude:: ../includes/email-read-alternative.py

Up to the prompt, the output from the above is:

.. code-block:: none

    To: Penelope Pussycat <penelope@example.com>, Fabrette Pussycat <fabrette@example.com>
    From: Pepé Le Pew <pepe@example.com>
    Subject: Pourquoi pas des asperges pour ce midi ?

    Salut!

    Cette recette [1] sera sûrement un très bon repas.


.. rubric:: Footnotes

.. [1] Thanks to Matthew Dixon Cowles for the original inspiration and examples.


================================================
File: /Doc/library/email.generator.rst
================================================
:mod:`!email.generator`: Generating MIME documents
--------------------------------------------------

.. module:: email.generator
   :synopsis: Generate flat text email messages from a message structure.

**Source code:** :source:`Lib/email/generator.py`

--------------

One of the most common tasks is to generate the flat (serialized) version of
the email message represented by a message object structure.  You will need to
do this if you want to send your message via :meth:`smtplib.SMTP.sendmail`,
or print the message on the console.  Taking a
message object structure and producing a serialized representation is the job
of the generator classes.

As with the :mod:`email.parser` module, you aren't limited to the functionality
of the bundled generator; you could write one from scratch yourself.  However
the bundled generator knows how to generate most email in a standards-compliant
way, should handle MIME and non-MIME email messages just fine, and is designed
so that the bytes-oriented parsing and generation operations are inverses,
assuming the same non-transforming :mod:`~email.policy` is used for both.  That
is, parsing the serialized byte stream via the
:class:`~email.parser.BytesParser` class and then regenerating the serialized
byte stream using :class:`BytesGenerator` should produce output identical to
the input [#]_.  (On the other hand, using the generator on an
:class:`~email.message.EmailMessage` constructed by program may result in
changes to the :class:`~email.message.EmailMessage` object as defaults are
filled in.)

The :class:`Generator` class can be used to flatten a message into a text (as
opposed to binary) serialized representation, but since Unicode cannot
represent binary data directly, the message is of necessity transformed into
something that contains only ASCII characters, using the standard email RFC
Content Transfer Encoding techniques for encoding email messages for transport
over channels that are not "8 bit clean".

To accommodate reproducible processing of SMIME-signed messages
:class:`Generator` disables header folding for message parts of type
``multipart/signed`` and all subparts.


.. class:: BytesGenerator(outfp, mangle_from_=None, maxheaderlen=None, *, \
                          policy=None)

   Return a :class:`BytesGenerator` object that will write any message provided
   to the :meth:`flatten` method, or any surrogateescape encoded text provided
   to the :meth:`write` method, to the :term:`file-like object` *outfp*.
   *outfp* must support a ``write`` method that accepts binary data.

   If optional *mangle_from_* is ``True``, put a ``>`` character in front of
   any line in the body that starts with the exact string ``"From "``, that is
   ``From`` followed by a space at the beginning of a line.  *mangle_from_*
   defaults to the value of the :attr:`~email.policy.Policy.mangle_from_`
   setting of the *policy* (which is ``True`` for the
   :data:`~email.policy.compat32` policy and ``False`` for all others).
   *mangle_from_* is intended for use when messages are stored in Unix mbox
   format (see :mod:`mailbox` and `WHY THE CONTENT-LENGTH FORMAT IS BAD
   <https://www.jwz.org/doc/content-length.html>`_).

   If *maxheaderlen* is not ``None``, refold any header lines that are longer
   than *maxheaderlen*, or if ``0``, do not rewrap any headers.  If
   *manheaderlen* is ``None`` (the default), wrap headers and other message
   lines according to the *policy* settings.

   If *policy* is specified, use that policy to control message generation.  If
   *policy* is ``None`` (the default), use the policy associated with the
   :class:`~email.message.Message` or :class:`~email.message.EmailMessage`
   object passed to ``flatten`` to control the message generation.  See
   :mod:`email.policy` for details on what *policy* controls.

   .. versionadded:: 3.2

   .. versionchanged:: 3.3 Added the *policy* keyword.

   .. versionchanged:: 3.6 The default behavior of the *mangle_from_*
      and *maxheaderlen* parameters is to follow the policy.


   .. method:: flatten(msg, unixfrom=False, linesep=None)

      Print the textual representation of the message object structure rooted
      at *msg* to the output file specified when the :class:`BytesGenerator`
      instance was created.

      If the :mod:`~email.policy` option :attr:`~email.policy.Policy.cte_type`
      is ``8bit`` (the default), copy any headers in the original parsed
      message that have not been modified to the output with any bytes with the
      high bit set reproduced as in the original, and preserve the non-ASCII
      :mailheader:`Content-Transfer-Encoding` of any body parts that have them.
      If ``cte_type`` is ``7bit``, convert the bytes with the high bit set as
      needed using an ASCII-compatible :mailheader:`Content-Transfer-Encoding`.
      That is, transform parts with non-ASCII
      :mailheader:`Content-Transfer-Encoding`
      (:mailheader:`Content-Transfer-Encoding: 8bit`) to an ASCII compatible
      :mailheader:`Content-Transfer-Encoding`, and encode RFC-invalid non-ASCII
      bytes in headers using the MIME ``unknown-8bit`` character set, thus
      rendering them RFC-compliant.

      .. XXX: There should be an option that just does the RFC
         compliance transformation on headers but leaves CTE 8bit parts alone.

      If *unixfrom* is ``True``, print the envelope header delimiter used by
      the Unix mailbox format (see :mod:`mailbox`) before the first of the
      :rfc:`5322` headers of the root message object.  If the root object has
      no envelope header, craft a standard one.  The default is ``False``.
      Note that for subparts, no envelope header is ever printed.

      If *linesep* is not ``None``, use it as the separator character between
      all the lines of the flattened message.  If *linesep* is ``None`` (the
      default), use the value specified in the *policy*.

      .. XXX: flatten should take a *policy* keyword.


   .. method:: clone(fp)

      Return an independent clone of this :class:`BytesGenerator` instance with
      the exact same option settings, and *fp* as the new *outfp*.


   .. method:: write(s)

      Encode *s* using the ``ASCII`` codec and the ``surrogateescape`` error
      handler, and pass it to the *write* method of the *outfp* passed to the
      :class:`BytesGenerator`'s constructor.


As a convenience, :class:`~email.message.EmailMessage` provides the methods
:meth:`~email.message.EmailMessage.as_bytes` and ``bytes(aMessage)`` (a.k.a.
:meth:`~email.message.EmailMessage.__bytes__`), which simplify the generation of
a serialized binary representation of a message object.  For more detail, see
:mod:`email.message`.


Because strings cannot represent binary data, the :class:`Generator` class must
convert any binary data in any message it flattens to an ASCII compatible
format, by converting them to an ASCII compatible
:mailheader:`Content-Transfer_Encoding`.  Using the terminology of the email
RFCs, you can think of this as :class:`Generator` serializing to an I/O stream
that is not "8 bit clean".  In other words, most applications will want
to be using :class:`BytesGenerator`, and not :class:`Generator`.

.. class:: Generator(outfp, mangle_from_=None, maxheaderlen=None, *, \
                     policy=None)

   Return a :class:`Generator` object that will write any message provided
   to the :meth:`flatten` method, or any text provided to the :meth:`write`
   method, to the :term:`file-like object` *outfp*.  *outfp* must support a
   ``write`` method that accepts string data.

   If optional *mangle_from_* is ``True``, put a ``>`` character in front of
   any line in the body that starts with the exact string ``"From "``, that is
   ``From`` followed by a space at the beginning of a line.  *mangle_from_*
   defaults to the value of the :attr:`~email.policy.Policy.mangle_from_`
   setting of the *policy* (which is ``True`` for the
   :data:`~email.policy.compat32` policy and ``False`` for all others).
   *mangle_from_* is intended for use when messages are stored in Unix mbox
   format (see :mod:`mailbox` and `WHY THE CONTENT-LENGTH FORMAT IS BAD
   <https://www.jwz.org/doc/content-length.html>`_).

   If *maxheaderlen* is not ``None``, refold any header lines that are longer
   than *maxheaderlen*, or if ``0``, do not rewrap any headers.  If
   *manheaderlen* is ``None`` (the default), wrap headers and other message
   lines according to the *policy* settings.

   If *policy* is specified, use that policy to control message generation.  If
   *policy* is ``None`` (the default), use the policy associated with the
   :class:`~email.message.Message` or :class:`~email.message.EmailMessage`
   object passed to ``flatten`` to control the message generation.  See
   :mod:`email.policy` for details on what *policy* controls.

   .. versionchanged:: 3.3 Added the *policy* keyword.

   .. versionchanged:: 3.6 The default behavior of the *mangle_from_*
      and *maxheaderlen* parameters is to follow the policy.


   .. method:: flatten(msg, unixfrom=False, linesep=None)

      Print the textual representation of the message object structure rooted
      at *msg* to the output file specified when the :class:`Generator`
      instance was created.

      If the :mod:`~email.policy` option :attr:`~email.policy.Policy.cte_type`
      is ``8bit``, generate the message as if the option were set to ``7bit``.
      (This is required because strings cannot represent non-ASCII bytes.)
      Convert any bytes with the high bit set as needed using an
      ASCII-compatible :mailheader:`Content-Transfer-Encoding`.  That is,
      transform parts with non-ASCII :mailheader:`Content-Transfer-Encoding`
      (:mailheader:`Content-Transfer-Encoding: 8bit`) to an ASCII compatible
      :mailheader:`Content-Transfer-Encoding`, and encode RFC-invalid non-ASCII
      bytes in headers using the MIME ``unknown-8bit`` character set, thus
      rendering them RFC-compliant.

      If *unixfrom* is ``True``, print the envelope header delimiter used by
      the Unix mailbox format (see :mod:`mailbox`) before the first of the
      :rfc:`5322` headers of the root message object.  If the root object has
      no envelope header, craft a standard one.  The default is ``False``.
      Note that for subparts, no envelope header is ever printed.

      If *linesep* is not ``None``, use it as the separator character between
      all the lines of the flattened message.  If *linesep* is ``None`` (the
      default), use the value specified in the *policy*.

      .. XXX: flatten should take a *policy* keyword.

      .. versionchanged:: 3.2
         Added support for re-encoding ``8bit`` message bodies, and the
         *linesep* argument.


   .. method:: clone(fp)

      Return an independent clone of this :class:`Generator` instance with the
      exact same options, and *fp* as the new *outfp*.


   .. method:: write(s)

      Write *s* to the *write* method of the *outfp* passed to the
      :class:`Generator`'s constructor.  This provides just enough file-like
      API for :class:`Generator` instances to be used in the :func:`print`
      function.


As a convenience, :class:`~email.message.EmailMessage` provides the methods
:meth:`~email.message.EmailMessage.as_string` and ``str(aMessage)`` (a.k.a.
:meth:`~email.message.EmailMessage.__str__`), which simplify the generation of
a formatted string representation of a message object.  For more detail, see
:mod:`email.message`.


The :mod:`email.generator` module also provides a derived class,
:class:`DecodedGenerator`, which is like the :class:`Generator` base class,
except that non-\ :mimetype:`text` parts are not serialized, but are instead
represented in the output stream by a string derived from a template filled
in with information about the part.

.. class:: DecodedGenerator(outfp, mangle_from_=None, maxheaderlen=None, \
                            fmt=None, *, policy=None)

   Act like :class:`Generator`, except that for any subpart of the message
   passed to :meth:`Generator.flatten`, if the subpart is of main type
   :mimetype:`text`, print the decoded payload of the subpart, and if the main
   type is not :mimetype:`text`, instead of printing it fill in the string
   *fmt* using information from the part and print the resulting
   filled-in string.

   To fill in *fmt*, execute ``fmt % part_info``, where ``part_info``
   is a dictionary composed of the following keys and values:

   * ``type`` -- Full MIME type of the non-\ :mimetype:`text` part

   * ``maintype`` -- Main MIME type of the non-\ :mimetype:`text` part

   * ``subtype`` -- Sub-MIME type of the non-\ :mimetype:`text` part

   * ``filename`` -- Filename of the non-\ :mimetype:`text` part

   * ``description`` -- Description associated with the non-\ :mimetype:`text` part

   * ``encoding`` -- Content transfer encoding of the non-\ :mimetype:`text` part

   If *fmt* is ``None``, use the following default *fmt*:

      "[Non-text (%(type)s) part of message omitted, filename %(filename)s]"

   Optional *_mangle_from_* and *maxheaderlen* are as with the
   :class:`Generator` base class.


.. rubric:: Footnotes

.. [#] This statement assumes that you use the appropriate setting for
       ``unixfrom``, and that there are no :mod:`email.policy` settings calling for
       automatic adjustments (for example,
       :attr:`~email.policy.EmailPolicy.refold_source` must be ``none``, which is
       *not* the default).  It is also not 100% true, since if the message
       does not conform to the RFC standards occasionally information about the
       exact original text is lost during parsing error recovery.  It is a goal
       to fix these latter edge cases when possible.


================================================
File: /Doc/library/email.header.rst
================================================
:mod:`!email.header`: Internationalized headers
-----------------------------------------------

.. module:: email.header
   :synopsis: Representing non-ASCII headers

**Source code:** :source:`Lib/email/header.py`

--------------

This module is part of the legacy (``Compat32``) email API.  In the current API
encoding and decoding of headers is handled transparently by the
dictionary-like API of the :class:`~email.message.EmailMessage` class.  In
addition to uses in legacy code, this module can be useful in applications that
need to completely control the character sets used when encoding headers.

The remaining text in this section is the original documentation of the module.

:rfc:`2822` is the base standard that describes the format of email messages.
It derives from the older :rfc:`822` standard which came into widespread use at
a time when most email was composed of ASCII characters only.  :rfc:`2822` is a
specification written assuming email contains only 7-bit ASCII characters.

Of course, as email has been deployed worldwide, it has become
internationalized, such that language specific character sets can now be used in
email messages.  The base standard still requires email messages to be
transferred using only 7-bit ASCII characters, so a slew of RFCs have been
written describing how to encode email containing non-ASCII characters into
:rfc:`2822`\ -compliant format. These RFCs include :rfc:`2045`, :rfc:`2046`,
:rfc:`2047`, and :rfc:`2231`. The :mod:`email` package supports these standards
in its :mod:`email.header` and :mod:`email.charset` modules.

If you want to include non-ASCII characters in your email headers, say in the
:mailheader:`Subject` or :mailheader:`To` fields, you should use the
:class:`Header` class and assign the field in the :class:`~email.message.Message`
object to an instance of :class:`Header` instead of using a string for the header
value.  Import the :class:`Header` class from the :mod:`email.header` module.
For example::

   >>> from email.message import Message
   >>> from email.header import Header
   >>> msg = Message()
   >>> h = Header('p\xf6stal', 'iso-8859-1')
   >>> msg['Subject'] = h
   >>> msg.as_string()
   'Subject: =?iso-8859-1?q?p=F6stal?=\n\n'



Notice here how we wanted the :mailheader:`Subject` field to contain a non-ASCII
character?  We did this by creating a :class:`Header` instance and passing in
the character set that the byte string was encoded in.  When the subsequent
:class:`~email.message.Message` instance was flattened, the :mailheader:`Subject`
field was properly :rfc:`2047` encoded.  MIME-aware mail readers would show this
header using the embedded ISO-8859-1 character.

Here is the :class:`Header` class description:


.. class:: Header(s=None, charset=None, maxlinelen=None, header_name=None, continuation_ws=' ', errors='strict')

   Create a MIME-compliant header that can contain strings in different character
   sets.

   Optional *s* is the initial header value.  If ``None`` (the default), the
   initial header value is not set.  You can later append to the header with
   :meth:`append` method calls.  *s* may be an instance of :class:`bytes` or
   :class:`str`, but see the :meth:`append` documentation for semantics.

   Optional *charset* serves two purposes: it has the same meaning as the *charset*
   argument to the :meth:`append` method.  It also sets the default character set
   for all subsequent :meth:`append` calls that omit the *charset* argument.  If
   *charset* is not provided in the constructor (the default), the ``us-ascii``
   character set is used both as *s*'s initial charset and as the default for
   subsequent :meth:`append` calls.

   The maximum line length can be specified explicitly via *maxlinelen*.  For
   splitting the first line to a shorter value (to account for the field header
   which isn't included in *s*, e.g. :mailheader:`Subject`) pass in the name of the
   field in *header_name*.  The default *maxlinelen* is 78, and the default value
   for *header_name* is ``None``, meaning it is not taken into account for the
   first line of a long, split header.

   Optional *continuation_ws* must be :rfc:`2822`\ -compliant folding
   whitespace, and is usually either a space or a hard tab character.  This
   character will be prepended to continuation lines.  *continuation_ws*
   defaults to a single space character.

   Optional *errors* is passed straight through to the :meth:`append` method.


   .. method:: append(s, charset=None, errors='strict')

      Append the string *s* to the MIME header.

      Optional *charset*, if given, should be a :class:`~email.charset.Charset`
      instance (see :mod:`email.charset`) or the name of a character set, which
      will be converted to a :class:`~email.charset.Charset` instance.  A value
      of ``None`` (the default) means that the *charset* given in the constructor
      is used.

      *s* may be an instance of :class:`bytes` or :class:`str`.  If it is an
      instance of :class:`bytes`, then *charset* is the encoding of that byte
      string, and a :exc:`UnicodeError` will be raised if the string cannot be
      decoded with that character set.

      If *s* is an instance of :class:`str`, then *charset* is a hint specifying
      the character set of the characters in the string.

      In either case, when producing an :rfc:`2822`\ -compliant header using
      :rfc:`2047` rules, the string will be encoded using the output codec of
      the charset.  If the string cannot be encoded using the output codec, a
      UnicodeError will be raised.

      Optional *errors* is passed as the errors argument to the decode call
      if *s* is a byte string.


   .. method:: encode(splitchars=';, \t', maxlinelen=None, linesep='\n')

      Encode a message header into an RFC-compliant format, possibly wrapping
      long lines and encapsulating non-ASCII parts in base64 or quoted-printable
      encodings.

      Optional *splitchars* is a string containing characters which should be
      given extra weight by the splitting algorithm during normal header
      wrapping.  This is in very rough support of :RFC:`2822`\'s 'higher level
      syntactic breaks':  split points preceded by a splitchar are preferred
      during line splitting, with the characters preferred in the order in
      which they appear in the string.  Space and tab may be included in the
      string to indicate whether preference should be given to one over the
      other as a split point when other split chars do not appear in the line
      being split.  Splitchars does not affect :RFC:`2047` encoded lines.

      *maxlinelen*, if given, overrides the instance's value for the maximum
      line length.

      *linesep* specifies the characters used to separate the lines of the
      folded header.  It defaults to the most useful value for Python
      application code (``\n``), but ``\r\n`` can be specified in order
      to produce headers with RFC-compliant line separators.

      .. versionchanged:: 3.2
         Added the *linesep* argument.


   The :class:`Header` class also provides a number of methods to support
   standard operators and built-in functions.

   .. method:: __str__()

      Returns an approximation of the :class:`Header` as a string, using an
      unlimited line length.  All pieces are converted to unicode using the
      specified encoding and joined together appropriately.  Any pieces with a
      charset of ``'unknown-8bit'`` are decoded as ASCII using the ``'replace'``
      error handler.

      .. versionchanged:: 3.2
         Added handling for the ``'unknown-8bit'`` charset.


   .. method:: __eq__(other)

      This method allows you to compare two :class:`Header` instances for
      equality.


   .. method:: __ne__(other)

      This method allows you to compare two :class:`Header` instances for
      inequality.

The :mod:`email.header` module also provides the following convenient functions.


.. function:: decode_header(header)

   Decode a message header value without converting the character set. The header
   value is in *header*.

   This function returns a list of ``(decoded_string, charset)`` pairs containing
   each of the decoded parts of the header.  *charset* is ``None`` for non-encoded
   parts of the header, otherwise a lower case string containing the name of the
   character set specified in the encoded string.

   Here's an example::

      >>> from email.header import decode_header
      >>> decode_header('=?iso-8859-1?q?p=F6stal?=')
      [(b'p\xf6stal', 'iso-8859-1')]


.. function:: make_header(decoded_seq, maxlinelen=None, header_name=None, continuation_ws=' ')

   Create a :class:`Header` instance from a sequence of pairs as returned by
   :func:`decode_header`.

   :func:`decode_header` takes a header value string and returns a sequence of
   pairs of the format ``(decoded_string, charset)`` where *charset* is the name of
   the character set.

   This function takes one of those sequence of pairs and returns a
   :class:`Header` instance.  Optional *maxlinelen*, *header_name*, and
   *continuation_ws* are as in the :class:`Header` constructor.



================================================
File: /Doc/library/email.headerregistry.rst
================================================
:mod:`!email.headerregistry`: Custom Header Objects
---------------------------------------------------

.. module:: email.headerregistry
   :synopsis: Automatic Parsing of headers based on the field name

.. moduleauthor:: R. David Murray <rdmurray@bitdance.com>
.. sectionauthor:: R. David Murray <rdmurray@bitdance.com>

**Source code:** :source:`Lib/email/headerregistry.py`

--------------

.. versionadded:: 3.6 [1]_

Headers are represented by customized subclasses of :class:`str`.  The
particular class used to represent a given header is determined by the
:attr:`~email.policy.EmailPolicy.header_factory` of the :mod:`~email.policy` in
effect when the headers are created.  This section documents the particular
``header_factory`` implemented by the email package for handling :RFC:`5322`
compliant email messages, which not only provides customized header objects for
various header types, but also provides an extension mechanism for applications
to add their own custom header types.

When using any of the policy objects derived from
:data:`~email.policy.EmailPolicy`, all headers are produced by
:class:`.HeaderRegistry` and have :class:`.BaseHeader` as their last base
class.  Each header class has an additional base class that is determined by
the type of the header.  For example, many headers have the class
:class:`.UnstructuredHeader` as their other base class.  The specialized second
class for a header is determined by the name of the header, using a lookup
table stored in the :class:`.HeaderRegistry`.  All of this is managed
transparently for the typical application program, but interfaces are provided
for modifying the default behavior for use by more complex applications.

The sections below first document the header base classes and their attributes,
followed by the API for modifying the behavior of :class:`.HeaderRegistry`, and
finally the support classes used to represent the data parsed from structured
headers.


.. class:: BaseHeader(name, value)

   *name* and *value* are passed to ``BaseHeader`` from the
   :attr:`~email.policy.EmailPolicy.header_factory` call.  The string value of
   any header object is the *value* fully decoded to unicode.

   This base class defines the following read-only properties:


   .. attribute:: name

      The name of the header (the portion of the field before the ':').  This
      is exactly the value passed in the
      :attr:`~email.policy.EmailPolicy.header_factory` call for *name*; that
      is, case is preserved.


   .. attribute:: defects

      A tuple of :exc:`~email.errors.HeaderDefect` instances reporting any
      RFC compliance problems found during parsing.  The email package tries to
      be complete about detecting compliance issues.  See the :mod:`~email.errors`
      module for a discussion of the types of defects that may be reported.


   .. attribute:: max_count

      The maximum number of headers of this type that can have the same
      ``name``.  A value of ``None`` means unlimited.  The ``BaseHeader`` value
      for this attribute is ``None``; it is expected that specialized header
      classes will override this value as needed.

   ``BaseHeader`` also provides the following method, which is called by the
   email library code and should not in general be called by application
   programs:

   .. method:: fold(*, policy)

      Return a string containing :attr:`~email.policy.Policy.linesep`
      characters as required to correctly fold the header according to
      *policy*.  A :attr:`~email.policy.Policy.cte_type` of ``8bit`` will be
      treated as if it were ``7bit``, since headers may not contain arbitrary
      binary data.  If :attr:`~email.policy.EmailPolicy.utf8` is ``False``,
      non-ASCII data will be :rfc:`2047` encoded.


   ``BaseHeader`` by itself cannot be used to create a header object.  It
   defines a protocol that each specialized header cooperates with in order to
   produce the header object.  Specifically, ``BaseHeader`` requires that
   the specialized class provide a :func:`classmethod` named ``parse``.  This
   method is called as follows::

       parse(string, kwds)

   ``kwds`` is a dictionary containing one pre-initialized key, ``defects``.
   ``defects`` is an empty list.  The parse method should append any detected
   defects to this list.  On return, the ``kwds`` dictionary *must* contain
   values for at least the keys ``decoded`` and ``defects``.  ``decoded``
   should be the string value for the header (that is, the header value fully
   decoded to unicode).  The parse method should assume that *string* may
   contain content-transfer-encoded parts, but should correctly handle all valid
   unicode characters as well so that it can parse un-encoded header values.

   ``BaseHeader``'s ``__new__`` then creates the header instance, and calls its
   ``init`` method.  The specialized class only needs to provide an ``init``
   method if it wishes to set additional attributes beyond those provided by
   ``BaseHeader`` itself.  Such an ``init`` method should look like this::

       def init(self, /, *args, **kw):
           self._myattr = kw.pop('myattr')
           super().init(*args, **kw)

   That is, anything extra that the specialized class puts in to the ``kwds``
   dictionary should be removed and handled, and the remaining contents of
   ``kw`` (and ``args``) passed to the ``BaseHeader`` ``init`` method.


.. class:: UnstructuredHeader

   An "unstructured" header is the default type of header in :rfc:`5322`.
   Any header that does not have a specified syntax is treated as
   unstructured.  The classic example of an unstructured header is the
   :mailheader:`Subject` header.

   In :rfc:`5322`, an unstructured header is a run of arbitrary text in the
   ASCII character set.  :rfc:`2047`, however, has an :rfc:`5322` compatible
   mechanism for encoding non-ASCII text as ASCII characters within a header
   value.  When a *value* containing encoded words is passed to the
   constructor, the ``UnstructuredHeader`` parser converts such encoded words
   into unicode, following the :rfc:`2047` rules for unstructured text.  The
   parser uses heuristics to attempt to decode certain non-compliant encoded
   words.  Defects are registered in such cases, as well as defects for issues
   such as invalid characters within the encoded words or the non-encoded text.

   This header type provides no additional attributes.


.. class:: DateHeader

   :rfc:`5322` specifies a very specific format for dates within email headers.
   The ``DateHeader`` parser recognizes that date format, as well as
   recognizing a number of variant forms that are sometimes found "in the
   wild".

   This header type provides the following additional attributes:

   .. attribute:: datetime

      If the header value can be recognized as a valid date of one form or
      another, this attribute will contain a :class:`~datetime.datetime`
      instance representing that date.  If the timezone of the input date is
      specified as ``-0000`` (indicating it is in UTC but contains no
      information about the source timezone), then :attr:`.datetime` will be a
      naive :class:`~datetime.datetime`.  If a specific timezone offset is
      found (including ``+0000``), then :attr:`.datetime` will contain an aware
      ``datetime`` that uses :class:`datetime.timezone` to record the timezone
      offset.

   The ``decoded`` value of the header is determined by formatting the
   ``datetime`` according to the :rfc:`5322` rules; that is, it is set to::

       email.utils.format_datetime(self.datetime)

   When creating a ``DateHeader``, *value* may be
   :class:`~datetime.datetime` instance.  This means, for example, that
   the following code is valid and does what one would expect::

       msg['Date'] = datetime(2011, 7, 15, 21)

   Because this is a naive ``datetime`` it will be interpreted as a UTC
   timestamp, and the resulting value will have a timezone of ``-0000``.  Much
   more useful is to use the :func:`~email.utils.localtime` function from the
   :mod:`~email.utils` module::

       msg['Date'] = utils.localtime()

   This example sets the date header to the current time and date using
   the current timezone offset.


.. class:: AddressHeader

   Address headers are one of the most complex structured header types.
   The ``AddressHeader`` class provides a generic interface to any address
   header.

   This header type provides the following additional attributes:


   .. attribute:: groups

      A tuple of :class:`.Group` objects encoding the
      addresses and groups found in the header value.  Addresses that are
      not part of a group are represented in this list as single-address
      ``Groups`` whose :attr:`~.Group.display_name` is ``None``.


   .. attribute:: addresses

      A tuple of :class:`.Address` objects encoding all
      of the individual addresses from the header value.  If the header value
      contains any groups, the individual addresses from the group are included
      in the list at the point where the group occurs in the value (that is,
      the list of addresses is "flattened" into a one dimensional list).

   The ``decoded`` value of the header will have all encoded words decoded to
   unicode.  :class:`~encodings.idna` encoded domain names are also decoded to
   unicode.  The ``decoded`` value is set by :ref:`joining <meth-str-join>` the
   :class:`str` value of the elements of the ``groups`` attribute with ``',
   '``.

   A list of :class:`.Address` and :class:`.Group` objects in any combination
   may be used to set the value of an address header.  ``Group`` objects whose
   ``display_name`` is ``None`` will be interpreted as single addresses, which
   allows an address list to be copied with groups intact by using the list
   obtained from the ``groups`` attribute of the source header.


.. class:: SingleAddressHeader

   A subclass of :class:`.AddressHeader` that adds one
   additional attribute:


   .. attribute:: address

      The single address encoded by the header value.  If the header value
      actually contains more than one address (which would be a violation of
      the RFC under the default :mod:`~email.policy`), accessing this attribute
      will result in a :exc:`ValueError`.


Many of the above classes also have a ``Unique`` variant (for example,
``UniqueUnstructuredHeader``).  The only difference is that in the ``Unique``
variant, :attr:`~.BaseHeader.max_count` is set to 1.


.. class:: MIMEVersionHeader

   There is really only one valid value for the :mailheader:`MIME-Version`
   header, and that is ``1.0``.  For future proofing, this header class
   supports other valid version numbers.  If a version number has a valid value
   per :rfc:`2045`, then the header object will have non-``None`` values for
   the following attributes:

   .. attribute:: version

      The version number as a string, with any whitespace and/or comments
      removed.

   .. attribute:: major

      The major version number as an integer

   .. attribute:: minor

      The minor version number as an integer


.. class:: ParameterizedMIMEHeader

    MIME headers all start with the prefix 'Content-'.  Each specific header has
    a certain value, described under the class for that header.  Some can
    also take a list of supplemental parameters, which have a common format.
    This class serves as a base for all the MIME headers that take parameters.

    .. attribute:: params

       A dictionary mapping parameter names to parameter values.


.. class:: ContentTypeHeader

    A :class:`ParameterizedMIMEHeader` class that handles the
    :mailheader:`Content-Type` header.

    .. attribute:: content_type

       The content type string, in the form ``maintype/subtype``.

    .. attribute:: maintype

    .. attribute:: subtype


.. class:: ContentDispositionHeader

    A :class:`ParameterizedMIMEHeader` class that handles the
    :mailheader:`Content-Disposition` header.

    .. attribute:: content_disposition

       ``inline`` and ``attachment`` are the only valid values in common use.


.. class:: ContentTransferEncoding

   Handles the :mailheader:`Content-Transfer-Encoding` header.

   .. attribute:: cte

      Valid values are ``7bit``, ``8bit``, ``base64``, and
      ``quoted-printable``.  See :rfc:`2045` for more information.



.. class:: HeaderRegistry(base_class=BaseHeader, \
                          default_class=UnstructuredHeader, \
                          use_default_map=True)

    This is the factory used by :class:`~email.policy.EmailPolicy` by default.
    ``HeaderRegistry`` builds the class used to create a header instance
    dynamically, using *base_class* and a specialized class retrieved from a
    registry that it holds.  When a given header name does not appear in the
    registry, the class specified by *default_class* is used as the specialized
    class.  When *use_default_map* is ``True`` (the default), the standard
    mapping of header names to classes is copied in to the registry during
    initialization.  *base_class* is always the last class in the generated
    class's :class:`~type.__bases__` list.

    The default mappings are:

      :subject:                   UniqueUnstructuredHeader
      :date:                      UniqueDateHeader
      :resent-date:               DateHeader
      :orig-date:                 UniqueDateHeader
      :sender:                    UniqueSingleAddressHeader
      :resent-sender:             SingleAddressHeader
      :to:                        UniqueAddressHeader
      :resent-to:                 AddressHeader
      :cc:                        UniqueAddressHeader
      :resent-cc:                 AddressHeader
      :bcc:                       UniqueAddressHeader
      :resent-bcc:                AddressHeader
      :from:                      UniqueAddressHeader
      :resent-from:               AddressHeader
      :reply-to:                  UniqueAddressHeader
      :mime-version:              MIMEVersionHeader
      :content-type:              ContentTypeHeader
      :content-disposition:       ContentDispositionHeader
      :content-transfer-encoding: ContentTransferEncodingHeader
      :message-id:                MessageIDHeader

    ``HeaderRegistry`` has the following methods:


    .. method:: map_to_type(self, name, cls)

       *name* is the name of the header to be mapped.  It will be converted to
       lower case in the registry.  *cls* is the specialized class to be used,
       along with *base_class*, to create the class used to instantiate headers
       that match *name*.


    .. method:: __getitem__(name)

       Construct and return a class to handle creating a *name* header.


    .. method:: __call__(name, value)

       Retrieves the specialized header associated with *name* from the
       registry (using *default_class* if *name* does not appear in the
       registry) and composes it with *base_class* to produce a class,
       calls the constructed class's constructor, passing it the same
       argument list, and finally returns the class instance created thereby.


The following classes are the classes used to represent data parsed from
structured headers and can, in general, be used by an application program to
construct structured values to assign to specific headers.


.. class:: Address(display_name='', username='', domain='', addr_spec=None)

   The class used to represent an email address.  The general form of an
   address is::

      [display_name] <username@domain>

   or::

      username@domain

   where each part must conform to specific syntax rules spelled out in
   :rfc:`5322`.

   As a convenience *addr_spec* can be specified instead of *username* and
   *domain*, in which case *username* and *domain* will be parsed from the
   *addr_spec*.  An *addr_spec* must be a properly RFC quoted string; if it is
   not ``Address`` will raise an error.  Unicode characters are allowed and
   will be property encoded when serialized.  However, per the RFCs, unicode is
   *not* allowed in the username portion of the address.

   .. attribute:: display_name

      The display name portion of the address, if any, with all quoting
      removed.  If the address does not have a display name, this attribute
      will be an empty string.

   .. attribute:: username

      The ``username`` portion of the address, with all quoting removed.

   .. attribute:: domain

      The ``domain`` portion of the address.

   .. attribute:: addr_spec

      The ``username@domain`` portion of the address, correctly quoted
      for use as a bare address (the second form shown above).  This
      attribute is not mutable.

   .. method:: __str__()

      The ``str`` value of the object is the address quoted according to
      :rfc:`5322` rules, but with no Content Transfer Encoding of any non-ASCII
      characters.

   To support SMTP (:rfc:`5321`), ``Address`` handles one special case: if
   ``username`` and ``domain`` are both the empty string (or ``None``), then
   the string value of the ``Address`` is ``<>``.


.. class:: Group(display_name=None, addresses=None)

   The class used to represent an address group.  The general form of an
   address group is::

     display_name: [address-list];

   As a convenience for processing lists of addresses that consist of a mixture
   of groups and single addresses, a ``Group`` may also be used to represent
   single addresses that are not part of a group by setting *display_name* to
   ``None`` and providing a list of the single address as *addresses*.

   .. attribute:: display_name

      The ``display_name`` of the group.  If it is ``None`` and there is
      exactly one ``Address`` in ``addresses``, then the ``Group`` represents a
      single address that is not in a group.

   .. attribute:: addresses

      A possibly empty tuple of :class:`.Address` objects representing the
      addresses in the group.

   .. method:: __str__()

      The ``str`` value of a ``Group`` is formatted according to :rfc:`5322`,
      but with no Content Transfer Encoding of any non-ASCII characters.  If
      ``display_name`` is none and there is a single ``Address`` in the
      ``addresses`` list, the ``str`` value will be the same as the ``str`` of
      that single ``Address``.


.. rubric:: Footnotes

.. [1] Originally added in 3.3 as a :term:`provisional module <provisional
       package>`


================================================
File: /Doc/library/email.iterators.rst
================================================
:mod:`!email.iterators`: Iterators
----------------------------------

.. module:: email.iterators
   :synopsis: Iterate over a  message object tree.

**Source code:** :source:`Lib/email/iterators.py`

--------------

Iterating over a message object tree is fairly easy with the
:meth:`Message.walk <email.message.Message.walk>` method.  The
:mod:`email.iterators` module provides some useful higher level iterations over
message object trees.


.. function:: body_line_iterator(msg, decode=False)

   This iterates over all the payloads in all the subparts of *msg*, returning the
   string payloads line-by-line.  It skips over all the subpart headers, and it
   skips over any subpart with a payload that isn't a Python string.  This is
   somewhat equivalent to reading the flat text representation of the message from
   a file using :meth:`~io.TextIOBase.readline`, skipping over all the
   intervening headers.

   Optional *decode* is passed through to :meth:`Message.get_payload
   <email.message.Message.get_payload>`.


.. function:: typed_subpart_iterator(msg, maintype='text', subtype=None)

   This iterates over all the subparts of *msg*, returning only those subparts that
   match the MIME type specified by *maintype* and *subtype*.

   Note that *subtype* is optional; if omitted, then subpart MIME type matching is
   done only with the main type.  *maintype* is optional too; it defaults to
   :mimetype:`text`.

   Thus, by default :func:`typed_subpart_iterator` returns each subpart that has a
   MIME type of :mimetype:`text/\*`.


The following function has been added as a useful debugging tool.  It should
*not* be considered part of the supported public interface for the package.

.. function:: _structure(msg, fp=None, level=0, include_default=False)

   Prints an indented representation of the content types of the message object
   structure.  For example:

   .. testsetup::

      import email
      from email.iterators import _structure
      somefile = open('../Lib/test/test_email/data/msg_02.txt')

   .. doctest::

      >>> msg = email.message_from_file(somefile)
      >>> _structure(msg)
      multipart/mixed
          text/plain
          text/plain
          multipart/digest
              message/rfc822
                  text/plain
              message/rfc822
                  text/plain
              message/rfc822
                  text/plain
              message/rfc822
                  text/plain
              message/rfc822
                  text/plain
          text/plain

   .. testcleanup::

      somefile.close()

   Optional *fp* is a file-like object to print the output to.  It must be
   suitable for Python's :func:`print` function.  *level* is used internally.
   *include_default*, if true, prints the default type as well.


================================================
File: /Doc/library/email.message.rst
================================================
:mod:`!email.message`: Representing an email message
----------------------------------------------------

.. module:: email.message
   :synopsis: The base class representing email messages.
.. moduleauthor:: R. David Murray <rdmurray@bitdance.com>
.. sectionauthor:: R. David Murray <rdmurray@bitdance.com>,
                   Barry A. Warsaw <barry@python.org>

**Source code:** :source:`Lib/email/message.py`

--------------

.. versionadded:: 3.6 [1]_

The central class in the :mod:`email` package is the :class:`EmailMessage`
class, imported from the :mod:`email.message` module.  It is the base class for
the :mod:`email` object model.  :class:`EmailMessage` provides the core
functionality for setting and querying header fields, for accessing message
bodies, and for creating or modifying structured messages.

An email message consists of *headers* and a *payload* (which is also referred
to as the *content*).  Headers are :rfc:`5322` or :rfc:`6532` style field names
and values, where the field name and value are separated by a colon.  The colon
is not part of either the field name or the field value.  The payload may be a
simple text message, or a binary object, or a structured sequence of
sub-messages each with their own set of headers and their own payload.  The
latter type of payload is indicated by the message having a MIME type such as
:mimetype:`multipart/\*` or :mimetype:`message/rfc822`.

The conceptual model provided by an :class:`EmailMessage` object is that of an
ordered dictionary of headers coupled with a *payload* that represents the
:rfc:`5322` body of the message, which might be a list of sub-``EmailMessage``
objects.  In addition to the normal dictionary methods for accessing the header
names and values, there are methods for accessing specialized information from
the headers (for example the MIME content type), for operating on the payload,
for generating a serialized version of the message, and for recursively walking
over the object tree.

The :class:`EmailMessage` dictionary-like interface is indexed by the header
names, which must be ASCII values.  The values of the dictionary are strings
with some extra methods.  Headers are stored and returned in case-preserving
form, but field names are matched case-insensitively.  The keys are ordered,
but unlike a real dict, there can be duplicates.  Additional methods are
provided for working with headers that have duplicate keys.

The *payload* is either a string or bytes object, in the case of simple message
objects, or a list of :class:`EmailMessage` objects, for MIME container
documents such as :mimetype:`multipart/\*` and :mimetype:`message/rfc822`
message objects.


.. class:: EmailMessage(policy=default)

   If *policy* is specified use the rules it specifies to update and serialize
   the representation of the message.  If *policy* is not set, use the
   :class:`~email.policy.default` policy, which follows the rules of the email
   RFCs except for line endings (instead of the RFC mandated ``\r\n``, it uses
   the Python standard ``\n`` line endings).  For more information see the
   :mod:`~email.policy` documentation.

   .. method:: as_string(unixfrom=False, maxheaderlen=None, policy=None)

      Return the entire message flattened as a string.  When optional
      *unixfrom* is true, the envelope header is included in the returned
      string.  *unixfrom* defaults to ``False``.  For backward compatibility
      with the base :class:`~email.message.Message` class *maxheaderlen* is
      accepted, but defaults to ``None``, which means that by default the line
      length is controlled by the
      :attr:`~email.policy.Policy.max_line_length` of the policy.  The
      *policy* argument may be used to override the default policy obtained
      from the message instance.  This can be used to control some of the
      formatting produced by the method, since the specified *policy* will be
      passed to the :class:`~email.generator.Generator`.

      Flattening the message may trigger changes to the :class:`EmailMessage`
      if defaults need to be filled in to complete the transformation to a
      string (for example, MIME boundaries may be generated or modified).

      Note that this method is provided as a convenience and may not be the
      most useful way to serialize messages in your application, especially if
      you are dealing with multiple messages.  See
      :class:`email.generator.Generator` for a more flexible API for
      serializing messages.  Note also that this method is restricted to
      producing messages serialized as "7 bit clean" when
      :attr:`~email.policy.EmailPolicy.utf8` is ``False``, which is the default.

      .. versionchanged:: 3.6 the default behavior when *maxheaderlen*
         is not specified was changed from defaulting to 0 to defaulting
         to the value of *max_line_length* from the policy.


   .. method:: __str__()

      Equivalent to ``as_string(policy=self.policy.clone(utf8=True))``.  Allows
      ``str(msg)`` to produce a string containing the serialized message in a
      readable format.

      .. versionchanged:: 3.4 the method was changed to use ``utf8=True``,
         thus producing an :rfc:`6531`-like message representation, instead of
         being a direct alias for :meth:`as_string`.


   .. method:: as_bytes(unixfrom=False, policy=None)

      Return the entire message flattened as a bytes object.  When optional
      *unixfrom* is true, the envelope header is included in the returned
      string.  *unixfrom* defaults to ``False``.  The *policy* argument may be
      used to override the default policy obtained from the message instance.
      This can be used to control some of the formatting produced by the
      method, since the specified *policy* will be passed to the
      :class:`~email.generator.BytesGenerator`.

      Flattening the message may trigger changes to the :class:`EmailMessage`
      if defaults need to be filled in to complete the transformation to a
      string (for example, MIME boundaries may be generated or modified).

      Note that this method is provided as a convenience and may not be the
      most useful way to serialize messages in your application, especially if
      you are dealing with multiple messages.  See
      :class:`email.generator.BytesGenerator` for a more flexible API for
      serializing messages.


   .. method:: __bytes__()

      Equivalent to :meth:`.as_bytes`.  Allows ``bytes(msg)`` to produce a
      bytes object containing the serialized message.


   .. method:: is_multipart()

      Return ``True`` if the message's payload is a list of
      sub-\ :class:`EmailMessage` objects, otherwise return ``False``.  When
      :meth:`is_multipart` returns ``False``, the payload should be a string
      object (which might be a CTE encoded binary payload).  Note that
      :meth:`is_multipart` returning ``True`` does not necessarily mean that
      "msg.get_content_maintype() == 'multipart'" will return the ``True``.
      For example, ``is_multipart`` will return ``True`` when the
      :class:`EmailMessage` is of type ``message/rfc822``.


   .. method:: set_unixfrom(unixfrom)

      Set the message's envelope header to *unixfrom*, which should be a
      string.  (See :class:`~mailbox.mboxMessage` for a brief description of
      this header.)


   .. method:: get_unixfrom()

      Return the message's envelope header.  Defaults to ``None`` if the
      envelope header was never set.


   The following methods implement the mapping-like interface for accessing the
   message's headers.  Note that there are some semantic differences
   between these methods and a normal mapping (i.e. dictionary) interface.  For
   example, in a dictionary there are no duplicate keys, but here there may be
   duplicate message headers.  Also, in dictionaries there is no guaranteed
   order to the keys returned by :meth:`keys`, but in an :class:`EmailMessage`
   object, headers are always returned in the order they appeared in the
   original message, or in which they were added to the message later.  Any
   header deleted and then re-added is always appended to the end of the
   header list.

   These semantic differences are intentional and are biased toward
   convenience in the most common use cases.

   Note that in all cases, any envelope header present in the message is not
   included in the mapping interface.


   .. method:: __len__()

      Return the total number of headers, including duplicates.


   .. method:: __contains__(name)

      Return ``True`` if the message object has a field named *name*. Matching is
      done without regard to case and *name* does not include the trailing
      colon.  Used for the ``in`` operator.  For example::

           if 'message-id' in myMessage:
              print('Message-ID:', myMessage['message-id'])


   .. method:: __getitem__(name)

      Return the value of the named header field.  *name* does not include the
      colon field separator.  If the header is missing, ``None`` is returned; a
      :exc:`KeyError` is never raised.

      Note that if the named field appears more than once in the message's
      headers, exactly which of those field values will be returned is
      undefined.  Use the :meth:`get_all` method to get the values of all the
      extant headers named *name*.

      Using the standard (non-``compat32``) policies, the returned value is an
      instance of a subclass of :class:`email.headerregistry.BaseHeader`.


   .. method:: __setitem__(name, val)

      Add a header to the message with field name *name* and value *val*.  The
      field is appended to the end of the message's existing headers.

      Note that this does *not* overwrite or delete any existing header with the same
      name.  If you want to ensure that the new header is the only one present in the
      message with field name *name*, delete the field first, e.g.::

         del msg['subject']
         msg['subject'] = 'Python roolz!'

      If the :mod:`policy <email.policy>` defines certain headers to be unique (as the standard
      policies do), this method may raise a :exc:`ValueError` when an attempt
      is made to assign a value to such a header when one already exists.  This
      behavior is intentional for consistency's sake, but do not depend on it
      as we may choose to make such assignments do an automatic deletion of the
      existing header in the future.


   .. method:: __delitem__(name)

      Delete all occurrences of the field with name *name* from the message's
      headers.  No exception is raised if the named field isn't present in the
      headers.


   .. method:: keys()

      Return a list of all the message's header field names.


   .. method:: values()

      Return a list of all the message's field values.


   .. method:: items()

      Return a list of 2-tuples containing all the message's field headers and
      values.


   .. method:: get(name, failobj=None)

      Return the value of the named header field.  This is identical to
      :meth:`~object.__getitem__` except that optional *failobj* is returned if the
      named header is missing (*failobj* defaults to ``None``).


   Here are some additional useful header related methods:


   .. method:: get_all(name, failobj=None)

      Return a list of all the values for the field named *name*. If there are
      no such named headers in the message, *failobj* is returned (defaults to
      ``None``).


   .. method:: add_header(_name, _value, **_params)

      Extended header setting.  This method is similar to :meth:`__setitem__`
      except that additional header parameters can be provided as keyword
      arguments.  *_name* is the header field to add and *_value* is the
      *primary* value for the header.

      For each item in the keyword argument dictionary *_params*, the key is
      taken as the parameter name, with underscores converted to dashes (since
      dashes are illegal in Python identifiers).  Normally, the parameter will
      be added as ``key="value"`` unless the value is ``None``, in which case
      only the key will be added.

      If the value contains non-ASCII characters, the charset and language may
      be explicitly controlled by specifying the value as a three tuple in the
      format ``(CHARSET, LANGUAGE, VALUE)``, where ``CHARSET`` is a string
      naming the charset to be used to encode the value, ``LANGUAGE`` can
      usually be set to ``None`` or the empty string (see :rfc:`2231` for other
      possibilities), and ``VALUE`` is the string value containing non-ASCII
      code points.  If a three tuple is not passed and the value contains
      non-ASCII characters, it is automatically encoded in :rfc:`2231` format
      using a ``CHARSET`` of ``utf-8`` and a ``LANGUAGE`` of ``None``.

      Here is an example::

         msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')

      This will add a header that looks like ::

         Content-Disposition: attachment; filename="bud.gif"

      An example of the extended interface with non-ASCII characters::

         msg.add_header('Content-Disposition', 'attachment',
                        filename=('iso-8859-1', '', 'Fußballer.ppt'))


   .. method:: replace_header(_name, _value)

      Replace a header.  Replace the first header found in the message that
      matches *_name*, retaining header order and field name case of the
      original header.  If no matching header is found, raise a
      :exc:`KeyError`.


   .. method:: get_content_type()

      Return the message's content type, coerced to lower case of the form
      :mimetype:`maintype/subtype`.  If there is no :mailheader:`Content-Type`
      header in the message return the value returned by
      :meth:`get_default_type`.  If the :mailheader:`Content-Type` header is
      invalid, return ``text/plain``.

      (According to :rfc:`2045`, messages always have a default type,
      :meth:`get_content_type` will always return a value.  :rfc:`2045` defines
      a message's default type to be :mimetype:`text/plain` unless it appears
      inside a :mimetype:`multipart/digest` container, in which case it would
      be :mimetype:`message/rfc822`.  If the :mailheader:`Content-Type` header
      has an invalid type specification, :rfc:`2045` mandates that the default
      type be :mimetype:`text/plain`.)


   .. method:: get_content_maintype()

      Return the message's main content type.  This is the :mimetype:`maintype`
      part of the string returned by :meth:`get_content_type`.


   .. method:: get_content_subtype()

      Return the message's sub-content type.  This is the :mimetype:`subtype`
      part of the string returned by :meth:`get_content_type`.


   .. method:: get_default_type()

      Return the default content type.  Most messages have a default content
      type of :mimetype:`text/plain`, except for messages that are subparts of
      :mimetype:`multipart/digest` containers.  Such subparts have a default
      content type of :mimetype:`message/rfc822`.


   .. method:: set_default_type(ctype)

      Set the default content type.  *ctype* should either be
      :mimetype:`text/plain` or :mimetype:`message/rfc822`, although this is
      not enforced.  The default content type is not stored in the
      :mailheader:`Content-Type` header, so it only affects the return value of
      the ``get_content_type`` methods when no :mailheader:`Content-Type`
      header is present in the message.


   .. method:: set_param(param, value, header='Content-Type', requote=True, \
                         charset=None, language='', replace=False)

      Set a parameter in the :mailheader:`Content-Type` header.  If the
      parameter already exists in the header, replace its value with *value*.
      When *header* is ``Content-Type`` (the default) and the header does not
      yet exist in the message, add it, set its value to
      :mimetype:`text/plain`, and append the new parameter value.  Optional
      *header* specifies an alternative header to :mailheader:`Content-Type`.

      If the value contains non-ASCII characters, the charset and language may
      be explicitly specified using the optional *charset* and *language*
      parameters.  Optional *language* specifies the :rfc:`2231` language,
      defaulting to the empty string.  Both *charset* and *language* should be
      strings.  The default is to use the ``utf8`` *charset* and ``None`` for
      the *language*.

      If *replace* is ``False`` (the default) the header is moved to the
      end of the list of headers.  If *replace* is ``True``, the header
      will be updated in place.

      Use of the *requote* parameter with :class:`EmailMessage` objects is
      deprecated.

      Note that existing parameter values of headers may be accessed through
      the :attr:`~email.headerregistry.ParameterizedMIMEHeader.params` attribute of the
      header value (for example, ``msg['Content-Type'].params['charset']``).

      .. versionchanged:: 3.4 ``replace`` keyword was added.


   .. method:: del_param(param, header='content-type', requote=True)

      Remove the given parameter completely from the :mailheader:`Content-Type`
      header.  The header will be re-written in place without the parameter or
      its value.  Optional *header* specifies an alternative to
      :mailheader:`Content-Type`.

      Use of the *requote* parameter with :class:`EmailMessage` objects is
      deprecated.


   .. method:: get_filename(failobj=None)

      Return the value of the ``filename`` parameter of the
      :mailheader:`Content-Disposition` header of the message.  If the header
      does not have a ``filename`` parameter, this method falls back to looking
      for the ``name`` parameter on the :mailheader:`Content-Type` header.  If
      neither is found, or the header is missing, then *failobj* is returned.
      The returned string will always be unquoted as per
      :func:`email.utils.unquote`.


   .. method:: get_boundary(failobj=None)

      Return the value of the ``boundary`` parameter of the
      :mailheader:`Content-Type` header of the message, or *failobj* if either
      the header is missing, or has no ``boundary`` parameter.  The returned
      string will always be unquoted as per :func:`email.utils.unquote`.


   .. method:: set_boundary(boundary)

      Set the ``boundary`` parameter of the :mailheader:`Content-Type` header to
      *boundary*.  :meth:`set_boundary` will always quote *boundary* if
      necessary.  A :exc:`~email.errors.HeaderParseError` is raised if the
      message object has no :mailheader:`Content-Type` header.

      Note that using this method is subtly different from deleting the old
      :mailheader:`Content-Type` header and adding a new one with the new
      boundary via :meth:`add_header`, because :meth:`set_boundary` preserves
      the order of the :mailheader:`Content-Type` header in the list of
      headers.


   .. method:: get_content_charset(failobj=None)

      Return the ``charset`` parameter of the :mailheader:`Content-Type` header,
      coerced to lower case.  If there is no :mailheader:`Content-Type` header, or if
      that header has no ``charset`` parameter, *failobj* is returned.


   .. method:: get_charsets(failobj=None)

      Return a list containing the character set names in the message.  If the
      message is a :mimetype:`multipart`, then the list will contain one element
      for each subpart in the payload, otherwise, it will be a list of length 1.

      Each item in the list will be a string which is the value of the
      ``charset`` parameter in the :mailheader:`Content-Type` header for the
      represented subpart.  If the subpart has no :mailheader:`Content-Type`
      header, no ``charset`` parameter, or is not of the :mimetype:`text` main
      MIME type, then that item in the returned list will be *failobj*.


   .. method:: is_attachment

      Return ``True`` if there is a :mailheader:`Content-Disposition` header
      and its (case insensitive) value is ``attachment``, ``False`` otherwise.

      .. versionchanged:: 3.4.2
         is_attachment is now a method instead of a property, for consistency
         with :meth:`~email.message.Message.is_multipart`.


   .. method:: get_content_disposition()

      Return the lowercased value (without parameters) of the message's
      :mailheader:`Content-Disposition` header if it has one, or ``None``.  The
      possible values for this method are *inline*, *attachment* or ``None``
      if the message follows :rfc:`2183`.

      .. versionadded:: 3.5


   The following methods relate to interrogating and manipulating the content
   (payload) of the message.


   .. method:: walk()

      The :meth:`walk` method is an all-purpose generator which can be used to
      iterate over all the parts and subparts of a message object tree, in
      depth-first traversal order.  You will typically use :meth:`walk` as the
      iterator in a ``for`` loop; each iteration returns the next subpart.

      Here's an example that prints the MIME type of every part of a multipart
      message structure:

      .. testsetup::

         from email import message_from_binary_file
         with open('../Lib/test/test_email/data/msg_16.txt', 'rb') as f:
             msg = message_from_binary_file(f)

      .. doctest::

         >>> for part in msg.walk():
         ...     print(part.get_content_type())
         multipart/report
         text/plain
         message/delivery-status
         text/plain
         text/plain
         message/rfc822
         text/plain

      ``walk`` iterates over the subparts of any part where
      :meth:`is_multipart` returns ``True``, even though
      ``msg.get_content_maintype() == 'multipart'`` may return ``False``.  We
      can see this in our example by making use of the ``_structure`` debug
      helper function:

      .. doctest::

         >>> from email.iterators import _structure
         >>> for part in msg.walk():
         ...     print(part.get_content_maintype() == 'multipart',
         ...           part.is_multipart())
         True True
         False False
         False True
         False False
         False False
         False True
         False False
         >>> _structure(msg)
         multipart/report
             text/plain
             message/delivery-status
                 text/plain
                 text/plain
             message/rfc822
                 text/plain

      Here the ``message`` parts are not ``multiparts``, but they do contain
      subparts. ``is_multipart()`` returns ``True`` and ``walk`` descends
      into the subparts.


   .. method:: get_body(preferencelist=('related', 'html', 'plain'))

      Return the MIME part that is the best candidate to be the "body" of the
      message.

      *preferencelist* must be a sequence of strings from the set ``related``,
      ``html``, and ``plain``, and indicates the order of preference for the
      content type of the part returned.

      Start looking for candidate matches with the object on which the
      ``get_body`` method is called.

      If ``related`` is not included in *preferencelist*, consider the root
      part (or subpart of the root part) of any related encountered as a
      candidate if the (sub-)part matches a preference.

      When encountering a ``multipart/related``, check the ``start`` parameter
      and if a part with a matching :mailheader:`Content-ID` is found, consider
      only it when looking for candidate matches.  Otherwise consider only the
      first (default root) part of the ``multipart/related``.

      If a part has a :mailheader:`Content-Disposition` header, only consider
      the part a candidate match if the value of the header is ``inline``.

      If none of the candidates matches any of the preferences in
      *preferencelist*, return ``None``.

      Notes: (1) For most applications the only *preferencelist* combinations
      that really make sense are ``('plain',)``, ``('html', 'plain')``, and the
      default ``('related', 'html', 'plain')``.  (2) Because matching starts
      with the object on which ``get_body`` is called, calling ``get_body`` on
      a ``multipart/related`` will return the object itself unless
      *preferencelist* has a non-default value. (3) Messages (or message parts)
      that do not specify a :mailheader:`Content-Type` or whose
      :mailheader:`Content-Type` header is invalid will be treated as if they
      are of type ``text/plain``, which may occasionally cause ``get_body`` to
      return unexpected results.


   .. method:: iter_attachments()

      Return an iterator over all of the immediate sub-parts of the message
      that are not candidate "body" parts.  That is, skip the first occurrence
      of each of ``text/plain``, ``text/html``, ``multipart/related``, or
      ``multipart/alternative`` (unless they are explicitly marked as
      attachments via :mailheader:`Content-Disposition: attachment`), and
      return all remaining parts.  When applied directly to a
      ``multipart/related``, return an iterator over the all the related parts
      except the root part (ie: the part pointed to by the ``start`` parameter,
      or the first part if there is no ``start`` parameter or the ``start``
      parameter doesn't match the :mailheader:`Content-ID` of any of the
      parts).  When applied directly to a ``multipart/alternative`` or a
      non-``multipart``, return an empty iterator.


   .. method:: iter_parts()

      Return an iterator over all of the immediate sub-parts of the message,
      which will be empty for a non-``multipart``.  (See also
      :meth:`~email.message.EmailMessage.walk`.)


   .. method:: get_content(*args, content_manager=None, **kw)

      Call the :meth:`~email.contentmanager.ContentManager.get_content` method
      of the *content_manager*, passing self as the message object, and passing
      along any other arguments or keywords as additional arguments.  If
      *content_manager* is not specified, use the ``content_manager`` specified
      by the current :mod:`~email.policy`.


   .. method:: set_content(*args, content_manager=None, **kw)

      Call the :meth:`~email.contentmanager.ContentManager.set_content` method
      of the *content_manager*, passing self as the message object, and passing
      along any other arguments or keywords as additional arguments.  If
      *content_manager* is not specified, use the ``content_manager`` specified
      by the current :mod:`~email.policy`.


   .. method:: make_related(boundary=None)

      Convert a non-``multipart`` message into a ``multipart/related`` message,
      moving any existing :mailheader:`Content-` headers and payload into a
      (new) first part of the ``multipart``.  If *boundary* is specified, use
      it as the boundary string in the multipart, otherwise leave the boundary
      to be automatically created when it is needed (for example, when the
      message is serialized).


   .. method:: make_alternative(boundary=None)

      Convert a non-``multipart`` or a ``multipart/related`` into a
      ``multipart/alternative``, moving any existing :mailheader:`Content-`
      headers and payload into a (new) first part of the ``multipart``.  If
      *boundary* is specified, use it as the boundary string in the multipart,
      otherwise leave the boundary to be automatically created when it is
      needed (for example, when the message is serialized).


   .. method:: make_mixed(boundary=None)

      Convert a non-``multipart``, a ``multipart/related``, or a
      ``multipart-alternative`` into a ``multipart/mixed``, moving any existing
      :mailheader:`Content-` headers and payload into a (new) first part of the
      ``multipart``.  If *boundary* is specified, use it as the boundary string
      in the multipart, otherwise leave the boundary to be automatically
      created when it is needed (for example, when the message is serialized).


   .. method:: add_related(*args, content_manager=None, **kw)

      If the message is a ``multipart/related``, create a new message
      object, pass all of the arguments to its :meth:`set_content` method,
      and :meth:`~email.message.Message.attach` it to the ``multipart``.  If
      the message is a non-``multipart``, call :meth:`make_related` and then
      proceed as above.  If the message is any other type of ``multipart``,
      raise a :exc:`TypeError`. If *content_manager* is not specified, use
      the ``content_manager`` specified by the current :mod:`~email.policy`.
      If the added part has no :mailheader:`Content-Disposition` header,
      add one with the value ``inline``.


   .. method:: add_alternative(*args, content_manager=None, **kw)

      If the message is a ``multipart/alternative``, create a new message
      object, pass all of the arguments to its :meth:`set_content` method, and
      :meth:`~email.message.Message.attach` it to the ``multipart``.  If the
      message is a non-``multipart`` or ``multipart/related``, call
      :meth:`make_alternative` and then proceed as above.  If the message is
      any other type of ``multipart``, raise a :exc:`TypeError`. If
      *content_manager* is not specified, use the ``content_manager`` specified
      by the current :mod:`~email.policy`.


   .. method:: add_attachment(*args, content_manager=None, **kw)

      If the message is a ``multipart/mixed``, create a new message object,
      pass all of the arguments to its :meth:`set_content` method, and
      :meth:`~email.message.Message.attach` it to the ``multipart``.  If the
      message is a non-``multipart``, ``multipart/related``, or
      ``multipart/alternative``, call :meth:`make_mixed` and then proceed as
      above. If *content_manager* is not specified, use the ``content_manager``
      specified by the current :mod:`~email.policy`.  If the added part
      has no :mailheader:`Content-Disposition` header, add one with the value
      ``attachment``.  This method can be used both for explicit attachments
      (:mailheader:`Content-Disposition: attachment`) and ``inline`` attachments
      (:mailheader:`Content-Disposition: inline`), by passing appropriate
      options to the ``content_manager``.


   .. method:: clear()

      Remove the payload and all of the headers.


   .. method:: clear_content()

      Remove the payload and all of the :mailheader:`!Content-` headers, leaving
      all other headers intact and in their original order.


   :class:`EmailMessage` objects have the following instance attributes:


   .. attribute:: preamble

      The format of a MIME document allows for some text between the blank line
      following the headers, and the first multipart boundary string. Normally,
      this text is never visible in a MIME-aware mail reader because it falls
      outside the standard MIME armor.  However, when viewing the raw text of
      the message, or when viewing the message in a non-MIME aware reader, this
      text can become visible.

      The *preamble* attribute contains this leading extra-armor text for MIME
      documents.  When the :class:`~email.parser.Parser` discovers some text
      after the headers but before the first boundary string, it assigns this
      text to the message's *preamble* attribute.  When the
      :class:`~email.generator.Generator` is writing out the plain text
      representation of a MIME message, and it finds the
      message has a *preamble* attribute, it will write this text in the area
      between the headers and the first boundary.  See :mod:`email.parser` and
      :mod:`email.generator` for details.

      Note that if the message object has no preamble, the *preamble* attribute
      will be ``None``.


   .. attribute:: epilogue

      The *epilogue* attribute acts the same way as the *preamble* attribute,
      except that it contains text that appears between the last boundary and
      the end of the message.  As with the :attr:`~EmailMessage.preamble`,
      if there is no epilog text this attribute will be ``None``.


   .. attribute:: defects

      The *defects* attribute contains a list of all the problems found when
      parsing this message.  See :mod:`email.errors` for a detailed description
      of the possible parsing defects.


.. class:: MIMEPart(policy=default)

    This class represents a subpart of a MIME message.  It is identical to
    :class:`EmailMessage`, except that no :mailheader:`MIME-Version` headers are
    added when :meth:`~EmailMessage.set_content` is called, since sub-parts do
    not need their own :mailheader:`MIME-Version` headers.


.. rubric:: Footnotes

.. [1] Originally added in 3.4 as a :term:`provisional module <provisional
       package>`.  Docs for legacy message class moved to
       :ref:`compat32_message`.


================================================
File: /Doc/library/email.mime.rst
================================================
:mod:`!email.mime`: Creating email and MIME objects from scratch
----------------------------------------------------------------

.. module:: email.mime
   :synopsis: Build MIME messages.

**Source code:** :source:`Lib/email/mime/`

--------------

This module is part of the legacy (``Compat32``) email API.  Its functionality
is partially replaced by the :mod:`~email.contentmanager` in the new API, but
in certain applications these classes may still be useful, even in non-legacy
code.

Ordinarily, you get a message object structure by passing a file or some text to
a parser, which parses the text and returns the root message object.  However
you can also build a complete message structure from scratch, or even individual
:class:`~email.message.Message` objects by hand.  In fact, you can also take an
existing structure and add new :class:`~email.message.Message` objects, move them
around, etc.  This makes a very convenient interface for slicing-and-dicing MIME
messages.

You can create a new object structure by creating :class:`~email.message.Message`
instances, adding attachments and all the appropriate headers manually.  For MIME
messages though, the :mod:`email` package provides some convenient subclasses to
make things easier.

Here are the classes:

.. module:: email.mime.base

.. class:: MIMEBase(_maintype, _subtype, *, policy=compat32, **_params)

   Module: :mod:`email.mime.base`

   This is the base class for all the MIME-specific subclasses of
   :class:`~email.message.Message`.  Ordinarily you won't create instances
   specifically of :class:`MIMEBase`, although you could.  :class:`MIMEBase`
   is provided primarily as a convenient base class for more specific
   MIME-aware subclasses.

   *_maintype* is the :mailheader:`Content-Type` major type (e.g. :mimetype:`text`
   or :mimetype:`image`), and *_subtype* is the :mailheader:`Content-Type` minor
   type  (e.g. :mimetype:`plain` or :mimetype:`gif`).  *_params* is a parameter
   key/value dictionary and is passed directly to :meth:`Message.add_header
   <email.message.Message.add_header>`.

   If *policy* is specified, (defaults to the
   :class:`compat32 <email.policy.Compat32>` policy) it will be passed to
   :class:`~email.message.Message`.

   The :class:`MIMEBase` class always adds a :mailheader:`Content-Type` header
   (based on *_maintype*, *_subtype*, and *_params*), and a
   :mailheader:`MIME-Version` header (always set to ``1.0``).

   .. versionchanged:: 3.6
      Added *policy* keyword-only parameter.


.. module:: email.mime.nonmultipart

.. class:: MIMENonMultipart()

   Module: :mod:`email.mime.nonmultipart`

   A subclass of :class:`~email.mime.base.MIMEBase`, this is an intermediate base
   class for MIME messages that are not :mimetype:`multipart`.  The primary
   purpose of this class is to prevent the use of the
   :meth:`~email.message.Message.attach` method, which only makes sense for
   :mimetype:`multipart` messages.  If :meth:`~email.message.Message.attach`
   is called, a :exc:`~email.errors.MultipartConversionError` exception is raised.


.. module:: email.mime.multipart

.. class:: MIMEMultipart(_subtype='mixed', boundary=None, _subparts=None, \
                         *, policy=compat32, **_params)

   Module: :mod:`email.mime.multipart`

   A subclass of :class:`~email.mime.base.MIMEBase`, this is an intermediate base
   class for MIME messages that are :mimetype:`multipart`.  Optional *_subtype*
   defaults to :mimetype:`mixed`, but can be used to specify the subtype of the
   message.  A :mailheader:`Content-Type` header of :mimetype:`multipart/_subtype`
   will be added to the message object.  A :mailheader:`MIME-Version` header will
   also be added.

   Optional *boundary* is the multipart boundary string.  When ``None`` (the
   default), the boundary is calculated when needed (for example, when the
   message is serialized).

   *_subparts* is a sequence of initial subparts for the payload.  It must be
   possible to convert this sequence to a list.  You can always attach new subparts
   to the message by using the :meth:`Message.attach
   <email.message.Message.attach>` method.

   Optional *policy* argument defaults to :class:`compat32 <email.policy.Compat32>`.

   Additional parameters for the :mailheader:`Content-Type` header are taken from
   the keyword arguments, or passed into the *_params* argument, which is a keyword
   dictionary.

   .. versionchanged:: 3.6
      Added *policy* keyword-only parameter.

.. module:: email.mime.application

.. class:: MIMEApplication(_data, _subtype='octet-stream', \
                           _encoder=email.encoders.encode_base64, \
                           *, policy=compat32, **_params)

   Module: :mod:`email.mime.application`

   A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the
   :class:`MIMEApplication` class is used to represent MIME message objects of
   major type :mimetype:`application`.  *_data* contains the bytes for the raw
   application data.  Optional *_subtype* specifies the MIME subtype and defaults
   to :mimetype:`octet-stream`.

   Optional *_encoder* is a callable (i.e. function) which will perform the actual
   encoding of the data for transport.  This callable takes one argument, which is
   the :class:`MIMEApplication` instance. It should use
   :meth:`~email.message.Message.get_payload` and
   :meth:`~email.message.Message.set_payload` to change the payload to encoded
   form.  It should also add
   any :mailheader:`Content-Transfer-Encoding` or other headers to the message
   object as necessary.  The default encoding is base64.  See the
   :mod:`email.encoders` module for a list of the built-in encoders.

   Optional *policy* argument defaults to :class:`compat32 <email.policy.Compat32>`.

   *_params* are passed straight through to the base class constructor.

   .. versionchanged:: 3.6
      Added *policy* keyword-only parameter.

.. module:: email.mime.audio

.. class:: MIMEAudio(_audiodata, _subtype=None, \
                     _encoder=email.encoders.encode_base64, \
                     *, policy=compat32, **_params)

   Module: :mod:`email.mime.audio`

   A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the
   :class:`MIMEAudio` class is used to create MIME message objects of major type
   :mimetype:`audio`. *_audiodata* contains the bytes for the raw audio data.  If
   this data can be decoded as au, wav, aiff, or aifc, then the
   subtype will be automatically included in the :mailheader:`Content-Type` header.
   Otherwise you can explicitly specify the audio subtype via the *_subtype*
   argument.  If the minor type could not be guessed and *_subtype* was not given,
   then :exc:`TypeError` is raised.

   Optional *_encoder* is a callable (i.e. function) which will perform the actual
   encoding of the audio data for transport.  This callable takes one argument,
   which is the :class:`MIMEAudio` instance. It should use
   :meth:`~email.message.Message.get_payload` and
   :meth:`~email.message.Message.set_payload` to change the payload to encoded
   form.  It should also add
   any :mailheader:`Content-Transfer-Encoding` or other headers to the message
   object as necessary.  The default encoding is base64.  See the
   :mod:`email.encoders` module for a list of the built-in encoders.

   Optional *policy* argument defaults to :class:`compat32 <email.policy.Compat32>`.

   *_params* are passed straight through to the base class constructor.

   .. versionchanged:: 3.6
      Added *policy* keyword-only parameter.

.. module:: email.mime.image

.. class:: MIMEImage(_imagedata, _subtype=None, \
                     _encoder=email.encoders.encode_base64, \
                    *, policy=compat32, **_params)

   Module: :mod:`email.mime.image`

   A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the
   :class:`MIMEImage` class is used to create MIME message objects of major type
   :mimetype:`image`. *_imagedata* contains the bytes for the raw image data.  If
   this data type can be detected (jpeg, png, gif, tiff, rgb, pbm, pgm, ppm,
   rast, xbm, bmp, webp, and exr attempted), then the subtype will be
   automatically included in the :mailheader:`Content-Type` header. Otherwise
   you can explicitly specify the image subtype via the *_subtype* argument.
   If the minor type could not be guessed and *_subtype* was not given, then
   :exc:`TypeError` is raised.

   Optional *_encoder* is a callable (i.e. function) which will perform the actual
   encoding of the image data for transport.  This callable takes one argument,
   which is the :class:`MIMEImage` instance. It should use
   :meth:`~email.message.Message.get_payload` and
   :meth:`~email.message.Message.set_payload` to change the payload to encoded
   form.  It should also add
   any :mailheader:`Content-Transfer-Encoding` or other headers to the message
   object as necessary.  The default encoding is base64.  See the
   :mod:`email.encoders` module for a list of the built-in encoders.

   Optional *policy* argument defaults to :class:`compat32 <email.policy.Compat32>`.

   *_params* are passed straight through to the :class:`~email.mime.base.MIMEBase`
   constructor.

   .. versionchanged:: 3.6
      Added *policy* keyword-only parameter.

.. module:: email.mime.message

.. class:: MIMEMessage(_msg, _subtype='rfc822', *, policy=compat32)

   Module: :mod:`email.mime.message`

   A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the
   :class:`MIMEMessage` class is used to create MIME objects of main type
   :mimetype:`message`. *_msg* is used as the payload, and must be an instance
   of class :class:`~email.message.Message` (or a subclass thereof), otherwise
   a :exc:`TypeError` is raised.

   Optional *_subtype* sets the subtype of the message; it defaults to
   :mimetype:`rfc822`.

   Optional *policy* argument defaults to :class:`compat32 <email.policy.Compat32>`.

   .. versionchanged:: 3.6
      Added *policy* keyword-only parameter.

.. module:: email.mime.text

.. class:: MIMEText(_text, _subtype='plain', _charset=None, *, policy=compat32)

   Module: :mod:`email.mime.text`

   A subclass of :class:`~email.mime.nonmultipart.MIMENonMultipart`, the
   :class:`MIMEText` class is used to create MIME objects of major type
   :mimetype:`text`. *_text* is the string for the payload.  *_subtype* is the
   minor type and defaults to :mimetype:`plain`.  *_charset* is the character
   set of the text and is passed as an argument to the
   :class:`~email.mime.nonmultipart.MIMENonMultipart` constructor; it defaults
   to ``us-ascii`` if the string contains only ``ascii`` code points, and
   ``utf-8`` otherwise.  The *_charset* parameter accepts either a string or a
   :class:`~email.charset.Charset` instance.

   Unless the *_charset* argument is explicitly set to ``None``, the
   MIMEText object created will have both a :mailheader:`Content-Type` header
   with a ``charset`` parameter, and a :mailheader:`Content-Transfer-Encoding`
   header.  This means that a subsequent ``set_payload`` call will not result
   in an encoded payload, even if a charset is passed in the ``set_payload``
   command.  You can "reset" this behavior by deleting the
   ``Content-Transfer-Encoding`` header, after which a ``set_payload`` call
   will automatically encode the new payload (and add a new
   :mailheader:`Content-Transfer-Encoding` header).

   Optional *policy* argument defaults to :class:`compat32 <email.policy.Compat32>`.

   .. versionchanged:: 3.5
      *_charset* also accepts :class:`~email.charset.Charset` instances.

   .. versionchanged:: 3.6
      Added *policy* keyword-only parameter.


================================================
File: /Doc/library/email.parser.rst
================================================
:mod:`!email.parser`: Parsing email messages
--------------------------------------------

.. module:: email.parser
   :synopsis: Parse flat text email messages to produce a message object structure.

**Source code:** :source:`Lib/email/parser.py`

--------------

Message object structures can be created in one of two ways: they can be
created from whole cloth by creating an :class:`~email.message.EmailMessage`
object, adding headers using the dictionary interface, and adding payload(s)
using :meth:`~email.message.EmailMessage.set_content` and related methods, or
they can be created by parsing a serialized representation of the email
message.

The :mod:`email` package provides a standard parser that understands most email
document structures, including MIME documents.  You can pass the parser a
bytes, string or file object, and the parser will return to you the root
:class:`~email.message.EmailMessage` instance of the object structure.  For
simple, non-MIME messages the payload of this root object will likely be a
string containing the text of the message.  For MIME messages, the root object
will return ``True`` from its :meth:`~email.message.EmailMessage.is_multipart`
method, and the subparts can be accessed via the payload manipulation methods,
such as :meth:`~email.message.EmailMessage.get_body`,
:meth:`~email.message.EmailMessage.iter_parts`, and
:meth:`~email.message.EmailMessage.walk`.

There are actually two parser interfaces available for use, the :class:`Parser`
API and the incremental :class:`FeedParser` API.  The :class:`Parser` API is
most useful if you have the entire text of the message in memory, or if the
entire message lives in a file on the file system.  :class:`FeedParser` is more
appropriate when you are reading the message from a stream which might block
waiting for more input (such as reading an email message from a socket).  The
:class:`FeedParser` can consume and parse the message incrementally, and only
returns the root object when you close the parser.

Note that the parser can be extended in limited ways, and of course you can
implement your own parser completely from scratch.  All of the logic that
connects the :mod:`email` package's bundled parser and the
:class:`~email.message.EmailMessage` class is embodied in the :class:`~email.policy.Policy`
class, so a custom parser can create message object trees any way it finds
necessary by implementing custom versions of the appropriate :class:`!Policy`
methods.


FeedParser API
^^^^^^^^^^^^^^

The :class:`BytesFeedParser`, imported from the :mod:`email.feedparser` module,
provides an API that is conducive to incremental parsing of email messages,
such as would be necessary when reading the text of an email message from a
source that can block (such as a socket).  The :class:`BytesFeedParser` can of
course be used to parse an email message fully contained in a :term:`bytes-like
object`, string, or file, but the :class:`BytesParser` API may be more
convenient for such use cases.  The semantics and results of the two parser
APIs are identical.

The :class:`BytesFeedParser`'s API is simple; you create an instance, feed it a
bunch of bytes until there's no more to feed it, then close the parser to
retrieve the root message object.  The :class:`BytesFeedParser` is extremely
accurate when parsing standards-compliant messages, and it does a very good job
of parsing non-compliant messages, providing information about how a message
was deemed broken.  It will populate a message object's
:attr:`~email.message.EmailMessage.defects` attribute with a list of any
problems it found in a message.  See the :mod:`email.errors` module for the
list of defects that it can find.

Here is the API for the :class:`BytesFeedParser`:


.. class:: BytesFeedParser(_factory=None, *, policy=policy.compat32)

   Create a :class:`BytesFeedParser` instance.  Optional *_factory* is a
   no-argument callable; if not specified use the
   :attr:`~email.policy.Policy.message_factory` from the *policy*.  Call
   *_factory* whenever a new message object is needed.

   If *policy* is specified use the rules it specifies to update the
   representation of the message.  If *policy* is not set, use the
   :class:`compat32 <email.policy.Compat32>` policy, which maintains backward
   compatibility with the Python 3.2 version of the email package and provides
   :class:`~email.message.Message` as the default factory.  All other policies
   provide :class:`~email.message.EmailMessage` as the default *_factory*. For
   more information on what else *policy* controls, see the
   :mod:`~email.policy` documentation.

   Note: **The policy keyword should always be specified**; The default will
   change to :data:`email.policy.default` in a future version of Python.

   .. versionadded:: 3.2

   .. versionchanged:: 3.3 Added the *policy* keyword.
   .. versionchanged:: 3.6 *_factory* defaults to the policy ``message_factory``.


   .. method:: feed(data)

      Feed the parser some more data.  *data* should be a :term:`bytes-like
      object` containing one or more lines.  The lines can be partial and the
      parser will stitch such partial lines together properly.  The lines can
      have any of the three common line endings: carriage return, newline, or
      carriage return and newline (they can even be mixed).


   .. method:: close()

      Complete the parsing of all previously fed data and return the root
      message object.  It is undefined what happens if :meth:`~feed` is called
      after this method has been called.


.. class:: FeedParser(_factory=None, *, policy=policy.compat32)

   Works like :class:`BytesFeedParser` except that the input to the
   :meth:`~BytesFeedParser.feed` method must be a string.  This is of limited
   utility, since the only way for such a message to be valid is for it to
   contain only ASCII text or, if :attr:`~email.policy.Policy.utf8` is
   ``True``, no binary attachments.

   .. versionchanged:: 3.3 Added the *policy* keyword.


Parser API
^^^^^^^^^^

The :class:`BytesParser` class, imported from the :mod:`email.parser` module,
provides an API that can be used to parse a message when the complete contents
of the message are available in a :term:`bytes-like object` or file.  The
:mod:`email.parser` module also provides :class:`Parser` for parsing strings,
and header-only parsers, :class:`BytesHeaderParser` and
:class:`HeaderParser`, which can be used if you're only interested in the
headers of the message.  :class:`BytesHeaderParser` and :class:`HeaderParser`
can be much faster in these situations, since they do not attempt to parse the
message body, instead setting the payload to the raw body.


.. class:: BytesParser(_class=None, *, policy=policy.compat32)

   Create a :class:`BytesParser` instance.  The *_class* and *policy*
   arguments have the same meaning and semantics as the *_factory*
   and *policy* arguments of :class:`BytesFeedParser`.

   Note: **The policy keyword should always be specified**; The default will
   change to :data:`email.policy.default` in a future version of Python.

   .. versionchanged:: 3.3
      Removed the *strict* argument that was deprecated in 2.4.  Added the
      *policy* keyword.
   .. versionchanged:: 3.6 *_class* defaults to the policy ``message_factory``.


   .. method:: parse(fp, headersonly=False)

      Read all the data from the binary file-like object *fp*, parse the
      resulting bytes, and return the message object.  *fp* must support
      both the :meth:`~io.IOBase.readline` and the :meth:`~io.IOBase.read`
      methods.

      The bytes contained in *fp* must be formatted as a block of :rfc:`5322`
      (or, if :attr:`~email.policy.Policy.utf8` is ``True``, :rfc:`6532`)
      style headers and header continuation lines, optionally preceded by an
      envelope header.  The header block is terminated either by the end of the
      data or by a blank line.  Following the header block is the body of the
      message (which may contain MIME-encoded subparts, including subparts
      with a :mailheader:`Content-Transfer-Encoding` of ``8bit``).

      Optional *headersonly* is a flag specifying whether to stop parsing after
      reading the headers or not.  The default is ``False``, meaning it parses
      the entire contents of the file.


   .. method:: parsebytes(bytes, headersonly=False)

      Similar to the :meth:`parse` method, except it takes a :term:`bytes-like
      object` instead of a file-like object.  Calling this method on a
      :term:`bytes-like object` is equivalent to wrapping *bytes* in a
      :class:`~io.BytesIO` instance first and calling :meth:`parse`.

      Optional *headersonly* is as with the :meth:`parse` method.

   .. versionadded:: 3.2


.. class:: BytesHeaderParser(_class=None, *, policy=policy.compat32)

   Exactly like :class:`BytesParser`, except that *headersonly*
   defaults to ``True``.

   .. versionadded:: 3.3


.. class:: Parser(_class=None, *, policy=policy.compat32)

   This class is parallel to :class:`BytesParser`, but handles string input.

   .. versionchanged:: 3.3
      Removed the *strict* argument.  Added the *policy* keyword.
   .. versionchanged:: 3.6 *_class* defaults to the policy ``message_factory``.


   .. method:: parse(fp, headersonly=False)

      Read all the data from the text-mode file-like object *fp*, parse the
      resulting text, and return the root message object.  *fp* must support
      both the :meth:`~io.TextIOBase.readline` and the
      :meth:`~io.TextIOBase.read` methods on file-like objects.

      Other than the text mode requirement, this method operates like
      :meth:`BytesParser.parse`.


   .. method:: parsestr(text, headersonly=False)

      Similar to the :meth:`parse` method, except it takes a string object
      instead of a file-like object.  Calling this method on a string is
      equivalent to wrapping *text* in a :class:`~io.StringIO` instance first
      and calling :meth:`parse`.

      Optional *headersonly* is as with the :meth:`parse` method.


.. class:: HeaderParser(_class=None, *, policy=policy.compat32)

   Exactly like :class:`Parser`, except that *headersonly*
   defaults to ``True``.


Since creating a message object structure from a string or a file object is such
a common task, four functions are provided as a convenience.  They are available
in the top-level :mod:`email` package namespace.

.. currentmodule:: email


.. function:: message_from_bytes(s, _class=None, *, policy=policy.compat32)

   Return a message object structure from a :term:`bytes-like object`.  This is
   equivalent to ``BytesParser().parsebytes(s)``.  Optional *_class* and
   *policy* are interpreted as with the :class:`~email.parser.BytesParser` class
   constructor.

   .. versionadded:: 3.2
   .. versionchanged:: 3.3
      Removed the *strict* argument.  Added the *policy* keyword.


.. function:: message_from_binary_file(fp, _class=None, *, \
                                       policy=policy.compat32)

   Return a message object structure tree from an open binary :term:`file
   object`.  This is equivalent to ``BytesParser().parse(fp)``.  *_class* and
   *policy* are interpreted as with the :class:`~email.parser.BytesParser` class
   constructor.

   .. versionadded:: 3.2
   .. versionchanged:: 3.3
      Removed the *strict* argument.  Added the *policy* keyword.


.. function:: message_from_string(s, _class=None, *, policy=policy.compat32)

   Return a message object structure from a string.  This is equivalent to
   ``Parser().parsestr(s)``.  *_class* and *policy* are interpreted as
   with the :class:`~email.parser.Parser` class constructor.

   .. versionchanged:: 3.3
      Removed the *strict* argument.  Added the *policy* keyword.


.. function:: message_from_file(fp, _class=None, *, policy=policy.compat32)

   Return a message object structure tree from an open :term:`file object`.
   This is equivalent to ``Parser().parse(fp)``.  *_class* and *policy* are
   interpreted as with the :class:`~email.parser.Parser` class constructor.

   .. versionchanged:: 3.3
      Removed the *strict* argument.  Added the *policy* keyword.
   .. versionchanged:: 3.6 *_class* defaults to the policy ``message_factory``.


Here's an example of how you might use :func:`message_from_bytes` at an
interactive Python prompt::

   >>> import email
   >>> msg = email.message_from_bytes(myBytes)  # doctest: +SKIP


Additional notes
^^^^^^^^^^^^^^^^

Here are some notes on the parsing semantics:

* Most non-\ :mimetype:`multipart` type messages are parsed as a single message
  object with a string payload.  These objects will return ``False`` for
  :meth:`~email.message.EmailMessage.is_multipart`, and
  :meth:`~email.message.EmailMessage.iter_parts` will yield an empty list.

* All :mimetype:`multipart` type messages will be parsed as a container message
  object with a list of sub-message objects for their payload.  The outer
  container message will return ``True`` for
  :meth:`~email.message.EmailMessage.is_multipart`, and
  :meth:`~email.message.EmailMessage.iter_parts` will yield a list of subparts.

* Most messages with a content type of :mimetype:`message/\*` (such as
  :mimetype:`message/delivery-status` and :mimetype:`message/rfc822`) will also
  be parsed as container object containing a list payload of length 1.  Their
  :meth:`~email.message.EmailMessage.is_multipart` method will return ``True``.
  The single element yielded by :meth:`~email.message.EmailMessage.iter_parts`
  will be a sub-message object.

* Some non-standards-compliant messages may not be internally consistent about
  their :mimetype:`multipart`\ -edness.  Such messages may have a
  :mailheader:`Content-Type` header of type :mimetype:`multipart`, but their
  :meth:`~email.message.EmailMessage.is_multipart` method may return ``False``.
  If such messages were parsed with the :class:`~email.parser.FeedParser`,
  they will have an instance of the
  :class:`~email.errors.MultipartInvariantViolationDefect` class in their
  *defects* attribute list.  See :mod:`email.errors` for details.


================================================
File: /Doc/library/email.policy.rst
================================================
:mod:`!email.policy`: Policy Objects
------------------------------------

.. module:: email.policy
   :synopsis: Controlling the parsing and generating of messages

.. moduleauthor:: R. David Murray <rdmurray@bitdance.com>
.. sectionauthor:: R. David Murray <rdmurray@bitdance.com>

.. versionadded:: 3.3

**Source code:** :source:`Lib/email/policy.py`

--------------

The :mod:`email` package's prime focus is the handling of email messages as
described by the various email and MIME RFCs.  However, the general format of
email messages (a block of header fields each consisting of a name followed by
a colon followed by a value, the whole block followed by a blank line and an
arbitrary 'body'), is a format that has found utility outside of the realm of
email.  Some of these uses conform fairly closely to the main email RFCs, some
do not.  Even when working with email, there are times when it is desirable to
