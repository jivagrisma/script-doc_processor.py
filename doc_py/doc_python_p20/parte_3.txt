   deemed interactive.  This is the case for files for which ``isatty(fileno(fp))``
   is true.  If the :c:member:`PyConfig.interactive` is non-zero, this function
   also returns true if the *filename* pointer is ``NULL`` or if the name is equal to
   one of the strings ``'<stdin>'`` or ``'???'``.

   This function must not be called before Python is initialized.


.. c:function:: void PyOS_BeforeFork()

   Function to prepare some internal state before a process fork.  This
   should be called before calling :c:func:`fork` or any similar function
   that clones the current process.
   Only available on systems where :c:func:`fork` is defined.

   .. warning::
      The C :c:func:`fork` call should only be made from the
      :ref:`"main" thread <fork-and-threads>` (of the
      :ref:`"main" interpreter <sub-interpreter-support>`).  The same is
      true for ``PyOS_BeforeFork()``.

   .. versionadded:: 3.7


.. c:function:: void PyOS_AfterFork_Parent()

   Function to update some internal state after a process fork.  This
   should be called from the parent process after calling :c:func:`fork`
   or any similar function that clones the current process, regardless
   of whether process cloning was successful.
   Only available on systems where :c:func:`fork` is defined.

   .. warning::
      The C :c:func:`fork` call should only be made from the
      :ref:`"main" thread <fork-and-threads>` (of the
      :ref:`"main" interpreter <sub-interpreter-support>`).  The same is
      true for ``PyOS_AfterFork_Parent()``.

   .. versionadded:: 3.7


.. c:function:: void PyOS_AfterFork_Child()

   Function to update internal interpreter state after a process fork.
   This must be called from the child process after calling :c:func:`fork`,
   or any similar function that clones the current process, if there is
   any chance the process will call back into the Python interpreter.
   Only available on systems where :c:func:`fork` is defined.

   .. warning::
      The C :c:func:`fork` call should only be made from the
      :ref:`"main" thread <fork-and-threads>` (of the
      :ref:`"main" interpreter <sub-interpreter-support>`).  The same is
      true for ``PyOS_AfterFork_Child()``.

   .. versionadded:: 3.7

   .. seealso::
      :func:`os.register_at_fork` allows registering custom Python functions
      to be called by :c:func:`PyOS_BeforeFork()`,
      :c:func:`PyOS_AfterFork_Parent` and  :c:func:`PyOS_AfterFork_Child`.


.. c:function:: void PyOS_AfterFork()

   Function to update some internal state after a process fork; this should be
   called in the new process if the Python interpreter will continue to be used.
   If a new executable is loaded into the new process, this function does not need
   to be called.

   .. deprecated:: 3.7
      This function is superseded by :c:func:`PyOS_AfterFork_Child()`.


.. c:function:: int PyOS_CheckStack()

   .. index:: single: USE_STACKCHECK (C macro)

   Return true when the interpreter runs out of stack space.  This is a reliable
   check, but is only available when :c:macro:`!USE_STACKCHECK` is defined (currently
   on certain versions of Windows using the Microsoft Visual C++ compiler).
   :c:macro:`!USE_STACKCHECK` will be defined automatically; you should never
   change the definition in your own code.


.. c:type::  void (*PyOS_sighandler_t)(int)


.. c:function:: PyOS_sighandler_t PyOS_getsig(int i)

   Return the current signal handler for signal *i*.  This is a thin wrapper around
   either :c:func:`!sigaction` or :c:func:`!signal`.  Do not call those functions
   directly!


.. c:function:: PyOS_sighandler_t PyOS_setsig(int i, PyOS_sighandler_t h)

   Set the signal handler for signal *i* to be *h*; return the old signal handler.
   This is a thin wrapper around either :c:func:`!sigaction` or :c:func:`!signal`.  Do
   not call those functions directly!

.. c:function:: wchar_t* Py_DecodeLocale(const char* arg, size_t *size)

   .. warning::
      This function should not be called directly: use the :c:type:`PyConfig`
      API with the :c:func:`PyConfig_SetBytesString` function which ensures
      that :ref:`Python is preinitialized <c-preinit>`.

      This function must not be called before :ref:`Python is preinitialized
      <c-preinit>` and so that the LC_CTYPE locale is properly configured: see
      the :c:func:`Py_PreInitialize` function.

   Decode a byte string from the :term:`filesystem encoding and error handler`.
   If the error handler is :ref:`surrogateescape error handler
   <surrogateescape>`, undecodable bytes are decoded as characters in range
   U+DC80..U+DCFF; and if a byte sequence can be decoded as a surrogate
   character, the bytes are escaped using the surrogateescape error handler
   instead of decoding them.

   Return a pointer to a newly allocated wide character string, use
   :c:func:`PyMem_RawFree` to free the memory. If size is not ``NULL``, write
   the number of wide characters excluding the null character into ``*size``

   Return ``NULL`` on decoding error or memory allocation error. If *size* is
   not ``NULL``, ``*size`` is set to ``(size_t)-1`` on memory error or set to
   ``(size_t)-2`` on decoding error.

   The :term:`filesystem encoding and error handler` are selected by
   :c:func:`PyConfig_Read`: see :c:member:`~PyConfig.filesystem_encoding` and
   :c:member:`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`.

   Decoding errors should never happen, unless there is a bug in the C
   library.

   Use the :c:func:`Py_EncodeLocale` function to encode the character string
   back to a byte string.

   .. seealso::

      The :c:func:`PyUnicode_DecodeFSDefaultAndSize` and
      :c:func:`PyUnicode_DecodeLocaleAndSize` functions.

   .. versionadded:: 3.5

   .. versionchanged:: 3.7
      The function now uses the UTF-8 encoding in the :ref:`Python UTF-8 Mode
      <utf8-mode>`.

   .. versionchanged:: 3.8
      The function now uses the UTF-8 encoding on Windows if
      :c:member:`PyPreConfig.legacy_windows_fs_encoding` is zero;


.. c:function:: char* Py_EncodeLocale(const wchar_t *text, size_t *error_pos)

   Encode a wide character string to the :term:`filesystem encoding and error
   handler`. If the error handler is :ref:`surrogateescape error handler
   <surrogateescape>`, surrogate characters in the range U+DC80..U+DCFF are
   converted to bytes 0x80..0xFF.

   Return a pointer to a newly allocated byte string, use :c:func:`PyMem_Free`
   to free the memory. Return ``NULL`` on encoding error or memory allocation
   error.

   If error_pos is not ``NULL``, ``*error_pos`` is set to ``(size_t)-1`` on
   success,  or set to the index of the invalid character on encoding error.

   The :term:`filesystem encoding and error handler` are selected by
   :c:func:`PyConfig_Read`: see :c:member:`~PyConfig.filesystem_encoding` and
   :c:member:`~PyConfig.filesystem_errors` members of :c:type:`PyConfig`.

   Use the :c:func:`Py_DecodeLocale` function to decode the bytes string back
   to a wide character string.

   .. warning::
      This function must not be called before :ref:`Python is preinitialized
      <c-preinit>` and so that the LC_CTYPE locale is properly configured: see
      the :c:func:`Py_PreInitialize` function.

   .. seealso::

      The :c:func:`PyUnicode_EncodeFSDefault` and
      :c:func:`PyUnicode_EncodeLocale` functions.

   .. versionadded:: 3.5

   .. versionchanged:: 3.7
      The function now uses the UTF-8 encoding in the :ref:`Python UTF-8 Mode
      <utf8-mode>`.

   .. versionchanged:: 3.8
      The function now uses the UTF-8 encoding on Windows if
      :c:member:`PyPreConfig.legacy_windows_fs_encoding` is zero.

.. c:function:: FILE* Py_fopen(PyObject *path, const char *mode)

   Similar to :c:func:`!fopen`, but *path* is a Python object and
   an exception is set on error.

   *path* must be a :class:`str` object, a :class:`bytes` object,
   or a :term:`path-like object`.

   On success, return the new file pointer.
   On error, set an exception and return ``NULL``.

   The file must be closed by :c:func:`Py_fclose` rather than calling directly
   :c:func:`!fclose`.

   The file descriptor is created non-inheritable (:pep:`446`).

   The caller must hold the GIL.

   .. versionadded:: next


.. c:function:: int Py_fclose(FILE *file)

   Close a file that was opened by :c:func:`Py_fopen`.

   On success, return ``0``.
   On error, return ``EOF`` and ``errno`` is set to indicate the error.
   In either case, any further access (including another call to
   :c:func:`Py_fclose`) to the stream results in undefined behavior.

   .. versionadded:: next


.. _systemfunctions:

System Functions
================

These are utility functions that make functionality from the :mod:`sys` module
accessible to C code.  They all work with the current interpreter thread's
:mod:`sys` module's dict, which is contained in the internal thread state structure.

.. c:function:: PyObject *PySys_GetObject(const char *name)

   Return the object *name* from the :mod:`sys` module or ``NULL`` if it does
   not exist, without setting an exception.

.. c:function:: int PySys_SetObject(const char *name, PyObject *v)

   Set *name* in the :mod:`sys` module to *v* unless *v* is ``NULL``, in which
   case *name* is deleted from the sys module. Returns ``0`` on success, ``-1``
   on error.

.. c:function:: void PySys_ResetWarnOptions()

   Reset :data:`sys.warnoptions` to an empty list. This function may be
   called prior to :c:func:`Py_Initialize`.

   .. deprecated-removed:: 3.13 3.15
      Clear :data:`sys.warnoptions` and :data:`!warnings.filters` instead.

.. c:function:: void PySys_WriteStdout(const char *format, ...)

   Write the output string described by *format* to :data:`sys.stdout`.  No
   exceptions are raised, even if truncation occurs (see below).

   *format* should limit the total size of the formatted output string to
   1000 bytes or less -- after 1000 bytes, the output string is truncated.
   In particular, this means that no unrestricted "%s" formats should occur;
   these should be limited using "%.<N>s" where <N> is a decimal number
   calculated so that <N> plus the maximum size of other formatted text does not
   exceed 1000 bytes.  Also watch out for "%f", which can print hundreds of
   digits for very large numbers.

   If a problem occurs, or :data:`sys.stdout` is unset, the formatted message
   is written to the real (C level) *stdout*.

.. c:function:: void PySys_WriteStderr(const char *format, ...)

   As :c:func:`PySys_WriteStdout`, but write to :data:`sys.stderr` or *stderr*
   instead.

.. c:function:: void PySys_FormatStdout(const char *format, ...)

   Function similar to PySys_WriteStdout() but format the message using
   :c:func:`PyUnicode_FromFormatV` and don't truncate the message to an
   arbitrary length.

   .. versionadded:: 3.2

.. c:function:: void PySys_FormatStderr(const char *format, ...)

   As :c:func:`PySys_FormatStdout`, but write to :data:`sys.stderr` or *stderr*
   instead.

   .. versionadded:: 3.2

.. c:function:: PyObject *PySys_GetXOptions()

   Return the current dictionary of :option:`-X` options, similarly to
   :data:`sys._xoptions`.  On error, ``NULL`` is returned and an exception is
   set.

   .. versionadded:: 3.2


.. c:function:: int PySys_Audit(const char *event, const char *format, ...)

   Raise an auditing event with any active hooks. Return zero for success
   and non-zero with an exception set on failure.

   The *event* string argument must not be *NULL*.

   If any hooks have been added, *format* and other arguments will be used
   to construct a tuple to pass. Apart from ``N``, the same format characters
   as used in :c:func:`Py_BuildValue` are available. If the built value is not
   a tuple, it will be added into a single-element tuple.

   The ``N`` format option must not be used. It consumes a reference, but since
   there is no way to know whether arguments to this function will be consumed,
   using it may cause reference leaks.

   Note that ``#`` format characters should always be treated as
   :c:type:`Py_ssize_t`, regardless of whether ``PY_SSIZE_T_CLEAN`` was defined.

   :func:`sys.audit` performs the same function from Python code.

   See also :c:func:`PySys_AuditTuple`.

   .. versionadded:: 3.8

   .. versionchanged:: 3.8.2

      Require :c:type:`Py_ssize_t` for ``#`` format characters. Previously, an
      unavoidable deprecation warning was raised.


.. c:function:: int PySys_AuditTuple(const char *event, PyObject *args)

   Similar to :c:func:`PySys_Audit`, but pass arguments as a Python object.
   *args* must be a :class:`tuple`. To pass no arguments, *args* can be *NULL*.

   .. versionadded:: 3.13


.. c:function:: int PySys_AddAuditHook(Py_AuditHookFunction hook, void *userData)

   Append the callable *hook* to the list of active auditing hooks.
   Return zero on success
   and non-zero on failure. If the runtime has been initialized, also set an
   error on failure. Hooks added through this API are called for all
   interpreters created by the runtime.

   The *userData* pointer is passed into the hook function. Since hook
   functions may be called from different runtimes, this pointer should not
   refer directly to Python state.

   This function is safe to call before :c:func:`Py_Initialize`. When called
   after runtime initialization, existing audit hooks are notified and may
   silently abort the operation by raising an error subclassed from
   :class:`Exception` (other errors will not be silenced).

   The hook function is always called with the GIL held by the Python
   interpreter that raised the event.

   See :pep:`578` for a detailed description of auditing.  Functions in the
   runtime and standard library that raise events are listed in the
   :ref:`audit events table <audit-events>`.
   Details are in each function's documentation.

   .. audit-event:: sys.addaudithook "" c.PySys_AddAuditHook

      If the interpreter is initialized, this function raises an auditing event
      ``sys.addaudithook`` with no arguments. If any existing hooks raise an
      exception derived from :class:`Exception`, the new hook will not be
      added and the exception is cleared. As a result, callers cannot assume
      that their hook has been added unless they control all existing hooks.

   .. c:namespace:: NULL
   .. c:type:: int (*Py_AuditHookFunction) (const char *event, PyObject *args, void *userData)

      The type of the hook function.
      *event* is the C string event argument passed to :c:func:`PySys_Audit` or
      :c:func:`PySys_AuditTuple`.
      *args* is guaranteed to be a :c:type:`PyTupleObject`.
      *userData* is the argument passed to PySys_AddAuditHook().

   .. versionadded:: 3.8


.. _processcontrol:

Process Control
===============


.. c:function:: void Py_FatalError(const char *message)

   .. index:: single: abort (C function)

   Print a fatal error message and kill the process.  No cleanup is performed.
   This function should only be invoked when a condition is detected that would
   make it dangerous to continue using the Python interpreter; e.g., when the
   object administration appears to be corrupted.  On Unix, the standard C library
   function :c:func:`!abort` is called which will attempt to produce a :file:`core`
   file.

   The ``Py_FatalError()`` function is replaced with a macro which logs
   automatically the name of the current function, unless the
   ``Py_LIMITED_API`` macro is defined.

   .. versionchanged:: 3.9
      Log the function name automatically.


.. c:function:: void Py_Exit(int status)

   .. index::
      single: Py_FinalizeEx (C function)
      single: exit (C function)

   Exit the current process.  This calls :c:func:`Py_FinalizeEx` and then calls the
   standard C library function ``exit(status)``.  If :c:func:`Py_FinalizeEx`
   indicates an error, the exit status is set to 120.

   .. versionchanged:: 3.6
      Errors from finalization no longer ignored.


.. c:function:: int Py_AtExit(void (*func) ())

   .. index::
      single: Py_FinalizeEx (C function)
      single: cleanup functions

   Register a cleanup function to be called by :c:func:`Py_FinalizeEx`.  The cleanup
   function will be called with no arguments and should return no value.  At most
   32 cleanup functions can be registered.  When the registration is successful,
   :c:func:`Py_AtExit` returns ``0``; on failure, it returns ``-1``.  The cleanup
   function registered last is called first. Each cleanup function will be called
   at most once.  Since Python's internal finalization will have completed before
   the cleanup function, no Python APIs should be called by *func*.

   .. seealso::

      :c:func:`PyUnstable_AtExit` for passing a ``void *data`` argument.


================================================
File: /Doc/c-api/time.rst
================================================
.. highlight:: c

.. _c-api-time:

PyTime C API
============

.. versionadded:: 3.13

The clock C API provides access to system clocks.
It is similar to the Python :mod:`time` module.

For C API related to the :mod:`datetime` module, see :ref:`datetimeobjects`.


Types
-----

.. c:type:: PyTime_t

   A timestamp or duration in nanoseconds, represented as a signed 64-bit
   integer.

   The reference point for timestamps depends on the clock used. For example,
   :c:func:`PyTime_Time` returns timestamps relative to the UNIX epoch.

   The supported range is around [-292.3 years; +292.3 years].
   Using the Unix epoch (January 1st, 1970) as reference, the supported date
   range is around [1677-09-21; 2262-04-11].
   The exact limits are exposed as constants:

.. c:var:: PyTime_t PyTime_MIN

   Minimum value of :c:type:`PyTime_t`.

.. c:var:: PyTime_t PyTime_MAX

   Maximum value of :c:type:`PyTime_t`.


Clock Functions
---------------

The following functions take a pointer to a :c:expr:`PyTime_t` that they
set to the value of a particular clock.
Details of each clock are given in the documentation of the corresponding
Python function.

The functions return ``0`` on success, or ``-1`` (with an exception set)
on failure.

On integer overflow, they set the :c:data:`PyExc_OverflowError` exception and
set ``*result`` to the value clamped to the ``[PyTime_MIN; PyTime_MAX]``
range.
(On current systems, integer overflows are likely caused by misconfigured
system time.)

As any other C API (unless otherwise specified), the functions must be called
with the :term:`GIL` held.

.. c:function:: int PyTime_Monotonic(PyTime_t *result)

   Read the monotonic clock.
   See :func:`time.monotonic` for important details on this clock.

.. c:function:: int PyTime_PerfCounter(PyTime_t *result)

   Read the performance counter.
   See :func:`time.perf_counter` for important details on this clock.

.. c:function:: int PyTime_Time(PyTime_t *result)

   Read the “wall clock” time.
   See :func:`time.time` for details important on this clock.


Raw Clock Functions
-------------------

Similar to clock functions, but don't set an exception on error and don't
require the caller to hold the GIL.

On success, the functions return ``0``.

On failure, they set ``*result`` to ``0`` and return ``-1``, *without* setting
an exception. To get the cause of the error, acquire the GIL and call the
regular (non-``Raw``) function. Note that the regular function may succeed after
the ``Raw`` one failed.

.. c:function:: int PyTime_MonotonicRaw(PyTime_t *result)

   Similar to :c:func:`PyTime_Monotonic`,
   but don't set an exception on error and don't require holding the GIL.

.. c:function:: int PyTime_PerfCounterRaw(PyTime_t *result)

   Similar to :c:func:`PyTime_PerfCounter`,
   but don't set an exception on error and don't require holding the GIL.

.. c:function:: int PyTime_TimeRaw(PyTime_t *result)

   Similar to :c:func:`PyTime_Time`,
   but don't set an exception on error and don't require holding the GIL.


Conversion functions
--------------------

.. c:function:: double PyTime_AsSecondsDouble(PyTime_t t)

   Convert a timestamp to a number of seconds as a C :c:expr:`double`.

   The function cannot fail, but note that :c:expr:`double` has limited
   accuracy for large values.


================================================
File: /Doc/c-api/tuple.rst
================================================
.. highlight:: c

.. _tupleobjects:

Tuple Objects
-------------

.. index:: pair: object; tuple


.. c:type:: PyTupleObject

   This subtype of :c:type:`PyObject` represents a Python tuple object.


.. c:var:: PyTypeObject PyTuple_Type

   This instance of :c:type:`PyTypeObject` represents the Python tuple type; it
   is the same object as :class:`tuple` in the Python layer.


.. c:function:: int PyTuple_Check(PyObject *p)

   Return true if *p* is a tuple object or an instance of a subtype of the
   tuple type.  This function always succeeds.


.. c:function:: int PyTuple_CheckExact(PyObject *p)

   Return true if *p* is a tuple object, but not an instance of a subtype of the
   tuple type.  This function always succeeds.


.. c:function:: PyObject* PyTuple_New(Py_ssize_t len)

   Return a new tuple object of size *len*,
   or ``NULL`` with an exception set on failure.


.. c:function:: PyObject* PyTuple_Pack(Py_ssize_t n, ...)

   Return a new tuple object of size *n*,
   or ``NULL`` with an exception set on failure. The tuple values
   are initialized to the subsequent *n* C arguments pointing to Python objects.
   ``PyTuple_Pack(2, a, b)`` is equivalent to ``Py_BuildValue("(OO)", a, b)``.


.. c:function:: Py_ssize_t PyTuple_Size(PyObject *p)

   Take a pointer to a tuple object, and return the size of that tuple.
   On error, return ``-1`` and with an exception set.


.. c:function:: Py_ssize_t PyTuple_GET_SIZE(PyObject *p)

   Like :c:func:`PyTuple_Size`, but without error checking.


.. c:function:: PyObject* PyTuple_GetItem(PyObject *p, Py_ssize_t pos)

   Return the object at position *pos* in the tuple pointed to by *p*.  If *pos* is
   negative or out of bounds, return ``NULL`` and set an :exc:`IndexError` exception.

   The returned reference is borrowed from the tuple *p*
   (that is: it is only valid as long as you hold a reference to *p*).
   To get a :term:`strong reference`, use
   :c:func:`Py_NewRef(PyTuple_GetItem(...)) <Py_NewRef>`
   or :c:func:`PySequence_GetItem`.


.. c:function:: PyObject* PyTuple_GET_ITEM(PyObject *p, Py_ssize_t pos)

   Like :c:func:`PyTuple_GetItem`, but does no checking of its arguments.


.. c:function:: PyObject* PyTuple_GetSlice(PyObject *p, Py_ssize_t low, Py_ssize_t high)

   Return the slice of the tuple pointed to by *p* between *low* and *high*,
   or ``NULL`` with an exception set on failure.

   This is the equivalent of the Python expression ``p[low:high]``.
   Indexing from the end of the tuple is not supported.


.. c:function:: int PyTuple_SetItem(PyObject *p, Py_ssize_t pos, PyObject *o)

   Insert a reference to object *o* at position *pos* of the tuple pointed to by
   *p*.  Return ``0`` on success.  If *pos* is out of bounds, return ``-1``
   and set an :exc:`IndexError` exception.

   .. note::

      This function "steals" a reference to *o* and discards a reference to
      an item already in the tuple at the affected position.


.. c:function:: void PyTuple_SET_ITEM(PyObject *p, Py_ssize_t pos, PyObject *o)

   Like :c:func:`PyTuple_SetItem`, but does no error checking, and should *only* be
   used to fill in brand new tuples.

   Bounds checking is performed as an assertion if Python is built in
   :ref:`debug mode <debug-build>` or :option:`with assertions <--with-assertions>`.

   .. note::

      This function "steals" a reference to *o*, and, unlike
      :c:func:`PyTuple_SetItem`, does *not* discard a reference to any item that
      is being replaced; any reference in the tuple at position *pos* will be
      leaked.

   .. warning::

      This macro should *only* be used on tuples that are newly created.
      Using this macro on a tuple that is already in use (or in other words, has
      a refcount > 1) could lead to undefined behavior.


.. c:function:: int _PyTuple_Resize(PyObject **p, Py_ssize_t newsize)

   Can be used to resize a tuple.  *newsize* will be the new length of the tuple.
   Because tuples are *supposed* to be immutable, this should only be used if there
   is only one reference to the object.  Do *not* use this if the tuple may already
   be known to some other part of the code.  The tuple will always grow or shrink
   at the end.  Think of this as destroying the old tuple and creating a new one,
   only more efficiently.  Returns ``0`` on success. Client code should never
   assume that the resulting value of ``*p`` will be the same as before calling
   this function. If the object referenced by ``*p`` is replaced, the original
   ``*p`` is destroyed.  On failure, returns ``-1`` and sets ``*p`` to ``NULL``, and
   raises :exc:`MemoryError` or :exc:`SystemError`.


.. _struct-sequence-objects:

Struct Sequence Objects
-----------------------

Struct sequence objects are the C equivalent of :func:`~collections.namedtuple`
objects, i.e. a sequence whose items can also be accessed through attributes.
To create a struct sequence, you first have to create a specific struct sequence
type.

.. c:function:: PyTypeObject* PyStructSequence_NewType(PyStructSequence_Desc *desc)

   Create a new struct sequence type from the data in *desc*, described below. Instances
   of the resulting type can be created with :c:func:`PyStructSequence_New`.

   Return ``NULL`` with an exception set on failure.


.. c:function:: void PyStructSequence_InitType(PyTypeObject *type, PyStructSequence_Desc *desc)

   Initializes a struct sequence type *type* from *desc* in place.


.. c:function:: int PyStructSequence_InitType2(PyTypeObject *type, PyStructSequence_Desc *desc)

   Like :c:func:`PyStructSequence_InitType`, but returns ``0`` on success
   and ``-1`` with an exception set on failure.

   .. versionadded:: 3.4


.. c:type:: PyStructSequence_Desc

   Contains the meta information of a struct sequence type to create.

   .. c:member:: const char *name

      Fully qualified name of the type; null-terminated UTF-8 encoded.
      The name must contain the module name.

   .. c:member:: const char *doc

      Pointer to docstring for the type or ``NULL`` to omit.

   .. c:member:: PyStructSequence_Field *fields

      Pointer to ``NULL``-terminated array with field names of the new type.

   .. c:member:: int n_in_sequence

      Number of fields visible to the Python side (if used as tuple).


.. c:type:: PyStructSequence_Field

   Describes a field of a struct sequence. As a struct sequence is modeled as a
   tuple, all fields are typed as :c:expr:`PyObject*`.  The index in the
   :c:member:`~PyStructSequence_Desc.fields` array of
   the :c:type:`PyStructSequence_Desc` determines which
   field of the struct sequence is described.

   .. c:member:: const char *name

      Name for the field or ``NULL`` to end the list of named fields,
      set to :c:data:`PyStructSequence_UnnamedField` to leave unnamed.

   .. c:member:: const char *doc

      Field docstring or ``NULL`` to omit.


.. c:var:: const char * const PyStructSequence_UnnamedField

   Special value for a field name to leave it unnamed.

   .. versionchanged:: 3.9
      The type was changed from ``char *``.


.. c:function:: PyObject* PyStructSequence_New(PyTypeObject *type)

   Creates an instance of *type*, which must have been created with
   :c:func:`PyStructSequence_NewType`.

   Return ``NULL`` with an exception set on failure.


.. c:function:: PyObject* PyStructSequence_GetItem(PyObject *p, Py_ssize_t pos)

   Return the object at position *pos* in the struct sequence pointed to by *p*.

   Bounds checking is performed as an assertion if Python is built in
   :ref:`debug mode <debug-build>` or :option:`with assertions <--with-assertions>`.


.. c:function:: PyObject* PyStructSequence_GET_ITEM(PyObject *p, Py_ssize_t pos)

   Alias to :c:func:`PyStructSequence_GetItem`.

   .. versionchanged:: 3.13
      Now implemented as an alias to :c:func:`PyStructSequence_GetItem`.


.. c:function:: void PyStructSequence_SetItem(PyObject *p, Py_ssize_t pos, PyObject *o)

   Sets the field at index *pos* of the struct sequence *p* to value *o*.  Like
   :c:func:`PyTuple_SET_ITEM`, this should only be used to fill in brand new
   instances.

   Bounds checking is performed as an assertion if Python is built in
   :ref:`debug mode <debug-build>` or :option:`with assertions <--with-assertions>`.

   .. note::

      This function "steals" a reference to *o*.


.. c:function:: void PyStructSequence_SET_ITEM(PyObject *p, Py_ssize_t *pos, PyObject *o)

   Alias to :c:func:`PyStructSequence_SetItem`.

   .. versionchanged:: 3.13
      Now implemented as an alias to :c:func:`PyStructSequence_SetItem`.


================================================
File: /Doc/c-api/type.rst
================================================
.. highlight:: c

.. _typeobjects:

Type Objects
------------

.. index:: pair: object; type


.. c:type:: PyTypeObject

   The C structure of the objects used to describe built-in types.


.. c:var:: PyTypeObject PyType_Type

   This is the type object for type objects; it is the same object as
   :class:`type` in the Python layer.


.. c:function:: int PyType_Check(PyObject *o)

   Return non-zero if the object *o* is a type object, including instances of
   types derived from the standard type object.  Return 0 in all other cases.
   This function always succeeds.


.. c:function:: int PyType_CheckExact(PyObject *o)

   Return non-zero if the object *o* is a type object, but not a subtype of
   the standard type object.  Return 0 in all other cases.  This function
   always succeeds.


.. c:function:: unsigned int PyType_ClearCache()

   Clear the internal lookup cache. Return the current version tag.

.. c:function:: unsigned long PyType_GetFlags(PyTypeObject* type)

   Return the :c:member:`~PyTypeObject.tp_flags` member of *type*. This function is primarily
   meant for use with ``Py_LIMITED_API``; the individual flag bits are
   guaranteed to be stable across Python releases, but access to
   :c:member:`~PyTypeObject.tp_flags` itself is not part of the :ref:`limited API <limited-c-api>`.

   .. versionadded:: 3.2

   .. versionchanged:: 3.4
      The return type is now ``unsigned long`` rather than ``long``.


.. c:function:: PyObject* PyType_GetDict(PyTypeObject* type)

   Return the type object's internal namespace, which is otherwise only
   exposed via a read-only proxy (:attr:`cls.__dict__ <type.__dict__>`).
   This is a
   replacement for accessing :c:member:`~PyTypeObject.tp_dict` directly.
   The returned dictionary must be treated as read-only.

   This function is meant for specific embedding and language-binding cases,
   where direct access to the dict is necessary and indirect access
   (e.g. via the proxy or :c:func:`PyObject_GetAttr`) isn't adequate.

   Extension modules should continue to use ``tp_dict``,
   directly or indirectly, when setting up their own types.

   .. versionadded:: 3.12


.. c:function:: void PyType_Modified(PyTypeObject *type)

   Invalidate the internal lookup cache for the type and all of its
   subtypes.  This function must be called after any manual
   modification of the attributes or base classes of the type.


.. c:function:: int PyType_AddWatcher(PyType_WatchCallback callback)

   Register *callback* as a type watcher. Return a non-negative integer ID
   which must be passed to future calls to :c:func:`PyType_Watch`. In case of
   error (e.g. no more watcher IDs available), return ``-1`` and set an
   exception.

   .. versionadded:: 3.12


.. c:function:: int PyType_ClearWatcher(int watcher_id)

   Clear watcher identified by *watcher_id* (previously returned from
   :c:func:`PyType_AddWatcher`). Return ``0`` on success, ``-1`` on error (e.g.
   if *watcher_id* was never registered.)

   An extension should never call ``PyType_ClearWatcher`` with a *watcher_id*
   that was not returned to it by a previous call to
   :c:func:`PyType_AddWatcher`.

   .. versionadded:: 3.12


.. c:function:: int PyType_Watch(int watcher_id, PyObject *type)

   Mark *type* as watched. The callback granted *watcher_id* by
   :c:func:`PyType_AddWatcher` will be called whenever
   :c:func:`PyType_Modified` reports a change to *type*. (The callback may be
   called only once for a series of consecutive modifications to *type*, if
   :c:func:`!_PyType_Lookup` is not called on *type* between the modifications;
   this is an implementation detail and subject to change.)

   An extension should never call ``PyType_Watch`` with a *watcher_id* that was
   not returned to it by a previous call to :c:func:`PyType_AddWatcher`.

   .. versionadded:: 3.12


.. c:type:: int (*PyType_WatchCallback)(PyObject *type)

   Type of a type-watcher callback function.

   The callback must not modify *type* or cause :c:func:`PyType_Modified` to be
   called on *type* or any type in its MRO; violating this rule could cause
   infinite recursion.

   .. versionadded:: 3.12


.. c:function:: int PyType_HasFeature(PyTypeObject *o, int feature)

   Return non-zero if the type object *o* sets the feature *feature*.
   Type features are denoted by single bit flags.


.. c:function:: int PyType_IS_GC(PyTypeObject *o)

   Return true if the type object includes support for the cycle detector; this
   tests the type flag :c:macro:`Py_TPFLAGS_HAVE_GC`.


.. c:function:: int PyType_IsSubtype(PyTypeObject *a, PyTypeObject *b)

   Return true if *a* is a subtype of *b*.

   This function only checks for actual subtypes, which means that
   :meth:`~type.__subclasscheck__` is not called on *b*.  Call
   :c:func:`PyObject_IsSubclass` to do the same check that :func:`issubclass`
   would do.


.. c:function:: PyObject* PyType_GenericAlloc(PyTypeObject *type, Py_ssize_t nitems)

   Generic handler for the :c:member:`~PyTypeObject.tp_alloc` slot of a type object.  Use
   Python's default memory allocation mechanism to allocate a new instance and
   initialize all its contents to ``NULL``.

.. c:function:: PyObject* PyType_GenericNew(PyTypeObject *type, PyObject *args, PyObject *kwds)

   Generic handler for the :c:member:`~PyTypeObject.tp_new` slot of a type object.  Create a
   new instance using the type's :c:member:`~PyTypeObject.tp_alloc` slot.

.. c:function:: int PyType_Ready(PyTypeObject *type)

   Finalize a type object.  This should be called on all type objects to finish
   their initialization.  This function is responsible for adding inherited slots
   from a type's base class.  Return ``0`` on success, or return ``-1`` and sets an
   exception on error.

   .. note::
       If some of the base classes implements the GC protocol and the provided
       type does not include the :c:macro:`Py_TPFLAGS_HAVE_GC` in its flags, then
       the GC protocol will be automatically implemented from its parents. On
       the contrary, if the type being created does include
       :c:macro:`Py_TPFLAGS_HAVE_GC` in its flags then it **must** implement the
       GC protocol itself by at least implementing the
       :c:member:`~PyTypeObject.tp_traverse` handle.

.. c:function:: PyObject* PyType_GetName(PyTypeObject *type)

   Return the type's name. Equivalent to getting the type's
   :attr:`~type.__name__` attribute.

   .. versionadded:: 3.11

.. c:function:: PyObject* PyType_GetQualName(PyTypeObject *type)

   Return the type's qualified name. Equivalent to getting the
   type's :attr:`~type.__qualname__` attribute.

   .. versionadded:: 3.11

.. c:function:: PyObject* PyType_GetFullyQualifiedName(PyTypeObject *type)

   Return the type's fully qualified name. Equivalent to
   ``f"{type.__module__}.{type.__qualname__}"``, or :attr:`type.__qualname__`
   if :attr:`type.__module__` is not a string or is equal to ``"builtins"``.

   .. versionadded:: 3.13

.. c:function:: PyObject* PyType_GetModuleName(PyTypeObject *type)

   Return the type's module name. Equivalent to getting the
   :attr:`type.__module__` attribute.

   .. versionadded:: 3.13

.. c:function:: void* PyType_GetSlot(PyTypeObject *type, int slot)

   Return the function pointer stored in the given slot. If the
   result is ``NULL``, this indicates that either the slot is ``NULL``,
   or that the function was called with invalid parameters.
   Callers will typically cast the result pointer into the appropriate
   function type.

   See :c:member:`PyType_Slot.slot` for possible values of the *slot* argument.

   .. versionadded:: 3.4

   .. versionchanged:: 3.10
      :c:func:`PyType_GetSlot` can now accept all types.
      Previously, it was limited to :ref:`heap types <heap-types>`.

.. c:function:: PyObject* PyType_GetModule(PyTypeObject *type)

   Return the module object associated with the given type when the type was
   created using :c:func:`PyType_FromModuleAndSpec`.

   If no module is associated with the given type, sets :py:class:`TypeError`
   and returns ``NULL``.

   This function is usually used to get the module in which a method is defined.
   Note that in such a method, ``PyType_GetModule(Py_TYPE(self))``
   may not return the intended result.
   ``Py_TYPE(self)`` may be a *subclass* of the intended class, and subclasses
   are not necessarily defined in the same module as their superclass.
   See :c:type:`PyCMethod` to get the class that defines the method.
   See :c:func:`PyType_GetModuleByDef` for cases when :c:type:`!PyCMethod` cannot
   be used.

   .. versionadded:: 3.9

.. c:function:: void* PyType_GetModuleState(PyTypeObject *type)

   Return the state of the module object associated with the given type.
   This is a shortcut for calling :c:func:`PyModule_GetState()` on the result
   of :c:func:`PyType_GetModule`.

   If no module is associated with the given type, sets :py:class:`TypeError`
   and returns ``NULL``.

   If the *type* has an associated module but its state is ``NULL``,
   returns ``NULL`` without setting an exception.

   .. versionadded:: 3.9

.. c:function:: PyObject* PyType_GetModuleByDef(PyTypeObject *type, struct PyModuleDef *def)

   Find the first superclass whose module was created from
   the given :c:type:`PyModuleDef` *def*, and return that module.

   If no module is found, raises a :py:class:`TypeError` and returns ``NULL``.

   This function is intended to be used together with
   :c:func:`PyModule_GetState()` to get module state from slot methods (such as
   :c:member:`~PyTypeObject.tp_init` or :c:member:`~PyNumberMethods.nb_add`)
   and other places where a method's defining class cannot be passed using the
   :c:type:`PyCMethod` calling convention.

   .. versionadded:: 3.11

.. c:function:: int PyType_GetBaseByToken(PyTypeObject *type, void *token, PyTypeObject **result)

   Find the first superclass in *type*'s :term:`method resolution order` whose
   :c:macro:`Py_tp_token` token is equal to the given one.

   * If found, set *\*result* to a new :term:`strong reference`
     to it and return ``1``.
   * If not found, set *\*result* to ``NULL`` and return ``0``.
   * On error, set *\*result* to ``NULL`` and return ``-1`` with an
     exception set.

   The *result* argument may be ``NULL``, in which case *\*result* is not set.
   Use this if you need only the return value.

   The *token* argument may not be ``NULL``.

   .. versionadded:: 3.14

.. c:function:: int PyUnstable_Type_AssignVersionTag(PyTypeObject *type)

   Attempt to assign a version tag to the given type.

   Returns 1 if the type already had a valid version tag or a new one was
   assigned, or 0 if a new tag could not be assigned.

   .. versionadded:: 3.12


Creating Heap-Allocated Types
.............................

The following functions and structs are used to create
:ref:`heap types <heap-types>`.

.. c:function:: PyObject* PyType_FromMetaclass(PyTypeObject *metaclass, PyObject *module, PyType_Spec *spec, PyObject *bases)

   Create and return a :ref:`heap type <heap-types>` from the *spec*
   (see :c:macro:`Py_TPFLAGS_HEAPTYPE`).

   The metaclass *metaclass* is used to construct the resulting type object.
   When *metaclass* is ``NULL``, the metaclass is derived from *bases*
   (or *Py_tp_base[s]* slots if *bases* is ``NULL``, see below).

   Metaclasses that override :c:member:`~PyTypeObject.tp_new` are not
   supported, except if ``tp_new`` is ``NULL``.
   (For backwards compatibility, other ``PyType_From*`` functions allow
   such metaclasses. They ignore ``tp_new``, which may result in incomplete
   initialization. This is deprecated and in Python 3.14+ such metaclasses will
   not be supported.)

   The *bases* argument can be used to specify base classes; it can either
   be only one class or a tuple of classes.
   If *bases* is ``NULL``, the *Py_tp_bases* slot is used instead.
   If that also is ``NULL``, the *Py_tp_base* slot is used instead.
   If that also is ``NULL``, the new type derives from :class:`object`.

   The *module* argument can be used to record the module in which the new
   class is defined. It must be a module object or ``NULL``.
   If not ``NULL``, the module is associated with the new type and can later be
   retrieved with :c:func:`PyType_GetModule`.
   The associated module is not inherited by subclasses; it must be specified
   for each class individually.

   This function calls :c:func:`PyType_Ready` on the new type.

   Note that this function does *not* fully match the behavior of
   calling :py:class:`type() <type>` or using the :keyword:`class` statement.
   With user-provided base types or metaclasses, prefer
   :ref:`calling <capi-call>` :py:class:`type` (or the metaclass)
   over ``PyType_From*`` functions.
   Specifically:

   * :py:meth:`~object.__new__` is not called on the new class
     (and it must be set to ``type.__new__``).
   * :py:meth:`~object.__init__` is not called on the new class.
   * :py:meth:`~object.__init_subclass__` is not called on any bases.
   * :py:meth:`~object.__set_name__` is not called on new descriptors.

   .. versionadded:: 3.12

.. c:function:: PyObject* PyType_FromModuleAndSpec(PyObject *module, PyType_Spec *spec, PyObject *bases)

   Equivalent to ``PyType_FromMetaclass(NULL, module, spec, bases)``.

   .. versionadded:: 3.9

   .. versionchanged:: 3.10

      The function now accepts a single class as the *bases* argument and
      ``NULL`` as the ``tp_doc`` slot.

   .. versionchanged:: 3.12

      The function now finds and uses a metaclass corresponding to the provided
      base classes.  Previously, only :class:`type` instances were returned.

      The :c:member:`~PyTypeObject.tp_new` of the metaclass is *ignored*.
      which may result in incomplete initialization.
      Creating classes whose metaclass overrides
      :c:member:`~PyTypeObject.tp_new` is deprecated.

   .. versionchanged:: 3.14

      Creating classes whose metaclass overrides
      :c:member:`~PyTypeObject.tp_new` is no longer allowed.

.. c:function:: PyObject* PyType_FromSpecWithBases(PyType_Spec *spec, PyObject *bases)

   Equivalent to ``PyType_FromMetaclass(NULL, NULL, spec, bases)``.

   .. versionadded:: 3.3

   .. versionchanged:: 3.12

      The function now finds and uses a metaclass corresponding to the provided
      base classes.  Previously, only :class:`type` instances were returned.

      The :c:member:`~PyTypeObject.tp_new` of the metaclass is *ignored*.
      which may result in incomplete initialization.
      Creating classes whose metaclass overrides
      :c:member:`~PyTypeObject.tp_new` is deprecated.

   .. versionchanged:: 3.14

      Creating classes whose metaclass overrides
      :c:member:`~PyTypeObject.tp_new` is no longer allowed.

.. c:function:: PyObject* PyType_FromSpec(PyType_Spec *spec)

   Equivalent to ``PyType_FromMetaclass(NULL, NULL, spec, NULL)``.

   .. versionchanged:: 3.12

      The function now finds and uses a metaclass corresponding to the
      base classes provided in *Py_tp_base[s]* slots.
      Previously, only :class:`type` instances were returned.

      The :c:member:`~PyTypeObject.tp_new` of the metaclass is *ignored*.
      which may result in incomplete initialization.
      Creating classes whose metaclass overrides
      :c:member:`~PyTypeObject.tp_new` is deprecated.

   .. versionchanged:: 3.14

      Creating classes whose metaclass overrides
      :c:member:`~PyTypeObject.tp_new` is no longer allowed.

.. c:function:: int PyType_Freeze(PyTypeObject *type)

   Make a type immutable: set the :c:macro:`Py_TPFLAGS_IMMUTABLETYPE` flag.

   All base classes of *type* must be immutable.

   On success, return ``0``.
   On error, set an exception and return ``-1``.

   The type must not be used before it's made immutable. For example, type
   instances must not be created before the type is made immutable.

   .. versionadded:: 3.14

.. raw:: html

   <!-- Keep old URL fragments working (see gh-97908) -->
   <span id='c.PyType_Spec.PyType_Spec.name'></span>
   <span id='c.PyType_Spec.PyType_Spec.basicsize'></span>
   <span id='c.PyType_Spec.PyType_Spec.itemsize'></span>
   <span id='c.PyType_Spec.PyType_Spec.flags'></span>
   <span id='c.PyType_Spec.PyType_Spec.slots'></span>

.. c:type:: PyType_Spec

   Structure defining a type's behavior.

   .. c:member:: const char* name

      Name of the type, used to set :c:member:`PyTypeObject.tp_name`.

   .. c:member:: int basicsize

      If positive, specifies the size of the instance in bytes.
      It is used to set :c:member:`PyTypeObject.tp_basicsize`.

      If zero, specifies that :c:member:`~PyTypeObject.tp_basicsize`
      should be inherited.

      If negative, the absolute value specifies how much space instances of the
      class need *in addition* to the superclass.
      Use :c:func:`PyObject_GetTypeData` to get a pointer to subclass-specific
      memory reserved this way.

      .. versionchanged:: 3.12

         Previously, this field could not be negative.

   .. c:member:: int itemsize

      Size of one element of a variable-size type, in bytes.
      Used to set :c:member:`PyTypeObject.tp_itemsize`.
      See ``tp_itemsize`` documentation for caveats.

      If zero, :c:member:`~PyTypeObject.tp_itemsize` is inherited.
      Extending arbitrary variable-sized classes is dangerous,
      since some types use a fixed offset for variable-sized memory,
      which can then overlap fixed-sized memory used by a subclass.
      To help prevent mistakes, inheriting ``itemsize`` is only possible
      in the following situations:

      - The base is not variable-sized (its
        :c:member:`~PyTypeObject.tp_itemsize`).
      - The requested :c:member:`PyType_Spec.basicsize` is positive,
        suggesting that the memory layout of the base class is known.
      - The requested :c:member:`PyType_Spec.basicsize` is zero,
        suggesting that the subclass does not access the instance's memory
        directly.
      - With the :c:macro:`Py_TPFLAGS_ITEMS_AT_END` flag.

   .. c:member:: unsigned int flags

      Type flags, used to set :c:member:`PyTypeObject.tp_flags`.

      If the ``Py_TPFLAGS_HEAPTYPE`` flag is not set,
      :c:func:`PyType_FromSpecWithBases` sets it automatically.

   .. c:member:: PyType_Slot *slots

      Array of :c:type:`PyType_Slot` structures.
      Terminated by the special slot value ``{0, NULL}``.

      Each slot ID should be specified at most once.

.. raw:: html

   <!-- Keep old URL fragments working (see gh-97908) -->
   <span id='c.PyType_Slot.PyType_Slot.slot'></span>
   <span id='c.PyType_Slot.PyType_Slot.pfunc'></span>

.. c:type:: PyType_Slot

   Structure defining optional functionality of a type, containing a slot ID
   and a value pointer.

   .. c:member:: int slot

      A slot ID.

      Slot IDs are named like the field names of the structures
      :c:type:`PyTypeObject`, :c:type:`PyNumberMethods`,
      :c:type:`PySequenceMethods`, :c:type:`PyMappingMethods` and
      :c:type:`PyAsyncMethods` with an added ``Py_`` prefix.
      For example, use:

      * ``Py_tp_dealloc`` to set :c:member:`PyTypeObject.tp_dealloc`
      * ``Py_nb_add`` to set :c:member:`PyNumberMethods.nb_add`
      * ``Py_sq_length`` to set :c:member:`PySequenceMethods.sq_length`

      An additional slot is supported that does not correspond to a
      :c:type:`!PyTypeObject` struct field:

      * :c:data:`Py_tp_token`

      The following “offset” fields cannot be set using :c:type:`PyType_Slot`:

      * :c:member:`~PyTypeObject.tp_weaklistoffset`
        (use :c:macro:`Py_TPFLAGS_MANAGED_WEAKREF` instead if possible)
      * :c:member:`~PyTypeObject.tp_dictoffset`
        (use :c:macro:`Py_TPFLAGS_MANAGED_DICT` instead if possible)
      * :c:member:`~PyTypeObject.tp_vectorcall_offset`
        (use ``"__vectorcalloffset__"`` in
        :ref:`PyMemberDef <pymemberdef-offsets>`)

      If it is not possible to switch to a ``MANAGED`` flag (for example,
      for vectorcall or to support Python older than 3.12), specify the
      offset in :c:member:`Py_tp_members <PyTypeObject.tp_members>`.
      See :ref:`PyMemberDef documentation <pymemberdef-offsets>`
      for details.

      The following internal fields cannot be set at all when creating a heap
      type:

      * :c:member:`~PyTypeObject.tp_dict`,
        :c:member:`~PyTypeObject.tp_mro`,
        :c:member:`~PyTypeObject.tp_cache`,
        :c:member:`~PyTypeObject.tp_subclasses`, and
        :c:member:`~PyTypeObject.tp_weaklist`.

      Setting :c:data:`Py_tp_bases` or :c:data:`Py_tp_base` may be
      problematic on some platforms.
      To avoid issues, use the *bases* argument of
      :c:func:`PyType_FromSpecWithBases` instead.

      .. versionchanged:: 3.9
         Slots in :c:type:`PyBufferProcs` may be set in the unlimited API.

      .. versionchanged:: 3.11
         :c:member:`~PyBufferProcs.bf_getbuffer` and
         :c:member:`~PyBufferProcs.bf_releasebuffer` are now available
         under the :ref:`limited API <limited-c-api>`.

      .. versionchanged:: 3.14
         The field :c:member:`~PyTypeObject.tp_vectorcall` can now set
         using ``Py_tp_vectorcall``.  See the field's documentation
         for details.

   .. c:member:: void *pfunc

      The desired value of the slot. In most cases, this is a pointer
      to a function.

      *pfunc* values may not be ``NULL``, except for the following slots:

      * ``Py_tp_doc``
      * :c:data:`Py_tp_token` (for clarity, prefer :c:data:`Py_TP_USE_SPEC`
        rather than ``NULL``)

.. c:macro:: Py_tp_token

   A :c:member:`~PyType_Slot.slot` that records a static memory layout ID
   for a class.

   If the :c:type:`PyType_Spec` of the class is statically
   allocated, the token can be set to the spec using the special value
   :c:data:`Py_TP_USE_SPEC`:

   .. code-block:: c

      static PyType_Slot foo_slots[] = {
         {Py_tp_token, Py_TP_USE_SPEC},

   It can also be set to an arbitrary pointer, but you must ensure that:

   * The pointer outlives the class, so it's not reused for something else
     while the class exists.
   * It "belongs" to the extension module where the class lives, so it will not
     clash with other extensions.

   Use :c:func:`PyType_GetBaseByToken` to check if a class's superclass has
   a given token -- that is, check whether the memory layout is compatible.

   To get the token for a given class (without considering superclasses),
   use :c:func:`PyType_GetSlot` with ``Py_tp_token``.

   .. versionadded:: 3.14

   .. c:namespace:: NULL

   .. c:macro:: Py_TP_USE_SPEC

      Used as a value with :c:data:`Py_tp_token` to set the token to the
      class's :c:type:`PyType_Spec`.
      Expands to ``NULL``.

      .. versionadded:: 3.14


================================================
File: /Doc/c-api/typehints.rst
================================================
.. highlight:: c

.. _typehintobjects:

Objects for Type Hinting
------------------------

Various built-in types for type hinting are provided.  Currently,
two types exist -- :ref:`GenericAlias <types-genericalias>` and
:ref:`Union <types-union>`.  Only ``GenericAlias`` is exposed to C.

.. c:function:: PyObject* Py_GenericAlias(PyObject *origin, PyObject *args)

   Create a :ref:`GenericAlias <types-genericalias>` object.
   Equivalent to calling the Python class
   :class:`types.GenericAlias`.  The *origin* and *args* arguments set the
   ``GenericAlias``\ 's ``__origin__`` and ``__args__`` attributes respectively.
   *origin* should be a :c:expr:`PyTypeObject*`, and *args* can be a
   :c:expr:`PyTupleObject*` or any ``PyObject*``.  If *args* passed is
   not a tuple, a 1-tuple is automatically constructed and ``__args__`` is set
   to ``(args,)``.
   Minimal checking is done for the arguments, so the function will succeed even
   if *origin* is not a type.
   The ``GenericAlias``\ 's ``__parameters__`` attribute is constructed lazily
   from ``__args__``.  On failure, an exception is raised and ``NULL`` is
   returned.

   Here's an example of how to make an extension type generic::

      ...
      static PyMethodDef my_obj_methods[] = {
          // Other methods.
          ...
          {"__class_getitem__", Py_GenericAlias, METH_O|METH_CLASS, "See PEP 585"}
          ...
      }

   .. seealso:: The data model method :meth:`~object.__class_getitem__`.

   .. versionadded:: 3.9

.. c:var:: PyTypeObject Py_GenericAliasType

   The C type of the object returned by :c:func:`Py_GenericAlias`. Equivalent to
   :class:`types.GenericAlias` in Python.

   .. versionadded:: 3.9


================================================
File: /Doc/c-api/utilities.rst
================================================
.. highlight:: c

.. _utilities:

*********
Utilities
*********

The functions in this chapter perform various utility tasks, ranging from
helping C code be more portable across platforms, using Python modules from C,
and parsing function arguments and constructing Python values from C values.

.. toctree::

   sys.rst
   import.rst
   marshal.rst
   arg.rst
   conversion.rst
   hash.rst
   reflection.rst
   codec.rst
   time.rst
   perfmaps.rst


================================================
File: /Doc/c-api/veryhigh.rst
================================================
.. highlight:: c


.. _veryhigh:

*************************
The Very High Level Layer
*************************

The functions in this chapter will let you execute Python source code given in a
file or a buffer, but they will not let you interact in a more detailed way with
the interpreter.

Several of these functions accept a start symbol from the grammar as a
parameter.  The available start symbols are :c:data:`Py_eval_input`,
:c:data:`Py_file_input`, and :c:data:`Py_single_input`.  These are described
following the functions which accept them as parameters.

Note also that several of these functions take :c:expr:`FILE*` parameters.  One
particular issue which needs to be handled carefully is that the :c:type:`FILE`
structure for different C libraries can be different and incompatible.  Under
Windows (at least), it is possible for dynamically linked extensions to actually
use different libraries, so care should be taken that :c:expr:`FILE*` parameters
are only passed to these functions if it is certain that they were created by
the same library that the Python runtime is using.


.. c:function:: int PyRun_AnyFile(FILE *fp, const char *filename)

   This is a simplified interface to :c:func:`PyRun_AnyFileExFlags` below, leaving
   *closeit* set to ``0`` and *flags* set to ``NULL``.


.. c:function:: int PyRun_AnyFileFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)

   This is a simplified interface to :c:func:`PyRun_AnyFileExFlags` below, leaving
   the *closeit* argument set to ``0``.


.. c:function:: int PyRun_AnyFileEx(FILE *fp, const char *filename, int closeit)

   This is a simplified interface to :c:func:`PyRun_AnyFileExFlags` below, leaving
   the *flags* argument set to ``NULL``.


.. c:function:: int PyRun_AnyFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)

   If *fp* refers to a file associated with an interactive device (console or
   terminal input or Unix pseudo-terminal), return the value of
   :c:func:`PyRun_InteractiveLoop`, otherwise return the result of
   :c:func:`PyRun_SimpleFile`.  *filename* is decoded from the filesystem
   encoding (:func:`sys.getfilesystemencoding`).  If *filename* is ``NULL``, this
   function uses ``"???"`` as the filename.
   If *closeit* is true, the file is closed before
   ``PyRun_SimpleFileExFlags()`` returns.


.. c:function:: int PyRun_SimpleString(const char *command)

   This is a simplified interface to :c:func:`PyRun_SimpleStringFlags` below,
   leaving the :c:struct:`PyCompilerFlags`\* argument set to ``NULL``.


.. c:function:: int PyRun_SimpleStringFlags(const char *command, PyCompilerFlags *flags)

   Executes the Python source code from *command* in the :mod:`__main__` module
   according to the *flags* argument. If :mod:`__main__` does not already exist, it
   is created.  Returns ``0`` on success or ``-1`` if an exception was raised.  If
   there was an error, there is no way to get the exception information. For the
   meaning of *flags*, see below.

   Note that if an otherwise unhandled :exc:`SystemExit` is raised, this
   function will not return ``-1``, but exit the process, as long as
   :c:member:`PyConfig.inspect` is zero.


.. c:function:: int PyRun_SimpleFile(FILE *fp, const char *filename)

   This is a simplified interface to :c:func:`PyRun_SimpleFileExFlags` below,
   leaving *closeit* set to ``0`` and *flags* set to ``NULL``.


.. c:function:: int PyRun_SimpleFileEx(FILE *fp, const char *filename, int closeit)

   This is a simplified interface to :c:func:`PyRun_SimpleFileExFlags` below,
   leaving *flags* set to ``NULL``.


.. c:function:: int PyRun_SimpleFileExFlags(FILE *fp, const char *filename, int closeit, PyCompilerFlags *flags)

   Similar to :c:func:`PyRun_SimpleStringFlags`, but the Python source code is read
   from *fp* instead of an in-memory string. *filename* should be the name of
   the file, it is decoded from :term:`filesystem encoding and error handler`.
   If *closeit* is true, the file is closed before
   ``PyRun_SimpleFileExFlags()`` returns.

   .. note::
      On Windows, *fp* should be opened as binary mode (e.g. ``fopen(filename, "rb")``).
      Otherwise, Python may not handle script file with LF line ending correctly.


.. c:function:: int PyRun_InteractiveOne(FILE *fp, const char *filename)

   This is a simplified interface to :c:func:`PyRun_InteractiveOneFlags` below,
   leaving *flags* set to ``NULL``.


.. c:function:: int PyRun_InteractiveOneFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)

   Read and execute a single statement from a file associated with an
   interactive device according to the *flags* argument.  The user will be
   prompted using ``sys.ps1`` and ``sys.ps2``.  *filename* is decoded from the
   :term:`filesystem encoding and error handler`.

   Returns ``0`` when the input was
   executed successfully, ``-1`` if there was an exception, or an error code
   from the :file:`errcode.h` include file distributed as part of Python if
   there was a parse error.  (Note that :file:`errcode.h` is not included by
   :file:`Python.h`, so must be included specifically if needed.)


.. c:function:: int PyRun_InteractiveLoop(FILE *fp, const char *filename)

   This is a simplified interface to :c:func:`PyRun_InteractiveLoopFlags` below,
   leaving *flags* set to ``NULL``.


.. c:function:: int PyRun_InteractiveLoopFlags(FILE *fp, const char *filename, PyCompilerFlags *flags)

   Read and execute statements from a file associated with an interactive device
   until EOF is reached.  The user will be prompted using ``sys.ps1`` and
   ``sys.ps2``.  *filename* is decoded from the :term:`filesystem encoding and
   error handler`.  Returns ``0`` at EOF or a negative number upon failure.


.. c:var:: int (*PyOS_InputHook)(void)

   Can be set to point to a function with the prototype
   ``int func(void)``.  The function will be called when Python's
   interpreter prompt is about to become idle and wait for user input
   from the terminal.  The return value is ignored.  Overriding this
   hook can be used to integrate the interpreter's prompt with other
   event loops, as done in the :file:`Modules/_tkinter.c` in the
   Python source code.

   .. versionchanged:: 3.12
      This function is only called from the
      :ref:`main interpreter <sub-interpreter-support>`.


.. c:var:: char* (*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, const char *)

   Can be set to point to a function with the prototype
   ``char *func(FILE *stdin, FILE *stdout, char *prompt)``,
   overriding the default function used to read a single line of input
   at the interpreter's prompt.  The function is expected to output
   the string *prompt* if it's not ``NULL``, and then read a line of
   input from the provided standard input file, returning the
   resulting string.  For example, The :mod:`readline` module sets
   this hook to provide line-editing and tab-completion features.

   The result must be a string allocated by :c:func:`PyMem_RawMalloc` or
   :c:func:`PyMem_RawRealloc`, or ``NULL`` if an error occurred.

   .. versionchanged:: 3.4
      The result must be allocated by :c:func:`PyMem_RawMalloc` or
      :c:func:`PyMem_RawRealloc`, instead of being allocated by
      :c:func:`PyMem_Malloc` or :c:func:`PyMem_Realloc`.

   .. versionchanged:: 3.12
      This function is only called from the
      :ref:`main interpreter <sub-interpreter-support>`.

.. c:function:: PyObject* PyRun_String(const char *str, int start, PyObject *globals, PyObject *locals)

   This is a simplified interface to :c:func:`PyRun_StringFlags` below, leaving
   *flags* set to ``NULL``.


.. c:function:: PyObject* PyRun_StringFlags(const char *str, int start, PyObject *globals, PyObject *locals, PyCompilerFlags *flags)

   Execute Python source code from *str* in the context specified by the
   objects *globals* and *locals* with the compiler flags specified by
   *flags*.  *globals* must be a dictionary; *locals* can be any object
   that implements the mapping protocol.  The parameter *start* specifies
   the start token that should be used to parse the source code.

   Returns the result of executing the code as a Python object, or ``NULL`` if an
   exception was raised.


.. c:function:: PyObject* PyRun_File(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals)

   This is a simplified interface to :c:func:`PyRun_FileExFlags` below, leaving
   *closeit* set to ``0`` and *flags* set to ``NULL``.


.. c:function:: PyObject* PyRun_FileEx(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, int closeit)

   This is a simplified interface to :c:func:`PyRun_FileExFlags` below, leaving
   *flags* set to ``NULL``.


.. c:function:: PyObject* PyRun_FileFlags(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, PyCompilerFlags *flags)

   This is a simplified interface to :c:func:`PyRun_FileExFlags` below, leaving
   *closeit* set to ``0``.


.. c:function:: PyObject* PyRun_FileExFlags(FILE *fp, const char *filename, int start, PyObject *globals, PyObject *locals, int closeit, PyCompilerFlags *flags)

   Similar to :c:func:`PyRun_StringFlags`, but the Python source code is read from
   *fp* instead of an in-memory string. *filename* should be the name of the file,
   it is decoded from the :term:`filesystem encoding and error handler`.
   If *closeit* is true, the file is closed before :c:func:`PyRun_FileExFlags`
   returns.


.. c:function:: PyObject* Py_CompileString(const char *str, const char *filename, int start)

   This is a simplified interface to :c:func:`Py_CompileStringFlags` below, leaving
   *flags* set to ``NULL``.


.. c:function:: PyObject* Py_CompileStringFlags(const char *str, const char *filename, int start, PyCompilerFlags *flags)

   This is a simplified interface to :c:func:`Py_CompileStringExFlags` below, with
   *optimize* set to ``-1``.


.. c:function:: PyObject* Py_CompileStringObject(const char *str, PyObject *filename, int start, PyCompilerFlags *flags, int optimize)

   Parse and compile the Python source code in *str*, returning the resulting code
   object.  The start token is given by *start*; this can be used to constrain the
   code which can be compiled and should be :c:data:`Py_eval_input`,
   :c:data:`Py_file_input`, or :c:data:`Py_single_input`.  The filename specified by
   *filename* is used to construct the code object and may appear in tracebacks or
   :exc:`SyntaxError` exception messages.  This returns ``NULL`` if the code
   cannot be parsed or compiled.

   The integer *optimize* specifies the optimization level of the compiler; a
   value of ``-1`` selects the optimization level of the interpreter as given by
   :option:`-O` options.  Explicit levels are ``0`` (no optimization;
   ``__debug__`` is true), ``1`` (asserts are removed, ``__debug__`` is false)
   or ``2`` (docstrings are removed too).

   .. versionadded:: 3.4


.. c:function:: PyObject* Py_CompileStringExFlags(const char *str, const char *filename, int start, PyCompilerFlags *flags, int optimize)

   Like :c:func:`Py_CompileStringObject`, but *filename* is a byte string
   decoded from the :term:`filesystem encoding and error handler`.

   .. versionadded:: 3.2

.. c:function:: PyObject* PyEval_EvalCode(PyObject *co, PyObject *globals, PyObject *locals)

   This is a simplified interface to :c:func:`PyEval_EvalCodeEx`, with just
   the code object, and global and local variables.  The other arguments are
   set to ``NULL``.


.. c:function:: PyObject* PyEval_EvalCodeEx(PyObject *co, PyObject *globals, PyObject *locals, PyObject *const *args, int argcount, PyObject *const *kws, int kwcount, PyObject *const *defs, int defcount, PyObject *kwdefs, PyObject *closure)

   Evaluate a precompiled code object, given a particular environment for its
   evaluation.  This environment consists of a dictionary of global variables,
   a mapping object of local variables, arrays of arguments, keywords and
   defaults, a dictionary of default values for :ref:`keyword-only
   <keyword-only_parameter>` arguments and a closure tuple of cells.


.. c:function:: PyObject* PyEval_EvalFrame(PyFrameObject *f)

   Evaluate an execution frame.  This is a simplified interface to
   :c:func:`PyEval_EvalFrameEx`, for backward compatibility.


.. c:function:: PyObject* PyEval_EvalFrameEx(PyFrameObject *f, int throwflag)

   This is the main, unvarnished function of Python interpretation.  The code
   object associated with the execution frame *f* is executed, interpreting
   bytecode and executing calls as needed.  The additional *throwflag*
   parameter can mostly be ignored - if true, then it causes an exception
   to immediately be thrown; this is used for the :meth:`~generator.throw`
   methods of generator objects.

   .. versionchanged:: 3.4
      This function now includes a debug assertion to help ensure that it
      does not silently discard an active exception.


.. c:function:: int PyEval_MergeCompilerFlags(PyCompilerFlags *cf)

   This function changes the flags of the current evaluation frame, and returns
   true on success, false on failure.


.. c:var:: int Py_eval_input

   .. index:: single: Py_CompileString (C function)

   The start symbol from the Python grammar for isolated expressions; for use with
   :c:func:`Py_CompileString`.


.. c:var:: int Py_file_input

   .. index:: single: Py_CompileString (C function)

   The start symbol from the Python grammar for sequences of statements as read
   from a file or other source; for use with :c:func:`Py_CompileString`.  This is
   the symbol to use when compiling arbitrarily long Python source code.


.. c:var:: int Py_single_input

   .. index:: single: Py_CompileString (C function)

   The start symbol from the Python grammar for a single statement; for use with
   :c:func:`Py_CompileString`. This is the symbol used for the interactive
   interpreter loop.


.. c:struct:: PyCompilerFlags

   This is the structure used to hold compiler flags.  In cases where code is only
   being compiled, it is passed as ``int flags``, and in cases where code is being
   executed, it is passed as ``PyCompilerFlags *flags``.  In this case, ``from
   __future__ import`` can modify *flags*.

   Whenever ``PyCompilerFlags *flags`` is ``NULL``, :c:member:`~PyCompilerFlags.cf_flags` is treated as
   equal to ``0``, and any modification due to ``from __future__ import`` is
   discarded.

   .. c:member:: int cf_flags

      Compiler flags.

   .. c:member:: int cf_feature_version

      *cf_feature_version* is the minor Python version. It should be
      initialized to ``PY_MINOR_VERSION``.

      The field is ignored by default, it is used if and only if
      ``PyCF_ONLY_AST`` flag is set in :c:member:`~PyCompilerFlags.cf_flags`.

   .. versionchanged:: 3.8
      Added *cf_feature_version* field.


.. c:var:: int CO_FUTURE_DIVISION

   This bit can be set in *flags* to cause division operator ``/`` to be
   interpreted as "true division" according to :pep:`238`.


================================================
File: /Doc/c-api/weakref.rst
================================================
.. highlight:: c

.. _weakrefobjects:

Weak Reference Objects
----------------------

Python supports *weak references* as first-class objects.  There are two
specific object types which directly implement weak references.  The first is a
simple reference object, and the second acts as a proxy for the original object
as much as it can.


.. c:function:: int PyWeakref_Check(PyObject *ob)

   Return non-zero if *ob* is either a reference or proxy object.  This function
   always succeeds.


.. c:function:: int PyWeakref_CheckRef(PyObject *ob)

   Return non-zero if *ob* is a reference object.  This function always succeeds.


.. c:function:: int PyWeakref_CheckProxy(PyObject *ob)

   Return non-zero if *ob* is a proxy object.  This function always succeeds.


.. c:function:: PyObject* PyWeakref_NewRef(PyObject *ob, PyObject *callback)

   Return a weak reference object for the object *ob*.  This will always return
   a new reference, but is not guaranteed to create a new object; an existing
   reference object may be returned.  The second parameter, *callback*, can be a
   callable object that receives notification when *ob* is garbage collected; it
   should accept a single parameter, which will be the weak reference object
   itself. *callback* may also be ``None`` or ``NULL``.  If *ob* is not a
   weakly referenceable object, or if *callback* is not callable, ``None``, or
   ``NULL``, this will return ``NULL`` and raise :exc:`TypeError`.


.. c:function:: PyObject* PyWeakref_NewProxy(PyObject *ob, PyObject *callback)

   Return a weak reference proxy object for the object *ob*.  This will always
   return a new reference, but is not guaranteed to create a new object; an
   existing proxy object may be returned.  The second parameter, *callback*, can
   be a callable object that receives notification when *ob* is garbage
   collected; it should accept a single parameter, which will be the weak
   reference object itself. *callback* may also be ``None`` or ``NULL``.  If *ob*
   is not a weakly referenceable object, or if *callback* is not callable,
   ``None``, or ``NULL``, this will return ``NULL`` and raise :exc:`TypeError`.


.. c:function:: int PyWeakref_GetRef(PyObject *ref, PyObject **pobj)

   Get a :term:`strong reference` to the referenced object from a weak
   reference, *ref*, into *\*pobj*.

   * On success, set *\*pobj* to a new :term:`strong reference` to the
     referenced object and return 1.
   * If the reference is dead, set *\*pobj* to ``NULL`` and return 0.
   * On error, raise an exception and return -1.

   .. versionadded:: 3.13


.. c:function:: PyObject* PyWeakref_GetObject(PyObject *ref)

   Return a :term:`borrowed reference` to the referenced object from a weak
   reference, *ref*.  If the referent is no longer live, returns ``Py_None``.

   .. note::

      This function returns a :term:`borrowed reference` to the referenced object.
      This means that you should always call :c:func:`Py_INCREF` on the object
      except when it cannot be destroyed before the last usage of the borrowed
      reference.

   .. deprecated-removed:: 3.13 3.15
      Use :c:func:`PyWeakref_GetRef` instead.


.. c:function:: PyObject* PyWeakref_GET_OBJECT(PyObject *ref)

   Similar to :c:func:`PyWeakref_GetObject`, but does no error checking.

   .. deprecated-removed:: 3.13 3.15
      Use :c:func:`PyWeakref_GetRef` instead.


.. c:function:: int PyWeakref_IsDead(PyObject *ref)

   Test if the weak reference *ref* is dead. Returns 1 if the reference is
   dead, 0 if it is alive, and -1 with an error set if *ref* is not a weak
   reference object.

   .. versionadded:: 3.14


.. c:function:: void PyObject_ClearWeakRefs(PyObject *object)

   This function is called by the :c:member:`~PyTypeObject.tp_dealloc` handler
   to clear weak references.

   This iterates through the weak references for *object* and calls callbacks
   for those references which have one. It returns when all callbacks have
   been attempted.


.. c:function:: void PyUnstable_Object_ClearWeakRefsNoCallbacks(PyObject *object)

   Clears the weakrefs for *object* without calling the callbacks.

   This function is called by the :c:member:`~PyTypeObject.tp_dealloc` handler
   for types with finalizers (i.e., :meth:`~object.__del__`).  The handler for
   those objects first calls :c:func:`PyObject_ClearWeakRefs` to clear weakrefs
   and call their callbacks, then the finalizer, and finally this function to
   clear any weakrefs that may have been created by the finalizer.

   In most circumstances, it's more appropriate to use
   :c:func:`PyObject_ClearWeakRefs` to clear weakrefs instead of this function.

   .. versionadded:: 3.13


================================================
File: /Doc/data/stable_abi.dat
================================================
role,name,added,ifdef_note,struct_abi_kind
macro,PY_VECTORCALL_ARGUMENTS_OFFSET,3.12,,
func,PyAIter_Check,3.10,,
func,PyArg_Parse,3.2,,
func,PyArg_ParseTuple,3.2,,
func,PyArg_ParseTupleAndKeywords,3.2,,
func,PyArg_UnpackTuple,3.2,,
func,PyArg_VaParse,3.2,,
func,PyArg_VaParseTupleAndKeywords,3.2,,
func,PyArg_ValidateKeywordArguments,3.2,,
data,PyBaseObject_Type,3.2,,
func,PyBool_FromLong,3.2,,
data,PyBool_Type,3.2,,
func,PyBuffer_FillContiguousStrides,3.11,,
func,PyBuffer_FillInfo,3.11,,
func,PyBuffer_FromContiguous,3.11,,
func,PyBuffer_GetPointer,3.11,,
func,PyBuffer_IsContiguous,3.11,,
func,PyBuffer_Release,3.11,,
func,PyBuffer_SizeFromFormat,3.11,,
func,PyBuffer_ToContiguous,3.11,,
data,PyByteArrayIter_Type,3.2,,
func,PyByteArray_AsString,3.2,,
func,PyByteArray_Concat,3.2,,
func,PyByteArray_FromObject,3.2,,
func,PyByteArray_FromStringAndSize,3.2,,
func,PyByteArray_Resize,3.2,,
func,PyByteArray_Size,3.2,,
data,PyByteArray_Type,3.2,,
data,PyBytesIter_Type,3.2,,
func,PyBytes_AsString,3.2,,
func,PyBytes_AsStringAndSize,3.2,,
func,PyBytes_Concat,3.2,,
func,PyBytes_ConcatAndDel,3.2,,
func,PyBytes_DecodeEscape,3.2,,
func,PyBytes_FromFormat,3.2,,
func,PyBytes_FromFormatV,3.2,,
func,PyBytes_FromObject,3.2,,
func,PyBytes_FromString,3.2,,
func,PyBytes_FromStringAndSize,3.2,,
func,PyBytes_Repr,3.2,,
func,PyBytes_Size,3.2,,
data,PyBytes_Type,3.2,,
type,PyCFunction,3.2,,
type,PyCFunctionFast,3.13,,
type,PyCFunctionFastWithKeywords,3.13,,
type,PyCFunctionWithKeywords,3.2,,
func,PyCFunction_GetFlags,3.2,,
func,PyCFunction_GetFunction,3.2,,
func,PyCFunction_GetSelf,3.2,,
func,PyCFunction_New,3.4,,
func,PyCFunction_NewEx,3.2,,
data,PyCFunction_Type,3.2,,
func,PyCMethod_New,3.9,,
func,PyCallIter_New,3.2,,
data,PyCallIter_Type,3.2,,
func,PyCallable_Check,3.2,,
type,PyCapsule_Destructor,3.2,,
func,PyCapsule_GetContext,3.2,,
func,PyCapsule_GetDestructor,3.2,,
func,PyCapsule_GetName,3.2,,
func,PyCapsule_GetPointer,3.2,,
func,PyCapsule_Import,3.2,,
func,PyCapsule_IsValid,3.2,,
func,PyCapsule_New,3.2,,
func,PyCapsule_SetContext,3.2,,
func,PyCapsule_SetDestructor,3.2,,
func,PyCapsule_SetName,3.2,,
func,PyCapsule_SetPointer,3.2,,
data,PyCapsule_Type,3.2,,
data,PyClassMethodDescr_Type,3.2,,
func,PyCodec_BackslashReplaceErrors,3.2,,
func,PyCodec_Decode,3.2,,
func,PyCodec_Decoder,3.2,,
func,PyCodec_Encode,3.2,,
func,PyCodec_Encoder,3.2,,
func,PyCodec_IgnoreErrors,3.2,,
func,PyCodec_IncrementalDecoder,3.2,,
func,PyCodec_IncrementalEncoder,3.2,,
func,PyCodec_KnownEncoding,3.2,,
func,PyCodec_LookupError,3.2,,
func,PyCodec_NameReplaceErrors,3.7,,
func,PyCodec_Register,3.2,,
func,PyCodec_RegisterError,3.2,,
func,PyCodec_ReplaceErrors,3.2,,
func,PyCodec_StreamReader,3.2,,
func,PyCodec_StreamWriter,3.2,,
func,PyCodec_StrictErrors,3.2,,
func,PyCodec_Unregister,3.10,,
func,PyCodec_XMLCharRefReplaceErrors,3.2,,
func,PyComplex_FromDoubles,3.2,,
func,PyComplex_ImagAsDouble,3.2,,
func,PyComplex_RealAsDouble,3.2,,
data,PyComplex_Type,3.2,,
func,PyDescr_NewClassMethod,3.2,,
func,PyDescr_NewGetSet,3.2,,
func,PyDescr_NewMember,3.2,,
func,PyDescr_NewMethod,3.2,,
data,PyDictItems_Type,3.2,,
data,PyDictIterItem_Type,3.2,,
data,PyDictIterKey_Type,3.2,,
data,PyDictIterValue_Type,3.2,,
data,PyDictKeys_Type,3.2,,
func,PyDictProxy_New,3.2,,
data,PyDictProxy_Type,3.2,,
data,PyDictRevIterItem_Type,3.8,,
data,PyDictRevIterKey_Type,3.8,,
data,PyDictRevIterValue_Type,3.8,,
data,PyDictValues_Type,3.2,,
func,PyDict_Clear,3.2,,
func,PyDict_Contains,3.2,,
func,PyDict_Copy,3.2,,
func,PyDict_DelItem,3.2,,
func,PyDict_DelItemString,3.2,,
func,PyDict_GetItem,3.2,,
func,PyDict_GetItemRef,3.13,,
func,PyDict_GetItemString,3.2,,
func,PyDict_GetItemStringRef,3.13,,
func,PyDict_GetItemWithError,3.2,,
func,PyDict_Items,3.2,,
func,PyDict_Keys,3.2,,
func,PyDict_Merge,3.2,,
func,PyDict_MergeFromSeq2,3.2,,
func,PyDict_New,3.2,,
func,PyDict_Next,3.2,,
func,PyDict_SetItem,3.2,,
func,PyDict_SetItemString,3.2,,
func,PyDict_Size,3.2,,
data,PyDict_Type,3.2,,
func,PyDict_Update,3.2,,
func,PyDict_Values,3.2,,
data,PyEllipsis_Type,3.2,,
data,PyEnum_Type,3.2,,
func,PyErr_BadArgument,3.2,,
func,PyErr_BadInternalCall,3.2,,
func,PyErr_CheckSignals,3.2,,
func,PyErr_Clear,3.2,,
func,PyErr_Display,3.2,,
func,PyErr_DisplayException,3.12,,
func,PyErr_ExceptionMatches,3.2,,
func,PyErr_Fetch,3.2,,
func,PyErr_Format,3.2,,
func,PyErr_FormatV,3.5,,
func,PyErr_GetExcInfo,3.7,,
func,PyErr_GetHandledException,3.11,,
func,PyErr_GetRaisedException,3.12,,
func,PyErr_GivenExceptionMatches,3.2,,
func,PyErr_NewException,3.2,,
func,PyErr_NewExceptionWithDoc,3.2,,
func,PyErr_NoMemory,3.2,,
func,PyErr_NormalizeException,3.2,,
func,PyErr_Occurred,3.2,,
func,PyErr_Print,3.2,,
func,PyErr_PrintEx,3.2,,
func,PyErr_ProgramText,3.2,,
func,PyErr_ResourceWarning,3.6,,
func,PyErr_Restore,3.2,,
func,PyErr_SetExcFromWindowsErr,3.7,on Windows,
func,PyErr_SetExcFromWindowsErrWithFilename,3.7,on Windows,
func,PyErr_SetExcFromWindowsErrWithFilenameObject,3.7,on Windows,
func,PyErr_SetExcFromWindowsErrWithFilenameObjects,3.7,on Windows,
func,PyErr_SetExcInfo,3.7,,
func,PyErr_SetFromErrno,3.2,,
func,PyErr_SetFromErrnoWithFilename,3.2,,
func,PyErr_SetFromErrnoWithFilenameObject,3.2,,
func,PyErr_SetFromErrnoWithFilenameObjects,3.7,,
func,PyErr_SetFromWindowsErr,3.7,on Windows,
func,PyErr_SetFromWindowsErrWithFilename,3.7,on Windows,
func,PyErr_SetHandledException,3.11,,
func,PyErr_SetImportError,3.7,,
func,PyErr_SetImportErrorSubclass,3.6,,
func,PyErr_SetInterrupt,3.2,,
func,PyErr_SetInterruptEx,3.10,,
func,PyErr_SetNone,3.2,,
func,PyErr_SetObject,3.2,,
func,PyErr_SetRaisedException,3.12,,
func,PyErr_SetString,3.2,,
func,PyErr_SyntaxLocation,3.2,,
func,PyErr_SyntaxLocationEx,3.7,,
func,PyErr_WarnEx,3.2,,
func,PyErr_WarnExplicit,3.2,,
func,PyErr_WarnFormat,3.2,,
func,PyErr_WriteUnraisable,3.2,,
func,PyEval_AcquireThread,3.2,,
func,PyEval_EvalCode,3.2,,
func,PyEval_EvalCodeEx,3.2,,
func,PyEval_EvalFrame,3.2,,
func,PyEval_EvalFrameEx,3.2,,
func,PyEval_GetBuiltins,3.2,,
func,PyEval_GetFrame,3.2,,
func,PyEval_GetFrameBuiltins,3.13,,
func,PyEval_GetFrameGlobals,3.13,,
func,PyEval_GetFrameLocals,3.13,,
func,PyEval_GetFuncDesc,3.2,,
func,PyEval_GetFuncName,3.2,,
func,PyEval_GetGlobals,3.2,,
func,PyEval_GetLocals,3.2,,
func,PyEval_InitThreads,3.2,,
func,PyEval_ReleaseThread,3.2,,
func,PyEval_RestoreThread,3.2,,
func,PyEval_SaveThread,3.2,,
data,PyExc_ArithmeticError,3.2,,
data,PyExc_AssertionError,3.2,,
data,PyExc_AttributeError,3.2,,
data,PyExc_BaseException,3.2,,
data,PyExc_BaseExceptionGroup,3.11,,
data,PyExc_BlockingIOError,3.7,,
data,PyExc_BrokenPipeError,3.7,,
data,PyExc_BufferError,3.2,,
data,PyExc_BytesWarning,3.2,,
data,PyExc_ChildProcessError,3.7,,
data,PyExc_ConnectionAbortedError,3.7,,
data,PyExc_ConnectionError,3.7,,
data,PyExc_ConnectionRefusedError,3.7,,
data,PyExc_ConnectionResetError,3.7,,
data,PyExc_DeprecationWarning,3.2,,
data,PyExc_EOFError,3.2,,
data,PyExc_EncodingWarning,3.10,,
data,PyExc_EnvironmentError,3.2,,
data,PyExc_Exception,3.2,,
data,PyExc_FileExistsError,3.7,,
data,PyExc_FileNotFoundError,3.7,,
data,PyExc_FloatingPointError,3.2,,
data,PyExc_FutureWarning,3.2,,
data,PyExc_GeneratorExit,3.2,,
data,PyExc_IOError,3.2,,
data,PyExc_ImportError,3.2,,
data,PyExc_ImportWarning,3.2,,
data,PyExc_IndentationError,3.2,,
data,PyExc_IndexError,3.2,,
data,PyExc_InterruptedError,3.7,,
data,PyExc_IsADirectoryError,3.7,,
data,PyExc_KeyError,3.2,,
data,PyExc_KeyboardInterrupt,3.2,,
data,PyExc_LookupError,3.2,,
data,PyExc_MemoryError,3.2,,
data,PyExc_ModuleNotFoundError,3.6,,
data,PyExc_NameError,3.2,,
data,PyExc_NotADirectoryError,3.7,,
data,PyExc_NotImplementedError,3.2,,
data,PyExc_OSError,3.2,,
data,PyExc_OverflowError,3.2,,
data,PyExc_PendingDeprecationWarning,3.2,,
data,PyExc_PermissionError,3.7,,
data,PyExc_ProcessLookupError,3.7,,
data,PyExc_RecursionError,3.7,,
data,PyExc_ReferenceError,3.2,,
data,PyExc_ResourceWarning,3.7,,
data,PyExc_RuntimeError,3.2,,
data,PyExc_RuntimeWarning,3.2,,
data,PyExc_StopAsyncIteration,3.7,,
data,PyExc_StopIteration,3.2,,
data,PyExc_SyntaxError,3.2,,
data,PyExc_SyntaxWarning,3.2,,
data,PyExc_SystemError,3.2,,
data,PyExc_SystemExit,3.2,,
data,PyExc_TabError,3.2,,
data,PyExc_TimeoutError,3.7,,
data,PyExc_TypeError,3.2,,
data,PyExc_UnboundLocalError,3.2,,
data,PyExc_UnicodeDecodeError,3.2,,
data,PyExc_UnicodeEncodeError,3.2,,
data,PyExc_UnicodeError,3.2,,
data,PyExc_UnicodeTranslateError,3.2,,
data,PyExc_UnicodeWarning,3.2,,
data,PyExc_UserWarning,3.2,,
data,PyExc_ValueError,3.2,,
data,PyExc_Warning,3.2,,
data,PyExc_WindowsError,3.7,on Windows,
data,PyExc_ZeroDivisionError,3.2,,
func,PyExceptionClass_Name,3.8,,
func,PyException_GetArgs,3.12,,
func,PyException_GetCause,3.2,,
func,PyException_GetContext,3.2,,
func,PyException_GetTraceback,3.2,,
func,PyException_SetArgs,3.12,,
func,PyException_SetCause,3.2,,
func,PyException_SetContext,3.2,,
func,PyException_SetTraceback,3.2,,
func,PyFile_FromFd,3.2,,
func,PyFile_GetLine,3.2,,
func,PyFile_WriteObject,3.2,,
func,PyFile_WriteString,3.2,,
data,PyFilter_Type,3.2,,
func,PyFloat_AsDouble,3.2,,
func,PyFloat_FromDouble,3.2,,
func,PyFloat_FromString,3.2,,
func,PyFloat_GetInfo,3.2,,
func,PyFloat_GetMax,3.2,,
func,PyFloat_GetMin,3.2,,
data,PyFloat_Type,3.2,,
type,PyFrameObject,3.2,,opaque
func,PyFrame_GetCode,3.10,,
func,PyFrame_GetLineNumber,3.10,,
func,PyFrozenSet_New,3.2,,
data,PyFrozenSet_Type,3.2,,
func,PyGC_Collect,3.2,,
func,PyGC_Disable,3.10,,
func,PyGC_Enable,3.10,,
func,PyGC_IsEnabled,3.10,,
func,PyGILState_Ensure,3.2,,
func,PyGILState_GetThisThreadState,3.2,,
func,PyGILState_Release,3.2,,
type,PyGILState_STATE,3.2,,
type,PyGetSetDef,3.2,,full-abi
data,PyGetSetDescr_Type,3.2,,
func,PyImport_AddModule,3.2,,
func,PyImport_AddModuleObject,3.7,,
func,PyImport_AddModuleRef,3.13,,
func,PyImport_AppendInittab,3.2,,
func,PyImport_ExecCodeModule,3.2,,
func,PyImport_ExecCodeModuleEx,3.2,,
func,PyImport_ExecCodeModuleObject,3.7,,
func,PyImport_ExecCodeModuleWithPathnames,3.2,,
func,PyImport_GetImporter,3.2,,
func,PyImport_GetMagicNumber,3.2,,
func,PyImport_GetMagicTag,3.2,,
func,PyImport_GetModule,3.8,,
func,PyImport_GetModuleDict,3.2,,
func,PyImport_Import,3.2,,
func,PyImport_ImportFrozenModule,3.2,,
func,PyImport_ImportFrozenModuleObject,3.7,,
func,PyImport_ImportModule,3.2,,
func,PyImport_ImportModuleLevel,3.2,,
func,PyImport_ImportModuleLevelObject,3.7,,
func,PyImport_ImportModuleNoBlock,3.2,,
func,PyImport_ReloadModule,3.2,,
func,PyIndex_Check,3.8,,
type,PyInterpreterState,3.2,,opaque
func,PyInterpreterState_Clear,3.2,,
func,PyInterpreterState_Delete,3.2,,
func,PyInterpreterState_Get,3.9,,
func,PyInterpreterState_GetDict,3.8,,
func,PyInterpreterState_GetID,3.7,,
func,PyInterpreterState_New,3.2,,
func,PyIter_Check,3.8,,
func,PyIter_Next,3.2,,
func,PyIter_NextItem,3.14,,
func,PyIter_Send,3.10,,
data,PyListIter_Type,3.2,,
data,PyListRevIter_Type,3.2,,
func,PyList_Append,3.2,,
func,PyList_AsTuple,3.2,,
func,PyList_GetItem,3.2,,
func,PyList_GetItemRef,3.13,,
func,PyList_GetSlice,3.2,,
func,PyList_Insert,3.2,,
func,PyList_New,3.2,,
func,PyList_Reverse,3.2,,
func,PyList_SetItem,3.2,,
func,PyList_SetSlice,3.2,,
func,PyList_Size,3.2,,
func,PyList_Sort,3.2,,
data,PyList_Type,3.2,,
type,PyLongObject,3.2,,opaque
data,PyLongRangeIter_Type,3.2,,
func,PyLong_AsDouble,3.2,,
func,PyLong_AsInt,3.13,,
func,PyLong_AsInt32,3.14,,
func,PyLong_AsInt64,3.14,,
func,PyLong_AsLong,3.2,,
func,PyLong_AsLongAndOverflow,3.2,,
func,PyLong_AsLongLong,3.2,,
func,PyLong_AsLongLongAndOverflow,3.2,,
func,PyLong_AsSize_t,3.2,,
func,PyLong_AsSsize_t,3.2,,
func,PyLong_AsUInt32,3.14,,
func,PyLong_AsUInt64,3.14,,
func,PyLong_AsUnsignedLong,3.2,,
func,PyLong_AsUnsignedLongLong,3.2,,
func,PyLong_AsUnsignedLongLongMask,3.2,,
func,PyLong_AsUnsignedLongMask,3.2,,
func,PyLong_AsVoidPtr,3.2,,
func,PyLong_FromDouble,3.2,,
func,PyLong_FromInt32,3.14,,
func,PyLong_FromInt64,3.14,,
func,PyLong_FromLong,3.2,,
func,PyLong_FromLongLong,3.2,,
func,PyLong_FromSize_t,3.2,,
func,PyLong_FromSsize_t,3.2,,
func,PyLong_FromString,3.2,,
func,PyLong_FromUInt32,3.14,,
func,PyLong_FromUInt64,3.14,,
func,PyLong_FromUnsignedLong,3.2,,
func,PyLong_FromUnsignedLongLong,3.2,,
func,PyLong_FromVoidPtr,3.2,,
func,PyLong_GetInfo,3.2,,
data,PyLong_Type,3.2,,
data,PyMap_Type,3.2,,
func,PyMapping_Check,3.2,,
func,PyMapping_GetItemString,3.2,,
func,PyMapping_GetOptionalItem,3.13,,
func,PyMapping_GetOptionalItemString,3.13,,
func,PyMapping_HasKey,3.2,,
func,PyMapping_HasKeyString,3.2,,
func,PyMapping_HasKeyStringWithError,3.13,,
func,PyMapping_HasKeyWithError,3.13,,
func,PyMapping_Items,3.2,,
func,PyMapping_Keys,3.2,,
func,PyMapping_Length,3.2,,
func,PyMapping_SetItemString,3.2,,
func,PyMapping_Size,3.2,,
func,PyMapping_Values,3.2,,
func,PyMem_Calloc,3.7,,
func,PyMem_Free,3.2,,
func,PyMem_Malloc,3.2,,
func,PyMem_RawCalloc,3.13,,
func,PyMem_RawFree,3.13,,
func,PyMem_RawMalloc,3.13,,
func,PyMem_RawRealloc,3.13,,
func,PyMem_Realloc,3.2,,
type,PyMemberDef,3.2,,full-abi
data,PyMemberDescr_Type,3.2,,
func,PyMember_GetOne,3.2,,
func,PyMember_SetOne,3.2,,
func,PyMemoryView_FromBuffer,3.11,,
func,PyMemoryView_FromMemory,3.7,,
func,PyMemoryView_FromObject,3.2,,
func,PyMemoryView_GetContiguous,3.2,,
data,PyMemoryView_Type,3.2,,
type,PyMethodDef,3.2,,full-abi
data,PyMethodDescr_Type,3.2,,
type,PyModuleDef,3.2,,full-abi
type,PyModuleDef_Base,3.2,,full-abi
func,PyModuleDef_Init,3.5,,
data,PyModuleDef_Type,3.5,,
func,PyModule_Add,3.13,,
func,PyModule_AddFunctions,3.7,,
func,PyModule_AddIntConstant,3.2,,
func,PyModule_AddObject,3.2,,
func,PyModule_AddObjectRef,3.10,,
func,PyModule_AddStringConstant,3.2,,
func,PyModule_AddType,3.10,,
func,PyModule_Create2,3.2,,
func,PyModule_ExecDef,3.7,,
func,PyModule_FromDefAndSpec2,3.7,,
func,PyModule_GetDef,3.2,,
func,PyModule_GetDict,3.2,,
func,PyModule_GetFilename,3.2,,
func,PyModule_GetFilenameObject,3.2,,
func,PyModule_GetName,3.2,,
func,PyModule_GetNameObject,3.7,,
func,PyModule_GetState,3.2,,
func,PyModule_New,3.2,,
func,PyModule_NewObject,3.7,,
func,PyModule_SetDocString,3.7,,
data,PyModule_Type,3.2,,
func,PyNumber_Absolute,3.2,,
func,PyNumber_Add,3.2,,
func,PyNumber_And,3.2,,
func,PyNumber_AsSsize_t,3.2,,
func,PyNumber_Check,3.2,,
func,PyNumber_Divmod,3.2,,
func,PyNumber_Float,3.2,,
func,PyNumber_FloorDivide,3.2,,
func,PyNumber_InPlaceAdd,3.2,,
func,PyNumber_InPlaceAnd,3.2,,
func,PyNumber_InPlaceFloorDivide,3.2,,
func,PyNumber_InPlaceLshift,3.2,,
func,PyNumber_InPlaceMatrixMultiply,3.7,,
func,PyNumber_InPlaceMultiply,3.2,,
func,PyNumber_InPlaceOr,3.2,,
func,PyNumber_InPlacePower,3.2,,
func,PyNumber_InPlaceRemainder,3.2,,
func,PyNumber_InPlaceRshift,3.2,,
func,PyNumber_InPlaceSubtract,3.2,,
func,PyNumber_InPlaceTrueDivide,3.2,,
func,PyNumber_InPlaceXor,3.2,,
func,PyNumber_Index,3.2,,
func,PyNumber_Invert,3.2,,
func,PyNumber_Long,3.2,,
func,PyNumber_Lshift,3.2,,
func,PyNumber_MatrixMultiply,3.7,,
func,PyNumber_Multiply,3.2,,
func,PyNumber_Negative,3.2,,
func,PyNumber_Or,3.2,,
func,PyNumber_Positive,3.2,,
func,PyNumber_Power,3.2,,
func,PyNumber_Remainder,3.2,,
func,PyNumber_Rshift,3.2,,
func,PyNumber_Subtract,3.2,,
func,PyNumber_ToBase,3.2,,
func,PyNumber_TrueDivide,3.2,,
func,PyNumber_Xor,3.2,,
func,PyOS_AfterFork,3.2,on platforms with fork(),
func,PyOS_AfterFork_Child,3.7,on platforms with fork(),
func,PyOS_AfterFork_Parent,3.7,on platforms with fork(),
func,PyOS_BeforeFork,3.7,on platforms with fork(),
func,PyOS_CheckStack,3.7,on platforms with USE_STACKCHECK,
func,PyOS_FSPath,3.6,,
data,PyOS_InputHook,3.2,,
func,PyOS_InterruptOccurred,3.2,,
func,PyOS_double_to_string,3.2,,
func,PyOS_getsig,3.2,,
func,PyOS_mystricmp,3.2,,
func,PyOS_mystrnicmp,3.2,,
func,PyOS_setsig,3.2,,
type,PyOS_sighandler_t,3.2,,
func,PyOS_snprintf,3.2,,
func,PyOS_string_to_double,3.2,,
func,PyOS_strtol,3.2,,
func,PyOS_strtoul,3.2,,
func,PyOS_vsnprintf,3.2,,
type,PyObject,3.2,,members
member,PyObject.ob_refcnt,3.2,,
member,PyObject.ob_type,3.2,,
func,PyObject_ASCII,3.2,,
func,PyObject_AsFileDescriptor,3.2,,
func,PyObject_Bytes,3.2,,
func,PyObject_Call,3.2,,
func,PyObject_CallFunction,3.2,,
func,PyObject_CallFunctionObjArgs,3.2,,
func,PyObject_CallMethod,3.2,,
func,PyObject_CallMethodObjArgs,3.2,,
func,PyObject_CallNoArgs,3.10,,
func,PyObject_CallObject,3.2,,
func,PyObject_Calloc,3.7,,
func,PyObject_CheckBuffer,3.11,,
func,PyObject_ClearWeakRefs,3.2,,
func,PyObject_CopyData,3.11,,
func,PyObject_DelAttr,3.13,,
func,PyObject_DelAttrString,3.13,,
func,PyObject_DelItem,3.2,,
func,PyObject_DelItemString,3.2,,
func,PyObject_Dir,3.2,,
func,PyObject_Format,3.2,,
func,PyObject_Free,3.2,,
func,PyObject_GC_Del,3.2,,
func,PyObject_GC_IsFinalized,3.9,,
func,PyObject_GC_IsTracked,3.9,,
func,PyObject_GC_Track,3.2,,
func,PyObject_GC_UnTrack,3.2,,
func,PyObject_GenericGetAttr,3.2,,
func,PyObject_GenericGetDict,3.10,,
func,PyObject_GenericSetAttr,3.2,,
func,PyObject_GenericSetDict,3.7,,
func,PyObject_GetAIter,3.10,,
func,PyObject_GetAttr,3.2,,
func,PyObject_GetAttrString,3.2,,
func,PyObject_GetBuffer,3.11,,
func,PyObject_GetItem,3.2,,
func,PyObject_GetIter,3.2,,
func,PyObject_GetOptionalAttr,3.13,,
func,PyObject_GetOptionalAttrString,3.13,,
func,PyObject_GetTypeData,3.12,,
func,PyObject_HasAttr,3.2,,
func,PyObject_HasAttrString,3.2,,
func,PyObject_HasAttrStringWithError,3.13,,
func,PyObject_HasAttrWithError,3.13,,
func,PyObject_Hash,3.2,,
func,PyObject_HashNotImplemented,3.2,,
func,PyObject_Init,3.2,,
func,PyObject_InitVar,3.2,,
func,PyObject_IsInstance,3.2,,
func,PyObject_IsSubclass,3.2,,
func,PyObject_IsTrue,3.2,,
func,PyObject_Length,3.2,,
func,PyObject_Malloc,3.2,,
func,PyObject_Not,3.2,,
func,PyObject_Realloc,3.2,,
func,PyObject_Repr,3.2,,
func,PyObject_RichCompare,3.2,,
func,PyObject_RichCompareBool,3.2,,
func,PyObject_SelfIter,3.2,,
func,PyObject_SetAttr,3.2,,
func,PyObject_SetAttrString,3.2,,
func,PyObject_SetItem,3.2,,
func,PyObject_Size,3.2,,
func,PyObject_Str,3.2,,
func,PyObject_Type,3.2,,
func,PyObject_Vectorcall,3.12,,
func,PyObject_VectorcallMethod,3.12,,
data,PyProperty_Type,3.2,,
data,PyRangeIter_Type,3.2,,
data,PyRange_Type,3.2,,
data,PyReversed_Type,3.2,,
func,PySeqIter_New,3.2,,
data,PySeqIter_Type,3.2,,
func,PySequence_Check,3.2,,
func,PySequence_Concat,3.2,,
func,PySequence_Contains,3.2,,
func,PySequence_Count,3.2,,
func,PySequence_DelItem,3.2,,
func,PySequence_DelSlice,3.2,,
func,PySequence_Fast,3.2,,
func,PySequence_GetItem,3.2,,
func,PySequence_GetSlice,3.2,,
func,PySequence_In,3.2,,
func,PySequence_InPlaceConcat,3.2,,
func,PySequence_InPlaceRepeat,3.2,,
func,PySequence_Index,3.2,,
func,PySequence_Length,3.2,,
func,PySequence_List,3.2,,
func,PySequence_Repeat,3.2,,
func,PySequence_SetItem,3.2,,
func,PySequence_SetSlice,3.2,,
func,PySequence_Size,3.2,,
func,PySequence_Tuple,3.2,,
data,PySetIter_Type,3.2,,
func,PySet_Add,3.2,,
func,PySet_Clear,3.2,,
func,PySet_Contains,3.2,,
func,PySet_Discard,3.2,,
func,PySet_New,3.2,,
func,PySet_Pop,3.2,,
func,PySet_Size,3.2,,
data,PySet_Type,3.2,,
func,PySlice_AdjustIndices,3.7,,
func,PySlice_GetIndices,3.2,,
func,PySlice_GetIndicesEx,3.2,,
func,PySlice_New,3.2,,
data,PySlice_Type,3.2,,
func,PySlice_Unpack,3.7,,
func,PyState_AddModule,3.3,,
func,PyState_FindModule,3.2,,
func,PyState_RemoveModule,3.3,,
type,PyStructSequence_Desc,3.2,,full-abi
type,PyStructSequence_Field,3.2,,full-abi
func,PyStructSequence_GetItem,3.2,,
func,PyStructSequence_New,3.2,,
func,PyStructSequence_NewType,3.2,,
func,PyStructSequence_SetItem,3.2,,
data,PyStructSequence_UnnamedField,3.11,,
data,PySuper_Type,3.2,,
func,PySys_Audit,3.13,,
func,PySys_AuditTuple,3.13,,
func,PySys_FormatStderr,3.2,,
func,PySys_FormatStdout,3.2,,
func,PySys_GetObject,3.2,,
func,PySys_GetXOptions,3.7,,
func,PySys_ResetWarnOptions,3.2,,
func,PySys_SetArgv,3.2,,
func,PySys_SetArgvEx,3.2,,
func,PySys_SetObject,3.2,,
func,PySys_WriteStderr,3.2,,
func,PySys_WriteStdout,3.2,,
type,PyThreadState,3.2,,opaque
func,PyThreadState_Clear,3.2,,
func,PyThreadState_Delete,3.2,,
func,PyThreadState_Get,3.2,,
func,PyThreadState_GetDict,3.2,,
func,PyThreadState_GetFrame,3.10,,
func,PyThreadState_GetID,3.10,,
func,PyThreadState_GetInterpreter,3.10,,
func,PyThreadState_New,3.2,,
func,PyThreadState_SetAsyncExc,3.2,,
func,PyThreadState_Swap,3.2,,
func,PyThread_GetInfo,3.3,,
func,PyThread_ReInitTLS,3.2,,
func,PyThread_acquire_lock,3.2,,
func,PyThread_acquire_lock_timed,3.2,,
func,PyThread_allocate_lock,3.2,,
func,PyThread_create_key,3.2,,
func,PyThread_delete_key,3.2,,
func,PyThread_delete_key_value,3.2,,
func,PyThread_exit_thread,3.2,,
func,PyThread_free_lock,3.2,,
func,PyThread_get_key_value,3.2,,
func,PyThread_get_stacksize,3.2,,
func,PyThread_get_thread_ident,3.2,,
func,PyThread_get_thread_native_id,3.2,on platforms with native thread IDs,
func,PyThread_init_thread,3.2,,
func,PyThread_release_lock,3.2,,
func,PyThread_set_key_value,3.2,,
func,PyThread_set_stacksize,3.2,,
func,PyThread_start_new_thread,3.2,,
func,PyThread_tss_alloc,3.7,,
func,PyThread_tss_create,3.7,,
func,PyThread_tss_delete,3.7,,
func,PyThread_tss_free,3.7,,
func,PyThread_tss_get,3.7,,
func,PyThread_tss_is_created,3.7,,
func,PyThread_tss_set,3.7,,
func,PyTraceBack_Here,3.2,,
func,PyTraceBack_Print,3.2,,
data,PyTraceBack_Type,3.2,,
data,PyTupleIter_Type,3.2,,
func,PyTuple_GetItem,3.2,,
func,PyTuple_GetSlice,3.2,,
func,PyTuple_New,3.2,,
func,PyTuple_Pack,3.2,,
func,PyTuple_SetItem,3.2,,
func,PyTuple_Size,3.2,,
data,PyTuple_Type,3.2,,
type,PyTypeObject,3.2,,opaque
func,PyType_ClearCache,3.2,,
func,PyType_Freeze,3.14,,
func,PyType_FromMetaclass,3.12,,
func,PyType_FromModuleAndSpec,3.10,,
func,PyType_FromSpec,3.2,,
func,PyType_FromSpecWithBases,3.3,,
func,PyType_GenericAlloc,3.2,,
func,PyType_GenericNew,3.2,,
func,PyType_GetBaseByToken,3.14,,
func,PyType_GetFlags,3.2,,
func,PyType_GetFullyQualifiedName,3.13,,
func,PyType_GetModule,3.10,,
func,PyType_GetModuleByDef,3.13,,
func,PyType_GetModuleName,3.13,,
func,PyType_GetModuleState,3.10,,
func,PyType_GetName,3.11,,
func,PyType_GetQualName,3.11,,
func,PyType_GetSlot,3.4,,
func,PyType_GetTypeDataSize,3.12,,
func,PyType_IsSubtype,3.2,,
func,PyType_Modified,3.2,,
func,PyType_Ready,3.2,,
type,PyType_Slot,3.2,,full-abi
type,PyType_Spec,3.2,,full-abi
data,PyType_Type,3.2,,
func,PyUnicodeDecodeError_Create,3.2,,
func,PyUnicodeDecodeError_GetEncoding,3.2,,
func,PyUnicodeDecodeError_GetEnd,3.2,,
func,PyUnicodeDecodeError_GetObject,3.2,,
func,PyUnicodeDecodeError_GetReason,3.2,,
func,PyUnicodeDecodeError_GetStart,3.2,,
func,PyUnicodeDecodeError_SetEnd,3.2,,
func,PyUnicodeDecodeError_SetReason,3.2,,
func,PyUnicodeDecodeError_SetStart,3.2,,
func,PyUnicodeEncodeError_GetEncoding,3.2,,
func,PyUnicodeEncodeError_GetEnd,3.2,,
func,PyUnicodeEncodeError_GetObject,3.2,,
func,PyUnicodeEncodeError_GetReason,3.2,,
func,PyUnicodeEncodeError_GetStart,3.2,,
func,PyUnicodeEncodeError_SetEnd,3.2,,
func,PyUnicodeEncodeError_SetReason,3.2,,
func,PyUnicodeEncodeError_SetStart,3.2,,
data,PyUnicodeIter_Type,3.2,,
func,PyUnicodeTranslateError_GetEnd,3.2,,
func,PyUnicodeTranslateError_GetObject,3.2,,
func,PyUnicodeTranslateError_GetReason,3.2,,
func,PyUnicodeTranslateError_GetStart,3.2,,
func,PyUnicodeTranslateError_SetEnd,3.2,,
func,PyUnicodeTranslateError_SetReason,3.2,,
func,PyUnicodeTranslateError_SetStart,3.2,,
func,PyUnicode_Append,3.2,,
func,PyUnicode_AppendAndDel,3.2,,
func,PyUnicode_AsASCIIString,3.2,,
func,PyUnicode_AsCharmapString,3.2,,
func,PyUnicode_AsDecodedObject,3.2,,
func,PyUnicode_AsDecodedUnicode,3.2,,
func,PyUnicode_AsEncodedObject,3.2,,
func,PyUnicode_AsEncodedString,3.2,,
func,PyUnicode_AsEncodedUnicode,3.2,,
func,PyUnicode_AsLatin1String,3.2,,
func,PyUnicode_AsMBCSString,3.7,on Windows,
func,PyUnicode_AsRawUnicodeEscapeString,3.2,,
func,PyUnicode_AsUCS4,3.7,,
func,PyUnicode_AsUCS4Copy,3.7,,
func,PyUnicode_AsUTF16String,3.2,,
func,PyUnicode_AsUTF32String,3.2,,
func,PyUnicode_AsUTF8AndSize,3.10,,
func,PyUnicode_AsUTF8String,3.2,,
func,PyUnicode_AsUnicodeEscapeString,3.2,,
func,PyUnicode_AsWideChar,3.2,,
func,PyUnicode_AsWideCharString,3.7,,
func,PyUnicode_BuildEncodingMap,3.2,,
func,PyUnicode_Compare,3.2,,
func,PyUnicode_CompareWithASCIIString,3.2,,
func,PyUnicode_Concat,3.2,,
func,PyUnicode_Contains,3.2,,
func,PyUnicode_Count,3.2,,
func,PyUnicode_Decode,3.2,,
func,PyUnicode_DecodeASCII,3.2,,
func,PyUnicode_DecodeCharmap,3.2,,
func,PyUnicode_DecodeCodePageStateful,3.7,on Windows,
func,PyUnicode_DecodeFSDefault,3.2,,
func,PyUnicode_DecodeFSDefaultAndSize,3.2,,
func,PyUnicode_DecodeLatin1,3.2,,
func,PyUnicode_DecodeLocale,3.7,,
func,PyUnicode_DecodeLocaleAndSize,3.7,,
func,PyUnicode_DecodeMBCS,3.7,on Windows,
func,PyUnicode_DecodeMBCSStateful,3.7,on Windows,
func,PyUnicode_DecodeRawUnicodeEscape,3.2,,
func,PyUnicode_DecodeUTF16,3.2,,
func,PyUnicode_DecodeUTF16Stateful,3.2,,
func,PyUnicode_DecodeUTF32,3.2,,
func,PyUnicode_DecodeUTF32Stateful,3.2,,
func,PyUnicode_DecodeUTF7,3.2,,
func,PyUnicode_DecodeUTF7Stateful,3.2,,
func,PyUnicode_DecodeUTF8,3.2,,
func,PyUnicode_DecodeUTF8Stateful,3.2,,
func,PyUnicode_DecodeUnicodeEscape,3.2,,
func,PyUnicode_EncodeCodePage,3.7,on Windows,
func,PyUnicode_EncodeFSDefault,3.2,,
func,PyUnicode_EncodeLocale,3.7,,
func,PyUnicode_Equal,3.14,,
func,PyUnicode_EqualToUTF8,3.13,,
func,PyUnicode_EqualToUTF8AndSize,3.13,,
func,PyUnicode_FSConverter,3.2,,
func,PyUnicode_FSDecoder,3.2,,
func,PyUnicode_Find,3.2,,
func,PyUnicode_FindChar,3.7,,
func,PyUnicode_Format,3.2,,
func,PyUnicode_FromEncodedObject,3.2,,
func,PyUnicode_FromFormat,3.2,,
func,PyUnicode_FromFormatV,3.2,,
func,PyUnicode_FromObject,3.2,,
func,PyUnicode_FromOrdinal,3.2,,
func,PyUnicode_FromString,3.2,,
func,PyUnicode_FromStringAndSize,3.2,,
func,PyUnicode_FromWideChar,3.2,,
func,PyUnicode_GetDefaultEncoding,3.2,,
func,PyUnicode_GetLength,3.7,,
func,PyUnicode_InternFromString,3.2,,
func,PyUnicode_InternInPlace,3.2,,
func,PyUnicode_IsIdentifier,3.2,,
func,PyUnicode_Join,3.2,,
func,PyUnicode_Partition,3.2,,
func,PyUnicode_RPartition,3.2,,
func,PyUnicode_RSplit,3.2,,
func,PyUnicode_ReadChar,3.7,,
func,PyUnicode_Replace,3.2,,
func,PyUnicode_Resize,3.2,,
func,PyUnicode_RichCompare,3.2,,
func,PyUnicode_Split,3.2,,
func,PyUnicode_Splitlines,3.2,,
func,PyUnicode_Substring,3.7,,
func,PyUnicode_Tailmatch,3.2,,
func,PyUnicode_Translate,3.2,,
data,PyUnicode_Type,3.2,,
func,PyUnicode_WriteChar,3.7,,
type,PyVarObject,3.2,,members
member,PyVarObject.ob_base,3.2,,
member,PyVarObject.ob_size,3.2,,
func,PyVectorcall_Call,3.12,,
func,PyVectorcall_NARGS,3.12,,
type,PyWeakReference,3.2,,opaque
func,PyWeakref_GetObject,3.2,,
func,PyWeakref_GetRef,3.13,,
func,PyWeakref_NewProxy,3.2,,
func,PyWeakref_NewRef,3.2,,
data,PyWrapperDescr_Type,3.2,,
func,PyWrapper_New,3.2,,
data,PyZip_Type,3.2,,
func,Py_AddPendingCall,3.2,,
func,Py_AtExit,3.2,,
macro,Py_BEGIN_ALLOW_THREADS,3.2,,
macro,Py_BLOCK_THREADS,3.2,,
func,Py_BuildValue,3.2,,
func,Py_BytesMain,3.8,,
func,Py_CompileString,3.2,,
func,Py_DecRef,3.2,,
func,Py_DecodeLocale,3.7,,
macro,Py_END_ALLOW_THREADS,3.2,,
func,Py_EncodeLocale,3.7,,
func,Py_EndInterpreter,3.2,,
func,Py_EnterRecursiveCall,3.9,,
func,Py_Exit,3.2,,
func,Py_FatalError,3.2,,
data,Py_FileSystemDefaultEncodeErrors,3.10,,
data,Py_FileSystemDefaultEncoding,3.2,,
func,Py_Finalize,3.2,,
func,Py_FinalizeEx,3.6,,
func,Py_GenericAlias,3.9,,
data,Py_GenericAliasType,3.9,,
func,Py_GetBuildInfo,3.2,,
func,Py_GetCompiler,3.2,,
func,Py_GetConstant,3.13,,
func,Py_GetConstantBorrowed,3.13,,
func,Py_GetCopyright,3.2,,
func,Py_GetExecPrefix,3.2,,
func,Py_GetPath,3.2,,
func,Py_GetPlatform,3.2,,
func,Py_GetPrefix,3.2,,
func,Py_GetProgramFullPath,3.2,,
func,Py_GetProgramName,3.2,,
func,Py_GetPythonHome,3.2,,
func,Py_GetRecursionLimit,3.2,,
func,Py_GetVersion,3.2,,
data,Py_HasFileSystemDefaultEncoding,3.2,,
func,Py_IncRef,3.2,,
func,Py_Initialize,3.2,,
func,Py_InitializeEx,3.2,,
func,Py_Is,3.10,,
func,Py_IsFalse,3.10,,
func,Py_IsFinalizing,3.13,,
func,Py_IsInitialized,3.2,,
func,Py_IsNone,3.10,,
func,Py_IsTrue,3.10,,
func,Py_LeaveRecursiveCall,3.9,,
func,Py_Main,3.2,,
func,Py_MakePendingCalls,3.2,,
func,Py_NewInterpreter,3.2,,
func,Py_NewRef,3.10,,
func,Py_PACK_FULL_VERSION,3.14,,
func,Py_PACK_VERSION,3.14,,
func,Py_REFCNT,3.14,,
func,Py_ReprEnter,3.2,,
func,Py_ReprLeave,3.2,,
func,Py_SetProgramName,3.2,,
func,Py_SetPythonHome,3.2,,
func,Py_SetRecursionLimit,3.2,,
func,Py_TYPE,3.14,,
type,Py_UCS4,3.2,,
macro,Py_UNBLOCK_THREADS,3.2,,
data,Py_UTF8Mode,3.8,,
func,Py_VaBuildValue,3.2,,
data,Py_Version,3.11,,
func,Py_XNewRef,3.10,,
type,Py_buffer,3.11,,full-abi
type,Py_intptr_t,3.2,,
type,Py_ssize_t,3.2,,
type,Py_uintptr_t,3.2,,
type,allocfunc,3.2,,
type,binaryfunc,3.2,,
type,descrgetfunc,3.2,,
type,descrsetfunc,3.2,,
type,destructor,3.2,,
type,getattrfunc,3.2,,
type,getattrofunc,3.2,,
type,getbufferproc,3.12,,
type,getiterfunc,3.2,,
type,getter,3.2,,
type,hashfunc,3.2,,
type,initproc,3.2,,
type,inquiry,3.2,,
type,iternextfunc,3.2,,
type,lenfunc,3.2,,
type,newfunc,3.2,,
type,objobjargproc,3.2,,
type,objobjproc,3.2,,
type,releasebufferproc,3.12,,
type,reprfunc,3.2,,
type,richcmpfunc,3.2,,
type,setattrfunc,3.2,,
type,setattrofunc,3.2,,
type,setter,3.2,,
type,ssizeargfunc,3.2,,
type,ssizeobjargproc,3.2,,
type,ssizessizeargfunc,3.2,,
type,ssizessizeobjargproc,3.2,,
type,symtable,3.2,,opaque
type,ternaryfunc,3.2,,
type,traverseproc,3.2,,
type,unaryfunc,3.2,,
type,vectorcallfunc,3.12,,
type,visitproc,3.2,,


================================================
File: /Doc/deprecations/c-api-pending-removal-in-3.14.rst
================================================
Pending removal in Python 3.14
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* The ``ma_version_tag`` field in :c:type:`PyDictObject` for extension modules
  (:pep:`699`; :gh:`101193`).

* Creating :c:data:`immutable types <Py_TPFLAGS_IMMUTABLETYPE>` with mutable
  bases (:gh:`95388`).

* Functions to configure Python's initialization, deprecated in Python 3.11:

  * :c:func:`!PySys_SetArgvEx()`:
    Set :c:member:`PyConfig.argv` instead.
  * :c:func:`!PySys_SetArgv()`:
    Set :c:member:`PyConfig.argv` instead.
  * :c:func:`!Py_SetProgramName()`:
    Set :c:member:`PyConfig.program_name` instead.
  * :c:func:`!Py_SetPythonHome()`:
    Set :c:member:`PyConfig.home` instead.

  The :c:func:`Py_InitializeFromConfig` API should be used with
  :c:type:`PyConfig` instead.

* Global configuration variables:

  * :c:var:`Py_DebugFlag`:
    Use :c:member:`PyConfig.parser_debug` instead.
  * :c:var:`Py_VerboseFlag`:
    Use :c:member:`PyConfig.verbose` instead.
  * :c:var:`Py_QuietFlag`:
    Use :c:member:`PyConfig.quiet` instead.
  * :c:var:`Py_InteractiveFlag`:
    Use :c:member:`PyConfig.interactive` instead.
  * :c:var:`Py_InspectFlag`:
    Use :c:member:`PyConfig.inspect` instead.
  * :c:var:`Py_OptimizeFlag`:
    Use :c:member:`PyConfig.optimization_level` instead.
  * :c:var:`Py_NoSiteFlag`:
    Use :c:member:`PyConfig.site_import` instead.
  * :c:var:`Py_BytesWarningFlag`:
    Use :c:member:`PyConfig.bytes_warning` instead.
  * :c:var:`Py_FrozenFlag`:
    Use :c:member:`PyConfig.pathconfig_warnings` instead.
  * :c:var:`Py_IgnoreEnvironmentFlag`:
    Use :c:member:`PyConfig.use_environment` instead.
  * :c:var:`Py_DontWriteBytecodeFlag`:
    Use :c:member:`PyConfig.write_bytecode` instead.
  * :c:var:`Py_NoUserSiteDirectory`:
    Use :c:member:`PyConfig.user_site_directory` instead.
  * :c:var:`Py_UnbufferedStdioFlag`:
    Use :c:member:`PyConfig.buffered_stdio` instead.
  * :c:var:`Py_HashRandomizationFlag`:
    Use :c:member:`PyConfig.use_hash_seed`
    and :c:member:`PyConfig.hash_seed` instead.
  * :c:var:`Py_IsolatedFlag`:
    Use :c:member:`PyConfig.isolated` instead.
  * :c:var:`Py_LegacyWindowsFSEncodingFlag`:
    Use :c:member:`PyPreConfig.legacy_windows_fs_encoding` instead.
  * :c:var:`Py_LegacyWindowsStdioFlag`:
    Use :c:member:`PyConfig.legacy_windows_stdio` instead.
  * :c:var:`!Py_FileSystemDefaultEncoding`:
    Use :c:member:`PyConfig.filesystem_encoding` instead.
  * :c:var:`!Py_HasFileSystemDefaultEncoding`:
    Use :c:member:`PyConfig.filesystem_encoding` instead.
  * :c:var:`!Py_FileSystemDefaultEncodeErrors`:
    Use :c:member:`PyConfig.filesystem_errors` instead.
  * :c:var:`!Py_UTF8Mode`:
    Use :c:member:`PyPreConfig.utf8_mode` instead.
    (see :c:func:`Py_PreInitialize`)

  The :c:func:`Py_InitializeFromConfig` API should be used with
  :c:type:`PyConfig` instead.


================================================
File: /Doc/deprecations/c-api-pending-removal-in-3.15.rst
================================================
Pending removal in Python 3.15
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

* The bundled copy of ``libmpdecimal``.
* The :c:func:`PyImport_ImportModuleNoBlock`:
  Use :c:func:`PyImport_ImportModule` instead.
* :c:func:`PyWeakref_GetObject` and :c:func:`PyWeakref_GET_OBJECT`:
  Use :c:func:`PyWeakref_GetRef` instead.
* :c:type:`Py_UNICODE` type and the :c:macro:`!Py_UNICODE_WIDE` macro:
  Use :c:type:`wchar_t` instead.
* Python initialization functions:

  * :c:func:`PySys_ResetWarnOptions`:
    Clear :data:`sys.warnoptions` and :data:`!warnings.filters` instead.
  * :c:func:`Py_GetExecPrefix`:
    Get :data:`sys.base_exec_prefix` and :data:`sys.exec_prefix` instead.
  * :c:func:`Py_GetPath`:
    Get :data:`sys.path` instead.
  * :c:func:`Py_GetPrefix`:
    Get :data:`sys.base_prefix` and :data:`sys.prefix` instead.
  * :c:func:`Py_GetProgramFullPath`:
    Get :data:`sys.executable` instead.
  * :c:func:`Py_GetProgramName`:
    Get :data:`sys.executable` instead.
  * :c:func:`Py_GetPythonHome`:
    Get :c:member:`PyConfig.home`
    or the :envvar:`PYTHONHOME` environment variable instead.


================================================
File: /Doc/deprecations/c-api-pending-removal-in-future.rst
================================================
Pending removal in future versions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The following APIs are deprecated and will be removed,
although there is currently no date scheduled for their removal.

* :c:macro:`Py_TPFLAGS_HAVE_FINALIZE`:
  Unneeded since Python 3.8.
* :c:func:`PyErr_Fetch`:
  Use :c:func:`PyErr_GetRaisedException` instead.
* :c:func:`PyErr_NormalizeException`:
  Use :c:func:`PyErr_GetRaisedException` instead.
* :c:func:`PyErr_Restore`:
  Use :c:func:`PyErr_SetRaisedException` instead.
* :c:func:`PyModule_GetFilename`:
  Use :c:func:`PyModule_GetFilenameObject` instead.
* :c:func:`PyOS_AfterFork`:
  Use :c:func:`PyOS_AfterFork_Child` instead.
* :c:func:`PySlice_GetIndicesEx`:
  Use :c:func:`PySlice_Unpack` and :c:func:`PySlice_AdjustIndices` instead.
* :c:func:`!PyUnicode_AsDecodedObject`:
  Use :c:func:`PyCodec_Decode` instead.
* :c:func:`!PyUnicode_AsDecodedUnicode`:
  Use :c:func:`PyCodec_Decode` instead.
* :c:func:`!PyUnicode_AsEncodedObject`:
  Use :c:func:`PyCodec_Encode` instead.
* :c:func:`!PyUnicode_AsEncodedUnicode`:
  Use :c:func:`PyCodec_Encode` instead.
* :c:func:`PyUnicode_READY`:
  Unneeded since Python 3.12
* :c:func:`!PyErr_Display`:
  Use :c:func:`PyErr_DisplayException` instead.
* :c:func:`!_PyErr_ChainExceptions`:
  Use :c:func:`!_PyErr_ChainExceptions1` instead.
* :c:member:`!PyBytesObject.ob_shash` member:
  call :c:func:`PyObject_Hash` instead.
* :c:member:`!PyDictObject.ma_version_tag` member.
* Thread Local Storage (TLS) API:

  * :c:func:`PyThread_create_key`:
    Use :c:func:`PyThread_tss_alloc` instead.
  * :c:func:`PyThread_delete_key`:
    Use :c:func:`PyThread_tss_free` instead.
  * :c:func:`PyThread_set_key_value`:
    Use :c:func:`PyThread_tss_set` instead.
  * :c:func:`PyThread_get_key_value`:
    Use :c:func:`PyThread_tss_get` instead.
  * :c:func:`PyThread_delete_key_value`:
    Use :c:func:`PyThread_tss_delete` instead.
  * :c:func:`PyThread_ReInitTLS`:
    Unneeded since Python 3.7.


================================================
File: /Doc/deprecations/index.rst
================================================
Deprecations
============

.. include:: pending-removal-in-3.15.rst

.. include:: pending-removal-in-3.16.rst

.. include:: pending-removal-in-future.rst

C API deprecations
------------------

.. include:: c-api-pending-removal-in-3.15.rst

.. include:: c-api-pending-removal-in-future.rst


================================================
File: /Doc/deprecations/pending-removal-in-3.13.rst
================================================
Pending removal in Python 3.13
------------------------------

Modules (see :pep:`594`):

* :mod:`!aifc`
* :mod:`!audioop`
* :mod:`!cgi`
* :mod:`!cgitb`
* :mod:`!chunk`
* :mod:`!crypt`
* :mod:`!imghdr`
* :mod:`!mailcap`
* :mod:`!msilib`
* :mod:`!nis`
* :mod:`!nntplib`
* :mod:`!ossaudiodev`
* :mod:`!pipes`
* :mod:`!sndhdr`
* :mod:`!spwd`
* :mod:`!sunau`
* :mod:`!telnetlib`
* :mod:`!uu`
* :mod:`!xdrlib`

Other modules:

* :mod:`!lib2to3`, and the :program:`2to3` program (:gh:`84540`)

APIs:

* :class:`!configparser.LegacyInterpolation` (:gh:`90765`)
* ``locale.resetlocale()`` (:gh:`90817`)
* :meth:`!turtle.RawTurtle.settiltangle` (:gh:`50096`)
* :func:`!unittest.findTestCases` (:gh:`50096`)
* :func:`!unittest.getTestCaseNames` (:gh:`50096`)
* :func:`!unittest.makeSuite` (:gh:`50096`)
* :meth:`!unittest.TestProgram.usageExit` (:gh:`67048`)
* :class:`!webbrowser.MacOSX` (:gh:`86421`)
* :class:`classmethod` descriptor chaining (:gh:`89519`)
* :mod:`importlib.resources` deprecated methods:

  * ``contents()``
  * ``is_resource()``
  * ``open_binary()``
  * ``open_text()``
  * ``path()``
  * ``read_binary()``
  * ``read_text()``

  Use :func:`importlib.resources.files` instead.  Refer to `importlib-resources: Migrating from Legacy
  <https://importlib-resources.readthedocs.io/en/latest/using.html#migrating-from-legacy>`_ (:gh:`106531`)


================================================
File: /Doc/deprecations/pending-removal-in-3.14.rst
================================================
Pending removal in Python 3.14
------------------------------

* :mod:`argparse`: The *type*, *choices*, and *metavar* parameters
  of :class:`!argparse.BooleanOptionalAction` are deprecated
  and will be removed in 3.14.
  (Contributed by Nikita Sobolev in :gh:`92248`.)

* :mod:`ast`: The following features have been deprecated in documentation
  since Python 3.8, now cause a :exc:`DeprecationWarning` to be emitted at
  runtime when they are accessed or used, and will be removed in Python 3.14:

  * :class:`!ast.Num`
  * :class:`!ast.Str`
  * :class:`!ast.Bytes`
  * :class:`!ast.NameConstant`
  * :class:`!ast.Ellipsis`

  Use :class:`ast.Constant` instead.
  (Contributed by Serhiy Storchaka in :gh:`90953`.)

* :mod:`asyncio`:

  * The child watcher classes :class:`!asyncio.MultiLoopChildWatcher`,
    :class:`!asyncio.FastChildWatcher`, :class:`!asyncio.AbstractChildWatcher`
    and :class:`!asyncio.SafeChildWatcher` are deprecated and
    will be removed in Python 3.14.
    (Contributed by Kumar Aditya in :gh:`94597`.)

  * :func:`!asyncio.set_child_watcher`, :func:`!asyncio.get_child_watcher`,
    :meth:`!asyncio.AbstractEventLoopPolicy.set_child_watcher` and
    :meth:`!asyncio.AbstractEventLoopPolicy.get_child_watcher` are deprecated
    and will be removed in Python 3.14.
    (Contributed by Kumar Aditya in :gh:`94597`.)

  * The :meth:`~asyncio.get_event_loop` method of the
    default event loop policy now emits a :exc:`DeprecationWarning` if there
    is no current event loop set and it decides to create one.
    (Contributed by Serhiy Storchaka and Guido van Rossum in :gh:`100160`.)

* :mod:`collections.abc`: Deprecated :class:`!collections.abc.ByteString`.
  Prefer :class:`!Sequence` or :class:`~collections.abc.Buffer`.
  For use in typing, prefer a union, like ``bytes | bytearray``,
  or :class:`collections.abc.Buffer`.
  (Contributed by Shantanu Jain in :gh:`91896`.)

* :mod:`email`: Deprecated the *isdst* parameter in :func:`email.utils.localtime`.
  (Contributed by Alan Williams in :gh:`72346`.)

* :mod:`importlib.abc` deprecated classes:

  * :class:`!importlib.abc.ResourceReader`
  * :class:`!importlib.abc.Traversable`
  * :class:`!importlib.abc.TraversableResources`

  Use :mod:`importlib.resources.abc` classes instead:

  * :class:`importlib.resources.abc.Traversable`
  * :class:`importlib.resources.abc.TraversableResources`

  (Contributed by Jason R. Coombs and Hugo van Kemenade in :gh:`93963`.)

* :mod:`itertools` had undocumented, inefficient, historically buggy,
  and inconsistent support for copy, deepcopy, and pickle operations.
  This will be removed in 3.14 for a significant reduction in code
  volume and maintenance burden.
  (Contributed by Raymond Hettinger in :gh:`101588`.)

* :mod:`multiprocessing`: The default start method will change to a safer one on
  Linux, BSDs, and other non-macOS POSIX platforms where ``'fork'`` is currently
  the default (:gh:`84559`). Adding a runtime warning about this was deemed too
  disruptive as the majority of code is not expected to care. Use the
  :func:`~multiprocessing.get_context` or
  :func:`~multiprocessing.set_start_method` APIs to explicitly specify when
  your code *requires* ``'fork'``.  See :ref:`multiprocessing-start-methods`.

* :mod:`pathlib`: :meth:`~pathlib.PurePath.is_relative_to` and
  :meth:`~pathlib.PurePath.relative_to`: passing additional arguments is
  deprecated.

* :mod:`pkgutil`: :func:`!pkgutil.find_loader` and :func:!pkgutil.get_loader`
  now raise :exc:`DeprecationWarning`;
  use :func:`importlib.util.find_spec` instead.
  (Contributed by Nikita Sobolev in :gh:`97850`.)

* :mod:`pty`:

  * ``master_open()``: use :func:`pty.openpty`.
  * ``slave_open()``: use :func:`pty.openpty`.

* :mod:`sqlite3`:

  * :data:`!version` and :data:`!version_info`.

  * :meth:`~sqlite3.Cursor.execute` and :meth:`~sqlite3.Cursor.executemany`
    if :ref:`named placeholders <sqlite3-placeholders>` are used and
    *parameters* is a sequence instead of a :class:`dict`.

* :mod:`typing`: :class:`!typing.ByteString`, deprecated since Python 3.9,
  now causes a :exc:`DeprecationWarning` to be emitted when it is used.

* :mod:`urllib`:
  :class:`!urllib.parse.Quoter` is deprecated: it was not intended to be a
  public API.
  (Contributed by Gregory P. Smith in :gh:`88168`.)


================================================
File: /Doc/deprecations/pending-removal-in-3.15.rst
================================================
Pending removal in Python 3.15
------------------------------

* The import system:

  * Setting :attr:`~module.__cached__` on a module while
    failing to set :attr:`__spec__.cached <importlib.machinery.ModuleSpec.cached>`
    is deprecated. In Python 3.15, :attr:`!__cached__` will cease to be set or
    take into consideration by the import system or standard library. (:gh:`97879`)

  * Setting :attr:`~module.__package__` on a module while
    failing to set :attr:`__spec__.parent <importlib.machinery.ModuleSpec.parent>`
    is deprecated. In Python 3.15, :attr:`!__package__` will cease to be set or
    take into consideration by the import system or standard library. (:gh:`97879`)

* :mod:`ctypes`:

  * The undocumented :func:`!ctypes.SetPointerType` function
    has been deprecated since Python 3.13.

* :mod:`http.server`:

  * The obsolete and rarely used :class:`~http.server.CGIHTTPRequestHandler`
    has been deprecated since Python 3.13.
    No direct replacement exists.
    *Anything* is better than CGI to interface
    a web server with a request handler.

  * The :option:`!--cgi` flag to the :program:`python -m http.server`
    command-line interface has been deprecated since Python 3.13.

* :class:`locale`:

  * The :func:`~locale.getdefaultlocale` function
    has been deprecated since Python 3.11.
    Its removal was originally planned for Python 3.13 (:gh:`90817`),
    but has been postponed to Python 3.15.
    Use :func:`~locale.getlocale`, :func:`~locale.setlocale`,
    and :func:`~locale.getencoding` instead.
    (Contributed by Hugo van Kemenade in :gh:`111187`.)

* :mod:`pathlib`:

  * :meth:`.PurePath.is_reserved`
    has been deprecated since Python 3.13.
    Use :func:`os.path.isreserved` to detect reserved paths on Windows.

* :mod:`platform`:

  * :func:`~platform.java_ver` has been deprecated since Python 3.13.
    This function is only useful for Jython support, has a confusing API,
    and is largely untested.

* :mod:`threading`:

  * :func:`~threading.RLock` will take no arguments in Python 3.15.
    Passing any arguments has been deprecated since Python 3.14,
    as the  Python version does not permit any arguments,
    but the C version allows any number of positional or keyword arguments,
    ignoring every argument.

* :mod:`types`:

  * :class:`types.CodeType`: Accessing :attr:`~codeobject.co_lnotab` was
    deprecated in :pep:`626`
    since 3.10 and was planned to be removed in 3.12,
    but it only got a proper :exc:`DeprecationWarning` in 3.12.
    May be removed in 3.15.
    (Contributed by Nikita Sobolev in :gh:`101866`.)

* :mod:`typing`:

  * The undocumented keyword argument syntax for creating
    :class:`~typing.NamedTuple` classes
    (for example, ``Point = NamedTuple("Point", x=int, y=int)``)
    has been deprecated since Python 3.13.
    Use the class-based syntax or the functional syntax instead.

  * The :func:`typing.no_type_check_decorator` decorator function
    has been deprecated since Python 3.13.
    After eight years in the :mod:`typing` module,
    it has yet to be supported by any major type checker.

* :mod:`wave`:

  * The :meth:`~wave.Wave_read.getmark`, :meth:`!setmark`,
    and :meth:`~wave.Wave_read.getmarkers` methods of
    the :class:`~wave.Wave_read` and :class:`~wave.Wave_write` classes
    have been deprecated since Python 3.13.


================================================
File: /Doc/deprecations/pending-removal-in-3.16.rst
================================================
Pending removal in Python 3.16
------------------------------

* The import system:

  * Setting :attr:`~module.__loader__` on a module while
    failing to set :attr:`__spec__.loader <importlib.machinery.ModuleSpec.loader>`
    is deprecated. In Python 3.16, :attr:`!__loader__` will cease to be set or
    taken into consideration by the import system or the standard library.

* :mod:`array`:

  * The ``'u'`` format code (:c:type:`wchar_t`)
    has been deprecated in documentation since Python 3.3
    and at runtime since Python 3.13.
    Use the ``'w'`` format code (:c:type:`Py_UCS4`)
    for Unicode characters instead.

* :mod:`asyncio`:

  * :func:`!asyncio.iscoroutinefunction` is deprecated
    and will be removed in Python 3.16;
    use :func:`inspect.iscoroutinefunction` instead.
    (Contributed by Jiahao Li and Kumar Aditya in :gh:`122875`.)

  * :mod:`asyncio` policy system is deprecated and will be removed in Python 3.16.
    In particular, the following classes and functions are deprecated:

    * :class:`asyncio.AbstractEventLoopPolicy`
    * :class:`asyncio.DefaultEventLoopPolicy`
    * :class:`asyncio.WindowsSelectorEventLoopPolicy`
    * :class:`asyncio.WindowsProactorEventLoopPolicy`
    * :func:`asyncio.get_event_loop_policy`
    * :func:`asyncio.set_event_loop_policy`
    * :func:`asyncio.set_event_loop`

    Users should use :func:`asyncio.run` or :class:`asyncio.Runner` with
    *loop_factory* to use the desired event loop implementation.

    For example, to use :class:`asyncio.SelectorEventLoop` on Windows::

      import asyncio

      async def main():
          ...

      asyncio.run(main(), loop_factory=asyncio.SelectorEventLoop)

    (Contributed by Kumar Aditya in :gh:`127949`.)

* :mod:`builtins`:

  * Bitwise inversion on boolean types, ``~True`` or ``~False``
    has been deprecated since Python 3.12,
    as it produces surprising and unintuitive results (``-2`` and ``-1``).
    Use ``not x`` instead for the logical negation of a Boolean.
    In the rare case that you need the bitwise inversion of
    the underlying integer, convert to ``int`` explicitly (``~int(x)``).

* :mod:`shutil`:

  * The :class:`!ExecError` exception
    has been deprecated since Python 3.14.
    It has not been used by any function in :mod:`!shutil` since Python 3.4,
    and is now an alias of :exc:`RuntimeError`.

* :mod:`symtable`:

  * The :meth:`Class.get_methods <symtable.Class.get_methods>` method
    has been deprecated since Python 3.14.

* :mod:`sys`:

  * The :func:`~sys._enablelegacywindowsfsencoding` function
    has been deprecated since Python 3.13.
    Use the :envvar:`PYTHONLEGACYWINDOWSFSENCODING` environment variable instead.

* :mod:`tarfile`:

  * The undocumented and unused :attr:`!TarFile.tarfile` attribute
    has been deprecated since Python 3.13.

* :mod:`functools`:

  * Calling the Python implementation of :func:`functools.reduce` with *function*
    or *sequence* as keyword arguments has been deprecated since Python 3.14.


================================================
File: /Doc/deprecations/pending-removal-in-future.rst
================================================
Pending removal in future versions
----------------------------------

The following APIs will be removed in the future,
although there is currently no date scheduled for their removal.

* :mod:`argparse`:

  * Nesting argument groups and nesting mutually exclusive
    groups are deprecated.
  * Passing the undocumented keyword argument *prefix_chars* to
    :meth:`~argparse.ArgumentParser.add_argument_group` is now
    deprecated.
  * The :class:`argparse.FileType` type converter is deprecated.

* :mod:`array`'s ``'u'`` format code (:gh:`57281`)

* :mod:`builtins`:

  * ``bool(NotImplemented)``.
  * Generators: ``throw(type, exc, tb)`` and ``athrow(type, exc, tb)``
    signature is deprecated: use ``throw(exc)`` and ``athrow(exc)`` instead,
    the single argument signature.
  * Currently Python accepts numeric literals immediately followed by keywords,
    for example ``0in x``, ``1or x``, ``0if 1else 2``.  It allows confusing and
    ambiguous expressions like ``[0x1for x in y]`` (which can be interpreted as
    ``[0x1 for x in y]`` or ``[0x1f or x in y]``).  A syntax warning is raised
    if the numeric literal is immediately followed by one of keywords
    :keyword:`and`, :keyword:`else`, :keyword:`for`, :keyword:`if`,
    :keyword:`in`, :keyword:`is` and :keyword:`or`.  In a future release it
    will be changed to a syntax error. (:gh:`87999`)
  * Support for ``__index__()`` and ``__int__()`` method returning non-int type:
    these methods will be required to return an instance of a strict subclass of
    :class:`int`.
  * Support for ``__float__()`` method returning a strict subclass of
    :class:`float`: these methods will be required to return an instance of
    :class:`float`.
  * Support for ``__complex__()`` method returning a strict subclass of
    :class:`complex`: these methods will be required to return an instance of
    :class:`complex`.
  * Delegation of ``int()`` to ``__trunc__()`` method.
  * Passing a complex number as the *real* or *imag* argument in the
    :func:`complex` constructor is now deprecated; it should only be passed
    as a single positional argument.
    (Contributed by Serhiy Storchaka in :gh:`109218`.)

* :mod:`calendar`: ``calendar.January`` and ``calendar.February`` constants are
  deprecated and replaced by :data:`calendar.JANUARY` and
  :data:`calendar.FEBRUARY`.
  (Contributed by Prince Roshan in :gh:`103636`.)

* :attr:`codeobject.co_lnotab`: use the :meth:`codeobject.co_lines` method
  instead.

* :mod:`datetime`:

  * :meth:`~datetime.datetime.utcnow`:
    use ``datetime.datetime.now(tz=datetime.UTC)``.
  * :meth:`~datetime.datetime.utcfromtimestamp`:
    use ``datetime.datetime.fromtimestamp(timestamp, tz=datetime.UTC)``.

* :mod:`gettext`: Plural value must be an integer.

* :mod:`importlib`:

  * ``load_module()`` method: use ``exec_module()`` instead.
  * :func:`~importlib.util.cache_from_source` *debug_override* parameter is
    deprecated: use the *optimization* parameter instead.

* :mod:`importlib.metadata`:

  * ``EntryPoints`` tuple interface.
  * Implicit ``None`` on return values.

* :mod:`logging`: the ``warn()`` method has been deprecated
  since Python 3.3, use :meth:`~logging.warning` instead.

* :mod:`mailbox`: Use of StringIO input and text mode is deprecated, use
  BytesIO and binary mode instead.

* :mod:`os`: Calling :func:`os.register_at_fork` in multi-threaded process.

* :class:`!pydoc.ErrorDuringImport`: A tuple value for *exc_info* parameter is
  deprecated, use an exception instance.

* :mod:`re`: More strict rules are now applied for numerical group references
  and group names in regular expressions.  Only sequence of ASCII digits is now
  accepted as a numerical reference.  The group name in bytes patterns and
  replacement strings can now only contain ASCII letters and digits and
  underscore.
  (Contributed by Serhiy Storchaka in :gh:`91760`.)

* :mod:`!sre_compile`, :mod:`!sre_constants` and :mod:`!sre_parse` modules.

* :mod:`shutil`: :func:`~shutil.rmtree`'s *onerror* parameter is deprecated in
  Python 3.12; use the *onexc* parameter instead.

* :mod:`ssl` options and protocols:

  * :class:`ssl.SSLContext` without protocol argument is deprecated.
  * :class:`ssl.SSLContext`: :meth:`~ssl.SSLContext.set_npn_protocols` and
    :meth:`!selected_npn_protocol` are deprecated: use ALPN
    instead.
  * ``ssl.OP_NO_SSL*`` options
  * ``ssl.OP_NO_TLS*`` options
  * ``ssl.PROTOCOL_SSLv3``
  * ``ssl.PROTOCOL_TLS``
  * ``ssl.PROTOCOL_TLSv1``
  * ``ssl.PROTOCOL_TLSv1_1``
  * ``ssl.PROTOCOL_TLSv1_2``
  * ``ssl.TLSVersion.SSLv3``
  * ``ssl.TLSVersion.TLSv1``
  * ``ssl.TLSVersion.TLSv1_1``

* :func:`sysconfig.is_python_build` *check_home* parameter is deprecated and
  ignored.

* :mod:`threading` methods:

  * :meth:`!threading.Condition.notifyAll`: use :meth:`~threading.Condition.notify_all`.
  * :meth:`!threading.Event.isSet`: use :meth:`~threading.Event.is_set`.
  * :meth:`!threading.Thread.isDaemon`, :meth:`threading.Thread.setDaemon`:
    use :attr:`threading.Thread.daemon` attribute.
  * :meth:`!threading.Thread.getName`, :meth:`threading.Thread.setName`:
    use :attr:`threading.Thread.name` attribute.
  * :meth:`!threading.currentThread`: use :meth:`threading.current_thread`.
  * :meth:`!threading.activeCount`: use :meth:`threading.active_count`.

* :class:`typing.Text` (:gh:`92332`).

* :class:`unittest.IsolatedAsyncioTestCase`: it is deprecated to return a value
  that is not ``None`` from a test case.

* :mod:`urllib.parse` deprecated functions: :func:`~urllib.parse.urlparse` instead

  * ``splitattr()``
  * ``splithost()``
  * ``splitnport()``
  * ``splitpasswd()``
  * ``splitport()``
  * ``splitquery()``
  * ``splittag()``
  * ``splittype()``
  * ``splituser()``
  * ``splitvalue()``
  * ``to_bytes()``

* :mod:`wsgiref`: ``SimpleHandler.stdout.write()`` should not do partial
  writes.

* :mod:`xml.etree.ElementTree`: Testing the truth value of an
  :class:`~xml.etree.ElementTree.Element` is deprecated. In a future release it
  will always return ``True``. Prefer explicit ``len(elem)`` or
  ``elem is not None`` tests instead.

* :meth:`zipimport.zipimporter.load_module` is deprecated:
  use :meth:`~zipimport.zipimporter.exec_module` instead.


================================================
File: /Doc/distributing/index.rst
================================================
:orphan:

.. This page is retained solely for existing links to /distributing/index.html.
   Direct readers to the PPUG instead.

.. _distributing-index:

###############################
  Distributing Python Modules
###############################

.. note::

   Information and guidance on distributing Python modules and packages
   has been moved to the `Python Packaging User Guide`_,
   and the tutorial on `packaging Python projects`_.

   .. _Python Packaging User Guide: https://packaging.python.org/
   .. _packaging Python projects: https://packaging.python.org/en/latest/tutorials/packaging-projects/


================================================
File: /Doc/extending/building.rst
================================================
.. highlight:: c

.. _building:

*****************************
Building C and C++ Extensions
*****************************

A C extension for CPython is a shared library (e.g. a ``.so`` file on Linux,
``.pyd`` on Windows), which exports an *initialization function*.

To be importable, the shared library must be available on :envvar:`PYTHONPATH`,
and must be named after the module name, with an appropriate extension.
When using setuptools, the correct filename is generated automatically.

The initialization function has the signature:

.. c:function:: PyObject* PyInit_modulename(void)

It returns either a fully initialized module, or a :c:type:`PyModuleDef`
instance. See :ref:`initializing-modules` for details.

.. highlight:: python

For modules with ASCII-only names, the function must be named
``PyInit_<modulename>``, with ``<modulename>`` replaced by the name of the
module. When using :ref:`multi-phase-initialization`, non-ASCII module names
are allowed. In this case, the initialization function name is
``PyInitU_<modulename>``, with ``<modulename>`` encoded using Python's
*punycode* encoding with hyphens replaced by underscores. In Python::

    def initfunc_name(name):
        try:
            suffix = b'_' + name.encode('ascii')
        except UnicodeEncodeError:
            suffix = b'U_' + name.encode('punycode').replace(b'-', b'_')
        return b'PyInit' + suffix

It is possible to export multiple modules from a single shared library by
defining multiple initialization functions. However, importing them requires
using symbolic links or a custom importer, because by default only the
function corresponding to the filename is found.
See the *"Multiple modules in one library"* section in :pep:`489` for details.


.. highlight:: c

.. _install-index:
.. _setuptools-index:

Building C and C++ Extensions with setuptools
=============================================

Python 3.12 and newer no longer come with distutils. Please refer to the
``setuptools`` documentation at
https://setuptools.readthedocs.io/en/latest/setuptools.html
to learn more about how build and distribute C/C++ extensions with setuptools.


================================================
File: /Doc/extending/embedding.rst
================================================
.. highlight:: c


.. _embedding:

***************************************
Embedding Python in Another Application
***************************************

The previous chapters discussed how to extend Python, that is, how to extend the
functionality of Python by attaching a library of C functions to it.  It is also
possible to do it the other way around: enrich your C/C++ application by
embedding Python in it.  Embedding provides your application with the ability to
implement some of the functionality of your application in Python rather than C
or C++. This can be used for many purposes; one example would be to allow users
to tailor the application to their needs by writing some scripts in Python.  You
can also use it yourself if some of the functionality can be written in Python
more easily.

Embedding Python is similar to extending it, but not quite.  The difference is
that when you extend Python, the main program of the application is still the
Python interpreter, while if you embed Python, the main program may have nothing
to do with Python --- instead, some parts of the application occasionally call
the Python interpreter to run some Python code.

So if you are embedding Python, you are providing your own main program.  One of
the things this main program has to do is initialize the Python interpreter.  At
the very least, you have to call the function :c:func:`Py_Initialize`.  There are
optional calls to pass command line arguments to Python.  Then later you can
call the interpreter from any part of the application.

There are several different ways to call the interpreter: you can pass a string
containing Python statements to :c:func:`PyRun_SimpleString`, or you can pass a
stdio file pointer and a file name (for identification in error messages only)
to :c:func:`PyRun_SimpleFile`.  You can also call the lower-level operations
described in the previous chapters to construct and use Python objects.


.. seealso::

   :ref:`c-api-index`
      The details of Python's C interface are given in this manual. A great deal of
      necessary information can be found here.


.. _high-level-embedding:

Very High Level Embedding
=========================

The simplest form of embedding Python is the use of the very high level
interface. This interface is intended to execute a Python script without needing
to interact with the application directly. This can for example be used to
perform some operation on a file. ::

   #define PY_SSIZE_T_CLEAN
   #include <Python.h>

   int
   main(int argc, char *argv[])
   {
       PyStatus status;
       PyConfig config;
       PyConfig_InitPythonConfig(&config);

       /* optional but recommended */
       status = PyConfig_SetBytesString(&config, &config.program_name, argv[0]);
       if (PyStatus_Exception(status)) {
           goto exception;
       }

       status = Py_InitializeFromConfig(&config);
       if (PyStatus_Exception(status)) {
           goto exception;
       }
       PyConfig_Clear(&config);

       PyRun_SimpleString("from time import time,ctime\n"
                          "print('Today is', ctime(time()))\n");
       if (Py_FinalizeEx() < 0) {
           exit(120);
       }
       return 0;

     exception:
        PyConfig_Clear(&config);
        Py_ExitStatusException(status);
   }

.. note::

   ``#define PY_SSIZE_T_CLEAN`` was used to indicate that ``Py_ssize_t`` should be
   used in some APIs instead of ``int``.
   It is not necessary since Python 3.13, but we keep it here for backward compatibility.
   See :ref:`arg-parsing-string-and-buffers` for a description of this macro.

Setting :c:member:`PyConfig.program_name` should be called before
:c:func:`Py_InitializeFromConfig` to inform the interpreter about paths to Python run-time
libraries.  Next, the Python interpreter is initialized with
:c:func:`Py_Initialize`, followed by the execution of a hard-coded Python script
that prints the date and time.  Afterwards, the :c:func:`Py_FinalizeEx` call shuts
the interpreter down, followed by the end of the program.  In a real program,
you may want to get the Python script from another source, perhaps a text-editor
routine, a file, or a database.  Getting the Python code from a file can better
be done by using the :c:func:`PyRun_SimpleFile` function, which saves you the
trouble of allocating memory space and loading the file contents.


.. _lower-level-embedding:

Beyond Very High Level Embedding: An overview
=============================================

The high level interface gives you the ability to execute arbitrary pieces of
Python code from your application, but exchanging data values is quite
cumbersome to say the least. If you want that, you should use lower level calls.
At the cost of having to write more C code, you can achieve almost anything.

It should be noted that extending Python and embedding Python is quite the same
activity, despite the different intent. Most topics discussed in the previous
chapters are still valid. To show this, consider what the extension code from
Python to C really does:

#. Convert data values from Python to C,

#. Perform a function call to a C routine using the converted values, and

#. Convert the data values from the call from C to Python.

When embedding Python, the interface code does:

#. Convert data values from C to Python,

#. Perform a function call to a Python interface routine using the converted
   values, and

#. Convert the data values from the call from Python to C.

As you can see, the data conversion steps are simply swapped to accommodate the
different direction of the cross-language transfer. The only difference is the
routine that you call between both data conversions. When extending, you call a
C routine, when embedding, you call a Python routine.

This chapter will not discuss how to convert data from Python to C and vice
versa.  Also, proper use of references and dealing with errors is assumed to be
understood.  Since these aspects do not differ from extending the interpreter,
you can refer to earlier chapters for the required information.


.. _pure-embedding:

Pure Embedding
==============

The first program aims to execute a function in a Python script. Like in the
section about the very high level interface, the Python interpreter does not
directly interact with the application (but that will change in the next
section).

The code to run a function defined in a Python script is:

.. literalinclude:: ../includes/run-func.c


This code loads a Python script using ``argv[1]``, and calls the function named
in ``argv[2]``.  Its integer arguments are the other values of the ``argv``
array.  If you :ref:`compile and link <compiling>` this program (let's call
the finished executable :program:`call`), and use it to execute a Python
script, such as:

.. code-block:: python

   def multiply(a,b):
       print("Will compute", a, "times", b)
       c = 0
       for i in range(0, a):
           c = c + b
       return c

then the result should be:

.. code-block:: shell-session

   $ call multiply multiply 3 2
   Will compute 3 times 2
   Result of call: 6

Although the program is quite large for its functionality, most of the code is
for data conversion between Python and C, and for error reporting.  The
interesting part with respect to embedding Python starts with ::

   Py_Initialize();
   pName = PyUnicode_DecodeFSDefault(argv[1]);
   /* Error checking of pName left out */
   pModule = PyImport_Import(pName);

After initializing the interpreter, the script is loaded using
:c:func:`PyImport_Import`.  This routine needs a Python string as its argument,
which is constructed using the :c:func:`PyUnicode_FromString` data conversion
routine. ::

   pFunc = PyObject_GetAttrString(pModule, argv[2]);
   /* pFunc is a new reference */

   if (pFunc && PyCallable_Check(pFunc)) {
       ...
   }
   Py_XDECREF(pFunc);

Once the script is loaded, the name we're looking for is retrieved using
:c:func:`PyObject_GetAttrString`.  If the name exists, and the object returned is
callable, you can safely assume that it is a function.  The program then
proceeds by constructing a tuple of arguments as normal.  The call to the Python
function is then made with::

   pValue = PyObject_CallObject(pFunc, pArgs);

Upon return of the function, ``pValue`` is either ``NULL`` or it contains a
reference to the return value of the function.  Be sure to release the reference
after examining the value.


.. _extending-with-embedding:

Extending Embedded Python
=========================

Until now, the embedded Python interpreter had no access to functionality from
the application itself.  The Python API allows this by extending the embedded
interpreter.  That is, the embedded interpreter gets extended with routines
provided by the application. While it sounds complex, it is not so bad.  Simply
forget for a while that the application starts the Python interpreter.  Instead,
consider the application to be a set of subroutines, and write some glue code
that gives Python access to those routines, just like you would write a normal
Python extension.  For example::

   static int numargs=0;

   /* Return the number of arguments of the application command line */
   static PyObject*
   emb_numargs(PyObject *self, PyObject *args)
   {
       if(!PyArg_ParseTuple(args, ":numargs"))
           return NULL;
       return PyLong_FromLong(numargs);
   }

   static PyMethodDef EmbMethods[] = {
       {"numargs", emb_numargs, METH_VARARGS,
        "Return the number of arguments received by the process."},
       {NULL, NULL, 0, NULL}
   };

   static PyModuleDef EmbModule = {
       PyModuleDef_HEAD_INIT, "emb", NULL, -1, EmbMethods,
       NULL, NULL, NULL, NULL
   };

   static PyObject*
   PyInit_emb(void)
   {
       return PyModule_Create(&EmbModule);
   }

Insert the above code just above the :c:func:`main` function. Also, insert the
following two statements before the call to :c:func:`Py_Initialize`::

   numargs = argc;
   PyImport_AppendInittab("emb", &PyInit_emb);

These two lines initialize the ``numargs`` variable, and make the
:func:`!emb.numargs` function accessible to the embedded Python interpreter.
With these extensions, the Python script can do things like

.. code-block:: python

   import emb
   print("Number of arguments", emb.numargs())

In a real application, the methods will expose an API of the application to
Python.

.. TODO: threads, code examples do not really behave well if errors happen
   (what to watch out for)


.. _embeddingincplusplus:

Embedding Python in C++
=======================

It is also possible to embed Python in a C++ program; precisely how this is done
will depend on the details of the C++ system used; in general you will need to
write the main program in C++, and use the C++ compiler to compile and link your
program.  There is no need to recompile Python itself using C++.


.. _compiling:

Compiling and Linking under Unix-like systems
=============================================

It is not necessarily trivial to find the right flags to pass to your
compiler (and linker) in order to embed the Python interpreter into your
application, particularly because Python needs to load library modules
implemented as C dynamic extensions (:file:`.so` files) linked against
it.

To find out the required compiler and linker flags, you can execute the
:file:`python{X.Y}-config` script which is generated as part of the
installation process (a :file:`python3-config` script may also be
available).  This script has several options, of which the following will
be directly useful to you:

* ``pythonX.Y-config --cflags`` will give you the recommended flags when
  compiling:

  .. code-block:: shell-session

     $ /opt/bin/python3.11-config --cflags
     -I/opt/include/python3.11 -I/opt/include/python3.11 -Wsign-compare  -DNDEBUG -g -fwrapv -O3 -Wall

* ``pythonX.Y-config --ldflags --embed`` will give you the recommended flags
  when linking:

  .. code-block:: shell-session

     $ /opt/bin/python3.11-config --ldflags --embed
     -L/opt/lib/python3.11/config-3.11-x86_64-linux-gnu -L/opt/lib -lpython3.11 -lpthread -ldl  -lutil -lm

.. note::
   To avoid confusion between several Python installations (and especially
   between the system Python and your own compiled Python), it is recommended
   that you use the absolute path to :file:`python{X.Y}-config`, as in the above
   example.

If this procedure doesn't work for you (it is not guaranteed to work for
all Unix-like platforms; however, we welcome :ref:`bug reports <reporting-bugs>`)
you will have to read your system's documentation about dynamic linking and/or
examine Python's :file:`Makefile` (use :func:`sysconfig.get_makefile_filename`
to find its location) and compilation
options.  In this case, the :mod:`sysconfig` module is a useful tool to
programmatically extract the configuration values that you will want to
combine together.  For example:

.. code-block:: pycon

   >>> import sysconfig
   >>> sysconfig.get_config_var('LIBS')
   '-lpthread -ldl  -lutil'
   >>> sysconfig.get_config_var('LINKFORSHARED')
   '-Xlinker -export-dynamic'


.. XXX similar documentation for Windows missing


================================================
File: /Doc/extending/index.rst
================================================
.. _extending-index:

##################################################
  Extending and Embedding the Python Interpreter
##################################################

This document describes how to write modules in C or C++ to extend the Python
interpreter with new modules.  Those modules can not only define new functions
but also new object types and their methods.  The document also describes how
to embed the Python interpreter in another application, for use as an extension
language.  Finally, it shows how to compile and link extension modules so that
they can be loaded dynamically (at run time) into the interpreter, if the
underlying operating system supports this feature.

This document assumes basic knowledge about Python.  For an informal
introduction to the language, see :ref:`tutorial-index`.  :ref:`reference-index`
gives a more formal definition of the language.  :ref:`library-index` documents
the existing object types, functions and modules (both built-in and written in
Python) that give the language its wide application range.

For a detailed description of the whole Python/C API, see the separate
:ref:`c-api-index`.


Recommended third party tools
=============================

This guide only covers the basic tools for creating extensions provided
as part of this version of CPython. Third party tools like
`Cython <https://cython.org/>`_, `cffi <https://cffi.readthedocs.io>`_,
`SWIG <https://www.swig.org>`_ and `Numba <https://numba.pydata.org/>`_
offer both simpler and more sophisticated approaches to creating C and C++
extensions for Python.

.. seealso::

   `Python Packaging User Guide: Binary Extensions <https://packaging.python.org/guides/packaging-binary-extensions/>`_
      The Python Packaging User Guide not only covers several available
      tools that simplify the creation of binary extensions, but also
      discusses the various reasons why creating an extension module may be
      desirable in the first place.


Creating extensions without third party tools
=============================================

This section of the guide covers creating C and C++ extensions without
assistance from third party tools. It is intended primarily for creators
of those tools, rather than being a recommended way to create your own
C extensions.

.. toctree::
   :maxdepth: 2
   :numbered:

   extending.rst
   newtypes_tutorial.rst
   newtypes.rst
   building.rst
   windows.rst

Embedding the CPython runtime in a larger application
=====================================================

Sometimes, rather than creating an extension that runs inside the Python
interpreter as the main application, it is desirable to instead embed
the CPython runtime inside a larger application. This section covers
some of the details involved in doing that successfully.

.. toctree::
   :maxdepth: 2
   :numbered:

   embedding.rst


================================================
File: /Doc/extending/newtypes.rst
================================================
.. highlight:: c

.. _new-types-topics:

*****************************************
Defining Extension Types: Assorted Topics
*****************************************

.. _dnt-type-methods:

This section aims to give a quick fly-by on the various type methods you can
implement and what they do.

Here is the definition of :c:type:`PyTypeObject`, with some fields only used in
:ref:`debug builds <debug-build>` omitted:

.. literalinclude:: ../includes/typestruct.h


Now that's a *lot* of methods.  Don't worry too much though -- if you have
a type you want to define, the chances are very good that you will only
implement a handful of these.

As you probably expect by now, we're going to go over this and give more
information about the various handlers.  We won't go in the order they are
defined in the structure, because there is a lot of historical baggage that
impacts the ordering of the fields.  It's often easiest to find an example
that includes the fields you need and then change the values to suit your new
type. ::

   const char *tp_name; /* For printing */

The name of the type -- as mentioned in the previous chapter, this will appear in
various places, almost entirely for diagnostic purposes. Try to choose something
that will be helpful in such a situation! ::

   Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */

These fields tell the runtime how much memory to allocate when new objects of
this type are created.  Python has some built-in support for variable length
structures (think: strings, tuples) which is where the :c:member:`~PyTypeObject.tp_itemsize` field
comes in.  This will be dealt with later. ::

   const char *tp_doc;

Here you can put a string (or its address) that you want returned when the
Python script references ``obj.__doc__`` to retrieve the doc string.

Now we come to the basic type methods -- the ones most extension types will
implement.


Finalization and De-allocation
------------------------------

.. index::
   single: object; deallocation
   single: deallocation, object
   single: object; finalization
   single: finalization, of objects

::

   destructor tp_dealloc;

This function is called when the reference count of the instance of your type is
reduced to zero and the Python interpreter wants to reclaim it.  If your type
has memory to free or other clean-up to perform, you can put it here.  The
object itself needs to be freed here as well.  Here is an example of this
function::

   static void
   newdatatype_dealloc(newdatatypeobject *obj)
   {
       free(obj->obj_UnderlyingDatatypePtr);
       Py_TYPE(obj)->tp_free((PyObject *)obj);
   }

If your type supports garbage collection, the destructor should call
:c:func:`PyObject_GC_UnTrack` before clearing any member fields::

   static void
   newdatatype_dealloc(newdatatypeobject *obj)
   {
       PyObject_GC_UnTrack(obj);
       Py_CLEAR(obj->other_obj);
       ...
       Py_TYPE(obj)->tp_free((PyObject *)obj);
   }

.. index::
   single: PyErr_Fetch (C function)
   single: PyErr_Restore (C function)

One important requirement of the deallocator function is that it leaves any
pending exceptions alone.  This is important since deallocators are frequently
called as the interpreter unwinds the Python stack; when the stack is unwound
due to an exception (rather than normal returns), nothing is done to protect the
deallocators from seeing that an exception has already been set.  Any actions
which a deallocator performs which may cause additional Python code to be
executed may detect that an exception has been set.  This can lead to misleading
errors from the interpreter.  The proper way to protect against this is to save
a pending exception before performing the unsafe action, and restoring it when
done.  This can be done using the :c:func:`PyErr_Fetch` and
:c:func:`PyErr_Restore` functions::

   static void
   my_dealloc(PyObject *obj)
   {
       MyObject *self = (MyObject *) obj;
       PyObject *cbresult;

       if (self->my_callback != NULL) {
           PyObject *err_type, *err_value, *err_traceback;

           /* This saves the current exception state */
           PyErr_Fetch(&err_type, &err_value, &err_traceback);

           cbresult = PyObject_CallNoArgs(self->my_callback);
           if (cbresult == NULL)
               PyErr_WriteUnraisable(self->my_callback);
           else
               Py_DECREF(cbresult);

           /* This restores the saved exception state */
           PyErr_Restore(err_type, err_value, err_traceback);

           Py_DECREF(self->my_callback);
       }
       Py_TYPE(obj)->tp_free((PyObject*)self);
   }

.. note::
   There are limitations to what you can safely do in a deallocator function.
   First, if your type supports garbage collection (using :c:member:`~PyTypeObject.tp_traverse`
   and/or :c:member:`~PyTypeObject.tp_clear`), some of the object's members can have been
   cleared or finalized by the time :c:member:`~PyTypeObject.tp_dealloc` is called.  Second, in
   :c:member:`~PyTypeObject.tp_dealloc`, your object is in an unstable state: its reference
   count is equal to zero.  Any call to a non-trivial object or API (as in the
   example above) might end up calling :c:member:`~PyTypeObject.tp_dealloc` again, causing a
   double free and a crash.

   Starting with Python 3.4, it is recommended not to put any complex
   finalization code in :c:member:`~PyTypeObject.tp_dealloc`, and instead use the new
   :c:member:`~PyTypeObject.tp_finalize` type method.

   .. seealso::
      :pep:`442` explains the new finalization scheme.

.. index::
   single: string; object representation
   pair: built-in function; repr

Object Presentation
-------------------

In Python, there are two ways to generate a textual representation of an object:
the :func:`repr` function, and the :func:`str` function.  (The :func:`print`
function just calls :func:`str`.)  These handlers are both optional.

::

   reprfunc tp_repr;
   reprfunc tp_str;

The :c:member:`~PyTypeObject.tp_repr` handler should return a string object containing a
representation of the instance for which it is called.  Here is a simple
example::

   static PyObject *
   newdatatype_repr(newdatatypeobject *obj)
   {
       return PyUnicode_FromFormat("Repr-ified_newdatatype{{size:%d}}",
                                   obj->obj_UnderlyingDatatypePtr->size);
   }

If no :c:member:`~PyTypeObject.tp_repr` handler is specified, the interpreter will supply a
representation that uses the type's :c:member:`~PyTypeObject.tp_name` and a uniquely identifying
value for the object.

The :c:member:`~PyTypeObject.tp_str` handler is to :func:`str` what the :c:member:`~PyTypeObject.tp_repr` handler
described above is to :func:`repr`; that is, it is called when Python code calls
:func:`str` on an instance of your object.  Its implementation is very similar
to the :c:member:`~PyTypeObject.tp_repr` function, but the resulting string is intended for human
consumption.  If :c:member:`~PyTypeObject.tp_str` is not specified, the :c:member:`~PyTypeObject.tp_repr` handler is
used instead.

Here is a simple example::

   static PyObject *
   newdatatype_str(newdatatypeobject *obj)
   {
       return PyUnicode_FromFormat("Stringified_newdatatype{{size:%d}}",
                                   obj->obj_UnderlyingDatatypePtr->size);
   }



Attribute Management
--------------------

For every object which can support attributes, the corresponding type must
provide the functions that control how the attributes are resolved.  There needs
to be a function which can retrieve attributes (if any are defined), and another
to set attributes (if setting attributes is allowed).  Removing an attribute is
a special case, for which the new value passed to the handler is ``NULL``.

Python supports two pairs of attribute handlers; a type that supports attributes
only needs to implement the functions for one pair.  The difference is that one
pair takes the name of the attribute as a :c:expr:`char\*`, while the other
accepts a :c:expr:`PyObject*`.  Each type can use whichever pair makes more
sense for the implementation's convenience. ::

   getattrfunc  tp_getattr;        /* char * version */
   setattrfunc  tp_setattr;
   /* ... */
   getattrofunc tp_getattro;       /* PyObject * version */
   setattrofunc tp_setattro;

If accessing attributes of an object is always a simple operation (this will be
explained shortly), there are generic implementations which can be used to
provide the :c:expr:`PyObject*` version of the attribute management functions.
The actual need for type-specific attribute handlers almost completely
disappeared starting with Python 2.2, though there are many examples which have
not been updated to use some of the new generic mechanism that is available.


.. _generic-attribute-management:

Generic Attribute Management
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Most extension types only use *simple* attributes.  So, what makes the
attributes simple?  There are only a couple of conditions that must be met:

#. The name of the attributes must be known when :c:func:`PyType_Ready` is
   called.

#. No special processing is needed to record that an attribute was looked up or
   set, nor do actions need to be taken based on the value.

Note that this list does not place any restrictions on the values of the
attributes, when the values are computed, or how relevant data is stored.

When :c:func:`PyType_Ready` is called, it uses three tables referenced by the
type object to create :term:`descriptor`\s which are placed in the dictionary of the
type object.  Each descriptor controls access to one attribute of the instance
object.  Each of the tables is optional; if all three are ``NULL``, instances of
the type will only have attributes that are inherited from their base type, and
should leave the :c:member:`~PyTypeObject.tp_getattro` and :c:member:`~PyTypeObject.tp_setattro` fields ``NULL`` as
well, allowing the base type to handle attributes.

The tables are declared as three fields of the type object::

   struct PyMethodDef *tp_methods;
   struct PyMemberDef *tp_members;
   struct PyGetSetDef *tp_getset;

If :c:member:`~PyTypeObject.tp_methods` is not ``NULL``, it must refer to an array of
:c:type:`PyMethodDef` structures.  Each entry in the table is an instance of this
structure::

   typedef struct PyMethodDef {
       const char  *ml_name;       /* method name */
       PyCFunction  ml_meth;       /* implementation function */
       int          ml_flags;      /* flags */
       const char  *ml_doc;        /* docstring */
   } PyMethodDef;

One entry should be defined for each method provided by the type; no entries are
needed for methods inherited from a base type.  One additional entry is needed
at the end; it is a sentinel that marks the end of the array.  The
:c:member:`~PyMethodDef.ml_name` field of the sentinel must be ``NULL``.

The second table is used to define attributes which map directly to data stored
in the instance.  A variety of primitive C types are supported, and access may
be read-only or read-write.  The structures in the table are defined as::

   typedef struct PyMemberDef {
       const char *name;
       int         type;
       int         offset;
       int         flags;
       const char *doc;
   } PyMemberDef;

For each entry in the table, a :term:`descriptor` will be constructed and added to the
type which will be able to extract a value from the instance structure.  The
:c:member:`~PyMemberDef.type` field should contain a type code like :c:macro:`Py_T_INT` or
:c:macro:`Py_T_DOUBLE`; the value will be used to determine how to
convert Python values to and from C values.  The :c:member:`~PyMemberDef.flags` field is used to
store flags which control how the attribute can be accessed: you can set it to
:c:macro:`Py_READONLY` to prevent Python code from setting it.

An interesting advantage of using the :c:member:`~PyTypeObject.tp_members` table to build
descriptors that are used at runtime is that any attribute defined this way can
have an associated doc string simply by providing the text in the table.  An
application can use the introspection API to retrieve the descriptor from the
class object, and get the doc string using its :attr:`~type.__doc__` attribute.

As with the :c:member:`~PyTypeObject.tp_methods` table, a sentinel entry with a :c:member:`~PyMethodDef.ml_name` value
of ``NULL`` is required.

.. XXX Descriptors need to be explained in more detail somewhere, but not here.

   Descriptor objects have two handler functions which correspond to the
   \member{tp_getattro} and \member{tp_setattro} handlers.  The
   \method{__get__()} handler is a function which is passed the descriptor,
   instance, and type objects, and returns the value of the attribute, or it
   returns \NULL{} and sets an exception.  The \method{__set__()} handler is
   passed the descriptor, instance, type, and new value;


Type-specific Attribute Management
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

For simplicity, only the :c:expr:`char\*` version will be demonstrated here; the
type of the name parameter is the only difference between the :c:expr:`char\*`
and :c:expr:`PyObject*` flavors of the interface. This example effectively does
the same thing as the generic example above, but does not use the generic
support added in Python 2.2.  It explains how the handler functions are
called, so that if you do need to extend their functionality, you'll understand
what needs to be done.

The :c:member:`~PyTypeObject.tp_getattr` handler is called when the object requires an attribute
look-up.  It is called in the same situations where the :meth:`~object.__getattr__`
method of a class would be called.

Here is an example::

   static PyObject *
   newdatatype_getattr(newdatatypeobject *obj, char *name)
   {
       if (strcmp(name, "data") == 0)
       {
           return PyLong_FromLong(obj->data);
       }

       PyErr_Format(PyExc_AttributeError,
                    "'%.100s' object has no attribute '%.400s'",
                    Py_TYPE(obj)->tp_name, name);
       return NULL;
   }

The :c:member:`~PyTypeObject.tp_setattr` handler is called when the :meth:`~object.__setattr__` or
:meth:`~object.__delattr__` method of a class instance would be called.  When an
attribute should be deleted, the third parameter will be ``NULL``.  Here is an
example that simply raises an exception; if this were really all you wanted, the
:c:member:`~PyTypeObject.tp_setattr` handler should be set to ``NULL``. ::

   static int
   newdatatype_setattr(newdatatypeobject *obj, char *name, PyObject *v)
   {
       PyErr_Format(PyExc_RuntimeError, "Read-only attribute: %s", name);
       return -1;
   }

Object Comparison
-----------------

::

   richcmpfunc tp_richcompare;

The :c:member:`~PyTypeObject.tp_richcompare` handler is called when comparisons are needed.  It is
analogous to the :ref:`rich comparison methods <richcmpfuncs>`, like
:meth:`!__lt__`, and also called by :c:func:`PyObject_RichCompare` and
:c:func:`PyObject_RichCompareBool`.

This function is called with two Python objects and the operator as arguments,
where the operator is one of ``Py_EQ``, ``Py_NE``, ``Py_LE``, ``Py_GE``,
``Py_LT`` or ``Py_GT``.  It should compare the two objects with respect to the
specified operator and return ``Py_True`` or ``Py_False`` if the comparison is
successful, ``Py_NotImplemented`` to indicate that comparison is not
implemented and the other object's comparison method should be tried, or ``NULL``
if an exception was set.

Here is a sample implementation, for a datatype that is considered equal if the
size of an internal pointer is equal::

   static PyObject *
   newdatatype_richcmp(newdatatypeobject *obj1, newdatatypeobject *obj2, int op)
   {
       PyObject *result;
       int c, size1, size2;

       /* code to make sure that both arguments are of type
          newdatatype omitted */

       size1 = obj1->obj_UnderlyingDatatypePtr->size;
       size2 = obj2->obj_UnderlyingDatatypePtr->size;

       switch (op) {
       case Py_LT: c = size1 <  size2; break;
       case Py_LE: c = size1 <= size2; break;
       case Py_EQ: c = size1 == size2; break;
       case Py_NE: c = size1 != size2; break;
       case Py_GT: c = size1 >  size2; break;
       case Py_GE: c = size1 >= size2; break;
       }
       result = c ? Py_True : Py_False;
       Py_INCREF(result);
       return result;
    }


Abstract Protocol Support
-------------------------

Python supports a variety of *abstract* 'protocols;' the specific interfaces
provided to use these interfaces are documented in :ref:`abstract`.


A number of these abstract interfaces were defined early in the development of
the Python implementation.  In particular, the number, mapping, and sequence
protocols have been part of Python since the beginning.  Other protocols have
been added over time.  For protocols which depend on several handler routines
from the type implementation, the older protocols have been defined as optional
blocks of handlers referenced by the type object.  For newer protocols there are
additional slots in the main type object, with a flag bit being set to indicate
that the slots are present and should be checked by the interpreter.  (The flag
bit does not indicate that the slot values are non-``NULL``. The flag may be set
to indicate the presence of a slot, but a slot may still be unfilled.) ::

   PyNumberMethods   *tp_as_number;
   PySequenceMethods *tp_as_sequence;
   PyMappingMethods  *tp_as_mapping;

If you wish your object to be able to act like a number, a sequence, or a
mapping object, then you place the address of a structure that implements the C
type :c:type:`PyNumberMethods`, :c:type:`PySequenceMethods`, or
:c:type:`PyMappingMethods`, respectively. It is up to you to fill in this
structure with appropriate values. You can find examples of the use of each of
these in the :file:`Objects` directory of the Python source distribution. ::

   hashfunc tp_hash;

This function, if you choose to provide it, should return a hash number for an
instance of your data type. Here is a simple example::

   static Py_hash_t
   newdatatype_hash(newdatatypeobject *obj)
   {
       Py_hash_t result;
       result = obj->some_size + 32767 * obj->some_number;
       if (result == -1)
          result = -2;
       return result;
   }

:c:type:`Py_hash_t` is a signed integer type with a platform-varying width.
Returning ``-1`` from :c:member:`~PyTypeObject.tp_hash` indicates an error,
which is why you should be careful to avoid returning it when hash computation
is successful, as seen above.

::

   ternaryfunc tp_call;

This function is called when an instance of your data type is "called", for
example, if ``obj1`` is an instance of your data type and the Python script
contains ``obj1('hello')``, the :c:member:`~PyTypeObject.tp_call` handler is invoked.

This function takes three arguments:

#. *self* is the instance of the data type which is the subject of the call.
   If the call is ``obj1('hello')``, then *self* is ``obj1``.

#. *args* is a tuple containing the arguments to the call.  You can use
   :c:func:`PyArg_ParseTuple` to extract the arguments.

#. *kwds* is a dictionary of keyword arguments that were passed. If this is
   non-``NULL`` and you support keyword arguments, use
   :c:func:`PyArg_ParseTupleAndKeywords` to extract the arguments.  If you
   do not want to support keyword arguments and this is non-``NULL``, raise a
   :exc:`TypeError` with a message saying that keyword arguments are not supported.

Here is a toy ``tp_call`` implementation::

   static PyObject *
   newdatatype_call(newdatatypeobject *obj, PyObject *args, PyObject *kwds)
   {
       PyObject *result;
       const char *arg1;
       const char *arg2;
       const char *arg3;

       if (!PyArg_ParseTuple(args, "sss:call", &arg1, &arg2, &arg3)) {
           return NULL;
       }
       result = PyUnicode_FromFormat(
           "Returning -- value: [%d] arg1: [%s] arg2: [%s] arg3: [%s]\n",
           obj->obj_UnderlyingDatatypePtr->size,
           arg1, arg2, arg3);
       return result;
   }

::

   /* Iterators */
   getiterfunc tp_iter;
   iternextfunc tp_iternext;

These functions provide support for the iterator protocol.  Both handlers
take exactly one parameter, the instance for which they are being called,
and return a new reference.  In the case of an error, they should set an
exception and return ``NULL``.  :c:member:`~PyTypeObject.tp_iter` corresponds
to the Python :meth:`~object.__iter__` method, while :c:member:`~PyTypeObject.tp_iternext`
corresponds to the Python :meth:`~iterator.__next__` method.

Any :term:`iterable` object must implement the :c:member:`~PyTypeObject.tp_iter`
handler, which must return an :term:`iterator` object.  Here the same guidelines
apply as for Python classes:

* For collections (such as lists and tuples) which can support multiple
  independent iterators, a new iterator should be created and returned by
  each call to :c:member:`~PyTypeObject.tp_iter`.
* Objects which can only be iterated over once (usually due to side effects of
  iteration, such as file objects) can implement :c:member:`~PyTypeObject.tp_iter`
  by returning a new reference to themselves -- and should also therefore
  implement the :c:member:`~PyTypeObject.tp_iternext`  handler.

Any :term:`iterator` object should implement both :c:member:`~PyTypeObject.tp_iter`
and :c:member:`~PyTypeObject.tp_iternext`.  An iterator's
:c:member:`~PyTypeObject.tp_iter` handler should return a new reference
to the iterator.  Its :c:member:`~PyTypeObject.tp_iternext` handler should
return a new reference to the next object in the iteration, if there is one.
If the iteration has reached the end, :c:member:`~PyTypeObject.tp_iternext`
may return ``NULL`` without setting an exception, or it may set
:exc:`StopIteration` *in addition* to returning ``NULL``; avoiding
the exception can yield slightly better performance.  If an actual error
occurs, :c:member:`~PyTypeObject.tp_iternext` should always set an exception
and return ``NULL``.


.. _weakref-support:

Weak Reference Support
----------------------

One of the goals of Python's weak reference implementation is to allow any type
to participate in the weak reference mechanism without incurring the overhead on
performance-critical objects (such as numbers).

.. seealso::
   Documentation for the :mod:`weakref` module.

For an object to be weakly referenceable, the extension type must set the
``Py_TPFLAGS_MANAGED_WEAKREF`` bit of the :c:member:`~PyTypeObject.tp_flags`
field. The legacy :c:member:`~PyTypeObject.tp_weaklistoffset` field should
be left as zero.

Concretely, here is how the statically declared type object would look::

   static PyTypeObject TrivialType = {
       PyVarObject_HEAD_INIT(NULL, 0)
       /* ... other members omitted for brevity ... */
       .tp_flags = Py_TPFLAGS_MANAGED_WEAKREF | ...,
   };


The only further addition is that ``tp_dealloc`` needs to clear any weak
references (by calling :c:func:`PyObject_ClearWeakRefs`)::

   static void
   Trivial_dealloc(TrivialObject *self)
   {
       /* Clear weakrefs first before calling any destructors */
       PyObject_ClearWeakRefs((PyObject *) self);
       /* ... remainder of destruction code omitted for brevity ... */
       Py_TYPE(self)->tp_free((PyObject *) self);
   }


More Suggestions
----------------

In order to learn how to implement any specific method for your new data type,
get the :term:`CPython` source code.  Go to the :file:`Objects` directory,
then search the C source files for ``tp_`` plus the function you want
(for example, ``tp_richcompare``).  You will find examples of the function
you want to implement.

When you need to verify that an object is a concrete instance of the type you
are implementing, use the :c:func:`PyObject_TypeCheck` function.  A sample of
its use might be something like the following::

   if (!PyObject_TypeCheck(some_object, &MyType)) {
       PyErr_SetString(PyExc_TypeError, "arg #1 not a mything");
       return NULL;
   }

.. seealso::
   Download CPython source releases.
      https://www.python.org/downloads/source/

   The CPython project on GitHub, where the CPython source code is developed.
      https://github.com/python/cpython


================================================
File: /Doc/extending/newtypes_tutorial.rst
================================================
.. highlight:: c

.. _defining-new-types:

**********************************
Defining Extension Types: Tutorial
**********************************

.. sectionauthor:: Michael Hudson <mwh@python.net>
.. sectionauthor:: Dave Kuhlman <dkuhlman@rexx.com>
.. sectionauthor:: Jim Fulton <jim@zope.com>


Python allows the writer of a C extension module to define new types that
can be manipulated from Python code, much like the built-in :class:`str`
and :class:`list` types.  The code for all extension types follows a
pattern, but there are some details that you need to understand before you
can get started.  This document is a gentle introduction to the topic.


.. _dnt-basics:

The Basics
==========

The :term:`CPython` runtime sees all Python objects as variables of type
:c:expr:`PyObject*`, which serves as a "base type" for all Python objects.
The :c:type:`PyObject` structure itself only contains the object's
:term:`reference count` and a pointer to the object's "type object".
This is where the action is; the type object determines which (C) functions
get called by the interpreter when, for instance, an attribute gets looked up
on an object, a method called, or it is multiplied by another object.  These
C functions are called "type methods".

So, if you want to define a new extension type, you need to create a new type
object.

This sort of thing can only be explained by example, so here's a minimal, but
complete, module that defines a new type named :class:`!Custom` inside a C
extension module :mod:`!custom`:

.. note::
   What we're showing here is the traditional way of defining *static*
   extension types.  It should be adequate for most uses.  The C API also
   allows defining heap-allocated extension types using the
   :c:func:`PyType_FromSpec` function, which isn't covered in this tutorial.

.. literalinclude:: ../includes/newtypes/custom.c

Now that's quite a bit to take in at once, but hopefully bits will seem familiar
from the previous chapter.  This file defines three things:

#. What a :class:`!Custom` **object** contains: this is the ``CustomObject``
   struct, which is allocated once for each :class:`!Custom` instance.
#. How the :class:`!Custom` **type** behaves: this is the ``CustomType`` struct,
   which defines a set of flags and function pointers that the interpreter
   inspects when specific operations are requested.
#. How to initialize the :mod:`!custom` module: this is the ``PyInit_custom``
   function and the associated ``custommodule`` struct.

The first bit is::

   typedef struct {
       PyObject_HEAD
   } CustomObject;

This is what a Custom object will contain.  ``PyObject_HEAD`` is mandatory
at the start of each object struct and defines a field called ``ob_base``
of type :c:type:`PyObject`, containing a pointer to a type object and a
reference count (these can be accessed using the macros :c:macro:`Py_TYPE`
and :c:macro:`Py_REFCNT` respectively).  The reason for the macro is to
abstract away the layout and to enable additional fields in :ref:`debug builds
<debug-build>`.

.. note::
   There is no semicolon above after the :c:macro:`PyObject_HEAD` macro.
   Be wary of adding one by accident: some compilers will complain.

Of course, objects generally store additional data besides the standard
``PyObject_HEAD`` boilerplate; for example, here is the definition for
standard Python floats::

   typedef struct {
       PyObject_HEAD
       double ob_fval;
   } PyFloatObject;

The second bit is the definition of the type object. ::

   static PyTypeObject CustomType = {
       .ob_base = PyVarObject_HEAD_INIT(NULL, 0)
       .tp_name = "custom.Custom",
       .tp_doc = PyDoc_STR("Custom objects"),
       .tp_basicsize = sizeof(CustomObject),
       .tp_itemsize = 0,
       .tp_flags = Py_TPFLAGS_DEFAULT,
       .tp_new = PyType_GenericNew,
   };

.. note::
   We recommend using C99-style designated initializers as above, to
   avoid listing all the :c:type:`PyTypeObject` fields that you don't care
   about and also to avoid caring about the fields' declaration order.

The actual definition of :c:type:`PyTypeObject` in :file:`object.h` has
many more :ref:`fields <type-structs>` than the definition above.  The
remaining fields will be filled with zeros by the C compiler, and it's
common practice to not specify them explicitly unless you need them.

We're going to pick it apart, one field at a time::

   .ob_base = PyVarObject_HEAD_INIT(NULL, 0)

This line is mandatory boilerplate to initialize the ``ob_base``
field mentioned above. ::

   .tp_name = "custom.Custom",

The name of our type.  This will appear in the default textual representation of
our objects and in some error messages, for example:

.. code-block:: pycon

   >>> "" + custom.Custom()
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: can only concatenate str (not "custom.Custom") to str

Note that the name is a dotted name that includes both the module name and the
name of the type within the module. The module in this case is :mod:`!custom` and
the type is :class:`!Custom`, so we set the type name to :class:`!custom.Custom`.
Using the real dotted import path is important to make your type compatible
with the :mod:`pydoc` and :mod:`pickle` modules. ::

   .tp_basicsize = sizeof(CustomObject),
   .tp_itemsize = 0,

This is so that Python knows how much memory to allocate when creating
new :class:`!Custom` instances.  :c:member:`~PyTypeObject.tp_itemsize` is
only used for variable-sized objects and should otherwise be zero.

.. note::

   If you want your type to be subclassable from Python, and your type has the same
   :c:member:`~PyTypeObject.tp_basicsize` as its base type, you may have problems with multiple
   inheritance.  A Python subclass of your type will have to list your type first
   in its :attr:`~type.__bases__`, or else it will not be able to call your type's
   :meth:`~object.__new__` method without getting an error.  You can avoid this problem by
   ensuring that your type has a larger value for :c:member:`~PyTypeObject.tp_basicsize` than its
   base type does.  Most of the time, this will be true anyway, because either your
   base type will be :class:`object`, or else you will be adding data members to
   your base type, and therefore increasing its size.

We set the class flags to :c:macro:`Py_TPFLAGS_DEFAULT`. ::

   .tp_flags = Py_TPFLAGS_DEFAULT,

All types should include this constant in their flags.  It enables all of the
members defined until at least Python 3.3.  If you need further members,
you will need to OR the corresponding flags.

We provide a doc string for the type in :c:member:`~PyTypeObject.tp_doc`. ::

   .tp_doc = PyDoc_STR("Custom objects"),

To enable object creation, we have to provide a :c:member:`~PyTypeObject.tp_new`
handler.  This is the equivalent of the Python method :meth:`~object.__new__`, but
has to be specified explicitly.  In this case, we can just use the default
implementation provided by the API function :c:func:`PyType_GenericNew`. ::

   .tp_new = PyType_GenericNew,

Everything else in the file should be familiar, except for some code in
:c:func:`!PyInit_custom`::

   if (PyType_Ready(&CustomType) < 0)
       return;

This initializes the :class:`!Custom` type, filling in a number of members
to the appropriate default values, including :c:member:`~PyObject.ob_type` that we initially
set to ``NULL``. ::

   if (PyModule_AddObjectRef(m, "Custom", (PyObject *) &CustomType) < 0) {
       Py_DECREF(m);
       return NULL;
   }

This adds the type to the module dictionary.  This allows us to create
:class:`!Custom` instances by calling the :class:`!Custom` class:

.. code-block:: pycon

   >>> import custom
   >>> mycustom = custom.Custom()

That's it!  All that remains is to build it; put the above code in a file called
:file:`custom.c`,

.. literalinclude:: ../includes/newtypes/pyproject.toml

in a file called :file:`pyproject.toml`, and

.. code-block:: python

   from setuptools import Extension, setup
   setup(ext_modules=[Extension("custom", ["custom.c"])])

in a file called :file:`setup.py`; then typing

.. code-block:: shell-session

   $ python -m pip install .

in a shell should produce a file :file:`custom.so` in a subdirectory
and install it; now fire up Python --- you should be able to ``import custom``
and play around with ``Custom`` objects.

That wasn't so hard, was it?

Of course, the current Custom type is pretty uninteresting. It has no data and
doesn't do anything. It can't even be subclassed.


Adding data and methods to the Basic example
============================================

Let's extend the basic example to add some data and methods.  Let's also make
the type usable as a base class. We'll create a new module, :mod:`!custom2` that
adds these capabilities:

.. literalinclude:: ../includes/newtypes/custom2.c


This version of the module has a number of changes.

The  :class:`!Custom` type now has three data attributes in its C struct,
*first*, *last*, and *number*.  The *first* and *last* variables are Python
strings containing first and last names.  The *number* attribute is a C integer.

The object structure is updated accordingly::

   typedef struct {
       PyObject_HEAD
       PyObject *first; /* first name */
       PyObject *last;  /* last name */
       int number;
   } CustomObject;

Because we now have data to manage, we have to be more careful about object
allocation and deallocation.  At a minimum, we need a deallocation method::

   static void
   Custom_dealloc(CustomObject *self)
   {
       Py_XDECREF(self->first);
       Py_XDECREF(self->last);
       Py_TYPE(self)->tp_free((PyObject *) self);
   }

which is assigned to the :c:member:`~PyTypeObject.tp_dealloc` member::

   .tp_dealloc = (destructor) Custom_dealloc,

This method first clears the reference counts of the two Python attributes.
:c:func:`Py_XDECREF` correctly handles the case where its argument is
``NULL`` (which might happen here if ``tp_new`` failed midway).  It then
calls the :c:member:`~PyTypeObject.tp_free` member of the object's type
(computed by ``Py_TYPE(self)``) to free the object's memory.  Note that
the object's type might not be :class:`!CustomType`, because the object may
be an instance of a subclass.

.. note::
   The explicit cast to ``destructor`` above is needed because we defined
   ``Custom_dealloc`` to take a ``CustomObject *`` argument, but the ``tp_dealloc``
   function pointer expects to receive a ``PyObject *`` argument.  Otherwise,
   the compiler will emit a warning.  This is object-oriented polymorphism,
   in C!

We want to make sure that the first and last names are initialized to empty
strings, so we provide a ``tp_new`` implementation::

   static PyObject *
   Custom_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
   {
       CustomObject *self;
       self = (CustomObject *) type->tp_alloc(type, 0);
       if (self != NULL) {
           self->first = PyUnicode_FromString("");
           if (self->first == NULL) {
               Py_DECREF(self);
               return NULL;
           }
           self->last = PyUnicode_FromString("");
           if (self->last == NULL) {
               Py_DECREF(self);
               return NULL;
           }
           self->number = 0;
       }
       return (PyObject *) self;
   }

and install it in the :c:member:`~PyTypeObject.tp_new` member::

   .tp_new = Custom_new,

The ``tp_new`` handler is responsible for creating (as opposed to initializing)
objects of the type.  It is exposed in Python as the :meth:`~object.__new__` method.
It is not required to define a ``tp_new`` member, and indeed many extension
types will simply reuse :c:func:`PyType_GenericNew` as done in the first
version of the :class:`!Custom` type above.  In this case, we use the ``tp_new``
handler to initialize the ``first`` and ``last`` attributes to non-``NULL``
default values.

``tp_new`` is passed the type being instantiated (not necessarily ``CustomType``,
if a subclass is instantiated) and any arguments passed when the type was
called, and is expected to return the instance created.  ``tp_new`` handlers
always accept positional and keyword arguments, but they often ignore the
arguments, leaving the argument handling to initializer (a.k.a. ``tp_init``
in C or ``__init__`` in Python) methods.

.. note::
   ``tp_new`` shouldn't call ``tp_init`` explicitly, as the interpreter
   will do it itself.

The ``tp_new`` implementation calls the :c:member:`~PyTypeObject.tp_alloc`
slot to allocate memory::

   self = (CustomObject *) type->tp_alloc(type, 0);

Since memory allocation may fail, we must check the :c:member:`~PyTypeObject.tp_alloc`
result against ``NULL`` before proceeding.

.. note::
   We didn't fill the :c:member:`~PyTypeObject.tp_alloc` slot ourselves. Rather
   :c:func:`PyType_Ready` fills it for us by inheriting it from our base class,
   which is :class:`object` by default.  Most types use the default allocation
   strategy.

.. note::
   If you are creating a co-operative :c:member:`~PyTypeObject.tp_new` (one
   that calls a base type's :c:member:`~PyTypeObject.tp_new` or :meth:`~object.__new__`),
   you must *not* try to determine what method to call using method resolution
   order at runtime.  Always statically determine what type you are going to
   call, and call its :c:member:`~PyTypeObject.tp_new` directly, or via
   ``type->tp_base->tp_new``.  If you do not do this, Python subclasses of your
   type that also inherit from other Python-defined classes may not work correctly.
   (Specifically, you may not be able to create instances of such subclasses
   without getting a :exc:`TypeError`.)

We also define an initialization function which accepts arguments to provide
initial values for our instance::

   static int
   Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)
   {
       static char *kwlist[] = {"first", "last", "number", NULL};
       PyObject *first = NULL, *last = NULL, *tmp;

       if (!PyArg_ParseTupleAndKeywords(args, kwds, "|OOi", kwlist,
                                        &first, &last,
                                        &self->number))
           return -1;

       if (first) {
           tmp = self->first;
           Py_INCREF(first);
           self->first = first;
           Py_XDECREF(tmp);
       }
       if (last) {
           tmp = self->last;
           Py_INCREF(last);
           self->last = last;
           Py_XDECREF(tmp);
       }
       return 0;
   }

by filling the :c:member:`~PyTypeObject.tp_init` slot. ::

   .tp_init = (initproc) Custom_init,

The :c:member:`~PyTypeObject.tp_init` slot is exposed in Python as the
:meth:`~object.__init__` method.  It is used to initialize an object after it's
created.  Initializers always accept positional and keyword arguments,
and they should return either ``0`` on success or ``-1`` on error.

Unlike the ``tp_new`` handler, there is no guarantee that ``tp_init``
is called at all (for example, the :mod:`pickle` module by default
doesn't call :meth:`~object.__init__` on unpickled instances).  It can also be
called multiple times.  Anyone can call the :meth:`!__init__` method on
our objects.  For this reason, we have to be extra careful when assigning
the new attribute values.  We might be tempted, for example to assign the
``first`` member like this::

   if (first) {
       Py_XDECREF(self->first);
       Py_INCREF(first);
       self->first = first;
   }

But this would be risky.  Our type doesn't restrict the type of the
``first`` member, so it could be any kind of object.  It could have a
destructor that causes code to be executed that tries to access the
``first`` member; or that destructor could release the
:term:`Global interpreter Lock <GIL>` and let arbitrary code run in other
threads that accesses and modifies our object.

To be paranoid and protect ourselves against this possibility, we almost
always reassign members before decrementing their reference counts.  When
don't we have to do this?

* when we absolutely know that the reference count is greater than 1;

* when we know that deallocation of the object [#]_ will neither release
  the :term:`GIL` nor cause any calls back into our type's code;

* when decrementing a reference count in a :c:member:`~PyTypeObject.tp_dealloc`
  handler on a type which doesn't support cyclic garbage collection [#]_.

We want to expose our instance variables as attributes. There are a
number of ways to do that. The simplest way is to define member definitions::

   static PyMemberDef Custom_members[] = {
       {"first", Py_T_OBJECT_EX, offsetof(CustomObject, first), 0,
        "first name"},
       {"last", Py_T_OBJECT_EX, offsetof(CustomObject, last), 0,
        "last name"},
       {"number", Py_T_INT, offsetof(CustomObject, number), 0,
        "custom number"},
       {NULL}  /* Sentinel */
   };

and put the definitions in the :c:member:`~PyTypeObject.tp_members` slot::

   .tp_members = Custom_members,

Each member definition has a member name, type, offset, access flags and
documentation string.  See the :ref:`Generic-Attribute-Management` section
below for details.

A disadvantage of this approach is that it doesn't provide a way to restrict the
types of objects that can be assigned to the Python attributes.  We expect the
first and last names to be strings, but any Python objects can be assigned.
Further, the attributes can be deleted, setting the C pointers to ``NULL``.  Even
though we can make sure the members are initialized to non-``NULL`` values, the
members can be set to ``NULL`` if the attributes are deleted.

We define a single method, :meth:`!Custom.name`, that outputs the objects name as the
concatenation of the first and last names. ::

   static PyObject *
   Custom_name(CustomObject *self, PyObject *Py_UNUSED(ignored))
   {
       if (self->first == NULL) {
           PyErr_SetString(PyExc_AttributeError, "first");
           return NULL;
       }
       if (self->last == NULL) {
           PyErr_SetString(PyExc_AttributeError, "last");
           return NULL;
       }
       return PyUnicode_FromFormat("%S %S", self->first, self->last);
   }

The method is implemented as a C function that takes a :class:`!Custom` (or
:class:`!Custom` subclass) instance as the first argument.  Methods always take an
instance as the first argument. Methods often take positional and keyword
arguments as well, but in this case we don't take any and don't need to accept
a positional argument tuple or keyword argument dictionary. This method is
equivalent to the Python method:

.. code-block:: python

   def name(self):
       return "%s %s" % (self.first, self.last)

Note that we have to check for the possibility that our :attr:`!first` and
:attr:`!last` members are ``NULL``.  This is because they can be deleted, in which
case they are set to ``NULL``.  It would be better to prevent deletion of these
attributes and to restrict the attribute values to be strings.  We'll see how to
do that in the next section.

Now that we've defined the method, we need to create an array of method
definitions::

   static PyMethodDef Custom_methods[] = {
       {"name", (PyCFunction) Custom_name, METH_NOARGS,
        "Return the name, combining the first and last name"
       },
       {NULL}  /* Sentinel */
   };

(note that we used the :c:macro:`METH_NOARGS` flag to indicate that the method
is expecting no arguments other than *self*)

and assign it to the :c:member:`~PyTypeObject.tp_methods` slot::

   .tp_methods = Custom_methods,

Finally, we'll make our type usable as a base class for subclassing.  We've
written our methods carefully so far so that they don't make any assumptions
about the type of the object being created or used, so all we need to do is
to add the :c:macro:`Py_TPFLAGS_BASETYPE` to our class flag definition::

   .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE,

We rename :c:func:`!PyInit_custom` to :c:func:`!PyInit_custom2`, update the
module name in the :c:type:`PyModuleDef` struct, and update the full class
name in the :c:type:`PyTypeObject` struct.

Finally, we update our :file:`setup.py` file to include the new module,

.. code-block:: python

   from setuptools import Extension, setup
   setup(ext_modules=[
       Extension("custom", ["custom.c"]),
       Extension("custom2", ["custom2.c"]),
   ])

and then we re-install so that we can ``import custom2``:

.. code-block:: shell-session

   $ python -m pip install .

Providing finer control over data attributes
============================================

In this section, we'll provide finer control over how the :attr:`!first` and
:attr:`!last` attributes are set in the :class:`!Custom` example. In the previous
version of our module, the instance variables :attr:`!first` and :attr:`!last`
could be set to non-string values or even deleted. We want to make sure that
these attributes always contain strings.

.. literalinclude:: ../includes/newtypes/custom3.c


To provide greater control, over the :attr:`!first` and :attr:`!last` attributes,
we'll use custom getter and setter functions.  Here are the functions for
getting and setting the :attr:`!first` attribute::

   static PyObject *
   Custom_getfirst(CustomObject *self, void *closure)
   {
       Py_INCREF(self->first);
       return self->first;
   }

   static int
   Custom_setfirst(CustomObject *self, PyObject *value, void *closure)
   {
       PyObject *tmp;
       if (value == NULL) {
           PyErr_SetString(PyExc_TypeError, "Cannot delete the first attribute");
           return -1;
       }
       if (!PyUnicode_Check(value)) {
           PyErr_SetString(PyExc_TypeError,
                           "The first attribute value must be a string");
           return -1;
       }
       tmp = self->first;
       Py_INCREF(value);
       self->first = value;
       Py_DECREF(tmp);
       return 0;
   }

The getter function is passed a :class:`!Custom` object and a "closure", which is
a void pointer.  In this case, the closure is ignored.  (The closure supports an
advanced usage in which definition data is passed to the getter and setter. This
could, for example, be used to allow a single set of getter and setter functions
that decide the attribute to get or set based on data in the closure.)

The setter function is passed the :class:`!Custom` object, the new value, and the
closure.  The new value may be ``NULL``, in which case the attribute is being
deleted.  In our setter, we raise an error if the attribute is deleted or if its
new value is not a string.

We create an array of :c:type:`PyGetSetDef` structures::

   static PyGetSetDef Custom_getsetters[] = {
       {"first", (getter) Custom_getfirst, (setter) Custom_setfirst,
        "first name", NULL},
       {"last", (getter) Custom_getlast, (setter) Custom_setlast,
        "last name", NULL},
       {NULL}  /* Sentinel */
   };

and register it in the :c:member:`~PyTypeObject.tp_getset` slot::

   .tp_getset = Custom_getsetters,

The last item in a :c:type:`PyGetSetDef` structure is the "closure" mentioned
above.  In this case, we aren't using a closure, so we just pass ``NULL``.

We also remove the member definitions for these attributes::

   static PyMemberDef Custom_members[] = {
       {"number", Py_T_INT, offsetof(CustomObject, number), 0,
        "custom number"},
       {NULL}  /* Sentinel */
   };

We also need to update the :c:member:`~PyTypeObject.tp_init` handler to only
allow strings [#]_ to be passed::

   static int
   Custom_init(CustomObject *self, PyObject *args, PyObject *kwds)
   {
       static char *kwlist[] = {"first", "last", "number", NULL};
       PyObject *first = NULL, *last = NULL, *tmp;

       if (!PyArg_ParseTupleAndKeywords(args, kwds, "|UUi", kwlist,
                                        &first, &last,
                                        &self->number))
           return -1;

       if (first) {
           tmp = self->first;
           Py_INCREF(first);
           self->first = first;
           Py_DECREF(tmp);
       }
       if (last) {
           tmp = self->last;
           Py_INCREF(last);
           self->last = last;
           Py_DECREF(tmp);
       }
       return 0;
   }

With these changes, we can assure that the ``first`` and ``last`` members are
never ``NULL`` so we can remove checks for ``NULL`` values in almost all cases.
This means that most of the :c:func:`Py_XDECREF` calls can be converted to
:c:func:`Py_DECREF` calls.  The only place we can't change these calls is in
the ``tp_dealloc`` implementation, where there is the possibility that the
initialization of these members failed in ``tp_new``.

We also rename the module initialization function and module name in the
initialization function, as we did before, and we add an extra definition to the
:file:`setup.py` file.


Supporting cyclic garbage collection
====================================

Python has a :term:`cyclic garbage collector (GC) <garbage collection>` that
can identify unneeded objects even when their reference counts are not zero.
This can happen when objects are involved in cycles.  For example, consider:

.. code-block:: pycon

   >>> l = []
   >>> l.append(l)
   >>> del l

In this example, we create a list that contains itself. When we delete it, it
still has a reference from itself. Its reference count doesn't drop to zero.
Fortunately, Python's cyclic garbage collector will eventually figure out that
the list is garbage and free it.

In the second version of the :class:`!Custom` example, we allowed any kind of
object to be stored in the :attr:`!first` or :attr:`!last` attributes [#]_.
Besides, in the second and third versions, we allowed subclassing
:class:`!Custom`, and subclasses may add arbitrary attributes.  For any of
those two reasons, :class:`!Custom` objects can participate in cycles:

.. code-block:: pycon

   >>> import custom3
   >>> class Derived(custom3.Custom): pass
   ...
   >>> n = Derived()
   >>> n.some_attribute = n

To allow a :class:`!Custom` instance participating in a reference cycle to
be properly detected and collected by the cyclic GC, our :class:`!Custom` type
needs to fill two additional slots and to enable a flag that enables these slots:

.. literalinclude:: ../includes/newtypes/custom4.c


First, the traversal method lets the cyclic GC know about subobjects that could
participate in cycles::

   static int
   Custom_traverse(CustomObject *self, visitproc visit, void *arg)
   {
       int vret;
       if (self->first) {
           vret = visit(self->first, arg);
           if (vret != 0)
               return vret;
       }
       if (self->last) {
           vret = visit(self->last, arg);
           if (vret != 0)
               return vret;
       }
       return 0;
   }

For each subobject that can participate in cycles, we need to call the
:c:func:`!visit` function, which is passed to the traversal method. The
:c:func:`!visit` function takes as arguments the subobject and the extra argument
*arg* passed to the traversal method.  It returns an integer value that must be
returned if it is non-zero.

Python provides a :c:func:`Py_VISIT` macro that automates calling visit
functions.  With :c:func:`Py_VISIT`, we can minimize the amount of boilerplate
in ``Custom_traverse``::

   static int
   Custom_traverse(CustomObject *self, visitproc visit, void *arg)
   {
       Py_VISIT(self->first);
       Py_VISIT(self->last);
       return 0;
   }

.. note::
   The :c:member:`~PyTypeObject.tp_traverse` implementation must name its
   arguments exactly *visit* and *arg* in order to use :c:func:`Py_VISIT`.

Second, we need to provide a method for clearing any subobjects that can
participate in cycles::

   static int
   Custom_clear(CustomObject *self)
   {
       Py_CLEAR(self->first);
       Py_CLEAR(self->last);
       return 0;
   }

Notice the use of the :c:func:`Py_CLEAR` macro.  It is the recommended and safe
way to clear data attributes of arbitrary types while decrementing
their reference counts.  If you were to call :c:func:`Py_XDECREF` instead
on the attribute before setting it to ``NULL``, there is a possibility
that the attribute's destructor would call back into code that reads the
attribute again (*especially* if there is a reference cycle).

.. note::
   You could emulate :c:func:`Py_CLEAR` by writing::

      PyObject *tmp;
      tmp = self->first;
      self->first = NULL;
      Py_XDECREF(tmp);

   Nevertheless, it is much easier and less error-prone to always
   use :c:func:`Py_CLEAR` when deleting an attribute.  Don't
   try to micro-optimize at the expense of robustness!

The deallocator ``Custom_dealloc`` may call arbitrary code when clearing
attributes.  It means the circular GC can be triggered inside the function.
Since the GC assumes reference count is not zero, we need to untrack the object
from the GC by calling :c:func:`PyObject_GC_UnTrack` before clearing members.
Here is our reimplemented deallocator using :c:func:`PyObject_GC_UnTrack`
and ``Custom_clear``::

   static void
   Custom_dealloc(CustomObject *self)
   {
       PyObject_GC_UnTrack(self);
       Custom_clear(self);
       Py_TYPE(self)->tp_free((PyObject *) self);
   }

Finally, we add the :c:macro:`Py_TPFLAGS_HAVE_GC` flag to the class flags::

   .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,

That's pretty much it.  If we had written custom :c:member:`~PyTypeObject.tp_alloc` or
:c:member:`~PyTypeObject.tp_free` handlers, we'd need to modify them for cyclic
garbage collection.  Most extensions will use the versions automatically provided.


Subclassing other types
=======================

It is possible to create new extension types that are derived from existing
types. It is easiest to inherit from the built in types, since an extension can
easily use the :c:type:`PyTypeObject` it needs. It can be difficult to share
these :c:type:`PyTypeObject` structures between extension modules.

In this example we will create a :class:`!SubList` type that inherits from the
built-in :class:`list` type. The new type will be completely compatible with
regular lists, but will have an additional :meth:`!increment` method that
increases an internal counter:

.. code-block:: pycon

   >>> import sublist
   >>> s = sublist.SubList(range(3))
   >>> s.extend(s)
   >>> print(len(s))
   6
   >>> print(s.increment())
   1
   >>> print(s.increment())
   2

.. literalinclude:: ../includes/newtypes/sublist.c


As you can see, the source code closely resembles the :class:`!Custom` examples in
previous sections. We will break down the main differences between them. ::

   typedef struct {
       PyListObject list;
       int state;
   } SubListObject;

The primary difference for derived type objects is that the base type's
object structure must be the first value.  The base type will already include
the :c:func:`PyObject_HEAD` at the beginning of its structure.

When a Python object is a :class:`!SubList` instance, its ``PyObject *`` pointer
can be safely cast to both ``PyListObject *`` and ``SubListObject *``::

   static int
   SubList_init(SubListObject *self, PyObject *args, PyObject *kwds)
   {
       if (PyList_Type.tp_init((PyObject *) self, args, kwds) < 0)
           return -1;
       self->state = 0;
       return 0;
   }

We see above how to call through to the :meth:`~object.__init__` method of the base
type.

This pattern is important when writing a type with custom
:c:member:`~PyTypeObject.tp_new` and :c:member:`~PyTypeObject.tp_dealloc`
members.  The :c:member:`~PyTypeObject.tp_new` handler should not actually
create the memory for the object with its :c:member:`~PyTypeObject.tp_alloc`,
but let the base class handle it by calling its own :c:member:`~PyTypeObject.tp_new`.

The :c:type:`PyTypeObject` struct supports a :c:member:`~PyTypeObject.tp_base`
specifying the type's concrete base class.  Due to cross-platform compiler
issues, you can't fill that field directly with a reference to
:c:type:`PyList_Type`; it should be done later in the module initialization
function::

   PyMODINIT_FUNC
   PyInit_sublist(void)
   {
       PyObject* m;
       SubListType.tp_base = &PyList_Type;
       if (PyType_Ready(&SubListType) < 0)
           return NULL;

       m = PyModule_Create(&sublistmodule);
       if (m == NULL)
           return NULL;

       if (PyModule_AddObjectRef(m, "SubList", (PyObject *) &SubListType) < 0) {
           Py_DECREF(m);
           return NULL;
       }

       return m;
   }

Before calling :c:func:`PyType_Ready`, the type structure must have the
:c:member:`~PyTypeObject.tp_base` slot filled in.  When we are deriving an
existing type, it is not necessary to fill out the :c:member:`~PyTypeObject.tp_alloc`
slot with :c:func:`PyType_GenericNew` -- the allocation function from the base
type will be inherited.

After that, calling :c:func:`PyType_Ready` and adding the type object to the
module is the same as with the basic :class:`!Custom` examples.


.. rubric:: Footnotes

.. [#] This is true when we know that the object is a basic type, like a string or a
   float.

.. [#] We relied on this in the :c:member:`~PyTypeObject.tp_dealloc` handler
   in this example, because our type doesn't support garbage collection.

.. [#] We now know that the first and last members are strings, so perhaps we
   could be less careful about decrementing their reference counts, however,
   we accept instances of string subclasses.  Even though deallocating normal
   strings won't call back into our objects, we can't guarantee that deallocating
   an instance of a string subclass won't call back into our objects.

.. [#] Also, even with our attributes restricted to strings instances, the user
   could pass arbitrary :class:`str` subclasses and therefore still create
   reference cycles.


================================================
File: /Doc/extending/windows.rst
================================================
.. highlight:: c


.. _building-on-windows:

****************************************
Building C and C++ Extensions on Windows
****************************************

This chapter briefly explains how to create a Windows extension module for
Python using Microsoft Visual C++, and follows with more detailed background
information on how it works.  The explanatory material is useful for both the
Windows programmer learning to build Python extensions and the Unix programmer
interested in producing software which can be successfully built on both Unix
and Windows.

Module authors are encouraged to use the distutils approach for building
extension modules, instead of the one described in this section. You will still
need the C compiler that was used to build Python; typically Microsoft Visual
C++.

.. note::

   This chapter mentions a number of filenames that include an encoded Python
   version number.  These filenames are represented with the version number shown
   as ``XY``; in practice, ``'X'`` will be the major version number and ``'Y'``
   will be the minor version number of the Python release you're working with.  For
   example, if you are using Python 2.2.1, ``XY`` will actually be ``22``.


.. _win-cookbook:

A Cookbook Approach
===================

There are two approaches to building extension modules on Windows, just as there
are on Unix: use the ``setuptools`` package to control the build process, or
do things manually.  The setuptools approach works well for most extensions;
documentation on using ``setuptools`` to build and package extension modules
is available in :ref:`setuptools-index`.  If you find you really need to do
things manually, it may be instructive to study the project file for the
:source:`winsound <PCbuild/winsound.vcxproj>` standard library module.


.. _dynamic-linking:

Differences Between Unix and Windows
====================================

.. sectionauthor:: Chris Phoenix <cphoenix@best.com>


Unix and Windows use completely different paradigms for run-time loading of
code.  Before you try to build a module that can be dynamically loaded, be aware
of how your system works.

In Unix, a shared object (:file:`.so`) file contains code to be used by the
program, and also the names of functions and data that it expects to find in the
program.  When the file is joined to the program, all references to those
functions and data in the file's code are changed to point to the actual
locations in the program where the functions and data are placed in memory.
This is basically a link operation.

In Windows, a dynamic-link library (:file:`.dll`) file has no dangling
references.  Instead, an access to functions or data goes through a lookup
table.  So the DLL code does not have to be fixed up at runtime to refer to the
program's memory; instead, the code already uses the DLL's lookup table, and the
lookup table is modified at runtime to point to the functions and data.

In Unix, there is only one type of library file (:file:`.a`) which contains code
from several object files (:file:`.o`).  During the link step to create a shared
object file (:file:`.so`), the linker may find that it doesn't know where an
identifier is defined.  The linker will look for it in the object files in the
libraries; if it finds it, it will include all the code from that object file.

In Windows, there are two types of library, a static library and an import
library (both called :file:`.lib`).  A static library is like a Unix :file:`.a`
file; it contains code to be included as necessary. An import library is
basically used only to reassure the linker that a certain identifier is legal,
and will be present in the program when the DLL is loaded.  So the linker uses
the information from the import library to build the lookup table for using
identifiers that are not included in the DLL.  When an application or a DLL is
linked, an import library may be generated, which will need to be used for all
future DLLs that depend on the symbols in the application or DLL.

Suppose you are building two dynamic-load modules, B and C, which should share
another block of code A.  On Unix, you would *not* pass :file:`A.a` to the
linker for :file:`B.so` and :file:`C.so`; that would cause it to be included
twice, so that B and C would each have their own copy.  In Windows, building
:file:`A.dll` will also build :file:`A.lib`.  You *do* pass :file:`A.lib` to the
linker for B and C.  :file:`A.lib` does not contain code; it just contains
information which will be used at runtime to access A's code.

In Windows, using an import library is sort of like using ``import spam``; it
gives you access to spam's names, but does not create a separate copy.  On Unix,
linking with a library is more like ``from spam import *``; it does create a
separate copy.


.. _win-dlls:

Using DLLs in Practice
======================

.. sectionauthor:: Chris Phoenix <cphoenix@best.com>


Windows Python is built in Microsoft Visual C++; using other compilers may or
may not work.  The rest of this section is MSVC++ specific.

When creating DLLs in Windows, you must pass :file:`pythonXY.lib` to the linker.
To build two DLLs, spam and ni (which uses C functions found in spam), you could
use these commands::

   cl /LD /I/python/include spam.c ../libs/pythonXY.lib
   cl /LD /I/python/include ni.c spam.lib ../libs/pythonXY.lib

The first command created three files: :file:`spam.obj`, :file:`spam.dll` and
:file:`spam.lib`.  :file:`Spam.dll` does not contain any Python functions (such
as :c:func:`PyArg_ParseTuple`), but it does know how to find the Python code
thanks to :file:`pythonXY.lib`.

The second command created :file:`ni.dll` (and :file:`.obj` and :file:`.lib`),
which knows how to find the necessary functions from spam, and also from the
Python executable.

Not every identifier is exported to the lookup table.  If you want any other
modules (including Python) to be able to see your identifiers, you have to say
``_declspec(dllexport)``, as in ``void _declspec(dllexport) initspam(void)`` or
``PyObject _declspec(dllexport) *NiGetSpamData(void)``.

Developer Studio will throw in a lot of import libraries that you do not really
need, adding about 100K to your executable.  To get rid of them, use the Project
Settings dialog, Link tab, to specify *ignore default libraries*.  Add the
correct :file:`msvcrt{xx}.lib` to the list of libraries.


================================================
File: /Doc/faq/design.rst
================================================
======================
Design and History FAQ
======================

.. only:: html

   .. contents::


Why does Python use indentation for grouping of statements?
-----------------------------------------------------------

Guido van Rossum believes that using indentation for grouping is extremely
elegant and contributes a lot to the clarity of the average Python program.
Most people learn to love this feature after a while.

Since there are no begin/end brackets there cannot be a disagreement between
grouping perceived by the parser and the human reader.  Occasionally C
programmers will encounter a fragment of code like this::

   if (x <= y)
           x++;
           y--;
   z++;

Only the ``x++`` statement is executed if the condition is true, but the
indentation leads many to believe otherwise.  Even experienced C programmers will
sometimes stare at it a long time wondering as to why ``y`` is being decremented even
for ``x > y``.

Because there are no begin/end brackets, Python is much less prone to
coding-style conflicts.  In C there are many different ways to place the braces.
After becoming used to reading and writing code using a particular style,
it is normal to feel somewhat uneasy when reading (or being required to write)
in a different one.


Many coding styles place begin/end brackets on a line by themselves.  This makes
programs considerably longer and wastes valuable screen space, making it harder
to get a good overview of a program.  Ideally, a function should fit on one
screen (say, 20--30 lines).  20 lines of Python can do a lot more work than 20
lines of C.  This is not solely due to the lack of begin/end brackets -- the
lack of declarations and the high-level data types are also responsible -- but
the indentation-based syntax certainly helps.


Why am I getting strange results with simple arithmetic operations?
-------------------------------------------------------------------

See the next question.


Why are floating-point calculations so inaccurate?
--------------------------------------------------

Users are often surprised by results like this::

    >>> 1.2 - 1.0
    0.19999999999999996

and think it is a bug in Python.  It's not.  This has little to do with Python,
and much more to do with how the underlying platform handles floating-point
numbers.

The :class:`float` type in CPython uses a C ``double`` for storage.  A
:class:`float` object's value is stored in binary floating-point with a fixed
precision (typically 53 bits) and Python uses C operations, which in turn rely
on the hardware implementation in the processor, to perform floating-point
operations. This means that as far as floating-point operations are concerned,
Python behaves like many popular languages including C and Java.

Many numbers that can be written easily in decimal notation cannot be expressed
exactly in binary floating point.  For example, after::

    >>> x = 1.2

the value stored for ``x`` is a (very good) approximation to the decimal value
``1.2``, but is not exactly equal to it.  On a typical machine, the actual
stored value is::

    1.0011001100110011001100110011001100110011001100110011 (binary)

which is exactly::

    1.1999999999999999555910790149937383830547332763671875 (decimal)

The typical precision of 53 bits provides Python floats with 15--16
decimal digits of accuracy.

For a fuller explanation, please see the :ref:`floating-point arithmetic
<tut-fp-issues>` chapter in the Python tutorial.


Why are Python strings immutable?
---------------------------------

There are several advantages.

One is performance: knowing that a string is immutable means we can allocate
space for it at creation time, and the storage requirements are fixed and
unchanging.  This is also one of the reasons for the distinction between tuples
and lists.

Another advantage is that strings in Python are considered as "elemental" as
numbers.  No amount of activity will change the value 8 to anything else, and in
Python, no amount of activity will change the string "eight" to anything else.


.. _why-self:

Why must 'self' be used explicitly in method definitions and calls?
-------------------------------------------------------------------

The idea was borrowed from Modula-3.  It turns out to be very useful, for a
variety of reasons.

First, it's more obvious that you are using a method or instance attribute
instead of a local variable.  Reading ``self.x`` or ``self.meth()`` makes it
absolutely clear that an instance variable or method is used even if you don't
know the class definition by heart.  In C++, you can sort of tell by the lack of
a local variable declaration (assuming globals are rare or easily recognizable)
-- but in Python, there are no local variable declarations, so you'd have to
look up the class definition to be sure.  Some C++ and Java coding standards
call for instance attributes to have an ``m_`` prefix, so this explicitness is
still useful in those languages, too.

Second, it means that no special syntax is necessary if you want to explicitly
reference or call the method from a particular class.  In C++, if you want to
use a method from a base class which is overridden in a derived class, you have
to use the ``::`` operator -- in Python you can write
``baseclass.methodname(self, <argument list>)``.  This is particularly useful
for :meth:`~object.__init__` methods, and in general in cases where a derived class
method wants to extend the base class method of the same name and thus has to
call the base class method somehow.

Finally, for instance variables it solves a syntactic problem with assignment:
since local variables in Python are (by definition!) those variables to which a
value is assigned in a function body (and that aren't explicitly declared
global), there has to be some way to tell the interpreter that an assignment was
meant to assign to an instance variable instead of to a local variable, and it
should preferably be syntactic (for efficiency reasons).  C++ does this through
declarations, but Python doesn't have declarations and it would be a pity having
to introduce them just for this purpose.  Using the explicit ``self.var`` solves
this nicely.  Similarly, for using instance variables, having to write
``self.var`` means that references to unqualified names inside a method don't
have to search the instance's directories.  To put it another way, local
variables and instance variables live in two different namespaces, and you need
to tell Python which namespace to use.


.. _why-can-t-i-use-an-assignment-in-an-expression:

Why can't I use an assignment in an expression?
-----------------------------------------------

Starting in Python 3.8, you can!

Assignment expressions using the walrus operator ``:=`` assign a variable in an
expression::

   while chunk := fp.read(200):
      print(chunk)

See :pep:`572` for more information.



Why does Python use methods for some functionality (e.g. list.index()) but functions for other (e.g. len(list))?
----------------------------------------------------------------------------------------------------------------

As Guido said:

    (a) For some operations, prefix notation just reads better than
    postfix -- prefix (and infix!) operations have a long tradition in
    mathematics which likes notations where the visuals help the
    mathematician thinking about a problem. Compare the easy with which we
    rewrite a formula like x*(a+b) into x*a + x*b to the clumsiness of
    doing the same thing using a raw OO notation.

    (b) When I read code that says len(x) I *know* that it is asking for
    the length of something. This tells me two things: the result is an
    integer, and the argument is some kind of container. To the contrary,
    when I read x.len(), I have to already know that x is some kind of
    container implementing an interface or inheriting from a class that
    has a standard len(). Witness the confusion we occasionally have when
    a class that is not implementing a mapping has a get() or keys()
    method, or something that isn't a file has a write() method.

    -- https://mail.python.org/pipermail/python-3000/2006-November/004643.html


Why is join() a string method instead of a list or tuple method?
----------------------------------------------------------------

Strings became much more like other standard types starting in Python 1.6, when
methods were added which give the same functionality that has always been
available using the functions of the string module.  Most of these new methods
have been widely accepted, but the one which appears to make some programmers
feel uncomfortable is::

   ", ".join(['1', '2', '4', '8', '16'])

which gives the result::

   "1, 2, 4, 8, 16"

There are two common arguments against this usage.

The first runs along the lines of: "It looks really ugly using a method of a
string literal (string constant)", to which the answer is that it might, but a
string literal is just a fixed value. If the methods are to be allowed on names
bound to strings there is no logical reason to make them unavailable on
literals.

The second objection is typically cast as: "I am really telling a sequence to
join its members together with a string constant".  Sadly, you aren't.  For some
reason there seems to be much less difficulty with having :meth:`~str.split` as
a string method, since in that case it is easy to see that ::

   "1, 2, 4, 8, 16".split(", ")

is an instruction to a string literal to return the substrings delimited by the
given separator (or, by default, arbitrary runs of white space).

:meth:`~str.join` is a string method because in using it you are telling the
separator string to iterate over a sequence of strings and insert itself between
adjacent elements.  This method can be used with any argument which obeys the
rules for sequence objects, including any new classes you might define yourself.
Similar methods exist for bytes and bytearray objects.


How fast are exceptions?
------------------------

A :keyword:`try`/:keyword:`except` block is extremely efficient if no exceptions
are raised.  Actually
catching an exception is expensive.  In versions of Python prior to 2.0 it was
common to use this idiom::

   try:
       value = mydict[key]
   except KeyError:
       mydict[key] = getvalue(key)
       value = mydict[key]

This only made sense when you expected the dict to have the key almost all the
time.  If that wasn't the case, you coded it like this::

   if key in mydict:
       value = mydict[key]
   else:
       value = mydict[key] = getvalue(key)

For this specific case, you could also use ``value = dict.setdefault(key,
getvalue(key))``, but only if the ``getvalue()`` call is cheap enough because it
is evaluated in all cases.


Why isn't there a switch or case statement in Python?
-----------------------------------------------------

In general, structured switch statements execute one block of code
when an expression has a particular value or set of values.
Since Python 3.10 one can easily match literal values, or constants
within a namespace, with a ``match ... case`` statement.
An older alternative is a sequence of ``if... elif... elif... else``.

For cases where you need to choose from a very large number of possibilities,
you can create a dictionary mapping case values to functions to call.  For
example::

   functions = {'a': function_1,
                'b': function_2,
                'c': self.method_1}

   func = functions[value]
   func()

For calling methods on objects, you can simplify yet further by using the
:func:`getattr` built-in to retrieve methods with a particular name::

   class MyVisitor:
       def visit_a(self):
           ...

       def dispatch(self, value):
           method_name = 'visit_' + str(value)
           method = getattr(self, method_name)
           method()

It's suggested that you use a prefix for the method names, such as ``visit_`` in
this example.  Without such a prefix, if values are coming from an untrusted
source, an attacker would be able to call any method on your object.

Imitating switch with fallthrough, as with C's switch-case-default,
is possible, much harder, and less needed.


Can't you emulate threads in the interpreter instead of relying on an OS-specific thread implementation?
--------------------------------------------------------------------------------------------------------

Answer 1: Unfortunately, the interpreter pushes at least one C stack frame for
each Python stack frame.  Also, extensions can call back into Python at almost
random moments.  Therefore, a complete threads implementation requires thread
support for C.

Answer 2: Fortunately, there is `Stackless Python <https://github.com/stackless-dev/stackless/wiki>`_,
which has a completely redesigned interpreter loop that avoids the C stack.


Why can't lambda expressions contain statements?
------------------------------------------------

Python lambda expressions cannot contain statements because Python's syntactic
framework can't handle statements nested inside expressions.  However, in
Python, this is not a serious problem.  Unlike lambda forms in other languages,
where they add functionality, Python lambdas are only a shorthand notation if
you're too lazy to define a function.

Functions are already first class objects in Python, and can be declared in a
local scope.  Therefore the only advantage of using a lambda instead of a
locally defined function is that you don't need to invent a name for the
function -- but that's just a local variable to which the function object (which
is exactly the same type of object that a lambda expression yields) is assigned!


Can Python be compiled to machine code, C or some other language?
-----------------------------------------------------------------

`Cython <https://cython.org/>`_ compiles a modified version of Python with
optional annotations into C extensions.  `Nuitka <https://nuitka.net/>`_ is
an up-and-coming compiler of Python into C++ code, aiming to support the full
Python language.


How does Python manage memory?
------------------------------

The details of Python memory management depend on the implementation.  The
standard implementation of Python, :term:`CPython`, uses reference counting to
detect inaccessible objects, and another mechanism to collect reference cycles,
periodically executing a cycle detection algorithm which looks for inaccessible
cycles and deletes the objects involved. The :mod:`gc` module provides functions
to perform a garbage collection, obtain debugging statistics, and tune the
collector's parameters.

Other implementations (such as `Jython <https://www.jython.org>`_ or
`PyPy <https://pypy.org>`_), however, can rely on a different mechanism
such as a full-blown garbage collector.  This difference can cause some
subtle porting problems if your Python code depends on the behavior of the
reference counting implementation.

In some Python implementations, the following code (which is fine in CPython)
will probably run out of file descriptors::

   for file in very_long_list_of_files:
       f = open(file)
       c = f.read(1)

Indeed, using CPython's reference counting and destructor scheme, each new
assignment to ``f`` closes the previous file.  With a traditional GC, however,
those file objects will only get collected (and closed) at varying and possibly
long intervals.

If you want to write code that will work with any Python implementation,
you should explicitly close the file or use the :keyword:`with` statement;
this will work regardless of memory management scheme::

   for file in very_long_list_of_files:
       with open(file) as f:
           c = f.read(1)


Why doesn't CPython use a more traditional garbage collection scheme?
---------------------------------------------------------------------

For one thing, this is not a C standard feature and hence it's not portable.
(Yes, we know about the Boehm GC library.  It has bits of assembler code for
*most* common platforms, not for all of them, and although it is mostly
transparent, it isn't completely transparent; patches are required to get
Python to work with it.)

Traditional GC also becomes a problem when Python is embedded into other
applications.  While in a standalone Python it's fine to replace the standard
``malloc()`` and ``free()`` with versions provided by the GC library, an application
embedding Python may want to have its *own* substitute for ``malloc()`` and ``free()``,
and may not want Python's.  Right now, CPython works with anything that
implements ``malloc()`` and ``free()`` properly.


Why isn't all memory freed when CPython exits?
----------------------------------------------

Objects referenced from the global namespaces of Python modules are not always
deallocated when Python exits.  This may happen if there are circular
references.  There are also certain bits of memory that are allocated by the C
library that are impossible to free (e.g. a tool like Purify will complain about
these).  Python is, however, aggressive about cleaning up memory on exit and
does try to destroy every single object.

If you want to force Python to delete certain things on deallocation use the
:mod:`atexit` module to run a function that will force those deletions.


Why are there separate tuple and list data types?
-------------------------------------------------

Lists and tuples, while similar in many respects, are generally used in
fundamentally different ways.  Tuples can be thought of as being similar to
Pascal ``records`` or C ``structs``; they're small collections of related data which may
be of different types which are operated on as a group.  For example, a
Cartesian coordinate is appropriately represented as a tuple of two or three
numbers.

Lists, on the other hand, are more like arrays in other languages.  They tend to
hold a varying number of objects all of which have the same type and which are
operated on one-by-one.  For example, :func:`os.listdir('.') <os.listdir>`
returns a list of
strings representing the files in the current directory.  Functions which
operate on this output would generally not break if you added another file or
two to the directory.

Tuples are immutable, meaning that once a tuple has been created, you can't
replace any of its elements with a new value.  Lists are mutable, meaning that
you can always change a list's elements.  Only immutable elements can be used as
dictionary keys, and hence only tuples and not lists can be used as keys.


How are lists implemented in CPython?
-------------------------------------

CPython's lists are really variable-length arrays, not Lisp-style linked lists.
The implementation uses a contiguous array of references to other objects, and
keeps a pointer to this array and the array's length in a list head structure.

This makes indexing a list ``a[i]`` an operation whose cost is independent of
the size of the list or the value of the index.

When items are appended or inserted, the array of references is resized.  Some
cleverness is applied to improve the performance of appending items repeatedly;
when the array must be grown, some extra space is allocated so the next few
times don't require an actual resize.


How are dictionaries implemented in CPython?
--------------------------------------------

CPython's dictionaries are implemented as resizable hash tables.  Compared to
B-trees, this gives better performance for lookup (the most common operation by
far) under most circumstances, and the implementation is simpler.

Dictionaries work by computing a hash code for each key stored in the dictionary
using the :func:`hash` built-in function.  The hash code varies widely depending
on the key and a per-process seed; for example, ``'Python'`` could hash to
``-539294296`` while ``'python'``, a string that differs by a single bit, could hash
to ``1142331976``.  The hash code is then used to calculate a location in an
internal array where the value will be stored.  Assuming that you're storing
keys that all have different hash values, this means that dictionaries take
constant time -- *O*\ (1), in Big-O notation -- to retrieve a key.


Why must dictionary keys be immutable?
--------------------------------------

The hash table implementation of dictionaries uses a hash value calculated from
the key value to find the key.  If the key were a mutable object, its value
could change, and thus its hash could also change.  But since whoever changes
the key object can't tell that it was being used as a dictionary key, it can't
move the entry around in the dictionary.  Then, when you try to look up the same
object in the dictionary it won't be found because its hash value is different.
If you tried to look up the old value it wouldn't be found either, because the
value of the object found in that hash bin would be different.

If you want a dictionary indexed with a list, simply convert the list to a tuple
first; the function ``tuple(L)`` creates a tuple with the same entries as the
list ``L``.  Tuples are immutable and can therefore be used as dictionary keys.

Some unacceptable solutions that have been proposed:

- Hash lists by their address (object ID).  This doesn't work because if you
  construct a new list with the same value it won't be found; e.g.::

     mydict = {[1, 2]: '12'}
     print(mydict[[1, 2]])

  would raise a :exc:`KeyError` exception because the id of the ``[1, 2]`` used in the
  second line differs from that in the first line.  In other words, dictionary
  keys should be compared using ``==``, not using :keyword:`is`.

- Make a copy when using a list as a key.  This doesn't work because the list,
  being a mutable object, could contain a reference to itself, and then the
  copying code would run into an infinite loop.

- Allow lists as keys but tell the user not to modify them.  This would allow a
  class of hard-to-track bugs in programs when you forgot or modified a list by
  accident. It also invalidates an important invariant of dictionaries: every
  value in ``d.keys()`` is usable as a key of the dictionary.

- Mark lists as read-only once they are used as a dictionary key.  The problem
  is that it's not just the top-level object that could change its value; you
  could use a tuple containing a list as a key.  Entering anything as a key into
  a dictionary would require marking all objects reachable from there as
  read-only -- and again, self-referential objects could cause an infinite loop.

There is a trick to get around this if you need to, but use it at your own risk:
You can wrap a mutable structure inside a class instance which has both a
:meth:`~object.__eq__` and a :meth:`~object.__hash__` method.
You must then make sure that the
hash value for all such wrapper objects that reside in a dictionary (or other
hash based structure), remain fixed while the object is in the dictionary (or
other structure). ::

   class ListWrapper:
       def __init__(self, the_list):
           self.the_list = the_list

       def __eq__(self, other):
           return self.the_list == other.the_list

       def __hash__(self):
           l = self.the_list
           result = 98767 - len(l)*555
           for i, el in enumerate(l):
               try:
                   result = result + (hash(el) % 9999999) * 1001 + i
               except Exception:
                   result = (result % 7777777) + i * 333
           return result

Note that the hash computation is complicated by the possibility that some
members of the list may be unhashable and also by the possibility of arithmetic
overflow.

Furthermore it must always be the case that if ``o1 == o2`` (ie ``o1.__eq__(o2)
is True``) then ``hash(o1) == hash(o2)`` (ie, ``o1.__hash__() == o2.__hash__()``),
regardless of whether the object is in a dictionary or not.  If you fail to meet
these restrictions dictionaries and other hash based structures will misbehave.

In the case of :class:`!ListWrapper`, whenever the wrapper object is in a dictionary the
wrapped list must not change to avoid anomalies.  Don't do this unless you are
prepared to think hard about the requirements and the consequences of not
meeting them correctly.  Consider yourself warned.


Why doesn't list.sort() return the sorted list?
-----------------------------------------------

In situations where performance matters, making a copy of the list just to sort
it would be wasteful. Therefore, :meth:`list.sort` sorts the list in place. In
order to remind you of that fact, it does not return the sorted list.  This way,
you won't be fooled into accidentally overwriting a list when you need a sorted
copy but also need to keep the unsorted version around.

If you want to return a new list, use the built-in :func:`sorted` function
instead.  This function creates a new list from a provided iterable, sorts
it and returns it.  For example, here's how to iterate over the keys of a
dictionary in sorted order::

   for key in sorted(mydict):
       ...  # do whatever with mydict[key]...


How do you specify and enforce an interface spec in Python?
-----------------------------------------------------------

An interface specification for a module as provided by languages such as C++ and
Java describes the prototypes for the methods and functions of the module.  Many
feel that compile-time enforcement of interface specifications helps in the
construction of large programs.

Python 2.6 adds an :mod:`abc` module that lets you define Abstract Base Classes
(ABCs).  You can then use :func:`isinstance` and :func:`issubclass` to check
whether an instance or a class implements a particular ABC.  The
:mod:`collections.abc` module defines a set of useful ABCs such as
:class:`~collections.abc.Iterable`, :class:`~collections.abc.Container`, and
:class:`~collections.abc.MutableMapping`.

For Python, many of the advantages of interface specifications can be obtained
by an appropriate test discipline for components.

A good test suite for a module can both provide a regression test and serve as a
module interface specification and a set of examples.  Many Python modules can
be run as a script to provide a simple "self test."  Even modules which use
complex external interfaces can often be tested in isolation using trivial
"stub" emulations of the external interface.  The :mod:`doctest` and
:mod:`unittest` modules or third-party test frameworks can be used to construct
exhaustive test suites that exercise every line of code in a module.

An appropriate testing discipline can help build large complex applications in
Python as well as having interface specifications would.  In fact, it can be
better because an interface specification cannot test certain properties of a
program.  For example, the :meth:`!list.append` method is expected to add new elements
to the end of some internal list; an interface specification cannot test that
your :meth:`!list.append` implementation will actually do this correctly, but it's
trivial to check this property in a test suite.

Writing test suites is very helpful, and you might want to design your code to
make it easily tested. One increasingly popular technique, test-driven
development, calls for writing parts of the test suite first, before you write
any of the actual code.  Of course Python allows you to be sloppy and not write
test cases at all.


Why is there no goto?
---------------------

In the 1970s people realized that unrestricted goto could lead
to messy "spaghetti" code that was hard to understand and revise.
In a high-level language, it is also unneeded as long as there
are ways to branch (in Python, with :keyword:`if` statements and :keyword:`or`,
:keyword:`and`, and :keyword:`if`/:keyword:`else` expressions) and loop (with :keyword:`while`
and :keyword:`for` statements, possibly containing :keyword:`continue` and :keyword:`break`).

One can also use exceptions to provide a "structured goto"
that works even across
function calls.  Many feel that exceptions can conveniently emulate all
reasonable uses of the ``go`` or ``goto`` constructs of C, Fortran, and other
languages.  For example::

   class label(Exception): pass  # declare a label

   try:
       ...
       if condition: raise label()  # goto label
       ...
   except label:  # where to goto
       pass
   ...

This doesn't allow you to jump into the middle of a loop, but that's usually
considered an abuse of ``goto`` anyway.  Use sparingly.


Why can't raw strings (r-strings) end with a backslash?
-------------------------------------------------------

More precisely, they can't end with an odd number of backslashes: the unpaired
backslash at the end escapes the closing quote character, leaving an
unterminated string.

Raw strings were designed to ease creating input for processors (chiefly regular
expression engines) that want to do their own backslash escape processing. Such
processors consider an unmatched trailing backslash to be an error anyway, so
raw strings disallow that.  In return, they allow you to pass on the string
quote character by escaping it with a backslash.  These rules work well when
r-strings are used for their intended purpose.

If you're trying to build Windows pathnames, note that all Windows system calls
accept forward slashes too::

   f = open("/mydir/file.txt")  # works fine!

If you're trying to build a pathname for a DOS command, try e.g. one of ::

   dir = r"\this\is\my\dos\dir" "\\"
   dir = r"\this\is\my\dos\dir\ "[:-1]
   dir = "\\this\\is\\my\\dos\\dir\\"


Why doesn't Python have a "with" statement for attribute assignments?
---------------------------------------------------------------------

Python has a :keyword:`with` statement that wraps the execution of a block, calling code
on the entrance and exit from the block.  Some languages have a construct that
looks like this::

   with obj:
       a = 1               # equivalent to obj.a = 1
       total = total + 1   # obj.total = obj.total + 1

In Python, such a construct would be ambiguous.

Other languages, such as Object Pascal, Delphi, and C++, use static types, so
it's possible to know, in an unambiguous way, what member is being assigned
to. This is the main point of static typing -- the compiler *always* knows the
scope of every variable at compile time.

Python uses dynamic types. It is impossible to know in advance which attribute
will be referenced at runtime. Member attributes may be added or removed from
objects on the fly. This makes it impossible to know, from a simple reading,
what attribute is being referenced: a local one, a global one, or a member
attribute?

For instance, take the following incomplete snippet::

   def foo(a):
       with a:
           print(x)

The snippet assumes that ``a`` must have a member attribute called ``x``. However,
there is nothing in Python that tells the interpreter this. What should happen
if ``a`` is, let us say, an integer?  If there is a global variable named ``x``,
will it be used inside the :keyword:`with` block?  As you see, the dynamic nature of Python
makes such choices much harder.

The primary benefit of :keyword:`with` and similar language features (reduction of code
volume) can, however, easily be achieved in Python by assignment.  Instead of::

   function(args).mydict[index][index].a = 21
   function(args).mydict[index][index].b = 42
   function(args).mydict[index][index].c = 63

write this::

   ref = function(args).mydict[index][index]
   ref.a = 21
   ref.b = 42
   ref.c = 63

This also has the side-effect of increasing execution speed because name
bindings are resolved at run-time in Python, and the second version only needs
to perform the resolution once.

Similar proposals that would introduce syntax to further reduce code volume,
such as using a 'leading dot', have been rejected in favour of explicitness (see
https://mail.python.org/pipermail/python-ideas/2016-May/040070.html).


Why don't generators support the with statement?
------------------------------------------------

For technical reasons, a generator used directly as a context manager
would not work correctly.  When, as is most common, a generator is used as
an iterator run to completion, no closing is needed.  When it is, wrap
it as :func:`contextlib.closing(generator) <contextlib.closing>`
in the :keyword:`with` statement.


Why are colons required for the if/while/def/class statements?
--------------------------------------------------------------

The colon is required primarily to enhance readability (one of the results of
the experimental ABC language).  Consider this::

   if a == b
       print(a)

versus ::

   if a == b:
       print(a)

Notice how the second one is slightly easier to read.  Notice further how a
colon sets off the example in this FAQ answer; it's a standard usage in English.

Another minor reason is that the colon makes it easier for editors with syntax
highlighting; they can look for colons to decide when indentation needs to be
increased instead of having to do a more elaborate parsing of the program text.


Why does Python allow commas at the end of lists and tuples?
------------------------------------------------------------

Python lets you add a trailing comma at the end of lists, tuples, and
dictionaries::

   [1, 2, 3,]
   ('a', 'b', 'c',)
   d = {
       "A": [1, 5],
       "B": [6, 7],  # last trailing comma is optional but good style
   }


There are several reasons to allow this.

When you have a literal value for a list, tuple, or dictionary spread across
multiple lines, it's easier to add more elements because you don't have to
remember to add a comma to the previous line.  The lines can also be reordered
without creating a syntax error.

Accidentally omitting the comma can lead to errors that are hard to diagnose.
For example::

       x = [
         "fee",
         "fie"
         "foo",
         "fum"
       ]

This list looks like it has four elements, but it actually contains three:
"fee", "fiefoo" and "fum".  Always adding the comma avoids this source of error.

Allowing the trailing comma may also make programmatic code generation easier.


================================================
File: /Doc/faq/extending.rst
================================================
=======================
Extending/Embedding FAQ
=======================

.. only:: html

   .. contents::

.. highlight:: c


.. XXX need review for Python 3.


Can I create my own functions in C?
-----------------------------------

Yes, you can create built-in modules containing functions, variables, exceptions
and even new types in C.  This is explained in the document
:ref:`extending-index`.

Most intermediate or advanced Python books will also cover this topic.


Can I create my own functions in C++?
-------------------------------------

Yes, using the C compatibility features found in C++.  Place ``extern "C" {
... }`` around the Python include files and put ``extern "C"`` before each
function that is going to be called by the Python interpreter.  Global or static
C++ objects with constructors are probably not a good idea.


.. _c-wrapper-software:

Writing C is hard; are there any alternatives?
----------------------------------------------

There are a number of alternatives to writing your own C extensions, depending
on what you're trying to do.

.. XXX make sure these all work

`Cython <https://cython.org>`_ and its relative `Pyrex
<https://www.csse.canterbury.ac.nz/greg.ewing/python/Pyrex/>`_ are compilers
that accept a slightly modified form of Python and generate the corresponding
C code.  Cython and Pyrex make it possible to write an extension without having
to learn Python's C API.

If you need to interface to some C or C++ library for which no Python extension
currently exists, you can try wrapping the library's data types and functions
with a tool such as `SWIG <https://www.swig.org>`_.  `SIP
<https://github.com/Python-SIP/sip>`__, `CXX
<https://cxx.sourceforge.net/>`_ `Boost
<https://www.boost.org/libs/python/doc/index.html>`_, or `Weave
<https://github.com/scipy/weave>`_ are also
alternatives for wrapping C++ libraries.


How can I execute arbitrary Python statements from C?
-----------------------------------------------------

The highest-level function to do this is :c:func:`PyRun_SimpleString` which takes
a single string argument to be executed in the context of the module
``__main__`` and returns ``0`` for success and ``-1`` when an exception occurred
(including :exc:`SyntaxError`).  If you want more control, use
:c:func:`PyRun_String`; see the source for :c:func:`PyRun_SimpleString` in
``Python/pythonrun.c``.


How can I evaluate an arbitrary Python expression from C?
---------------------------------------------------------

Call the function :c:func:`PyRun_String` from the previous question with the
start symbol :c:data:`Py_eval_input`; it parses an expression, evaluates it and
returns its value.


How do I extract C values from a Python object?
-----------------------------------------------

That depends on the object's type.  If it's a tuple, :c:func:`PyTuple_Size`
returns its length and :c:func:`PyTuple_GetItem` returns the item at a specified
index.  Lists have similar functions, :c:func:`PyList_Size` and
:c:func:`PyList_GetItem`.

For bytes, :c:func:`PyBytes_Size` returns its length and
:c:func:`PyBytes_AsStringAndSize` provides a pointer to its value and its
length.  Note that Python bytes objects may contain null bytes so C's
:c:func:`!strlen` should not be used.

To test the type of an object, first make sure it isn't ``NULL``, and then use
:c:func:`PyBytes_Check`, :c:func:`PyTuple_Check`, :c:func:`PyList_Check`, etc.

There is also a high-level API to Python objects which is provided by the
so-called 'abstract' interface -- read ``Include/abstract.h`` for further
details.  It allows interfacing with any kind of Python sequence using calls
like :c:func:`PySequence_Length`, :c:func:`PySequence_GetItem`, etc. as well
as many other useful protocols such as numbers (:c:func:`PyNumber_Index` et
al.) and mappings in the PyMapping APIs.


How do I use Py_BuildValue() to create a tuple of arbitrary length?
-------------------------------------------------------------------

You can't.  Use :c:func:`PyTuple_Pack` instead.


How do I call an object's method from C?
----------------------------------------

The :c:func:`PyObject_CallMethod` function can be used to call an arbitrary
method of an object.  The parameters are the object, the name of the method to
call, a format string like that used with :c:func:`Py_BuildValue`, and the
argument values::

   PyObject *
   PyObject_CallMethod(PyObject *object, const char *method_name,
                       const char *arg_format, ...);

This works for any object that has methods -- whether built-in or user-defined.
You are responsible for eventually :c:func:`Py_DECREF`\ 'ing the return value.

To call, e.g., a file object's "seek" method with arguments 10, 0 (assuming the
file object pointer is "f")::

   res = PyObject_CallMethod(f, "seek", "(ii)", 10, 0);
   if (res == NULL) {
           ... an exception occurred ...
   }
   else {
           Py_DECREF(res);
   }

Note that since :c:func:`PyObject_CallObject` *always* wants a tuple for the
argument list, to call a function without arguments, pass "()" for the format,
and to call a function with one argument, surround the argument in parentheses,
e.g. "(i)".


How do I catch the output from PyErr_Print() (or anything that prints to stdout/stderr)?
----------------------------------------------------------------------------------------

In Python code, define an object that supports the ``write()`` method.  Assign
this object to :data:`sys.stdout` and :data:`sys.stderr`.  Call print_error, or
just allow the standard traceback mechanism to work. Then, the output will go
wherever your ``write()`` method sends it.

The easiest way to do this is to use the :class:`io.StringIO` class:

.. code-block:: pycon

   >>> import io, sys
   >>> sys.stdout = io.StringIO()
   >>> print('foo')
   >>> print('hello world!')
   >>> sys.stderr.write(sys.stdout.getvalue())
   foo
   hello world!

A custom object to do the same would look like this:

.. code-block:: pycon

   >>> import io, sys
   >>> class StdoutCatcher(io.TextIOBase):
   ...     def __init__(self):
   ...         self.data = []
   ...     def write(self, stuff):
   ...         self.data.append(stuff)
   ...
   >>> import sys
   >>> sys.stdout = StdoutCatcher()
   >>> print('foo')
   >>> print('hello world!')
   >>> sys.stderr.write(''.join(sys.stdout.data))
   foo
   hello world!


How do I access a module written in Python from C?
--------------------------------------------------

You can get a pointer to the module object as follows::

   module = PyImport_ImportModule("<modulename>");

If the module hasn't been imported yet (i.e. it is not yet present in
:data:`sys.modules`), this initializes the module; otherwise it simply returns
the value of ``sys.modules["<modulename>"]``.  Note that it doesn't enter the
module into any namespace -- it only ensures it has been initialized and is
stored in :data:`sys.modules`.

You can then access the module's attributes (i.e. any name defined in the
module) as follows::

   attr = PyObject_GetAttrString(module, "<attrname>");

Calling :c:func:`PyObject_SetAttrString` to assign to variables in the module
also works.


How do I interface to C++ objects from Python?
----------------------------------------------

Depending on your requirements, there are many approaches.  To do this manually,
begin by reading :ref:`the "Extending and Embedding" document
<extending-index>`.  Realize that for the Python run-time system, there isn't a
whole lot of difference between C and C++ -- so the strategy of building a new
Python type around a C structure (pointer) type will also work for C++ objects.

For C++ libraries, see :ref:`c-wrapper-software`.


I added a module using the Setup file and the make fails; why?
--------------------------------------------------------------

Setup must end in a newline, if there is no newline there, the build process
fails.  (Fixing this requires some ugly shell script hackery, and this bug is so
minor that it doesn't seem worth the effort.)


How do I debug an extension?
----------------------------

When using GDB with dynamically loaded extensions, you can't set a breakpoint in
your extension until your extension is loaded.

In your ``.gdbinit`` file (or interactively), add the command:

.. code-block:: none

   br _PyImport_LoadDynamicModule

Then, when you run GDB:

.. code-block:: shell-session

   $ gdb /local/bin/python
   gdb) run myscript.py
   gdb) continue # repeat until your extension is loaded
   gdb) finish   # so that your extension is loaded
   gdb) br myfunction.c:50
   gdb) continue

I want to compile a Python module on my Linux system, but some files are missing. Why?
--------------------------------------------------------------------------------------

Most packaged versions of Python omit some files
required for compiling Python extensions.

For Red Hat, install the python3-devel RPM to get the necessary files.

For Debian, run ``apt-get install python3-dev``.

How do I tell "incomplete input" from "invalid input"?
------------------------------------------------------

Sometimes you want to emulate the Python interactive interpreter's behavior,
where it gives you a continuation prompt when the input is incomplete (e.g. you
typed the start of an "if" statement or you didn't close your parentheses or
triple string quotes), but it gives you a syntax error message immediately when
the input is invalid.

In Python you can use the :mod:`codeop` module, which approximates the parser's
behavior sufficiently.  IDLE uses this, for example.

The easiest way to do it in C is to call :c:func:`PyRun_InteractiveLoop` (perhaps
in a separate thread) and let the Python interpreter handle the input for
you. You can also set the :c:func:`PyOS_ReadlineFunctionPointer` to point at your
custom input function. See ``Modules/readline.c`` and ``Parser/myreadline.c``
for more hints.

How do I find undefined g++ symbols __builtin_new or __pure_virtual?
--------------------------------------------------------------------

To dynamically load g++ extension modules, you must recompile Python, relink it
using g++ (change LINKCC in the Python Modules Makefile), and link your
extension module using g++ (e.g., ``g++ -shared -o mymodule.so mymodule.o``).


Can I create an object class with some methods implemented in C and others in Python (e.g. through inheritance)?
----------------------------------------------------------------------------------------------------------------

Yes, you can inherit from built-in classes such as :class:`int`, :class:`list`,
:class:`dict`, etc.

The Boost Python Library (BPL, https://www.boost.org/libs/python/doc/index.html)
provides a way of doing this from C++ (i.e. you can inherit from an extension
class written in C++ using the BPL).


================================================
File: /Doc/faq/general.rst
================================================
:tocdepth: 2

==================
General Python FAQ
==================

.. only:: html

   .. contents::


General Information
===================

What is Python?
---------------

Python is an interpreted, interactive, object-oriented programming language.  It
incorporates modules, exceptions, dynamic typing, very high level dynamic data
types, and classes.  It supports multiple programming paradigms beyond
object-oriented programming, such as procedural and functional programming.
Python combines remarkable power with very clear syntax. It has interfaces to
many system calls and libraries, as well as to various window systems, and is
extensible in C or C++.  It is also usable as an extension language for
applications that need a programmable interface. Finally, Python is portable:
it runs on many Unix variants including Linux and macOS, and on Windows.

To find out more, start with :ref:`tutorial-index`.  The `Beginner's Guide to
Python <https://wiki.python.org/moin/BeginnersGuide>`_ links to other
introductory tutorials and resources for learning Python.


What is the Python Software Foundation?
---------------------------------------

The Python Software Foundation is an independent non-profit organization that
holds the copyright on Python versions 2.1 and newer.  The PSF's mission is to
advance open source technology related to the Python programming language and to
publicize the use of Python.  The PSF's home page is at
https://www.python.org/psf/.

Donations to the PSF are tax-exempt in the US.  If you use Python and find it
helpful, please contribute via `the PSF donation page
<https://www.python.org/psf/donations/>`_.


Are there copyright restrictions on the use of Python?
------------------------------------------------------

You can do anything you want with the source, as long as you leave the
copyrights in and display those copyrights in any documentation about Python
that you produce.  If you honor the copyright rules, it's OK to use Python for
commercial use, to sell copies of Python in source or binary form (modified or
unmodified), or to sell products that incorporate Python in some form.  We would
still like to know about all commercial use of Python, of course.

See `the license page <https://docs.python.org/3/license.html>`_ to find further
explanations and the full text of the PSF License.

The Python logo is trademarked, and in certain cases permission is required to
use it.  Consult `the Trademark Usage Policy
<https://www.python.org/psf/trademarks/>`__ for more information.


Why was Python created in the first place?
------------------------------------------

Here's a *very* brief summary of what started it all, written by Guido van
Rossum:

   I had extensive experience with implementing an interpreted language in the
   ABC group at CWI, and from working with this group I had learned a lot about
   language design.  This is the origin of many Python features, including the
   use of indentation for statement grouping and the inclusion of
   very-high-level data types (although the details are all different in
   Python).

   I had a number of gripes about the ABC language, but also liked many of its
   features.  It was impossible to extend the ABC language (or its
   implementation) to remedy my complaints -- in fact its lack of extensibility
   was one of its biggest problems.  I had some experience with using Modula-2+
   and talked with the designers of Modula-3 and read the Modula-3 report.
   Modula-3 is the origin of the syntax and semantics used for exceptions, and
   some other Python features.

   I was working in the Amoeba distributed operating system group at CWI.  We
   needed a better way to do system administration than by writing either C
   programs or Bourne shell scripts, since Amoeba had its own system call
   interface which wasn't easily accessible from the Bourne shell.  My
   experience with error handling in Amoeba made me acutely aware of the
   importance of exceptions as a programming language feature.

   It occurred to me that a scripting language with a syntax like ABC but with
   access to the Amoeba system calls would fill the need.  I realized that it
   would be foolish to write an Amoeba-specific language, so I decided that I
   needed a language that was generally extensible.

   During the 1989 Christmas holidays, I had a lot of time on my hand, so I
   decided to give it a try.  During the next year, while still mostly working
   on it in my own time, Python was used in the Amoeba project with increasing
   success, and the feedback from colleagues made me add many early
   improvements.

   In February 1991, after just over a year of development, I decided to post to
   USENET.  The rest is in the ``Misc/HISTORY`` file.


What is Python good for?
------------------------

Python is a high-level general-purpose programming language that can be applied
to many different classes of problems.

The language comes with a large standard library that covers areas such as
string processing (regular expressions, Unicode, calculating differences between
files), internet protocols (HTTP, FTP, SMTP, XML-RPC, POP, IMAP),
software engineering (unit testing, logging, profiling, parsing
Python code), and operating system interfaces (system calls, filesystems, TCP/IP
sockets).  Look at the table of contents for :ref:`library-index` to get an idea
of what's available.  A wide variety of third-party extensions are also
available.  Consult `the Python Package Index <https://pypi.org>`_ to
find packages of interest to you.


.. _faq-version-numbering-scheme:

How does the Python version numbering scheme work?
--------------------------------------------------

Python versions are numbered "A.B.C" or "A.B":

* *A* is the major version number -- it is only incremented for really major
  changes in the language.
* *B* is the minor version number -- it is incremented for less earth-shattering
  changes.
* *C* is the micro version number -- it is incremented for each bugfix release.

Not all releases are bugfix releases.  In the run-up to a new feature release, a
series of development releases are made, denoted as alpha, beta, or release
candidate.  Alphas are early releases in which interfaces aren't yet finalized;
it's not unexpected to see an interface change between two alpha releases.
Betas are more stable, preserving existing interfaces but possibly adding new
modules, and release candidates are frozen, making no changes except as needed
to fix critical bugs.

Alpha, beta and release candidate versions have an additional suffix:

* The suffix for an alpha version is "aN" for some small number *N*.
* The suffix for a beta version is "bN" for some small number *N*.
* The suffix for a release candidate version is "rcN" for some small number *N*.

In other words, all versions labeled *2.0aN* precede the versions labeled
*2.0bN*, which precede versions labeled *2.0rcN*, and *those* precede 2.0.

You may also find version numbers with a "+" suffix, e.g. "2.2+".  These are
unreleased versions, built directly from the CPython development repository.  In
practice, after a final minor release is made, the version is incremented to the
next minor version, which becomes the "a0" version, e.g. "2.4a0".

See the `Developer's Guide
<https://devguide.python.org/developer-workflow/development-cycle/>`__
for more information about the development cycle, and
:pep:`387` to learn more about Python's backward compatibility policy.  See also
the documentation for :data:`sys.version`, :data:`sys.hexversion`, and
:data:`sys.version_info`.


How do I obtain a copy of the Python source?
--------------------------------------------

The latest Python source distribution is always available from python.org, at
https://www.python.org/downloads/.  The latest development sources can be obtained
at https://github.com/python/cpython/.

The source distribution is a gzipped tar file containing the complete C source,
Sphinx-formatted documentation, Python library modules, example programs, and
several useful pieces of freely distributable software.  The source will compile
and run out of the box on most UNIX platforms.

Consult the `Getting Started section of the Python Developer's Guide
<https://devguide.python.org/setup/>`__ for more
information on getting the source code and compiling it.


How do I get documentation on Python?
-------------------------------------

The standard documentation for the current stable version of Python is available
at https://docs.python.org/3/.  PDF, plain text, and downloadable HTML versions are
also available at https://docs.python.org/3/download.html.

The documentation is written in reStructuredText and processed by `the Sphinx
documentation tool <https://www.sphinx-doc.org/>`__.  The reStructuredText source for
the documentation is part of the Python source distribution.


I've never programmed before. Is there a Python tutorial?
---------------------------------------------------------

There are numerous tutorials and books available.  The standard documentation
includes :ref:`tutorial-index`.

Consult `the Beginner's Guide <https://wiki.python.org/moin/BeginnersGuide>`_ to
find information for beginning Python programmers, including lists of tutorials.


Is there a newsgroup or mailing list devoted to Python?
-------------------------------------------------------

There is a newsgroup, :newsgroup:`comp.lang.python`, and a mailing list,
`python-list <https://mail.python.org/mailman/listinfo/python-list>`_.  The
newsgroup and mailing list are gatewayed into each other -- if you can read news
it's unnecessary to subscribe to the mailing list.
:newsgroup:`comp.lang.python` is high-traffic, receiving hundreds of postings
every day, and Usenet readers are often more able to cope with this volume.

Announcements of new software releases and events can be found in
comp.lang.python.announce, a low-traffic moderated list that receives about five
postings per day.  It's available as `the python-announce mailing list
<https://mail.python.org/mailman3/lists/python-announce-list.python.org/>`_.

More info about other mailing lists and newsgroups
can be found at https://www.python.org/community/lists/.


How do I get a beta test version of Python?
-------------------------------------------

Alpha and beta releases are available from https://www.python.org/downloads/.  All
releases are announced on the comp.lang.python and comp.lang.python.announce
newsgroups and on the Python home page at https://www.python.org/; an RSS feed of
news is available.

You can also access the development version of Python through Git.  See
`The Python Developer's Guide <https://devguide.python.org/>`_ for details.


How do I submit bug reports and patches for Python?
---------------------------------------------------

To report a bug or submit a patch, use the issue tracker at
https://github.com/python/cpython/issues.

For more information on how Python is developed, consult `the Python Developer's
Guide <https://devguide.python.org/>`_.


Are there any published articles about Python that I can reference?
-------------------------------------------------------------------

It's probably best to cite your favorite book about Python.

The `very first article <https://ir.cwi.nl/pub/18204>`_ about Python was
written in 1991 and is now quite outdated.

    Guido van Rossum and Jelke de Boer, "Interactively Testing Remote Servers
    Using the Python Programming Language", CWI Quarterly, Volume 4, Issue 4
    (December 1991), Amsterdam, pp 283--303.


Are there any books on Python?
------------------------------

Yes, there are many, and more are being published.  See the python.org wiki at
https://wiki.python.org/moin/PythonBooks for a list.

You can also search online bookstores for "Python" and filter out the Monty
Python references; or perhaps search for "Python" and "language".


Where in the world is www.python.org located?
---------------------------------------------

The Python project's infrastructure is located all over the world and is managed
by the Python Infrastructure Team. Details `here <https://infra.psf.io>`__.


Why is it called Python?
------------------------

When he began implementing Python, Guido van Rossum was also reading the
published scripts from `"Monty Python's Flying Circus"
<https://en.wikipedia.org/wiki/Monty_Python>`__, a BBC comedy series from the 1970s.  Van Rossum
thought he needed a name that was short, unique, and slightly mysterious, so he
decided to call the language Python.


Do I have to like "Monty Python's Flying Circus"?
-------------------------------------------------

No, but it helps.  :)


Python in the real world
========================

How stable is Python?
---------------------

Very stable.  New, stable releases have been coming out roughly every 6 to 18
months since 1991, and this seems likely to continue.  As of version 3.9,
Python will have a new feature release every 12 months (:pep:`602`).

The developers issue bugfix releases of older versions, so the stability of
existing releases gradually improves.  Bugfix releases, indicated by a third
component of the version number (e.g. 3.5.3, 3.6.2), are managed for stability;
only fixes for known problems are included in a bugfix release, and it's
guaranteed that interfaces will remain the same throughout a series of bugfix
releases.

The latest stable releases can always be found on the `Python download page
<https://www.python.org/downloads/>`_.
Python 3.x is the recommended version and supported by most widely used libraries.
Python 2.x :pep:`is not maintained anymore <373>`.

How many people are using Python?
---------------------------------

There are probably millions of users, though it's difficult to obtain an exact
count.

Python is available for free download, so there are no sales figures, and it's
available from many different sites and packaged with many Linux distributions,
so download statistics don't tell the whole story either.

The comp.lang.python newsgroup is very active, but not all Python users post to
the group or even read it.


Have any significant projects been done in Python?
--------------------------------------------------

See https://www.python.org/about/success for a list of projects that use Python.
Consulting the proceedings for `past Python conferences
<https://www.python.org/community/workshops/>`_ will reveal contributions from many
different companies and organizations.

High-profile Python projects include `the Mailman mailing list manager
<https://www.list.org>`_ and `the Zope application server
<https://www.zope.dev>`_.  Several Linux distributions, most notably `Red Hat
<https://www.redhat.com>`_, have written part or all of their installer and
system administration software in Python.  Companies that use Python internally
include Google, Yahoo, and Lucasfilm Ltd.


What new developments are expected for Python in the future?
------------------------------------------------------------

See https://peps.python.org/ for the Python Enhancement Proposals
(PEPs). PEPs are design documents describing a suggested new feature for Python,
providing a concise technical specification and a rationale.  Look for a PEP
titled "Python X.Y Release Schedule", where X.Y is a version that hasn't been
publicly released yet.

New development is discussed on `the python-dev mailing list
<https://mail.python.org/mailman3/lists/python-dev.python.org/>`_.


Is it reasonable to propose incompatible changes to Python?
-----------------------------------------------------------

In general, no.  There are already millions of lines of Python code around the
world, so any change in the language that invalidates more than a very small
fraction of existing programs has to be frowned upon.  Even if you can provide a
conversion program, there's still the problem of updating all documentation;
many books have been written about Python, and we don't want to invalidate them
all at a single stroke.

Providing a gradual upgrade path is necessary if a feature has to be changed.
:pep:`5` describes the procedure followed for introducing backward-incompatible
changes while minimizing disruption for users.


Is Python a good language for beginning programmers?
----------------------------------------------------

Yes.

It is still common to start students with a procedural and statically typed
language such as Pascal, C, or a subset of C++ or Java.  Students may be better
served by learning Python as their first language.  Python has a very simple and
consistent syntax and a large standard library and, most importantly, using
Python in a beginning programming course lets students concentrate on important
programming skills such as problem decomposition and data type design.  With
Python, students can be quickly introduced to basic concepts such as loops and
procedures.  They can probably even work with user-defined objects in their very
first course.

For a student who has never programmed before, using a statically typed language
seems unnatural.  It presents additional complexity that the student must master
and slows the pace of the course.  The students are trying to learn to think
like a computer, decompose problems, design consistent interfaces, and
encapsulate data.  While learning to use a statically typed language is
important in the long term, it is not necessarily the best topic to address in
the students' first programming course.

Many other aspects of Python make it a good first language.  Like Java, Python
has a large standard library so that students can be assigned programming
projects very early in the course that *do* something.  Assignments aren't
restricted to the standard four-function calculator and check balancing
programs.  By using the standard library, students can gain the satisfaction of
working on realistic applications as they learn the fundamentals of programming.
Using the standard library also teaches students about code reuse.  Third-party
modules such as PyGame are also helpful in extending the students' reach.

Python's interactive interpreter enables students to test language features
while they're programming.  They can keep a window with the interpreter running
while they enter their program's source in another window.  If they can't
remember the methods for a list, they can do something like this::

   >>> L = []
   >>> dir(L) # doctest: +NORMALIZE_WHITESPACE
   ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',
   '__dir__', '__doc__', '__eq__', '__format__', '__ge__',
   '__getattribute__', '__getitem__', '__gt__', '__hash__', '__iadd__',
   '__imul__', '__init__', '__iter__', '__le__', '__len__', '__lt__',
   '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__',
   '__repr__', '__reversed__', '__rmul__', '__setattr__', '__setitem__',
   '__sizeof__', '__str__', '__subclasshook__', 'append', 'clear',
   'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove',
   'reverse', 'sort']
   >>> [d for d in dir(L) if '__' not in d]
   ['append', 'clear', 'copy', 'count', 'extend', 'index', 'insert', 'pop', 'remove', 'reverse', 'sort']

   >>> help(L.append)
   Help on built-in function append:
   <BLANKLINE>
   append(...)
       L.append(object) -> None -- append object to end
   <BLANKLINE>
   >>> L.append(1)
   >>> L
   [1]

With the interpreter, documentation is never far from the student as they are
programming.

There are also good IDEs for Python.  IDLE is a cross-platform IDE for Python
that is written in Python using Tkinter.
Emacs users will be happy to know that there is a very good Python mode for
Emacs.  All of these programming environments provide syntax highlighting,
auto-indenting, and access to the interactive interpreter while coding.  Consult
`the Python wiki <https://wiki.python.org/moin/PythonEditors>`_ for a full list
of Python editing environments.

If you want to discuss Python's use in education, you may be interested in
joining `the edu-sig mailing list
<https://www.python.org/community/sigs/current/edu-sig>`_.


================================================
File: /Doc/faq/gui.rst
================================================
:tocdepth: 2

==========================
Graphic User Interface FAQ
==========================

.. only:: html

   .. contents::

.. XXX need review for Python 3.


General GUI Questions
=====================

What GUI toolkits exist for Python?
===================================

Standard builds of Python include an object-oriented interface to the Tcl/Tk
widget set, called :ref:`tkinter <Tkinter>`.  This is probably the easiest to
install (since it comes included with most
`binary distributions <https://www.python.org/downloads/>`_ of Python) and use.
For more info about Tk, including pointers to the source, see the
`Tcl/Tk home page <https://www.tcl.tk>`_.  Tcl/Tk is fully portable to the
macOS, Windows, and Unix platforms.

Depending on what platform(s) you are aiming at, there are also several
alternatives. A `list of cross-platform
<https://wiki.python.org/moin/GuiProgramming#Cross-Platform_Frameworks>`_ and
`platform-specific
<https://wiki.python.org/moin/GuiProgramming#Platform-specific_Frameworks>`_ GUI
frameworks can be found on the python wiki.

Tkinter questions
=================

How do I freeze Tkinter applications?
-------------------------------------

Freeze is a tool to create stand-alone applications.  When freezing Tkinter
applications, the applications will not be truly stand-alone, as the application
will still need the Tcl and Tk libraries.

One solution is to ship the application with the Tcl and Tk libraries, and point
to them at run-time using the :envvar:`!TCL_LIBRARY` and :envvar:`!TK_LIBRARY`
environment variables.

Various third-party freeze libraries such as py2exe and cx_Freeze have
handling for Tkinter applications built-in.


Can I have Tk events handled while waiting for I/O?
---------------------------------------------------

On platforms other than Windows, yes, and you don't even
need threads!  But you'll have to restructure your I/O
code a bit.  Tk has the equivalent of Xt's :c:func:`!XtAddInput` call, which allows you
to register a callback function which will be called from the Tk mainloop when
I/O is possible on a file descriptor.  See :ref:`tkinter-file-handlers`.


I can't get key bindings to work in Tkinter: why?
-------------------------------------------------

An often-heard complaint is that event handlers :ref:`bound <bindings-and-events>`
to events with the :meth:`!bind` method
don't get handled even when the appropriate key is pressed.

The most common cause is that the widget to which the binding applies doesn't
have "keyboard focus".  Check out the Tk documentation for the focus command.
Usually a widget is given the keyboard focus by clicking in it (but not for
labels; see the takefocus option).


================================================
File: /Doc/faq/index.rst
================================================
.. _faq-index:

###################################
  Python Frequently Asked Questions
###################################

.. toctree::
   :maxdepth: 1

   general.rst
   programming.rst
   design.rst
   library.rst
   extending.rst
   windows.rst
   gui.rst
   installed.rst


================================================
File: /Doc/faq/installed.rst
================================================
=============================================
"Why is Python Installed on my Computer?" FAQ
=============================================

What is Python?
---------------

Python is a programming language.  It's used for many different applications.
It's used in some high schools and colleges as an introductory programming
language because Python is easy to learn, but it's also used by professional
software developers at places such as Google, NASA, and Lucasfilm Ltd.

If you wish to learn more about Python, start with the `Beginner's Guide to
Python <https://wiki.python.org/moin/BeginnersGuide>`_.


Why is Python installed on my machine?
--------------------------------------

If you find Python installed on your system but don't remember installing it,
there are several possible ways it could have gotten there.

* Perhaps another user on the computer wanted to learn programming and installed
  it; you'll have to figure out who's been using the machine and might have
  installed it.
* A third-party application installed on the machine might have been written in
  Python and included a Python installation.  There are many such applications,
  from GUI programs to network servers and administrative scripts.
* Some Windows machines also have Python installed.  At this writing we're aware
  of computers from Hewlett-Packard and Compaq that include Python.  Apparently
  some of HP/Compaq's administrative tools are written in Python.
* Many Unix-compatible operating systems, such as macOS and some Linux
  distributions, have Python installed by default; it's included in the base
  installation.


Can I delete Python?
--------------------

That depends on where Python came from.

If someone installed it deliberately, you can remove it without hurting
anything.  On Windows, use the Add/Remove Programs icon in the Control Panel.

If Python was installed by a third-party application, you can also remove it,
but that application will no longer work.  You should use that application's
uninstaller rather than removing Python directly.

If Python came with your operating system, removing it is not recommended.  If
you remove it, whatever tools were written in Python will no longer run, and
some of them might be important to you.  Reinstalling the whole system would
then be required to fix things again.



================================================
File: /Doc/faq/library.rst
================================================
:tocdepth: 2

=========================
Library and Extension FAQ
=========================

.. only:: html

   .. contents::

General Library Questions
=========================

How do I find a module or application to perform task X?
--------------------------------------------------------

Check :ref:`the Library Reference <library-index>` to see if there's a relevant
standard library module.  (Eventually you'll learn what's in the standard
library and will be able to skip this step.)

For third-party packages, search the `Python Package Index
<https://pypi.org>`_ or try `Google <https://www.google.com>`_ or
another web search engine.  Searching for "Python" plus a keyword or two for
your topic of interest will usually find something helpful.


Where is the math.py (socket.py, regex.py, etc.) source file?
-------------------------------------------------------------

If you can't find a source file for a module it may be a built-in or
dynamically loaded module implemented in C, C++ or other compiled language.
In this case you may not have the source file or it may be something like
:file:`mathmodule.c`, somewhere in a C source directory (not on the Python Path).

There are (at least) three kinds of modules in Python:

1) modules written in Python (.py);
2) modules written in C and dynamically loaded (.dll, .pyd, .so, .sl, etc);
3) modules written in C and linked with the interpreter; to get a list of these,
   type::

      import sys
      print(sys.builtin_module_names)


How do I make a Python script executable on Unix?
-------------------------------------------------

You need to do two things: the script file's mode must be executable and the
first line must begin with ``#!`` followed by the path of the Python
interpreter.

The first is done by executing ``chmod +x scriptfile`` or perhaps ``chmod 755
scriptfile``.

The second can be done in a number of ways.  The most straightforward way is to
write ::

  #!/usr/local/bin/python

as the very first line of your file, using the pathname for where the Python
interpreter is installed on your platform.

If you would like the script to be independent of where the Python interpreter
lives, you can use the :program:`env` program.  Almost all Unix variants support
the following, assuming the Python interpreter is in a directory on the user's
:envvar:`PATH`::

  #!/usr/bin/env python

*Don't* do this for CGI scripts.  The :envvar:`PATH` variable for CGI scripts is
often very minimal, so you need to use the actual absolute pathname of the
interpreter.

Occasionally, a user's environment is so full that the :program:`/usr/bin/env`
program fails; or there's no env program at all.  In that case, you can try the
following hack (due to Alex Rezinsky):

.. code-block:: sh

   #! /bin/sh
   """:"
   exec python $0 ${1+"$@"}
   """

The minor disadvantage is that this defines the script's __doc__ string.
However, you can fix that by adding ::

   __doc__ = """...Whatever..."""



Is there a curses/termcap package for Python?
---------------------------------------------

.. XXX curses *is* built by default, isn't it?

For Unix variants: The standard Python source distribution comes with a curses
