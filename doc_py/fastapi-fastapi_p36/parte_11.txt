Se soportan todas las mismas opciones.

Todos los mismos `parameters`, `responses`, `dependencies`, `tags`, etc.

/// tip | Consejo

En este ejemplo, la variable se llama `router`, pero puedes nombrarla como quieras.

///

Vamos a incluir este `APIRouter` en la aplicaci√≥n principal de `FastAPI`, pero primero, revisemos las dependencias y otro `APIRouter`.

## Dependencias

Vemos que vamos a necesitar algunas dependencias usadas en varios lugares de la aplicaci√≥n.

As√≠ que las ponemos en su propio m√≥dulo `dependencies` (`app/dependencies.py`).

Ahora utilizaremos una dependencia simple para leer un encabezado `X-Token` personalizado:

//// tab | Python 3.9+

```Python hl_lines="3  6-8" title="app/dependencies.py"
{!> ../../docs_src/bigger_applications/app_an_py39/dependencies.py!}
```

////

//// tab | Python 3.8+

```Python hl_lines="1  5-7" title="app/dependencies.py"
{!> ../../docs_src/bigger_applications/app_an/dependencies.py!}
```

////

//// tab | Python 3.8+ non-Annotated

/// tip | Consejo

Preferiblemente usa la versi√≥n `Annotated` si es posible.

///

```Python hl_lines="1  4-6" title="app/dependencies.py"
{!> ../../docs_src/bigger_applications/app/dependencies.py!}
```

////

/// tip | Consejo

Estamos usando un encabezado inventado para simplificar este ejemplo.

Pero en casos reales obtendr√°s mejores resultados usando las [utilidades de Seguridad](security/index.md){.internal-link target=_blank} integradas.

///

## Otro m√≥dulo con `APIRouter`

Digamos que tambi√©n tienes los endpoints dedicados a manejar "items" de tu aplicaci√≥n en el m√≥dulo `app/routers/items.py`.

Tienes *path operations* para:

* `/items/`
* `/items/{item_id}`

Es toda la misma estructura que con `app/routers/users.py`.

Pero queremos ser m√°s inteligentes y simplificar un poco el c√≥digo.

Sabemos que todas las *path operations* en este m√≥dulo tienen el mismo:

* Prefijo de path: `/items`.
* `tags`: (solo una etiqueta: `items`).
* `responses` extra.
* `dependencies`: todas necesitan esa dependencia `X-Token` que creamos.

Entonces, en lugar de agregar todo eso a cada *path operation*, podemos agregarlo al `APIRouter`.

```Python hl_lines="5-10  16  21" title="app/routers/items.py"
{!../../docs_src/bigger_applications/app/routers/items.py!}
```

Como el path de cada *path operation* tiene que empezar con `/`, como en:

```Python hl_lines="1"
@router.get("/{item_id}")
async def read_item(item_id: str):
    ...
```

...el prefijo no debe incluir un `/` final.

As√≠ que, el prefijo en este caso es `/items`.

Tambi√©n podemos agregar una lista de `tags` y `responses` extra que se aplicar√°n a todas las *path operations* incluidas en este router.

Y podemos agregar una lista de `dependencies` que se a√±adir√° a todas las *path operations* en el router y se ejecutar√°n/solucionar√°n por cada request que les haga.

/// tip | Consejo

Nota que, al igual que [dependencias en decoradores de *path operations*](dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank}, ning√∫n valor ser√° pasado a tu *path operation function*.

///

El resultado final es que los paths de item son ahora:

* `/items/`
* `/items/{item_id}`

...como pretend√≠amos.

* Ser√°n marcados con una lista de tags que contiene un solo string `"items"`.
  * Estos "tags" son especialmente √∫tiles para los sistemas de documentaci√≥n interactiva autom√°tica (usando OpenAPI).
* Todos incluir√°n las `responses` predefinidas.
* Todas estas *path operations* tendr√°n la lista de `dependencies` evaluadas/ejecutadas antes de ellas.
  * Si tambi√©n declaras dependencias en una *path operation* espec√≠fica, **tambi√©n se ejecutar√°n**.
  * Las dependencias del router se ejecutan primero, luego las [dependencias en el decorador](dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank}, y luego las dependencias de par√°metros normales.
  * Tambi√©n puedes agregar [dependencias de `Security` con `scopes`](../advanced/security/oauth2-scopes.md){.internal-link target=_blank}.

/// tip | Consejo

Tener `dependencies` en el `APIRouter` puede ser usado, por ejemplo, para requerir autenticaci√≥n para un grupo completo de *path operations*. Incluso si las dependencias no son a√±adidas individualmente a cada una de ellas.

///

/// check | Revisa

Los par√°metros `prefix`, `tags`, `responses`, y `dependencies` son (como en muchos otros casos) solo una funcionalidad de **FastAPI** para ayudarte a evitar la duplicaci√≥n de c√≥digo.

///

### Importar las dependencias

Este c√≥digo vive en el m√≥dulo `app.routers.items`, el archivo `app/routers/items.py`.

Y necesitamos obtener la funci√≥n de dependencia del m√≥dulo `app.dependencies`, el archivo `app/dependencies.py`.

As√≠ que usamos un import relativo con `..` para las dependencias:

```Python hl_lines="3" title="app/routers/items.py"
{!../../docs_src/bigger_applications/app/routers/items.py!}
```

#### C√≥mo funcionan los imports relativos

/// tip | Consejo

Si sabes perfectamente c√≥mo funcionan los imports, contin√∫a a la siguiente secci√≥n.

///

Un solo punto `.`, como en:

```Python
from .dependencies import get_token_header
```

significar√≠a:

* Partiendo en el mismo paquete en el que este m√≥dulo (el archivo `app/routers/items.py`) habita (el directorio `app/routers/`)...
* busca el m√≥dulo `dependencies` (un archivo imaginario en `app/routers/dependencies.py`)...
* y de √©l, importa la funci√≥n `get_token_header`.

Pero ese archivo no existe, nuestras dependencias est√°n en un archivo en `app/dependencies.py`.

Recuerda c√≥mo se ve nuestra estructura de aplicaci√≥n/archivo:

<img src="/img/tutorial/bigger-applications/package.svg">

---

Los dos puntos `..`, como en:

```Python
from ..dependencies import get_token_header
```

significan:

* Partiendo en el mismo paquete en el que este m√≥dulo (el archivo `app/routers/items.py`) habita (el directorio `app/routers/`)...
* ve al paquete padre (el directorio `app/`)...
* y all√≠, busca el m√≥dulo `dependencies` (el archivo en `app/dependencies.py`)...
* y de √©l, importa la funci√≥n `get_token_header`.

¬°Eso funciona correctamente! üéâ

---

De la misma manera, si hubi√©ramos usado tres puntos `...`, como en:

```Python
from ...dependencies import get_token_header
```

eso significar√≠a:

* Partiendo en el mismo paquete en el que este m√≥dulo (el archivo `app/routers/items.py`) habita (el directorio `app/routers/`)...
* ve al paquete padre (el directorio `app/`)...
* luego ve al paquete padre de ese paquete (no hay paquete padre, `app` es el nivel superior üò±)...
* y all√≠, busca el m√≥dulo `dependencies` (el archivo en `app/dependencies.py`)...
* y de √©l, importa la funci√≥n `get_token_header`.

Eso se referir√≠a a alg√∫n paquete arriba de `app/`, con su propio archivo `__init__.py`, etc. Pero no tenemos eso. As√≠ que, eso lanzar√≠a un error en nuestro ejemplo. üö®

Pero ahora sabes c√≥mo funciona, para que puedas usar imports relativos en tus propias aplicaciones sin importar cu√°n complejas sean. ü§ì

### Agregar algunos `tags`, `responses`, y `dependencies` personalizados

No estamos agregando el prefijo `/items` ni los `tags=["items"]` a cada *path operation* porque los hemos a√±adido al `APIRouter`.

Pero a√∫n podemos agregar _m√°s_ `tags` que se aplicar√°n a una *path operation* espec√≠fica, y tambi√©n algunas `responses` extra espec√≠ficas para esa *path operation*:

```Python hl_lines="30-31" title="app/routers/items.py"
{!../../docs_src/bigger_applications/app/routers/items.py!}
```

/// tip | Consejo

Esta √∫ltima *path operation* tendr√° la combinaci√≥n de tags: `["items", "custom"]`.

Y tambi√©n tendr√° ambas responses en la documentaci√≥n, una para `404` y otra para `403`.

///

## El `FastAPI` principal

Ahora, veamos el m√≥dulo en `app/main.py`.

Aqu√≠ es donde importas y usas la clase `FastAPI`.

Este ser√° el archivo principal en tu aplicaci√≥n que conecta todo.

### Importar `FastAPI`

Importas y creas una clase `FastAPI` como de costumbre.

Y podemos incluso declarar [dependencias globales](dependencies/global-dependencies.md){.internal-link target=_blank} que se combinar√°n con las dependencias para cada `APIRouter`:

```Python hl_lines="1  3  7" title="app/main.py"
{!../../docs_src/bigger_applications/app/main.py!}
```

### Importar el `APIRouter`

Ahora importamos los otros subm√≥dulos que tienen `APIRouter`s:

```Python hl_lines="4-5" title="app/main.py"
{!../../docs_src/bigger_applications/app/main.py!}
```

Como los archivos `app/routers/users.py` y `app/routers/items.py` son subm√≥dulos que son parte del mismo paquete de Python `app`, podemos usar un solo punto `.` para importarlos usando "imports relativos".

### C√≥mo funciona la importaci√≥n

La secci√≥n:

```Python
from .routers import items, users
```

significa:

* Partiendo en el mismo paquete en el que este m√≥dulo (el archivo `app/main.py`) habita (el directorio `app/`)...
* busca el subpaquete `routers` (el directorio en `app/routers/`)...
* y de √©l, importa el subm√≥dulo `items` (el archivo en `app/routers/items.py`) y `users` (el archivo en `app/routers/users.py`)...

El m√≥dulo `items` tendr√° una variable `router` (`items.router`). Este es el mismo que creamos en el archivo `app/routers/items.py`, es un objeto `APIRouter`.

Y luego hacemos lo mismo para el m√≥dulo `users`.

Tambi√©n podr√≠amos importarlos as√≠:

```Python
from app.routers import items, users
```

/// info | Informaci√≥n

La primera versi√≥n es un "import relativo":

```Python
from .routers import items, users
```

La segunda versi√≥n es un "import absoluto":

```Python
from app.routers import items, users
```

Para aprender m√°s sobre Paquetes y M√≥dulos de Python, lee <a href="https://docs.python.org/3/tutorial/modules.html" class="external-link" target="_blank">la documentaci√≥n oficial de Python sobre M√≥dulos</a>.

///

### Evitar colisiones de nombres

Estamos importando el subm√≥dulo `items` directamente, en lugar de importar solo su variable `router`.

Esto se debe a que tambi√©n tenemos otra variable llamada `router` en el subm√≥dulo `users`.

Si hubi√©ramos importado uno despu√©s del otro, como:

```Python
from .routers.items import router
from .routers.users import router
```

el `router` de `users` sobrescribir√≠a el de `items` y no podr√≠amos usarlos al mismo tiempo.

As√≠ que, para poder usar ambos en el mismo archivo, importamos los subm√≥dulos directamente:

```Python hl_lines="5" title="app/main.py"
{!../../docs_src/bigger_applications/app/main.py!}
```

### Incluir los `APIRouter`s para `users` y `items`

Ahora, incluyamos los `router`s de los subm√≥dulos `users` y `items`:

```Python hl_lines="10-11" title="app/main.py"
{!../../docs_src/bigger_applications/app/main.py!}
```

/// info | Informaci√≥n

`users.router` contiene el `APIRouter` dentro del archivo `app/routers/users.py`.

Y `items.router` contiene el `APIRouter` dentro del archivo `app/routers/items.py`.

///

Con `app.include_router()` podemos agregar cada `APIRouter` a la aplicaci√≥n principal de `FastAPI`.

Incluir√° todas las rutas de ese router como parte de ella.

/// note | Detalles T√©cnicos

En realidad crear√° internamente una *path operation* para cada *path operation* que fue declarada en el `APIRouter`.

As√≠, detr√°s de escena, funcionar√° como si todo fuera la misma √∫nica aplicaci√≥n.

///

/// check | Revisa

No tienes que preocuparte por el rendimiento al incluir routers.

Esto tomar√° microsegundos y solo suceder√° al inicio.

As√≠ que no afectar√° el rendimiento. ‚ö°

///

### Incluir un `APIRouter` con un `prefix`, `tags`, `responses`, y `dependencies` personalizados

Ahora, imaginemos que tu organizaci√≥n te dio el archivo `app/internal/admin.py`.

Contiene un `APIRouter` con algunas *path operations* de administraci√≥n que tu organizaci√≥n comparte entre varios proyectos.

Para este ejemplo ser√° s√∫per simple. Pero digamos que porque est√° compartido con otros proyectos en la organizaci√≥n, no podemos modificarlo y agregar un `prefix`, `dependencies`, `tags`, etc. directamente al `APIRouter`:

```Python hl_lines="3" title="app/internal/admin.py"
{!../../docs_src/bigger_applications/app/internal/admin.py!}
```

Pero a√∫n queremos configurar un `prefix` personalizado al incluir el `APIRouter` para que todas sus *path operations* comiencen con `/admin`, queremos asegurarlo con las `dependencies` que ya tenemos para este proyecto, y queremos incluir `tags` y `responses`.

Podemos declarar todo eso sin tener que modificar el `APIRouter` original pasando esos par√°metros a `app.include_router()`:

```Python hl_lines="14-17" title="app/main.py"
{!../../docs_src/bigger_applications/app/main.py!}
```

De esa manera, el `APIRouter` original permanecer√° sin modificar, por lo que a√∫n podemos compartir ese mismo archivo `app/internal/admin.py` con otros proyectos en la organizaci√≥n.

El resultado es que, en nuestra aplicaci√≥n, cada una de las *path operations* del m√≥dulo `admin` tendr√°:

* El prefix `/admin`.
* El tag `admin`.
* La dependencia `get_token_header`.
* La response `418`. üçµ

Pero eso solo afectar√° a ese `APIRouter` en nuestra aplicaci√≥n, no en ning√∫n otro c√≥digo que lo utilice.

As√≠, por ejemplo, otros proyectos podr√≠an usar el mismo `APIRouter` con un m√©todo de autenticaci√≥n diferente.

### Incluir una *path operation*

Tambi√©n podemos agregar *path operations* directamente a la aplicaci√≥n de `FastAPI`.

Aqu√≠ lo hacemos... solo para mostrar que podemos ü§∑:

```Python hl_lines="21-23" title="app/main.py"
{!../../docs_src/bigger_applications/app/main.py!}
```

y funcionar√° correctamente, junto con todas las otras *path operations* a√±adidas con `app.include_router()`.

/// info | Detalles Muy T√©cnicos

**Nota**: este es un detalle muy t√©cnico que probablemente puedes **simplemente omitir**.

---

Los `APIRouter`s no est√°n "montados", no est√°n aislados del resto de la aplicaci√≥n.

Esto se debe a que queremos incluir sus *path operations* en el esquema de OpenAPI y las interfaces de usuario.

Como no podemos simplemente aislarlos y "montarlos" independientemente del resto, se "clonan" las *path operations* (se vuelven a crear), no se incluyen directamente.

///

## Revisa la documentaci√≥n autom√°tica de la API

Ahora, ejecuta tu aplicaci√≥n:

<div class="termy">

```console
$ fastapi dev app/main.py

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

Y abre la documentaci√≥n en <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

Ver√°s la documentaci√≥n autom√°tica de la API, incluyendo los paths de todos los subm√≥dulos, usando los paths correctos (y prefijos) y las tags correctas:

<img src="/img/tutorial/bigger-applications/image01.png">

## Incluir el mismo router m√∫ltiples veces con diferentes `prefix`

Tambi√©n puedes usar `.include_router()` m√∫ltiples veces con el *mismo* router usando diferentes prefijos.

Esto podr√≠a ser √∫til, por ejemplo, para exponer la misma API bajo diferentes prefijos, por ejemplo, `/api/v1` y `/api/latest`.

Este es un uso avanzado que quiz√°s no necesites realmente, pero est√° all√≠ en caso de que lo necesites.

## Incluir un `APIRouter` en otro

De la misma manera que puedes incluir un `APIRouter` en una aplicaci√≥n `FastAPI`, puedes incluir un `APIRouter` en otro `APIRouter` usando:

```Python
router.include_router(other_router)
```

Aseg√∫rate de hacerlo antes de incluir `router` en la aplicaci√≥n de `FastAPI`, para que las *path operations* de `other_router` tambi√©n se incluyan.


================================================
File: /docs/es/docs/tutorial/body-fields.md
================================================
# Body - Campos

De la misma manera que puedes declarar validaciones adicionales y metadatos en los par√°metros de las *path operation function* con `Query`, `Path` y `Body`, puedes declarar validaciones y metadatos dentro de los modelos de Pydantic usando `Field` de Pydantic.

## Importar `Field`

Primero, tienes que importarlo:

{* ../../docs_src/body_fields/tutorial001_an_py310.py hl[4] *}

/// warning | Advertencia

F√≠jate que `Field` se importa directamente desde `pydantic`, no desde `fastapi` como el resto (`Query`, `Path`, `Body`, etc).

///

## Declarar atributos del modelo

Despu√©s puedes utilizar `Field` con los atributos del modelo:

{* ../../docs_src/body_fields/tutorial001_an_py310.py hl[11:14] *}

`Field` funciona de la misma manera que `Query`, `Path` y `Body`, tiene todos los mismos par√°metros, etc.

/// note | Detalles t√©cnicos

En realidad, `Query`, `Path` y otros que ver√°s a continuaci√≥n crean objetos de subclases de una clase com√∫n `Param`, que es a su vez una subclase de la clase `FieldInfo` de Pydantic.

Y `Field` de Pydantic tambi√©n regresa una instance de `FieldInfo`.

`Body` tambi√©n devuelve objetos de una subclase de `FieldInfo` directamente. Y hay otros que ver√°s m√°s adelante que son subclases de la clase `Body`.

Recuerda que cuando importas `Query`, `Path`, y otros desde `fastapi`, en realidad son funciones que devuelven clases especiales.

///

/// tip | Consejo

Observa c√≥mo cada atributo del modelo con un tipo, un valor por defecto y `Field` tiene la misma estructura que un par√°metro de una *path operation function*, con `Field` en lugar de `Path`, `Query` y `Body`.

///

## Agregar informaci√≥n extra

Puedes declarar informaci√≥n extra en `Field`, `Query`, `Body`, etc. Y ser√° incluida en el JSON Schema generado.

Aprender√°s m√°s sobre c√≥mo agregar informaci√≥n extra m√°s adelante en la documentaci√≥n, cuando aprendamos a declarar ejemplos.

/// warning | Advertencia

Las claves extra pasadas a `Field` tambi√©n estar√°n presentes en el esquema de OpenAPI resultante para tu aplicaci√≥n.
Como estas claves no necesariamente tienen que ser parte de la especificaci√≥n de OpenAPI, algunas herramientas de OpenAPI, por ejemplo [el validador de OpenAPI](https://validator.swagger.io/), podr√≠an no funcionar con tu esquema generado.

///

## Resumen

Puedes utilizar `Field` de Pydantic para declarar validaciones adicionales y metadatos para los atributos del modelo.

Tambi√©n puedes usar los argumentos de palabra clave extra para pasar metadatos adicionales del JSON Schema.


================================================
File: /docs/es/docs/tutorial/body-multiple-params.md
================================================
# Cuerpo - M√∫ltiples Par√°metros

Ahora que hemos visto c√≥mo usar `Path` y `Query`, veamos usos m√°s avanzados de las declaraciones del request body.

## Mezclar `Path`, `Query` y par√°metros del cuerpo

Primero, por supuesto, puedes mezclar las declaraciones de par√°metros de `Path`, `Query` y del request body libremente y **FastAPI** sabr√° qu√© hacer.

Y tambi√©n puedes declarar par√°metros del cuerpo como opcionales, estableciendo el valor predeterminado a `None`:

{* ../../docs_src/body_multiple_params/tutorial001_an_py310.py hl[18:20] *}

## M√∫ltiples par√°metros del cuerpo

/// note | Nota

Ten en cuenta que, en este caso, el `item` que se tomar√≠a del cuerpo es opcional. Ya que tiene un valor por defecto de `None`.

///

## M√∫ltiples par√°metros del cuerpo

En el ejemplo anterior, las *path operations* esperar√≠an un cuerpo JSON con los atributos de un `Item`, como:

```JSON
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2
}
```

Pero tambi√©n puedes declarar m√∫ltiples par√°metros del cuerpo, por ejemplo `item` y `user`:

{* ../../docs_src/body_multiple_params/tutorial002_py310.py hl[20] *}

En este caso, **FastAPI** notar√° que hay m√°s de un par√°metro del cuerpo en la funci√≥n (hay dos par√°metros que son modelos de Pydantic).

Entonces, usar√° los nombres de los par√°metros como claves (nombres de campo) en el cuerpo, y esperar√° un cuerpo como:

```JSON
{
    "item": {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    },
    "user": {
        "username": "dave",
        "full_name": "Dave Grohl"
    }
}
```

/// note | Nota

Ten en cuenta que aunque el `item` se declar√≥ de la misma manera que antes, ahora se espera que est√© dentro del cuerpo con una clave `item`.

///

**FastAPI** har√° la conversi√≥n autom√°tica del request, de modo que el par√°metro `item` reciba su contenido espec√≠fico y lo mismo para `user`.

Realizar√° la validaci√≥n de los datos compuestos, y los documentar√° as√≠ para el esquema de OpenAPI y la documentaci√≥n autom√°tica.

## Valores singulares en el cuerpo

De la misma manera que hay un `Query` y `Path` para definir datos extra para par√°metros de query y path, **FastAPI** proporciona un equivalente `Body`.

Por ejemplo, ampliando el modelo anterior, podr√≠as decidir que deseas tener otra clave `importance` en el mismo cuerpo, adem√°s de `item` y `user`.

Si lo declaras tal cual, debido a que es un valor singular, **FastAPI** asumir√° que es un par√°metro de query.

Pero puedes instruir a **FastAPI** para que lo trate como otra clave del cuerpo usando `Body`:

{* ../../docs_src/body_multiple_params/tutorial003_an_py310.py hl[23] *}

En este caso, **FastAPI** esperar√° un cuerpo como:

```JSON
{
    "item": {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    },
    "user": {
        "username": "dave",
        "full_name": "Dave Grohl"
    },
    "importance": 5
}
```

Nuevamente, convertir√° los tipos de datos, validar√°, documentar√°, etc.

## M√∫ltiples par√°metros de cuerpo y query

Por supuesto, tambi√©n puedes declarar par√°metros adicionales de query siempre que lo necesites, adem√°s de cualquier par√°metro del cuerpo.

Como, por defecto, los valores singulares se interpretan como par√°metros de query, no tienes que a√±adir expl√≠citamente un `Query`, solo puedes hacer:

```Python
q: Union[str, None] = None
```

O en Python 3.10 y superior:

```Python
q: str | None = None
```

Por ejemplo:

{* ../../docs_src/body_multiple_params/tutorial004_an_py310.py hl[28] *}

/// info | Informaci√≥n

`Body` tambi√©n tiene todos los mismos par√°metros de validaci√≥n y metadatos extras que `Query`, `Path` y otros que ver√°s luego.

///

## Embeber un solo par√°metro de cuerpo

Supongamos que solo tienes un √∫nico par√°metro de cuerpo `item` de un modelo Pydantic `Item`.

Por defecto, **FastAPI** esperar√° su cuerpo directamente.

Pero si deseas que espere un JSON con una clave `item` y dentro de ella los contenidos del modelo, como lo hace cuando declaras par√°metros de cuerpo extra, puedes usar el par√°metro especial `Body` `embed`:

```Python
item: Item = Body(embed=True)
```

como en:

{* ../../docs_src/body_multiple_params/tutorial005_an_py310.py hl[17] *}

En este caso, **FastAPI** esperar√° un cuerpo como:

```JSON hl_lines="2"
{
    "item": {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    }
}
```

en lugar de:

```JSON
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2
}
```

## Resumen

Puedes a√±adir m√∫ltiples par√°metros de cuerpo a tu *path operation function*, aunque un request solo puede tener un √∫nico cuerpo.

Pero **FastAPI** lo manejar√°, te dar√° los datos correctos en tu funci√≥n, y validar√° y documentar√° el esquema correcto en la *path operation*.

Tambi√©n puedes declarar valores singulares para ser recibidos como parte del cuerpo.

Y puedes instruir a **FastAPI** para embeber el cuerpo en una clave incluso cuando solo hay un √∫nico par√°metro declarado.


================================================
File: /docs/es/docs/tutorial/body-nested-models.md
================================================
# Cuerpo - Modelos Anidados

Con **FastAPI**, puedes definir, validar, documentar y usar modelos anidados de manera arbitraria (gracias a Pydantic).

## Campos de lista

Puedes definir un atributo como un subtipo. Por ejemplo, una `list` en Python:

{* ../../docs_src/body_nested_models/tutorial001_py310.py hl[12] *}

Esto har√° que `tags` sea una lista, aunque no declare el tipo de los elementos de la lista.

## Campos de lista con par√°metro de tipo

Pero Python tiene una forma espec√≠fica de declarar listas con tipos internos, o "par√°metros de tipo":

### Importar `List` de typing

En Python 3.9 y superior, puedes usar el `list` est√°ndar para declarar estas anotaciones de tipo como veremos a continuaci√≥n. üí°

Pero en versiones de Python anteriores a 3.9 (desde 3.6 en adelante), primero necesitas importar `List` del m√≥dulo `typing` est√°ndar de Python:

{* ../../docs_src/body_nested_models/tutorial002.py hl[1] *}

### Declarar una `list` con un par√°metro de tipo

Para declarar tipos que tienen par√°metros de tipo (tipos internos), como `list`, `dict`, `tuple`:

* Si est√°s en una versi√≥n de Python inferior a 3.9, importa su versi√≥n equivalente del m√≥dulo `typing`
* Pasa el/los tipo(s) interno(s) como "par√°metros de tipo" usando corchetes: `[` y `]`

En Python 3.9 ser√≠a:

```Python
my_list: list[str]
```

En versiones de Python anteriores a 3.9, ser√≠a:

```Python
from typing import List

my_list: List[str]
```

Eso es toda la sintaxis est√°ndar de Python para declaraciones de tipo.

Usa esa misma sintaxis est√°ndar para atributos de modelos con tipos internos.

As√≠, en nuestro ejemplo, podemos hacer que `tags` sea espec√≠ficamente una "lista de strings":

{* ../../docs_src/body_nested_models/tutorial002_py310.py hl[12] *}

## Tipos de conjunto

Pero luego pensamos en ello, y nos damos cuenta de que los tags no deber√≠an repetirse, probablemente ser√≠an strings √∫nicos.

Y Python tiene un tipo de datos especial para conjuntos de elementos √∫nicos, el `set`.

Entonces podemos declarar `tags` como un conjunto de strings:

{* ../../docs_src/body_nested_models/tutorial003_py310.py hl[12] *}

Con esto, incluso si recibes un request con datos duplicados, se convertir√° en un conjunto de elementos √∫nicos.

Y siempre que emitas esos datos, incluso si la fuente ten√≠a duplicados, se emitir√° como un conjunto de elementos √∫nicos.

Y tambi√©n se anotar√°/documentar√° en consecuencia.

## Modelos Anidados

Cada atributo de un modelo Pydantic tiene un tipo.

Pero ese tipo puede ser en s√≠ mismo otro modelo Pydantic.

As√≠ que, puedes declarar "objetos" JSON anidados profundamente con nombres de atributos espec√≠ficos, tipos y validaciones.

Todo eso, de manera arbitraria.

### Definir un submodelo

Por ejemplo, podemos definir un modelo `Image`:

{* ../../docs_src/body_nested_models/tutorial004_py310.py hl[7:9] *}

### Usar el submodelo como tipo

Y luego podemos usarlo como el tipo de un atributo:

{* ../../docs_src/body_nested_models/tutorial004_py310.py hl[18] *}

Esto significar√≠a que **FastAPI** esperar√≠a un cuerpo similar a:

```JSON
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2,
    "tags": ["rock", "metal", "bar"],
    "image": {
        "url": "http://example.com/baz.jpg",
        "name": "The Foo live"
    }
}
```

Nuevamente, haciendo solo esa declaraci√≥n, con **FastAPI** obtienes:

* Soporte de editor (autocompletado, etc.), incluso para modelos anidados
* Conversi√≥n de datos
* Validaci√≥n de datos
* Documentaci√≥n autom√°tica

## Tipos especiales y validaci√≥n

Adem√°s de tipos singulares normales como `str`, `int`, `float`, etc., puedes usar tipos singulares m√°s complejos que heredan de `str`.

Para ver todas las opciones que tienes, revisa el <a href="https://docs.pydantic.dev/latest/concepts/types/" class="external-link" target="_blank">Overview de Tipos de Pydantic</a>. Ver√°s algunos ejemplos en el siguiente cap√≠tulo.

Por ejemplo, como en el modelo `Image` tenemos un campo `url`, podemos declararlo como una instance de `HttpUrl` de Pydantic en lugar de un `str`:

{* ../../docs_src/body_nested_models/tutorial005_py310.py hl[2,8] *}

El string ser√° verificado para ser una URL v√°lida, y documentado en JSON Schema / OpenAPI como tal.

## Atributos con listas de submodelos

Tambi√©n puedes usar modelos Pydantic como subtipos de `list`, `set`, etc.:

{* ../../docs_src/body_nested_models/tutorial006_py310.py hl[18] *}

Esto esperar√° (convertir√°, validar√°, documentar√°, etc.) un cuerpo JSON como:

```JSON hl_lines="11"
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2,
    "tags": [
        "rock",
        "metal",
        "bar"
    ],
    "images": [
        {
            "url": "http://example.com/baz.jpg",
            "name": "The Foo live"
        },
        {
            "url": "http://example.com/dave.jpg",
            "name": "The Baz"
        }
    ]
}
```

/// info | Informaci√≥n

Nota c√≥mo la clave `images` ahora tiene una lista de objetos de imagen.

///

## Modelos anidados profundamente

Puedes definir modelos anidados tan profundamente como desees:

{* ../../docs_src/body_nested_models/tutorial007_py310.py hl[7,12,18,21,25] *}

/// info | Informaci√≥n

Observa c√≥mo `Offer` tiene una lista de `Item`s, que a su vez tienen una lista opcional de `Image`s

///

## Cuerpos de listas puras

Si el valor superior del cuerpo JSON que esperas es un `array` JSON (una `list` en Python), puedes declarar el tipo en el par√°metro de la funci√≥n, al igual que en los modelos Pydantic:

```Python
images: List[Image]
```

o en Python 3.9 y superior:

```Python
images: list[Image]
```

como en:

{* ../../docs_src/body_nested_models/tutorial008_py39.py hl[13] *}

## Soporte de editor en todas partes

Y obtienes soporte de editor en todas partes.

Incluso para elementos dentro de listas:

<img src="/img/tutorial/body-nested-models/image01.png">

No podr√≠as obtener este tipo de soporte de editor si estuvieras trabajando directamente con `dict` en lugar de modelos Pydantic.

Pero tampoco tienes que preocuparte por ellos, los `dicts` entrantes se convierten autom√°ticamente y tu salida se convierte autom√°ticamente a JSON tambi√©n.

## Cuerpos de `dict`s arbitrarios

Tambi√©n puedes declarar un cuerpo como un `dict` con claves de alg√∫n tipo y valores de alg√∫n otro tipo.

De esta manera, no tienes que saber de antemano cu√°les son los nombres v√°lidos de campo/atributo (como ser√≠a el caso con modelos Pydantic).

Esto ser√≠a √∫til si deseas recibir claves que a√∫n no conoces.

---

Otro caso √∫til es cuando deseas tener claves de otro tipo (por ejemplo, `int`).

Eso es lo que vamos a ver aqu√≠.

En este caso, aceptar√≠as cualquier `dict` siempre que tenga claves `int` con valores `float`:

{* ../../docs_src/body_nested_models/tutorial009_py39.py hl[7] *}

/// tip | Consejo

Ten en cuenta que JSON solo admite `str` como claves.

Pero Pydantic tiene conversi√≥n autom√°tica de datos.

Esto significa que, aunque tus clientes de API solo pueden enviar strings como claves, mientras esos strings contengan enteros puros, Pydantic los convertir√° y validar√°.

Y el `dict` que recibas como `weights` tendr√° realmente claves `int` y valores `float`.

///

## Resumen

Con **FastAPI** tienes la m√°xima flexibilidad proporcionada por los modelos Pydantic, manteniendo tu c√≥digo simple, corto y elegante.

Pero con todos los beneficios:

* Soporte de editor (¬°autocompletado en todas partes!)
* Conversi√≥n de datos (tambi√©n conocido como parsing/serializaci√≥n)
* Validaci√≥n de datos
* Documentaci√≥n del esquema
* Documentaci√≥n autom√°tica


================================================
File: /docs/es/docs/tutorial/body-updates.md
================================================
# Cuerpo - Actualizaciones

## Actualizaci√≥n reemplazando con `PUT`

Para actualizar un √≠tem puedes utilizar la operaci√≥n de <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT" class="external-link" target="_blank">HTTP `PUT`</a>.

Puedes usar el `jsonable_encoder` para convertir los datos de entrada en datos que se puedan almacenar como JSON (por ejemplo, con una base de datos NoSQL). Por ejemplo, convirtiendo `datetime` a `str`.

{* ../../docs_src/body_updates/tutorial001_py310.py hl[28:33] *}

`PUT` se usa para recibir datos que deben reemplazar los datos existentes.

### Advertencia sobre el reemplazo

Esto significa que si quieres actualizar el √≠tem `bar` usando `PUT` con un body que contenga:

```Python
{
    "name": "Barz",
    "price": 3,
    "description": None,
}
```

debido a que no incluye el atributo ya almacenado `"tax": 20.2`, el modelo de entrada tomar√≠a el valor por defecto de `"tax": 10.5`.

Y los datos se guardar√≠an con ese "nuevo" `tax` de `10.5`.

## Actualizaciones parciales con `PATCH`

Tambi√©n puedes usar la operaci√≥n de <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH" class="external-link" target="_blank">HTTP `PATCH`</a> para actualizar *parcialmente* datos.

Esto significa que puedes enviar solo los datos que deseas actualizar, dejando el resto intacto.

/// note | Nota

`PATCH` es menos usado y conocido que `PUT`.

Y muchos equipos utilizan solo `PUT`, incluso para actualizaciones parciales.

Eres **libre** de usarlos como desees, **FastAPI** no impone ninguna restricci√≥n.

Pero esta gu√≠a te muestra, m√°s o menos, c√≥mo se pretende que se usen.

///

### Uso del par√°metro `exclude_unset` de Pydantic

Si quieres recibir actualizaciones parciales, es muy √∫til usar el par√°metro `exclude_unset` en el `.model_dump()` del modelo de Pydantic.

Como `item.model_dump(exclude_unset=True)`.

/// info | Informaci√≥n

En Pydantic v1 el m√©todo se llamaba `.dict()`, fue deprecado (pero a√∫n soportado) en Pydantic v2, y renombrado a `.model_dump()`.

Los ejemplos aqu√≠ usan `.dict()` para compatibilidad con Pydantic v1, pero deber√≠as usar `.model_dump()` si puedes usar Pydantic v2.

///

Eso generar√≠a un `dict` solo con los datos que se establecieron al crear el modelo `item`, excluyendo los valores por defecto.

Luego puedes usar esto para generar un `dict` solo con los datos que se establecieron (enviados en el request), omitiendo los valores por defecto:

{* ../../docs_src/body_updates/tutorial002_py310.py hl[32] *}

### Uso del par√°metro `update` de Pydantic

Ahora, puedes crear una copia del modelo existente usando `.model_copy()`, y pasar el par√°metro `update` con un `dict` que contenga los datos a actualizar.

/// info | Informaci√≥n

En Pydantic v1 el m√©todo se llamaba `.copy()`, fue deprecado (pero a√∫n soportado) en Pydantic v2, y renombrado a `.model_copy()`.

Los ejemplos aqu√≠ usan `.copy()` para compatibilidad con Pydantic v1, pero deber√≠as usar `.model_copy()` si puedes usar Pydantic v2.

///

Como `stored_item_model.model_copy(update=update_data)`:

{* ../../docs_src/body_updates/tutorial002_py310.py hl[33] *}

### Resumen de actualizaciones parciales

En resumen, para aplicar actualizaciones parciales deber√≠as:

* (Opcionalmente) usar `PATCH` en lugar de `PUT`.
* Recuperar los datos almacenados.
* Poner esos datos en un modelo de Pydantic.
* Generar un `dict` sin valores por defecto del modelo de entrada (usando `exclude_unset`).
    * De esta manera puedes actualizar solo los valores realmente establecidos por el usuario, en lugar de sobrescribir valores ya almacenados con valores por defecto en tu modelo.
* Crear una copia del modelo almacenado, actualizando sus atributos con las actualizaciones parciales recibidas (usando el par√°metro `update`).
* Convertir el modelo copiado en algo que pueda almacenarse en tu base de datos (por ejemplo, usando el `jsonable_encoder`).
    * Esto es comparable a usar el m√©todo `.model_dump()` del modelo de nuevo, pero asegura (y convierte) los valores a tipos de datos que pueden convertirse a JSON, por ejemplo, `datetime` a `str`.
* Guardar los datos en tu base de datos.
* Devolver el modelo actualizado.

{* ../../docs_src/body_updates/tutorial002_py310.py hl[28:35] *}

/// tip | Consejo

Puedes realmente usar esta misma t√©cnica con una operaci√≥n HTTP `PUT`.

Pero el ejemplo aqu√≠ usa `PATCH` porque fue creado para estos casos de uso.

///

/// note | Nota

Observa que el modelo de entrada sigue siendo validado.

Entonces, si deseas recibir actualizaciones parciales que puedan omitir todos los atributos, necesitas tener un modelo con todos los atributos marcados como opcionales (con valores por defecto o `None`).

Para distinguir entre los modelos con todos los valores opcionales para **actualizaciones** y modelos con valores requeridos para **creaci√≥n**, puedes utilizar las ideas descritas en [Modelos Extra](extra-models.md){.internal-link target=_blank}.

///


================================================
File: /docs/es/docs/tutorial/body.md
================================================
# Request Body

Cuando necesitas enviar datos desde un cliente (digamos, un navegador) a tu API, los env√≠as como un **request body**.

Un **request** body es un dato enviado por el cliente a tu API. Un **response** body es el dato que tu API env√≠a al cliente.

Tu API casi siempre tiene que enviar un **response** body. Pero los clientes no necesariamente necesitan enviar **request bodies** todo el tiempo, a veces solo solicitan un path, quiz√°s con algunos par√°metros de query, pero no env√≠an un body.

Para declarar un **request** body, usas modelos de <a href="https://docs.pydantic.dev/" class="external-link" target="_blank">Pydantic</a> con todo su poder y beneficios.

/// info | Informaci√≥n

Para enviar datos, deber√≠as usar uno de estos m√©todos: `POST` (el m√°s com√∫n), `PUT`, `DELETE` o `PATCH`.

Enviar un body con un request `GET` tiene un comportamiento indefinido en las especificaciones, no obstante, es soportado por FastAPI, solo para casos de uso muy complejos/extremos.

Como no se recomienda, la documentaci√≥n interactiva con Swagger UI no mostrar√° la documentaci√≥n para el body cuando se usa `GET`, y los proxies intermedios podr√≠an no soportarlo.

///

## Importar `BaseModel` de Pydantic

Primero, necesitas importar `BaseModel` de `pydantic`:

{* ../../docs_src/body/tutorial001_py310.py hl[2] *}

## Crea tu modelo de datos

Luego, declaras tu modelo de datos como una clase que hereda de `BaseModel`.

Usa tipos est√°ndar de Python para todos los atributos:

{* ../../docs_src/body/tutorial001_py310.py hl[5:9] *}

Al igual que al declarar par√°metros de query, cuando un atributo del modelo tiene un valor por defecto, no es obligatorio. De lo contrario, es obligatorio. Usa `None` para hacerlo opcional.

Por ejemplo, el modelo anterior declara un ‚Äú`object`‚Äù JSON (o `dict` en Python) como:

```JSON
{
    "name": "Foo",
    "description": "An optional description",
    "price": 45.2,
    "tax": 3.5
}
```

...dado que `description` y `tax` son opcionales (con un valor por defecto de `None`), este ‚Äú`object`‚Äù JSON tambi√©n ser√≠a v√°lido:

```JSON
{
    "name": "Foo",
    "price": 45.2
}
```

## Decl√°ralo como un par√°metro

Para a√±adirlo a tu *path operation*, decl√°ralo de la misma manera que declaraste par√°metros de path y query:

{* ../../docs_src/body/tutorial001_py310.py hl[16] *}

...y declara su tipo como el modelo que creaste, `Item`.

## Resultados

Con solo esa declaraci√≥n de tipo en Python, **FastAPI** har√° lo siguiente:

* Leer el body del request como JSON.
* Convertir los tipos correspondientes (si es necesario).
* Validar los datos.
    * Si los datos son inv√°lidos, devolver√° un error claro e indicado, se√±alando exactamente d√≥nde y qu√© fue lo incorrecto.
* Proporcionar los datos recibidos en el par√°metro `item`.
    * Como lo declaraste en la funci√≥n como de tipo `Item`, tambi√©n tendr√°s todo el soporte del editor (autocompletado, etc.) para todos los atributos y sus tipos.
* Generar definiciones de <a href="https://json-schema.org" class="external-link" target="_blank">JSON Schema</a> para tu modelo, que tambi√©n puedes usar en cualquier otro lugar si tiene sentido para tu proyecto.
* Esquemas que ser√°n parte del esquema de OpenAPI generado y usados por la <abbr title="User Interfaces">UIs</abbr> de documentaci√≥n autom√°tica.

## Documentaci√≥n autom√°tica

Los JSON Schemas de tus modelos ser√°n parte del esquema OpenAPI generado y se mostrar√°n en la documentaci√≥n API interactiva:

<img src="/img/tutorial/body/image01.png">

Y tambi√©n se utilizar√°n en la documentaci√≥n API dentro de cada *path operation* que los necesite:

<img src="/img/tutorial/body/image02.png">

## Soporte del editor

En tu editor, dentro de tu funci√≥n, obtendr√°s anotaciones de tipos y autocompletado en todas partes (esto no suceder√≠a si recibieras un `dict` en lugar de un modelo de Pydantic):

<img src="/img/tutorial/body/image03.png">

Tambi√©n recibir√°s chequeos de errores para operaciones de tipo incorrecto:

<img src="/img/tutorial/body/image04.png">

No es por casualidad, todo el framework fue construido alrededor de ese dise√±o.

Y fue rigurosamente probado en la fase de dise√±o, antes de cualquier implementaci√≥n, para garantizar que funcionar√≠a con todos los editores.

Incluso se hicieron algunos cambios en Pydantic para admitir esto.

Las capturas de pantalla anteriores se tomaron con <a href="https://code.visualstudio.com" class="external-link" target="_blank">Visual Studio Code</a>.

Pero obtendr√≠as el mismo soporte en el editor con <a href="https://www.jetbrains.com/pycharm/" class="external-link" target="_blank">PyCharm</a> y la mayor√≠a de los otros editores de Python:

<img src="/img/tutorial/body/image05.png">

/// tip | Consejo

Si usas <a href="https://www.jetbrains.com/pycharm/" class="external-link" target="_blank">PyCharm</a> como tu editor, puedes usar el <a href="https://github.com/koxudaxi/pydantic-pycharm-plugin/" class="external-link" target="_blank">Pydantic PyCharm Plugin</a>.

Mejora el soporte del editor para modelos de Pydantic, con:

* autocompletado
* chequeo de tipos
* refactorizaci√≥n
* b√∫squeda
* inspecciones

///

## Usa el modelo

Dentro de la funci√≥n, puedes acceder a todos los atributos del objeto modelo directamente:

{* ../../docs_src/body/tutorial002_py310.py *}

## Request body + par√°metros de path

Puedes declarar par√°metros de path y request body al mismo tiempo.

**FastAPI** reconocer√° que los par√°metros de funci√≥n que coinciden con los par√°metros de path deben ser **tomados del path**, y que los par√°metros de funci√≥n que se declaran como modelos de Pydantic deben ser **tomados del request body**.

{* ../../docs_src/body/tutorial003_py310.py hl[15:16] *}

## Request body + path + par√°metros de query

Tambi√©n puedes declarar par√°metros de **body**, **path** y **query**, todos al mismo tiempo.

**FastAPI** reconocer√° cada uno de ellos y tomar√° los datos del lugar correcto.

{* ../../docs_src/body/tutorial004_py310.py hl[16] *}

Los par√°metros de la funci√≥n se reconocer√°n de la siguiente manera:

* Si el par√°metro tambi√©n se declara en el **path**, se utilizar√° como un par√°metro de path.
* Si el par√°metro es de un **tipo singular** (como `int`, `float`, `str`, `bool`, etc.), se interpretar√° como un par√°metro de **query**.
* Si el par√°metro se declara como del tipo de un **modelo de Pydantic**, se interpretar√° como un **request body**.

/// note | Nota

FastAPI sabr√° que el valor de `q` no es requerido debido al valor por defecto `= None`.

El `str | None` (Python 3.10+) o `Union` en `Union[str, None]` (Python 3.8+) no es utilizado por FastAPI para determinar que el valor no es requerido, sabr√° que no es requerido porque tiene un valor por defecto de `= None`.

Pero agregar las anotaciones de tipos permitir√° que tu editor te brinde un mejor soporte y detecte errores.

///

## Sin Pydantic

Si no quieres usar modelos de Pydantic, tambi√©n puedes usar par√°metros **Body**. Consulta la documentaci√≥n para [Body - Multiples Parametros: Valores singulares en body](body-multiple-params.md#singular-values-in-body){.internal-link target=_blank}.


================================================
File: /docs/es/docs/tutorial/cookie-param-models.md
================================================
# Modelos de Cookies

Si tienes un grupo de **cookies** que est√°n relacionadas, puedes crear un **modelo de Pydantic** para declararlas. üç™

Esto te permitir√° **reutilizar el modelo** en **m√∫ltiples lugares** y tambi√©n declarar validaciones y metadatos para todos los par√°metros a la vez. üòé

/// note | Nota

Esto es compatible desde la versi√≥n `0.115.0` de FastAPI. ü§ì

///

/// tip | Consejo

Esta misma t√©cnica se aplica a `Query`, `Cookie`, y `Header`. üòé

///

## Cookies con un Modelo de Pydantic

Declara los par√°metros de **cookie** que necesites en un **modelo de Pydantic**, y luego declara el par√°metro como `Cookie`:

{* ../../docs_src/cookie_param_models/tutorial001_an_py310.py hl[9:12,16] *}

**FastAPI** **extraer√°** los datos para **cada campo** de las **cookies** recibidas en el request y te entregar√° el modelo de Pydantic que definiste.

## Revisa la Documentaci√≥n

Puedes ver las cookies definidas en la UI de la documentaci√≥n en `/docs`:

<div class="screenshot">
<img src="/img/tutorial/cookie-param-models/image01.png">
</div>

/// info | Informaci√≥n

Ten en cuenta que, como los **navegadores manejan las cookies** de maneras especiales y detr√°s de escenas, **no** permiten f√°cilmente que **JavaScript** las toque.

Si vas a la **UI de la documentaci√≥n de la API** en `/docs` podr√°s ver la **documentaci√≥n** de las cookies para tus *path operations*.

Pero incluso si **rellenas los datos** y haces clic en "Execute", como la UI de la documentaci√≥n funciona con **JavaScript**, las cookies no ser√°n enviadas y ver√°s un **mensaje de error** como si no hubieras escrito ning√∫n valor.

///

## Prohibir Cookies Extra

En algunos casos de uso especiales (probablemente no muy comunes), podr√≠as querer **restringir** las cookies que deseas recibir.

Tu API ahora tiene el poder de controlar su propio <abbr title="Esto es una broma, por si acaso. No tiene nada que ver con los consentimientos de cookies, pero es gracioso que incluso la API ahora pueda rechazar las pobres cookies. Toma una cookie. üç™">consentimiento de cookies</abbr>. ü§™üç™

Puedes usar la configuraci√≥n del modelo de Pydantic para `prohibir` cualquier campo `extra`:

{* ../../docs_src/cookie_param_models/tutorial002_an_py39.py hl[10] *}

Si un cliente intenta enviar algunas **cookies extra**, recibir√°n un response de **error**.

Pobres banners de cookies con todo su esfuerzo para obtener tu consentimiento para que la <abbr title="Esta es otra broma. No me prestes atenci√≥n. Toma un caf√© para tu cookie. ‚òï">API lo rechace</abbr>. üç™

Por ejemplo, si el cliente intenta enviar una cookie `santa_tracker` con un valor de `good-list-please`, el cliente recibir√° un response de **error** que le informa que la cookie `santa_tracker` <abbr title="Santa desaprueba la falta de cookies. üéÖ Est√° bien, no m√°s bromas de cookies.">no est√° permitida</abbr>:

```json
{
    "detail": [
        {
            "type": "extra_forbidden",
            "loc": ["cookie", "santa_tracker"],
            "msg": "Extra inputs are not permitted",
            "input": "good-list-please",
        }
    ]
}
```

## Resumen

Puedes usar **modelos de Pydantic** para declarar <abbr title="Toma una √∫ltima cookie antes de irte. üç™">**cookies**</abbr> en **FastAPI**. üòé


================================================
File: /docs/es/docs/tutorial/cookie-params.md
================================================
# Par√°metros de Cookie

Puedes definir par√°metros de Cookie de la misma manera que defines los par√°metros `Query` y `Path`.

## Importar `Cookie`

Primero importa `Cookie`:

{* ../../docs_src/cookie_params/tutorial001_an_py310.py hl[3] *}

## Declarar par√°metros de `Cookie`

Luego declara los par√°metros de cookie usando la misma estructura que con `Path` y `Query`.

Puedes definir el valor por defecto as√≠ como toda la validaci√≥n extra o los par√°metros de anotaci√≥n:

{* ../../docs_src/cookie_params/tutorial001_an_py310.py hl[9] *}

/// note | Detalles T√©cnicos

`Cookie` es una clase "hermana" de `Path` y `Query`. Tambi√©n hereda de la misma clase com√∫n `Param`.

Pero recuerda que cuando importas `Query`, `Path`, `Cookie` y otros desde `fastapi`, en realidad son funciones que devuelven clases especiales.

///

/// info | Informaci√≥n

Para declarar cookies, necesitas usar `Cookie`, porque de lo contrario los par√°metros ser√≠an interpretados como par√°metros de query.

///

## Resumen

Declara cookies con `Cookie`, usando el mismo patr√≥n com√∫n que `Query` y `Path`.


================================================
File: /docs/es/docs/tutorial/cors.md
================================================
# CORS (Cross-Origin Resource Sharing)

<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" class="external-link" target="_blank">CORS o "Cross-Origin Resource Sharing"</a> se refiere a situaciones en las que un frontend que se ejecuta en un navegador tiene c√≥digo JavaScript que se comunica con un backend, y el backend est√° en un "origen" diferente al frontend.

## Origen

Un origen es la combinaci√≥n de protocolo (`http`, `https`), dominio (`myapp.com`, `localhost`, `localhost.tiangolo.com`) y puerto (`80`, `443`, `8080`).

As√≠ que, todos estos son or√≠genes diferentes:

* `http://localhost`
* `https://localhost`
* `http://localhost:8080`

Aunque todos est√°n en `localhost`, usan protocolos o puertos diferentes, por lo tanto, son "or√≠genes" diferentes.

## Pasos

Entonces, digamos que tienes un frontend corriendo en tu navegador en `http://localhost:8080`, y su JavaScript est√° tratando de comunicarse con un backend corriendo en `http://localhost` (porque no especificamos un puerto, el navegador asumir√° el puerto por defecto `80`).

Entonces, el navegador enviar√° un request HTTP `OPTIONS` al backend `:80`, y si el backend env√≠a los headers apropiados autorizando la comunicaci√≥n desde este origen diferente (`http://localhost:8080`), entonces el navegador `:8080` permitir√° que el JavaScript en el frontend env√≠e su request al backend `:80`.

Para lograr esto, el backend `:80` debe tener una lista de "or√≠genes permitidos".

En este caso, la lista tendr√≠a que incluir `http://localhost:8080` para que el frontend `:8080` funcione correctamente.

## Comodines

Tambi√©n es posible declarar la lista como `"*"` (un "comod√≠n") para decir que todos est√°n permitidos.

Pero eso solo permitir√° ciertos tipos de comunicaci√≥n, excluyendo todo lo que implique credenciales: Cookies, headers de autorizaci√≥n como los utilizados con Bearer Tokens, etc.

As√≠ que, para que todo funcione correctamente, es mejor especificar expl√≠citamente los or√≠genes permitidos.

## Usa `CORSMiddleware`

Puedes configurarlo en tu aplicaci√≥n **FastAPI** usando el `CORSMiddleware`.

* Importa `CORSMiddleware`.
* Crea una lista de or√≠genes permitidos (como strings).
* Agr√©galo como un "middleware" a tu aplicaci√≥n **FastAPI**.

Tambi√©n puedes especificar si tu backend permite:

* Credenciales (headers de autorizaci√≥n, cookies, etc).
* M√©todos HTTP espec√≠ficos (`POST`, `PUT`) o todos ellos con el comod√≠n `"*"`.
* Headers HTTP espec√≠ficos o todos ellos con el comod√≠n `"*"`.

{* ../../docs_src/cors/tutorial001.py hl[2,6:11,13:19] *}

Los par√°metros predeterminados utilizados por la implementaci√≥n de `CORSMiddleware` son restrictivos por defecto, por lo que necesitar√°s habilitar expl√≠citamente or√≠genes, m√©todos o headers particulares para que los navegadores est√©n permitidos de usarlos en un contexto de Cross-Domain.

Se admiten los siguientes argumentos:

* `allow_origins` - Una lista de or√≠genes que deber√≠an estar permitidos para hacer requests cross-origin. Por ejemplo, `['https://example.org', 'https://www.example.org']`. Puedes usar `['*']` para permitir cualquier origen.
* `allow_origin_regex` - Una cadena regex para coincidir con or√≠genes que deber√≠an estar permitidos para hacer requests cross-origin. por ejemplo, `'https://.*\.example\.org'`.
* `allow_methods` - Una lista de m√©todos HTTP que deber√≠an estar permitidos para requests cross-origin. Por defecto es `['GET']`. Puedes usar `['*']` para permitir todos los m√©todos est√°ndar.
* `allow_headers` - Una lista de headers de request HTTP que deber√≠an estar soportados para requests cross-origin. Por defecto es `[]`. Puedes usar `['*']` para permitir todos los headers. Los headers `Accept`, `Accept-Language`, `Content-Language` y `Content-Type` siempre est√°n permitidos para <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#simple_requests" class="external-link" rel="noopener" target="_blank">requests CORS simples</a>.
* `allow_credentials` - Indica que las cookies deber√≠an estar soportadas para requests cross-origin. Por defecto es `False`. Adem√°s, `allow_origins` no puede ser configurado a `['*']` para que las credenciales est√©n permitidas, los or√≠genes deben ser especificados.
* `expose_headers` - Indica cualquier header de response que deber√≠a ser accesible para el navegador. Por defecto es `[]`.
* `max_age` - Establece un tiempo m√°ximo en segundos para que los navegadores almacenen en cach√© los responses CORS. Por defecto es `600`.

El middleware responde a dos tipos particulares de request HTTP...

### Requests de preflight CORS

Estos son cualquier request `OPTIONS` con headers `Origin` y `Access-Control-Request-Method`.

En este caso, el middleware interceptar√° el request entrante y responder√° con los headers CORS adecuados, y un response `200` o `400` con fines informativos.

### Requests simples

Cualquier request con un header `Origin`. En este caso, el middleware pasar√° el request a trav√©s de lo normal, pero incluir√° los headers CORS adecuados en el response.

## M√°s info

Para m√°s informaci√≥n sobre <abbr title="Cross-Origin Resource Sharing">CORS</abbr>, revisa la <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS" class="external-link" target="_blank">documentaci√≥n de CORS de Mozilla</a>.

/// note | Detalles T√©cnicos

Tambi√©n podr√≠as usar `from starlette.middleware.cors import CORSMiddleware`.

**FastAPI** proporciona varios middlewares en `fastapi.middleware` como una conveniencia para ti, el desarrollador. Pero la mayor√≠a de los middlewares disponibles provienen directamente de Starlette.

///


================================================
File: /docs/es/docs/tutorial/debugging.md
================================================
# Depuraci√≥n

Puedes conectar el depurador en tu editor, por ejemplo con Visual Studio Code o PyCharm.

## Llama a `uvicorn`

En tu aplicaci√≥n de FastAPI, importa y ejecuta `uvicorn` directamente:

{* ../../docs_src/debugging/tutorial001.py hl[1,15] *}

### Acerca de `__name__ == "__main__"`

El objetivo principal de `__name__ == "__main__"` es tener algo de c√≥digo que se ejecute cuando tu archivo es llamado con:

<div class="termy">

```console
$ python myapp.py
```

</div>

pero no es llamado cuando otro archivo lo importa, como en:

```Python
from myapp import app
```

#### M√°s detalles

Supongamos que tu archivo se llama `myapp.py`.

Si lo ejecutas con:

<div class="termy">

```console
$ python myapp.py
```

</div>

entonces la variable interna `__name__` en tu archivo, creada autom√°ticamente por Python, tendr√° como valor el string `"__main__"`.

As√≠ que, la secci√≥n:

```Python
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

se ejecutar√°.

---

Esto no ocurrir√° si importas ese m√≥dulo (archivo).

Entonces, si tienes otro archivo `importer.py` con:

```Python
from myapp import app

# Alg√∫n c√≥digo adicional
```

en ese caso, la variable creada autom√°ticamente dentro de `myapp.py` no tendr√° la variable `__name__` con un valor de `"__main__"`.

As√≠ que, la l√≠nea:

```Python
    uvicorn.run(app, host="0.0.0.0", port=8000)
```

no se ejecutar√°.

/// info | Informaci√≥n

Para m√°s informaci√≥n, revisa <a href="https://docs.python.org/3/library/__main__.html" class="external-link" target="_blank">la documentaci√≥n oficial de Python</a>.

///

## Ejecuta tu c√≥digo con tu depurador

Dado que est√°s ejecutando el servidor Uvicorn directamente desde tu c√≥digo, puedes llamar a tu programa de Python (tu aplicaci√≥n FastAPI) directamente desde el depurador.

---

Por ejemplo, en Visual Studio Code, puedes:

* Ir al panel de "Debug".
* "Add configuration...".
* Seleccionar "Python".
* Ejecutar el depurador con la opci√≥n "`Python: Current File (Integrated Terminal)`".

Luego, iniciar√° el servidor con tu c√≥digo **FastAPI**, deteni√©ndose en tus puntos de interrupci√≥n, etc.

As√≠ es como podr√≠a verse:

<img src="/img/tutorial/debugging/image01.png">

---

Si usas PyCharm, puedes:

* Abrir el men√∫ "Run".
* Seleccionar la opci√≥n "Debug...".
* Luego aparece un men√∫ contextual.
* Selecciona el archivo para depurar (en este caso, `main.py`).

Luego, iniciar√° el servidor con tu c√≥digo **FastAPI**, deteni√©ndose en tus puntos de interrupci√≥n, etc.

As√≠ es como podr√≠a verse:

<img src="/img/tutorial/debugging/image02.png">


================================================
File: /docs/es/docs/tutorial/encoder.md
================================================
# JSON Compatible Encoder

Hay algunos casos en los que podr√≠as necesitar convertir un tipo de dato (como un modelo de Pydantic) a algo compatible con JSON (como un `dict`, `list`, etc).

Por ejemplo, si necesitas almacenarlo en una base de datos.

Para eso, **FastAPI** proporciona una funci√≥n `jsonable_encoder()`.

## Usando el `jsonable_encoder`

Imaginemos que tienes una base de datos `fake_db` que solo recibe datos compatibles con JSON.

Por ejemplo, no recibe objetos `datetime`, ya que no son compatibles con JSON.

Entonces, un objeto `datetime` tendr√≠a que ser convertido a un `str` que contenga los datos en formato <a href="https://en.wikipedia.org/wiki/ISO_8601" class="external-link" target="_blank">ISO</a>.

De la misma manera, esta base de datos no recibir√≠a un modelo de Pydantic (un objeto con atributos), solo un `dict`.

Puedes usar `jsonable_encoder` para eso.

Recibe un objeto, como un modelo de Pydantic, y devuelve una versi√≥n compatible con JSON:

{* ../../docs_src/encoder/tutorial001_py310.py hl[4,21] *}

En este ejemplo, convertir√≠a el modelo de Pydantic a un `dict`, y el `datetime` a un `str`.

El resultado de llamarlo es algo que puede ser codificado con la funci√≥n est√°ndar de Python <a href="https://docs.python.org/3/library/json.html#json.dumps" class="external-link" target="_blank">`json.dumps()`</a>.

No devuelve un gran `str` que contenga los datos en formato JSON (como una cadena de texto). Devuelve una estructura de datos est√°ndar de Python (por ejemplo, un `dict`) con valores y sub-valores que son todos compatibles con JSON.

/// note | Nota

`jsonable_encoder` es utilizado internamente por **FastAPI** para convertir datos. Pero es √∫til en muchos otros escenarios.

///


================================================
File: /docs/es/docs/tutorial/extra-data-types.md
================================================
# Tipos de Datos Extra

Hasta ahora, has estado usando tipos de datos comunes, como:

* `int`
* `float`
* `str`
* `bool`

Pero tambi√©n puedes usar tipos de datos m√°s complejos.

Y seguir√°s teniendo las mismas funcionalidades como hasta ahora:

* Gran soporte de editor.
* Conversi√≥n de datos de requests entrantes.
* Conversi√≥n de datos para datos de response.
* Validaci√≥n de datos.
* Anotaci√≥n y documentaci√≥n autom√°tica.

## Otros tipos de datos

Aqu√≠ hay algunos de los tipos de datos adicionales que puedes usar:

* `UUID`:
    * Un "Identificador Universalmente √önico" est√°ndar, com√∫n como un ID en muchas bases de datos y sistemas.
    * En requests y responses se representar√° como un `str`.
* `datetime.datetime`:
    * Un `datetime.datetime` de Python.
    * En requests y responses se representar√° como un `str` en formato ISO 8601, como: `2008-09-15T15:53:00+05:00`.
* `datetime.date`:
    * `datetime.date` de Python.
    * En requests y responses se representar√° como un `str` en formato ISO 8601, como: `2008-09-15`.
* `datetime.time`:
    * Un `datetime.time` de Python.
    * En requests y responses se representar√° como un `str` en formato ISO 8601, como: `14:23:55.003`.
* `datetime.timedelta`:
    * Un `datetime.timedelta` de Python.
    * En requests y responses se representar√° como un `float` de segundos totales.
    * Pydantic tambi√©n permite representarlo como una "codificaci√≥n de diferencia horaria ISO 8601", <a href="https://docs.pydantic.dev/latest/concepts/serialization/#custom-serializers" class="external-link" target="_blank">consulta la documentaci√≥n para m√°s informaci√≥n</a>.
* `frozenset`:
    * En requests y responses, tratado igual que un `set`:
        * En requests, se leer√° una list, eliminando duplicados y convirti√©ndola en un `set`.
        * En responses, el `set` se convertir√° en una `list`.
        * El esquema generado especificar√° que los valores del `set` son √∫nicos (usando `uniqueItems` de JSON Schema).
* `bytes`:
    * `bytes` est√°ndar de Python.
    * En requests y responses se tratar√° como `str`.
    * El esquema generado especificar√° que es un `str` con "binary" como "format".
* `Decimal`:
    * `Decimal` est√°ndar de Python.
    * En requests y responses, manejado igual que un `float`.
* Puedes revisar todos los tipos de datos v√°lidos de Pydantic aqu√≠: <a href="https://docs.pydantic.dev/latest/usage/types/types/" class="external-link" target="_blank">Tipos de datos de Pydantic</a>.

## Ejemplo

Aqu√≠ tienes un ejemplo de una *path operation* con par√°metros usando algunos de los tipos anteriores.

{* ../../docs_src/extra_data_types/tutorial001_an_py310.py hl[1,3,12:16] *}

Nota que los par√°metros dentro de la funci√≥n tienen su tipo de dato natural, y puedes, por ejemplo, realizar manipulaciones de fechas normales, como:

{* ../../docs_src/extra_data_types/tutorial001_an_py310.py hl[18:19] *}


================================================
File: /docs/es/docs/tutorial/extra-models.md
================================================
# Modelos Extra

Continuando con el ejemplo anterior, ser√° com√∫n tener m√°s de un modelo relacionado.

Esto es especialmente el caso para los modelos de usuario, porque:

* El **modelo de entrada** necesita poder tener una contrase√±a.
* El **modelo de salida** no deber√≠a tener una contrase√±a.
* El **modelo de base de datos** probablemente necesitar√≠a tener una contrase√±a hasheada.

/// danger | Peligro

Nunca almacenes contrase√±as de usuarios en texto plano. Siempre almacena un "hash seguro" que puedas verificar luego.

Si no lo sabes, aprender√°s qu√© es un "hash de contrase√±a" en los [cap√≠tulos de seguridad](security/simple-oauth2.md#password-hashing){.internal-link target=_blank}.

///

## M√∫ltiples modelos

Aqu√≠ tienes una idea general de c√≥mo podr√≠an ser los modelos con sus campos de contrase√±a y los lugares donde se utilizan:

{* ../../docs_src/extra_models/tutorial001_py310.py hl[7,9,14,20,22,27:28,31:33,38:39] *}

/// info | Informaci√≥n

En Pydantic v1 el m√©todo se llamaba `.dict()`, fue deprecado (pero a√∫n soportado) en Pydantic v2, y renombrado a `.model_dump()`.

Los ejemplos aqu√≠ usan `.dict()` para compatibilidad con Pydantic v1, pero deber√≠as usar `.model_dump()` en su lugar si puedes usar Pydantic v2.

///

### Acerca de `**user_in.dict()`

#### `.dict()` de Pydantic

`user_in` es un modelo Pydantic de la clase `UserIn`.

Los modelos Pydantic tienen un m√©todo `.dict()` que devuelve un `dict` con los datos del modelo.

As√≠ que, si creamos un objeto Pydantic `user_in` como:

```Python
user_in = UserIn(username="john", password="secret", email="john.doe@example.com")
```

y luego llamamos a:

```Python
user_dict = user_in.dict()
```

ahora tenemos un `dict` con los datos en la variable `user_dict` (es un `dict` en lugar de un objeto modelo Pydantic).

Y si llamamos a:

```Python
print(user_dict)
```

obtendremos un `dict` de Python con:

```Python
{
    'username': 'john',
    'password': 'secret',
    'email': 'john.doe@example.com',
    'full_name': None,
}
```

#### Desempaquetando un `dict`

Si tomamos un `dict` como `user_dict` y lo pasamos a una funci√≥n (o clase) con `**user_dict`, Python lo "desempaquetar√°". Pasar√° las claves y valores del `user_dict` directamente como argumentos clave-valor.

As√≠ que, continuando con el `user_dict` anterior, escribir:

```Python
UserInDB(**user_dict)
```

ser√≠a equivalente a algo como:

```Python
UserInDB(
    username="john",
    password="secret",
    email="john.doe@example.com",
    full_name=None,
)
```

O m√°s exactamente, usando `user_dict` directamente, con cualquier contenido que pueda tener en el futuro:

```Python
UserInDB(
    username = user_dict["username"],
    password = user_dict["password"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
)
```

#### Un modelo Pydantic a partir del contenido de otro

Como en el ejemplo anterior obtuvimos `user_dict` de `user_in.dict()`, este c√≥digo:

```Python
user_dict = user_in.dict()
UserInDB(**user_dict)
```

ser√≠a equivalente a:

```Python
UserInDB(**user_in.dict())
```

...porque `user_in.dict()` es un `dict`, y luego hacemos que Python lo "desempaquete" al pasarlo a `UserInDB` con el prefijo `**`.

As√≠, obtenemos un modelo Pydantic a partir de los datos en otro modelo Pydantic.

#### Desempaquetando un `dict` y palabras clave adicionales

Y luego agregando el argumento de palabra clave adicional `hashed_password=hashed_password`, como en:

```Python
UserInDB(**user_in.dict(), hashed_password=hashed_password)
```

...termina siendo como:

```Python
UserInDB(
    username = user_dict["username"],
    password = user_dict["password"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
    hashed_password = hashed_password,
)
```

/// warning | Advertencia

Las funciones adicionales de soporte `fake_password_hasher` y `fake_save_user` son solo para demostrar un posible flujo de datos, pero por supuesto no proporcionan ninguna seguridad real.

///

## Reducir duplicaci√≥n

Reducir la duplicaci√≥n de c√≥digo es una de las ideas centrales en **FastAPI**.

Ya que la duplicaci√≥n de c√≥digo incrementa las posibilidades de bugs, problemas de seguridad, problemas de desincronizaci√≥n de c√≥digo (cuando actualizas en un lugar pero no en los otros), etc.

Y estos modelos est√°n compartiendo muchos de los datos y duplicando nombres y tipos de atributos.

Podr√≠amos hacerlo mejor.

Podemos declarar un modelo `UserBase` que sirva como base para nuestros otros modelos. Y luego podemos hacer subclases de ese modelo que heredan sus atributos (declaraciones de tipo, validaci√≥n, etc).

Toda la conversi√≥n de datos, validaci√≥n, documentaci√≥n, etc. seguir√° funcionando normalmente.

De esa manera, podemos declarar solo las diferencias entre los modelos (con `password` en texto plano, con `hashed_password` y sin contrase√±a):

{* ../../docs_src/extra_models/tutorial002_py310.py hl[7,13:14,17:18,21:22] *}

## `Union` o `anyOf`

Puedes declarar un response que sea la `Union` de dos o m√°s tipos, eso significa que el response ser√≠a cualquiera de ellos.

Se definir√° en OpenAPI con `anyOf`.

Para hacerlo, usa el type hint est√°ndar de Python <a href="https://docs.python.org/3/library/typing.html#typing.Union" class="external-link" target="_blank">`typing.Union`</a>:

/// note | Nota

Al definir una <a href="https://docs.pydantic.dev/latest/concepts/types/#unions" class="external-link" target="_blank">`Union`</a>, incluye el tipo m√°s espec√≠fico primero, seguido por el tipo menos espec√≠fico. En el ejemplo a continuaci√≥n, el m√°s espec√≠fico `PlaneItem` viene antes de `CarItem` en `Union[PlaneItem, CarItem]`.

///

{* ../../docs_src/extra_models/tutorial003_py310.py hl[1,14:15,18:20,33] *}


### `Union` en Python 3.10

En este ejemplo pasamos `Union[PlaneItem, CarItem]` como el valor del argumento `response_model`.

Porque lo estamos pasando como un **valor a un argumento** en lugar de ponerlo en una **anotaci√≥n de tipo**, tenemos que usar `Union` incluso en Python 3.10.

Si estuviera en una anotaci√≥n de tipo podr√≠amos haber usado la barra vertical, como:

```Python
some_variable: PlaneItem | CarItem
```

Pero si ponemos eso en la asignaci√≥n `response_model=PlaneItem | CarItem` obtendr√≠amos un error, porque Python intentar√≠a realizar una **operaci√≥n inv√°lida** entre `PlaneItem` y `CarItem` en lugar de interpretar eso como una anotaci√≥n de tipo.

## Lista de modelos

De la misma manera, puedes declarar responses de listas de objetos.

Para eso, usa el `typing.List` est√°ndar de Python (o simplemente `list` en Python 3.9 y posteriores):

{* ../../docs_src/extra_models/tutorial004_py39.py hl[18] *}


## Response con `dict` arbitrario

Tambi√©n puedes declarar un response usando un `dict` arbitrario plano, declarando solo el tipo de las claves y valores, sin usar un modelo Pydantic.

Esto es √∫til si no conoces los nombres de los campos/atributos v√°lidos (que ser√≠an necesarios para un modelo Pydantic) de antemano.

En este caso, puedes usar `typing.Dict` (o solo `dict` en Python 3.9 y posteriores):

{* ../../docs_src/extra_models/tutorial005_py39.py hl[6] *}


## Recapitulaci√≥n

Usa m√∫ltiples modelos Pydantic y hereda libremente para cada caso.

No necesitas tener un solo modelo de datos por entidad si esa entidad debe poder tener diferentes "estados". Como el caso con la "entidad" usuario con un estado que incluye `password`, `password_hash` y sin contrase√±a.


================================================
File: /docs/es/docs/tutorial/first-steps.md
================================================
# Primeros Pasos

El archivo FastAPI m√°s simple podr√≠a verse as√≠:

{* ../../docs_src/first_steps/tutorial001.py *}

Copia eso en un archivo `main.py`.

Ejecuta el servidor en vivo:

<div class="termy">

```console
$ <font color="#4E9A06">fastapi</font> dev <u style="text-decoration-style:single">main.py</u>
<font color="#3465A4">INFO    </font> Using path <font color="#3465A4">main.py</font>
<font color="#3465A4">INFO    </font> Resolved absolute path <font color="#75507B">/home/user/code/awesomeapp/</font><font color="#AD7FA8">main.py</font>
<font color="#3465A4">INFO    </font> Searching for package file structure from directories with <font color="#3465A4">__init__.py</font> files
<font color="#3465A4">INFO    </font> Importing from <font color="#75507B">/home/user/code/</font><font color="#AD7FA8">awesomeapp</font>

 ‚ï≠‚îÄ <font color="#8AE234"><b>Python module file</b></font> ‚îÄ‚ïÆ
 ‚îÇ                      ‚îÇ
 ‚îÇ  üêç main.py          ‚îÇ
 ‚îÇ                      ‚îÇ
 ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

<font color="#3465A4">INFO    </font> Importing module <font color="#4E9A06">main</font>
<font color="#3465A4">INFO    </font> Found importable FastAPI app

 ‚ï≠‚îÄ <font color="#8AE234"><b>Importable FastAPI app</b></font> ‚îÄ‚ïÆ
 ‚îÇ                          ‚îÇ
 ‚îÇ  <span style="background-color:#272822"><font color="#FF4689">from</font></span><span style="background-color:#272822"><font color="#F8F8F2"> main </font></span><span style="background-color:#272822"><font color="#FF4689">import</font></span><span style="background-color:#272822"><font color="#F8F8F2"> app</font></span><span style="background-color:#272822">  </span>  ‚îÇ
 ‚îÇ                          ‚îÇ
 ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

<font color="#3465A4">INFO    </font> Using import string <font color="#8AE234"><b>main:app</b></font>

 <span style="background-color:#C4A000"><font color="#2E3436">‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FastAPI CLI - Development mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ                                                     ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ  Serving at: http://127.0.0.1:8000                  ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ                                                     ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ  API docs: http://127.0.0.1:8000/docs               ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ                                                     ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ  Running in development mode, for production use:   ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ                                                     ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ  </font></span><span style="background-color:#C4A000"><font color="#555753"><b>fastapi run</b></font></span><span style="background-color:#C4A000"><font color="#2E3436">                                        ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ                                                     ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font></span>

<font color="#4E9A06">INFO</font>:     Will watch for changes in these directories: [&apos;/home/user/code/awesomeapp&apos;]
<font color="#4E9A06">INFO</font>:     Uvicorn running on <b>http://127.0.0.1:8000</b> (Press CTRL+C to quit)
<font color="#4E9A06">INFO</font>:     Started reloader process [<font color="#34E2E2"><b>2265862</b></font>] using <font color="#34E2E2"><b>WatchFiles</b></font>
<font color="#4E9A06">INFO</font>:     Started server process [<font color="#06989A">2265873</font>]
<font color="#4E9A06">INFO</font>:     Waiting for application startup.
<font color="#4E9A06">INFO</font>:     Application startup complete.
```

</div>

En el resultado, hay una l√≠nea con algo como:

```hl_lines="4"
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

Esa l√≠nea muestra la URL donde tu aplicaci√≥n est√° siendo servida, en tu m√°quina local.

### Compru√©balo

Abre tu navegador en <a href="http://127.0.0.1:8000" class="external-link" target="_blank">http://127.0.0.1:8000</a>.

Ver√°s el response JSON como:

```JSON
{"message": "Hello World"}
```

### Documentaci√≥n interactiva de la API

Ahora ve a <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

Ver√°s la documentaci√≥n interactiva autom√°tica de la API (proporcionada por <a href="https://github.com/swagger-api/swagger-ui" class="external-link" target="_blank">Swagger UI</a>):

![Swagger UI](https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png)

### Documentaci√≥n alternativa de la API

Y ahora, ve a <a href="http://127.0.0.1:8000/redoc" class="external-link" target="_blank">http://127.0.0.1:8000/redoc</a>.

Ver√°s la documentaci√≥n alternativa autom√°tica (proporcionada por <a href="https://github.com/Rebilly/ReDoc" class="external-link" target="_blank">ReDoc</a>):

![ReDoc](https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png)

### OpenAPI

**FastAPI** genera un "esquema" con toda tu API utilizando el est√°ndar **OpenAPI** para definir APIs.

#### "Esquema"

Un "esquema" es una definici√≥n o descripci√≥n de algo. No el c√≥digo que lo implementa, sino solo una descripci√≥n abstracta.

#### Esquema de la API

En este caso, <a href="https://github.com/OAI/OpenAPI-Specification" class="external-link" target="_blank">OpenAPI</a> es una especificaci√≥n que dicta c√≥mo definir un esquema de tu API.

Esta definici√≥n de esquema incluye los paths de tu API, los posibles par√°metros que toman, etc.

#### Esquema de Datos

El t√©rmino "esquema" tambi√©n podr√≠a referirse a la forma de algunos datos, como el contenido JSON.

En ese caso, significar√≠a los atributos del JSON, los tipos de datos que tienen, etc.

#### OpenAPI y JSON Schema

OpenAPI define un esquema de API para tu API. Y ese esquema incluye definiciones (o "esquemas") de los datos enviados y recibidos por tu API utilizando **JSON Schema**, el est√°ndar para esquemas de datos JSON.

#### Revisa el `openapi.json`

Si tienes curiosidad por c√≥mo se ve el esquema OpenAPI en bruto, FastAPI autom√°ticamente genera un JSON (esquema) con las descripciones de toda tu API.

Puedes verlo directamente en: <a href="http://127.0.0.1:8000/openapi.json" class="external-link" target="_blank">http://127.0.0.1:8000/openapi.json</a>.

Mostrar√° un JSON que empieza con algo como:

```JSON
{
    "openapi": "3.1.0",
    "info": {
        "title": "FastAPI",
        "version": "0.1.0"
    },
    "paths": {
        "/items/": {
            "get": {
                "responses": {
                    "200": {
                        "description": "Successful Response",
                        "content": {
                            "application/json": {



...
```

#### Para qu√© sirve OpenAPI

El esquema OpenAPI es lo que impulsa los dos sistemas de documentaci√≥n interactiva incluidos.

Y hay docenas de alternativas, todas basadas en OpenAPI. Podr√≠as a√±adir f√°cilmente cualquiera de esas alternativas a tu aplicaci√≥n construida con **FastAPI**.

Tambi√©n podr√≠as usarlo para generar c√≥digo autom√°ticamente, para clientes que se comuniquen con tu API. Por ejemplo, aplicaciones frontend, m√≥viles o IoT.

## Recapitulaci√≥n, paso a paso

### Paso 1: importa `FastAPI`

{* ../../docs_src/first_steps/tutorial001.py hl[1] *}

`FastAPI` es una clase de Python que proporciona toda la funcionalidad para tu API.

/// note | Detalles T√©cnicos

`FastAPI` es una clase que hereda directamente de `Starlette`.

Puedes usar toda la funcionalidad de <a href="https://www.starlette.io/" class="external-link" target="_blank">Starlette</a> con `FastAPI` tambi√©n.

///

### Paso 2: crea una "instance" de `FastAPI`

{* ../../docs_src/first_steps/tutorial001.py hl[3] *}

Aqu√≠ la variable `app` ser√° una "instance" de la clase `FastAPI`.

Este ser√° el punto principal de interacci√≥n para crear toda tu API.

### Paso 3: crea una *path operation*

#### Path

"Path" aqu√≠ se refiere a la √∫ltima parte de la URL empezando desde la primera `/`.

As√≠ que, en una URL como:

```
https://example.com/items/foo
```

...el path ser√≠a:

```
/items/foo
```

/// info

Un "path" tambi√©n es com√∫nmente llamado "endpoint" o "ruta".

///

Mientras construyes una API, el "path" es la forma principal de separar "concerns" y "resources".

#### Operaci√≥n

"Operaci√≥n" aqu√≠ se refiere a uno de los "m√©todos" HTTP.

Uno de:

* `POST`
* `GET`
* `PUT`
* `DELETE`

...y los m√°s ex√≥ticos:

* `OPTIONS`
* `HEAD`
* `PATCH`
* `TRACE`

En el protocolo HTTP, puedes comunicarte con cada path usando uno (o m√°s) de estos "m√©todos".

---

Al construir APIs, normalmente usas estos m√©todos HTTP espec√≠ficos para realizar una acci√≥n espec√≠fica.

Normalmente usas:

* `POST`: para crear datos.
* `GET`: para leer datos.
* `PUT`: para actualizar datos.
* `DELETE`: para eliminar datos.

As√≠ que, en OpenAPI, cada uno de los m√©todos HTTP se llama una "operation".

Vamos a llamarlas "**operaciones**" tambi√©n.

#### Define un *path operation decorator*

{* ../../docs_src/first_steps/tutorial001.py hl[6] *}

El `@app.get("/")` le dice a **FastAPI** que la funci√≥n justo debajo se encarga de manejar requests que vayan a:

* el path `/`
* usando una <abbr title="un m√©todo HTTP GET"><code>get</code> operation</abbr>

/// info | Informaci√≥n sobre `@decorator`

Esa sintaxis `@algo` en Python se llama un "decorador".

Lo pones encima de una funci√≥n. Como un bonito sombrero decorativo (supongo que de ah√≠ viene el t√©rmino).

Un "decorador" toma la funci√≥n de abajo y hace algo con ella.

En nuestro caso, este decorador le dice a **FastAPI** que la funci√≥n de abajo corresponde al **path** `/` con una **operation** `get`.

Es el "**path operation decorator**".

///

Tambi√©n puedes usar las otras operaciones:

* `@app.post()`
* `@app.put()`
* `@app.delete()`

Y los m√°s ex√≥ticos:

* `@app.options()`
* `@app.head()`
* `@app.patch()`
* `@app.trace()`

/// tip

Eres libre de usar cada operaci√≥n (m√©todo HTTP) como quieras.

**FastAPI** no fuerza ning√∫n significado espec√≠fico.

La informaci√≥n aqu√≠ se presenta como una gu√≠a, no un requisito.

Por ejemplo, cuando usas GraphQL normalmente realizas todas las acciones usando solo operaciones `POST`.

///

### Paso 4: define la **path operation function**

Esta es nuestra "**path operation function**":

* **path**: es `/`.
* **operation**: es `get`.
* **function**: es la funci√≥n debajo del "decorador" (debajo de `@app.get("/")`).

{* ../../docs_src/first_steps/tutorial001.py hl[7] *}

Esta es una funci√≥n de Python.

Ser√° llamada por **FastAPI** cuando reciba un request en la URL "`/`" usando una operaci√≥n `GET`.

En este caso, es una funci√≥n `async`.

---

Tambi√©n podr√≠as definirla como una funci√≥n normal en lugar de `async def`:

{* ../../docs_src/first_steps/tutorial003.py hl[7] *}

/// note | Nota

Si no sabes la diferencia, revisa la secci√≥n [Async: *"¬øTienes prisa?"*](../async.md#in-a-hurry){.internal-link target=_blank}.

///

### Paso 5: retorna el contenido

{* ../../docs_src/first_steps/tutorial001.py hl[8] *}

Puedes retornar un `dict`, `list`, valores singulares como `str`, `int`, etc.

Tambi√©n puedes retornar modelos de Pydantic (ver√°s m√°s sobre eso m√°s adelante).

Hay muchos otros objetos y modelos que ser√°n autom√°ticamente convertidos a JSON (incluyendo ORMs, etc). Intenta usar tus favoritos, es altamente probable que ya sean compatibles.

## Recapitulaci√≥n

* Importa `FastAPI`.
* Crea una instancia `app`.
* Escribe un **path operation decorator** usando decoradores como `@app.get("/")`.
* Define una **path operation function**; por ejemplo, `def root(): ...`.
* Ejecuta el servidor de desarrollo usando el comando `fastapi dev`.


================================================
File: /docs/es/docs/tutorial/handling-errors.md
================================================
# Manejo de Errores

Existen muchas situaciones en las que necesitas notificar un error a un cliente que est√° usando tu API.

Este cliente podr√≠a ser un navegador con un frontend, un c√≥digo de otra persona, un dispositivo IoT, etc.

Podr√≠as necesitar decirle al cliente que:

* El cliente no tiene suficientes privilegios para esa operaci√≥n.
* El cliente no tiene acceso a ese recurso.
* El √≠tem al que el cliente intentaba acceder no existe.
* etc.

En estos casos, normalmente devolver√≠as un **c√≥digo de estado HTTP** en el rango de **400** (de 400 a 499).

Esto es similar a los c√≥digos de estado HTTP 200 (de 200 a 299). Esos c√≥digos de estado "200" significan que de alguna manera hubo un "√©xito" en el request.

Los c√≥digos de estado en el rango de 400 significan que hubo un error por parte del cliente.

¬øRecuerdas todos esos errores de **"404 Not Found"** (y chistes)?

## Usa `HTTPException`

Para devolver responses HTTP con errores al cliente, usa `HTTPException`.

### Importa `HTTPException`

{* ../../docs_src/handling_errors/tutorial001.py hl[1] *}

### Lanza un `HTTPException` en tu c√≥digo

`HTTPException` es una excepci√≥n de Python normal con datos adicionales relevantes para APIs.

Debido a que es una excepci√≥n de Python, no la `return`, sino que la `raise`.

Esto tambi√©n significa que si est√°s dentro de una funci√≥n de utilidad que est√°s llamando dentro de tu *path operation function*, y lanzas el `HTTPException` desde dentro de esa funci√≥n de utilidad, no se ejecutar√° el resto del c√≥digo en la *path operation function*, terminar√° ese request de inmediato y enviar√° el error HTTP del `HTTPException` al cliente.

El beneficio de lanzar una excepci√≥n en lugar de `return`ar un valor ser√° m√°s evidente en la secci√≥n sobre Dependencias y Seguridad.

En este ejemplo, cuando el cliente solicita un √≠tem por un ID que no existe, lanza una excepci√≥n con un c√≥digo de estado de `404`:

{* ../../docs_src/handling_errors/tutorial001.py hl[11] *}

### El response resultante

Si el cliente solicita `http://example.com/items/foo` (un `item_id` `"foo"`), ese cliente recibir√° un c√≥digo de estado HTTP de 200, y un response JSON de:

```JSON
{
  "item": "The Foo Wrestlers"
}
```

Pero si el cliente solicita `http://example.com/items/bar` (un `item_id` inexistente `"bar"`), ese cliente recibir√° un c√≥digo de estado HTTP de 404 (el error "no encontrado"), y un response JSON de:

```JSON
{
  "detail": "Item not found"
}
```

/// tip | Consejo

Cuando lanzas un `HTTPException`, puedes pasar cualquier valor que pueda convertirse a JSON como el par√°metro `detail`, no solo `str`.

Podr√≠as pasar un `dict`, un `list`, etc.

Son manejados autom√°ticamente por **FastAPI** y convertidos a JSON.

///

## Agrega headers personalizados

Existen algunas situaciones en las que es √∫til poder agregar headers personalizados al error HTTP. Por ejemplo, para algunos tipos de seguridad.

Probablemente no necesitar√°s usarlos directamente en tu c√≥digo.

Pero en caso de que los necesites para un escenario avanzado, puedes agregar headers personalizados:

{* ../../docs_src/handling_errors/tutorial002.py hl[14] *}

## Instalar manejadores de excepciones personalizados

Puedes agregar manejadores de excepciones personalizados con <a href="https://www.starlette.io/exceptions/" class="external-link" target="_blank">las mismas utilidades de excepciones de Starlette</a>.

Supongamos que tienes una excepci√≥n personalizada `UnicornException` que t√∫ (o un paquete que usas) podr√≠a lanzar.

Y quieres manejar esta excepci√≥n globalmente con FastAPI.

Podr√≠as agregar un manejador de excepciones personalizado con `@app.exception_handler()`:

{* ../../docs_src/handling_errors/tutorial003.py hl[5:7,13:18,24] *}

Aqu√≠, si solicitas `/unicorns/yolo`, la *path operation* lanzar√° un `UnicornException`.

Pero ser√° manejado por el `unicorn_exception_handler`.

As√≠ que recibir√°s un error limpio, con un c√≥digo de estado HTTP de `418` y un contenido JSON de:

```JSON
{"message": "Oops! yolo did something. There goes a rainbow..."}
```

/// note | Nota T√©cnica

Tambi√©n podr√≠as usar `from starlette.requests import Request` y `from starlette.responses import JSONResponse`.

**FastAPI** ofrece las mismas `starlette.responses` como `fastapi.responses` solo como una conveniencia para ti, el desarrollador. Pero la mayor√≠a de los responses disponibles vienen directamente de Starlette. Lo mismo con `Request`.

///

## Sobrescribir los manejadores de excepciones predeterminados

**FastAPI** tiene algunos manejadores de excepciones predeterminados.

Estos manejadores se encargan de devolver los responses JSON predeterminadas cuando lanzas un `HTTPException` y cuando el request tiene datos inv√°lidos.

Puedes sobrescribir estos manejadores de excepciones con los tuyos propios.

### Sobrescribir excepciones de validaci√≥n de request

Cuando un request contiene datos inv√°lidos, **FastAPI** lanza internamente un `RequestValidationError`.

Y tambi√©n incluye un manejador de excepciones predeterminado para ello.

Para sobrescribirlo, importa el `RequestValidationError` y √∫salo con `@app.exception_handler(RequestValidationError)` para decorar el manejador de excepciones.

El manejador de excepciones recibir√° un `Request` y la excepci√≥n.

{* ../../docs_src/handling_errors/tutorial004.py hl[2,14:16] *}

Ahora, si vas a `/items/foo`, en lugar de obtener el error JSON por defecto con:

```JSON
{
    "detail": [
        {
            "loc": [
                "path",
                "item_id"
            ],
            "msg": "value is not a valid integer",
            "type": "type_error.integer"
        }
    ]
}
```

obtendr√°s una versi√≥n en texto, con:

```
1 validation error
path -> item_id
  value is not a valid integer (type=type_error.integer)
```

#### `RequestValidationError` vs `ValidationError`

/// warning | Advertencia

Estos son detalles t√©cnicos que podr√≠as omitir si no es importante para ti en este momento.

///

`RequestValidationError` es una subclase de <a href="https://docs.pydantic.dev/latest/concepts/models/#error-handling" class="external-link" target="_blank">`ValidationError`</a> de Pydantic.

**FastAPI** la usa para que, si usas un modelo Pydantic en `response_model`, y tus datos tienen un error, lo ver√°s en tu log.

Pero el cliente/usuario no lo ver√°. En su lugar, el cliente recibir√° un "Error Interno del Servidor" con un c√≥digo de estado HTTP `500`.

Deber√≠a ser as√≠ porque si tienes un `ValidationError` de Pydantic en tu *response* o en cualquier lugar de tu c√≥digo (no en el *request* del cliente), en realidad es un bug en tu c√≥digo.

Y mientras lo arreglas, tus clientes/usuarios no deber√≠an tener acceso a informaci√≥n interna sobre el error, ya que eso podr√≠a exponer una vulnerabilidad de seguridad.

### Sobrescribir el manejador de errores de `HTTPException`

De la misma manera, puedes sobrescribir el manejador de `HTTPException`.

Por ejemplo, podr√≠as querer devolver un response de texto plano en lugar de JSON para estos errores:

{* ../../docs_src/handling_errors/tutorial004.py hl[3:4,9:11,22] *}

/// note | Nota T√©cnica

Tambi√©n podr√≠as usar `from starlette.responses import PlainTextResponse`.

**FastAPI** ofrece las mismas `starlette.responses` como `fastapi.responses` solo como una conveniencia para ti, el desarrollador. Pero la mayor√≠a de los responses disponibles vienen directamente de Starlette.

///

### Usar el body de `RequestValidationError`

El `RequestValidationError` contiene el `body` que recibi√≥ con datos inv√°lidos.

Podr√≠as usarlo mientras desarrollas tu aplicaci√≥n para registrar el body y depurarlo, devolverlo al usuario, etc.

{* ../../docs_src/handling_errors/tutorial005.py hl[14] *}

Ahora intenta enviar un √≠tem inv√°lido como:

```JSON
{
  "title": "towel",
  "size": "XL"
}
```

Recibir√°s un response que te dir√° que los datos son inv√°lidos conteniendo el body recibido:

```JSON hl_lines="12-15"
{
  "detail": [
    {
      "loc": [
        "body",
        "size"
      ],
      "msg": "value is not a valid integer",
      "type": "type_error.integer"
    }
  ],
  "body": {
    "title": "towel",
    "size": "XL"
  }
}
```

#### `HTTPException` de FastAPI vs `HTTPException` de Starlette

**FastAPI** tiene su propio `HTTPException`.

Y la clase de error `HTTPException` de **FastAPI** hereda de la clase de error `HTTPException` de Starlette.

La √∫nica diferencia es que el `HTTPException` de **FastAPI** acepta cualquier dato JSON-able para el campo `detail`, mientras que el `HTTPException` de Starlette solo acepta strings para ello.

As√≠ que puedes seguir lanzando un `HTTPException` de **FastAPI** como de costumbre en tu c√≥digo.

Pero cuando registras un manejador de excepciones, deber√≠as registrarlo para el `HTTPException` de Starlette.

De esta manera, si alguna parte del c√≥digo interno de Starlette, o una extensi√≥n o complemento de Starlette, lanza un `HTTPException` de Starlette, tu manejador podr√° capturarlo y manejarlo.

En este ejemplo, para poder tener ambos `HTTPException` en el mismo c√≥digo, las excepciones de Starlette son renombradas a `StarletteHTTPException`:

```Python
from starlette.exceptions import HTTPException as StarletteHTTPException
```

### Reutilizar los manejadores de excepciones de **FastAPI**

Si quieres usar la excepci√≥n junto con los mismos manejadores de excepciones predeterminados de **FastAPI**, puedes importar y reutilizar los manejadores de excepciones predeterminados de `fastapi.exception_handlers`:

{* ../../docs_src/handling_errors/tutorial006.py hl[2:5,15,21] *}

En este ejemplo solo est√°s `print`eando el error con un mensaje muy expresivo, pero te haces una idea. Puedes usar la excepci√≥n y luego simplemente reutilizar los manejadores de excepciones predeterminados.


================================================
File: /docs/es/docs/tutorial/header-param-models.md
================================================
# Modelos de Par√°metros de Header

Si tienes un grupo de **par√°metros de header** relacionados, puedes crear un **modelo Pydantic** para declararlos.

Esto te permitir√° **reutilizar el modelo** en **m√∫ltiples lugares** y tambi√©n declarar validaciones y metadatos para todos los par√°metros al mismo tiempo. üòé

/// note | Nota

Esto es compatible desde la versi√≥n `0.115.0` de FastAPI. ü§ì

///

## Par√°metros de Header con un Modelo Pydantic

Declara los **par√°metros de header** que necesitas en un **modelo Pydantic**, y luego declara el par√°metro como `Header`:

{* ../../docs_src/header_param_models/tutorial001_an_py310.py hl[9:14,18] *}

**FastAPI** **extraer√°** los datos para **cada campo** de los **headers** en el request y te dar√° el modelo Pydantic que definiste.

## Revisa la Documentaci√≥n

Puedes ver los headers requeridos en la interfaz de documentaci√≥n en `/docs`:

<div class="screenshot">
<img src="/img/tutorial/header-param-models/image01.png">
</div>

## Prohibir Headers Extra

En algunos casos de uso especiales (probablemente no muy comunes), podr√≠as querer **restringir** los headers que deseas recibir.

Puedes usar la configuraci√≥n del modelo de Pydantic para `prohibir` cualquier campo `extra`:

{* ../../docs_src/header_param_models/tutorial002_an_py310.py hl[10] *}

Si un cliente intenta enviar algunos **headers extra**, recibir√°n un response de **error**.

Por ejemplo, si el cliente intenta enviar un header `tool` con un valor de `plumbus`, recibir√°n un response de **error** indicando que el par√°metro de header `tool` no est√° permitido:

```json
{
    "detail": [
        {
            "type": "extra_forbidden",
            "loc": ["header", "tool"],
            "msg": "Extra inputs are not permitted",
            "input": "plumbus",
        }
    ]
}
```

## Resumen

Puedes usar **modelos Pydantic** para declarar **headers** en **FastAPI**. üòé


================================================
File: /docs/es/docs/tutorial/header-params.md
================================================
# Par√°metros de Header

Puedes definir los par√°metros de Header de la misma manera que defines los par√°metros de `Query`, `Path` y `Cookie`.

## Importar `Header`

Primero importa `Header`:

{* ../../docs_src/header_params/tutorial001_an_py310.py hl[3] *}

## Declarar par√°metros de `Header`

Luego declara los par√°metros de header usando la misma estructura que con `Path`, `Query` y `Cookie`.

Puedes definir el valor por defecto as√≠ como toda la validaci√≥n extra o los par√°metros de anotaciones:

{* ../../docs_src/header_params/tutorial001_an_py310.py hl[9] *}

/// note | Detalles T√©cnicos

`Header` es una clase "hermana" de `Path`, `Query` y `Cookie`. Tambi√©n hereda de la misma clase com√∫n `Param`.

Pero recuerda que cuando importas `Query`, `Path`, `Header`, y otros de `fastapi`, en realidad son funciones que retornan clases especiales.

///

/// info | Informaci√≥n

Para declarar headers, necesitas usar `Header`, porque de otra forma los par√°metros ser√≠an interpretados como par√°metros de query.

///

## Conversi√≥n autom√°tica

`Header` tiene un poquito de funcionalidad extra adem√°s de lo que proporcionan `Path`, `Query` y `Cookie`.

La mayor√≠a de los headers est√°ndar est√°n separados por un car√°cter "guion", tambi√©n conocido como el "s√≠mbolo menos" (`-`).

Pero una variable como `user-agent` es inv√°lida en Python.

As√≠ que, por defecto, `Header` convertir√° los caracteres de los nombres de los par√°metros de guion bajo (`_`) a guion (`-`) para extraer y documentar los headers.

Adem√°s, los headers HTTP no diferencian entre may√∫sculas y min√∫sculas, por lo que los puedes declarar con el estilo est√°ndar de Python (tambi√©n conocido como "snake_case").

As√≠ que, puedes usar `user_agent` como normalmente lo har√≠as en c√≥digo Python, en lugar de necesitar capitalizar las primeras letras como `User_Agent` o algo similar.

Si por alguna raz√≥n necesitas desactivar la conversi√≥n autom√°tica de guiones bajos a guiones, establece el par√°metro `convert_underscores` de `Header` a `False`:

{* ../../docs_src/header_params/tutorial002_an_py310.py hl[10] *}

/// warning | Advertencia

Antes de establecer `convert_underscores` a `False`, ten en cuenta que algunos proxies y servidores HTTP no permiten el uso de headers con guiones bajos.

///

## Headers duplicados

Es posible recibir headers duplicados. Eso significa, el mismo header con m√∫ltiples valores.

Puedes definir esos casos usando una lista en la declaraci√≥n del tipo.

Recibir√°s todos los valores del header duplicado como una `list` de Python.

Por ejemplo, para declarar un header de `X-Token` que puede aparecer m√°s de una vez, puedes escribir:

{* ../../docs_src/header_params/tutorial003_an_py310.py hl[9] *}

Si te comunicas con esa *path operation* enviando dos headers HTTP como:

```
X-Token: foo
X-Token: bar
```

El response ser√≠a como:

```JSON
{
    "X-Token values": [
        "bar",
        "foo"
    ]
}
```

## Recapitulaci√≥n

Declara headers con `Header`, usando el mismo patr√≥n com√∫n que `Query`, `Path` y `Cookie`.

Y no te preocupes por los guiones bajos en tus variables, **FastAPI** se encargar√° de convertirlos.


================================================
File: /docs/es/docs/tutorial/index.md
================================================
# Tutorial - Gu√≠a del Usuario

Este tutorial te muestra c√≥mo usar **FastAPI** con la mayor√≠a de sus funcionalidades, paso a paso.

Cada secci√≥n se basa gradualmente en las anteriores, pero est√° estructurada para separar temas, de manera que puedas ir directamente a cualquier secci√≥n espec√≠fica para resolver tus necesidades espec√≠ficas de API.

Tambi√©n est√° dise√±ado para funcionar como una referencia futura para que puedas volver y ver exactamente lo que necesitas.

## Ejecuta el c√≥digo

Todos los bloques de c√≥digo pueden ser copiados y usados directamente (de hecho, son archivos Python probados).

Para ejecutar cualquiera de los ejemplos, copia el c√≥digo a un archivo `main.py`, y comienza `fastapi dev` con:

<div class="termy">

```console
$ <font color="#4E9A06">fastapi</font> dev <u style="text-decoration-style:single">main.py</u>
<font color="#3465A4">INFO    </font> Using path <font color="#3465A4">main.py</font>
<font color="#3465A4">INFO    </font> Resolved absolute path <font color="#75507B">/home/user/code/awesomeapp/</font><font color="#AD7FA8">main.py</font>
<font color="#3465A4">INFO    </font> Searching for package file structure from directories with <font color="#3465A4">__init__.py</font> files
<font color="#3465A4">INFO    </font> Importing from <font color="#75507B">/home/user/code/</font><font color="#AD7FA8">awesomeapp</font>

 ‚ï≠‚îÄ <font color="#8AE234"><b>Python module file</b></font> ‚îÄ‚ïÆ
 ‚îÇ                      ‚îÇ
 ‚îÇ  üêç main.py          ‚îÇ
 ‚îÇ                      ‚îÇ
 ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

<font color="#3465A4">INFO    </font> Importing module <font color="#4E9A06">main</font>
<font color="#3465A4">INFO    </font> Found importable FastAPI app

 ‚ï≠‚îÄ <font color="#8AE234"><b>Importable FastAPI app</b></font> ‚îÄ‚ïÆ
 ‚îÇ                          ‚îÇ
 ‚îÇ  <span style="background-color:#272822"><font color="#FF4689">from</font></span><span style="background-color:#272822"><font color="#F8F8F2"> main </font></span><span style="background-color:#272822"><font color="#FF4689">import</font></span><span style="background-color:#272822"><font color="#F8F8F2"> app</font></span><span style="background-color:#272822">  </span>  ‚îÇ
 ‚îÇ                          ‚îÇ
 ‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ

<font color="#3465A4">INFO    </font> Using import string <font color="#8AE234"><b>main:app</b></font>

 <span style="background-color:#C4A000"><font color="#2E3436">‚ï≠‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ FastAPI CLI - Development mode ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïÆ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ                                                     ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ  Serving at: http://127.0.0.1:8000                  ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ                                                     ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ  API docs: http://127.0.0.1:8000/docs               ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ                                                     ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ  Running in development mode, for production use:   ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ                                                     ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ  </font></span><span style="background-color:#C4A000"><font color="#555753"><b>fastapi run</b></font></span><span style="background-color:#C4A000"><font color="#2E3436">                                        ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚îÇ                                                     ‚îÇ</font></span>
 <span style="background-color:#C4A000"><font color="#2E3436">‚ï∞‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ïØ</font></span>

<font color="#4E9A06">INFO</font>:     Will watch for changes in these directories: [&apos;/home/user/code/awesomeapp&apos;]
<font color="#4E9A06">INFO</font>:     Uvicorn running on <b>http://127.0.0.1:8000</b> (Press CTRL+C to quit)
<font color="#4E9A06">INFO</font>:     Started reloader process [<font color="#34E2E2"><b>2265862</b></font>] using <font color="#34E2E2"><b>WatchFiles</b></font>
<font color="#4E9A06">INFO</font>:     Started server process [<font color="#06989A">2265873</font>]
<font color="#4E9A06">INFO</font>:     Waiting for application startup.
<font color="#4E9A06">INFO</font>:     Application startup complete.
</pre>
```

</div>

Es **ALTAMENTE recomendable** que escribas o copies el c√≥digo, lo edites y lo ejecutes localmente.

Usarlo en tu editor es lo que realmente te muestra los beneficios de FastAPI, al ver cu√°n poco c√≥digo tienes que escribir, todos los chequeos de tipos, autocompletado, etc.

---

## Instalar FastAPI

El primer paso es instalar FastAPI.

Aseg√∫rate de crear un [entorno virtual](../virtual-environments.md){.internal-link target=_blank}, act√≠valo, y luego **instala FastAPI**:

<div class="termy">

```console
$ pip install "fastapi[standard]"

---> 100%
```

</div>

/// note | Nota

Cuando instalas con `pip install "fastapi[standard]"` viene con algunas dependencias opcionales est√°ndar por defecto.

Si no quieres tener esas dependencias opcionales, en su lugar puedes instalar `pip install fastapi`.

///

## Gu√≠a Avanzada del Usuario

Tambi√©n hay una **Gu√≠a Avanzada del Usuario** que puedes leer despu√©s de esta **Tutorial - Gu√≠a del Usuario**.

La **Gu√≠a Avanzada del Usuario** se basa en esta, utiliza los mismos conceptos y te ense√±a algunas funcionalidades adicionales.

Pero primero deber√≠as leer la **Tutorial - Gu√≠a del Usuario** (lo que est√°s leyendo ahora mismo).

Est√° dise√±ada para que puedas construir una aplicaci√≥n completa solo con la **Tutorial - Gu√≠a del Usuario**, y luego extenderla de diferentes maneras, dependiendo de tus necesidades, utilizando algunas de las ideas adicionales de la **Gu√≠a Avanzada del Usuario**.


================================================
File: /docs/es/docs/tutorial/metadata.md
================================================
# Metadata y URLs de Docs

Puedes personalizar varias configuraciones de metadata en tu aplicaci√≥n **FastAPI**.

## Metadata para la API

Puedes establecer los siguientes campos que se usan en la especificaci√≥n OpenAPI y en las interfaces autom√°ticas de documentaci√≥n de la API:

| Par√°metro | Tipo | Descripci√≥n |
|------------|------|-------------|
| `title` | `str` | El t√≠tulo de la API. |
| `summary` | `str` | Un resumen corto de la API. <small>Disponible desde OpenAPI 3.1.0, FastAPI 0.99.0.</small> |
| `description` | `str` | Una breve descripci√≥n de la API. Puede usar Markdown. |
| `version` | `string` | La versi√≥n de la API. Esta es la versi√≥n de tu propia aplicaci√≥n, no de OpenAPI. Por ejemplo, `2.5.0`. |
| `terms_of_service` | `str` | Una URL a los T√©rminos de Servicio para la API. Si se proporciona, debe ser una URL. |
| `contact` | `dict` | La informaci√≥n de contacto para la API expuesta. Puede contener varios campos. <details><summary><code>contact</code> fields</summary><table><thead><tr><th>Par√°metro</th><th>Tipo</th><th>Descripci√≥n</th></tr></thead><tbody><tr><td><code>name</code></td><td><code>str</code></td><td>El nombre identificativo de la persona/organizaci√≥n de contacto.</td></tr><tr><td><code>url</code></td><td><code>str</code></td><td>La URL que apunta a la informaci√≥n de contacto. DEBE tener el formato de una URL.</td></tr><tr><td><code>email</code></td><td><code>str</code></td><td>La direcci√≥n de correo electr√≥nico de la persona/organizaci√≥n de contacto. DEBE tener el formato de una direcci√≥n de correo.</td></tr></tbody></table></details> |
| `license_info` | `dict` | La informaci√≥n de la licencia para la API expuesta. Puede contener varios campos. <details><summary><code>license_info</code> fields</summary><table><thead><tr><th>Par√°metro</th><th>Tipo</th><th>Descripci√≥n</th></tr></thead><tbody><tr><td><code>name</code></td><td><code>str</code></td><td><strong>REQUERIDO</strong> (si se establece un <code>license_info</code>). El nombre de la licencia utilizada para la API.</td></tr><tr><td><code>identifier</code></td><td><code>str</code></td><td>Una expresi√≥n de licencia <a href="https://spdx.org/licenses/" class="external-link" target="_blank">SPDX</a> para la API. El campo <code>identifier</code> es mutuamente excluyente del campo <code>url</code>. <small>Disponible desde OpenAPI 3.1.0, FastAPI 0.99.0.</small></td></tr><tr><td><code>url</code></td><td><code>str</code></td><td>Una URL a la licencia utilizada para la API. DEBE tener el formato de una URL.</td></tr></tbody></table></details> |

Puedes configurarlos de la siguiente manera:

{* ../../docs_src/metadata/tutorial001.py hl[3:16, 19:32] *}

/// tip | Consejo

Puedes escribir Markdown en el campo `description` y se mostrar√° en el resultado.

///

Con esta configuraci√≥n, la documentaci√≥n autom√°tica de la API se ver√≠a as√≠:

<img src="/img/tutorial/metadata/image01.png">

## Identificador de licencia

Desde OpenAPI 3.1.0 y FastAPI 0.99.0, tambi√©n puedes establecer la `license_info` con un `identifier` en lugar de una `url`.

Por ejemplo:

{* ../../docs_src/metadata/tutorial001_1.py hl[31] *}

## Metadata para etiquetas

Tambi√©n puedes agregar metadata adicional para las diferentes etiquetas usadas para agrupar tus path operations con el par√°metro `openapi_tags`.

Este toma una list que contiene un diccionario para cada etiqueta.

Cada diccionario puede contener:

* `name` (**requerido**): un `str` con el mismo nombre de etiqueta que usas en el par√°metro `tags` en tus *path operations* y `APIRouter`s.
* `description`: un `str` con una breve descripci√≥n de la etiqueta. Puede tener Markdown y se mostrar√° en la interfaz de documentaci√≥n.
* `externalDocs`: un `dict` que describe documentaci√≥n externa con:
    * `description`: un `str` con una breve descripci√≥n para la documentaci√≥n externa.
    * `url` (**requerido**): un `str` con la URL para la documentaci√≥n externa.

### Crear metadata para etiquetas

Probemos eso en un ejemplo con etiquetas para `users` y `items`.

Crea metadata para tus etiquetas y p√°sala al par√°metro `openapi_tags`:

{* ../../docs_src/metadata/tutorial004.py hl[3:16,18] *}

Nota que puedes utilizar Markdown dentro de las descripciones, por ejemplo "login" se mostrar√° en negrita (**login**) y "fancy" se mostrar√° en cursiva (_fancy_).

/// tip | Consejo

No tienes que agregar metadata para todas las etiquetas que uses.

///

### Usar tus etiquetas

Usa el par√°metro `tags` con tus *path operations* (y `APIRouter`s) para asignarlas a diferentes etiquetas:

{* ../../docs_src/metadata/tutorial004.py hl[21,26] *}

/// info | Informaci√≥n

Lee m√°s sobre etiquetas en [Configuraci√≥n de Path Operation](path-operation-configuration.md#tags){.internal-link target=_blank}.

///

### Revisa la documentaci√≥n

Ahora, si revisas la documentaci√≥n, mostrar√° toda la metadata adicional:

<img src="/img/tutorial/metadata/image02.png">

### Orden de las etiquetas

El orden de cada diccionario de metadata de etiqueta tambi√©n define el orden mostrado en la interfaz de documentaci√≥n.

Por ejemplo, aunque `users` ir√≠a despu√©s de `items` en orden alfab√©tico, se muestra antes porque agregamos su metadata como el primer diccionario en la list.

## URL de OpenAPI

Por defecto, el esquema OpenAPI se sirve en `/openapi.json`.

Pero puedes configurarlo con el par√°metro `openapi_url`.

Por ejemplo, para configurarlo para que se sirva en `/api/v1/openapi.json`:

{* ../../docs_src/metadata/tutorial002.py hl[3] *}

Si quieres deshabilitar el esquema OpenAPI completamente, puedes establecer `openapi_url=None`, eso tambi√©n deshabilitar√° las interfaces de usuario de documentaci√≥n que lo usan.

## URLs de Docs

Puedes configurar las dos interfaces de usuario de documentaci√≥n incluidas:

* **Swagger UI**: servida en `/docs`.
    * Puedes establecer su URL con el par√°metro `docs_url`.
    * Puedes deshabilitarla estableciendo `docs_url=None`.
* **ReDoc**: servida en `/redoc`.
    * Puedes establecer su URL con el par√°metro `redoc_url`.
    * Puedes deshabilitarla estableciendo `redoc_url=None`.

Por ejemplo, para configurar Swagger UI para que se sirva en `/documentation` y deshabilitar ReDoc:

{* ../../docs_src/metadata/tutorial003.py hl[3] *}


================================================
File: /docs/es/docs/tutorial/middleware.md
================================================
# Middleware

Puedes a√±adir middleware a las aplicaciones de **FastAPI**.

Un "middleware" es una funci√≥n que trabaja con cada **request** antes de que sea procesada por cualquier *path operation* espec√≠fica. Y tambi√©n con cada **response** antes de devolverla.

* Toma cada **request** que llega a tu aplicaci√≥n.
* Puede entonces hacer algo a esa **request** o ejecutar cualquier c√≥digo necesario.
* Luego pasa la **request** para que sea procesada por el resto de la aplicaci√≥n (por alguna *path operation*).
* Despu√©s toma la **response** generada por la aplicaci√≥n (por alguna *path operation*).
* Puede hacer algo a esa **response** o ejecutar cualquier c√≥digo necesario.
* Luego devuelve la **response**.

/// note | Detalles T√©cnicos

Si tienes dependencias con `yield`, el c√≥digo de salida se ejecutar√° *despu√©s* del middleware.

Si hubiera alguna tarea en segundo plano (documentada m√°s adelante), se ejecutar√° *despu√©s* de todo el middleware.

///

## Crear un middleware

Para crear un middleware usas el decorador `@app.middleware("http")` encima de una funci√≥n.

La funci√≥n middleware recibe:

* La `request`.
* Una funci√≥n `call_next` que recibir√° la `request` como par√°metro.
    * Esta funci√≥n pasar√° la `request` a la correspondiente *path operation*.
    * Luego devuelve la `response` generada por la correspondiente *path operation*.
* Puedes entonces modificar a√∫n m√°s la `response` antes de devolverla.

{* ../../docs_src/middleware/tutorial001.py hl[8:9,11,14] *}

/// tip | Consejo

Ten en cuenta que los custom proprietary headers se pueden a√±adir <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" class="external-link" target="_blank">usando el prefijo 'X-'</a>.

Pero si tienes custom headers que deseas que un cliente en un navegador pueda ver, necesitas a√±adirlos a tus configuraciones de CORS ([CORS (Cross-Origin Resource Sharing)](cors.md){.internal-link target=_blank}) usando el par√°metro `expose_headers` documentado en <a href="https://www.starlette.io/middleware/#corsmiddleware" class="external-link" target="_blank">la documentaci√≥n de CORS de Starlette</a>.

///

/// note | Detalles T√©cnicos

Tambi√©n podr√≠as usar `from starlette.requests import Request`.

**FastAPI** lo proporciona como una conveniencia para ti, el desarrollador. Pero viene directamente de Starlette.

///

### Antes y despu√©s de la `response`

Puedes a√±adir c√≥digo que se ejecute con la `request`, antes de que cualquier *path operation* la reciba.

Y tambi√©n despu√©s de que se genere la `response`, antes de devolverla.

Por ejemplo, podr√≠as a√±adir un custom header `X-Process-Time` que contenga el tiempo en segundos que tom√≥ procesar la request y generar una response:

{* ../../docs_src/middleware/tutorial001.py hl[10,12:13] *}

/// tip | Consejo

Aqu√≠ usamos <a href="https://docs.python.org/3/library/time.html#time.perf_counter" class="external-link" target="_blank">`time.perf_counter()`</a> en lugar de `time.time()` porque puede ser m√°s preciso para estos casos de uso. ü§ì

///

## Otros middlewares

M√°s adelante puedes leer sobre otros middlewares en la [Gu√≠a del Usuario Avanzado: Middleware Avanzado](../advanced/middleware.md){.internal-link target=_blank}.

Leer√°s sobre c√≥mo manejar <abbr title="Cross-Origin Resource Sharing">CORS</abbr> con un middleware en la siguiente secci√≥n.


================================================
File: /docs/es/docs/tutorial/path-operation-configuration.md
================================================
# Configuraci√≥n de Path Operation

Hay varios par√°metros que puedes pasar a tu *path operation decorator* para configurarlo.

/// warning | Advertencia

Ten en cuenta que estos par√°metros se pasan directamente al *path operation decorator*, no a tu *path operation function*.

///

## C√≥digo de Estado del Response

Puedes definir el `status_code` (HTTP) que se utilizar√° en el response de tu *path operation*.

Puedes pasar directamente el c√≥digo `int`, como `404`.

Pero si no recuerdas para qu√© es cada c√≥digo num√©rico, puedes usar las constantes atajo en `status`:

{* ../../docs_src/path_operation_configuration/tutorial001_py310.py hl[1,15] *}

Ese c√≥digo de estado se usar√° en el response y se a√±adir√° al esquema de OpenAPI.

/// note | Detalles T√©cnicos

Tambi√©n podr√≠as usar `from starlette import status`.

**FastAPI** ofrece el mismo `starlette.status` como `fastapi.status` solo por conveniencia para ti, el desarrollador. Pero viene directamente de Starlette.

///

## Tags

Puedes a√±adir tags a tu *path operation*, pasando el par√°metro `tags` con un `list` de `str` (com√∫nmente solo una `str`):

{* ../../docs_src/path_operation_configuration/tutorial002_py310.py hl[15,20,25] *}

Ser√°n a√±adidas al esquema de OpenAPI y usadas por las interfaces de documentaci√≥n autom√°tica:

<img src="/img/tutorial/path-operation-configuration/image01.png">

### Tags con Enums

Si tienes una gran aplicaci√≥n, podr√≠as terminar acumulando **varias tags**, y querr√≠as asegurarte de que siempre uses la **misma tag** para *path operations* relacionadas.

En estos casos, podr√≠a tener sentido almacenar las tags en un `Enum`.

**FastAPI** soporta eso de la misma manera que con strings normales:

{* ../../docs_src/path_operation_configuration/tutorial002b.py hl[1,8:10,13,18] *}

## Resumen y Descripci√≥n

Puedes a√±adir un `summary` y `description`:

{* ../../docs_src/path_operation_configuration/tutorial003_py310.py hl[18:19] *}

## Descripci√≥n desde docstring

Como las descripciones tienden a ser largas y cubrir m√∫ltiples l√≠neas, puedes declarar la descripci√≥n de la *path operation* en la <abbr title="un string de m√∫ltiples l√≠neas como la primera expresi√≥n dentro de una funci√≥n (no asignada a ninguna variable) usada para documentaci√≥n">docstring</abbr> de la funci√≥n y **FastAPI** la leer√° desde all√≠.

Puedes escribir <a href="https://en.wikipedia.org/wiki/Markdown" class="external-link" target="_blank">Markdown</a> en el docstring, se interpretar√° y mostrar√° correctamente (teniendo en cuenta la indentaci√≥n del docstring).

{* ../../docs_src/path_operation_configuration/tutorial004_py310.py hl[17:25] *}

Ser√° usado en la documentaci√≥n interactiva:

<img src="/img/tutorial/path-operation-configuration/image02.png">

## Descripci√≥n del Response

Puedes especificar la descripci√≥n del response con el par√°metro `response_description`:

{* ../../docs_src/path_operation_configuration/tutorial005_py310.py hl[19] *}

/// info | Informaci√≥n

Ten en cuenta que `response_description` se refiere espec√≠ficamente al response, mientras que `description` se refiere a la *path operation* en general.

///

/// check | Revisa

OpenAPI especifica que cada *path operation* requiere una descripci√≥n de response.

Entonces, si no proporcionas una, **FastAPI** generar√° autom√°ticamente una de "Response exitoso".

///

<img src="/img/tutorial/path-operation-configuration/image03.png">

## Deprecar una *path operation*

Si necesitas marcar una *path operation* como <abbr title="obsoleta, se recomienda no usarla">deprecated</abbr>, pero sin eliminarla, pasa el par√°metro `deprecated`:

{* ../../docs_src/path_operation_configuration/tutorial006.py hl[16] *}

Se marcar√° claramente como deprecado en la documentaci√≥n interactiva:

<img src="/img/tutorial/path-operation-configuration/image04.png">

Revisa c√≥mo lucen las *path operations* deprecadas y no deprecadas:

<img src="/img/tutorial/path-operation-configuration/image05.png">

## Resumen

Puedes configurar y a√±adir metadatos a tus *path operations* f√°cilmente pasando par√°metros a los *path operation decorators*.


================================================
File: /docs/es/docs/tutorial/path-params-numeric-validations.md
================================================
# Par√°metros de Path y Validaciones Num√©ricas

De la misma manera que puedes declarar m√°s validaciones y metadatos para los par√°metros de query con `Query`, puedes declarar el mismo tipo de validaciones y metadatos para los par√°metros de path con `Path`.

## Importar Path

Primero, importa `Path` de `fastapi`, e importa `Annotated`:

{* ../../docs_src/path_params_numeric_validations/tutorial001_an_py310.py hl[1,3] *}

/// info | Informaci√≥n

FastAPI agreg√≥ soporte para `Annotated` (y comenz√≥ a recomendar su uso) en la versi√≥n 0.95.0.

Si tienes una versi√≥n anterior, obtendr√°s errores al intentar usar `Annotated`.

Aseg√∫rate de [Actualizar la versi√≥n de FastAPI](../deployment/versions.md#upgrading-the-fastapi-versions){.internal-link target=_blank} a al menos la 0.95.1 antes de usar `Annotated`.

///

## Declarar metadatos

Puedes declarar todos los mismos par√°metros que para `Query`.

Por ejemplo, para declarar un valor de metadato `title` para el par√°metro de path `item_id` puedes escribir:

{* ../../docs_src/path_params_numeric_validations/tutorial001_an_py310.py hl[10] *}

/// note | Nota

Un par√°metro de path siempre es requerido ya que tiene que formar parte del path. Incluso si lo declaras con `None` o le asignas un valor por defecto, no afectar√° en nada, siempre ser√° requerido.

///

## Ordena los par√°metros como necesites

/// tip | Consejo

Esto probablemente no es tan importante o necesario si usas `Annotated`.

///

Supongamos que quieres declarar el par√°metro de query `q` como un `str` requerido.

Y no necesitas declarar nada m√°s para ese par√°metro, as√≠ que realmente no necesitas usar `Query`.

Pero a√∫n necesitas usar `Path` para el par√°metro de path `item_id`. Y no quieres usar `Annotated` por alguna raz√≥n.

Python se quejar√° si pones un valor con un "default" antes de un valor que no tenga un "default".

Pero puedes reordenarlos y poner el valor sin un default (el par√°metro de query `q`) primero.

No importa para **FastAPI**. Detectar√° los par√°metros por sus nombres, tipos y declaraciones por defecto (`Query`, `Path`, etc.), no le importa el orden.

As√≠ que puedes declarar tu funci√≥n como:

//// tab | Python 3.8 non-Annotated

/// tip | Consejo

Prefiere usar la versi√≥n `Annotated` si es posible.

///

{* ../../docs_src/path_params_numeric_validations/tutorial002.py hl[7] *}

////

Pero ten en cuenta que si usas `Annotated`, no tendr√°s este problema, no importar√° ya que no est√°s usando los valores por defecto de los par√°metros de la funci√≥n para `Query()` o `Path()`.

{* ../../docs_src/path_params_numeric_validations/tutorial002_an_py39.py *}

## Ordena los par√°metros como necesites, trucos

/// tip | Consejo

Esto probablemente no es tan importante o necesario si usas `Annotated`.

///

Aqu√≠ hay un **peque√±o truco** que puede ser √∫til, pero no lo necesitar√°s a menudo.

Si quieres:

* declarar el par√°metro de query `q` sin un `Query` ni ning√∫n valor por defecto
* declarar el par√°metro de path `item_id` usando `Path`
* tenerlos en un orden diferente
* no usar `Annotated`

...Python tiene una sintaxis especial para eso.

Pasa `*`, como el primer par√°metro de la funci√≥n.

Python no har√° nada con ese `*`, pero sabr√° que todos los par√°metros siguientes deben ser llamados como argumentos de palabras clave (parejas key-value), tambi√©n conocidos como <abbr title="De: K-ey W-ord Arg-uments"><code>kwargs</code></abbr>. Incluso si no tienen un valor por defecto.

{* ../../docs_src/path_params_numeric_validations/tutorial003.py hl[7] *}

### Mejor con `Annotated`

Ten en cuenta que si usas `Annotated`, como no est√°s usando valores por defecto de los par√°metros de la funci√≥n, no tendr√°s este problema y probablemente no necesitar√°s usar `*`.

{* ../../docs_src/path_params_numeric_validations/tutorial003_an_py39.py hl[10] *}

## Validaciones num√©ricas: mayor o igual

Con `Query` y `Path` (y otros que ver√°s m√°s adelante) puedes declarar restricciones num√©ricas.

Aqu√≠, con `ge=1`, `item_id` necesitar√° ser un n√∫mero entero "`g`reater than or `e`qual" a `1`.

{* ../../docs_src/path_params_numeric_validations/tutorial004_an_py39.py hl[10] *}

## Validaciones num√©ricas: mayor que y menor o igual

Lo mismo aplica para:

* `gt`: `g`reater `t`han
* `le`: `l`ess than or `e`qual

{* ../../docs_src/path_params_numeric_validations/tutorial005_an_py39.py hl[10] *}

## Validaciones num√©ricas: flotantes, mayor y menor

Las validaciones num√©ricas tambi√©n funcionan para valores `float`.

Aqu√≠ es donde se convierte en importante poder declarar <abbr title="greater than"><code>gt</code></abbr> y no solo <abbr title="greater than or equal"><code>ge</code></abbr>. Ya que con esto puedes requerir, por ejemplo, que un valor sea mayor que `0`, incluso si es menor que `1`.

As√≠, `0.5` ser√≠a un valor v√°lido. Pero `0.0` o `0` no lo ser√≠an.

Y lo mismo para <abbr title="less than"><code>lt</code></abbr>.

{* ../../docs_src/path_params_numeric_validations/tutorial006_an_py39.py hl[13] *}

## Resumen

Con `Query`, `Path` (y otros que a√∫n no has visto) puedes declarar metadatos y validaciones de string de las mismas maneras que con [Par√°metros de Query y Validaciones de String](query-params-str-validations.md){.internal-link target=_blank}.

Y tambi√©n puedes declarar validaciones num√©ricas:

* `gt`: `g`reater `t`han
* `ge`: `g`reater than or `e`qual
* `lt`: `l`ess `t`han
* `le`: `l`ess than or `e`qual

/// info | Informaci√≥n

`Query`, `Path` y otras clases que ver√°s m√°s adelante son subclases de una clase com√∫n `Param`.

Todas ellas comparten los mismos par√°metros para validaci√≥n adicional y metadatos que has visto.

///

/// note | Nota t√©cnica

Cuando importas `Query`, `Path` y otros de `fastapi`, en realidad son funciones.

Que cuando se llaman, retornan instances de clases con el mismo nombre.

As√≠ que importas `Query`, que es una funci√≥n. Y cuando la llamas, retorna una instance de una clase tambi√©n llamada `Query`.

Estas funciones est√°n all√≠ (en lugar de usar simplemente las clases directamente) para que tu editor no marque errores sobre sus tipos.

De esa forma puedes usar tu editor y herramientas de programaci√≥n normales sin tener que agregar configuraciones personalizadas para omitir esos errores.

///


================================================
File: /docs/es/docs/tutorial/path-params.md
================================================
# Par√°metros de Path

Puedes declarar "par√°metros" o "variables" de path con la misma sintaxis que se usa en los format strings de Python:

{* ../../docs_src/path_params/tutorial001.py hl[6:7] *}

El valor del par√°metro de path `item_id` se pasar√° a tu funci√≥n como el argumento `item_id`.

As√≠ que, si ejecutas este ejemplo y vas a <a href="http://127.0.0.1:8000/items/foo" class="external-link" target="_blank">http://127.0.0.1:8000/items/foo</a>, ver√°s un response de:

```JSON
{"item_id":"foo"}
```

## Par√°metros de path con tipos

Puedes declarar el tipo de un par√°metro de path en la funci√≥n, usando anotaciones de tipos est√°ndar de Python:

{* ../../docs_src/path_params/tutorial002.py hl[7] *}

En este caso, `item_id` se declara como un `int`.

/// check | Revisa

Esto te dar√° soporte del editor dentro de tu funci√≥n, con chequeo de errores, autocompletado, etc.

///

## Conversi√≥n de datos

Si ejecutas este ejemplo y abres tu navegador en <a href="http://127.0.0.1:8000/items/3" class="external-link" target="_blank">http://127.0.0.1:8000/items/3</a>, ver√°s un response de:

```JSON
{"item_id":3}
```

/// check | Revisa

Nota que el valor que tu funci√≥n recibi√≥ (y devolvi√≥) es `3`, como un `int` de Python, no un string `"3"`.

Entonces, con esa declaraci√≥n de tipo, **FastAPI** te ofrece <abbr title="converting the string that comes from an HTTP request into Python data">"parsing"</abbr> autom√°tico de requests.

///

## Validaci√≥n de datos

Pero si vas al navegador en <a href="http://127.0.0.1:8000/items/foo" class="external-link" target="_blank">http://127.0.0.1:8000/items/foo</a>, ver√°s un bonito error HTTP de:

```JSON
{
  "detail": [
    {
      "type": "int_parsing",
      "loc": [
        "path",
        "item_id"
      ],
      "msg": "Input should be a valid integer, unable to parse string as an integer",
      "input": "foo",
      "url": "https://errors.pydantic.dev/2.1/v/int_parsing"
    }
  ]
}
```

porque el par√°metro de path `item_id` ten√≠a un valor de `"foo"`, que no es un `int`.

El mismo error aparecer√≠a si proporcionaras un `float` en lugar de un `int`, como en: <a href="http://127.0.0.1:8000/items/4.2" class="external-link" target="_blank">http://127.0.0.1:8000/items/4.2</a>

/// check | Revisa

Entonces, con la misma declaraci√≥n de tipo de Python, **FastAPI** te ofrece validaci√≥n de datos.

Nota que el error tambi√©n indica claramente el punto exacto donde la validaci√≥n fall√≥.

Esto es incre√≠blemente √∫til mientras desarrollas y depuras c√≥digo que interact√∫a con tu API.

///

## Documentaci√≥n

Y cuando abras tu navegador en <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>, ver√°s una documentaci√≥n de API autom√°tica e interactiva como:

<img src="/img/tutorial/path-params/image01.png">

/// check | Revisa

Nuevamente, solo con esa misma declaraci√≥n de tipo de Python, **FastAPI** te ofrece documentaci√≥n autom√°tica e interactiva (integrando Swagger UI).

Nota que el par√°metro de path est√° declarado como un entero.

///

## Beneficios basados en est√°ndares, documentaci√≥n alternativa

Y porque el esquema generado es del est√°ndar <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md" class="external-link" target="_blank">OpenAPI</a>, hay muchas herramientas compatibles.

Debido a esto, el propio **FastAPI** proporciona una documentaci√≥n de API alternativa (usando ReDoc), a la cual puedes acceder en <a href="http://127.0.0.1:8000/redoc" class="external-link" target="_blank">http://127.0.0.1:8000/redoc</a>:

<img src="/img/tutorial/path-params/image02.png">

De la misma manera, hay muchas herramientas compatibles. Incluyendo herramientas de generaci√≥n de c√≥digo para muchos lenguajes.

## Pydantic

Toda la validaci√≥n de datos se realiza internamente con <a href="https://docs.pydantic.dev/" class="external-link" target="_blank">Pydantic</a>, as√≠ que obtienes todos los beneficios de esta. Y sabes que est√°s en buenas manos.

Puedes usar las mismas declaraciones de tipo con `str`, `float`, `bool` y muchos otros tipos de datos complejos.

Varios de estos se exploran en los siguientes cap√≠tulos del tutorial.

## El orden importa

Al crear *path operations*, puedes encontrarte en situaciones donde tienes un path fijo.

Como `/users/me`, imaginemos que es para obtener datos sobre el usuario actual.

Y luego tambi√©n puedes tener un path `/users/{user_id}` para obtener datos sobre un usuario espec√≠fico por alg√∫n ID de usuario.

Debido a que las *path operations* se eval√∫an en orden, necesitas asegurarte de que el path para `/users/me` se declara antes que el de `/users/{user_id}`:

{* ../../docs_src/path_params/tutorial003.py hl[6,11] *}

De lo contrario, el path para `/users/{user_id}` tambi√©n coincidir√≠a para `/users/me`, "pensando" que est√° recibiendo un par√°metro `user_id` con un valor de `"me"`.

De manera similar, no puedes redefinir una path operation:

{* ../../docs_src/path_params/tutorial003b.py hl[6,11] *}

La primera siempre ser√° utilizada ya que el path coincide primero.

## Valores predefinidos

Si tienes una *path operation* que recibe un *path parameter*, pero quieres que los valores posibles v√°lidos del *path parameter* est√©n predefinidos, puedes usar un <abbr title="Enumeration">`Enum`</abbr> est√°ndar de Python.

### Crear una clase `Enum`

Importa `Enum` y crea una subclase que herede de `str` y de `Enum`.

Al heredar de `str`, la documentaci√≥n de la API podr√° saber que los valores deben ser de tipo `string` y podr√° representarlos correctamente.

Luego crea atributos de clase con valores fijos, que ser√°n los valores v√°lidos disponibles:

{* ../../docs_src/path_params/tutorial005.py hl[1,6:9] *}

/// info | Informaci√≥n

<a href="https://docs.python.org/3/library/enum.html" class="external-link" target="_blank">Las enumeraciones (o enums) est√°n disponibles en Python</a> desde la versi√≥n 3.4.

///

/// tip | Consejo

Si te est√°s preguntando, "AlexNet", "ResNet" y "LeNet" son solo nombres de <abbr title="T√©cnicamente, arquitecturas de modelos de Deep Learning">modelos</abbr> de Machine Learning.

///

### Declarar un *path parameter*

Luego crea un *path parameter* con una anotaci√≥n de tipo usando la clase enum que creaste (`ModelName`):

{* ../../docs_src/path_params/tutorial005.py hl[16] *}

### Revisa la documentaci√≥n

Como los valores disponibles para el *path parameter* est√°n predefinidos, la documentaci√≥n interactiva puede mostrarlos de manera ordenada:

<img src="/img/tutorial/path-params/image03.png">

### Trabajando con *enumeraciones* de Python

El valor del *path parameter* ser√° un *miembro* de enumeraci√≥n.

#### Comparar *miembros* de enumeraciones

Puedes compararlo con el *miembro* de enumeraci√≥n en tu enum creada `ModelName`:

{* ../../docs_src/path_params/tutorial005.py hl[17] *}

#### Obtener el valor de *enumeraci√≥n*

Puedes obtener el valor actual (un `str` en este caso) usando `model_name.value`, o en general, `your_enum_member.value`:

{* ../../docs_src/path_params/tutorial005.py hl[20] *}

/// tip | Consejo

Tambi√©n podr√≠as acceder al valor `"lenet"` con `ModelName.lenet.value`.

///

#### Devolver *miembros* de enumeraci√≥n

Puedes devolver *miembros de enum* desde tu *path operation*, incluso anidados en un cuerpo JSON (por ejemplo, un `dict`).

Ser√°n convertidos a sus valores correspondientes (cadenas en este caso) antes de devolverlos al cliente:

{* ../../docs_src/path_params/tutorial005.py hl[18,21,23] *}

En tu cliente recibir√°s un response JSON como:

```JSON
{
  "model_name": "alexnet",
  "message": "Deep Learning FTW!"
}
```

## Par√°metros de path conteniendo paths

Imaginemos que tienes una *path operation* con un path `/files/{file_path}`.

Pero necesitas que `file_path` en s√≠ mismo contenga un *path*, como `home/johndoe/myfile.txt`.

Entonces, la URL para ese archivo ser√≠a algo como: `/files/home/johndoe/myfile.txt`.

### Soporte de OpenAPI

OpenAPI no soporta una manera de declarar un *path parameter* para que contenga un *path* dentro, ya que eso podr√≠a llevar a escenarios que son dif√≠ciles de probar y definir.

Sin embargo, todav√≠a puedes hacerlo en **FastAPI**, usando una de las herramientas internas de Starlette.

Y la documentaci√≥n seguir√≠a funcionando, aunque no agregue ninguna documentaci√≥n indicando que el par√°metro debe contener un path.

### Convertidor de Path

Usando una opci√≥n directamente de Starlette puedes declarar un *path parameter* conteniendo un *path* usando una URL como:

```
/files/{file_path:path}
```

En este caso, el nombre del par√°metro es `file_path`, y la √∫ltima parte, `:path`, indica que el par√°metro deber√≠a coincidir con cualquier *path*.

As√≠ que, puedes usarlo con:

{* ../../docs_src/path_params/tutorial004.py hl[6] *}

/// tip | Consejo

Podr√≠as necesitar que el par√°metro contenga `/home/johndoe/myfile.txt`, con una barra inclinada (`/`) inicial.

En ese caso, la URL ser√≠a: `/files//home/johndoe/myfile.txt`, con una doble barra inclinada (`//`) entre `files` y `home`.

///

## Resumen

Con **FastAPI**, al usar declaraciones de tipo est√°ndar de Python, cortas e intuitivas, obtienes:

* Soporte del editor: chequeo de errores, autocompletado, etc.
* "<abbr title="converting the string that comes from an HTTP request into Python data">parsing</abbr>" de datos
* Validaci√≥n de datos
* Anotaci√≥n de API y documentaci√≥n autom√°tica

Y solo tienes que declararlos una vez.

Probablemente esa sea la principal ventaja visible de **FastAPI** en comparaci√≥n con otros frameworks alternativos (aparte del rendimiento bruto).


================================================
File: /docs/es/docs/tutorial/query-param-models.md
================================================
# Modelos de Par√°metros Query

Si tienes un grupo de **par√°metros query** que est√°n relacionados, puedes crear un **modelo de Pydantic** para declararlos.

Esto te permitir√≠a **reutilizar el modelo** en **m√∫ltiples lugares** y tambi√©n declarar validaciones y metadatos para todos los par√°metros de una vez. üòé

/// note | Nota

Esto es compatible desde la versi√≥n `0.115.0` de FastAPI. ü§ì

///

## Par√°metros Query con un Modelo Pydantic

Declara los **par√°metros query** que necesitas en un **modelo de Pydantic**, y luego declara el par√°metro como `Query`:

{* ../../docs_src/query_param_models/tutorial001_an_py310.py hl[9:13,17] *}

**FastAPI** **extraer√°** los datos para **cada campo** de los **par√°metros query** en el request y te proporcionar√° el modelo de Pydantic que definiste.

## Revisa la Documentaci√≥n

Puedes ver los par√°metros query en la UI de documentaci√≥n en `/docs`:

<div class="screenshot">
<img src="/img/tutorial/query-param-models/image01.png">
</div>

## Prohibir Par√°metros Query Extras

En algunos casos de uso especiales (probablemente no muy comunes), podr√≠as querer **restringir** los par√°metros query que deseas recibir.

Puedes usar la configuraci√≥n del modelo de Pydantic para `forbid` cualquier campo `extra`:

{* ../../docs_src/query_param_models/tutorial002_an_py310.py hl[10] *}

Si un cliente intenta enviar algunos datos **extra** en los **par√°metros query**, recibir√°n un response de **error**.

Por ejemplo, si el cliente intenta enviar un par√°metro query `tool` con un valor de `plumbus`, como:

```http
https://example.com/items/?limit=10&tool=plumbus
```

Recibir√°n un response de **error** que les indica que el par√°metro query `tool` no est√° permitido:

```json
{
    "detail": [
        {
            "type": "extra_forbidden",
            "loc": ["query", "tool"],
            "msg": "Extra inputs are not permitted",
            "input": "plumbus"
        }
    ]
}
```

## Resumen

Puedes usar **modelos de Pydantic** para declarar **par√°metros query** en **FastAPI**. üòé

/// tip | Consejo

Alerta de spoiler: tambi√©n puedes usar modelos de Pydantic para declarar cookies y headers, pero leer√°s sobre eso m√°s adelante en el tutorial. ü§´

///


================================================
File: /docs/es/docs/tutorial/query-params-str-validations.md
================================================
# Par√°metros de Query y Validaciones de String

**FastAPI** te permite declarar informaci√≥n adicional y validaci√≥n para tus par√°metros.

Tomemos esta aplicaci√≥n como ejemplo:

{* ../../docs_src/query_params_str_validations/tutorial001_py310.py hl[7] *}

El par√°metro de query `q` es del tipo `Union[str, None]` (o `str | None` en Python 3.10), lo que significa que es de tipo `str` pero tambi√©n podr√≠a ser `None`, y de hecho, el valor por defecto es `None`, as√≠ que FastAPI sabr√° que no es requerido.

/// note | Nota

FastAPI sabr√° que el valor de `q` no es requerido por el valor por defecto `= None`.

El `Union` en `Union[str, None]` permitir√° a tu editor darte un mejor soporte y detectar errores.

///

## Validaciones adicionales

Vamos a hacer que, aunque `q` sea opcional, siempre que se proporcione, **su longitud no exceda los 50 caracteres**.

### Importar `Query` y `Annotated`

Para lograr eso, primero importa:

* `Query` desde `fastapi`
* `Annotated` desde `typing` (o desde `typing_extensions` en Python por debajo de 3.9)

//// tab | Python 3.10+

En Python 3.9 o superior, `Annotated` es parte de la biblioteca est√°ndar, as√≠ que puedes importarlo desde `typing`.

```Python hl_lines="1  3"
{!> ../../docs_src/query_params_str_validations/tutorial002_an_py310.py!}
```

////

//// tab | Python 3.8+

En versiones de Python por debajo de 3.9 importas `Annotated` desde `typing_extensions`.

Ya estar√° instalado con FastAPI.

```Python hl_lines="3-4"
{!> ../../docs_src/query_params_str_validations/tutorial002_an.py!}
```

////

/// info | Informaci√≥n

FastAPI a√±adi√≥ soporte para `Annotated` (y empez√≥ a recomendarlo) en la versi√≥n 0.95.0.

Si tienes una versi√≥n m√°s antigua, obtendr√°s errores al intentar usar `Annotated`.

Aseg√∫rate de [Actualizar la versi√≥n de FastAPI](../deployment/versions.md#upgrading-the-fastapi-versions){.internal-link target=_blank} a al menos 0.95.1 antes de usar `Annotated`.

///

## Usar `Annotated` en el tipo del par√°metro `q`

¬øRecuerdas que te dije antes que `Annotated` puede ser usado para agregar metadatos a tus par√°metros en la [Introducci√≥n a Tipos de Python](../python-types.md#type-hints-with-metadata-annotations){.internal-link target=_blank}?

Ahora es el momento de usarlo con FastAPI. üöÄ

Ten√≠amos esta anotaci√≥n de tipo:

//// tab | Python 3.10+

```Python
q: str | None = None
```

////

//// tab | Python 3.8+

```Python
q: Union[str, None] = None
```

////

Lo que haremos es envolver eso con `Annotated`, para que se convierta en:

//// tab | Python 3.10+

```Python
q: Annotated[str | None] = None
```

////

//// tab | Python 3.8+

```Python
q: Annotated[Union[str, None]] = None
```

////

Ambas versiones significan lo mismo, `q` es un par√°metro que puede ser un `str` o `None`, y por defecto, es `None`.

Ahora vamos a lo divertido. üéâ

## Agregar `Query` a `Annotated` en el par√°metro `q`

Ahora que tenemos este `Annotated` donde podemos poner m√°s informaci√≥n (en este caso algunas validaciones adicionales), agrega `Query` dentro de `Annotated`, y establece el par√°metro `max_length` a `50`:

{* ../../docs_src/query_params_str_validations/tutorial002_an_py310.py hl[9] *}

Nota que el valor por defecto sigue siendo `None`, por lo que el par√°metro sigue siendo opcional.

Pero ahora, al tener `Query(max_length=50)` dentro de `Annotated`, le estamos diciendo a FastAPI que queremos que tenga **validaci√≥n adicional** para este valor, queremos que tenga un m√°ximo de 50 caracteres. üòé

/// tip | Consejo

Aqu√≠ estamos usando `Query()` porque este es un **par√°metro de query**. M√°s adelante veremos otros como `Path()`, `Body()`, `Header()`, y `Cookie()`, que tambi√©n aceptan los mismos argumentos que `Query()`.

///

FastAPI ahora:

* **Validar√°** los datos asegur√°ndose de que la longitud m√°xima sea de 50 caracteres
* Mostrar√° un **error claro** para el cliente cuando los datos no sean v√°lidos
* **Documentar√°** el par√°metro en el OpenAPI esquema *path operation* (as√≠ aparecer√° en la **UI de documentaci√≥n autom√°tica**)

## Alternativa (antigua): `Query` como valor por defecto

Versiones anteriores de FastAPI (antes de <abbr title="antes de 2023-03">0.95.0</abbr>) requer√≠an que usaras `Query` como el valor por defecto de tu par√°metro, en lugar de ponerlo en `Annotated`. Hay una alta probabilidad de que veas c√≥digo us√°ndolo alrededor, as√≠ que te lo explicar√©.

/// tip | Consejo

Para nuevo c√≥digo y siempre que sea posible, usa `Annotated` como se explic√≥ arriba. Hay m√∫ltiples ventajas (explicadas a continuaci√≥n) y no hay desventajas. üç∞

///

As√≠ es como usar√≠as `Query()` como el valor por defecto de tu par√°metro de funci√≥n, estableciendo el par√°metro `max_length` a 50:

{* ../../docs_src/query_params_str_validations/tutorial002_py310.py hl[7] *}

Ya que en este caso (sin usar `Annotated`) debemos reemplazar el valor por defecto `None` en la funci√≥n con `Query()`, ahora necesitamos establecer el valor por defecto con el par√°metro `Query(default=None)`, esto sirve al mismo prop√≥sito de definir ese valor por defecto (al menos para FastAPI).

Entonces:

```Python
q: Union[str, None] = Query(default=None)
```

...hace que el par√°metro sea opcional, con un valor por defecto de `None`, lo mismo que:

```Python
q: Union[str, None] = None
```

Y en Python 3.10 y superior:

```Python
q: str | None = Query(default=None)
```

...hace que el par√°metro sea opcional, con un valor por defecto de `None`, lo mismo que:

```Python
q: str | None = None
```

Pero las versiones de `Query` lo declaran expl√≠citamente como un par√°metro de query.

/// info | Informaci√≥n

Ten en cuenta que la parte m√°s importante para hacer un par√°metro opcional es la parte:

```Python
= None
```

o la parte:

```Python
= Query(default=None)
```

ya que usar√° ese `None` como el valor por defecto, y de esa manera har√° el par√°metro **no requerido**.

La parte `Union[str, None]` permite que tu editor brinde un mejor soporte, pero no es lo que le dice a FastAPI que este par√°metro no es requerido.

///

Luego, podemos pasar m√°s par√°metros a `Query`. En este caso, el par√°metro `max_length` que se aplica a los strings:

```Python
q: Union[str, None] = Query(default=None, max_length=50)
```

Esto validar√° los datos, mostrar√° un error claro cuando los datos no sean v√°lidos, y documentar√° el par√°metro en el esquema del *path operation* de OpenaPI.

### `Query` como valor por defecto o en `Annotated`

Ten en cuenta que cuando uses `Query` dentro de `Annotated` no puedes usar el par√°metro `default` para `Query`.

En su lugar utiliza el valor por defecto real del par√°metro de la funci√≥n. De lo contrario, ser√≠a inconsistente.

Por ejemplo, esto no est√° permitido:

```Python
q: Annotated[str, Query(default="rick")] = "morty"
```

...porque no est√° claro si el valor por defecto deber√≠a ser `"rick"` o `"morty"`.

As√≠ que utilizar√≠as (preferentemente):

```Python
q: Annotated[str, Query()] = "rick"
```

...o en code bases m√°s antiguos encontrar√°s:

```Python
q: str = Query(default="rick")
```

### Ventajas de `Annotated`

**Usar `Annotated` es recomendado** en lugar del valor por defecto en los par√°metros de funci√≥n, es **mejor** por m√∫ltiples razones. ü§ì

El valor **por defecto** del **par√°metro de funci√≥n** es el valor **real por defecto**, eso es m√°s intuitivo con Python en general. üòå

Podr√≠as **llamar** a esa misma funci√≥n en **otros lugares** sin FastAPI, y **funcionar√≠a como se espera**. Si hay un par√°metro **requerido** (sin un valor por defecto), tu **editor** te avisar√° con un error, **Python** tambi√©n se quejar√° si lo ejecutas sin pasar el par√°metro requerido.

Cuando no usas `Annotated` y en su lugar usas el estilo de valor por defecto **(antiguo)**, si llamas a esa funci√≥n sin FastAPI en **otros lugares**, tienes que **recordar** pasar los argumentos a la funci√≥n para que funcione correctamente, de lo contrario, los valores ser√°n diferentes de lo que esperas (por ejemplo, `QueryInfo` o algo similar en lugar de `str`). Y tu editor no se quejar√°, y Python no se quejar√° al ejecutar esa funci√≥n, solo cuando los errores dentro de las operaciones hagan que funcione incorrectamente.

Dado que `Annotated` puede tener m√°s de una anotaci√≥n de metadato, ahora podr√≠as incluso usar la misma funci√≥n con otras herramientas, como <a href="https://typer.tiangolo.com/" class="external-link" target="_blank">Typer</a>. üöÄ

## Agregar m√°s validaciones

Tambi√©n puedes agregar un par√°metro `min_length`:

{* ../../docs_src/query_params_str_validations/tutorial003_an_py310.py hl[10] *}

## Agregar expresiones regulares

Puedes definir una <abbr title="Una expresi√≥n regular, regex o regexp es una secuencia de caracteres que define un patr√≥n de b√∫squeda para strings.">expresi√≥n regular</abbr> `pattern` que el par√°metro debe coincidir:

{* ../../docs_src/query_params_str_validations/tutorial004_an_py310.py hl[11] *}

Este patr√≥n espec√≠fico de expresi√≥n regular comprueba que el valor recibido del par√°metro:

* `^`: comience con los siguientes caracteres, no tiene caracteres antes.
* `fixedquery`: tiene el valor exacto `fixedquery`.
* `$`: termina all√≠, no tiene m√°s caracteres despu√©s de `fixedquery`.

Si te sientes perdido con todas estas ideas de **"expresi√≥n regular"**, no te preocupes. Son un tema dif√≠cil para muchas personas. A√∫n puedes hacer muchas cosas sin necesitar expresiones regulares todav√≠a.

Pero cuando las necesites y vayas a aprenderlas, ya sabes que puedes usarlas directamente en **FastAPI**.

### Pydantic v1 `regex` en lugar de `pattern`

Antes de la versi√≥n 2 de Pydantic y antes de FastAPI 0.100.0, el par√°metro se llamaba `regex` en lugar de `pattern`, pero ahora est√° en desuso.

Todav√≠a podr√≠as ver algo de c√≥digo que lo usa:

//// tab | Pydantic v1

{* ../../docs_src/query_params_str_validations/tutorial004_regex_an_py310.py hl[11] *}

////

Pero que sepas que esto est√° deprecado y deber√≠a actualizarse para usar el nuevo par√°metro `pattern`. ü§ì

## Valores por defecto

Puedes, por supuesto, usar valores por defecto diferentes de `None`.

Digamos que quieres declarar el par√°metro de query `q` para que tenga un `min_length` de `3`, y para que tenga un valor por defecto de `"fixedquery"`:

{* ../../docs_src/query_params_str_validations/tutorial005_an_py39.py hl[9] *}

/// note | Nota

Tener un valor por defecto de cualquier tipo, incluyendo `None`, hace que el par√°metro sea opcional (no requerido).

///

## Par√°metros requeridos

Cuando no necesitamos declarar m√°s validaciones o metadatos, podemos hacer que el par√°metro de query `q` sea requerido simplemente no declarando un valor por defecto, como:

```Python
q: str
```

en lugar de:

```Python
q: Union[str, None] = None
```

Pero ahora lo estamos declarando con `Query`, por ejemplo, como:

//// tab | Annotated

```Python
q: Annotated[Union[str, None], Query(min_length=3)] = None
```

////

//// tab | non-Annotated

```Python
q: Union[str, None] = Query(default=None, min_length=3)
```

////

As√≠ que, cuando necesites declarar un valor como requerido mientras usas `Query`, simplemente puedes no declarar un valor por defecto:

{* ../../docs_src/query_params_str_validations/tutorial006_an_py39.py hl[9] *}

### Requerido con Puntos suspensivos (`...`)

Hay una manera alternativa de declarar expl√≠citamente que un valor es requerido. Puedes establecer el valor por defecto al valor literal `...`:

{* ../../docs_src/query_params_str_validations/tutorial006b_an_py39.py hl[9] *}

/// info | Informaci√≥n

Si no hab√≠as visto eso `...` antes: es un valor especial √∫nico, es <a href="https://docs.python.org/3/library/constants.html#Ellipsis" class="external-link" target="_blank">parte de Python y se llama "Ellipsis"</a>.

Se usa por Pydantic y FastAPI para declarar expl√≠citamente que un valor es requerido.

///

Esto le permitir√° a **FastAPI** saber que este par√°metro es requerido.

### Requerido, puede ser `None`

Puedes declarar que un par√°metro puede aceptar `None`, pero que a√∫n as√≠ es requerido. Esto obligar√≠a a los clientes a enviar un valor, incluso si el valor es `None`.

Para hacer eso, puedes declarar que `None` es un tipo v√°lido pero a√∫n usar `...` como el valor por defecto:

{* ../../docs_src/query_params_str_validations/tutorial006c_an_py310.py hl[9] *}

/// tip | Consejo

Pydantic, que es lo que impulsa toda la validaci√≥n y serializaci√≥n de datos en FastAPI, tiene un comportamiento especial cuando usas `Optional` o `Union[Something, None]` sin un valor por defecto, puedes leer m√°s al respecto en la documentaci√≥n de Pydantic sobre <a href="https://docs.pydantic.dev/2.3/usage/models/#required-optional-fields" class="external-link" target="_blank">Campos requeridos</a>.

///

/// tip | Consejo

Recuerda que en la mayor√≠a de los casos, cuando algo es requerido, puedes simplemente omitir el default, as√≠ que normalmente no tienes que usar `...`.

///

## Lista de par√°metros de Query / m√∫ltiples valores

Cuando defines un par√°metro de query expl√≠citamente con `Query` tambi√©n puedes declararlo para recibir una lista de valores, o dicho de otra manera, para recibir m√∫ltiples valores.

Por ejemplo, para declarar un par√°metro de query `q` que puede aparecer varias veces en la URL, puedes escribir:

{* ../../docs_src/query_params_str_validations/tutorial011_an_py310.py hl[9] *}

Entonces, con una URL como:

```
http://localhost:8000/items/?q=foo&q=bar
```

recibir√≠as los m√∫ltiples valores del *query parameter* `q` (`foo` y `bar`) en una `list` de Python dentro de tu *path operation function*, en el *par√°metro de funci√≥n* `q`.

Entonces, el response a esa URL ser√≠a:

```JSON
{
  "q": [
    "foo",
    "bar"
  ]
}
```

/// tip | Consejo

Para declarar un par√°metro de query con un tipo de `list`, como en el ejemplo anterior, necesitas usar expl√≠citamente `Query`, de lo contrario ser√≠a interpretado como un request body.

///

La documentaci√≥n interactiva de API se actualizar√° en consecuencia, para permitir m√∫ltiples valores:

<img src="/img/tutorial/query-params-str-validations/image02.png">

### Lista de par√°metros de Query / m√∫ltiples valores con valores por defecto

Y tambi√©n puedes definir un valor por defecto `list` de valores si no se proporcionan ninguno:

{* ../../docs_src/query_params_str_validations/tutorial012_an_py39.py hl[9] *}

Si vas a:

```
http://localhost:8000/items/
```

el valor por defecto de `q` ser√°: `["foo", "bar"]` y tu response ser√°:

```JSON
{
  "q": [
    "foo",
    "bar"
  ]
}
```

#### Usando solo `list`

Tambi√©n puedes usar `list` directamente en lugar de `List[str]` (o `list[str]` en Python 3.9+):

{* ../../docs_src/query_params_str_validations/tutorial013_an_py39.py hl[9] *}

/// note | Nota

Ten en cuenta que en este caso, FastAPI no comprobar√° el contenido de la lista.

Por ejemplo, `List[int]` comprobar√≠a (y documentar√≠a) que el contenido de la lista son enteros. Pero `list` sola no lo har√≠a.

///

## Declarar m√°s metadatos

Puedes agregar m√°s informaci√≥n sobre el par√°metro.

Esa informaci√≥n se incluir√° en el OpenAPI generado y ser√° utilizada por las interfaces de usuario de documentaci√≥n y herramientas externas.

/// note | Nota

Ten en cuenta que diferentes herramientas podr√≠an tener diferentes niveles de soporte de OpenAPI.

Algunas de ellas podr√≠an no mostrar toda la informaci√≥n extra declarada todav√≠a, aunque en la mayor√≠a de los casos, la funcionalidad faltante ya est√° planificada para desarrollo.

///

Puedes agregar un `title`:

{* ../../docs_src/query_params_str_validations/tutorial007_an_py310.py hl[10] *}

Y una `description`:

{* ../../docs_src/query_params_str_validations/tutorial008_an_py310.py hl[14] *}

## Alias para par√°metros

Imagina que quieres que el par√°metro sea `item-query`.

Como en:

```
http://127.0.0.1:8000/items/?item-query=foobaritems
```

Pero `item-query` no es un nombre de variable v√°lido en Python.

Lo m√°s cercano ser√≠a `item_query`.

Pero a√∫n necesitas que sea exactamente `item-query`...

Entonces puedes declarar un `alias`, y ese alias ser√° usado para encontrar el valor del par√°metro:

{* ../../docs_src/query_params_str_validations/tutorial009_an_py310.py hl[9] *}

## Declarar par√°metros obsoletos

Ahora digamos que ya no te gusta este par√°metro.

Tienes que dejarlo all√≠ por un tiempo porque hay clientes us√°ndolo, pero quieres que la documentaci√≥n lo muestre claramente como <abbr title="obsoleto, se recomienda no usarlo">deprecated</abbr>.

Luego pasa el par√°metro `deprecated=True` a `Query`:

{* ../../docs_src/query_params_str_validations/tutorial010_an_py310.py hl[19] *}

La documentaci√≥n lo mostrar√° as√≠:

<img src="/img/tutorial/query-params-str-validations/image01.png">

## Excluir par√°metros de OpenAPI

Para excluir un par√°metro de query del esquema de OpenAPI generado (y por lo tanto, de los sistemas de documentaci√≥n autom√°tica), establece el par√°metro `include_in_schema` de `Query` a `False`:

{* ../../docs_src/query_params_str_validations/tutorial014_an_py310.py hl[10] *}

## Recapitulaci√≥n

Puedes declarar validaciones y metadatos adicionales para tus par√°metros.

Validaciones gen√©ricas y metadatos:

* `alias`
* `title`
* `description`
* `deprecated`

Validaciones espec√≠ficas para strings:

* `min_length`
* `max_length`
* `pattern`

En estos ejemplos viste c√≥mo declarar validaciones para valores de tipo `str`.

Mira los siguientes cap√≠tulos para aprender c√≥mo declarar validaciones para otros tipos, como n√∫meros.


================================================
File: /docs/es/docs/tutorial/query-params.md
================================================
# Par√°metros de Query

Cuando declaras otros par√°metros de funci√≥n que no son parte de los par√°metros de path, son autom√°ticamente interpretados como par√°metros de "query".

{* ../../docs_src/query_params/tutorial001.py hl[9] *}

La query es el conjunto de pares clave-valor que van despu√©s del `?` en una URL, separados por caracteres `&`.

Por ejemplo, en la URL:

```
http://127.0.0.1:8000/items/?skip=0&limit=10
```

...los par√°metros de query son:

* `skip`: con un valor de `0`
* `limit`: con un valor de `10`

Como son parte de la URL, son "naturalmente" strings.

Pero cuando los declaras con tipos de Python (en el ejemplo anterior, como `int`), son convertidos a ese tipo y validados respecto a √©l.

Todo el mismo proceso que se aplica para los par√°metros de path tambi√©n se aplica para los par√°metros de query:

* Soporte del editor (obviamente)
* <abbr title="convirtiendo el string que viene de un request HTTP en datos de Python">"Parsing"</abbr> de datos
* Validaci√≥n de datos
* Documentaci√≥n autom√°tica

## Valores por defecto

Como los par√°metros de query no son una parte fija de un path, pueden ser opcionales y pueden tener valores por defecto.

En el ejemplo anterior, tienen valores por defecto de `skip=0` y `limit=10`.

Entonces, ir a la URL:

```
http://127.0.0.1:8000/items/
```

ser√≠a lo mismo que ir a:

```
http://127.0.0.1:8000/items/?skip=0&limit=10
```

Pero si vas a, por ejemplo:

```
http://127.0.0.1:8000/items/?skip=20
```

Los valores de los par√°metros en tu funci√≥n ser√°n:

* `skip=20`: porque lo configuraste en la URL
* `limit=10`: porque ese era el valor por defecto

## Par√°metros opcionales

De la misma manera, puedes declarar par√°metros de query opcionales, estableciendo su valor por defecto en `None`:

{* ../../docs_src/query_params/tutorial002_py310.py hl[7] *}

/// check | Revisa

Adem√°s, nota que **FastAPI** es lo suficientemente inteligente para notar que el par√°metro de path `item_id` es un par√°metro de path y `q` no lo es, por lo tanto, es un par√°metro de query.

///

## Conversi√≥n de tipos en par√°metros de query

Tambi√©n puedes declarar tipos `bool`, y ser√°n convertidos:

{* ../../docs_src/query_params/tutorial003_py310.py hl[7] *}

En este caso, si vas a:

```
http://127.0.0.1:8000/items/foo?short=1
```

o

```
http://127.0.0.1:8000/items/foo?short=True
```

o

```
http://127.0.0.1:8000/items/foo?short=true
```

o

```
http://127.0.0.1:8000/items/foo?short=on
```

o

```
http://127.0.0.1:8000/items/foo?short=yes
```

o cualquier otra variaci√≥n (may√∫sculas, primera letra en may√∫scula, etc.), tu funci√≥n ver√° el par√°metro `short` con un valor `bool` de `True`. De lo contrario, ser√° `False`.

## M√∫ltiples par√°metros de path y de query

Puedes declarar m√∫ltiples par√°metros de path y de query al mismo tiempo, **FastAPI** sabe cu√°l es cu√°l.

Y no tienes que declararlos en un orden espec√≠fico.

Ser√°n detectados por nombre:

{* ../../docs_src/query_params/tutorial004_py310.py hl[6,8] *}

## Par√°metros de query requeridos

Cuando declaras un valor por defecto para par√°metros que no son de path (por ahora, solo hemos visto par√°metros de query), entonces no es requerido.

Si no quieres agregar un valor espec√≠fico pero solo hacer que sea opcional, establece el valor por defecto como `None`.

Pero cuando quieres hacer un par√°metro de query requerido, simplemente no declares ning√∫n valor por defecto:

{* ../../docs_src/query_params/tutorial005.py hl[6:7] *}

Aqu√≠ el par√°metro de query `needy` es un par√°metro de query requerido de tipo `str`.

Si abres en tu navegador una URL como:

```
http://127.0.0.1:8000/items/foo-item
```

...sin agregar el par√°metro requerido `needy`, ver√°s un error como:

```JSON
{
  "detail": [
    {
      "type": "missing",
      "loc": [
        "query",
        "needy"
      ],
      "msg": "Field required",
      "input": null,
      "url": "https://errors.pydantic.dev/2.1/v/missing"
    }
  ]
}
```

Como `needy` es un par√°metro requerido, necesitar√≠as establecerlo en la URL:

```
http://127.0.0.1:8000/items/foo-item?needy=sooooneedy
```

...esto funcionar√≠a:

```JSON
{
    "item_id": "foo-item",
    "needy": "sooooneedy"
}
```

Y por supuesto, puedes definir algunos par√°metros como requeridos, algunos con un valor por defecto, y algunos enteramente opcionales:

{* ../../docs_src/query_params/tutorial006_py310.py hl[8] *}

En este caso, hay 3 par√°metros de query:

* `needy`, un `str` requerido.
* `skip`, un `int` con un valor por defecto de `0`.
* `limit`, un `int` opcional.

/// tip | Consejo

Tambi√©n podr√≠as usar `Enum`s de la misma manera que con [Par√°metros de Path](path-params.md#predefined-values){.internal-link target=_blank}.

///


================================================
File: /docs/es/docs/tutorial/request-files.md
================================================
# Archivos de Request

Puedes definir archivos que ser√°n subidos por el cliente utilizando `File`.

/// info | Informaci√≥n

Para recibir archivos subidos, primero instala <a href="https://github.com/Kludex/python-multipart" class="external-link" target="_blank">`python-multipart`</a>.

Aseg√∫rate de crear un [entorno virtual](../virtual-environments.md){.internal-link target=_blank}, activarlo y luego instalarlo, por ejemplo:

```console
$ pip install python-multipart
```

Esto es porque los archivos subidos se env√≠an como "form data".

///

## Importar `File`

Importa `File` y `UploadFile` desde `fastapi`:

{* ../../docs_src/request_files/tutorial001_an_py39.py hl[3] *}

## Definir Par√°metros `File`

Crea par√°metros de archivo de la misma manera que lo har√≠as para `Body` o `Form`:

{* ../../docs_src/request_files/tutorial001_an_py39.py hl[9] *}

/// info | Informaci√≥n

`File` es una clase que hereda directamente de `Form`.

Pero recuerda que cuando importas `Query`, `Path`, `File` y otros desde `fastapi`, esos son en realidad funciones que devuelven clases especiales.

///

/// tip | Consejo

Para declarar cuerpos de File, necesitas usar `File`, porque de otra manera los par√°metros ser√≠an interpretados como par√°metros query o par√°metros de cuerpo (JSON).

///

Los archivos se subir√°n como "form data".

Si declaras el tipo de tu par√°metro de *path operation function* como `bytes`, **FastAPI** leer√° el archivo por ti y recibir√°s el contenido como `bytes`.

Ten en cuenta que esto significa que todo el contenido se almacenar√° en memoria. Esto funcionar√° bien para archivos peque√±os.

Pero hay varios casos en los que podr√≠as beneficiarte de usar `UploadFile`.

## Par√°metros de Archivo con `UploadFile`

Define un par√°metro de archivo con un tipo de `UploadFile`:

{* ../../docs_src/request_files/tutorial001_an_py39.py hl[14] *}

Usar `UploadFile` tiene varias ventajas sobre `bytes`:

* No tienes que usar `File()` en el valor por defecto del par√°metro.
* Usa un archivo "spooled":
    * Un archivo almacenado en memoria hasta un l√≠mite de tama√±o m√°ximo, y despu√©s de superar este l√≠mite, se almacenar√° en el disco.
* Esto significa que funcionar√° bien para archivos grandes como im√°genes, videos, binarios grandes, etc. sin consumir toda la memoria.
* Puedes obtener metadatos del archivo subido.
* Tiene una interfaz `async` <a href="https://docs.python.org/3/glossary.html#term-file-like-object" class="external-link" target="_blank">parecida a un archivo</a>.
* Expone un objeto Python real <a href="https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile" class="external-link" target="_blank">`SpooledTemporaryFile`</a> que puedes pasar directamente a otros paquetes que esperan un objeto parecido a un archivo.

### `UploadFile`

`UploadFile` tiene los siguientes atributos:

* `filename`: Un `str` con el nombre original del archivo que fue subido (por ejemplo, `myimage.jpg`).
* `content_type`: Un `str` con el tipo de contenido (MIME type / media type) (por ejemplo, `image/jpeg`).
* `file`: Un <a href="https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile" class="external-link" target="_blank">`SpooledTemporaryFile`</a> (un objeto <a href="https://docs.python.org/3/glossary.html#term-file-like-object" class="external-link" target="_blank">parecido a un archivo</a>). Este es el objeto de archivo Python real que puedes pasar directamente a otras funciones o paquetes que esperan un objeto "parecido a un archivo".

`UploadFile` tiene los siguientes m√©todos `async`. Todos ellos llaman a los m√©todos correspondientes del archivo por debajo (usando el `SpooledTemporaryFile` interno).

* `write(data)`: Escribe `data` (`str` o `bytes`) en el archivo.
* `read(size)`: Lee `size` (`int`) bytes/caracteres del archivo.
* `seek(offset)`: Va a la posici√≥n de bytes `offset` (`int`) en el archivo.
    * Por ejemplo, `await myfile.seek(0)` ir√≠a al inicio del archivo.
    * Esto es especialmente √∫til si ejecutas `await myfile.read()` una vez y luego necesitas leer el contenido nuevamente.
* `close()`: Cierra el archivo.

Como todos estos m√©todos son m√©todos `async`, necesitas "await" para ellos.

Por ejemplo, dentro de una *path operation function* `async` puedes obtener los contenidos con:

```Python
contents = await myfile.read()
```

Si est√°s dentro de una *path operation function* normal `def`, puedes acceder al `UploadFile.file` directamente, por ejemplo:

```Python
contents = myfile.file.read()
```

/// note | Detalles T√©cnicos de `async`

Cuando usas los m√©todos `async`, **FastAPI** ejecuta los m√©todos del archivo en un threadpool y los espera.

///

/// note | Detalles T√©cnicos de Starlette

El `UploadFile` de **FastAPI** hereda directamente del `UploadFile` de **Starlette**, pero a√±ade algunas partes necesarias para hacerlo compatible con **Pydantic** y las otras partes de FastAPI.

///

## Qu√© es "Form Data"

La manera en que los forms de HTML (`<form></form>`) env√≠an los datos al servidor normalmente utiliza una codificaci√≥n "especial" para esos datos, es diferente de JSON.

**FastAPI** se asegurar√° de leer esos datos del lugar correcto en lugar de JSON.

/// note | Detalles T√©cnicos

Los datos de los forms normalmente se codifican usando el "media type" `application/x-www-form-urlencoded` cuando no incluyen archivos.

Pero cuando el formulario incluye archivos, se codifica como `multipart/form-data`. Si usas `File`, **FastAPI** sabr√° que tiene que obtener los archivos de la parte correcta del cuerpo.

Si deseas leer m√°s sobre estas codificaciones y campos de formularios, dir√≠gete a la <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" class="external-link" target="_blank"><abbr title="Mozilla Developer Network">MDN</abbr> web docs para <code>POST</code></a>.

///

/// warning | Advertencia

Puedes declarar m√∫ltiples par√°metros `File` y `Form` en una *path operation*, pero no puedes declarar campos `Body` que esperas recibir como JSON, ya que el request tendr√° el cuerpo codificado usando `multipart/form-data` en lugar de `application/json`.

Esto no es una limitaci√≥n de **FastAPI**, es parte del protocolo HTTP.

///

## Subida de Archivos Opcional

Puedes hacer un archivo opcional utilizando anotaciones de tipos est√°ndar y estableciendo un valor por defecto de `None`:

{* ../../docs_src/request_files/tutorial001_02_an_py310.py hl[9,17] *}

## `UploadFile` con Metadatos Adicionales

Tambi√©n puedes usar `File()` con `UploadFile`, por ejemplo, para establecer metadatos adicionales:

{* ../../docs_src/request_files/tutorial001_03_an_py39.py hl[9,15] *}

## Subidas de M√∫ltiples Archivos

Es posible subir varios archivos al mismo tiempo.

Estar√≠an asociados al mismo "campo de formulario" enviado usando "form data".

Para usar eso, declara una lista de `bytes` o `UploadFile`:

{* ../../docs_src/request_files/tutorial002_an_py39.py hl[10,15] *}

Recibir√°s, como se declar√≥, una `list` de `bytes` o `UploadFile`s.

/// note | Detalles T√©cnicos

Tambi√©n podr√≠as usar `from starlette.responses import HTMLResponse`.

**FastAPI** proporciona las mismas `starlette.responses` como `fastapi.responses` solo como una conveniencia para ti, el desarrollador. Pero la mayor√≠a de los responses disponibles vienen directamente de Starlette.

///

### Subidas de M√∫ltiples Archivos con Metadatos Adicionales

Y de la misma manera que antes, puedes usar `File()` para establecer par√°metros adicionales, incluso para `UploadFile`:

{* ../../docs_src/request_files/tutorial003_an_py39.py hl[11,18:20] *}

## Recapitulaci√≥n

Usa `File`, `bytes` y `UploadFile` para declarar archivos que se subir√°n en el request, enviados como form data.


================================================
File: /docs/es/docs/tutorial/request-form-models.md
================================================
# Modelos de Formulario

Puedes usar **modelos de Pydantic** para declarar **campos de formulario** en FastAPI.

/// info | Informaci√≥n

Para usar formularios, primero instala <a href="https://github.com/Kludex/python-multipart" class="external-link" target="_blank">`python-multipart`</a>.

Aseg√∫rate de crear un [entorno virtual](../virtual-environments.md){.internal-link target=_blank}, activarlo, y luego instalarlo, por ejemplo:

```console
$ pip install python-multipart
```

///

/// note | Nota

Esto es compatible desde la versi√≥n `0.113.0` de FastAPI. ü§ì

///

## Modelos de Pydantic para Formularios

Solo necesitas declarar un **modelo de Pydantic** con los campos que quieres recibir como **campos de formulario**, y luego declarar el par√°metro como `Form`:

{* ../../docs_src/request_form_models/tutorial001_an_py39.py hl[9:11,15] *}

**FastAPI** **extraer√°** los datos de **cada campo** de los **form data** en el request y te dar√° el modelo de Pydantic que definiste.

## Revisa la Documentaci√≥n

Puedes verificarlo en la interfaz de documentaci√≥n en `/docs`:

<div class="screenshot">
<img src="/img/tutorial/request-form-models/image01.png">
</div>

## Prohibir Campos de Formulario Extra

En algunos casos de uso especiales (probablemente no muy comunes), podr√≠as querer **restringir** los campos de formulario a solo aquellos declarados en el modelo de Pydantic. Y **prohibir** cualquier campo **extra**.

/// note | Nota

Esto es compatible desde la versi√≥n `0.114.0` de FastAPI. ü§ì

///

Puedes usar la configuraci√≥n del modelo de Pydantic para `forbid` cualquier campo `extra`:

{* ../../docs_src/request_form_models/tutorial002_an_py39.py hl[12] *}

Si un cliente intenta enviar datos extra, recibir√° un response de **error**.

Por ejemplo, si el cliente intenta enviar los campos de formulario:

* `username`: `Rick`
* `password`: `Portal Gun`
* `extra`: `Mr. Poopybutthole`

Recibir√° un response de error indicando que el campo `extra` no est√° permitido:

```json
{
    "detail": [
        {
            "type": "extra_forbidden",
            "loc": ["body", "extra"],
            "msg": "Extra inputs are not permitted",
            "input": "Mr. Poopybutthole"
        }
    ]
}
```

## Resumen

Puedes usar modelos de Pydantic para declarar campos de formulario en FastAPI. üòé


================================================
File: /docs/es/docs/tutorial/request-forms-and-files.md
================================================
# Request Forms and Files

Puedes definir archivos y campos de formulario al mismo tiempo usando `File` y `Form`.

/// info | Informaci√≥n

Para recibir archivos subidos y/o form data, primero instala <a href="https://github.com/Kludex/python-multipart" class="external-link" target="_blank">`python-multipart`</a>.

Aseg√∫rate de crear un [entorno virtual](../virtual-environments.md){.internal-link target=_blank}, act√≠valo y luego inst√°lalo, por ejemplo:

```console
$ pip install python-multipart
```

///

## Importar `File` y `Form`

{* ../../docs_src/request_forms_and_files/tutorial001_an_py39.py hl[3] *}

## Definir par√°metros `File` y `Form`

Crea par√°metros de archivo y formulario de la misma manera que lo har√≠as para `Body` o `Query`:

{* ../../docs_src/request_forms_and_files/tutorial001_an_py39.py hl[10:12] *}

Los archivos y campos de formulario se subir√°n como form data y recibir√°s los archivos y campos de formulario.

Y puedes declarar algunos de los archivos como `bytes` y algunos como `UploadFile`.

/// warning | Advertencia

Puedes declarar m√∫ltiples par√°metros `File` y `Form` en una *path operation*, pero no puedes tambi√©n declarar campos `Body` que esperas recibir como JSON, ya que el request tendr√° el body codificado usando `multipart/form-data` en lugar de `application/json`.

Esto no es una limitaci√≥n de **FastAPI**, es parte del protocolo HTTP.

///

## Resumen

Usa `File` y `Form` juntos cuando necesites recibir datos y archivos en el mismo request.


================================================
File: /docs/es/docs/tutorial/request-forms.md
================================================
# Form Data

Cuando necesitas recibir campos de formulario en lugar de JSON, puedes usar `Form`.

/// info | Informaci√≥n

Para usar forms, primero instala <a href="https://github.com/Kludex/python-multipart" class="external-link" target="_blank">`python-multipart`</a>.

Aseg√∫rate de crear un [entorno virtual](../virtual-environments.md){.internal-link target=_blank}, activarlo, y luego instalarlo, por ejemplo:

```console
$ pip install python-multipart
```

///

## Importar `Form`

Importar `Form` desde `fastapi`:

{* ../../docs_src/request_forms/tutorial001_an_py39.py hl[3] *}

## Definir par√°metros de `Form`

Crea par√°metros de formulario de la misma manera que lo har√≠as para `Body` o `Query`:

{* ../../docs_src/request_forms/tutorial001_an_py39.py hl[9] *}

Por ejemplo, en una de las formas en las que se puede usar la especificaci√≥n OAuth2 (llamada "password flow") se requiere enviar un `username` y `password` como campos de formulario.

La <abbr title="specification">especificaci√≥n</abbr> requiere que los campos se llamen exactamente `username` y `password`, y que se env√≠en como campos de formulario, no JSON.

Con `Form` puedes declarar las mismas configuraciones que con `Body` (y `Query`, `Path`, `Cookie`), incluyendo validaci√≥n, ejemplos, un alias (por ejemplo, `user-name` en lugar de `username`), etc.

/// info | Informaci√≥n

`Form` es una clase que hereda directamente de `Body`.

///

/// tip | Consejo

Para declarar bodies de forms, necesitas usar `Form` expl√≠citamente, porque sin √©l, los par√°metros se interpretar√≠an como par√°metros de query o como par√°metros de body (JSON).

///

## Sobre "Campos de Formulario"

La manera en que los forms HTML (`<form></form>`) env√≠an los datos al servidor normalmente usa una codificaci√≥n "especial" para esos datos, es diferente de JSON.

**FastAPI** se encargar√° de leer esos datos del lugar correcto en lugar de JSON.

/// note | Detalles t√©cnicos

Los datos de forms normalmente se codifican usando el "media type" `application/x-www-form-urlencoded`.

Pero cuando el formulario incluye archivos, se codifica como `multipart/form-data`. Leer√°s sobre la gesti√≥n de archivos en el pr√≥ximo cap√≠tulo.

Si quieres leer m√°s sobre estas codificaciones y campos de formulario, dir√≠gete a la <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" class="external-link" target="_blank"><abbr title="Mozilla Developer Network">MDN</abbr> web docs para <code>POST</code></a>.

///

/// warning | Advertencia

Puedes declarar m√∫ltiples par√°metros `Form` en una *path operation*, pero no puedes tambi√©n declarar campos `Body` que esperas recibir como JSON, ya que el request tendr√° el body codificado usando `application/x-www-form-urlencoded` en lugar de `application/json`.

Esto no es una limitaci√≥n de **FastAPI**, es parte del protocolo HTTP.

///

## Recapitulaci√≥n

Usa `Form` para declarar par√°metros de entrada de datos de formulario.


================================================
File: /docs/es/docs/tutorial/response-model.md
================================================
# Modelo de Response - Tipo de Retorno

Puedes declarar el tipo utilizado para el response anotando el **tipo de retorno** de la *path operation function*.

Puedes utilizar **anotaciones de tipos** de la misma manera que lo har√≠as para datos de entrada en **par√°metros** de funci√≥n, puedes utilizar modelos de Pydantic, listas, diccionarios, valores escalares como enteros, booleanos, etc.

{* ../../docs_src/response_model/tutorial001_01_py310.py hl[16,21] *}

FastAPI usar√° este tipo de retorno para:

* **Validar** los datos devueltos.
    * Si los datos son inv√°lidos (por ejemplo, falta un campo), significa que el c√≥digo de *tu* aplicaci√≥n est√° defectuoso, no devolviendo lo que deber√≠a, y retornar√° un error del servidor en lugar de devolver datos incorrectos. De esta manera, t√∫ y tus clientes pueden estar seguros de que recibir√°n los datos y la forma de los datos esperada.
* Agregar un **JSON Schema** para el response, en la *path operation* de OpenAPI.
    * Esto ser√° utilizado por la **documentaci√≥n autom√°tica**.
    * Tambi√©n ser√° utilizado por herramientas de generaci√≥n autom√°tica de c√≥digo de cliente.

Pero lo m√°s importante:

* **Limitar√° y filtrar√°** los datos de salida a lo que se define en el tipo de retorno.
    * Esto es particularmente importante para la **seguridad**, veremos m√°s sobre eso a continuaci√≥n.

## Par√°metro `response_model`

Hay algunos casos en los que necesitas o quieres devolver algunos datos que no son exactamente lo que declara el tipo.

Por ejemplo, podr√≠as querer **devolver un diccionario** u objeto de base de datos, pero **declararlo como un modelo de Pydantic**. De esta manera el modelo de Pydantic har√≠a toda la documentaci√≥n de datos, validaci√≥n, etc. para el objeto que devolviste (por ejemplo, un diccionario u objeto de base de datos).

Si a√±adiste la anotaci√≥n del tipo de retorno, las herramientas y editores se quejar√≠an con un error (correcto) dici√©ndote que tu funci√≥n est√° devolviendo un tipo (por ejemplo, un dict) que es diferente de lo que declaraste (por ejemplo, un modelo de Pydantic).

En esos casos, puedes usar el par√°metro del decorador de path operation `response_model` en lugar del tipo de retorno.

Puedes usar el par√°metro `response_model` en cualquiera de las *path operations*:

* `@app.get()`
* `@app.post()`
* `@app.put()`
* `@app.delete()`
* etc.

{* ../../docs_src/response_model/tutorial001_py310.py hl[17,22,24:27] *}

/// note | Nota

Observa que `response_model` es un par√°metro del m√©todo "decorador" (`get`, `post`, etc). No de tu *path operation function*, como todos los par√°metros y el cuerpo.

///

`response_model` recibe el mismo tipo que declarar√≠as para un campo de modelo Pydantic, por lo que puede ser un modelo de Pydantic, pero tambi√©n puede ser, por ejemplo, un `list` de modelos de Pydantic, como `List[Item]`.

FastAPI usar√° este `response_model` para hacer toda la documentaci√≥n de datos, validaci√≥n, etc. y tambi√©n para **convertir y filtrar los datos de salida** a su declaraci√≥n de tipo.

/// tip | Consejo

Si tienes chequeos estrictos de tipos en tu editor, mypy, etc., puedes declarar el tipo de retorno de la funci√≥n como `Any`.

De esa manera le dices al editor que intencionalmente est√°s devolviendo cualquier cosa. Pero FastAPI todav√≠a har√° la documentaci√≥n de datos, validaci√≥n, filtrado, etc. con `response_model`.

///

### Prioridad del `response_model`

Si declaras tanto un tipo de retorno como un `response_model`, el `response_model` tomar√° prioridad y ser√° utilizado por FastAPI.

De esta manera puedes a√±adir anotaciones de tipos correctas a tus funciones incluso cuando est√°s devolviendo un tipo diferente al modelo de response, para ser utilizado por el editor y herramientas como mypy. Y a√∫n as√≠ puedes hacer que FastAPI realice la validaci√≥n de datos, documentaci√≥n, etc. usando el `response_model`.

Tambi√©n puedes usar `response_model=None` para desactivar la creaci√≥n de un modelo de response para esa *path operation*, podr√≠as necesitar hacerlo si est√°s a√±adiendo anotaciones de tipos para cosas que no son campos v√°lidos de Pydantic, ver√°s un ejemplo de eso en una de las secciones a continuaci√≥n.

## Devolver los mismos datos de entrada

Aqu√≠ estamos declarando un modelo `UserIn`, contendr√° una contrase√±a en texto plano:

{* ../../docs_src/response_model/tutorial002_py310.py hl[7,9] *}

/// info | Informaci√≥n

Para usar `EmailStr`, primero instala <a href="https://github.com/JoshData/python-email-validator" class="external-link" target="_blank">`email-validator`</a>.

Aseg√∫rate de crear un [entorno virtual](../virtual-environments.md){.internal-link target=_blank}, activarlo, y luego instalarlo, por ejemplo:

```console
$ pip install email-validator
```

o con:

```console
$ pip install "pydantic[email]"
```

///

Y estamos usando este modelo para declarar nuestra entrada y el mismo modelo para declarar nuestra salida:

{* ../../docs_src/response_model/tutorial002_py310.py hl[16] *}

Ahora, cada vez que un navegador est√© creando un usuario con una contrase√±a, la API devolver√° la misma contrase√±a en el response.

En este caso, podr√≠a no ser un problema, porque es el mismo usuario que env√≠a la contrase√±a.

Pero si usamos el mismo modelo para otra *path operation*, podr√≠amos estar enviando las contrase√±as de nuestros usuarios a cada cliente.

/// danger | Peligro

Nunca almacenes la contrase√±a en texto plano de un usuario ni la env√≠es en un response como esta, a menos que conozcas todas las advertencias y sepas lo que est√°s haciendo.

///

## A√±adir un modelo de salida

Podemos en cambio crear un modelo de entrada con la contrase√±a en texto plano y un modelo de salida sin ella:

{* ../../docs_src/response_model/tutorial003_py310.py hl[9,11,16] *}

Aqu√≠, aunque nuestra *path operation function* est√° devolviendo el mismo usuario de entrada que contiene la contrase√±a:

{* ../../docs_src/response_model/tutorial003_py310.py hl[24] *}

...hemos declarado el `response_model` para ser nuestro modelo `UserOut`, que no incluye la contrase√±a:

{* ../../docs_src/response_model/tutorial003_py310.py hl[22] *}

Entonces, **FastAPI** se encargar√° de filtrar todos los datos que no est√©n declarados en el modelo de salida (usando Pydantic).

### `response_model` o Tipo de Retorno

En este caso, como los dos modelos son diferentes, si anot√°ramos el tipo de retorno de la funci√≥n como `UserOut`, el editor y las herramientas se quejar√≠an de que estamos devolviendo un tipo inv√°lido, ya que son clases diferentes.

Por eso en este ejemplo tenemos que declararlo en el par√°metro `response_model`.

...pero sigue leyendo abajo para ver c√≥mo superar eso.

## Tipo de Retorno y Filtrado de Datos

Continuemos con el ejemplo anterior. Quer√≠amos **anotar la funci√≥n con un tipo**, pero quer√≠amos poder devolver desde la funci√≥n algo que en realidad incluya **m√°s datos**.

Queremos que FastAPI contin√∫e **filtrando** los datos usando el modelo de response. Para que, incluso cuando la funci√≥n devuelva m√°s datos, el response solo incluya los campos declarados en el modelo de response.

En el ejemplo anterior, debido a que las clases eran diferentes, tuvimos que usar el par√°metro `response_model`. Pero eso tambi√©n significa que no obtenemos el soporte del editor y las herramientas verificando el tipo de retorno de la funci√≥n.

Pero en la mayor√≠a de los casos en los que necesitamos hacer algo como esto, queremos que el modelo solo **filtre/elimine** algunos de los datos como en este ejemplo.

Y en esos casos, podemos usar clases y herencia para aprovechar las **anotaciones de tipos** de funciones para obtener mejor soporte en el editor y herramientas, y a√∫n as√≠ obtener el **filtrado de datos** de FastAPI.

{* ../../docs_src/response_model/tutorial003_01_py310.py hl[7:10,13:14,18] *}

Con esto, obtenemos soporte de las herramientas, de los editores y mypy ya que este c√≥digo es correcto en t√©rminos de tipos, pero tambi√©n obtenemos el filtrado de datos de FastAPI.

¬øC√≥mo funciona esto? Vamos a echarle un vistazo. ü§ì

### Anotaciones de Tipos y Herramientas

Primero vamos a ver c√≥mo los editores, mypy y otras herramientas ver√≠an esto.

`BaseUser` tiene los campos base. Luego `UserIn` hereda de `BaseUser` y a√±ade el campo `password`, por lo que incluir√° todos los campos de ambos modelos.

Anotamos el tipo de retorno de la funci√≥n como `BaseUser`, pero en realidad estamos devolviendo una instancia de `UserIn`.

El editor, mypy y otras herramientas no se quejar√°n de esto porque, en t√©rminos de tipificaci√≥n, `UserIn` es una subclase de `BaseUser`, lo que significa que es un tipo *v√°lido* cuando se espera algo que es un `BaseUser`.

### Filtrado de Datos en FastAPI

Ahora, para FastAPI, ver√° el tipo de retorno y se asegurar√° de que lo que devuelves incluya **solo** los campos que est√°n declarados en el tipo.

FastAPI realiza varias cosas internamente con Pydantic para asegurarse de que esas mismas reglas de herencia de clases no se utilicen para el filtrado de datos devueltos, de lo contrario, podr√≠as terminar devolviendo muchos m√°s datos de los que esperabas.

De esta manera, puedes obtener lo mejor de ambos mundos: anotaciones de tipos con **soporte de herramientas** y **filtrado de datos**.

## Verlo en la documentaci√≥n

Cuando veas la documentaci√≥n autom√°tica, puedes verificar que el modelo de entrada y el modelo de salida tendr√°n cada uno su propio JSON Schema:

<img src="/img/tutorial/response-model/image01.png">

Y ambos modelos se utilizar√°n para la documentaci√≥n interactiva de la API:

<img src="/img/tutorial/response-model/image02.png">

## Otras Anotaciones de Tipos de Retorno

Podr√≠a haber casos en los que devuelvas algo que no es un campo v√°lido de Pydantic y lo anotes en la funci√≥n, solo para obtener el soporte proporcionado por las herramientas (el editor, mypy, etc).

### Devolver un Response Directamente

El caso m√°s com√∫n ser√≠a [devolver un Response directamente como se explica m√°s adelante en la documentaci√≥n avanzada](../advanced/response-directly.md){.internal-link target=_blank}.

{* ../../docs_src/response_model/tutorial003_02.py hl[8,10:11] *}

Este caso simple es manejado autom√°ticamente por FastAPI porque la anotaci√≥n del tipo de retorno es la clase (o una subclase de) `Response`.

Y las herramientas tambi√©n estar√°n felices porque tanto `RedirectResponse` como `JSONResponse` son subclases de `Response`, por lo que la anotaci√≥n del tipo es correcta.

### Anotar una Subclase de Response

Tambi√©n puedes usar una subclase de `Response` en la anotaci√≥n del tipo:

{* ../../docs_src/response_model/tutorial003_03.py hl[8:9] *}

Esto tambi√©n funcionar√° porque `RedirectResponse` es una subclase de `Response`, y FastAPI manejar√° autom√°ticamente este caso simple.

### Anotaciones de Tipos de Retorno Inv√°lidas

Pero cuando devuelves alg√∫n otro objeto arbitrario que no es un tipo v√°lido de Pydantic (por ejemplo, un objeto de base de datos) y lo anotas as√≠ en la funci√≥n, FastAPI intentar√° crear un modelo de response de Pydantic a partir de esa anotaci√≥n de tipo, y fallar√°.

Lo mismo suceder√≠a si tuvieras algo como un <abbr title='Una uni√≥n entre m√∫ltiples tipos significa "cualquiera de estos tipos".'>union</abbr> entre diferentes tipos donde uno o m√°s de ellos no son tipos v√°lidos de Pydantic, por ejemplo esto fallar√≠a üí•:

{* ../../docs_src/response_model/tutorial003_04_py310.py hl[8] *}

...esto falla porque la anotaci√≥n de tipo no es un tipo de Pydantic y no es solo una sola clase `Response` o subclase, es una uni√≥n (cualquiera de los dos) entre una `Response` y un `dict`.

### Desactivar el Modelo de Response

Continuando con el ejemplo anterior, puede que no quieras tener la validaci√≥n de datos por defecto, documentaci√≥n, filtrado, etc. que realiza FastAPI.

Pero puedes querer mantener la anotaci√≥n del tipo de retorno en la funci√≥n para obtener el soporte de herramientas como editores y verificadores de tipos (por ejemplo, mypy).

En este caso, puedes desactivar la generaci√≥n del modelo de response configurando `response_model=None`:

{* ../../docs_src/response_model/tutorial003_05_py310.py hl[7] *}

Esto har√° que FastAPI omita la generaci√≥n del modelo de response y de esa manera puedes tener cualquier anotaci√≥n de tipo de retorno que necesites sin que afecte a tu aplicaci√≥n FastAPI. ü§ì

## Par√°metros de codificaci√≥n del Modelo de Response

Tu modelo de response podr√≠a tener valores por defecto, como:

{* ../../docs_src/response_model/tutorial004_py310.py hl[9,11:12] *}

* `description: Union[str, None] = None` (o `str | None = None` en Python 3.10) tiene un valor por defecto de `None`.
* `tax: float = 10.5` tiene un valor por defecto de `10.5`.
* `tags: List[str] = []` tiene un valor por defecto de una lista vac√≠a: `[]`.

pero podr√≠as querer omitirlos del resultado si no fueron en realidad almacenados.

Por ejemplo, si tienes modelos con muchos atributos opcionales en una base de datos NoSQL, pero no quieres enviar responses JSON muy largos llenos de valores por defecto.

### Usa el par√°metro `response_model_exclude_unset`

Puedes configurar el par√°metro del decorador de path operation `response_model_exclude_unset=True`:

{* ../../docs_src/response_model/tutorial004_py310.py hl[22] *}

y esos valores por defecto no ser√°n incluidos en el response, solo los valores realmente establecidos.

Entonces, si env√≠as un request a esa *path operation* para el √≠tem con ID `foo`, el response (no incluyendo valores por defecto) ser√°:

```JSON
{
    "name": "Foo",
    "price": 50.2
}
```

/// info | Informaci√≥n

En Pydantic v1 el m√©todo se llamaba `.dict()`, fue deprecado (pero a√∫n soportado) en Pydantic v2, y renombrado a `.model_dump()`.

Los ejemplos aqu√≠ usan `.dict()` para compatibilidad con Pydantic v1, pero deber√≠as usar `.model_dump()` en su lugar si puedes usar Pydantic v2.

///

/// info | Informaci√≥n

FastAPI usa el m√©todo `.dict()` del modelo de Pydantic con <a href="https://docs.pydantic.dev/1.10/usage/exporting_models/#modeldict" class="external-link" target="_blank">su par√°metro `exclude_unset`</a> para lograr esto.

///

/// info | Informaci√≥n

Tambi√©n puedes usar:

* `response_model_exclude_defaults=True`
* `response_model_exclude_none=True`

como se describe en <a href="https://docs.pydantic.dev/1.10/usage/exporting_models/#modeldict" class="external-link" target="_blank">la documentaci√≥n de Pydantic</a> para `exclude_defaults` y `exclude_none`.

///

#### Datos con valores para campos con valores por defecto

Pero si tus datos tienen valores para los campos del modelo con valores por defecto, como el art√≠culo con ID `bar`:

```Python hl_lines="3  5"
{
    "name": "Bar",
    "description": "The bartenders",
    "price": 62,
    "tax": 20.2
}
```

ser√°n incluidos en el response.

#### Datos con los mismos valores que los valores por defecto

Si los datos tienen los mismos valores que los valores por defecto, como el art√≠culo con ID `baz`:

```Python hl_lines="3  5-6"
{
    "name": "Baz",
    "description": None,
    "price": 50.2,
    "tax": 10.5,
    "tags": []
}
```

FastAPI es lo suficientemente inteligente (de hecho, Pydantic es lo suficientemente inteligente) para darse cuenta de que, a pesar de que `description`, `tax` y `tags` tienen los mismos valores que los valores por defecto, fueron establecidos expl√≠citamente (en lugar de tomados de los valores por defecto).

Por lo tanto, se incluir√°n en el response JSON.

/// tip | Consejo

Ten en cuenta que los valores por defecto pueden ser cualquier cosa, no solo `None`.

Pueden ser una lista (`[]`), un `float` de `10.5`, etc.

///

### `response_model_include` y `response_model_exclude`

Tambi√©n puedes usar los par√°metros del decorador de path operation `response_model_include` y `response_model_exclude`.

Aceptan un `set` de `str` con el nombre de los atributos a incluir (omitiendo el resto) o excluir (incluyendo el resto).

Esto se puede usar como un atajo r√°pido si solo tienes un modelo de Pydantic y quieres eliminar algunos datos de la salida.

/// tip | Consejo

Pero todav√≠a se recomienda usar las ideas anteriores, usando m√∫ltiples clases, en lugar de estos par√°metros.

Esto se debe a que el JSON Schema generado en el OpenAPI de tu aplicaci√≥n (y la documentaci√≥n) a√∫n ser√° el del modelo completo, incluso si usas `response_model_include` o `response_model_exclude` para omitir algunos atributos.

Esto tambi√©n se aplica a `response_model_by_alias` que funciona de manera similar.

///

{* ../../docs_src/response_model/tutorial005_py310.py hl[29,35] *}

/// tip | Consejo

La sintaxis `{"name", "description"}` crea un `set` con esos dos valores.

Es equivalente a `set(["name", "description"])`.

///

#### Usar `list`s en lugar de `set`s

Si olvidas usar un `set` y usas un `list` o `tuple` en su lugar, FastAPI todav√≠a lo convertir√° a un `set` y funcionar√° correctamente:

{* ../../docs_src/response_model/tutorial006_py310.py hl[29,35] *}

## Resumen

Usa el par√°metro `response_model` del *decorador de path operation* para definir modelos de response y especialmente para asegurarte de que los datos privados sean filtrados.

Usa `response_model_exclude_unset` para devolver solo los valores establecidos expl√≠citamente.


================================================
File: /docs/es/docs/tutorial/response-status-code.md
================================================
# C√≥digo de Estado del Response

De la misma manera que puedes especificar un modelo de response, tambi√©n puedes declarar el c√≥digo de estado HTTP usado para el response con el par√°metro `status_code` en cualquiera de las *path operations*:

* `@app.get()`
* `@app.post()`
* `@app.put()`
* `@app.delete()`
* etc.

{* ../../docs_src/response_status_code/tutorial001.py hl[6] *}

/// note | Nota

Observa que `status_code` es un par√°metro del m√©todo "decorador" (`get`, `post`, etc). No de tu *path operation function*, como todos los par√°metros y body.

///

El par√°metro `status_code` recibe un n√∫mero con el c√≥digo de estado HTTP.

/// info | Informaci√≥n

`status_code` tambi√©n puede recibir un `IntEnum`, como por ejemplo el <a href="https://docs.python.org/3/library/http.html#http.HTTPStatus" class="external-link" target="_blank">`http.HTTPStatus`</a> de Python.

///

Esto har√°:

* Devolver ese c√≥digo de estado en el response.
* Documentarlo como tal en el esquema de OpenAPI (y por lo tanto, en las interfaces de usuario):

<img src="/img/tutorial/response-status-code/image01.png">

/// note | Nota

Algunos c√≥digos de response (ver la siguiente secci√≥n) indican que el response no tiene un body.

FastAPI sabe esto, y producir√° documentaci√≥n OpenAPI que establece que no hay un response body.

///

## Acerca de los c√≥digos de estado HTTP

/// note | Nota

Si ya sabes qu√© son los c√≥digos de estado HTTP, salta a la siguiente secci√≥n.

///

En HTTP, env√≠as un c√≥digo de estado num√©rico de 3 d√≠gitos como parte del response.

Estos c√≥digos de estado tienen un nombre asociado para reconocerlos, pero la parte importante es el n√∫mero.

En breve:

* `100` y superiores son para "Informaci√≥n". Rara vez los usas directamente. Los responses con estos c√≥digos de estado no pueden tener un body.
* **`200`** y superiores son para responses "Exitosos". Estos son los que usar√≠as m√°s.
    * `200` es el c√≥digo de estado por defecto, lo que significa que todo estaba "OK".
    * Otro ejemplo ser√≠a `201`, "Created". Com√∫nmente se usa despu√©s de crear un nuevo registro en la base de datos.
    * Un caso especial es `204`, "No Content". Este response se usa cuando no hay contenido para devolver al cliente, por lo tanto, el response no debe tener un body.
* **`300`** y superiores son para "Redirecci√≥n". Los responses con estos c√≥digos de estado pueden o no tener un body, excepto `304`, "Not Modified", que no debe tener uno.
* **`400`** y superiores son para responses de "Error del Cliente". Este es el segundo tipo que probablemente m√°s usar√≠as.
    * Un ejemplo es `404`, para un response "Not Found".
    * Para errores gen√©ricos del cliente, puedes usar simplemente `400`.
* `500` y superiores son para errores del servidor. Casi nunca los usas directamente. Cuando algo sale mal en alguna parte de tu c√≥digo de aplicaci√≥n, o del servidor, autom√°ticamente devolver√° uno de estos c√≥digos de estado.

/// tip | Consejo

Para saber m√°s sobre cada c√≥digo de estado y qu√© c√≥digo es para qu√©, revisa la <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" class="external-link" target="_blank">documentaci√≥n de <abbr title="Mozilla Developer Network">MDN</abbr> sobre c√≥digos de estado HTTP</a>.

///

## Atajo para recordar los nombres

Veamos de nuevo el ejemplo anterior:

{* ../../docs_src/response_status_code/tutorial001.py hl[6] *}

`201` es el c√≥digo de estado para "Created".

Pero no tienes que memorizar lo que significa cada uno de estos c√≥digos.

Puedes usar las variables de conveniencia de `fastapi.status`.

{* ../../docs_src/response_status_code/tutorial002.py hl[1,6] *}

Son solo una conveniencia, mantienen el mismo n√∫mero, pero de esa manera puedes usar el autocompletado del editor para encontrarlos:

<img src="/img/tutorial/response-status-code/image02.png">

/// note | Nota T√©cnica

Tambi√©n podr√≠as usar `from starlette import status`.

**FastAPI** proporciona el mismo `starlette.status` como `fastapi.status` solo como una conveniencia para ti, el desarrollador. Pero proviene directamente de Starlette.

///

## Cambiando el valor por defecto

M√°s adelante, en la [Gu√≠a de Usuario Avanzada](../advanced/response-change-status-code.md){.internal-link target=_blank}, ver√°s c√≥mo devolver un c√≥digo de estado diferente al valor por defecto que est√°s declarando aqu√≠.


================================================
File: /docs/es/docs/tutorial/schema-extra-example.md
================================================
# Declarar Ejemplos de Request

Puedes declarar ejemplos de los datos que tu aplicaci√≥n puede recibir.

Aqu√≠ tienes varias formas de hacerlo.

## Datos extra de JSON Schema en modelos de Pydantic

Puedes declarar `examples` para un modelo de Pydantic que se a√±adir√° al JSON Schema generado.

//// tab | Pydantic v2

{* ../../docs_src/schema_extra_example/tutorial001_py310.py hl[13:24] *}

////

//// tab | Pydantic v1

{* ../../docs_src/schema_extra_example/tutorial001_pv1_py310.py hl[13:23] *}

////

Esa informaci√≥n extra se a√±adir√° tal cual al **JSON Schema** generado para ese modelo, y se usar√° en la documentaci√≥n de la API.

//// tab | Pydantic v2

En Pydantic versi√≥n 2, usar√≠as el atributo `model_config`, que toma un `dict` como se describe en <a href="https://docs.pydantic.dev/latest/api/config/" class="external-link" target="_blank">la documentaci√≥n de Pydantic: Configuraci√≥n</a>.

Puedes establecer `"json_schema_extra"` con un `dict` que contenga cualquier dato adicional que desees que aparezca en el JSON Schema generado, incluyendo `examples`.

////

//// tab | Pydantic v1

En Pydantic versi√≥n 1, usar√≠as una clase interna `Config` y `schema_extra`, como se describe en <a href="https://docs.pydantic.dev/1.10/usage/schema/#schema-customization" class="external-link" target="_blank">la documentaci√≥n de Pydantic: Personalizaci√≥n de Esquema</a>.

Puedes establecer `schema_extra` con un `dict` que contenga cualquier dato adicional que desees que aparezca en el JSON Schema generado, incluyendo `examples`.

////

/// tip | Consejo

Podr√≠as usar la misma t√©cnica para extender el JSON Schema y a√±adir tu propia informaci√≥n extra personalizada.

Por ejemplo, podr√≠as usarlo para a√±adir metadatos para una interfaz de usuario frontend, etc.

///

/// info | Informaci√≥n

OpenAPI 3.1.0 (usado desde FastAPI 0.99.0) a√±adi√≥ soporte para `examples`, que es parte del est√°ndar de **JSON Schema**.

Antes de eso, solo soportaba la palabra clave `example` con un solo ejemplo. Eso a√∫n es soportado por OpenAPI 3.1.0, pero est√° obsoleto y no es parte del est√°ndar de JSON Schema. As√≠ que se recomienda migrar de `example` a `examples`. ü§ì

Puedes leer m√°s al final de esta p√°gina.

///

## Argumentos adicionales en `Field`

Cuando usas `Field()` con modelos de Pydantic, tambi√©n puedes declarar `examples` adicionales:

{* ../../docs_src/schema_extra_example/tutorial002_py310.py hl[2,8:11] *}

## `examples` en JSON Schema - OpenAPI

Cuando usas cualquiera de:

* `Path()`
* `Query()`
* `Header()`
* `Cookie()`
* `Body()`
* `Form()`
* `File()`

tambi√©n puedes declarar un grupo de `examples` con informaci√≥n adicional que se a√±adir√° a sus **JSON Schemas** dentro de **OpenAPI**.

### `Body` con `examples`

Aqu√≠ pasamos `examples` que contiene un ejemplo de los datos esperados en `Body()`:

{* ../../docs_src/schema_extra_example/tutorial003_an_py310.py hl[22:29] *}

### Ejemplo en la interfaz de documentaci√≥n

Con cualquiera de los m√©todos anteriores se ver√≠a as√≠ en los `/docs`:

<img src="/img/tutorial/body-fields/image01.png">

### `Body` con m√∫ltiples `examples`

Por supuesto, tambi√©n puedes pasar m√∫ltiples `examples`:

{* ../../docs_src/schema_extra_example/tutorial004_an_py310.py hl[23:38] *}

Cuando haces esto, los ejemplos ser√°n parte del **JSON Schema** interno para esos datos de body.

Sin embargo, al <abbr title="2023-08-26">momento de escribir esto</abbr>, Swagger UI, la herramienta encargada de mostrar la interfaz de documentaci√≥n, no soporta mostrar m√∫ltiples ejemplos para los datos en **JSON Schema**. Pero lee m√°s abajo para una soluci√≥n alternativa.

### `examples` espec√≠ficos de OpenAPI

Desde antes de que **JSON Schema** soportara `examples`, OpenAPI ten√≠a soporte para un campo diferente tambi√©n llamado `examples`.

Estos `examples` espec√≠ficos de **OpenAPI** van en otra secci√≥n en la especificaci√≥n de OpenAPI. Van en los **detalles para cada *path operation***, no dentro de cada JSON Schema.

Y Swagger UI ha soportado este campo particular de `examples` por un tiempo. As√≠ que, puedes usarlo para **mostrar** diferentes **ejemplos en la interfaz de documentaci√≥n**.

La forma de este campo espec√≠fico de OpenAPI `examples` es un `dict` con **m√∫ltiples ejemplos** (en lugar de una `list`), cada uno con informaci√≥n adicional que tambi√©n se a√±adir√° a **OpenAPI**.

Esto no va dentro de cada JSON Schema contenido en OpenAPI, esto va afuera, directamente en la *path operation*.

### Usando el Par√°metro `openapi_examples`

Puedes declarar los `examples` espec√≠ficos de OpenAPI en FastAPI con el par√°metro `openapi_examples` para:

* `Path()`
* `Query()`
* `Header()`
* `Cookie()`
* `Body()`
* `Form()`
* `File()`

Las claves del `dict` identifican cada ejemplo, y cada valor es otro `dict`.

Cada `dict` espec√≠fico del ejemplo en los `examples` puede contener:

* `summary`: Descripci√≥n corta del ejemplo.
* `description`: Una descripci√≥n larga que puede contener texto Markdown.
* `value`: Este es el ejemplo real mostrado, e.g. un `dict`.
* `externalValue`: alternativa a `value`, una URL que apunta al ejemplo. Aunque esto puede no ser soportado por tantas herramientas como `value`.

Puedes usarlo as√≠:

{* ../../docs_src/schema_extra_example/tutorial005_an_py310.py hl[23:49] *}

### Ejemplos de OpenAPI en la Interfaz de Documentaci√≥n

Con `openapi_examples` a√±adido a `Body()`, los `/docs` se ver√≠an as√≠:

<img src="/img/tutorial/body-fields/image02.png">

## Detalles T√©cnicos

/// tip | Consejo

Si ya est√°s usando la versi√≥n **0.99.0 o superior** de **FastAPI**, probablemente puedes **omitir** estos detalles.

Son m√°s relevantes para versiones m√°s antiguas, antes de que OpenAPI 3.1.0 estuviera disponible.

Puedes considerar esto una breve lecci√≥n de **historia** de OpenAPI y JSON Schema. ü§ì

///

/// warning | Advertencia

Estos son detalles muy t√©cnicos sobre los est√°ndares **JSON Schema** y **OpenAPI**.

Si las ideas anteriores ya funcionan para ti, eso podr√≠a ser suficiente, y probablemente no necesites estos detalles, si√©ntete libre de omitirlos.

///

Antes de OpenAPI 3.1.0, OpenAPI usaba una versi√≥n m√°s antigua y modificada de **JSON Schema**.

JSON Schema no ten√≠a `examples`, as√≠ que OpenAPI a√±adi√≥ su propio campo `example` a su versi√≥n modificada.

OpenAPI tambi√©n a√±adi√≥ los campos `example` y `examples` a otras partes de la especificaci√≥n:

* <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#parameter-object" class="external-link" target="_blank">`Parameter Object` (en la especificaci√≥n)</a> que era usado por FastAPI:
    * `Path()`
    * `Query()`
    * `Header()`
    * `Cookie()`
* <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#media-type-object" class="external-link" target="_blank">`Request Body Object`, en el campo `content`, sobre el `Media Type Object` (en la especificaci√≥n)</a> que era usado por FastAPI:
    * `Body()`
    * `File()`
    * `Form()`

/// info | Informaci√≥n

Este viejo par√°metro `examples` espec√≠fico de OpenAPI ahora es `openapi_examples` desde FastAPI `0.103.0`.

///

### Campo `examples` de JSON Schema

Pero luego JSON Schema a√±adi√≥ un <a href="https://json-schema.org/draft/2019-09/json-schema-validation.html#rfc.section.9.5" class="external-link" target="_blank">campo `examples`</a> a una nueva versi√≥n de la especificaci√≥n.

Y entonces el nuevo OpenAPI 3.1.0 se bas√≥ en la √∫ltima versi√≥n (JSON Schema 2020-12) que inclu√≠a este nuevo campo `examples`.

Y ahora este nuevo campo `examples` tiene precedencia sobre el viejo campo √∫nico (y personalizado) `example`, que ahora est√° obsoleto.

Este nuevo campo `examples` en JSON Schema es **solo una `list`** de ejemplos, no un dict con metadatos adicionales como en los otros lugares en OpenAPI (descritos arriba).

/// info | Informaci√≥n

Incluso despu√©s de que OpenAPI 3.1.0 fue lanzado con esta nueva integraci√≥n m√°s sencilla con JSON Schema, por un tiempo, Swagger UI, la herramienta que proporciona la documentaci√≥n autom√°tica, no soportaba OpenAPI 3.1.0 (lo hace desde la versi√≥n 5.0.0 üéâ).

Debido a eso, las versiones de FastAPI anteriores a 0.99.0 todav√≠a usaban versiones de OpenAPI menores a 3.1.0.

///

### `examples` de Pydantic y FastAPI

Cuando a√±ades `examples` dentro de un modelo de Pydantic, usando `schema_extra` o `Field(examples=["algo"])`, ese ejemplo se a√±ade al **JSON Schema** para ese modelo de Pydantic.

Y ese **JSON Schema** del modelo de Pydantic se incluye en el **OpenAPI** de tu API, y luego se usa en la interfaz de documentaci√≥n.

En las versiones de FastAPI antes de 0.99.0 (0.99.0 y superior usan el nuevo OpenAPI 3.1.0) cuando usabas `example` o `examples` con cualquiera de las otras utilidades (`Query()`, `Body()`, etc.) esos ejemplos no se a√±ad√≠an al JSON Schema que describe esos datos (ni siquiera a la propia versi√≥n de JSON Schema de OpenAPI), se a√±ad√≠an directamente a la declaraci√≥n de la *path operation* en OpenAPI (fuera de las partes de OpenAPI que usan JSON Schema).

Pero ahora que FastAPI 0.99.0 y superiores usa OpenAPI 3.1.0, que usa JSON Schema 2020-12, y Swagger UI 5.0.0 y superiores, todo es m√°s consistente y los ejemplos se incluyen en JSON Schema.

### Swagger UI y `examples` espec√≠ficos de OpenAPI

Ahora, como Swagger UI no soportaba m√∫ltiples ejemplos de JSON Schema (a fecha de 2023-08-26), los usuarios no ten√≠an una forma de mostrar m√∫ltiples ejemplos en los documentos.

Para resolver eso, FastAPI `0.103.0` **a√±adi√≥ soporte** para declarar el mismo viejo campo **espec√≠fico de OpenAPI** `examples` con el nuevo par√°metro `openapi_examples`. ü§ì

### Resumen

Sol√≠a decir que no me gustaba mucho la historia... y m√≠rame ahora dando lecciones de "historia tecnol√≥gica". üòÖ

En resumen, **actualiza a FastAPI 0.99.0 o superior**, y las cosas son mucho **m√°s simples, consistentes e intuitivas**, y no necesitas conocer todos estos detalles hist√≥ricos. üòé


================================================
File: /docs/es/docs/tutorial/sql-databases.md
================================================
# Bases de Datos SQL (Relacionales)

**FastAPI** no requiere que uses una base de datos SQL (relacional). Pero puedes utilizar **cualquier base de datos** que desees.

Aqu√≠ veremos un ejemplo usando <a href="https://sqlmodel.tiangolo.com/" class="external-link" target="_blank">SQLModel</a>.

**SQLModel** est√° construido sobre <a href="https://www.sqlalchemy.org/" class="external-link" target="_blank">SQLAlchemy</a> y Pydantic. Fue creado por el mismo autor de **FastAPI** para ser la combinaci√≥n perfecta para aplicaciones de FastAPI que necesiten usar **bases de datos SQL**.

/// tip | Consejo

Puedes usar cualquier otro paquete de bases de datos SQL o NoSQL que quieras (en algunos casos llamadas <abbr title="Object Relational Mapper, un t√©rmino elegante para un paquete donde algunas clases representan tablas SQL y las instances representan filas en esas tablas">"ORMs"</abbr>), FastAPI no te obliga a usar nada. üòé

///

Como SQLModel se basa en SQLAlchemy, puedes usar f√°cilmente **cualquier base de datos soportada** por SQLAlchemy (lo que las hace tambi√©n soportadas por SQLModel), como:

* PostgreSQL
* MySQL
* SQLite
* Oracle
* Microsoft SQL Server, etc.

En este ejemplo, usaremos **SQLite**, porque utiliza un solo archivo y Python tiene soporte integrado. As√≠ que puedes copiar este ejemplo y ejecutarlo tal cual.

M√°s adelante, para tu aplicaci√≥n en producci√≥n, es posible que desees usar un servidor de base de datos como **PostgreSQL**.

/// tip | Consejo

Hay un generador de proyectos oficial con **FastAPI** y **PostgreSQL** que incluye un frontend y m√°s herramientas: <a href="https://github.com/fastapi/full-stack-fastapi-template" class="external-link" target="_blank">https://github.com/fastapi/full-stack-fastapi-template</a>

///

Este es un tutorial muy simple y corto, si deseas aprender sobre bases de datos en general, sobre SQL o m√°s funcionalidades avanzadas, ve a la <a href="https://sqlmodel.tiangolo.com/" class="external-link" target="_blank">documentaci√≥n de SQLModel</a>.

## Instalar `SQLModel`

Primero, aseg√∫rate de crear tu [entorno virtual](../virtual-environments.md){.internal-link target=_blank}, act√≠valo, y luego instala `sqlmodel`:

<div class="termy">

```console
$ pip install sqlmodel
---> 100%
```

</div>

## Crear la App con un Solo Modelo

Primero crearemos la versi√≥n m√°s simple de la aplicaci√≥n con un solo modelo de **SQLModel**.

M√°s adelante la mejoraremos aumentando la seguridad y versatilidad con **m√∫ltiples modelos** a continuaci√≥n. ü§ì

### Crear Modelos

Importa `SQLModel` y crea un modelo de base de datos:

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[1:11] hl[7:11] *}

La clase `Hero` es muy similar a un modelo de Pydantic (de hecho, en el fondo, realmente *es un modelo de Pydantic*).

Hay algunas diferencias:

* `table=True` le dice a SQLModel que este es un *modelo de tabla*, que debe representar una **tabla** en la base de datos SQL, no es solo un *modelo de datos* (como lo ser√≠a cualquier otra clase regular de Pydantic).

* `Field(primary_key=True)` le dice a SQLModel que `id` es la **clave primaria** en la base de datos SQL (puedes aprender m√°s sobre claves primarias de SQL en la documentaci√≥n de SQLModel).

    Al tener el tipo como `int | None`, SQLModel sabr√° que esta columna debe ser un `INTEGER` en la base de datos SQL y que debe ser `NULLABLE`.

* `Field(index=True)` le dice a SQLModel que debe crear un **√≠ndice SQL** para esta columna, lo que permitir√° b√∫squedas m√°s r√°pidas en la base de datos cuando se lean datos filtrados por esta columna.

    SQLModel sabr√° que algo declarado como `str` ser√° una columna SQL de tipo `TEXT` (o `VARCHAR`, dependiendo de la base de datos).

### Crear un Engine

Un `engine` de SQLModel (en el fondo, realmente es un `engine` de SQLAlchemy) es lo que **mantiene las conexiones** a la base de datos.

Tendr√≠as **un solo objeto `engine`** para todo tu c√≥digo para conectar a la misma base de datos.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[14:18] hl[14:15,17:18] *}

Usar `check_same_thread=False` permite a FastAPI usar la misma base de datos SQLite en diferentes hilos. Esto es necesario ya que **una sola request** podr√≠a usar **m√°s de un hilo** (por ejemplo, en dependencias).

No te preocupes, con la forma en que est√° estructurado el c√≥digo, nos aseguraremos de usar **una sola *session* de SQLModel por request** m√°s adelante, esto es realmente lo que intenta lograr el `check_same_thread`.

### Crear las Tablas

Luego a√±adimos una funci√≥n que usa `SQLModel.metadata.create_all(engine)` para **crear las tablas** para todos los *modelos de tabla*.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[21:22] hl[21:22] *}

### Crear una Dependencia de Session

Una **`Session`** es lo que almacena los **objetos en memoria** y lleva un seguimiento de cualquier cambio necesario en los datos, luego **usa el `engine`** para comunicarse con la base de datos.

Crearemos una **dependencia de FastAPI** con `yield` que proporcionar√° una nueva `Session` para cada request. Esto es lo que asegura que usemos una sola session por request. ü§ì

Luego creamos una dependencia `Annotated` `SessionDep` para simplificar el resto del c√≥digo que usar√° esta dependencia.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[25:30]  hl[25:27,30] *}

### Crear Tablas de Base de Datos al Arrancar

Crearemos las tablas de la base de datos cuando arranque la aplicaci√≥n.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[32:37] hl[35:37] *}

Aqu√≠ creamos las tablas en un evento de inicio de la aplicaci√≥n.

Para producci√≥n probablemente usar√≠as un script de migraci√≥n que se ejecuta antes de iniciar tu aplicaci√≥n. ü§ì

/// tip | Consejo

SQLModel tendr√° utilidades de migraci√≥n envolviendo Alembic, pero por ahora, puedes usar <a href="https://alembic.sqlalchemy.org/en/latest/" class="external-link" target="_blank">Alembic</a> directamente.

///

### Crear un Hero

Debido a que cada modelo de SQLModel tambi√©n es un modelo de Pydantic, puedes usarlo en las mismas **anotaciones de tipos** que podr√≠as usar en modelos de Pydantic.

Por ejemplo, si declaras un par√°metro de tipo `Hero`, ser√° le√≠do desde el **JSON body**.

De la misma manera, puedes declararlo como el **tipo de retorno** de la funci√≥n, y luego la forma de los datos aparecer√° en la interfaz autom√°tica de documentaci√≥n de la API.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[40:45] hl[40:45] *}

</details>

Aqu√≠ usamos la dependencia `SessionDep` (una `Session`) para a√±adir el nuevo `Hero` a la instance `Session`, comiteamos los cambios a la base de datos, refrescamos los datos en el `hero` y luego lo devolvemos.

### Leer Heroes

Podemos **leer** `Hero`s de la base de datos usando un `select()`. Podemos incluir un `limit` y `offset` para paginar los resultados.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[48:55] hl[51:52,54] *}

### Leer Un Hero

Podemos **leer** un √∫nico `Hero`.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[58:63] hl[60] *}

### Eliminar un Hero

Tambi√©n podemos **eliminar** un `Hero`.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[66:73] hl[71] *}

### Ejecutar la App

Puedes ejecutar la aplicaci√≥n:

<div class="termy">

```console
$ fastapi dev main.py

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

Luego dir√≠gete a la interfaz de `/docs`, ver√°s que **FastAPI** est√° usando estos **modelos** para **documentar** la API, y los usar√° para **serializar** y **validar** los datos tambi√©n.

<div class="screenshot">
<img src="/img/tutorial/sql-databases/image01.png">
</div>

## Actualizar la App con M√∫ltiples Modelos

Ahora vamos a **refactorizar** un poco esta aplicaci√≥n para aumentar la **seguridad** y la **versatilidad**.

Si revisas la aplicaci√≥n anterior, en la interfaz ver√°s que, hasta ahora, permite al cliente decidir el `id` del `Hero` a crear. üò±

No deber√≠amos permitir que eso suceda, podr√≠an sobrescribir un `id` que ya tenemos asignado en la base de datos. Decidir el `id` deber√≠a ser tarea del **backend** o la **base de datos**, **no del cliente**.

Adem√°s, creamos un `secret_name` para el h√©roe, pero hasta ahora, lo estamos devolviendo en todas partes, eso no es muy **secreto**... üòÖ

Arreglaremos estas cosas a√±adiendo unos **modelos extra**. Aqu√≠ es donde SQLModel brillar√°. ‚ú®

### Crear M√∫ltiples Modelos

En **SQLModel**, cualquier clase de modelo que tenga `table=True` es un **modelo de tabla**.

Y cualquier clase de modelo que no tenga `table=True` es un **modelo de datos**, estos son en realidad solo modelos de Pydantic (con un par de caracter√≠sticas extra peque√±as). ü§ì

Con SQLModel, podemos usar **herencia** para **evitar duplicar** todos los campos en todos los casos.

#### `HeroBase` - la clase base

Comencemos con un modelo `HeroBase` que tiene todos los **campos que son compartidos** por todos los modelos:

* `name`
* `age`

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:9] hl[7:9] *}

#### `Hero` - el *modelo de tabla*

Luego, crearemos `Hero`, el *modelo de tabla* real, con los **campos extra** que no siempre est√°n en los otros modelos:

* `id`
* `secret_name`

Debido a que `Hero` hereda de `HeroBase`, **tambi√©n** tiene los **campos** declarados en `HeroBase`, por lo que todos los campos para `Hero` son:

* `id`
* `name`
* `age`
* `secret_name`

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:14] hl[12:14] *}

#### `HeroPublic` - el *modelo de datos* p√∫blico

A continuaci√≥n, creamos un modelo `HeroPublic`, este es el que ser√° **devuelto** a los clientes de la API.

Tiene los mismos campos que `HeroBase`, por lo que no incluir√° `secret_name`.

Por fin, la identidad de nuestros h√©roes est√° protegida! ü•∑

Tambi√©n vuelve a declarar `id: int`. Al hacer esto, estamos haciendo un **contrato** con los clientes de la API, para que siempre puedan esperar que el `id` est√© all√≠ y sea un `int` (nunca ser√° `None`).

/// tip | Consejo

Tener el modelo de retorno asegurando que un valor siempre est√© disponible y siempre sea `int` (no `None`) es muy √∫til para los clientes de la API, pueden escribir c√≥digo mucho m√°s simple teniendo esta certeza.

Adem√°s, los **clientes generados autom√°ticamente** tendr√°n interfaces m√°s simples, para que los desarrolladores que se comuniquen con tu API puedan tener una experiencia mucho mejor trabajando con tu API. üòé

///

Todos los campos en `HeroPublic` son los mismos que en `HeroBase`, con `id` declarado como `int` (no `None`):

* `id`
* `name`
* `age`
* `secret_name`

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:18] hl[17:18] *}

#### `HeroCreate` - el *modelo de datos* para crear un h√©roe

Ahora creamos un modelo `HeroCreate`, este es el que **validar√°** los datos de los clientes.

Tiene los mismos campos que `HeroBase`, y tambi√©n tiene `secret_name`.

Ahora, cuando los clientes **crean un nuevo h√©roe**, enviar√°n el `secret_name`, se almacenar√° en la base de datos, pero esos nombres secretos no se devolver√°n en la API a los clientes.

/// tip | Consejo

Esta es la forma en la que manejar√≠as **contrase√±as**. Rec√≠belas, pero no las devuelvas en la API.

Tambi√©n **hashea** los valores de las contrase√±as antes de almacenarlos, **nunca los almacenes en texto plano**.

///

Los campos de `HeroCreate` son:

* `name`
* `age`
* `secret_name`

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:22] hl[21:22] *}

#### `HeroUpdate` - el *modelo de datos* para actualizar un h√©roe

No ten√≠amos una forma de **actualizar un h√©roe** en la versi√≥n anterior de la aplicaci√≥n, pero ahora con **m√∫ltiples modelos**, podemos hacerlo. üéâ

El *modelo de datos* `HeroUpdate` es algo especial, tiene **todos los mismos campos** que ser√≠an necesarios para crear un nuevo h√©roe, pero todos los campos son **opcionales** (todos tienen un valor por defecto). De esta forma, cuando actualices un h√©roe, puedes enviar solo los campos que deseas actualizar.

Debido a que todos los **campos realmente cambian** (el tipo ahora incluye `None` y ahora tienen un valor por defecto de `None`), necesitamos **volver a declararlos**.

Realmente no necesitamos heredar de `HeroBase` porque estamos volviendo a declarar todos los campos. Lo dejar√© heredando solo por consistencia, pero esto no es necesario. Es m√°s una cuesti√≥n de gusto personal. ü§∑

Los campos de `HeroUpdate` son:

* `name`
* `age`
* `secret_name`

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:28] hl[25:28] *}

### Crear con `HeroCreate` y devolver un `HeroPublic`

Ahora que tenemos **m√∫ltiples modelos**, podemos actualizar las partes de la aplicaci√≥n que los usan.

Recibimos en la request un *modelo de datos* `HeroCreate`, y a partir de √©l, creamos un *modelo de tabla* `Hero`.

Este nuevo *modelo de tabla* `Hero` tendr√° los campos enviados por el cliente, y tambi√©n tendr√° un `id` generado por la base de datos.

Luego devolvemos el mismo *modelo de tabla* `Hero` tal cual desde la funci√≥n. Pero como declaramos el `response_model` con el *modelo de datos* `HeroPublic`, **FastAPI** usar√° `HeroPublic` para validar y serializar los datos.

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[56:62] hl[56:58] *}

/// tip | Consejo

Ahora usamos `response_model=HeroPublic` en lugar de la **anotaci√≥n de tipo de retorno** `-> HeroPublic` porque el valor que estamos devolviendo en realidad *no* es un `HeroPublic`.

Si hubi√©ramos declarado `-> HeroPublic`, tu editor y linter se quejar√≠an (con raz√≥n) de que est√°s devolviendo un `Hero` en lugar de un `HeroPublic`.

Al declararlo en `response_model` le estamos diciendo a **FastAPI** que haga lo suyo, sin interferir con las anotaciones de tipo y la ayuda de tu editor y otras herramientas.

///

### Leer Heroes con `HeroPublic`

Podemos hacer lo mismo que antes para **leer** `Hero`s, nuevamente, usamos `response_model=list[HeroPublic]` para asegurar que los datos se validen y serialicen correctamente.

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[65:72] hl[65] *}

### Leer Un Hero con `HeroPublic`

Podemos **leer** un √∫nico h√©roe:

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[75:80] hl[77] *}

### Actualizar un Hero con `HeroUpdate`

Podemos **actualizar un h√©roe**. Para esto usamos una operaci√≥n HTTP `PATCH`.

Y en el c√≥digo, obtenemos un `dict` con todos los datos enviados por el cliente, **solo los datos enviados por el cliente**, excluyendo cualquier valor que estar√≠a all√≠ solo por ser valores por defecto. Para hacerlo usamos `exclude_unset=True`. Este es el truco principal. ü™Ñ

Luego usamos `hero_db.sqlmodel_update(hero_data)` para actualizar el `hero_db` con los datos de `hero_data`.

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[83:93] hl[83:84,88:89] *}

### Eliminar un Hero de Nuevo

**Eliminar** un h√©roe se mantiene pr√°cticamente igual.

No satisfaremos el deseo de refactorizar todo en este punto. üòÖ

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[96:103] hl[101] *}

### Ejecutar la App de Nuevo

Puedes ejecutar la aplicaci√≥n de nuevo:

<div class="termy">

```console
$ fastapi dev main.py

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

Si vas a la interfaz de `/docs` de la API, ver√°s que ahora est√° actualizada, y no esperar√° recibir el `id` del cliente al crear un h√©roe, etc.

<div class="screenshot">
<img src="/img/tutorial/sql-databases/image02.png">
</div>

## Resumen

Puedes usar <a href="https://sqlmodel.tiangolo.com/" class="external-link" target="_blank">**SQLModel**</a> para interactuar con una base de datos SQL y simplificar el c√≥digo con *modelos de datos* y *modelos de tablas*.

Puedes aprender mucho m√°s en la documentaci√≥n de **SQLModel**, hay un mini <a href="https://sqlmodel.tiangolo.com/tutorial/fastapi/" class="external-link" target="_blank">tutorial sobre el uso de SQLModel con **FastAPI**</a>. üöÄ


================================================
File: /docs/es/docs/tutorial/static-files.md
================================================
# Archivos Est√°ticos

Puedes servir archivos est√°ticos autom√°ticamente desde un directorio utilizando `StaticFiles`.

## Usa `StaticFiles`

* Importa `StaticFiles`.
* "Monta" una instance de `StaticFiles()` en un path espec√≠fico.

{* ../../docs_src/static_files/tutorial001.py hl[2,6] *}

/// note | Detalles T√©cnicos

Tambi√©n podr√≠as usar `from starlette.staticfiles import StaticFiles`.

**FastAPI** proporciona el mismo `starlette.staticfiles` como `fastapi.staticfiles` solo como una conveniencia para ti, el desarrollador. Pero en realidad viene directamente de Starlette.

///

### Qu√© es "Montar"

"Montar" significa agregar una aplicaci√≥n completa "independiente" en un path espec√≠fico, que luego se encargar√° de manejar todos los sub-paths.

Esto es diferente a usar un `APIRouter`, ya que una aplicaci√≥n montada es completamente independiente. El OpenAPI y la documentaci√≥n de tu aplicaci√≥n principal no incluir√°n nada de la aplicaci√≥n montada, etc.

Puedes leer m√°s sobre esto en la [Gu√≠a de Usuario Avanzada](../advanced/index.md){.internal-link target=_blank}.

## Detalles

El primer `"/static"` se refiere al sub-path en el que esta "sub-aplicaci√≥n" ser√° "montada". Por lo tanto, cualquier path que comience con `"/static"` ser√° manejado por ella.

El `directory="static"` se refiere al nombre del directorio que contiene tus archivos est√°ticos.

El `name="static"` le da un nombre que puede ser utilizado internamente por **FastAPI**.

Todos estos par√°metros pueden ser diferentes a "`static`", aj√∫stalos seg√∫n las necesidades y detalles espec√≠ficos de tu propia aplicaci√≥n.

## M√°s info

Para m√°s detalles y opciones revisa <a href="https://www.starlette.io/staticfiles/" class="external-link" target="_blank">la documentaci√≥n de Starlette sobre Archivos Est√°ticos</a>.


================================================
File: /docs/es/docs/tutorial/testing.md
================================================
# Testing

Gracias a <a href="https://www.starlette.io/testclient/" class="external-link" target="_blank">Starlette</a>, escribir pruebas para aplicaciones de **FastAPI** es f√°cil y agradable.

Est√° basado en <a href="https://www.python-httpx.org" class="external-link" target="_blank">HTTPX</a>, que a su vez est√° dise√±ado basado en Requests, por lo que es muy familiar e intuitivo.

Con √©l, puedes usar <a href="https://docs.pytest.org/" class="external-link" target="_blank">pytest</a> directamente con **FastAPI**.

## Usando `TestClient`

/// info | Informaci√≥n

Para usar `TestClient`, primero instala <a href="https://www.python-httpx.org" class="external-link" target="_blank">`httpx`</a>.

Aseg√∫rate de crear un [entorno virtual](../virtual-environments.md){.internal-link target=_blank}, activarlo y luego instalarlo, por ejemplo:

```console
$ pip install httpx
```

///

Importa `TestClient`.

Crea un `TestClient` pas√°ndole tu aplicaci√≥n de **FastAPI**.

Crea funciones con un nombre que comience con `test_` (esta es la convenci√≥n est√°ndar de `pytest`).

Usa el objeto `TestClient` de la misma manera que con `httpx`.

Escribe declaraciones `assert` simples con las expresiones est√°ndar de Python que necesites revisar (otra vez, est√°ndar de `pytest`).

{* ../../docs_src/app_testing/tutorial001.py hl[2,12,15:18] *}

/// tip | Consejo

Nota que las funciones de prueba son `def` normales, no `async def`.

Y las llamadas al cliente tambi√©n son llamadas normales, sin usar `await`.

Esto te permite usar `pytest` directamente sin complicaciones.

///

/// note | Nota T√©cnica

Tambi√©n podr√≠as usar `from starlette.testclient import TestClient`.

**FastAPI** proporciona el mismo `starlette.testclient` como `fastapi.testclient` solo por conveniencia para ti, el desarrollador. Pero proviene directamente de Starlette.

///

/// tip | Consejo

Si quieres llamar a funciones `async` en tus pruebas adem√°s de enviar solicitudes a tu aplicaci√≥n FastAPI (por ejemplo, funciones asincr√≥nicas de bases de datos), echa un vistazo a las [Pruebas Asincr√≥nicas](../advanced/async-tests.md){.internal-link target=_blank} en el tutorial avanzado.

///

## Separando pruebas

En una aplicaci√≥n real, probablemente tendr√≠as tus pruebas en un archivo diferente.

Y tu aplicaci√≥n de **FastAPI** tambi√©n podr√≠a estar compuesta de varios archivos/m√≥dulos, etc.

### Archivo de aplicaci√≥n **FastAPI**

Digamos que tienes una estructura de archivos como se describe en [Aplicaciones M√°s Grandes](bigger-applications.md){.internal-link target=_blank}:

```
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ main.py
```

En el archivo `main.py` tienes tu aplicaci√≥n de **FastAPI**:

{* ../../docs_src/app_testing/main.py *}

### Archivo de prueba

Entonces podr√≠as tener un archivo `test_main.py` con tus pruebas. Podr√≠a estar en el mismo paquete de Python (el mismo directorio con un archivo `__init__.py`):

``` hl_lines="5"
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_main.py
```

Debido a que este archivo est√° en el mismo paquete, puedes usar importaciones relativas para importar el objeto `app` desde el m√≥dulo `main` (`main.py`):

{* ../../docs_src/app_testing/test_main.py hl[3] *}

...y tener el c√≥digo para las pruebas tal como antes.

## Pruebas: ejemplo extendido

Ahora extiende este ejemplo y a√±ade m√°s detalles para ver c√≥mo escribir pruebas para diferentes partes.

### Archivo de aplicaci√≥n **FastAPI** extendido

Continuemos con la misma estructura de archivos que antes:

```
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_main.py
```

Digamos que ahora el archivo `main.py` con tu aplicaci√≥n de **FastAPI** tiene algunas otras **path operations**.

Tiene una operaci√≥n `GET` que podr√≠a devolver un error.

Tiene una operaci√≥n `POST` que podr√≠a devolver varios errores.

Ambas *path operations* requieren un `X-Token` header.

//// tab | Python 3.10+

```Python
{!> ../../docs_src/app_testing/app_b_an_py310/main.py!}
```

////

//// tab | Python 3.9+

```Python
{!> ../../docs_src/app_testing/app_b_an_py39/main.py!}
```

////

//// tab | Python 3.8+

```Python
{!> ../../docs_src/app_testing/app_b_an/main.py!}
```

////

//// tab | Python 3.10+ sin Anotar

/// tip | Consejo

Prefiere usar la versi√≥n `Annotated` si es posible.

///

```Python
{!> ../../docs_src/app_testing/app_b_py310/main.py!}
```

////

//// tab | Python 3.8+ sin Anotar

/// tip | Consejo

Prefiere usar la versi√≥n `Annotated` si es posible.

///

```Python
{!> ../../docs_src/app_testing/app_b/main.py!}
```

////

### Archivo de prueba extendido

Podr√≠as entonces actualizar `test_main.py` con las pruebas extendidas:

{* ../../docs_src/app_testing/app_b/test_main.py *}

Cada vez que necesites que el cliente pase informaci√≥n en el request y no sepas c√≥mo, puedes buscar (Googlear) c√≥mo hacerlo en `httpx`, o incluso c√≥mo hacerlo con `requests`, dado que el dise√±o de HTTPX est√° basado en el dise√±o de Requests.

Luego simplemente haces lo mismo en tus pruebas.

Por ejemplo:

* Para pasar un par√°metro de *path* o *query*, a√±√°delo a la URL misma.
* Para pasar un cuerpo JSON, pasa un objeto de Python (por ejemplo, un `dict`) al par√°metro `json`.
* Si necesitas enviar *Form Data* en lugar de JSON, usa el par√°metro `data` en su lugar.
* Para pasar *headers*, usa un `dict` en el par√°metro `headers`.
* Para *cookies*, un `dict` en el par√°metro `cookies`.

Para m√°s informaci√≥n sobre c√≥mo pasar datos al backend (usando `httpx` o el `TestClient`) revisa la <a href="https://www.python-httpx.org" class="external-link" target="_blank">documentaci√≥n de HTTPX</a>.

/// info | Informaci√≥n

Ten en cuenta que el `TestClient` recibe datos que pueden ser convertidos a JSON, no modelos de Pydantic.

Si tienes un modelo de Pydantic en tu prueba y quieres enviar sus datos a la aplicaci√≥n durante las pruebas, puedes usar el `jsonable_encoder` descrito en [Codificador Compatible con JSON](encoder.md){.internal-link target=_blank}.

///

## Ejec√∫talo

Despu√©s de eso, solo necesitas instalar `pytest`.

Aseg√∫rate de crear un [entorno virtual](../virtual-environments.md){.internal-link target=_blank}, activarlo y luego instalarlo, por ejemplo:

<div class="termy">

```console
$ pip install pytest

---> 100%
```

</div>

Detectar√° los archivos y pruebas autom√°ticamente, ejecutar√° las mismas y te reportar√° los resultados.

Ejecuta las pruebas con:

<div class="termy">

```console
$ pytest

================ test session starts ================
platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1
rootdir: /home/user/code/superawesome-cli/app
plugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1
collected 6 items

---> 100%

test_main.py <span style="color: green; white-space: pre;">......                            [100%]</span>

<span style="color: green;">================= 1 passed in 0.03s =================</span>
```

</div>


================================================
File: /docs/es/docs/tutorial/dependencies/classes-as-dependencies.md
================================================
# Clases como dependencias

Antes de profundizar en el sistema de **Inyecci√≥n de Dependencias**, vamos a mejorar el ejemplo anterior.

## Un `dict` del ejemplo anterior

En el ejemplo anterior, est√°bamos devolviendo un `dict` de nuestra dependencia ("dependable"):

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[9] *}

Pero luego obtenemos un `dict` en el par√°metro `commons` de la *path operation function*.

Y sabemos que los editores no pueden proporcionar mucho soporte (como autocompletado) para `dict`s, porque no pueden conocer sus claves y tipos de valor.

Podemos hacerlo mejor...

## Qu√© hace a una dependencia

Hasta ahora has visto dependencias declaradas como funciones.

Pero esa no es la √∫nica forma de declarar dependencias (aunque probablemente sea la m√°s com√∫n).

El factor clave es que una dependencia debe ser un "callable".

Un "**callable**" en Python es cualquier cosa que Python pueda "llamar" como una funci√≥n.

Entonces, si tienes un objeto `something` (que podr√≠a _no_ ser una funci√≥n) y puedes "llamarlo" (ejecutarlo) como:

```Python
something()
```

o

```Python
something(some_argument, some_keyword_argument="foo")
```

entonces es un "callable".

## Clases como dependencias

Puedes notar que para crear una instance de una clase en Python, utilizas esa misma sintaxis.

Por ejemplo:

```Python
class Cat:
    def __init__(self, name: str):
        self.name = name


fluffy = Cat(name="Mr Fluffy")
```

En este caso, `fluffy` es una instance de la clase `Cat`.

Y para crear `fluffy`, est√°s "llamando" a `Cat`.

Entonces, una clase en Python tambi√©n es un **callable**.

Entonces, en **FastAPI**, podr√≠as usar una clase de Python como una dependencia.

Lo que **FastAPI** realmente comprueba es que sea un "callable" (funci√≥n, clase o cualquier otra cosa) y los par√°metros definidos.

Si pasas un "callable" como dependencia en **FastAPI**, analizar√° los par√°metros de ese "callable", y los procesar√° de la misma manera que los par√°metros de una *path operation function*. Incluyendo sub-dependencias.

Eso tambi√©n se aplica a los callables sin par√°metros. Igual que ser√≠a para *path operation functions* sin par√°metros.

Entonces, podemos cambiar la dependencia "dependable" `common_parameters` de arriba a la clase `CommonQueryParams`:

{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[11:15] *}

Presta atenci√≥n al m√©todo `__init__` usado para crear la instance de la clase:

{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[12] *}

...tiene los mismos par√°metros que nuestros `common_parameters` anteriores:

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[8] *}

Esos par√°metros son los que **FastAPI** usar√° para "resolver" la dependencia.

En ambos casos, tendr√°:

* Un par√°metro de query `q` opcional que es un `str`.
* Un par√°metro de query `skip` que es un `int`, con un valor por defecto de `0`.
* Un par√°metro de query `limit` que es un `int`, con un valor por defecto de `100`.

En ambos casos, los datos ser√°n convertidos, validados, documentados en el esquema de OpenAPI, etc.

## √ösalo

Ahora puedes declarar tu dependencia usando esta clase.

{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[19] *}

**FastAPI** llama a la clase `CommonQueryParams`. Esto crea una "instance" de esa clase y la instance ser√° pasada como el par√°metro `commons` a tu funci√≥n.

## Anotaci√≥n de tipos vs `Depends`

Nota c√≥mo escribimos `CommonQueryParams` dos veces en el c√≥digo anterior:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
```

////

//// tab | Python 3.8+ sin `Annotated`

/// tip | Consejo

Prefiere usar la versi√≥n `Annotated` si es posible.

///

```Python
commons: CommonQueryParams = Depends(CommonQueryParams)
```

////

El √∫ltimo `CommonQueryParams`, en:

```Python
... Depends(CommonQueryParams)
```

...es lo que **FastAPI** utilizar√° realmente para saber cu√°l es la dependencia.

Es a partir de este que **FastAPI** extraer√° los par√°metros declarados y es lo que **FastAPI** realmente llamar√°.

---

En este caso, el primer `CommonQueryParams`, en:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, ...
```

////

//// tab | Python 3.8+ sin `Annotated`

/// tip | Consejo

Prefiere usar la versi√≥n `Annotated` si es posible.

///

```Python
commons: CommonQueryParams ...
```

////

...no tiene ning√∫n significado especial para **FastAPI**. **FastAPI** no lo usar√° para la conversi√≥n de datos, validaci√≥n, etc. (ya que est√° usando `Depends(CommonQueryParams)` para eso).

De hecho, podr√≠as escribir simplemente:

//// tab | Python 3.8+

```Python
commons: Annotated[Any, Depends(CommonQueryParams)]
```

////

//// tab | Python 3.8+ sin `Annotated`

/// tip | Consejo

Prefiere usar la versi√≥n `Annotated` si es posible.

///

```Python
commons = Depends(CommonQueryParams)
```

////

...como en:

{* ../../docs_src/dependencies/tutorial003_an_py310.py hl[19] *}

Pero declarar el tipo es recomendable, ya que de esa manera tu editor sabr√° lo que se pasar√° como el par√°metro `commons`, y entonces podr√° ayudarte con el autocompletado, chequeo de tipos, etc:

<img src="/img/tutorial/dependencies/image02.png">

## Atajo

Pero ves que estamos teniendo algo de repetici√≥n de c√≥digo aqu√≠, escribiendo `CommonQueryParams` dos veces:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
```

////

//// tab | Python 3.8+ sin `Annotated`

/// tip | Consejo

Prefiere usar la versi√≥n `Annotated` si es posible.

///

```Python
commons: CommonQueryParams = Depends(CommonQueryParams)
```

////

**FastAPI** proporciona un atajo para estos casos, en donde la dependencia es *espec√≠ficamente* una clase que **FastAPI** "llamar√°" para crear una instance de la clase misma.

Para esos casos espec√≠ficos, puedes hacer lo siguiente:

En lugar de escribir:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
```

////

//// tab | Python 3.8+ sin `Annotated`

/// tip | Consejo

Prefiere usar la versi√≥n `Annotated` si es posible.

///

```Python
commons: CommonQueryParams = Depends(CommonQueryParams)
```

////

...escribes:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, Depends()]
```

////

//// tab | Python 3.8 sin `Annotated`

/// tip | Consejo

Prefiere usar la versi√≥n `Annotated` si es posible.

///

```Python
commons: CommonQueryParams = Depends()
```

////

Declaras la dependencia como el tipo del par√°metro, y usas `Depends()` sin ning√∫n par√°metro, en lugar de tener que escribir la clase completa *otra vez* dentro de `Depends(CommonQueryParams)`.

El mismo ejemplo se ver√≠a entonces as√≠:

{* ../../docs_src/dependencies/tutorial004_an_py310.py hl[19] *}

...y **FastAPI** sabr√° qu√© hacer.

/// tip | Consejo

Si eso parece m√°s confuso que √∫til, ign√≥ralo, no lo *necesitas*.

Es solo un atajo. Porque a **FastAPI** le importa ayudarte a minimizar la repetici√≥n de c√≥digo.

///


================================================
File: /docs/es/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
================================================
# Dependencias en decoradores de *path operation*

En algunos casos realmente no necesitas el valor de retorno de una dependencia dentro de tu *path operation function*.

O la dependencia no devuelve un valor.

Pero a√∫n necesitas que sea ejecutada/resuelta.

Para esos casos, en lugar de declarar un par√°metro de *path operation function* con `Depends`, puedes a√±adir una `list` de `dependencies` al decorador de *path operation*.

## Agregar `dependencies` al decorador de *path operation*

El decorador de *path operation* recibe un argumento opcional `dependencies`.

Debe ser una `list` de `Depends()`:

{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[19] *}

Estas dependencias ser√°n ejecutadas/resueltas de la misma manera que las dependencias normales. Pero su valor (si devuelven alguno) no ser√° pasado a tu *path operation function*.

/// tip | Consejo

Algunos editores revisan los par√°metros de funci√≥n no usados y los muestran como errores.

Usando estas `dependencies` en el decorador de *path operation* puedes asegurarte de que se ejecutan mientras evitas errores en editores/herramientas.

Tambi√©n puede ayudar a evitar confusiones para nuevos desarrolladores que vean un par√°metro no usado en tu c√≥digo y puedan pensar que es innecesario.

///

/// info | Informaci√≥n

En este ejemplo usamos headers personalizados inventados `X-Key` y `X-Token`.

Pero en casos reales, al implementar seguridad, obtendr√≠as m√°s beneficios usando las [Utilidades de Seguridad integradas (el pr√≥ximo cap√≠tulo)](../security/index.md){.internal-link target=_blank}.

///

## Errores de dependencias y valores de retorno

Puedes usar las mismas *funciones* de dependencia que usas normalmente.

### Requisitos de dependencia

Pueden declarar requisitos de request (como headers) u otras sub-dependencias:

{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[8,13] *}

### Lanzar excepciones

Estas dependencias pueden `raise` excepciones, igual que las dependencias normales:

{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[10,15] *}

### Valores de retorno

Y pueden devolver valores o no, los valores no ser√°n usados.

As√≠ que, puedes reutilizar una dependencia normal (que devuelve un valor) que ya uses en otro lugar, y aunque el valor no se use, la dependencia ser√° ejecutada:

{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[11,16] *}

## Dependencias para un grupo de *path operations*

M√°s adelante, cuando leas sobre c√≥mo estructurar aplicaciones m√°s grandes ([Aplicaciones M√°s Grandes - M√∫ltiples Archivos](../../tutorial/bigger-applications.md){.internal-link target=_blank}), posiblemente con m√∫ltiples archivos, aprender√°s c√≥mo declarar un √∫nico par√°metro `dependencies` para un grupo de *path operations*.

## Dependencias Globales

A continuaci√≥n veremos c√≥mo a√±adir dependencias a toda la aplicaci√≥n `FastAPI`, de modo que se apliquen a cada *path operation*.


================================================
File: /docs/es/docs/tutorial/dependencies/dependencies-with-yield.md
================================================
# Dependencias con yield

FastAPI admite dependencias que realizan algunos <abbr title='sometimes also called "exit code", "cleanup code", "teardown code", "closing code", "context manager exit code", etc.'>pasos adicionales despu√©s de finalizar</abbr>.

Para hacer esto, usa `yield` en lugar de `return` y escribe los pasos adicionales (c√≥digo) despu√©s.

/// tip | Consejo

Aseg√∫rate de usar `yield` una sola vez por dependencia.

///

/// note | Nota t√©cnica

Cualquier funci√≥n que sea v√°lida para usar con:

* <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" class="external-link" target="_blank">`@contextlib.contextmanager`</a> o
* <a href="https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager" class="external-link" target="_blank">`@contextlib.asynccontextmanager`</a>

ser√≠a v√°lida para usar como una dependencia en **FastAPI**.

De hecho, FastAPI usa esos dos decoradores internamente.

///

## Una dependencia de base de datos con `yield`

Por ejemplo, podr√≠as usar esto para crear una sesi√≥n de base de datos y cerrarla despu√©s de finalizar.

Solo el c√≥digo anterior e incluyendo la declaraci√≥n `yield` se ejecuta antes de crear un response:

{* ../../docs_src/dependencies/tutorial007.py hl[2:4] *}

El valor generado es lo que se inyecta en *path operations* y otras dependencias:

{* ../../docs_src/dependencies/tutorial007.py hl[4] *}

El c√≥digo posterior a la declaraci√≥n `yield` se ejecuta despu√©s de crear el response pero antes de enviarla:

{* ../../docs_src/dependencies/tutorial007.py hl[5:6] *}

/// tip | Consejo

Puedes usar funciones `async` o regulares.

**FastAPI** har√° lo correcto con cada una, igual que con dependencias normales.

///

## Una dependencia con `yield` y `try`

Si usas un bloque `try` en una dependencia con `yield`, recibir√°s cualquier excepci√≥n que se haya lanzado al usar la dependencia.

Por ejemplo, si alg√∫n c√≥digo en alg√∫n punto intermedio, en otra dependencia o en una *path operation*, realiza un "rollback" en una transacci√≥n de base de datos o crea cualquier otro error, recibir√°s la excepci√≥n en tu dependencia.

Por lo tanto, puedes buscar esa excepci√≥n espec√≠fica dentro de la dependencia con `except SomeException`.

Del mismo modo, puedes usar `finally` para asegurarte de que los pasos de salida se ejecuten, sin importar si hubo una excepci√≥n o no.

{* ../../docs_src/dependencies/tutorial007.py hl[3,5] *}

## Sub-dependencias con `yield`

Puedes tener sub-dependencias y "√°rboles" de sub-dependencias de cualquier tama√±o y forma, y cualquiera o todas ellas pueden usar `yield`.

**FastAPI** se asegurar√° de que el "c√≥digo de salida" en cada dependencia con `yield` se ejecute en el orden correcto.

Por ejemplo, `dependency_c` puede tener una dependencia de `dependency_b`, y `dependency_b` de `dependency_a`:

{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[6,14,22] *}

Y todas ellas pueden usar `yield`.

En este caso, `dependency_c`, para ejecutar su c√≥digo de salida, necesita que el valor de `dependency_b` (aqu√≠ llamado `dep_b`) todav√≠a est√© disponible.

Y, a su vez, `dependency_b` necesita que el valor de `dependency_a` (aqu√≠ llamado `dep_a`) est√© disponible para su c√≥digo de salida.

{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[18:19,26:27] *}

De la misma manera, podr√≠as tener algunas dependencias con `yield` y otras dependencias con `return`, y hacer que algunas de esas dependan de algunas de las otras.

Y podr√≠as tener una sola dependencia que requiera varias otras dependencias con `yield`, etc.

Puedes tener cualquier combinaci√≥n de dependencias que quieras.

**FastAPI** se asegurar√° de que todo se ejecute en el orden correcto.

/// note | Nota t√©cnica

Esto funciona gracias a los <a href="https://docs.python.org/3/library/contextlib.html" class="external-link" target="_blank">Context Managers</a> de Python.

**FastAPI** los utiliza internamente para lograr esto.

///

## Dependencias con `yield` y `HTTPException`

Viste que puedes usar dependencias con `yield` y tener bloques `try` que capturen excepciones.

De la misma manera, podr√≠as lanzar una `HTTPException` o similar en el c√≥digo de salida, despu√©s del `yield`.

/// tip | Consejo

Esta es una t√©cnica algo avanzada, y en la mayor√≠a de los casos realmente no lo necesitar√°s, ya que puedes lanzar excepciones (incluyendo `HTTPException`) desde dentro del resto del c√≥digo de tu aplicaci√≥n, por ejemplo, en la *path operation function*.

Pero est√° ah√≠ para ti si la necesitas. ü§ì

///

{* ../../docs_src/dependencies/tutorial008b_an_py39.py hl[18:22,31] *}

Una alternativa que podr√≠as usar para capturar excepciones (y posiblemente tambi√©n lanzar otra `HTTPException`) es crear un [Manejador de Excepciones Personalizado](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}.

## Dependencias con `yield` y `except`

Si capturas una excepci√≥n usando `except` en una dependencia con `yield` y no la lanzas nuevamente (o lanzas una nueva excepci√≥n), FastAPI no podr√° notar que hubo una excepci√≥n, al igual que suceder√≠a con Python normal:

{* ../../docs_src/dependencies/tutorial008c_an_py39.py hl[15:16] *}

En este caso, el cliente ver√° un response *HTTP 500 Internal Server Error* como deber√≠a, dado que no estamos lanzando una `HTTPException` o similar, pero el servidor **no tendr√° ning√∫n registro** ni ninguna otra indicaci√≥n de cu√°l fue el error. üò±

### Siempre `raise` en Dependencias con `yield` y `except`

Si capturas una excepci√≥n en una dependencia con `yield`, a menos que est√©s lanzando otra `HTTPException` o similar, deber√≠as volver a lanzar la excepci√≥n original.

Puedes volver a lanzar la misma excepci√≥n usando `raise`:

{* ../../docs_src/dependencies/tutorial008d_an_py39.py hl[17] *}

Ahora el cliente obtendr√° el mismo response *HTTP 500 Internal Server Error*, pero el servidor tendr√° nuestro `InternalError` personalizado en los registros. üòé

## Ejecuci√≥n de dependencias con `yield`

La secuencia de ejecuci√≥n es m√°s o menos como este diagrama. El tiempo fluye de arriba a abajo. Y cada columna es una de las partes que interact√∫a o ejecuta c√≥digo.

```mermaid
sequenceDiagram

participant client as Client
participant handler as Exception handler
participant dep as Dep with yield
participant operation as Path Operation
participant tasks as Background tasks

    Note over client,operation: Puede lanzar excepciones, incluyendo HTTPException
    client ->> dep: Iniciar request
    Note over dep: Ejecutar c√≥digo hasta yield
    opt raise Exception
        dep -->> handler: Lanzar Exception
        handler -->> client: Response HTTP de error
    end
    dep ->> operation: Ejecutar dependencia, por ejemplo, sesi√≥n de BD
    opt raise
        operation -->> dep: Lanzar Exception (por ejemplo, HTTPException)
        opt handle
            dep -->> dep: Puede capturar excepci√≥n, lanzar una nueva HTTPException, lanzar otra excepci√≥n
        end
        handler -->> client: Response HTTP de error
    end

    operation ->> client: Devolver response al cliente
    Note over client,operation: El response ya fue enviado, no se puede cambiar
    opt Tasks
        operation -->> tasks: Enviar tareas en background
    end
    opt Lanzar otra excepci√≥n
        tasks -->> tasks: Manejar excepciones en el c√≥digo de la tarea en background
    end
```

/// info | Informaci√≥n

Solo **un response** ser√° enviado al cliente. Podr√≠a ser uno de los responses de error o ser√° el response de la *path operation*.

Despu√©s de que se env√≠e uno de esos responses, no se podr√° enviar ning√∫n otro response.

///

/// tip | Consejo

Este diagrama muestra `HTTPException`, pero tambi√©n podr√≠as lanzar cualquier otra excepci√≥n que captures en una dependencia con `yield` o con un [Manejador de Excepciones Personalizado](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}.

Si lanzas alguna excepci√≥n, ser√° pasada a las dependencias con yield, incluyendo `HTTPException`. En la mayor√≠a de los casos querr√°s volver a lanzar esa misma excepci√≥n o una nueva desde la dependencia con `yield` para asegurarte de que se maneje correctamente.

///

## Dependencias con `yield`, `HTTPException`, `except` y Tareas en Background

/// warning | Advertencia

Probablemente no necesites estos detalles t√©cnicos, puedes omitir esta secci√≥n y continuar abajo.

Estos detalles son √∫tiles principalmente si estabas usando una versi√≥n de FastAPI anterior a 0.106.0 y usabas recursos de dependencias con `yield` en tareas en background.

///

### Dependencias con `yield` y `except`, Detalles T√©cnicos

Antes de FastAPI 0.110.0, si usabas una dependencia con `yield`, y luego capturabas una excepci√≥n con `except` en esa dependencia, y no volv√≠as a lanzar la excepci√≥n, la excepci√≥n se lanzar√≠a autom√°ticamente/transmitir√≠a a cualquier manejador de excepciones o al manejador de errores interno del servidor.

Esto se cambi√≥ en la versi√≥n 0.110.0 para corregir el consumo no gestionado de memoria de excepciones transmitidas sin un manejador (errores internos del servidor), y para que sea consistente con el comportamiento del c√≥digo regular de Python.

### Tareas en Background y Dependencias con `yield`, Detalles T√©cnicos

Antes de FastAPI 0.106.0, lanzar excepciones despu√©s de `yield` no era posible, el c√≥digo de salida en dependencias con `yield` se ejecutaba *despu√©s* de que el response se enviara, por lo que los [Manejadores de Excepciones](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank} ya se habr√≠an ejecutado.

Esto se dise√±√≥ de esta manera principalmente para permitir usar los mismos objetos "extra√≠dos" por dependencias dentro de tareas en background, porque el c√≥digo de salida se ejecutar√≠a despu√©s de que las tareas en background terminaran.

Sin embargo, ya que esto significar√≠a esperar a que el response viaje a trav√©s de la red mientras se retiene innecesariamente un recurso en una dependencia con yield (por ejemplo, una conexi√≥n a base de datos), esto se cambi√≥ en FastAPI 0.106.0.

/// tip | Consejo

Adem√°s, una tarea en background es normalmente un conjunto independiente de l√≥gica que deber√≠a manejarse por separado, con sus propios recursos (por ejemplo, su propia conexi√≥n a base de datos).

De esta manera probablemente tendr√°s un c√≥digo m√°s limpio.

///

Si sol√≠as depender de este comportamiento, ahora deber√≠as crear los recursos para tareas en background dentro de la propia tarea en background, y usar internamente solo datos que no dependan de los recursos de las dependencias con `yield`.

Por ejemplo, en lugar de usar la misma sesi√≥n de base de datos, crear√≠as una nueva sesi√≥n de base de datos dentro de la tarea en background, y obtendr√≠as los objetos de la base de datos usando esta nueva sesi√≥n. Y luego, en lugar de pasar el objeto de la base de datos como par√°metro a la funci√≥n de tarea en background, pasar√≠as el ID de ese objeto y luego obtendr√≠as el objeto nuevamente dentro de la funci√≥n de tarea en background.

## Context Managers

### Qu√© son los "Context Managers"

Los "Context Managers" son aquellos objetos de Python que puedes usar en una declaraci√≥n `with`.

Por ejemplo, <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files" class="external-link" target="_blank">puedes usar `with` para leer un archivo</a>:

```Python
with open("./somefile.txt") as f:
    contents = f.read()
    print(contents)
```

Internamente, `open("./somefile.txt")` crea un objeto llamado "Context Manager".

Cuando el bloque `with` termina, se asegura de cerrar el archivo, incluso si hubo excepciones.

Cuando creas una dependencia con `yield`, **FastAPI** crear√° internamente un context manager para ella y lo combinar√° con algunas otras herramientas relacionadas.

### Usando context managers en dependencias con `yield`

/// warning | Advertencia

Esto es, m√°s o menos, una idea "avanzada".

Si apenas est√°s comenzando con **FastAPI**, podr√≠as querer omitirlo por ahora.

///

En Python, puedes crear Context Managers <a href="https://docs.python.org/3/reference/datamodel.html#context-managers" class="external-link" target="_blank">creando una clase con dos m√©todos: `__enter__()` y `__exit__()`</a>.

Tambi√©n puedes usarlos dentro de las dependencias de **FastAPI** con `yield` usando
`with` o `async with` en la funci√≥n de dependencia:

{* ../../docs_src/dependencies/tutorial010.py hl[1:9,13] *}

/// tip | Consejo

Otra manera de crear un context manager es con:

* <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" class="external-link" target="_blank">`@contextlib.contextmanager`</a> o
* <a href="https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager" class="external-link" target="_blank">`@contextlib.asynccontextmanager`</a>

us√°ndolos para decorar una funci√≥n con un solo `yield`.

Eso es lo que **FastAPI** usa internamente para dependencias con `yield`.

Pero no tienes que usar los decoradores para las dependencias de FastAPI (y no deber√≠as).

FastAPI lo har√° por ti internamente.

///


================================================
File: /docs/es/docs/tutorial/dependencies/global-dependencies.md
================================================
# Dependencias Globales

Para algunos tipos de aplicaciones, podr√≠as querer agregar dependencias a toda la aplicaci√≥n.

Similar a como puedes [agregar `dependencies` a los *path operation decorators*](dependencies-in-path-operation-decorators.md){.internal-link target=_blank}, puedes agregarlos a la aplicaci√≥n de `FastAPI`.

En ese caso, se aplicar√°n a todas las *path operations* en la aplicaci√≥n:

{* ../../docs_src/dependencies/tutorial012_an_py39.py hl[16] *}

Y todas las ideas en la secci√≥n sobre [agregar `dependencies` a los *path operation decorators*](dependencies-in-path-operation-decorators.md){.internal-link target=_blank} siguen aplic√°ndose, pero en este caso, a todas las *path operations* en la app.

## Dependencias para grupos de *path operations*

M√°s adelante, al leer sobre c√≥mo estructurar aplicaciones m√°s grandes ([Aplicaciones M√°s Grandes - M√∫ltiples Archivos](../../tutorial/bigger-applications.md){.internal-link target=_blank}), posiblemente con m√∫ltiples archivos, aprender√°s c√≥mo declarar un solo par√°metro de `dependencies` para un grupo de *path operations*.


================================================
File: /docs/es/docs/tutorial/dependencies/index.md
================================================
# Dependencias

**FastAPI** tiene un sistema de **<abbr title="tambi√©n conocido como componentes, recursos, proveedores, servicios, inyectables">Inyecci√≥n de Dependencias</abbr>** muy poderoso pero intuitivo.

Est√° dise√±ado para ser muy simple de usar, y para hacer que cualquier desarrollador integre otros componentes con **FastAPI** de forma muy sencilla.

## Qu√© es la "Inyecci√≥n de Dependencias"

**"Inyecci√≥n de Dependencias"** significa, en programaci√≥n, que hay una manera para que tu c√≥digo (en este caso, tus *path operation functions*) declare las cosas que necesita para funcionar y utilizar: "dependencias".

Y luego, ese sistema (en este caso **FastAPI**) se encargar√° de hacer lo que sea necesario para proporcionar a tu c√≥digo esas dependencias necesarias ("inyectar" las dependencias).

Esto es muy √∫til cuando necesitas:

* Tener l√≥gica compartida (la misma l√≥gica de c√≥digo una y otra vez).
* Compartir conexiones a bases de datos.
* Imponer seguridad, autenticaci√≥n, requisitos de roles, etc.
* Y muchas otras cosas...

Todo esto, mientras minimizas la repetici√≥n de c√≥digo.

## Primeros Pasos

Veamos un ejemplo muy simple. Ser√° tan simple que no es muy √∫til, por ahora.

Pero de esta manera podemos enfocarnos en c√≥mo funciona el sistema de **Inyecci√≥n de Dependencias**.

### Crear una dependencia, o "dependable"

Primero enfoqu√©monos en la dependencia.

Es solo una funci√≥n que puede tomar todos los mismos par√°metros que una *path operation function* puede tomar:

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[8:9] *}

Eso es todo.

**2 l√≠neas**.

Y tiene la misma forma y estructura que todas tus *path operation functions*.

Puedes pensar en ella como una *path operation function* sin el "decorador" (sin el `@app.get("/some-path")`).

Y puede devolver lo que quieras.

En este caso, esta dependencia espera:

* Un par√°metro de query opcional `q` que es un `str`.
* Un par√°metro de query opcional `skip` que es un `int`, y por defecto es `0`.
* Un par√°metro de query opcional `limit` que es un `int`, y por defecto es `100`.

Y luego solo devuelve un `dict` que contiene esos valores.

/// info | Informaci√≥n

FastAPI agreg√≥ soporte para `Annotated` (y comenz√≥ a recomendarlo) en la versi√≥n 0.95.0.

Si tienes una versi√≥n anterior, obtendr√°s errores al intentar usar `Annotated`.

Aseg√∫rate de [Actualizar la versi√≥n de FastAPI](../../deployment/versions.md#upgrading-the-fastapi-versions){.internal-link target=_blank} al menos a la 0.95.1 antes de usar `Annotated`.

///

### Importar `Depends`

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[3] *}

### Declarar la dependencia, en el "dependant"

De la misma forma en que usas `Body`, `Query`, etc. con los par√°metros de tu *path operation function*, usa `Depends` con un nuevo par√°metro:

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[13,18] *}

Aunque usas `Depends` en los par√°metros de tu funci√≥n de la misma manera que usas `Body`, `Query`, etc., `Depends` funciona un poco diferente.

Le das a `Depends` un solo par√°metro.

Este par√°metro debe ser algo como una funci√≥n.

**No la llames** directamente (no agregues los par√©ntesis al final), solo p√°sala como un par√°metro a `Depends()`.

Y esa funci√≥n toma par√°metros de la misma manera que las *path operation functions*.

/// tip | Consejo

Ver√°s qu√© otras "cosas", adem√°s de funciones, pueden usarse como dependencias en el pr√≥ximo cap√≠tulo.

///

Cada vez que llega un nuevo request, **FastAPI** se encargar√° de:

* Llamar a tu funci√≥n de dependencia ("dependable") con los par√°metros correctos.
* Obtener el resultado de tu funci√≥n.
* Asignar ese resultado al par√°metro en tu *path operation function*.

```mermaid
graph TB

common_parameters(["common_parameters"])
read_items["/items/"]
read_users["/users/"]

common_parameters --> read_items
common_parameters --> read_users
```

De esta manera escribes c√≥digo compartido una vez y **FastAPI** se encarga de llamarlo para tus *path operations*.

/// check | Revisa

Nota que no tienes que crear una clase especial y pasarla en alg√∫n lugar a **FastAPI** para "registrarla" o algo similar.

Solo la pasas a `Depends` y **FastAPI** sabe c√≥mo hacer el resto.

///

## Compartir dependencias `Annotated`

En los ejemplos anteriores, ves que hay un poquito de **duplicaci√≥n de c√≥digo**.

Cuando necesitas usar la dependencia `common_parameters()`, tienes que escribir todo el par√°metro con la anotaci√≥n de tipo y `Depends()`:

```Python
commons: Annotated[dict, Depends(common_parameters)]
```

Pero como estamos usando `Annotated`, podemos almacenar ese valor `Annotated` en una variable y usarlo en m√∫ltiples lugares:

{* ../../docs_src/dependencies/tutorial001_02_an_py310.py hl[12,16,21] *}

/// tip | Consejo

Esto es solo Python est√°ndar, se llama un "alias de tipo", en realidad no es espec√≠fico de **FastAPI**.

Pero porque **FastAPI** est√° basado en los est√°ndares de Python, incluido `Annotated`, puedes usar este truco en tu c√≥digo. üòé

///

Las dependencias seguir√°n funcionando como se esperaba, y la **mejor parte** es que la **informaci√≥n de tipo se preservar√°**, lo que significa que tu editor podr√° seguir proporcion√°ndote **autocompletado**, **errores en l√≠nea**, etc. Lo mismo para otras herramientas como `mypy`.

Esto ser√° especialmente √∫til cuando lo uses en una **gran base de c√≥digo** donde uses **las mismas dependencias** una y otra vez en **muchas *path operations***.

## Usar `async` o no usar `async`

Como las dependencias tambi√©n ser√°n llamadas por **FastAPI** (lo mismo que tus *path operation functions*), las mismas reglas aplican al definir tus funciones.

Puedes usar `async def` o `def` normal.

Y puedes declarar dependencias con `async def` dentro de *path operation functions* normales `def`, o dependencias `def` dentro de *path operation functions* `async def`, etc.

No importa. **FastAPI** sabr√° qu√© hacer.

/// note | Nota

Si no lo sabes, revisa la secci√≥n [Async: *"¬øCon prisa?"*](../../async.md#in-a-hurry){.internal-link target=_blank} sobre `async` y `await` en la documentaci√≥n.

///

## Integraci√≥n con OpenAPI

Todas las declaraciones de request, validaciones y requisitos de tus dependencias (y sub-dependencias) se integrar√°n en el mismo esquema de OpenAPI.

As√≠, la documentaci√≥n interactiva tendr√° toda la informaci√≥n de estas dependencias tambi√©n:

<img src="/img/tutorial/dependencies/image01.png">

## Uso simple

Si lo ves, las *path operation functions* se declaran para ser usadas siempre que un *path* y una *operaci√≥n* coincidan, y luego **FastAPI** se encarga de llamar la funci√≥n con los par√°metros correctos, extrayendo los datos del request.

En realidad, todos (o la mayor√≠a) de los frameworks web funcionan de esta misma manera.

Nunca llamas directamente a esas funciones. Son llamadas por tu framework (en este caso, **FastAPI**).

Con el sistema de Inyecci√≥n de Dependencias, tambi√©n puedes decirle a **FastAPI** que tu *path operation function* tambi√©n "depende" de algo m√°s que debe ejecutarse antes que tu *path operation function*, y **FastAPI** se encargar√° de ejecutarlo e "inyectar" los resultados.

Otros t√©rminos comunes para esta misma idea de "inyecci√≥n de dependencias" son:

* recursos
* proveedores
* servicios
* inyectables
* componentes

## Plug-ins de **FastAPI**

Las integraciones y "plug-ins" pueden construirse usando el sistema de **Inyecci√≥n de Dependencias**. Pero, de hecho, en realidad **no hay necesidad de crear "plug-ins"**, ya que al usar dependencias es posible declarar una cantidad infinita de integraciones e interacciones que se vuelven disponibles para tus *path operation functions*.

Y las dependencias se pueden crear de una manera muy simple e intuitiva que te permite simplemente importar los paquetes de Python que necesitas, e integrarlos con tus funciones de API en un par de l√≠neas de c√≥digo, *literalmente*.

Ver√°s ejemplos de esto en los pr√≥ximos cap√≠tulos, sobre bases de datos relacionales y NoSQL, seguridad, etc.

## Compatibilidad de **FastAPI**

La simplicidad del sistema de inyecci√≥n de dependencias hace que **FastAPI** sea compatible con:

* todas las bases de datos relacionales
* bases de datos NoSQL
* paquetes externos
* APIs externas
* sistemas de autenticaci√≥n y autorizaci√≥n
* sistemas de monitoreo de uso de la API
* sistemas de inyecci√≥n de datos de response
* etc.

## Simple y Poderoso

Aunque el sistema de inyecci√≥n de dependencias jer√°rquico es muy simple de definir y usar, sigue siendo muy poderoso.

Puedes definir dependencias que a su vez pueden definir dependencias ellas mismas.

Al final, se construye un √°rbol jer√°rquico de dependencias, y el sistema de **Inyecci√≥n de Dependencias** se encarga de resolver todas estas dependencias por ti (y sus sub-dependencias) y proporcionar (inyectar) los resultados en cada paso.

Por ejemplo, digamos que tienes 4 endpoints de API (*path operations*):

* `/items/public/`
* `/items/private/`
* `/users/{user_id}/activate`
* `/items/pro/`

entonces podr√≠as agregar diferentes requisitos de permiso para cada uno de ellos solo con dependencias y sub-dependencias:

```mermaid
graph TB

current_user(["current_user"])
active_user(["active_user"])
admin_user(["admin_user"])
paying_user(["paying_user"])

public["/items/public/"]
private["/items/private/"]
activate_user["/users/{user_id}/activate"]
pro_items["/items/pro/"]

current_user --> active_user
active_user --> admin_user
active_user --> paying_user

current_user --> public
active_user --> private
admin_user --> activate_user
paying_user --> pro_items
```

## Integrado con **OpenAPI**

Todas estas dependencias, al declarar sus requisitos, tambi√©n a√±aden par√°metros, validaciones, etc. a tus *path operations*.

**FastAPI** se encargar√° de agregar todo al esquema de OpenAPI, para que se muestre en los sistemas de documentaci√≥n interactiva.


================================================
File: /docs/es/docs/tutorial/dependencies/sub-dependencies.md
================================================
# Sub-dependencias

Puedes crear dependencias que tengan **sub-dependencias**.

Pueden ser tan **profundas** como necesites.

**FastAPI** se encargar√° de resolverlas.

## Primera dependencia "dependable"

Podr√≠as crear una primera dependencia ("dependable") as√≠:

{* ../../docs_src/dependencies/tutorial005_an_py310.py hl[8:9] *}

Declara un par√°metro de query opcional `q` como un `str`, y luego simplemente lo devuelve.

Esto es bastante simple (no muy √∫til), pero nos ayudar√° a centrarnos en c√≥mo funcionan las sub-dependencias.

## Segunda dependencia, "dependable" y "dependant"

Luego puedes crear otra funci√≥n de dependencia (un "dependable") que al mismo tiempo declare una dependencia propia (por lo que tambi√©n es un "dependant"):

{* ../../docs_src/dependencies/tutorial005_an_py310.py hl[13] *}

Centr√©monos en los par√°metros declarados:

* Aunque esta funci√≥n es una dependencia ("dependable") en s√≠ misma, tambi√©n declara otra dependencia (depende de algo m√°s).
    * Depende del `query_extractor`, y asigna el valor que devuelve al par√°metro `q`.
* Tambi√©n declara una `last_query` cookie opcional, como un `str`.
    * Si el usuario no proporcion√≥ ning√∫n query `q`, usamos el √∫ltimo query utilizado, que guardamos previamente en una cookie.

## Usa la dependencia

Entonces podemos usar la dependencia con:

{* ../../docs_src/dependencies/tutorial005_an_py310.py hl[23] *}

/// info | Informaci√≥n

F√≠jate que solo estamos declarando una dependencia en la *path operation function*, `query_or_cookie_extractor`.

Pero **FastAPI** sabr√° que tiene que resolver `query_extractor` primero, para pasar los resultados de eso a `query_or_cookie_extractor` al llamarlo.

///

```mermaid
graph TB

query_extractor(["query_extractor"])
query_or_cookie_extractor(["query_or_cookie_extractor"])

read_query["/items/"]

query_extractor --> query_or_cookie_extractor --> read_query
```

## Usando la misma dependencia m√∫ltiples veces

Si una de tus dependencias se declara varias veces para la misma *path operation*, por ejemplo, m√∫ltiples dependencias tienen una sub-dependencia com√∫n, **FastAPI** sabr√° llamar a esa sub-dependencia solo una vez por request.

Y guardar√° el valor devuelto en un <abbr title="Una utilidad/sistema para almacenar valores calculados/generados, para reutilizarlos en lugar de calcularlos nuevamente.">"cache"</abbr> y lo pasar√° a todos los "dependants" que lo necesiten en ese request espec√≠fico, en lugar de llamar a la dependencia varias veces para el mismo request.

En un escenario avanzado donde sabes que necesitas que la dependencia se llame en cada paso (posiblemente varias veces) en el mismo request en lugar de usar el valor "cache", puedes establecer el par√°metro `use_cache=False` al usar `Depends`:

//// tab | Python 3.8+

```Python hl_lines="1"
async def needy_dependency(fresh_value: Annotated[str, Depends(get_value, use_cache=False)]):
    return {"fresh_value": fresh_value}
```

////

//// tab | Python 3.8+ sin Anotaciones

/// tip | Consejo

Prefiere usar la versi√≥n `Annotated` si es posible.

///

```Python hl_lines="1"
async def needy_dependency(fresh_value: str = Depends(get_value, use_cache=False)):
    return {"fresh_value": fresh_value}
```

////

## Resumen

Aparte de todas las palabras rimbombantes usadas aqu√≠, el sistema de **Inyecci√≥n de Dependencias** es bastante simple.

Solo son funciones que se ven igual que las *path operation functions*.

Pero aun as√≠, es muy potente y te permite declarar "grafos" de dependencia anidados arbitrariamente profundos (√°rboles).

/// tip | Consejo

Todo esto podr√≠a no parecer tan √∫til con estos ejemplos simples.

Pero ver√°s lo √∫til que es en los cap√≠tulos sobre **seguridad**.

Y tambi√©n ver√°s la cantidad de c√≥digo que te ahorrar√°.

///


================================================
File: /docs/es/docs/tutorial/security/first-steps.md
================================================
# Seguridad - Primeros pasos

Imaginemos que tienes tu API de **backend** en alg√∫n dominio.

Y tienes un **frontend** en otro dominio o en un path diferente del mismo dominio (o en una aplicaci√≥n m√≥vil).

Y quieres tener una forma para que el frontend se autentique con el backend, usando un **username** y **password**.

Podemos usar **OAuth2** para construir eso con **FastAPI**.

Pero vamos a ahorrarte el tiempo de leer la larga especificaci√≥n completa solo para encontrar esos peque√±os fragmentos de informaci√≥n que necesitas.

Usemos las herramientas proporcionadas por **FastAPI** para manejar la seguridad.

## C√≥mo se ve

Primero solo usemos el c√≥digo y veamos c√≥mo funciona, y luego volveremos para entender qu√© est√° sucediendo.

## Crea `main.py`

Copia el ejemplo en un archivo `main.py`:

{* ../../docs_src/security/tutorial001_an_py39.py *}

## Ejec√∫talo

/// info | Informaci√≥n

El paquete <a href="https://github.com/Kludex/python-multipart" class="external-link" target="_blank">`python-multipart`</a> se instala autom√°ticamente con **FastAPI** cuando ejecutas el comando `pip install "fastapi[standard]"`.

Sin embargo, si usas el comando `pip install fastapi`, el paquete `python-multipart` no se incluye por defecto.

Para instalarlo manualmente, aseg√∫rate de crear un [entorno virtual](../../virtual-environments.md){.internal-link target=_blank}, activarlo, y luego instalarlo con:

```console
$ pip install python-multipart
```

Esto se debe a que **OAuth2** utiliza "form data" para enviar el `username` y `password`.

///

Ejecuta el ejemplo con:

<div class="termy">

```console
$ fastapi dev main.py

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

## Revisa

Ve a la documentaci√≥n interactiva en: <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

Ver√°s algo as√≠:

<img src="/img/tutorial/security/image01.png">

/// check | ¬°Bot√≥n de autorizaci√≥n!

Ya tienes un nuevo y brillante bot√≥n de "Authorize".

Y tu *path operation* tiene un peque√±o candado en la esquina superior derecha que puedes pulsar.

///

Y si lo haces, tendr√°s un peque√±o formulario de autorizaci√≥n para escribir un `username` y `password` (y otros campos opcionales):

<img src="/img/tutorial/security/image02.png">

/// note | Nota

No importa lo que escribas en el formulario, a√∫n no funcionar√°. Pero llegaremos all√≠.

///

Esto por supuesto no es el frontend para los usuarios finales, pero es una gran herramienta autom√°tica para documentar interactivamente toda tu API.

Puede ser utilizada por el equipo de frontend (que tambi√©n puedes ser t√∫ mismo).

Puede ser utilizada por aplicaciones y sistemas de terceros.

Y tambi√©n puede ser utilizada por ti mismo, para depurar, revisar y probar la misma aplicaci√≥n.

## El flujo `password`

Ahora retrocedamos un poco y entendamos qu√© es todo eso.

El "flujo" `password` es una de las formas ("flujos") definidas en OAuth2, para manejar la seguridad y la autenticaci√≥n.

OAuth2 fue dise√±ado para que el backend o la API pudieran ser independientes del servidor que autentica al usuario.

Pero en este caso, la misma aplicaci√≥n de **FastAPI** manejar√° la API y la autenticaci√≥n.

As√≠ que, revis√©moslo desde ese punto de vista simplificado:

* El usuario escribe el `username` y `password` en el frontend, y presiona `Enter`.
* El frontend (ejecut√°ndose en el navegador del usuario) env√≠a ese `username` y `password` a una URL espec√≠fica en nuestra API (declarada con `tokenUrl="token"`).
* La API verifica ese `username` y `password`, y responde con un "token" (no hemos implementado nada de esto a√∫n).
    * Un "token" es solo un string con alg√∫n contenido que podemos usar luego para verificar a este usuario.
    * Normalmente, un token se establece para que expire despu√©s de alg√∫n tiempo.
        * As√≠ que, el usuario tendr√° que volver a iniciar sesi√≥n m√°s adelante.
        * Y si el token es robado, el riesgo es menor. No es como una llave permanente que funcionar√° para siempre (en la mayor√≠a de los casos).
* El frontend almacena temporalmente ese token en alg√∫n lugar.
* El usuario hace clic en el frontend para ir a otra secci√≥n de la aplicaci√≥n web frontend.
* El frontend necesita obtener m√°s datos de la API.
    * Pero necesita autenticaci√≥n para ese endpoint espec√≠fico.
    * As√≠ que, para autenticarse con nuestra API, env√≠a un `header` `Authorization` con un valor de `Bearer ` m√°s el token.
    * Si el token contiene `foobar`, el contenido del `header` `Authorization` ser√≠a: `Bearer foobar`.

## `OAuth2PasswordBearer` de **FastAPI**

**FastAPI** proporciona varias herramientas, en diferentes niveles de abstracci√≥n, para implementar estas funcionalidades de seguridad.

En este ejemplo vamos a usar **OAuth2**, con el flujo **Password**, usando un token **Bearer**. Hacemos eso utilizando la clase `OAuth2PasswordBearer`.

/// info | Informaci√≥n

Un token "bearer" no es la √∫nica opci√≥n.

Pero es la mejor para nuestro caso de uso.

Y podr√≠a ser la mejor para la mayor√≠a de los casos de uso, a menos que seas un experto en OAuth2 y sepas exactamente por qu√© hay otra opci√≥n que se adapta mejor a tus necesidades.

En ese caso, **FastAPI** tambi√©n te proporciona las herramientas para construirlo.

///

Cuando creamos una instance de la clase `OAuth2PasswordBearer` pasamos el par√°metro `tokenUrl`. Este par√°metro contiene la URL que el cliente (el frontend corriendo en el navegador del usuario) usar√° para enviar el `username` y `password` a fin de obtener un token.

{* ../../docs_src/security/tutorial001_an_py39.py hl[8] *}

/// tip | Consejo

Aqu√≠ `tokenUrl="token"` se refiere a una URL relativa `token` que a√∫n no hemos creado. Como es una URL relativa, es equivalente a `./token`.

Porque estamos usando una URL relativa, si tu API estuviera ubicada en `https://example.com/`, entonces se referir√≠a a `https://example.com/token`. Pero si tu API estuviera ubicada en `https://example.com/api/v1/`, entonces se referir√≠a a `https://example.com/api/v1/token`.

Usar una URL relativa es importante para asegurarse de que tu aplicaci√≥n siga funcionando incluso en un caso de uso avanzado como [Detr√°s de un Proxy](../../advanced/behind-a-proxy.md){.internal-link target=_blank}.

///

Este par√°metro no crea ese endpoint / *path operation*, pero declara que la URL `/token` ser√° la que el cliente deber√° usar para obtener el token. Esa informaci√≥n se usa en OpenAPI, y luego en los sistemas de documentaci√≥n interactiva del API.

Pronto tambi√©n crearemos la verdadera *path operation*.

/// info | Informaci√≥n

Si eres un "Pythonista" muy estricto, tal vez no te guste el estilo del nombre del par√°metro `tokenUrl` en lugar de `token_url`.

Eso es porque est√° usando el mismo nombre que en la especificaci√≥n de OpenAPI. Para que si necesitas investigar m√°s sobre cualquiera de estos esquemas de seguridad, puedas simplemente copiarlo y pegarlo para encontrar m√°s informaci√≥n al respecto.

///

La variable `oauth2_scheme` es una instance de `OAuth2PasswordBearer`, pero tambi√©n es un "callable".

Podr√≠a ser llamada como:

```Python
oauth2_scheme(some, parameters)
```

As√≠ que, puede usarse con `Depends`.

### √ösalo

Ahora puedes pasar ese `oauth2_scheme` en una dependencia con `Depends`.

{* ../../docs_src/security/tutorial001_an_py39.py hl[12] *}

Esta dependencia proporcionar√° un `str` que se asigna al par√°metro `token` de la *path operation function*.

**FastAPI** sabr√° que puede usar esta dependencia para definir un "security scheme" en el esquema OpenAPI (y en los docs autom√°ticos del API).

/// info | Detalles t√©cnicos

**FastAPI** sabr√° que puede usar la clase `OAuth2PasswordBearer` (declarada en una dependencia) para definir el esquema de seguridad en OpenAPI porque hereda de `fastapi.security.oauth2.OAuth2`, que a su vez hereda de `fastapi.security.base.SecurityBase`.

Todas las utilidades de seguridad que se integran con OpenAPI (y los docs autom√°ticos del API) heredan de `SecurityBase`, as√≠ es como **FastAPI** puede saber c√≥mo integrarlas en OpenAPI.

///

## Lo que hace

Ir√° y buscar√° en el request ese header `Authorization`, verificar√° si el valor es `Bearer ` m√°s alg√∫n token, y devolver√° el token como un `str`.

Si no ve un header `Authorization`, o el valor no tiene un token `Bearer `, responder√° directamente con un error de c√≥digo de estado 401 (`UNAUTHORIZED`).

Ni siquiera tienes que verificar si el token existe para devolver un error. Puedes estar seguro de que si tu funci√≥n se ejecuta, tendr√° un `str` en ese token.

Puedes probarlo ya en los docs interactivos:

<img src="/img/tutorial/security/image03.png">

Todav√≠a no estamos verificando la validez del token, pero ya es un comienzo.

## Resumen

As√≠ que, en solo 3 o 4 l√≠neas adicionales, ya tienes alguna forma primitiva de seguridad.


================================================
File: /docs/es/docs/tutorial/security/get-current-user.md
================================================
# Obtener Usuario Actual

En el cap√≠tulo anterior, el sistema de seguridad (que se basa en el sistema de inyecci√≥n de dependencias) le estaba dando a la *path operation function* un `token` como un `str`:

{* ../../docs_src/security/tutorial001_an_py39.py hl[12] *}

Pero eso a√∫n no es tan √∫til. Vamos a hacer que nos d√© el usuario actual.

## Crear un modelo de usuario

Primero, vamos a crear un modelo de usuario con Pydantic.

De la misma manera que usamos Pydantic para declarar cuerpos, podemos usarlo en cualquier otra parte:

{* ../../docs_src/security/tutorial002_an_py310.py hl[5,12:6] *}

## Crear una dependencia `get_current_user`

Vamos a crear una dependencia `get_current_user`.

¬øRecuerdas que las dependencias pueden tener sub-dependencias?

`get_current_user` tendr√° una dependencia con el mismo `oauth2_scheme` que creamos antes.

De la misma manera que est√°bamos haciendo antes en la *path operation* directamente, nuestra nueva dependencia `get_current_user` recibir√° un `token` como un `str` de la sub-dependencia `oauth2_scheme`:

{* ../../docs_src/security/tutorial002_an_py310.py hl[25] *}

## Obtener el usuario

`get_current_user` usar√° una funci√≥n de utilidad (falsa) que creamos, que toma un token como un `str` y devuelve nuestro modelo de Pydantic `User`:

{* ../../docs_src/security/tutorial002_an_py310.py hl[19:22,26:27] *}

## Inyectar al usuario actual

Entonces ahora podemos usar el mismo `Depends` con nuestro `get_current_user` en la *path operation*:

{* ../../docs_src/security/tutorial002_an_py310.py hl[31] *}

Ten en cuenta que declaramos el tipo de `current_user` como el modelo de Pydantic `User`.

Esto nos ayudar√° dentro de la funci√≥n con todo el autocompletado y chequeo de tipos.

/// tip | Consejo

Tal vez recuerdes que los cuerpos de request tambi√©n se declaran con modelos de Pydantic.

Aqu√≠ **FastAPI** no se confundir√° porque est√°s usando `Depends`.

///

/// check | Revisa

El modo en que este sistema de dependencias est√° dise√±ado nos permite tener diferentes dependencias (diferentes "dependables") que todas devuelven un modelo `User`.

No estamos restringidos a tener solo una dependencia que pueda devolver ese tipo de datos.

///

## Otros modelos

Ahora puedes obtener el usuario actual directamente en las *path operation functions* y manejar los mecanismos de seguridad a nivel de **Dependency Injection**, usando `Depends`.

Y puedes usar cualquier modelo o datos para los requisitos de seguridad (en este caso, un modelo de Pydantic `User`).

Pero no est√°s limitado a usar alg√∫n modelo de datos, clase o tipo espec√≠fico.

¬øQuieres tener un `id` y `email` y no tener un `username` en tu modelo? Claro. Puedes usar estas mismas herramientas.

¬øQuieres solo tener un `str`? ¬øO solo un `dict`? ¬øO un instance de clase modelo de base de datos directamente? Todo funciona de la misma manera.

¬øEn realidad no tienes usuarios que inicien sesi√≥n en tu aplicaci√≥n sino robots, bots u otros sistemas, que solo tienen un token de acceso? Una vez m√°s, todo funciona igual.

Usa cualquier tipo de modelo, cualquier tipo de clase, cualquier tipo de base de datos que necesites para tu aplicaci√≥n. **FastAPI** te cubre con el sistema de inyecci√≥n de dependencias.

## Tama√±o del c√≥digo

Este ejemplo podr√≠a parecer extenso. Ten en cuenta que estamos mezclando seguridad, modelos de datos, funciones de utilidad y *path operations* en el mismo archivo.

Pero aqu√≠ est√° el punto clave.

El tema de seguridad e inyecci√≥n de dependencias se escribe una vez.

Y puedes hacerlo tan complejo como desees. Y a√∫n as√≠, tenerlo escrito solo una vez, en un solo lugar. Con toda la flexibilidad.

Pero puedes tener miles de endpoints (*path operations*) usando el mismo sistema de seguridad.

Y todos ellos (o cualquier porci√≥n de ellos que quieras) pueden aprovechar la reutilizaci√≥n de estas dependencias o cualquier otra dependencia que crees.

Y todas estas miles de *path operations* pueden ser tan peque√±as como 3 l√≠neas:

{* ../../docs_src/security/tutorial002_an_py310.py hl[30:32] *}

## Resumen

Ahora puedes obtener el usuario actual directamente en tu *path operation function*.
