```

/// tip

To declare a query parameter with a type of `list`, like in the example above, you need to explicitly use `Query`, otherwise it would be interpreted as a request body.

///

The interactive API docs will update accordingly, to allow multiple values:

<img src="/img/tutorial/query-params-str-validations/image02.png">

### Query parameter list / multiple values with defaults

And you can also define a default `list` of values if none are provided:

{* ../../docs_src/query_params_str_validations/tutorial012_an_py39.py hl[9] *}

If you go to:

```
http://localhost:8000/items/
```

the default of `q` will be: `["foo", "bar"]` and your response will be:

```JSON
{
  "q": [
    "foo",
    "bar"
  ]
}
```

#### Using just `list`

You can also use `list` directly instead of `List[str]` (or `list[str]` in Python 3.9+):

{* ../../docs_src/query_params_str_validations/tutorial013_an_py39.py hl[9] *}

/// note

Keep in mind that in this case, FastAPI won't check the contents of the list.

For example, `List[int]` would check (and document) that the contents of the list are integers. But `list` alone wouldn't.

///

## Declare more metadata

You can add more information about the parameter.

That information will be included in the generated OpenAPI and used by the documentation user interfaces and external tools.

/// note

Keep in mind that different tools might have different levels of OpenAPI support.

Some of them might not show all the extra information declared yet, although in most of the cases, the missing feature is already planned for development.

///

You can add a `title`:

{* ../../docs_src/query_params_str_validations/tutorial007_an_py310.py hl[10] *}

And a `description`:

{* ../../docs_src/query_params_str_validations/tutorial008_an_py310.py hl[14] *}

## Alias parameters

Imagine that you want the parameter to be `item-query`.

Like in:

```
http://127.0.0.1:8000/items/?item-query=foobaritems
```

But `item-query` is not a valid Python variable name.

The closest would be `item_query`.

But you still need it to be exactly `item-query`...

Then you can declare an `alias`, and that alias is what will be used to find the parameter value:

{* ../../docs_src/query_params_str_validations/tutorial009_an_py310.py hl[9] *}

## Deprecating parameters

Now let's say you don't like this parameter anymore.

You have to leave it there a while because there are clients using it, but you want the docs to clearly show it as <abbr title="obsolete, recommended not to use it">deprecated</abbr>.

Then pass the parameter `deprecated=True` to `Query`:

{* ../../docs_src/query_params_str_validations/tutorial010_an_py310.py hl[19] *}

The docs will show it like this:

<img src="/img/tutorial/query-params-str-validations/image01.png">

## Exclude parameters from OpenAPI

To exclude a query parameter from the generated OpenAPI schema (and thus, from the automatic documentation systems), set the parameter `include_in_schema` of `Query` to `False`:

{* ../../docs_src/query_params_str_validations/tutorial014_an_py310.py hl[10] *}

## Recap

You can declare additional validations and metadata for your parameters.

Generic validations and metadata:

* `alias`
* `title`
* `description`
* `deprecated`

Validations specific for strings:

* `min_length`
* `max_length`
* `pattern`

In these examples you saw how to declare validations for `str` values.

See the next chapters to learn how to declare validations for other types, like numbers.


================================================
File: /docs/en/docs/tutorial/query-params.md
================================================
# Query Parameters

When you declare other function parameters that are not part of the path parameters, they are automatically interpreted as "query" parameters.

{* ../../docs_src/query_params/tutorial001.py hl[9] *}

The query is the set of key-value pairs that go after the `?` in a URL, separated by `&` characters.

For example, in the URL:

```
http://127.0.0.1:8000/items/?skip=0&limit=10
```

...the query parameters are:

* `skip`: with a value of `0`
* `limit`: with a value of `10`

As they are part of the URL, they are "naturally" strings.

But when you declare them with Python types (in the example above, as `int`), they are converted to that type and validated against it.

All the same process that applied for path parameters also applies for query parameters:

* Editor support (obviously)
* Data <abbr title="converting the string that comes from an HTTP request into Python data">"parsing"</abbr>
* Data validation
* Automatic documentation

## Defaults

As query parameters are not a fixed part of a path, they can be optional and can have default values.

In the example above they have default values of `skip=0` and `limit=10`.

So, going to the URL:

```
http://127.0.0.1:8000/items/
```

would be the same as going to:

```
http://127.0.0.1:8000/items/?skip=0&limit=10
```

But if you go to, for example:

```
http://127.0.0.1:8000/items/?skip=20
```

The parameter values in your function will be:

* `skip=20`: because you set it in the URL
* `limit=10`: because that was the default value

## Optional parameters

The same way, you can declare optional query parameters, by setting their default to `None`:

{* ../../docs_src/query_params/tutorial002_py310.py hl[7] *}

In this case, the function parameter `q` will be optional, and will be `None` by default.

/// check

Also notice that **FastAPI** is smart enough to notice that the path parameter `item_id` is a path parameter and `q` is not, so, it's a query parameter.

///

## Query parameter type conversion

You can also declare `bool` types, and they will be converted:

{* ../../docs_src/query_params/tutorial003_py310.py hl[7] *}

In this case, if you go to:

```
http://127.0.0.1:8000/items/foo?short=1
```

or

```
http://127.0.0.1:8000/items/foo?short=True
```

or

```
http://127.0.0.1:8000/items/foo?short=true
```

or

```
http://127.0.0.1:8000/items/foo?short=on
```

or

```
http://127.0.0.1:8000/items/foo?short=yes
```

or any other case variation (uppercase, first letter in uppercase, etc), your function will see the parameter `short` with a `bool` value of `True`. Otherwise as `False`.


## Multiple path and query parameters

You can declare multiple path parameters and query parameters at the same time, **FastAPI** knows which is which.

And you don't have to declare them in any specific order.

They will be detected by name:

{* ../../docs_src/query_params/tutorial004_py310.py hl[6,8] *}

## Required query parameters

When you declare a default value for non-path parameters (for now, we have only seen query parameters), then it is not required.

If you don't want to add a specific value but just make it optional, set the default as `None`.

But when you want to make a query parameter required, you can just not declare any default value:

{* ../../docs_src/query_params/tutorial005.py hl[6:7] *}

Here the query parameter `needy` is a required query parameter of type `str`.

If you open in your browser a URL like:

```
http://127.0.0.1:8000/items/foo-item
```

...without adding the required parameter `needy`, you will see an error like:

```JSON
{
  "detail": [
    {
      "type": "missing",
      "loc": [
        "query",
        "needy"
      ],
      "msg": "Field required",
      "input": null,
      "url": "https://errors.pydantic.dev/2.1/v/missing"
    }
  ]
}
```

As `needy` is a required parameter, you would need to set it in the URL:

```
http://127.0.0.1:8000/items/foo-item?needy=sooooneedy
```

...this would work:

```JSON
{
    "item_id": "foo-item",
    "needy": "sooooneedy"
}
```

And of course, you can define some parameters as required, some as having a default value, and some entirely optional:

{* ../../docs_src/query_params/tutorial006_py310.py hl[8] *}

In this case, there are 3 query parameters:

* `needy`, a required `str`.
* `skip`, an `int` with a default value of `0`.
* `limit`, an optional `int`.

/// tip

You could also use `Enum`s the same way as with [Path Parameters](path-params.md#predefined-values){.internal-link target=_blank}.

///


================================================
File: /docs/en/docs/tutorial/request-files.md
================================================
# Request Files

You can define files to be uploaded by the client using `File`.

/// info

To receive uploaded files, first install <a href="https://github.com/Kludex/python-multipart" class="external-link" target="_blank">`python-multipart`</a>.

Make sure you create a [virtual environment](../virtual-environments.md){.internal-link target=_blank}, activate it, and then install it, for example:

```console
$ pip install python-multipart
```

This is because uploaded files are sent as "form data".

///

## Import `File`

Import `File` and `UploadFile` from `fastapi`:

{* ../../docs_src/request_files/tutorial001_an_py39.py hl[3] *}

## Define `File` Parameters

Create file parameters the same way you would for `Body` or `Form`:

{* ../../docs_src/request_files/tutorial001_an_py39.py hl[9] *}

/// info

`File` is a class that inherits directly from `Form`.

But remember that when you import `Query`, `Path`, `File` and others from `fastapi`, those are actually functions that return special classes.

///

/// tip

To declare File bodies, you need to use `File`, because otherwise the parameters would be interpreted as query parameters or body (JSON) parameters.

///

The files will be uploaded as "form data".

If you declare the type of your *path operation function* parameter as `bytes`, **FastAPI** will read the file for you and you will receive the contents as `bytes`.

Keep in mind that this means that the whole contents will be stored in memory. This will work well for small files.

But there are several cases in which you might benefit from using `UploadFile`.

## File Parameters with `UploadFile`

Define a file parameter with a type of `UploadFile`:

{* ../../docs_src/request_files/tutorial001_an_py39.py hl[14] *}

Using `UploadFile` has several advantages over `bytes`:

* You don't have to use `File()` in the default value of the parameter.
* It uses a "spooled" file:
    * A file stored in memory up to a maximum size limit, and after passing this limit it will be stored in disk.
* This means that it will work well for large files like images, videos, large binaries, etc. without consuming all the memory.
* You can get metadata from the uploaded file.
* It has a <a href="https://docs.python.org/3/glossary.html#term-file-like-object" class="external-link" target="_blank">file-like</a> `async` interface.
* It exposes an actual Python <a href="https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile" class="external-link" target="_blank">`SpooledTemporaryFile`</a> object that you can pass directly to other libraries that expect a file-like object.

### `UploadFile`

`UploadFile` has the following attributes:

* `filename`: A `str` with the original file name that was uploaded (e.g. `myimage.jpg`).
* `content_type`: A `str` with the content type (MIME type / media type) (e.g. `image/jpeg`).
* `file`: A <a href="https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile" class="external-link" target="_blank">`SpooledTemporaryFile`</a> (a <a href="https://docs.python.org/3/glossary.html#term-file-like-object" class="external-link" target="_blank">file-like</a> object). This is the actual Python file object that you can pass directly to other functions or libraries that expect a "file-like" object.

`UploadFile` has the following `async` methods. They all call the corresponding file methods underneath (using the internal `SpooledTemporaryFile`).

* `write(data)`: Writes `data` (`str` or `bytes`) to the file.
* `read(size)`: Reads `size` (`int`) bytes/characters of the file.
* `seek(offset)`: Goes to the byte position `offset` (`int`) in the file.
    * E.g., `await myfile.seek(0)` would go to the start of the file.
    * This is especially useful if you run `await myfile.read()` once and then need to read the contents again.
* `close()`: Closes the file.

As all these methods are `async` methods, you need to "await" them.

For example, inside of an `async` *path operation function* you can get the contents with:

```Python
contents = await myfile.read()
```

If you are inside of a normal `def` *path operation function*, you can access the `UploadFile.file` directly, for example:

```Python
contents = myfile.file.read()
```

/// note | `async` Technical Details

When you use the `async` methods, **FastAPI** runs the file methods in a threadpool and awaits for them.

///

/// note | Starlette Technical Details

**FastAPI**'s `UploadFile` inherits directly from **Starlette**'s `UploadFile`, but adds some necessary parts to make it compatible with **Pydantic** and the other parts of FastAPI.

///

## What is "Form Data"

The way HTML forms (`<form></form>`) sends the data to the server normally uses a "special" encoding for that data, it's different from JSON.

**FastAPI** will make sure to read that data from the right place instead of JSON.

/// note | Technical Details

Data from forms is normally encoded using the "media type" `application/x-www-form-urlencoded` when it doesn't include files.

But when the form includes files, it is encoded as `multipart/form-data`. If you use `File`, **FastAPI** will know it has to get the files from the correct part of the body.

If you want to read more about these encodings and form fields, head to the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" class="external-link" target="_blank"><abbr title="Mozilla Developer Network">MDN</abbr> web docs for <code>POST</code></a>.

///

/// warning

You can declare multiple `File` and `Form` parameters in a *path operation*, but you can't also declare `Body` fields that you expect to receive as JSON, as the request will have the body encoded using `multipart/form-data` instead of `application/json`.

This is not a limitation of **FastAPI**, it's part of the HTTP protocol.

///

## Optional File Upload

You can make a file optional by using standard type annotations and setting a default value of `None`:

{* ../../docs_src/request_files/tutorial001_02_an_py310.py hl[9,17] *}

## `UploadFile` with Additional Metadata

You can also use `File()` with `UploadFile`, for example, to set additional metadata:

{* ../../docs_src/request_files/tutorial001_03_an_py39.py hl[9,15] *}

## Multiple File Uploads

It's possible to upload several files at the same time.

They would be associated to the same "form field" sent using "form data".

To use that, declare a list of `bytes` or `UploadFile`:

{* ../../docs_src/request_files/tutorial002_an_py39.py hl[10,15] *}

You will receive, as declared, a `list` of `bytes` or `UploadFile`s.

/// note | Technical Details

You could also use `from starlette.responses import HTMLResponse`.

**FastAPI** provides the same `starlette.responses` as `fastapi.responses` just as a convenience for you, the developer. But most of the available responses come directly from Starlette.

///

### Multiple File Uploads with Additional Metadata

And the same way as before, you can use `File()` to set additional parameters, even for `UploadFile`:

{* ../../docs_src/request_files/tutorial003_an_py39.py hl[11,18:20] *}

## Recap

Use `File`, `bytes`, and `UploadFile` to declare files to be uploaded in the request, sent as form data.


================================================
File: /docs/en/docs/tutorial/request-form-models.md
================================================
# Form Models

You can use **Pydantic models** to declare **form fields** in FastAPI.

/// info

To use forms, first install <a href="https://github.com/Kludex/python-multipart" class="external-link" target="_blank">`python-multipart`</a>.

Make sure you create a [virtual environment](../virtual-environments.md){.internal-link target=_blank}, activate it, and then install it, for example:

```console
$ pip install python-multipart
```

///

/// note

This is supported since FastAPI version `0.113.0`. ðŸ¤“

///

## Pydantic Models for Forms

You just need to declare a **Pydantic model** with the fields you want to receive as **form fields**, and then declare the parameter as `Form`:

{* ../../docs_src/request_form_models/tutorial001_an_py39.py hl[9:11,15] *}

**FastAPI** will **extract** the data for **each field** from the **form data** in the request and give you the Pydantic model you defined.

## Check the Docs

You can verify it in the docs UI at `/docs`:

<div class="screenshot">
<img src="/img/tutorial/request-form-models/image01.png">
</div>

## Forbid Extra Form Fields

In some special use cases (probably not very common), you might want to **restrict** the form fields to only those declared in the Pydantic model. And **forbid** any **extra** fields.

/// note

This is supported since FastAPI version `0.114.0`. ðŸ¤“

///

You can use Pydantic's model configuration to `forbid` any `extra` fields:

{* ../../docs_src/request_form_models/tutorial002_an_py39.py hl[12] *}

If a client tries to send some extra data, they will receive an **error** response.

For example, if the client tries to send the form fields:

* `username`: `Rick`
* `password`: `Portal Gun`
* `extra`: `Mr. Poopybutthole`

They will receive an error response telling them that the field `extra` is not allowed:

```json
{
    "detail": [
        {
            "type": "extra_forbidden",
            "loc": ["body", "extra"],
            "msg": "Extra inputs are not permitted",
            "input": "Mr. Poopybutthole"
        }
    ]
}
```

## Summary

You can use Pydantic models to declare form fields in FastAPI. ðŸ˜Ž


================================================
File: /docs/en/docs/tutorial/request-forms-and-files.md
================================================
# Request Forms and Files

You can define files and form fields at the same time using `File` and `Form`.

/// info

To receive uploaded files and/or form data, first install <a href="https://github.com/Kludex/python-multipart" class="external-link" target="_blank">`python-multipart`</a>.

Make sure you create a [virtual environment](../virtual-environments.md){.internal-link target=_blank}, activate it, and then install it, for example:

```console
$ pip install python-multipart
```

///

## Import `File` and `Form`

{* ../../docs_src/request_forms_and_files/tutorial001_an_py39.py hl[3] *}

## Define `File` and `Form` parameters

Create file and form parameters the same way you would for `Body` or `Query`:

{* ../../docs_src/request_forms_and_files/tutorial001_an_py39.py hl[10:12] *}

The files and form fields will be uploaded as form data and you will receive the files and form fields.

And you can declare some of the files as `bytes` and some as `UploadFile`.

/// warning

You can declare multiple `File` and `Form` parameters in a *path operation*, but you can't also declare `Body` fields that you expect to receive as JSON, as the request will have the body encoded using `multipart/form-data` instead of `application/json`.

This is not a limitation of **FastAPI**, it's part of the HTTP protocol.

///

## Recap

Use `File` and `Form` together when you need to receive data and files in the same request.


================================================
File: /docs/en/docs/tutorial/request-forms.md
================================================
# Form Data

When you need to receive form fields instead of JSON, you can use `Form`.

/// info

To use forms, first install <a href="https://github.com/Kludex/python-multipart" class="external-link" target="_blank">`python-multipart`</a>.

Make sure you create a [virtual environment](../virtual-environments.md){.internal-link target=_blank}, activate it, and then install it, for example:

```console
$ pip install python-multipart
```

///

## Import `Form`

Import `Form` from `fastapi`:

{* ../../docs_src/request_forms/tutorial001_an_py39.py hl[3] *}

## Define `Form` parameters

Create form parameters the same way you would for `Body` or `Query`:

{* ../../docs_src/request_forms/tutorial001_an_py39.py hl[9] *}

For example, in one of the ways the OAuth2 specification can be used (called "password flow") it is required to send a `username` and `password` as form fields.

The <abbr title="specification">spec</abbr> requires the fields to be exactly named `username` and `password`, and to be sent as form fields, not JSON.

With `Form` you can declare the same configurations as with `Body` (and `Query`, `Path`, `Cookie`), including validation, examples, an alias (e.g. `user-name` instead of `username`), etc.

/// info

`Form` is a class that inherits directly from `Body`.

///

/// tip

To declare form bodies, you need to use `Form` explicitly, because without it the parameters would be interpreted as query parameters or body (JSON) parameters.

///

## About "Form Fields"

The way HTML forms (`<form></form>`) sends the data to the server normally uses a "special" encoding for that data, it's different from JSON.

**FastAPI** will make sure to read that data from the right place instead of JSON.

/// note | Technical Details

Data from forms is normally encoded using the "media type" `application/x-www-form-urlencoded`.

But when the form includes files, it is encoded as `multipart/form-data`. You'll read about handling files in the next chapter.

If you want to read more about these encodings and form fields, head to the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" class="external-link" target="_blank"><abbr title="Mozilla Developer Network">MDN</abbr> web docs for <code>POST</code></a>.

///

/// warning

You can declare multiple `Form` parameters in a *path operation*, but you can't also declare `Body` fields that you expect to receive as JSON, as the request will have the body encoded using `application/x-www-form-urlencoded` instead of `application/json`.

This is not a limitation of **FastAPI**, it's part of the HTTP protocol.

///

## Recap

Use `Form` to declare form data input parameters.


================================================
File: /docs/en/docs/tutorial/response-model.md
================================================
# Response Model - Return Type

You can declare the type used for the response by annotating the *path operation function* **return type**.

You can use **type annotations** the same way you would for input data in function **parameters**, you can use Pydantic models, lists, dictionaries, scalar values like integers, booleans, etc.

{* ../../docs_src/response_model/tutorial001_01_py310.py hl[16,21] *}

FastAPI will use this return type to:

* **Validate** the returned data.
    * If the data is invalid (e.g. you are missing a field), it means that *your* app code is broken, not returning what it should, and it will return a server error instead of returning incorrect data. This way you and your clients can be certain that they will receive the data and the data shape expected.
* Add a **JSON Schema** for the response, in the OpenAPI *path operation*.
    * This will be used by the **automatic docs**.
    * It will also be used by automatic client code generation tools.

But most importantly:

* It will **limit and filter** the output data to what is defined in the return type.
    * This is particularly important for **security**, we'll see more of that below.

## `response_model` Parameter

There are some cases where you need or want to return some data that is not exactly what the type declares.

For example, you could want to **return a dictionary** or a database object, but **declare it as a Pydantic model**. This way the Pydantic model would do all the data documentation, validation, etc. for the object that you returned (e.g. a dictionary or database object).

If you added the return type annotation, tools and editors would complain with a (correct) error telling you that your function is returning a type (e.g. a dict) that is different from what you declared (e.g. a Pydantic model).

In those cases, you can use the *path operation decorator* parameter `response_model` instead of the return type.

You can use the `response_model` parameter in any of the *path operations*:

* `@app.get()`
* `@app.post()`
* `@app.put()`
* `@app.delete()`
* etc.

{* ../../docs_src/response_model/tutorial001_py310.py hl[17,22,24:27] *}

/// note

Notice that `response_model` is a parameter of the "decorator" method (`get`, `post`, etc). Not of your *path operation function*, like all the parameters and body.

///

`response_model` receives the same type you would declare for a Pydantic model field, so, it can be a Pydantic model, but it can also be, e.g. a `list` of Pydantic models, like `List[Item]`.

FastAPI will use this `response_model` to do all the data documentation, validation, etc. and also to **convert and filter the output data** to its type declaration.

/// tip

If you have strict type checks in your editor, mypy, etc, you can declare the function return type as `Any`.

That way you tell the editor that you are intentionally returning anything. But FastAPI will still do the data documentation, validation, filtering, etc. with the `response_model`.

///

### `response_model` Priority

If you declare both a return type and a `response_model`, the `response_model` will take priority and be used by FastAPI.

This way you can add correct type annotations to your functions even when you are returning a type different than the response model, to be used by the editor and tools like mypy. And still you can have FastAPI do the data validation, documentation, etc. using the `response_model`.

You can also use `response_model=None` to disable creating a response model for that *path operation*, you might need to do it if you are adding type annotations for things that are not valid Pydantic fields, you will see an example of that in one of the sections below.

## Return the same input data

Here we are declaring a `UserIn` model, it will contain a plaintext password:

{* ../../docs_src/response_model/tutorial002_py310.py hl[7,9] *}

/// info

To use `EmailStr`, first install <a href="https://github.com/JoshData/python-email-validator" class="external-link" target="_blank">`email-validator`</a>.

Make sure you create a [virtual environment](../virtual-environments.md){.internal-link target=_blank}, activate it, and then install it, for example:

```console
$ pip install email-validator
```

or with:

```console
$ pip install "pydantic[email]"
```

///

And we are using this model to declare our input and the same model to declare our output:

{* ../../docs_src/response_model/tutorial002_py310.py hl[16] *}

Now, whenever a browser is creating a user with a password, the API will return the same password in the response.

In this case, it might not be a problem, because it's the same user sending the password.

But if we use the same model for another *path operation*, we could be sending our user's passwords to every client.

/// danger

Never store the plain password of a user or send it in a response like this, unless you know all the caveats and you know what you are doing.

///

## Add an output model

We can instead create an input model with the plaintext password and an output model without it:

{* ../../docs_src/response_model/tutorial003_py310.py hl[9,11,16] *}

Here, even though our *path operation function* is returning the same input user that contains the password:

{* ../../docs_src/response_model/tutorial003_py310.py hl[24] *}

...we declared the `response_model` to be our model `UserOut`, that doesn't include the password:

{* ../../docs_src/response_model/tutorial003_py310.py hl[22] *}

So, **FastAPI** will take care of filtering out all the data that is not declared in the output model (using Pydantic).

### `response_model` or Return Type

In this case, because the two models are different, if we annotated the function return type as `UserOut`, the editor and tools would complain that we are returning an invalid type, as those are different classes.

That's why in this example we have to declare it in the `response_model` parameter.

...but continue reading below to see how to overcome that.

## Return Type and Data Filtering

Let's continue from the previous example. We wanted to **annotate the function with one type**, but we wanted to be able to return from the function something that actually includes **more data**.

We want FastAPI to keep **filtering** the data using the response model. So that even though the function returns more data, the response will only include the fields declared in the response model.

In the previous example, because the classes were different, we had to use the `response_model` parameter. But that also means that we don't get the support from the editor and tools checking the function return type.

But in most of the cases where we need to do something like this, we want the model just to **filter/remove** some of the data as in this example.

And in those cases, we can use classes and inheritance to take advantage of function **type annotations** to get better support in the editor and tools, and still get the FastAPI **data filtering**.

{* ../../docs_src/response_model/tutorial003_01_py310.py hl[7:10,13:14,18] *}

With this, we get tooling support, from editors and mypy as this code is correct in terms of types, but we also get the data filtering from FastAPI.

How does this work? Let's check that out. ðŸ¤“

### Type Annotations and Tooling

First let's see how editors, mypy and other tools would see this.

`BaseUser` has the base fields. Then `UserIn` inherits from `BaseUser` and adds the `password` field, so, it will include all the fields from both models.

We annotate the function return type as `BaseUser`, but we are actually returning a `UserIn` instance.

The editor, mypy, and other tools won't complain about this because, in typing terms, `UserIn` is a subclass of `BaseUser`, which means it's a *valid* type when what is expected is anything that is a `BaseUser`.

### FastAPI Data Filtering

Now, for FastAPI, it will see the return type and make sure that what you return includes **only** the fields that are declared in the type.

FastAPI does several things internally with Pydantic to make sure that those same rules of class inheritance are not used for the returned data filtering, otherwise you could end up returning much more data than what you expected.

This way, you can get the best of both worlds: type annotations with **tooling support** and **data filtering**.

## See it in the docs

When you see the automatic docs, you can check that the input model and output model will both have their own JSON Schema:

<img src="/img/tutorial/response-model/image01.png">

And both models will be used for the interactive API documentation:

<img src="/img/tutorial/response-model/image02.png">

## Other Return Type Annotations

There might be cases where you return something that is not a valid Pydantic field and you annotate it in the function, only to get the support provided by tooling (the editor, mypy, etc).

### Return a Response Directly

The most common case would be [returning a Response directly as explained later in the advanced docs](../advanced/response-directly.md){.internal-link target=_blank}.

{* ../../docs_src/response_model/tutorial003_02.py hl[8,10:11] *}

This simple case is handled automatically by FastAPI because the return type annotation is the class (or a subclass of) `Response`.

And tools will also be happy because both `RedirectResponse` and `JSONResponse` are subclasses of `Response`, so the type annotation is correct.

### Annotate a Response Subclass

You can also use a subclass of `Response` in the type annotation:

{* ../../docs_src/response_model/tutorial003_03.py hl[8:9] *}

This will also work because `RedirectResponse` is a subclass of `Response`, and FastAPI will automatically handle this simple case.

### Invalid Return Type Annotations

But when you return some other arbitrary object that is not a valid Pydantic type (e.g. a database object) and you annotate it like that in the function, FastAPI will try to create a Pydantic response model from that type annotation, and will fail.

The same would happen if you had something like a <abbr title='A union between multiple types means "any of these types".'>union</abbr> between different types where one or more of them are not valid Pydantic types, for example this would fail ðŸ’¥:

{* ../../docs_src/response_model/tutorial003_04_py310.py hl[8] *}

...this fails because the type annotation is not a Pydantic type and is not just a single `Response` class or subclass, it's a union (any of the two) between a `Response` and a `dict`.

### Disable Response Model

Continuing from the example above, you might not want to have the default data validation, documentation, filtering, etc. that is performed by FastAPI.

But you might want to still keep the return type annotation in the function to get the support from tools like editors and type checkers (e.g. mypy).

In this case, you can disable the response model generation by setting `response_model=None`:

{* ../../docs_src/response_model/tutorial003_05_py310.py hl[7] *}

This will make FastAPI skip the response model generation and that way you can have any return type annotations you need without it affecting your FastAPI application. ðŸ¤“

## Response Model encoding parameters

Your response model could have default values, like:

{* ../../docs_src/response_model/tutorial004_py310.py hl[9,11:12] *}

* `description: Union[str, None] = None` (or `str | None = None` in Python 3.10) has a default of `None`.
* `tax: float = 10.5` has a default of `10.5`.
* `tags: List[str] = []` has a default of an empty list: `[]`.

but you might want to omit them from the result if they were not actually stored.

For example, if you have models with many optional attributes in a NoSQL database, but you don't want to send very long JSON responses full of default values.

### Use the `response_model_exclude_unset` parameter

You can set the *path operation decorator* parameter `response_model_exclude_unset=True`:

{* ../../docs_src/response_model/tutorial004_py310.py hl[22] *}

and those default values won't be included in the response, only the values actually set.

So, if you send a request to that *path operation* for the item with ID `foo`, the response (not including default values) will be:

```JSON
{
    "name": "Foo",
    "price": 50.2
}
```

/// info

In Pydantic v1 the method was called `.dict()`, it was deprecated (but still supported) in Pydantic v2, and renamed to `.model_dump()`.

The examples here use `.dict()` for compatibility with Pydantic v1, but you should use `.model_dump()` instead if you can use Pydantic v2.

///

/// info

FastAPI uses Pydantic model's `.dict()` with <a href="https://docs.pydantic.dev/1.10/usage/exporting_models/#modeldict" class="external-link" target="_blank">its `exclude_unset` parameter</a> to achieve this.

///

/// info

You can also use:

* `response_model_exclude_defaults=True`
* `response_model_exclude_none=True`

as described in <a href="https://docs.pydantic.dev/1.10/usage/exporting_models/#modeldict" class="external-link" target="_blank">the Pydantic docs</a> for `exclude_defaults` and `exclude_none`.

///

#### Data with values for fields with defaults

But if your data has values for the model's fields with default values, like the item with ID `bar`:

```Python hl_lines="3  5"
{
    "name": "Bar",
    "description": "The bartenders",
    "price": 62,
    "tax": 20.2
}
```

they will be included in the response.

#### Data with the same values as the defaults

If the data has the same values as the default ones, like the item with ID `baz`:

```Python hl_lines="3  5-6"
{
    "name": "Baz",
    "description": None,
    "price": 50.2,
    "tax": 10.5,
    "tags": []
}
```

FastAPI is smart enough (actually, Pydantic is smart enough) to realize that, even though `description`, `tax`, and `tags` have the same values as the defaults, they were set explicitly (instead of taken from the defaults).

So, they will be included in the JSON response.

/// tip

Notice that the default values can be anything, not only `None`.

They can be a list (`[]`), a `float` of `10.5`, etc.

///

### `response_model_include` and `response_model_exclude`

You can also use the *path operation decorator* parameters `response_model_include` and `response_model_exclude`.

They take a `set` of `str` with the name of the attributes to include (omitting the rest) or to exclude (including the rest).

This can be used as a quick shortcut if you have only one Pydantic model and want to remove some data from the output.

/// tip

But it is still recommended to use the ideas above, using multiple classes, instead of these parameters.

This is because the JSON Schema generated in your app's OpenAPI (and the docs) will still be the one for the complete model, even if you use `response_model_include` or `response_model_exclude` to omit some attributes.

This also applies to `response_model_by_alias` that works similarly.

///

{* ../../docs_src/response_model/tutorial005_py310.py hl[29,35] *}

/// tip

The syntax `{"name", "description"}` creates a `set` with those two values.

It is equivalent to `set(["name", "description"])`.

///

#### Using `list`s instead of `set`s

If you forget to use a `set` and use a `list` or `tuple` instead, FastAPI will still convert it to a `set` and it will work correctly:

{* ../../docs_src/response_model/tutorial006_py310.py hl[29,35] *}

## Recap

Use the *path operation decorator's* parameter `response_model` to define response models and especially to ensure private data is filtered out.

Use `response_model_exclude_unset` to return only the values explicitly set.


================================================
File: /docs/en/docs/tutorial/response-status-code.md
================================================
# Response Status Code

The same way you can specify a response model, you can also declare the HTTP status code used for the response with the parameter `status_code` in any of the *path operations*:

* `@app.get()`
* `@app.post()`
* `@app.put()`
* `@app.delete()`
* etc.

{* ../../docs_src/response_status_code/tutorial001.py hl[6] *}

/// note

Notice that `status_code` is a parameter of the "decorator" method (`get`, `post`, etc). Not of your *path operation function*, like all the parameters and body.

///

The `status_code` parameter receives a number with the HTTP status code.

/// info

`status_code` can alternatively also receive an `IntEnum`, such as Python's <a href="https://docs.python.org/3/library/http.html#http.HTTPStatus" class="external-link" target="_blank">`http.HTTPStatus`</a>.

///

It will:

* Return that status code in the response.
* Document it as such in the OpenAPI schema (and so, in the user interfaces):

<img src="/img/tutorial/response-status-code/image01.png">

/// note

Some response codes (see the next section) indicate that the response does not have a body.

FastAPI knows this, and will produce OpenAPI docs that state there is no response body.

///

## About HTTP status codes

/// note

If you already know what HTTP status codes are, skip to the next section.

///

In HTTP, you send a numeric status code of 3 digits as part of the response.

These status codes have a name associated to recognize them, but the important part is the number.

In short:

* `100` and above are for "Information". You rarely use them directly.  Responses with these status codes cannot have a body.
* **`200`** and above are for "Successful" responses. These are the ones you would use the most.
    * `200` is the default status code, which means everything was "OK".
    * Another example would be `201`, "Created". It is commonly used after creating a new record in the database.
    * A special case is `204`, "No Content".  This response is used when there is no content to return to the client, and so the response must not have a body.
* **`300`** and above are for "Redirection".  Responses with these status codes may or may not have a body, except for `304`, "Not Modified", which must not have one.
* **`400`** and above are for "Client error" responses. These are the second type you would probably use the most.
    * An example is `404`, for a "Not Found" response.
    * For generic errors from the client, you can just use `400`.
* `500` and above are for server errors. You almost never use them directly. When something goes wrong at some part in your application code, or server, it will automatically return one of these status codes.

/// tip

To know more about each status code and which code is for what, check the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" class="external-link" target="_blank"><abbr title="Mozilla Developer Network">MDN</abbr> documentation about HTTP status codes</a>.

///

## Shortcut to remember the names

Let's see the previous example again:

{* ../../docs_src/response_status_code/tutorial001.py hl[6] *}

`201` is the status code for "Created".

But you don't have to memorize what each of these codes mean.

You can use the convenience variables from `fastapi.status`.

{* ../../docs_src/response_status_code/tutorial002.py hl[1,6] *}

They are just a convenience, they hold the same number, but that way you can use the editor's autocomplete to find them:

<img src="/img/tutorial/response-status-code/image02.png">

/// note | Technical Details

You could also use `from starlette import status`.

**FastAPI** provides the same `starlette.status` as `fastapi.status` just as a convenience for you, the developer. But it comes directly from Starlette.

///

## Changing the default

Later, in the [Advanced User Guide](../advanced/response-change-status-code.md){.internal-link target=_blank}, you will see how to return a different status code than the default you are declaring here.


================================================
File: /docs/en/docs/tutorial/schema-extra-example.md
================================================
# Declare Request Example Data

You can declare examples of the data your app can receive.

Here are several ways to do it.

## Extra JSON Schema data in Pydantic models

You can declare `examples` for a Pydantic model that will be added to the generated JSON Schema.

//// tab | Pydantic v2

{* ../../docs_src/schema_extra_example/tutorial001_py310.py hl[13:24] *}

////

//// tab | Pydantic v1

{* ../../docs_src/schema_extra_example/tutorial001_pv1_py310.py hl[13:23] *}

////

That extra info will be added as-is to the output **JSON Schema** for that model, and it will be used in the API docs.

//// tab | Pydantic v2

In Pydantic version 2, you would use the attribute `model_config`, that takes a `dict` as described in <a href="https://docs.pydantic.dev/latest/api/config/" class="external-link" target="_blank">Pydantic's docs: Configuration</a>.

You can set `"json_schema_extra"` with a `dict` containing any additional data you would like to show up in the generated JSON Schema, including `examples`.

////

//// tab | Pydantic v1

In Pydantic version 1, you would use an internal class `Config` and `schema_extra`, as described in <a href="https://docs.pydantic.dev/1.10/usage/schema/#schema-customization" class="external-link" target="_blank">Pydantic's docs: Schema customization</a>.

You can set `schema_extra` with a `dict` containing any additional data you would like to show up in the generated JSON Schema, including `examples`.

////

/// tip

You could use the same technique to extend the JSON Schema and add your own custom extra info.

For example you could use it to add metadata for a frontend user interface, etc.

///

/// info

OpenAPI 3.1.0 (used since FastAPI 0.99.0) added support for `examples`, which is part of the **JSON Schema** standard.

Before that, it only supported the keyword `example` with a single example. That is still supported by OpenAPI 3.1.0, but is deprecated and is not part of the JSON Schema standard. So you are encouraged to migrate `example` to `examples`. ðŸ¤“

You can read more at the end of this page.

///

## `Field` additional arguments

When using `Field()` with Pydantic models, you can also declare additional `examples`:

{* ../../docs_src/schema_extra_example/tutorial002_py310.py hl[2,8:11] *}

## `examples` in JSON Schema - OpenAPI

When using any of:

* `Path()`
* `Query()`
* `Header()`
* `Cookie()`
* `Body()`
* `Form()`
* `File()`

you can also declare a group of `examples` with additional information that will be added to their **JSON Schemas** inside of **OpenAPI**.

### `Body` with `examples`

Here we pass `examples` containing one example of the data expected in `Body()`:

{* ../../docs_src/schema_extra_example/tutorial003_an_py310.py hl[22:29] *}

### Example in the docs UI

With any of the methods above it would look like this in the `/docs`:

<img src="/img/tutorial/body-fields/image01.png">

### `Body` with multiple `examples`

You can of course also pass multiple `examples`:

{* ../../docs_src/schema_extra_example/tutorial004_an_py310.py hl[23:38] *}

When you do this, the examples will be part of the internal **JSON Schema** for that body data.

Nevertheless, at the <abbr title="2023-08-26">time of writing this</abbr>, Swagger UI, the tool in charge of showing the docs UI, doesn't support showing multiple examples for the data in **JSON Schema**. But read below for a workaround.

### OpenAPI-specific `examples`

Since before **JSON Schema** supported `examples` OpenAPI had support for a different field also called `examples`.

This **OpenAPI-specific** `examples` goes in another section in the OpenAPI specification. It goes in the **details for each *path operation***, not inside each JSON Schema.

And Swagger UI has supported this particular `examples` field for a while. So, you can use it to **show** different **examples in the docs UI**.

The shape of this OpenAPI-specific field `examples` is a `dict` with **multiple examples** (instead of a `list`), each with extra information that will be added to **OpenAPI** too.

This doesn't go inside of each JSON Schema contained in OpenAPI, this goes outside, in the *path operation* directly.

### Using the `openapi_examples` Parameter

You can declare the OpenAPI-specific `examples` in FastAPI with the parameter `openapi_examples` for:

* `Path()`
* `Query()`
* `Header()`
* `Cookie()`
* `Body()`
* `Form()`
* `File()`

The keys of the `dict` identify each example, and each value is another `dict`.

Each specific example `dict` in the `examples` can contain:

* `summary`: Short description for the example.
* `description`: A long description that can contain Markdown text.
* `value`: This is the actual example shown, e.g. a `dict`.
* `externalValue`: alternative to `value`, a URL pointing to the example. Although this might not be supported by as many tools as `value`.

You can use it like this:

{* ../../docs_src/schema_extra_example/tutorial005_an_py310.py hl[23:49] *}

### OpenAPI Examples in the Docs UI

With `openapi_examples` added to `Body()` the `/docs` would look like:

<img src="/img/tutorial/body-fields/image02.png">

## Technical Details

/// tip

If you are already using **FastAPI** version **0.99.0 or above**, you can probably **skip** these details.

They are more relevant for older versions, before OpenAPI 3.1.0 was available.

You can consider this a brief OpenAPI and JSON Schema **history lesson**. ðŸ¤“

///

/// warning

These are very technical details about the standards **JSON Schema** and **OpenAPI**.

If the ideas above already work for you, that might be enough, and you probably don't need these details, feel free to skip them.

///

Before OpenAPI 3.1.0, OpenAPI used an older and modified version of **JSON Schema**.

JSON Schema didn't have `examples`, so OpenAPI added its own `example` field to its own modified version.

OpenAPI also added `example` and `examples` fields to other parts of the specification:

* <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#parameter-object" class="external-link" target="_blank">`Parameter Object` (in the specification)</a> that was used by FastAPI's:
    * `Path()`
    * `Query()`
    * `Header()`
    * `Cookie()`
* <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#media-type-object" class="external-link" target="_blank">`Request Body Object`, in the field `content`, on the `Media Type Object` (in the specification)</a> that was used by FastAPI's:
    * `Body()`
    * `File()`
    * `Form()`

/// info

This old OpenAPI-specific `examples` parameter is now `openapi_examples` since FastAPI `0.103.0`.

///

### JSON Schema's `examples` field

But then JSON Schema added an <a href="https://json-schema.org/draft/2019-09/json-schema-validation.html#rfc.section.9.5" class="external-link" target="_blank">`examples`</a> field to a new version of the specification.

And then the new OpenAPI 3.1.0 was based on the latest version (JSON Schema 2020-12) that included this new field `examples`.

And now this new `examples` field takes precedence over the old single (and custom) `example` field, that is now deprecated.

This new `examples` field in JSON Schema is **just a `list`** of examples, not a dict with extra metadata as in the other places in OpenAPI (described above).

/// info

Even after OpenAPI 3.1.0 was released with this new simpler integration with JSON Schema, for a while, Swagger UI, the tool that provides the automatic docs, didn't support OpenAPI 3.1.0 (it does since version 5.0.0 ðŸŽ‰).

Because of that, versions of FastAPI previous to 0.99.0 still used versions of OpenAPI lower than 3.1.0.

///

### Pydantic and FastAPI `examples`

When you add `examples` inside a Pydantic model, using `schema_extra` or `Field(examples=["something"])` that example is added to the **JSON Schema** for that Pydantic model.

And that **JSON Schema** of the Pydantic model is included in the **OpenAPI** of your API, and then it's used in the docs UI.

In versions of FastAPI before 0.99.0 (0.99.0 and above use the newer OpenAPI 3.1.0) when you used `example` or `examples` with any of the other utilities (`Query()`, `Body()`, etc.) those examples were not added to the JSON Schema that describes that data (not even to OpenAPI's own version of JSON Schema), they were added directly to the *path operation* declaration in OpenAPI (outside the parts of OpenAPI that use JSON Schema).

But now that FastAPI 0.99.0 and above uses OpenAPI 3.1.0, that uses JSON Schema 2020-12, and Swagger UI 5.0.0 and above, everything is more consistent and the examples are included in JSON Schema.

### Swagger UI and OpenAPI-specific `examples`

Now, as Swagger UI didn't support multiple JSON Schema examples (as of 2023-08-26), users didn't have a way to show multiple examples in the docs.

To solve that, FastAPI `0.103.0` **added support** for declaring the same old **OpenAPI-specific** `examples` field with the new parameter `openapi_examples`. ðŸ¤“

### Summary

I used to say I didn't like history that much... and look at me now giving "tech history" lessons. ðŸ˜…

In short, **upgrade to FastAPI 0.99.0 or above**, and things are much **simpler, consistent, and intuitive**, and you don't have to know all these historic details. ðŸ˜Ž


================================================
File: /docs/en/docs/tutorial/sql-databases.md
================================================
# SQL (Relational) Databases

**FastAPI** doesn't require you to use a SQL (relational) database. But you can use **any database** that you want.

Here we'll see an example using <a href="https://sqlmodel.tiangolo.com/" class="external-link" target="_blank">SQLModel</a>.

**SQLModel** is built on top of <a href="https://www.sqlalchemy.org/" class="external-link" target="_blank">SQLAlchemy</a> and Pydantic. It was made by the same author of **FastAPI** to be the perfect match for FastAPI applications that need to use **SQL databases**.

/// tip

You could use any other SQL or NoSQL database library you want (in some cases called <abbr title="Object Relational Mapper, a fancy term for a library where some classes represent SQL tables and instances represent rows in those tables">"ORMs"</abbr>), FastAPI doesn't force you to use anything. ðŸ˜Ž

///

As SQLModel is based on SQLAlchemy, you can easily use **any database supported** by SQLAlchemy (which makes them also supported by SQLModel), like:

* PostgreSQL
* MySQL
* SQLite
* Oracle
* Microsoft SQL Server, etc.

In this example, we'll use **SQLite**, because it uses a single file and Python has integrated support. So, you can copy this example and run it as is.

Later, for your production application, you might want to use a database server like **PostgreSQL**.

/// tip

There is an official project generator with **FastAPI** and **PostgreSQL** including a frontend and more tools: <a href="https://github.com/fastapi/full-stack-fastapi-template" class="external-link" target="_blank">https://github.com/fastapi/full-stack-fastapi-template</a>

///

This is a very simple and short tutorial, if you want to learn about databases in general, about SQL, or more advanced features, go to the <a href="https://sqlmodel.tiangolo.com/" class="external-link" target="_blank">SQLModel docs</a>.

## Install `SQLModel`

First, make sure you create your [virtual environment](../virtual-environments.md){.internal-link target=_blank}, activate it, and then install `sqlmodel`:

<div class="termy">

```console
$ pip install sqlmodel
---> 100%
```

</div>

## Create the App with a Single Model

We'll create the simplest first version of the app with a single **SQLModel** model first.

Later we'll improve it increasing security and versatility with **multiple models** below. ðŸ¤“

### Create Models

Import `SQLModel` and create a database model:

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[1:11] hl[7:11] *}

The `Hero` class is very similar to a Pydantic model (in fact, underneath, it actually *is a Pydantic model*).

There are a few differences:

* `table=True` tells SQLModel that this is a *table model*, it should represent a **table** in the SQL database, it's not just a *data model* (as would be any other regular Pydantic class).

* `Field(primary_key=True)` tells SQLModel that the `id` is the **primary key** in the SQL database (you can learn more about SQL primary keys in the SQLModel docs).

    By having the type as `int | None`, SQLModel will know that this column should be an `INTEGER` in the SQL database and that it should be `NULLABLE`.

* `Field(index=True)` tells SQLModel that it should create a **SQL index** for this column, that would allow faster lookups in the database when reading data filtered by this column.

    SQLModel will know that something declared as `str` will be a SQL column of type `TEXT` (or `VARCHAR`, depending on the database).

### Create an Engine

A SQLModel `engine` (underneath it's actually a SQLAlchemy `engine`) is what **holds the connections** to the database.

You would have **one single `engine` object** for all your code to connect to the same database.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[14:18] hl[14:15,17:18] *}

Using `check_same_thread=False` allows FastAPI to use the same SQLite database in different threads. This is necessary as **one single request** could use **more than one thread** (for example in dependencies).

Don't worry, with the way the code is structured, we'll make sure we use **a single SQLModel *session* per request** later, this is actually what the `check_same_thread` is trying to achieve.

### Create the Tables

We then add a function that uses `SQLModel.metadata.create_all(engine)` to **create the tables** for all the *table models*.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[21:22] hl[21:22] *}

### Create a Session Dependency

A **`Session`** is what stores the **objects in memory** and keeps track of any changes needed in the data, then it **uses the `engine`** to communicate with the database.

We will create a FastAPI **dependency** with `yield` that will provide a new `Session` for each request. This is what ensures that we use a single session per request. ðŸ¤“

Then we create an `Annotated` dependency `SessionDep` to simplify the rest of the code that will use this dependency.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[25:30]  hl[25:27,30] *}

### Create Database Tables on Startup

We will create the database tables when the application starts.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[32:37] hl[35:37] *}

Here we create the tables on an application startup event.

For production you would probably use a migration script that runs before you start your app. ðŸ¤“

/// tip

SQLModel will have migration utilities wrapping Alembic, but for now, you can use <a href="https://alembic.sqlalchemy.org/en/latest/" class="external-link" target="_blank">Alembic</a> directly.

///

### Create a Hero

Because each SQLModel model is also a Pydantic model, you can use it in the same **type annotations** that you could use Pydantic models.

For example, if you declare a parameter of type `Hero`, it will be read from the **JSON body**.

The same way, you can declare it as the function's **return type**, and then the shape of the data will show up in the automatic API docs UI.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[40:45] hl[40:45] *}

Here we use the `SessionDep` dependency (a `Session`) to add the new `Hero` to the `Session` instance, commit the changes to the database, refresh the data in the `hero`, and then return it.

### Read Heroes

We can **read** `Hero`s from the database using a `select()`. We can include a `limit` and `offset` to paginate the results.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[48:55] hl[51:52,54] *}

### Read One Hero

We can **read** a single `Hero`.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[58:63] hl[60] *}

### Delete a Hero

We can also **delete** a `Hero`.

{* ../../docs_src/sql_databases/tutorial001_an_py310.py ln[66:73] hl[71] *}

### Run the App

You can run the app:

<div class="termy">

```console
$ fastapi dev main.py

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

Then go to the `/docs` UI, you will see that **FastAPI** is using these **models** to **document** the API, and it will use them to **serialize** and **validate** the data too.

<div class="screenshot">
<img src="/img/tutorial/sql-databases/image01.png">
</div>

## Update the App with Multiple Models

Now let's **refactor** this app a bit to increase **security** and **versatility**.

If you check the previous app, in the UI you can see that, up to now, it lets the client decide the `id` of the `Hero` to create. ðŸ˜±

We shouldn't let that happen, they could overwrite an `id` we already have assigned in the DB. Deciding the `id` should be done by the **backend** or the **database**, **not by the client**.

Additionally, we create a `secret_name` for the hero, but so far, we are returning it everywhere, that's not very **secret**... ðŸ˜…

We'll fix these things by adding a few **extra models**. Here's where SQLModel will shine. âœ¨

### Create Multiple Models

In **SQLModel**, any model class that has `table=True` is a **table model**.

And any model class that doesn't have `table=True` is a **data model**, these ones are actually just Pydantic models (with a couple of small extra features). ðŸ¤“

With SQLModel, we can use **inheritance** to **avoid duplicating** all the fields in all the cases.

#### `HeroBase` - the base class

Let's start with a `HeroBase` model that has all the **fields that are shared** by all the models:

* `name`
* `age`

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:9] hl[7:9] *}

#### `Hero` - the *table model*

Then let's create `Hero`, the actual *table model*, with the **extra fields** that are not always in the other models:

* `id`
* `secret_name`

Because `Hero` inherits form `HeroBase`, it **also** has the **fields** declared in `HeroBase`, so all the fields for `Hero` are:

* `id`
* `name`
* `age`
* `secret_name`

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:14] hl[12:14] *}

#### `HeroPublic` - the public *data model*

Next, we create a `HeroPublic` model, this is the one that will be **returned** to the clients of the API.

It has the same fields as `HeroBase`, so it won't include `secret_name`.

Finally, the identity of our heroes is protected! ðŸ¥·

It also re-declares `id: int`. By doing this, we are making a **contract** with the API clients, so that they can always expect the `id` to be there and to be an `int` (it will never be `None`).

/// tip

Having the return model ensure that a value is always available and always `int` (not `None`) is very useful for the API clients, they can write much simpler code having this certainty.

Also, **automatically generated clients** will have simpler interfaces, so that the developers communicating with your API can have a much better time working with your API. ðŸ˜Ž

///

All the fields in `HeroPublic` are the same as in `HeroBase`, with `id` declared as `int` (not `None`):

* `id`
* `name`
* `age`

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:18] hl[17:18] *}

#### `HeroCreate` - the *data model* to create a hero

Now we create a `HeroCreate` model, this is the one that will **validate** the data from the clients.

It has the same fields as `HeroBase`, and it also has `secret_name`.

Now, when the clients **create a new hero**, they will send the `secret_name`, it will be stored in the database, but those secret names won't be returned in the API to the clients.

/// tip

This is how you would handle **passwords**. Receive them, but don't return them in the API.

You would also **hash** the values of the passwords before storing them, **never store them in plain text**.

///

The fields of `HeroCreate` are:

* `name`
* `age`
* `secret_name`

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:22] hl[21:22] *}

#### `HeroUpdate` - the *data model* to update a hero

We didn't have a way to **update a hero** in the previous version of the app, but now with **multiple models**, we can do it. ðŸŽ‰

The `HeroUpdate` *data model* is somewhat special, it has **all the same fields** that would be needed to create a new hero, but all the fields are **optional** (they all have a default value). This way, when you update a hero, you can send just the fields that you want to update.

Because all the **fields actually change** (the type now includes `None` and they now have a default value of `None`), we need to **re-declare** them.

We don't really need to inherit from `HeroBase` because we are re-declaring all the fields. I'll leave it inheriting just for consistency, but this is not necessary. It's more a matter of personal taste. ðŸ¤·

The fields of `HeroUpdate` are:

* `name`
* `age`
* `secret_name`

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[7:28] hl[25:28] *}

### Create with `HeroCreate` and return a `HeroPublic`

Now that we have **multiple models**, we can update the parts of the app that use them.

We receive in the request a `HeroCreate` *data model*, and from it, we create a `Hero` *table model*.

This new *table model* `Hero` will have the fields sent by the client, and will also have an `id` generated by the database.

Then we return the same *table model* `Hero` as is from the function. But as we declare the `response_model` with the `HeroPublic` *data model*, **FastAPI** will use `HeroPublic` to validate and serialize the data.

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[56:62] hl[56:58] *}

/// tip

Now we use `response_model=HeroPublic` instead of the **return type annotation** `-> HeroPublic` because the value that we are returning is actually *not* a `HeroPublic`.

If we had declared `-> HeroPublic`, your editor and linter would complain (rightfully so) that you are returning a `Hero` instead of a `HeroPublic`.

By declaring it in `response_model` we are telling **FastAPI** to do its thing, without interfering with the type annotations and the help from your editor and other tools.

///

### Read Heroes with `HeroPublic`

We can do the same as before to **read** `Hero`s, again, we use `response_model=list[HeroPublic]` to ensure that the data is validated and serialized correctly.

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[65:72] hl[65] *}

### Read One Hero with `HeroPublic`

We can **read** a single hero:

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[75:80] hl[77] *}

### Update a Hero with `HeroUpdate`

We can **update a hero**. For this we use an HTTP `PATCH` operation.

And in the code, we get a `dict` with all the data sent by the client, **only the data sent by the client**, excluding any values that would be there just for being the default values. To do it we use `exclude_unset=True`. This is the main trick. ðŸª„

Then we use `hero_db.sqlmodel_update(hero_data)` to update the `hero_db` with the data from `hero_data`.

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[83:93] hl[83:84,88:89] *}

### Delete a Hero Again

**Deleting** a hero stays pretty much the same.

We won't satisfy the desire to refactor everything in this one. ðŸ˜…

{* ../../docs_src/sql_databases/tutorial002_an_py310.py ln[96:103] hl[101] *}

### Run the App Again

You can run the app again:

<div class="termy">

```console
$ fastapi dev main.py

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

If you go to the `/docs` API UI, you will see that it is now updated, and it won't expect to receive the `id` from the client when creating a hero, etc.

<div class="screenshot">
<img src="/img/tutorial/sql-databases/image02.png">
</div>

## Recap

You can use <a href="https://sqlmodel.tiangolo.com/" class="external-link" target="_blank">**SQLModel**</a> to interact with a SQL database and simplify the code with *data models*  and *table models*.

You can learn a lot more at the **SQLModel** docs, there's a longer mini <a href="https://sqlmodel.tiangolo.com/tutorial/fastapi/" class="external-link" target="_blank">tutorial on using SQLModel with **FastAPI**</a>. ðŸš€


================================================
File: /docs/en/docs/tutorial/static-files.md
================================================
# Static Files

You can serve static files automatically from a directory using `StaticFiles`.

## Use `StaticFiles`

* Import `StaticFiles`.
* "Mount" a `StaticFiles()` instance in a specific path.

{* ../../docs_src/static_files/tutorial001.py hl[2,6] *}

/// note | Technical Details

You could also use `from starlette.staticfiles import StaticFiles`.

**FastAPI** provides the same `starlette.staticfiles` as `fastapi.staticfiles` just as a convenience for you, the developer. But it actually comes directly from Starlette.

///

### What is "Mounting"

"Mounting" means adding a complete "independent" application in a specific path, that then takes care of handling all the sub-paths.

This is different from using an `APIRouter` as a mounted application is completely independent. The OpenAPI and docs from your main application won't include anything from the mounted application, etc.

You can read more about this in the [Advanced User Guide](../advanced/index.md){.internal-link target=_blank}.

## Details

The first `"/static"` refers to the sub-path this "sub-application" will be "mounted" on. So, any path that starts with `"/static"` will be handled by it.

The `directory="static"` refers to the name of the directory that contains your static files.

The `name="static"` gives it a name that can be used internally by **FastAPI**.

All these parameters can be different than "`static`", adjust them with the needs and specific details of your own application.

## More info

For more details and options check <a href="https://www.starlette.io/staticfiles/" class="external-link" target="_blank">Starlette's docs about Static Files</a>.


================================================
File: /docs/en/docs/tutorial/testing.md
================================================
# Testing

Thanks to <a href="https://www.starlette.io/testclient/" class="external-link" target="_blank">Starlette</a>, testing **FastAPI** applications is easy and enjoyable.

It is based on <a href="https://www.python-httpx.org" class="external-link" target="_blank">HTTPX</a>, which in turn is designed based on Requests, so it's very familiar and intuitive.

With it, you can use <a href="https://docs.pytest.org/" class="external-link" target="_blank">pytest</a> directly with **FastAPI**.

## Using `TestClient`

/// info

To use `TestClient`, first install <a href="https://www.python-httpx.org" class="external-link" target="_blank">`httpx`</a>.

Make sure you create a [virtual environment](../virtual-environments.md){.internal-link target=_blank}, activate it, and then install it, for example:

```console
$ pip install httpx
```

///

Import `TestClient`.

Create a `TestClient` by passing your **FastAPI** application to it.

Create functions with a name that starts with `test_` (this is standard `pytest` conventions).

Use the `TestClient` object the same way as you do with `httpx`.

Write simple `assert` statements with the standard Python expressions that you need to check (again, standard `pytest`).

{* ../../docs_src/app_testing/tutorial001.py hl[2,12,15:18] *}

/// tip

Notice that the testing functions are normal `def`, not `async def`.

And the calls to the client are also normal calls, not using `await`.

This allows you to use `pytest` directly without complications.

///

/// note | Technical Details

You could also use `from starlette.testclient import TestClient`.

**FastAPI** provides the same `starlette.testclient` as `fastapi.testclient` just as a convenience for you, the developer. But it comes directly from Starlette.

///

/// tip

If you want to call `async` functions in your tests apart from sending requests to your FastAPI application (e.g. asynchronous database functions), have a look at the [Async Tests](../advanced/async-tests.md){.internal-link target=_blank} in the advanced tutorial.

///

## Separating tests

In a real application, you probably would have your tests in a different file.

And your **FastAPI** application might also be composed of several files/modules, etc.

### **FastAPI** app file

Let's say you have a file structure as described in [Bigger Applications](bigger-applications.md){.internal-link target=_blank}:

```
.
â”œâ”€â”€ app
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â””â”€â”€ main.py
```

In the file `main.py` you have your **FastAPI** app:


{* ../../docs_src/app_testing/main.py *}

### Testing file

Then you could have a file `test_main.py` with your tests. It could live on the same Python package (the same directory with a `__init__.py` file):

``` hl_lines="5"
.
â”œâ”€â”€ app
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ main.py
â”‚Â Â  â””â”€â”€ test_main.py
```

Because this file is in the same package, you can use relative imports to import the object `app` from the `main` module (`main.py`):

{* ../../docs_src/app_testing/test_main.py hl[3] *}


...and have the code for the tests just like before.

## Testing: extended example

Now let's extend this example and add more details to see how to test different parts.

### Extended **FastAPI** app file

Let's continue with the same file structure as before:

```
.
â”œâ”€â”€ app
â”‚Â Â  â”œâ”€â”€ __init__.py
â”‚Â Â  â”œâ”€â”€ main.py
â”‚Â Â  â””â”€â”€ test_main.py
```

Let's say that now the file `main.py` with your **FastAPI** app has some other **path operations**.

It has a `GET` operation that could return an error.

It has a `POST` operation that could return several errors.

Both *path operations* require an `X-Token` header.

//// tab | Python 3.10+

```Python
{!> ../../docs_src/app_testing/app_b_an_py310/main.py!}
```

////

//// tab | Python 3.9+

```Python
{!> ../../docs_src/app_testing/app_b_an_py39/main.py!}
```

////

//// tab | Python 3.8+

```Python
{!> ../../docs_src/app_testing/app_b_an/main.py!}
```

////

//// tab | Python 3.10+ non-Annotated

/// tip

Prefer to use the `Annotated` version if possible.

///

```Python
{!> ../../docs_src/app_testing/app_b_py310/main.py!}
```

////

//// tab | Python 3.8+ non-Annotated

/// tip

Prefer to use the `Annotated` version if possible.

///

```Python
{!> ../../docs_src/app_testing/app_b/main.py!}
```

////

### Extended testing file

You could then update `test_main.py` with the extended tests:

{* ../../docs_src/app_testing/app_b/test_main.py *}


Whenever you need the client to pass information in the request and you don't know how to, you can search (Google) how to do it in `httpx`, or even how to do it with `requests`, as HTTPX's design is based on Requests' design.

Then you just do the same in your tests.

E.g.:

* To pass a *path* or *query* parameter, add it to the URL itself.
* To pass a JSON body, pass a Python object (e.g. a `dict`) to the parameter `json`.
* If you need to send *Form Data* instead of JSON, use the `data` parameter instead.
* To pass *headers*, use a `dict` in the `headers` parameter.
* For *cookies*, a `dict` in the `cookies` parameter.

For more information about how to pass data to the backend (using `httpx` or the `TestClient`) check the <a href="https://www.python-httpx.org" class="external-link" target="_blank">HTTPX documentation</a>.

/// info

Note that the `TestClient` receives data that can be converted to JSON, not Pydantic models.

If you have a Pydantic model in your test and you want to send its data to the application during testing, you can use the `jsonable_encoder` described in [JSON Compatible Encoder](encoder.md){.internal-link target=_blank}.

///

## Run it

After that, you just need to install `pytest`.

Make sure you create a [virtual environment](../virtual-environments.md){.internal-link target=_blank}, activate it, and then install it, for example:

<div class="termy">

```console
$ pip install pytest

---> 100%
```

</div>

It will detect the files and tests automatically, execute them, and report the results back to you.

Run the tests with:

<div class="termy">

```console
$ pytest

================ test session starts ================
platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1
rootdir: /home/user/code/superawesome-cli/app
plugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1
collected 6 items

---> 100%

test_main.py <span style="color: green; white-space: pre;">......                            [100%]</span>

<span style="color: green;">================= 1 passed in 0.03s =================</span>
```

</div>


================================================
File: /docs/en/docs/tutorial/dependencies/classes-as-dependencies.md
================================================
# Classes as Dependencies

Before diving deeper into the **Dependency Injection** system, let's upgrade the previous example.

## A `dict` from the previous example

In the previous example, we were returning a `dict` from our dependency ("dependable"):

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[9] *}

But then we get a `dict` in the parameter `commons` of the *path operation function*.

And we know that editors can't provide a lot of support (like completion) for `dict`s, because they can't know their keys and value types.

We can do better...

## What makes a dependency

Up to now you have seen dependencies declared as functions.

But that's not the only way to declare dependencies (although it would probably be the more common).

The key factor is that a dependency should be a "callable".

A "**callable**" in Python is anything that Python can "call" like a function.

So, if you have an object `something` (that might _not_ be a function) and you can "call" it (execute it) like:

```Python
something()
```

or

```Python
something(some_argument, some_keyword_argument="foo")
```

then it is a "callable".

## Classes as dependencies

You might notice that to create an instance of a Python class, you use that same syntax.

For example:

```Python
class Cat:
    def __init__(self, name: str):
        self.name = name


fluffy = Cat(name="Mr Fluffy")
```

In this case, `fluffy` is an instance of the class `Cat`.

And to create `fluffy`, you are "calling" `Cat`.

So, a Python class is also a **callable**.

Then, in **FastAPI**, you could use a Python class as a dependency.

What FastAPI actually checks is that it is a "callable" (function, class or anything else) and the parameters defined.

If you pass a "callable" as a dependency in **FastAPI**, it will analyze the parameters for that "callable", and process them in the same way as the parameters for a *path operation function*. Including sub-dependencies.

That also applies to callables with no parameters at all. The same as it would be for *path operation functions* with no parameters.

Then, we can change the dependency "dependable" `common_parameters` from above to the class `CommonQueryParams`:

{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[11:15] *}

Pay attention to the `__init__` method used to create the instance of the class:

{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[12] *}

...it has the same parameters as our previous `common_parameters`:

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[8] *}

Those parameters are what **FastAPI** will use to "solve" the dependency.

In both cases, it will have:

* An optional `q` query parameter that is a `str`.
* A `skip` query parameter that is an `int`, with a default of `0`.
* A `limit` query parameter that is an `int`, with a default of `100`.

In both cases the data will be converted, validated, documented on the OpenAPI schema, etc.

## Use it

Now you can declare your dependency using this class.

{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[19] *}

**FastAPI** calls the `CommonQueryParams` class. This creates an "instance" of that class and the instance will be passed as the parameter `commons` to your function.

## Type annotation vs `Depends`

Notice how we write `CommonQueryParams` twice in the above code:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
```

////

//// tab | Python 3.8+ non-Annotated

/// tip

Prefer to use the `Annotated` version if possible.

///

```Python
commons: CommonQueryParams = Depends(CommonQueryParams)
```

////

The last `CommonQueryParams`, in:

```Python
... Depends(CommonQueryParams)
```

...is what **FastAPI** will actually use to know what is the dependency.

It is from this one that FastAPI will extract the declared parameters and that is what FastAPI will actually call.

---

In this case, the first `CommonQueryParams`, in:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, ...
```

////

//// tab | Python 3.8+ non-Annotated

/// tip

Prefer to use the `Annotated` version if possible.

///

```Python
commons: CommonQueryParams ...
```

////

...doesn't have any special meaning for **FastAPI**. FastAPI won't use it for data conversion, validation, etc. (as it is using the `Depends(CommonQueryParams)` for that).

You could actually write just:

//// tab | Python 3.8+

```Python
commons: Annotated[Any, Depends(CommonQueryParams)]
```

////

//// tab | Python 3.8+ non-Annotated

/// tip

Prefer to use the `Annotated` version if possible.

///

```Python
commons = Depends(CommonQueryParams)
```

////

...as in:

{* ../../docs_src/dependencies/tutorial003_an_py310.py hl[19] *}

But declaring the type is encouraged as that way your editor will know what will be passed as the parameter `commons`, and then it can help you with code completion, type checks, etc:

<img src="/img/tutorial/dependencies/image02.png">

## Shortcut

But you see that we are having some code repetition here, writing `CommonQueryParams` twice:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
```

////

//// tab | Python 3.8+ non-Annotated

/// tip

Prefer to use the `Annotated` version if possible.

///

```Python
commons: CommonQueryParams = Depends(CommonQueryParams)
```

////

**FastAPI** provides a shortcut for these cases, in where the dependency is *specifically* a class that **FastAPI** will "call" to create an instance of the class itself.

For those specific cases, you can do the following:

Instead of writing:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
```

////

//// tab | Python 3.8+ non-Annotated

/// tip

Prefer to use the `Annotated` version if possible.

///

```Python
commons: CommonQueryParams = Depends(CommonQueryParams)
```

////

...you write:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, Depends()]
```

////

//// tab | Python 3.8 non-Annotated

/// tip

Prefer to use the `Annotated` version if possible.

///

```Python
commons: CommonQueryParams = Depends()
```

////

You declare the dependency as the type of the parameter, and you use `Depends()` without any parameter, instead of having to write the full class *again* inside of `Depends(CommonQueryParams)`.

The same example would then look like:

{* ../../docs_src/dependencies/tutorial004_an_py310.py hl[19] *}

...and **FastAPI** will know what to do.

/// tip

If that seems more confusing than helpful, disregard it, you don't *need* it.

It is just a shortcut. Because **FastAPI** cares about helping you minimize code repetition.

///


================================================
File: /docs/en/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
================================================
# Dependencies in path operation decorators

In some cases you don't really need the return value of a dependency inside your *path operation function*.

Or the dependency doesn't return a value.

But you still need it to be executed/solved.

For those cases, instead of declaring a *path operation function* parameter with `Depends`, you can add a `list` of `dependencies` to the *path operation decorator*.

## Add `dependencies` to the *path operation decorator*

The *path operation decorator* receives an optional argument `dependencies`.

It should be a `list` of `Depends()`:

{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[19] *}

These dependencies will be executed/solved the same way as normal dependencies. But their value (if they return any) won't be passed to your *path operation function*.

/// tip

Some editors check for unused function parameters, and show them as errors.

Using these `dependencies` in the *path operation decorator* you can make sure they are executed while avoiding editor/tooling errors.

It might also help avoid confusion for new developers that see an unused parameter in your code and could think it's unnecessary.

///

/// info

In this example we use invented custom headers `X-Key` and `X-Token`.

But in real cases, when implementing security, you would get more benefits from using the integrated [Security utilities (the next chapter)](../security/index.md){.internal-link target=_blank}.

///

## Dependencies errors and return values

You can use the same dependency *functions* you use normally.

### Dependency requirements

They can declare request requirements (like headers) or other sub-dependencies:

{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[8,13] *}

### Raise exceptions

These dependencies can `raise` exceptions, the same as normal dependencies:

{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[10,15] *}

### Return values

And they can return values or not, the values won't be used.

So, you can reuse a normal dependency (that returns a value) you already use somewhere else, and even though the value won't be used, the dependency will be executed:

{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[11,16] *}

## Dependencies for a group of *path operations*

Later, when reading about how to structure bigger applications ([Bigger Applications - Multiple Files](../../tutorial/bigger-applications.md){.internal-link target=_blank}), possibly with multiple files, you will learn how to declare a single `dependencies` parameter for a group of *path operations*.

## Global Dependencies

Next we will see how to add dependencies to the whole `FastAPI` application, so that they apply to each *path operation*.


================================================
File: /docs/en/docs/tutorial/dependencies/dependencies-with-yield.md
================================================
# Dependencies with yield

FastAPI supports dependencies that do some <abbr title='sometimes also called "exit code", "cleanup code", "teardown code", "closing code", "context manager exit code", etc.'>extra steps after finishing</abbr>.

To do this, use `yield` instead of `return`, and write the extra steps (code) after.

/// tip

Make sure to use `yield` one single time per dependency.

///

/// note | Technical Details

Any function that is valid to use with:

* <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" class="external-link" target="_blank">`@contextlib.contextmanager`</a> or
* <a href="https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager" class="external-link" target="_blank">`@contextlib.asynccontextmanager`</a>

would be valid to use as a **FastAPI** dependency.

In fact, FastAPI uses those two decorators internally.

///

## A database dependency with `yield`

For example, you could use this to create a database session and close it after finishing.

Only the code prior to and including the `yield` statement is executed before creating a response:

{* ../../docs_src/dependencies/tutorial007.py hl[2:4] *}

The yielded value is what is injected into *path operations* and other dependencies:

{* ../../docs_src/dependencies/tutorial007.py hl[4] *}

The code following the `yield` statement is executed after creating the response but before sending it:

{* ../../docs_src/dependencies/tutorial007.py hl[5:6] *}

/// tip

You can use `async` or regular functions.

**FastAPI** will do the right thing with each, the same as with normal dependencies.

///

## A dependency with `yield` and `try`

If you use a `try` block in a dependency with `yield`, you'll receive any exception that was thrown when using the dependency.

For example, if some code at some point in the middle, in another dependency or in a *path operation*, made a database transaction "rollback" or create any other error, you will receive the exception in your dependency.

So, you can look for that specific exception inside the dependency with `except SomeException`.

In the same way, you can use `finally` to make sure the exit steps are executed, no matter if there was an exception or not.

{* ../../docs_src/dependencies/tutorial007.py hl[3,5] *}

## Sub-dependencies with `yield`

You can have sub-dependencies and "trees" of sub-dependencies of any size and shape, and any or all of them can use `yield`.

**FastAPI** will make sure that the "exit code" in each dependency with `yield` is run in the correct order.

For example, `dependency_c` can have a dependency on `dependency_b`, and `dependency_b` on `dependency_a`:

{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[6,14,22] *}

And all of them can use `yield`.

In this case `dependency_c`, to execute its exit code, needs the value from `dependency_b` (here named `dep_b`) to still be available.

And, in turn, `dependency_b` needs the value from `dependency_a` (here named `dep_a`) to be available for its exit code.

{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[18:19,26:27] *}

The same way, you could have some dependencies with `yield` and some other dependencies with `return`, and have some of those depend on some of the others.

And you could have a single dependency that requires several other dependencies with `yield`, etc.

You can have any combinations of dependencies that you want.

**FastAPI** will make sure everything is run in the correct order.

/// note | Technical Details

This works thanks to Python's <a href="https://docs.python.org/3/library/contextlib.html" class="external-link" target="_blank">Context Managers</a>.

**FastAPI** uses them internally to achieve this.

///

## Dependencies with `yield` and `HTTPException`

You saw that you can use dependencies with `yield` and have `try` blocks that catch exceptions.

The same way, you could raise an `HTTPException` or similar in the exit code, after the `yield`.

/// tip

This is a somewhat advanced technique, and in most of the cases you won't really need it, as you can raise exceptions (including `HTTPException`) from inside of the rest of your application code, for example, in the *path operation function*.

But it's there for you if you need it. ðŸ¤“

///

{* ../../docs_src/dependencies/tutorial008b_an_py39.py hl[18:22,31] *}

An alternative you could use to catch exceptions (and possibly also raise another `HTTPException`) is to create a [Custom Exception Handler](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}.

## Dependencies with `yield` and `except`

If you catch an exception using `except` in a dependency with `yield` and you don't raise it again (or raise a new exception), FastAPI won't be able to notice there was an exception, the same way that would happen with regular Python:

{* ../../docs_src/dependencies/tutorial008c_an_py39.py hl[15:16] *}

In this case, the client will see an *HTTP 500 Internal Server Error* response as it should, given that we are not raising an `HTTPException` or similar, but the server will **not have any logs** or any other indication of what was the error. ðŸ˜±

### Always `raise` in Dependencies with `yield` and `except`

If you catch an exception in a dependency with `yield`, unless you are raising another `HTTPException` or similar, you should re-raise the original exception.

You can re-raise the same exception using `raise`:

{* ../../docs_src/dependencies/tutorial008d_an_py39.py hl[17] *}

Now the client will get the same *HTTP 500 Internal Server Error* response, but the server will have our custom `InternalError` in the logs. ðŸ˜Ž

## Execution of dependencies with `yield`

The sequence of execution is more or less like this diagram. Time flows from top to bottom. And each column is one of the parts interacting or executing code.

```mermaid
sequenceDiagram

participant client as Client
participant handler as Exception handler
participant dep as Dep with yield
participant operation as Path Operation
participant tasks as Background tasks

    Note over client,operation: Can raise exceptions, including HTTPException
    client ->> dep: Start request
    Note over dep: Run code up to yield
    opt raise Exception
        dep -->> handler: Raise Exception
        handler -->> client: HTTP error response
    end
    dep ->> operation: Run dependency, e.g. DB session
    opt raise
        operation -->> dep: Raise Exception (e.g. HTTPException)
        opt handle
            dep -->> dep: Can catch exception, raise a new HTTPException, raise other exception
        end
        handler -->> client: HTTP error response
    end

    operation ->> client: Return response to client
    Note over client,operation: Response is already sent, can't change it anymore
    opt Tasks
        operation -->> tasks: Send background tasks
    end
    opt Raise other exception
        tasks -->> tasks: Handle exceptions in the background task code
    end
```

/// info

Only **one response** will be sent to the client. It might be one of the error responses or it will be the response from the *path operation*.

After one of those responses is sent, no other response can be sent.

///

/// tip

This diagram shows `HTTPException`, but you could also raise any other exception that you catch in a dependency with `yield` or with a [Custom Exception Handler](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank}.

If you raise any exception, it will be passed to the dependencies with yield, including `HTTPException`. In most cases you will want to re-raise that same exception or a new one from the dependency with `yield` to make sure it's properly handled.

///

## Dependencies with `yield`, `HTTPException`, `except` and Background Tasks

/// warning

You most probably don't need these technical details, you can skip this section and continue below.

These details are useful mainly if you were using a version of FastAPI prior to 0.106.0 and used resources from dependencies with `yield` in background tasks.

///

### Dependencies with `yield` and `except`, Technical Details

Before FastAPI 0.110.0, if you used a dependency with `yield`, and then you captured an exception with `except` in that dependency, and you didn't raise the exception again, the exception would be automatically raised/forwarded to any exception handlers or the internal server error handler.

This was changed in version 0.110.0 to fix unhandled memory consumption from forwarded exceptions without a handler (internal server errors), and to make it consistent with the behavior of regular Python code.

### Background Tasks and Dependencies with `yield`, Technical Details

Before FastAPI 0.106.0, raising exceptions after `yield` was not possible, the exit code in dependencies with `yield` was executed *after* the response was sent, so [Exception Handlers](../handling-errors.md#install-custom-exception-handlers){.internal-link target=_blank} would have already run.

This was designed this way mainly to allow using the same objects "yielded" by dependencies inside of background tasks, because the exit code would be executed after the background tasks were finished.

Nevertheless, as this would mean waiting for the response to travel through the network while unnecessarily holding a resource in a dependency with yield (for example a database connection), this was changed in FastAPI 0.106.0.

/// tip

Additionally, a background task is normally an independent set of logic that should be handled separately, with its own resources (e.g. its own database connection).

So, this way you will probably have cleaner code.

///

If you used to rely on this behavior, now you should create the resources for background tasks inside the background task itself, and use internally only data that doesn't depend on the resources of dependencies with `yield`.

For example, instead of using the same database session, you would create a new database session inside of the background task, and you would obtain the objects from the database using this new session. And then instead of passing the object from the database as a parameter to the background task function, you would pass the ID of that object and then obtain the object again inside the background task function.

## Context Managers

### What are "Context Managers"

"Context Managers" are any of those Python objects that you can use in a `with` statement.

For example, <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files" class="external-link" target="_blank">you can use `with` to read a file</a>:

```Python
with open("./somefile.txt") as f:
    contents = f.read()
    print(contents)
```

Underneath, the `open("./somefile.txt")` creates an object that is called a "Context Manager".

When the `with` block finishes, it makes sure to close the file, even if there were exceptions.

When you create a dependency with `yield`, **FastAPI** will internally create a context manager for it, and combine it with some other related tools.

### Using context managers in dependencies with `yield`

/// warning

This is, more or less, an "advanced" idea.

If you are just starting with **FastAPI** you might want to skip it for now.

///

In Python, you can create Context Managers by <a href="https://docs.python.org/3/reference/datamodel.html#context-managers" class="external-link" target="_blank">creating a class with two methods: `__enter__()` and `__exit__()`</a>.

You can also use them inside of **FastAPI** dependencies with `yield` by using
`with` or `async with` statements inside of the dependency function:

{* ../../docs_src/dependencies/tutorial010.py hl[1:9,13] *}

/// tip

Another way to create a context manager is with:

* <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" class="external-link" target="_blank">`@contextlib.contextmanager`</a> or
* <a href="https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager" class="external-link" target="_blank">`@contextlib.asynccontextmanager`</a>

using them to decorate a function with a single `yield`.

That's what **FastAPI** uses internally for dependencies with `yield`.

But you don't have to use the decorators for FastAPI dependencies (and you shouldn't).

FastAPI will do it for you internally.

///


================================================
File: /docs/en/docs/tutorial/dependencies/global-dependencies.md
================================================
# Global Dependencies

For some types of applications you might want to add dependencies to the whole application.

Similar to the way you can [add `dependencies` to the *path operation decorators*](dependencies-in-path-operation-decorators.md){.internal-link target=_blank}, you can add them to the `FastAPI` application.

In that case, they will be applied to all the *path operations* in the application:

{* ../../docs_src/dependencies/tutorial012_an_py39.py hl[16] *}


And all the ideas in the section about [adding `dependencies` to the *path operation decorators*](dependencies-in-path-operation-decorators.md){.internal-link target=_blank} still apply, but in this case, to all of the *path operations* in the app.

## Dependencies for groups of *path operations*

Later, when reading about how to structure bigger applications ([Bigger Applications - Multiple Files](../../tutorial/bigger-applications.md){.internal-link target=_blank}), possibly with multiple files, you will learn how to declare a single `dependencies` parameter for a group of *path operations*.


================================================
File: /docs/en/docs/tutorial/dependencies/index.md
================================================
# Dependencies

**FastAPI** has a very powerful but intuitive **<abbr title="also known as components, resources, providers, services, injectables">Dependency Injection</abbr>** system.

It is designed to be very simple to use, and to make it very easy for any developer to integrate other components with **FastAPI**.

## What is "Dependency Injection"

**"Dependency Injection"** means, in programming, that there is a way for your code (in this case, your *path operation functions*) to declare things that it requires to work and use: "dependencies".

And then, that system (in this case **FastAPI**) will take care of doing whatever is needed to provide your code with those needed dependencies ("inject" the dependencies).

This is very useful when you need to:

* Have shared logic (the same code logic again and again).
* Share database connections.
* Enforce security, authentication, role requirements, etc.
* And many other things...

All these, while minimizing code repetition.

## First Steps

Let's see a very simple example. It will be so simple that it is not very useful, for now.

But this way we can focus on how the **Dependency Injection** system works.

### Create a dependency, or "dependable"

Let's first focus on the dependency.

It is just a function that can take all the same parameters that a *path operation function* can take:

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[8:9] *}

That's it.

**2 lines**.

And it has the same shape and structure that all your *path operation functions* have.

You can think of it as a *path operation function* without the "decorator" (without the `@app.get("/some-path")`).

And it can return anything you want.

In this case, this dependency expects:

* An optional query parameter `q` that is a `str`.
* An optional query parameter `skip` that is an `int`, and by default is `0`.
* An optional query parameter `limit` that is an `int`, and by default is `100`.

And then it just returns a `dict` containing those values.

/// info

FastAPI added support for `Annotated` (and started recommending it) in version 0.95.0.

If you have an older version, you would get errors when trying to use `Annotated`.

Make sure you [Upgrade the FastAPI version](../../deployment/versions.md#upgrading-the-fastapi-versions){.internal-link target=_blank} to at least 0.95.1 before using `Annotated`.

///

### Import `Depends`

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[3] *}

### Declare the dependency, in the "dependant"

The same way you use `Body`, `Query`, etc. with your *path operation function* parameters, use `Depends` with a new parameter:

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[13,18] *}

Although you use `Depends` in the parameters of your function the same way you use `Body`, `Query`, etc, `Depends` works a bit differently.

You only give `Depends` a single parameter.

This parameter must be something like a function.

You **don't call it** directly (don't add the parenthesis at the end), you just pass it as a parameter to `Depends()`.

And that function takes parameters in the same way that *path operation functions* do.

/// tip

You'll see what other "things", apart from functions, can be used as dependencies in the next chapter.

///

Whenever a new request arrives, **FastAPI** will take care of:

* Calling your dependency ("dependable") function with the correct parameters.
* Get the result from your function.
* Assign that result to the parameter in your *path operation function*.

```mermaid
graph TB

common_parameters(["common_parameters"])
read_items["/items/"]
read_users["/users/"]

common_parameters --> read_items
common_parameters --> read_users
```

This way you write shared code once and **FastAPI** takes care of calling it for your *path operations*.

/// check

Notice that you don't have to create a special class and pass it somewhere to **FastAPI** to "register" it or anything similar.

You just pass it to `Depends` and **FastAPI** knows how to do the rest.

///

## Share `Annotated` dependencies

In the examples above, you see that there's a tiny bit of **code duplication**.

When you need to use the `common_parameters()` dependency, you have to write the whole parameter with the type annotation and `Depends()`:

```Python
commons: Annotated[dict, Depends(common_parameters)]
```

But because we are using `Annotated`, we can store that `Annotated` value in a variable and use it in multiple places:

{* ../../docs_src/dependencies/tutorial001_02_an_py310.py hl[12,16,21] *}

/// tip

This is just standard Python, it's called a "type alias", it's actually not specific to **FastAPI**.

But because **FastAPI** is based on the Python standards, including `Annotated`, you can use this trick in your code. ðŸ˜Ž

///

The dependencies will keep working as expected, and the **best part** is that the **type information will be preserved**, which means that your editor will be able to keep providing you with **autocompletion**, **inline errors**, etc. The same for other tools like `mypy`.

This will be especially useful when you use it in a **large code base** where you use **the same dependencies** over and over again in **many *path operations***.

## To `async` or not to `async`

As dependencies will also be called by **FastAPI** (the same as your *path operation functions*), the same rules apply while defining your functions.

You can use `async def` or normal `def`.

And you can declare dependencies with `async def` inside of normal `def` *path operation functions*, or `def` dependencies inside of `async def` *path operation functions*, etc.

It doesn't matter. **FastAPI** will know what to do.

/// note

If you don't know, check the [Async: *"In a hurry?"*](../../async.md#in-a-hurry){.internal-link target=_blank} section about `async` and `await` in the docs.

///

## Integrated with OpenAPI

All the request declarations, validations and requirements of your dependencies (and sub-dependencies) will be integrated in the same OpenAPI schema.

So, the interactive docs will have all the information from these dependencies too:

<img src="/img/tutorial/dependencies/image01.png">

## Simple usage

If you look at it, *path operation functions* are declared to be used whenever a *path* and *operation* matches, and then **FastAPI** takes care of calling the function with the correct parameters, extracting the data from the request.

Actually, all (or most) of the web frameworks work in this same way.

You never call those functions directly. They are called by your framework (in this case, **FastAPI**).

With the Dependency Injection system, you can also tell **FastAPI** that your *path operation function* also "depends" on something else that should be executed before your *path operation function*, and **FastAPI** will take care of executing it and "injecting" the results.

Other common terms for this same idea of "dependency injection" are:

* resources
* providers
* services
* injectables
* components

## **FastAPI** plug-ins

Integrations and "plug-ins" can be built using the **Dependency Injection** system. But in fact, there is actually **no need to create "plug-ins"**, as by using dependencies it's possible to declare an infinite number of integrations and interactions that become available to your *path operation functions*.

And dependencies can be created in a very simple and intuitive way that allows you to just import the Python packages you need, and integrate them with your API functions in a couple of lines of code, *literally*.

You will see examples of this in the next chapters, about relational and NoSQL databases, security, etc.

## **FastAPI** compatibility

The simplicity of the dependency injection system makes **FastAPI** compatible with:

* all the relational databases
* NoSQL databases
* external packages
* external APIs
* authentication and authorization systems
* API usage monitoring systems
* response data injection systems
* etc.

## Simple and Powerful

Although the hierarchical dependency injection system is very simple to define and use, it's still very powerful.

You can define dependencies that in turn can define dependencies themselves.

In the end, a hierarchical tree of dependencies is built, and the **Dependency Injection** system takes care of solving all these dependencies for you (and their sub-dependencies) and providing (injecting) the results at each step.

For example, let's say you have 4 API endpoints (*path operations*):

* `/items/public/`
* `/items/private/`
* `/users/{user_id}/activate`
* `/items/pro/`

then you could add different permission requirements for each of them just with dependencies and sub-dependencies:

```mermaid
graph TB

current_user(["current_user"])
active_user(["active_user"])
admin_user(["admin_user"])
paying_user(["paying_user"])

public["/items/public/"]
private["/items/private/"]
activate_user["/users/{user_id}/activate"]
pro_items["/items/pro/"]

current_user --> active_user
active_user --> admin_user
active_user --> paying_user

current_user --> public
active_user --> private
admin_user --> activate_user
paying_user --> pro_items
```

## Integrated with **OpenAPI**

All these dependencies, while declaring their requirements, also add parameters, validations, etc. to your *path operations*.

**FastAPI** will take care of adding it all to the OpenAPI schema, so that it is shown in the interactive documentation systems.


================================================
File: /docs/en/docs/tutorial/dependencies/sub-dependencies.md
================================================
# Sub-dependencies

You can create dependencies that have **sub-dependencies**.

They can be as **deep** as you need them to be.

**FastAPI** will take care of solving them.

## First dependency "dependable"

You could create a first dependency ("dependable") like:

{* ../../docs_src/dependencies/tutorial005_an_py310.py hl[8:9] *}

It declares an optional query parameter `q` as a `str`, and then it just returns it.

This is quite simple (not very useful), but will help us focus on how the sub-dependencies work.

## Second dependency, "dependable" and "dependant"

Then you can create another dependency function (a "dependable") that at the same time declares a dependency of its own (so it is a "dependant" too):

{* ../../docs_src/dependencies/tutorial005_an_py310.py hl[13] *}

Let's focus on the parameters declared:

* Even though this function is a dependency ("dependable") itself, it also declares another dependency (it "depends" on something else).
    * It depends on the `query_extractor`, and assigns the value returned by it to the parameter `q`.
* It also declares an optional `last_query` cookie, as a `str`.
    * If the user didn't provide any query `q`, we use the last query used, which we saved to a cookie before.

## Use the dependency

Then we can use the dependency with:

{* ../../docs_src/dependencies/tutorial005_an_py310.py hl[23] *}

/// info

Notice that we are only declaring one dependency in the *path operation function*, the `query_or_cookie_extractor`.

But **FastAPI** will know that it has to solve `query_extractor` first, to pass the results of that to `query_or_cookie_extractor` while calling it.

///

```mermaid
graph TB

query_extractor(["query_extractor"])
query_or_cookie_extractor(["query_or_cookie_extractor"])

read_query["/items/"]

query_extractor --> query_or_cookie_extractor --> read_query
```

## Using the same dependency multiple times

If one of your dependencies is declared multiple times for the same *path operation*, for example, multiple dependencies have a common sub-dependency, **FastAPI** will know to call that sub-dependency only once per request.

And it will save the returned value in a <abbr title="A utility/system to store computed/generated values, to reuse them instead of computing them again.">"cache"</abbr> and pass it to all the "dependants" that need it in that specific request, instead of calling the dependency multiple times for the same request.

In an advanced scenario where you know you need the dependency to be called at every step (possibly multiple times) in the same request instead of using the "cached" value, you can set the parameter `use_cache=False` when using `Depends`:

//// tab | Python 3.8+

```Python hl_lines="1"
async def needy_dependency(fresh_value: Annotated[str, Depends(get_value, use_cache=False)]):
    return {"fresh_value": fresh_value}
```

////

//// tab | Python 3.8+ non-Annotated

/// tip

Prefer to use the `Annotated` version if possible.

///

```Python hl_lines="1"
async def needy_dependency(fresh_value: str = Depends(get_value, use_cache=False)):
    return {"fresh_value": fresh_value}
```

////

## Recap

Apart from all the fancy words used here, the **Dependency Injection** system is quite simple.

Just functions that look the same as the *path operation functions*.

But still, it is very powerful, and allows you to declare arbitrarily deeply nested dependency "graphs" (trees).

/// tip

All this might not seem as useful with these simple examples.

But you will see how useful it is in the chapters about **security**.

And you will also see the amounts of code it will save you.

///


================================================
File: /docs/en/docs/tutorial/security/first-steps.md
================================================
# Security - First Steps

Let's imagine that you have your **backend** API in some domain.

And you have a **frontend** in another domain or in a different path of the same domain (or in a mobile application).

And you want to have a way for the frontend to authenticate with the backend, using a **username** and **password**.

We can use **OAuth2** to build that with **FastAPI**.

But let's save you the time of reading the full long specification just to find those little pieces of information you need.

Let's use the tools provided by **FastAPI** to handle security.

## How it looks

Let's first just use the code and see how it works, and then we'll come back to understand what's happening.

## Create `main.py`

Copy the example in a file `main.py`:

{* ../../docs_src/security/tutorial001_an_py39.py *}

## Run it

/// info

The <a href="https://github.com/Kludex/python-multipart" class="external-link" target="_blank">`python-multipart`</a> package is automatically installed with **FastAPI** when you run the `pip install "fastapi[standard]"` command.

However, if you use the `pip install fastapi` command, the `python-multipart` package is not included by default.

To install it manually, make sure you create a [virtual environment](../../virtual-environments.md){.internal-link target=_blank}, activate it, and then install it with:

```console
$ pip install python-multipart
```

This is because **OAuth2** uses "form data" for sending the `username` and `password`.

///

Run the example with:

<div class="termy">

```console
$ fastapi dev main.py

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

## Check it

Go to the interactive docs at: <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

You will see something like this:

<img src="/img/tutorial/security/image01.png">

/// check | Authorize button!

You already have a shiny new "Authorize" button.

And your *path operation* has a little lock in the top-right corner that you can click.

///

And if you click it, you have a little authorization form to type a `username` and `password` (and other optional fields):

<img src="/img/tutorial/security/image02.png">

/// note

It doesn't matter what you type in the form, it won't work yet. But we'll get there.

///

This is of course not the frontend for the final users, but it's a great automatic tool to document interactively all your API.

It can be used by the frontend team (that can also be yourself).

It can be used by third party applications and systems.

And it can also be used by yourself, to debug, check and test the same application.

## The `password` flow

Now let's go back a bit and understand what is all that.

The `password` "flow" is one of the ways ("flows") defined in OAuth2, to handle security and authentication.

OAuth2 was designed so that the backend or API could be independent of the server that authenticates the user.

But in this case, the same **FastAPI** application will handle the API and the authentication.

So, let's review it from that simplified point of view:

* The user types the `username` and `password` in the frontend, and hits `Enter`.
* The frontend (running in the user's browser) sends that `username` and `password` to a specific URL in our API (declared with `tokenUrl="token"`).
* The API checks that `username` and `password`, and responds with a "token" (we haven't implemented any of this yet).
    * A "token" is just a string with some content that we can use later to verify this user.
    * Normally, a token is set to expire after some time.
        * So, the user will have to log in again at some point later.
        * And if the token is stolen, the risk is less. It is not like a permanent key that will work forever (in most of the cases).
* The frontend stores that token temporarily somewhere.
* The user clicks in the frontend to go to another section of the frontend web app.
* The frontend needs to fetch some more data from the API.
    * But it needs authentication for that specific endpoint.
    * So, to authenticate with our API, it sends a header `Authorization` with a value of `Bearer ` plus the token.
    * If the token contains `foobar`, the content of the `Authorization` header would be: `Bearer foobar`.

## **FastAPI**'s `OAuth2PasswordBearer`

**FastAPI** provides several tools, at different levels of abstraction, to implement these security features.

In this example we are going to use **OAuth2**, with the **Password** flow, using a **Bearer** token. We do that using the `OAuth2PasswordBearer` class.

/// info

A "bearer" token is not the only option.

But it's the best one for our use case.

And it might be the best for most use cases, unless you are an OAuth2 expert and know exactly why there's another option that better suits your needs.

In that case, **FastAPI** also provides you with the tools to build it.

///

When we create an instance of the `OAuth2PasswordBearer` class we pass in the `tokenUrl` parameter. This parameter contains the URL that the client (the frontend running in the user's browser) will use to send the `username` and `password` in order to get a token.

{* ../../docs_src/security/tutorial001_an_py39.py hl[8] *}

/// tip

Here `tokenUrl="token"` refers to a relative URL `token` that we haven't created yet. As it's a relative URL, it's equivalent to `./token`.

Because we are using a relative URL, if your API was located at `https://example.com/`, then it would refer to `https://example.com/token`. But if your API was located at `https://example.com/api/v1/`, then it would refer to `https://example.com/api/v1/token`.

Using a relative URL is important to make sure your application keeps working even in an advanced use case like [Behind a Proxy](../../advanced/behind-a-proxy.md){.internal-link target=_blank}.

///

This parameter doesn't create that endpoint / *path operation*, but declares that the URL `/token` will be the one that the client should use to get the token. That information is used in OpenAPI, and then in the interactive API documentation systems.

We will soon also create the actual path operation.

/// info

If you are a very strict "Pythonista" you might dislike the style of the parameter name `tokenUrl` instead of `token_url`.

That's because it is using the same name as in the OpenAPI spec. So that if you need to investigate more about any of these security schemes you can just copy and paste it to find more information about it.

///

The `oauth2_scheme` variable is an instance of `OAuth2PasswordBearer`, but it is also a "callable".

It could be called as:

```Python
oauth2_scheme(some, parameters)
```

So, it can be used with `Depends`.

### Use it

Now you can pass that `oauth2_scheme` in a dependency with `Depends`.

{* ../../docs_src/security/tutorial001_an_py39.py hl[12] *}

This dependency will provide a `str` that is assigned to the parameter `token` of the *path operation function*.

**FastAPI** will know that it can use this dependency to define a "security scheme" in the OpenAPI schema (and the automatic API docs).

/// info | Technical Details

**FastAPI** will know that it can use the class `OAuth2PasswordBearer` (declared in a dependency) to define the security scheme in OpenAPI because it inherits from `fastapi.security.oauth2.OAuth2`, which in turn inherits from `fastapi.security.base.SecurityBase`.

All the security utilities that integrate with OpenAPI (and the automatic API docs) inherit from `SecurityBase`, that's how **FastAPI** can know how to integrate them in OpenAPI.

///

## What it does

It will go and look in the request for that `Authorization` header, check if the value is `Bearer ` plus some token, and will return the token as a `str`.

If it doesn't see an `Authorization` header, or the value doesn't have a `Bearer ` token, it will respond with a 401 status code error (`UNAUTHORIZED`) directly.

You don't even have to check if the token exists to return an error. You can be sure that if your function is executed, it will have a `str` in that token.

You can try it already in the interactive docs:

<img src="/img/tutorial/security/image03.png">

We are not verifying the validity of the token yet, but that's a start already.

## Recap

So, in just 3 or 4 extra lines, you already have some primitive form of security.


================================================
File: /docs/en/docs/tutorial/security/get-current-user.md
================================================
# Get Current User

In the previous chapter the security system (which is based on the dependency injection system) was giving the *path operation function* a `token` as a `str`:

{* ../../docs_src/security/tutorial001_an_py39.py hl[12] *}

But that is still not that useful.

Let's make it give us the current user.

## Create a user model

First, let's create a Pydantic user model.

The same way we use Pydantic to declare bodies, we can use it anywhere else:

{* ../../docs_src/security/tutorial002_an_py310.py hl[5,12:6] *}

## Create a `get_current_user` dependency

Let's create a dependency `get_current_user`.

Remember that dependencies can have sub-dependencies?

`get_current_user` will have a dependency with the same `oauth2_scheme` we created before.

The same as we were doing before in the *path operation* directly, our new dependency `get_current_user` will receive a `token` as a `str` from the sub-dependency `oauth2_scheme`:

{* ../../docs_src/security/tutorial002_an_py310.py hl[25] *}

## Get the user

`get_current_user` will use a (fake) utility function we created, that takes a token as a `str` and returns our Pydantic `User` model:

{* ../../docs_src/security/tutorial002_an_py310.py hl[19:22,26:27] *}

## Inject the current user

So now we can use the same `Depends` with our `get_current_user` in the *path operation*:

{* ../../docs_src/security/tutorial002_an_py310.py hl[31] *}

Notice that we declare the type of `current_user` as the Pydantic model `User`.

This will help us inside of the function with all the completion and type checks.

/// tip

You might remember that request bodies are also declared with Pydantic models.

Here **FastAPI** won't get confused because you are using `Depends`.

///

/// check

The way this dependency system is designed allows us to have different dependencies (different "dependables") that all return a `User` model.

We are not restricted to having only one dependency that can return that type of data.

///

## Other models

You can now get the current user directly in the *path operation functions* and deal with the security mechanisms at the **Dependency Injection** level, using `Depends`.

And you can use any model or data for the security requirements (in this case, a Pydantic model `User`).

But you are not restricted to using some specific data model, class or type.

Do you want to have an `id` and `email` and not have any `username` in your model? Sure. You can use these same tools.

Do you want to just have a `str`? Or just a `dict`? Or a database class model instance directly? It all works the same way.

You actually don't have users that log in to your application but robots, bots, or other systems, that have just an access token? Again, it all works the same.

Just use any kind of model, any kind of class, any kind of database that you need for your application. **FastAPI** has you covered with the dependency injection system.

## Code size

This example might seem verbose. Keep in mind that we are mixing security, data models, utility functions and *path operations* in the same file.

But here's the key point.

The security and dependency injection stuff is written once.

And you can make it as complex as you want. And still, have it written only once, in a single place. With all the flexibility.

But you can have thousands of endpoints (*path operations*) using the same security system.

And all of them (or any portion of them that you want) can take advantage of re-using these dependencies or any other dependencies you create.

And all these thousands of *path operations* can be as small as 3 lines:

{* ../../docs_src/security/tutorial002_an_py310.py hl[30:32] *}

## Recap

You can now get the current user directly in your *path operation function*.

We are already halfway there.

We just need to add a *path operation* for the user/client to actually send the `username` and `password`.

That comes next.


================================================
File: /docs/en/docs/tutorial/security/index.md
================================================
# Security

There are many ways to handle security, authentication and authorization.

And it normally is a complex and "difficult" topic.

In many frameworks and systems just handling security and authentication takes a big amount of effort and code (in many cases it can be 50% or more of all the code written).

**FastAPI** provides several tools to help you deal with **Security** easily, rapidly, in a standard way, without having to study and learn all the security specifications.

But first, let's check some small concepts.

## In a hurry?

If you don't care about any of these terms and you just need to add security with authentication based on username and password *right now*, skip to the next chapters.

## OAuth2

OAuth2 is a specification that defines several ways to handle authentication and authorization.

It is quite an extensive specification and covers several complex use cases.

It includes ways to authenticate using a "third party".

That's what all the systems with "login with Facebook, Google, Twitter, GitHub" use underneath.

### OAuth 1

There was an OAuth 1, which is very different from OAuth2, and more complex, as it included direct specifications on how to encrypt the communication.

It is not very popular or used nowadays.

OAuth2 doesn't specify how to encrypt the communication, it expects you to have your application served with HTTPS.

/// tip

In the section about **deployment** you will see how to set up HTTPS for free, using Traefik and Let's Encrypt.

///

## OpenID Connect

OpenID Connect is another specification, based on **OAuth2**.

It just extends OAuth2 specifying some things that are relatively ambiguous in OAuth2, to try to make it more interoperable.

For example, Google login uses OpenID Connect (which underneath uses OAuth2).

But Facebook login doesn't support OpenID Connect. It has its own flavor of OAuth2.

### OpenID (not "OpenID Connect")

There was also an "OpenID" specification. That tried to solve the same thing as **OpenID Connect**, but was not based on OAuth2.

So, it was a complete additional system.

It is not very popular or used nowadays.

## OpenAPI

OpenAPI (previously known as Swagger) is the open specification for building APIs (now part of the Linux Foundation).

**FastAPI** is based on **OpenAPI**.

That's what makes it possible to have multiple automatic interactive documentation interfaces, code generation, etc.

OpenAPI has a way to define multiple security "schemes".

By using them, you can take advantage of all these standard-based tools, including these interactive documentation systems.

OpenAPI defines the following security schemes:

* `apiKey`: an application specific key that can come from:
    * A query parameter.
    * A header.
    * A cookie.
* `http`: standard HTTP authentication systems, including:
    * `bearer`: a header `Authorization` with a value of `Bearer ` plus a token. This is inherited from OAuth2.
    * HTTP Basic authentication.
    * HTTP Digest, etc.
* `oauth2`: all the OAuth2 ways to handle security (called "flows").
    * Several of these flows are appropriate for building an OAuth 2.0 authentication provider (like Google, Facebook, Twitter, GitHub, etc):
        * `implicit`
        * `clientCredentials`
        * `authorizationCode`
    * But there is one specific "flow" that can be perfectly used for handling authentication in the same application directly:
        * `password`: some next chapters will cover examples of this.
* `openIdConnect`: has a way to define how to discover OAuth2 authentication data automatically.
    * This automatic discovery is what is defined in the OpenID Connect specification.


/// tip

Integrating other authentication/authorization providers like Google, Facebook, Twitter, GitHub, etc. is also possible and relatively easy.

The most complex problem is building an authentication/authorization provider like those, but **FastAPI** gives you the tools to do it easily, while doing the heavy lifting for you.

///

## **FastAPI** utilities

FastAPI provides several tools for each of these security schemes in the `fastapi.security` module that simplify using these security mechanisms.

In the next chapters you will see how to add security to your API using those tools provided by **FastAPI**.

And you will also see how it gets automatically integrated into the interactive documentation system.


================================================
File: /docs/en/docs/tutorial/security/oauth2-jwt.md
================================================
# OAuth2 with Password (and hashing), Bearer with JWT tokens

Now that we have all the security flow, let's make the application actually secure, using <abbr title="JSON Web Tokens">JWT</abbr> tokens and secure password hashing.

This code is something you can actually use in your application, save the password hashes in your database, etc.

We are going to start from where we left in the previous chapter and increment it.

## About JWT

JWT means "JSON Web Tokens".

It's a standard to codify a JSON object in a long dense string without spaces. It looks like this:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

It is not encrypted, so, anyone could recover the information from the contents.

But it's signed. So, when you receive a token that you emitted, you can verify that you actually emitted it.

That way, you can create a token with an expiration of, let's say, 1 week. And then when the user comes back the next day with the token, you know that user is still logged in to your system.

After a week, the token will be expired and the user will not be authorized and will have to sign in again to get a new token. And if the user (or a third party) tried to modify the token to change the expiration, you would be able to discover it, because the signatures would not match.

If you want to play with JWT tokens and see how they work, check <a href="https://jwt.io/" class="external-link" target="_blank">https://jwt.io</a>.

## Install `PyJWT`

We need to install `PyJWT` to generate and verify the JWT tokens in Python.

Make sure you create a [virtual environment](../../virtual-environments.md){.internal-link target=_blank}, activate it, and then install `pyjwt`:

<div class="termy">

```console
$ pip install pyjwt

---> 100%
```

</div>

/// info

If you are planning to use digital signature algorithms like RSA or ECDSA, you should install the cryptography library dependency `pyjwt[crypto]`.

You can read more about it in the <a href="https://pyjwt.readthedocs.io/en/latest/installation.html" class="external-link" target="_blank">PyJWT Installation docs</a>.

///

## Password hashing

"Hashing" means converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish.

Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish.

But you cannot convert from the gibberish back to the password.

### Why use password hashing

If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes.

So, the thief won't be able to try to use that password in another system (as many users use the same password everywhere, this would be dangerous).

## Install `passlib`

PassLib is a great Python package to handle password hashes.

It supports many secure hashing algorithms and utilities to work with them.

The recommended algorithm is "Bcrypt".

Make sure you create a [virtual environment](../../virtual-environments.md){.internal-link target=_blank}, activate it, and then install PassLib with Bcrypt:

<div class="termy">

```console
$ pip install "passlib[bcrypt]"

---> 100%
```

</div>

/// tip

With `passlib`, you could even configure it to be able to read passwords created by **Django**, a **Flask** security plug-in or many others.

So, you would be able to, for example, share the same data from a Django application in a database with a FastAPI application. Or gradually migrate a Django application using the same database.

And your users would be able to login from your Django app or from your **FastAPI** app, at the same time.

///

## Hash and verify the passwords

Import the tools we need from `passlib`.

Create a PassLib "context". This is what will be used to hash and verify passwords.

/// tip

The PassLib context also has functionality to use different hashing algorithms, including deprecated old ones only to allow verifying them, etc.

For example, you could use it to read and verify passwords generated by another system (like Django) but hash any new passwords with a different algorithm like Bcrypt.

And be compatible with all of them at the same time.

///

Create a utility function to hash a password coming from the user.

And another utility to verify if a received password matches the hash stored.

And another one to authenticate and return a user.

{* ../../docs_src/security/tutorial004_an_py310.py hl[8,49,56:57,60:61,70:76] *}

/// note

If you check the new (fake) database `fake_users_db`, you will see how the hashed password looks like now: `"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"`.

///

## Handle JWT tokens

Import the modules installed.

Create a random secret key that will be used to sign the JWT tokens.

To generate a secure random secret key use the command:

<div class="termy">

```console
$ openssl rand -hex 32

09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7
```

</div>

And copy the output to the variable `SECRET_KEY` (don't use the one in the example).

Create a variable `ALGORITHM` with the algorithm used to sign the JWT token and set it to `"HS256"`.

Create a variable for the expiration of the token.

Define a Pydantic Model that will be used in the token endpoint for the response.

Create a utility function to generate a new access token.

{* ../../docs_src/security/tutorial004_an_py310.py hl[4,7,13:15,29:31,79:87] *}

## Update the dependencies

Update `get_current_user` to receive the same token as before, but this time, using JWT tokens.

Decode the received token, verify it, and return the current user.

If the token is invalid, return an HTTP error right away.

{* ../../docs_src/security/tutorial004_an_py310.py hl[90:107] *}

## Update the `/token` *path operation*

Create a `timedelta` with the expiration time of the token.

Create a real JWT access token and return it.

{* ../../docs_src/security/tutorial004_an_py310.py hl[118:133] *}

### Technical details about the JWT "subject" `sub`

The JWT specification says that there's a key `sub`, with the subject of the token.

It's optional to use it, but that's where you would put the user's identification, so we are using it here.

JWT might be used for other things apart from identifying a user and allowing them to perform operations directly on your API.

For example, you could identify a "car" or a "blog post".

Then you could add permissions about that entity, like "drive" (for the car) or "edit" (for the blog).

And then, you could give that JWT token to a user (or bot), and they could use it to perform those actions (drive the car, or edit the blog post) without even needing to have an account, just with the JWT token your API generated for that.

Using these ideas, JWT can be used for way more sophisticated scenarios.

In those cases, several of those entities could have the same ID, let's say `foo` (a user `foo`, a car `foo`, and a blog post `foo`).

So, to avoid ID collisions, when creating the JWT token for the user, you could prefix the value of the `sub` key, e.g. with `username:`. So, in this example, the value of `sub` could have been: `username:johndoe`.

The important thing to keep in mind is that the `sub` key should have a unique identifier across the entire application, and it should be a string.

## Check it

Run the server and go to the docs: <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

You'll see the user interface like:

<img src="/img/tutorial/security/image07.png">

Authorize the application the same way as before.

Using the credentials:

Username: `johndoe`
Password: `secret`

/// check

Notice that nowhere in the code is the plaintext password "`secret`", we only have the hashed version.

///

<img src="/img/tutorial/security/image08.png">

Call the endpoint `/users/me/`, you will get the response as:

```JSON
{
  "username": "johndoe",
  "email": "johndoe@example.com",
  "full_name": "John Doe",
  "disabled": false
}
```

<img src="/img/tutorial/security/image09.png">

If you open the developer tools, you could see how the data sent only includes the token, the password is only sent in the first request to authenticate the user and get that access token, but not afterwards:

<img src="/img/tutorial/security/image10.png">

/// note

Notice the header `Authorization`, with a value that starts with `Bearer `.

///

## Advanced usage with `scopes`

OAuth2 has the notion of "scopes".

You can use them to add a specific set of permissions to a JWT token.

Then you can give this token to a user directly or a third party, to interact with your API with a set of restrictions.

You can learn how to use them and how they are integrated into **FastAPI** later in the **Advanced User Guide**.

## Recap

With what you have seen up to now, you can set up a secure **FastAPI** application using standards like OAuth2 and JWT.

In almost any framework handling the security becomes a rather complex subject quite quickly.

Many packages that simplify it a lot have to make many compromises with the data model, database, and available features. And some of these packages that simplify things too much actually have security flaws underneath.

---

**FastAPI** doesn't make any compromise with any database, data model or tool.

It gives you all the flexibility to choose the ones that fit your project the best.

And you can use directly many well maintained and widely used packages like `passlib` and `PyJWT`, because **FastAPI** doesn't require any complex mechanisms to integrate external packages.

But it provides you the tools to simplify the process as much as possible without compromising flexibility, robustness, or security.

And you can use and implement secure, standard protocols, like OAuth2 in a relatively simple way.

You can learn more in the **Advanced User Guide** about how to use OAuth2 "scopes", for a more fine-grained permission system, following these same standards. OAuth2 with scopes is the mechanism used by many big authentication providers, like Facebook, Google, GitHub, Microsoft, Twitter, etc. to authorize third party applications to interact with their APIs on behalf of their users.


================================================
File: /docs/en/docs/tutorial/security/simple-oauth2.md
================================================
# Simple OAuth2 with Password and Bearer

Now let's build from the previous chapter and add the missing parts to have a complete security flow.

## Get the `username` and `password`

We are going to use **FastAPI** security utilities to get the `username` and `password`.

OAuth2 specifies that when using the "password flow" (that we are using) the client/user must send a `username` and `password` fields as form data.

And the spec says that the fields have to be named like that. So `user-name` or `email` wouldn't work.

But don't worry, you can show it as you wish to your final users in the frontend.

And your database models can use any other names you want.

But for the login *path operation*, we need to use these names to be compatible with the spec (and be able to, for example, use the integrated API documentation system).

The spec also states that the `username` and `password` must be sent as form data (so, no JSON here).

### `scope`

The spec also says that the client can send another form field "`scope`".

The form field name is `scope` (in singular), but it is actually a long string with "scopes" separated by spaces.

Each "scope" is just a string (without spaces).

They are normally used to declare specific security permissions, for example:

* `users:read` or `users:write` are common examples.
* `instagram_basic` is used by Facebook / Instagram.
* `https://www.googleapis.com/auth/drive` is used by Google.

/// info

In OAuth2 a "scope" is just a string that declares a specific permission required.

It doesn't matter if it has other characters like `:` or if it is a URL.

Those details are implementation specific.

For OAuth2 they are just strings.

///

## Code to get the `username` and `password`

Now let's use the utilities provided by **FastAPI** to handle this.

### `OAuth2PasswordRequestForm`

First, import `OAuth2PasswordRequestForm`, and use it as a dependency with `Depends` in the *path operation* for `/token`:

{* ../../docs_src/security/tutorial003_an_py310.py hl[4,78] *}

`OAuth2PasswordRequestForm` is a class dependency that declares a form body with:

* The `username`.
* The `password`.
* An optional `scope` field as a big string, composed of strings separated by spaces.
* An optional `grant_type`.

/// tip

The OAuth2 spec actually *requires* a field `grant_type` with a fixed value of `password`, but `OAuth2PasswordRequestForm` doesn't enforce it.

If you need to enforce it, use `OAuth2PasswordRequestFormStrict` instead of `OAuth2PasswordRequestForm`.

///

* An optional `client_id` (we don't need it for our example).
* An optional `client_secret` (we don't need it for our example).

/// info

The `OAuth2PasswordRequestForm` is not a special class for **FastAPI** as is `OAuth2PasswordBearer`.

`OAuth2PasswordBearer` makes **FastAPI** know that it is a security scheme. So it is added that way to OpenAPI.

But `OAuth2PasswordRequestForm` is just a class dependency that you could have written yourself, or you could have declared `Form` parameters directly.

But as it's a common use case, it is provided by **FastAPI** directly, just to make it easier.

///

### Use the form data

/// tip

The instance of the dependency class `OAuth2PasswordRequestForm` won't have an attribute `scope` with the long string separated by spaces, instead, it will have a `scopes` attribute with the actual list of strings for each scope sent.

We are not using `scopes` in this example, but the functionality is there if you need it.

///

Now, get the user data from the (fake) database, using the `username` from the form field.

If there is no such user, we return an error saying "Incorrect username or password".

For the error, we use the exception `HTTPException`:

{* ../../docs_src/security/tutorial003_an_py310.py hl[3,79:81] *}

### Check the password

At this point we have the user data from our database, but we haven't checked the password.

Let's put that data in the Pydantic `UserInDB` model first.

You should never save plaintext passwords, so, we'll use the (fake) password hashing system.

If the passwords don't match, we return the same error.

#### Password hashing

"Hashing" means: converting some content (a password in this case) into a sequence of bytes (just a string) that looks like gibberish.

Whenever you pass exactly the same content (exactly the same password) you get exactly the same gibberish.

But you cannot convert from the gibberish back to the password.

##### Why use password hashing

If your database is stolen, the thief won't have your users' plaintext passwords, only the hashes.

So, the thief won't be able to try to use those same passwords in another system (as many users use the same password everywhere, this would be dangerous).

{* ../../docs_src/security/tutorial003_an_py310.py hl[82:85] *}

#### About `**user_dict`

`UserInDB(**user_dict)` means:

*Pass the keys and values of the `user_dict` directly as key-value arguments, equivalent to:*

```Python
UserInDB(
    username = user_dict["username"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
    disabled = user_dict["disabled"],
    hashed_password = user_dict["hashed_password"],
)
```

/// info

For a more complete explanation of `**user_dict` check back in [the documentation for **Extra Models**](../extra-models.md#about-user_indict){.internal-link target=_blank}.

///

## Return the token

The response of the `token` endpoint must be a JSON object.

It should have a `token_type`. In our case, as we are using "Bearer" tokens, the token type should be "`bearer`".

And it should have an `access_token`, with a string containing our access token.

For this simple example, we are going to just be completely insecure and return the same `username` as the token.

/// tip

In the next chapter, you will see a real secure implementation, with password hashing and <abbr title="JSON Web Tokens">JWT</abbr> tokens.

But for now, let's focus on the specific details we need.

///

{* ../../docs_src/security/tutorial003_an_py310.py hl[87] *}

/// tip

By the spec, you should return a JSON with an `access_token` and a `token_type`, the same as in this example.

This is something that you have to do yourself in your code, and make sure you use those JSON keys.

It's almost the only thing that you have to remember to do correctly yourself, to be compliant with the specifications.

For the rest, **FastAPI** handles it for you.

///

## Update the dependencies

Now we are going to update our dependencies.

We want to get the `current_user` *only* if this user is active.

So, we create an additional dependency `get_current_active_user` that in turn uses `get_current_user` as a dependency.

Both of these dependencies will just return an HTTP error if the user doesn't exist, or if is inactive.

So, in our endpoint, we will only get a user if the user exists, was correctly authenticated, and is active:

{* ../../docs_src/security/tutorial003_an_py310.py hl[58:66,69:74,94] *}

/// info

The additional header `WWW-Authenticate` with value `Bearer` we are returning here is also part of the spec.

Any HTTP (error) status code 401 "UNAUTHORIZED" is supposed to also return a `WWW-Authenticate` header.

In the case of bearer tokens (our case), the value of that header should be `Bearer`.

You can actually skip that extra header and it would still work.

But it's provided here to be compliant with the specifications.

Also, there might be tools that expect and use it (now or in the future) and that might be useful for you or your users, now or in the future.

That's the benefit of standards...

///

## See it in action

Open the interactive docs: <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

### Authenticate

Click the "Authorize" button.

Use the credentials:

User: `johndoe`

Password: `secret`

<img src="/img/tutorial/security/image04.png">

After authenticating in the system, you will see it like:

<img src="/img/tutorial/security/image05.png">

### Get your own user data

Now use the operation `GET` with the path `/users/me`.

You will get your user's data, like:

```JSON
{
  "username": "johndoe",
  "email": "johndoe@example.com",
  "full_name": "John Doe",
  "disabled": false,
  "hashed_password": "fakehashedsecret"
}
```

<img src="/img/tutorial/security/image06.png">

If you click the lock icon and logout, and then try the same operation again, you will get an HTTP 401 error of:

```JSON
{
  "detail": "Not authenticated"
}
```

### Inactive user

Now try with an inactive user, authenticate with:

User: `alice`

Password: `secret2`

And try to use the operation `GET` with the path `/users/me`.

You will get an "Inactive user" error, like:

```JSON
{
  "detail": "Inactive user"
}
```

## Recap

You now have the tools to implement a complete security system based on `username` and `password` for your API.

Using these tools, you can make the security system compatible with any database and with any user or data model.

The only detail missing is that it is not actually "secure" yet.

In the next chapter you'll see how to use a secure password hashing library and <abbr title="JSON Web Tokens">JWT</abbr> tokens.


================================================
File: /docs/en/overrides/main.html
================================================
{% extends "base.html" %}

{% block announce %}
<div class="announce-wrapper">
  <div id="announce-left">
    <div class="item">
      <a class="announce-link" href="https://twitter.com/fastapi" target="_blank">
        <span class="twemoji twitter">
          {% include ".icons/fontawesome/brands/twitter.svg" %}
        </span> Follow <strong>@fastapi</strong> on <strong>Twitter</strong> to stay updated
      </a>
    </div>
    <div class="item">
      <a class="announce-link" href="https://fastapi.tiangolo.com/newsletter/">
        <span class="twemoji">
          {% include ".icons/material/email.svg" %}
        </span> Subscribe to the <strong>FastAPI and friends</strong> newsletter ðŸŽ‰
      </a>
    </div>
    <div class="item">
      <iframe style="display: inline-block; vertical-align: middle; border: none; margin-right: 0.5rem;" src="https://github.com/sponsors/tiangolo/button" title="Sponsor tiangolo" height="35" width="116" style="border: 0;"></iframe> <a class="announce-link" target="_blank" href="https://github.com/sponsors/tiangolo">You can now sponsor <strong>FastAPI</strong> ðŸ°</a>
    </div>
  </div>
  <div id="announce-right" style="position: relative;">
    <div class="item">
      <a title="BlockBee Cryptocurrency Payment Gateway" style="display: block; position: relative;" href="https://blockbee.io?ref=fastapi" target="_blank">
        <span class="sponsor-badge">sponsor</span>
        <img class="sponsor-image" src="/img/sponsors/blockbee-banner.png" />
      </a>
    </div>
    <div class="item">
      <a title="Build, run and scale your apps on a modern, reliable, and secure PaaS." style="display: block; position: relative;" href="https://platform.sh/try-it-now/?utm_source=fastapi-signup&utm_medium=banner&utm_campaign=FastAPI-signup-June-2023" target="_blank">
        <span class="sponsor-badge">sponsor</span>
        <img class="sponsor-image" src="/img/sponsors/platform-sh-banner.png" />
      </a>
    </div>
    <div class="item">
      <a title="Deploy FastAPI on AWS with a few clicks" style="display: block; position: relative;" href="https://www.porter.run" target="_blank">
        <span class="sponsor-badge">sponsor</span>
        <img class="sponsor-image" src="/img/sponsors/porter-banner.png" />
      </a>
    </div>
    <div class="item">
      <a title="Automate FastAPI documentation generation with Bump.sh" style="display: block; position: relative;" href="https://bump.sh/fastapi?utm_source=fastapi&utm_medium=referral&utm_campaign=sponsor" target="_blank">
        <span class="sponsor-badge">sponsor</span>
        <img class="sponsor-image" src="/img/sponsors/bump-sh-banner.svg" />
      </a>
    </div>
    <div class="item">
      <a title="Scalar: Beautiful Open-Source API References from Swagger/OpenAPI files" style="display: block; position: relative;" href="https://github.com/scalar/scalar/?utm_source=fastapi&utm_medium=website&utm_campaign=top-banner" target="_blank">
        <span class="sponsor-badge">sponsor</span>
        <img class="sponsor-image" src="/img/sponsors/scalar-banner.svg" />
      </a>
    </div>
    <div class="item">
      <a title="Auth, user management and more for your B2B product" style="display: block; position: relative;" href="https://www.propelauth.com/?utm_source=fastapi&utm_campaign=1223&utm_medium=topbanner" target="_blank">
        <span class="sponsor-badge">sponsor</span>
        <img class="sponsor-image" src="/img/sponsors/propelauth-banner.png" />
      </a>
    </div>
    <div class="item">
      <a title="Coherence" style="display: block; position: relative;" href="https://www.withcoherence.com/?utm_medium=advertising&utm_source=fastapi&utm_campaign=website" target="_blank">
        <span class="sponsor-badge">sponsor</span>
        <img class="sponsor-image" src="/img/sponsors/coherence-banner.png" />
      </a>
    </div>
    <div class="item">
      <a title="Build your next app with FastAPI and MongoDB" style="display: block; position: relative;" href="https://www.mongodb.com/developer/languages/python/python-quickstart-fastapi/?utm_campaign=fastapi_framework&utm_source=fastapi_sponsorship&utm_medium=web_referral" target="_blank">
        <span class="sponsor-badge">sponsor</span>
        <img class="sponsor-image" src="/img/sponsors/mongodb-banner.png" />
      </a>
    </div>
    <div class="item">
      <a title="Zuplo: Scale, Protect, Document, and Monetize your FastAPI" style="display: block; position: relative;" href="https://zuplo.link/fastapi-web" target="_blank">
        <span class="sponsor-badge">sponsor</span>
        <img class="sponsor-image" src="/img/sponsors/zuplo-banner.png" />
      </a>
    </div>
    <div class="item">
      <a title="liblab - Generate SDKs from FastAPI" style="display: block; position: relative;" href="https://liblab.com?utm_source=fastapi" target="_blank">
        <span class="sponsor-badge">sponsor</span>
        <img class="sponsor-image" src="/img/sponsors/liblab-banner.png" />
      </a>
    </div>
    <div class="item">
      <a title="Deploy & scale any full-stack web app on Render. Focus on building apps, not infra." style="display: block; position: relative;" href="https://docs.render.com/deploy-fastapi?utm_source=deploydoc&utm_medium=referral&utm_campaign=fastapi" target="_blank">
        <span class="sponsor-badge">sponsor</span>
        <img class="sponsor-image" src="/img/sponsors/render-banner.svg" />
      </a>
    </div>
  </div>
</div>
{% endblock %}


================================================
File: /docs/en/overrides/partials/copyright.html
================================================
<div class="md-copyright">
    <div class="md-copyright__highlight">
        The FastAPI trademark is owned by <a href="https://tiangolo.com" target="_blank">@tiangolo</a> and is registered in the US and across other regions
    </div>
    {% if not config.extra.generator == false %}
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
        Material for MkDocs
    </a>
    {% endif %}
</div>


================================================
File: /docs/es/llm-prompt.md
================================================
Translate to Spanish (espaÃ±ol).

Use the informal grammar (use "tÃº" instead of "usted").

For instructions or titles in imperative, keep them in imperative, for example "Edit it" to "EdÃ­talo".

There are special blocks of notes, tips and others that look like:

/// note

To translate it, keep the same line and add the translation after a vertical bar:

/// note | Nota

Some examples:

Source:

/// tip

Result:

/// tip | Consejo

Source:

/// details | Preview

Result:

/// details | Vista previa

Source:

/// warning

Result:

/// warning | Advertencia

Source:

/// info

Result:

/// info | InformaciÃ³n

Source:

/// note | Technical Details

Result:

/// note | Detalles TÃ©cnicos

---

For the next terms, use the following translations:

* framework: framework (do not translate to "marco")
* performance: rendimiento
* program (verb): programar
* code (verb): programar
* type hints: anotaciones de tipos
* type annotations: anotaciones de tipos
* autocomplete: autocompletado
* completion (in the context of autocompletion): autocompletado
* feature: funcionalidad
* sponsor: sponsor
* host (in a podcast): host
* request (as in HTTP request): request
* response (as in HTTP response): response
* path operation function: path operation function (do not translate to "funciÃ³n de operaciÃ³n de ruta")
* path operation: path operation (do not translate to "operaciÃ³n de ruta")
* path (as in URL path): path (do not translate to "ruta")
* query (as in URL query): query (do not translate to "consulta")
* cookie (as in HTTP cookie): cookie
* header (as in HTTP header): header
* form (as in HTML form): formulario
* type checks: chequeo de tipos
* parse: parse
* parsing: parsing
* marshall: marshall
* library: paquete (do not translate to "biblioteca" or "librerÃ­a")
* instance: instance (do not translate to "instancia")
* scratch the surface: tocar los conceptos bÃ¡sicos
* string: string
* bug: bug
* docs: documentaciÃ³n (do not translate to "documentos")
* cheat sheet: cheat sheet (do not translate to "chuleta")
* key (as in key-value pair, dictionary key): clave
* array (as in JSON array): array
* API key: API key (do not translate to "clave API")
* 100% test coverage: cobertura de tests del 100%
* back and forth: de un lado a otro
* I/O (as in "input and output"): I/O (do not translate to "E/S")
* Machine Learning: Machine Learning (do not translate to "Aprendizaje AutomÃ¡tico")
* Deep Learning: Deep Learning (do not translate to "Aprendizaje Profundo")
* callback hell: callback hell (do not translate to "infierno de callbacks")
* tip: Consejo (do not translate to "tip")
* check: Revisa (do not translate to "chequea" or "comprobaciÃ³n)
* Cross-Origin Resource Sharing: Cross-Origin Resource Sharing (do not translate to "ComparticiÃ³n de Recursos de Origen Cruzado")
* Release Notes: Release Notes (do not translate to "Notas de la VersiÃ³n")
* Semantic Versioning: Semantic Versioning (do not translate to "Versionado SemÃ¡ntico")
* dependable: dependable (do not translate to "confiable" or "fiable")
* list (as in Python list): list
* context manager: context manager (do not translate to "gestor de contexto" or "administrador de contexto")
* a little bit: un poquito
* graph (data structure, as in "dependency graph"): grafo (do not translate to "grÃ¡fico")
* form data: form data (do not translate to "datos de formulario" or "datos de form")
* import (as in code import): import (do not translate to "importaciÃ³n")
* JSON Schema: JSON Schema (do not translate to "Esquema JSON")
* embed: embeber (do not translate to "incrustar")
* request body: request body (do not translate to "cuerpo de la peticiÃ³n")
* response body: response body (do not translate to "cuerpo de la respuesta")
* cross domain: cross domain (do not translate to "dominio cruzado")
* cross origin: cross origin (do not translate to "origen cruzado")
* plugin: plugin (do not translate to "complemento" or "extensiÃ³n")
* plug-in: plug-in (do not translate to "complemento" or "extensiÃ³n")
* plug-ins: plug-ins (do not translate to "complementos" or "extensiones")
* full stack: full stack (do not translate to "pila completa")
* full-stack: full-stack (do not translate to "de pila completa")
* stack: stack (do not translate to "pila")
* loop (as in async loop): loop (do not translate to "bucle" or "ciclo")
* hard dependencies: dependencias obligatorias (do not translate to "dependencias duras")
* locking: locking (do not translate to "bloqueo")
* testing (as in software testing): escribir pruebas (do not translate to "probar")
* code base: code base (do not translate to "base de cÃ³digo")
* default: por defecto (do not translate to "predeterminado")
* default values: valores por defecto (do not translate to "valores predeterminados")
* media type: media type (do not translate to "tipo de medio")
* instantiate: crear un instance (do not translate to "instanciar")
* OAuth2 Scopes: Scopes de OAuth2 (do not translate to "Alcances de OAuth2")
* on the fly: sobre la marcha (do not translate to "al vuelo")
* terminal: terminal (femenine, as in "la terminal")
* terminals: terminales (plural femenine, as in "las terminales")
* lifespan: lifespan (do not translate to "vida Ãºtil" or "tiempo de vida")
* unload: quitar de memoria (do not translate to "descargar")
* mount (noun): mount (do not translate to "montura")
* mount (verb): montar
* statement (as in code statement): statement (do not translate to "declaraciÃ³n" or "sentencia")
* worker process: worker process (do not translate to "proceso trabajador" or "proceso de trabajo")
* worker processes: worker processes (do not translate to "procesos trabajadores" or "procesos de trabajo")
* worker: worker (do not translate to "trabajador")
* load balancer: load balancer (do not translate to "balanceador de carga")
* load balance: load balance (do not translate to "balancear carga")
* self hosting: self hosting (do not translate to "auto alojamiento")


================================================
File: /docs/es/mkdocs.yml
================================================
INHERIT: ../en/mkdocs.yml


================================================
File: /docs/es/docs/alternatives.md
================================================
# Alternativas, InspiraciÃ³n y Comparaciones

Lo que inspirÃ³ a **FastAPI**, cÃ³mo se compara con las alternativas y lo que aprendiÃ³ de ellas.

## IntroducciÃ³n

**FastAPI** no existirÃ­a si no fuera por el trabajo previo de otros.

Se han creado muchas herramientas antes que han ayudado a inspirar su creaciÃ³n.

He estado evitando la creaciÃ³n de un nuevo framework durante varios aÃ±os. Primero intentÃ© resolver todas las funcionalidades cubiertas por **FastAPI** usando muchos frameworks diferentes, plug-ins y herramientas.

Pero en algÃºn punto, no hubo otra opciÃ³n que crear algo que proporcionara todas estas funcionalidades, tomando las mejores ideas de herramientas previas y combinÃ¡ndolas de la mejor manera posible, usando funcionalidades del lenguaje que ni siquiera estaban disponibles antes (anotaciones de tipos de Python 3.6+).

## Herramientas previas

### <a href="https://www.djangoproject.com/" class="external-link" target="_blank">Django</a>

Es el framework mÃ¡s popular de Python y es ampliamente confiable. Se utiliza para construir sistemas como Instagram.

EstÃ¡ relativamente acoplado con bases de datos relacionales (como MySQL o PostgreSQL), por lo que tener una base de datos NoSQL (como Couchbase, MongoDB, Cassandra, etc) como motor de almacenamiento principal no es muy fÃ¡cil.

Fue creado para generar el HTML en el backend, no para crear APIs utilizadas por un frontend moderno (como React, Vue.js y Angular) o por otros sistemas (como dispositivos del <abbr title="Internet of Things">IoT</abbr>) comunicÃ¡ndose con Ã©l.

### <a href="https://www.django-rest-framework.org/" class="external-link" target="_blank">Django REST Framework</a>

El framework Django REST fue creado para ser un kit de herramientas flexible para construir APIs Web utilizando Django, mejorando sus capacidades API.

Es utilizado por muchas empresas, incluidas Mozilla, Red Hat y Eventbrite.

Fue uno de los primeros ejemplos de **documentaciÃ³n automÃ¡tica de APIs**, y esto fue especÃ­ficamente una de las primeras ideas que inspiraron "la bÃºsqueda de" **FastAPI**.

/// note | Nota

Django REST Framework fue creado por Tom Christie. El mismo creador de Starlette y Uvicorn, en los cuales **FastAPI** estÃ¡ basado.

///

/// check | InspirÃ³ a **FastAPI** a

Tener una interfaz de usuario web de documentaciÃ³n automÃ¡tica de APIs.

///

### <a href="https://flask.palletsprojects.com" class="external-link" target="_blank">Flask</a>

Flask es un "microframework", no incluye integraciones de bases de datos ni muchas de las cosas que vienen por defecto en Django.

Esta simplicidad y flexibilidad permiten hacer cosas como usar bases de datos NoSQL como el sistema de almacenamiento de datos principal.

Como es muy simple, es relativamente intuitivo de aprender, aunque la documentaciÃ³n se vuelve algo tÃ©cnica en algunos puntos.

TambiÃ©n se utiliza comÃºnmente para otras aplicaciones que no necesariamente necesitan una base de datos, gestiÃ³n de usuarios, o cualquiera de las muchas funcionalidades que vienen preconstruidas en Django. Aunque muchas de estas funcionalidades se pueden aÃ±adir con plug-ins.

Esta separaciÃ³n de partes, y ser un "microframework" que podrÃ­a extenderse para cubrir exactamente lo que se necesita, fue una funcionalidad clave que quise mantener.

Dada la simplicidad de Flask, parecÃ­a una buena opciÃ³n para construir APIs. Lo siguiente a encontrar era un "Django REST Framework" para Flask.

/// check | InspirÃ³ a **FastAPI** a

Ser un micro-framework. Haciendo fÃ¡cil mezclar y combinar las herramientas y partes necesarias.

Tener un sistema de routing simple y fÃ¡cil de usar.

///

### <a href="https://requests.readthedocs.io" class="external-link" target="_blank">Requests</a>

**FastAPI** no es en realidad una alternativa a **Requests**. Su Ã¡mbito es muy diferente.

De hecho, serÃ­a comÃºn usar Requests *dentro* de una aplicaciÃ³n FastAPI.

Aun asÃ­, FastAPI se inspirÃ³ bastante en Requests.

**Requests** es un paquete para *interactuar* con APIs (como cliente), mientras que **FastAPI** es un paquete para *construir* APIs (como servidor).

EstÃ¡n, mÃ¡s o menos, en extremos opuestos, complementÃ¡ndose entre sÃ­.

Requests tiene un diseÃ±o muy simple e intuitivo, es muy fÃ¡cil de usar, con valores predeterminados sensatos. Pero al mismo tiempo, es muy poderoso y personalizable.

Por eso, como se dice en el sitio web oficial:

> Requests es uno de los paquetes Python mÃ¡s descargados de todos los tiempos

La forma en que lo usas es muy sencilla. Por ejemplo, para hacer un `GET` request, escribirÃ­as:

```Python
response = requests.get("http://example.com/some/url")
```

La operaciÃ³n de path equivalente en FastAPI podrÃ­a verse como:

```Python hl_lines="1"
@app.get("/some/url")
def read_url():
    return {"message": "Hello World"}
```

Mira las similitudes entre `requests.get(...)` y `@app.get(...)`.

/// check | InspirÃ³ a **FastAPI** a

* Tener un API simple e intuitivo.
* Usar nombres de mÃ©todos HTTP (operaciones) directamente, de una manera sencilla e intuitiva.
* Tener valores predeterminados sensatos, pero personalizaciones poderosas.

///

### <a href="https://swagger.io/" class="external-link" target="_blank">Swagger</a> / <a href="https://github.com/OAI/OpenAPI-Specification/" class="external-link" target="_blank">OpenAPI</a>

La principal funcionalidad que querÃ­a de Django REST Framework era la documentaciÃ³n automÃ¡tica de la API.

Luego descubrÃ­ que habÃ­a un estÃ¡ndar para documentar APIs, usando JSON (o YAML, una extensiÃ³n de JSON) llamado Swagger.

Y ya existÃ­a una interfaz de usuario web para las APIs Swagger. Por lo tanto, ser capaz de generar documentaciÃ³n Swagger para una API permitirÃ­a usar esta interfaz de usuario web automÃ¡ticamente.

En algÃºn punto, Swagger fue entregado a la Linux Foundation, para ser renombrado OpenAPI.

Es por eso que cuando se habla de la versiÃ³n 2.0 es comÃºn decir "Swagger", y para la versiÃ³n 3+ "OpenAPI".

/// check | InspirÃ³ a **FastAPI** a

Adoptar y usar un estÃ¡ndar abierto para especificaciones de API, en lugar de usar un esquema personalizado.

Y a integrar herramientas de interfaz de usuario basadas en estÃ¡ndares:

* <a href="https://github.com/swagger-api/swagger-ui" class="external-link" target="_blank">Swagger UI</a>
* <a href="https://github.com/Rebilly/ReDoc" class="external-link" target="_blank">ReDoc</a>

Estas dos fueron elegidas por ser bastante populares y estables, pero haciendo una bÃºsqueda rÃ¡pida, podrÃ­as encontrar docenas de interfaces de usuario alternativas para OpenAPI (que puedes usar con **FastAPI**).

///

### Frameworks REST para Flask

Existen varios frameworks REST para Flask, pero despuÃ©s de invertir tiempo y trabajo investigÃ¡ndolos, encontrÃ© que muchos son descontinuados o abandonados, con varios problemas existentes que los hacÃ­an inadecuados.

### <a href="https://marshmallow.readthedocs.io/en/stable/" class="external-link" target="_blank">Marshmallow</a>

Una de las principales funcionalidades necesitadas por los sistemas API es la "<abbr title="tambiÃ©n llamada marshalling, conversiÃ³n">serializaciÃ³n</abbr>" de datos, que consiste en tomar datos del cÃ³digo (Python) y convertirlos en algo que pueda ser enviado a travÃ©s de la red. Por ejemplo, convertir un objeto que contiene datos de una base de datos en un objeto JSON. Convertir objetos `datetime` en strings, etc.

Otra gran funcionalidad necesaria por las APIs es la validaciÃ³n de datos, asegurarse de que los datos sean vÃ¡lidos, dados ciertos parÃ¡metros. Por ejemplo, que algÃºn campo sea un `int`, y no algÃºn string aleatorio. Esto es especialmente Ãºtil para los datos entrantes.

Sin un sistema de validaciÃ³n de datos, tendrÃ­as que hacer todas las comprobaciones a mano, en cÃ³digo.

Estas funcionalidades son para lo que fue creado Marshmallow. Es un gran paquete, y lo he usado mucho antes.

Pero fue creado antes de que existieran las anotaciones de tipos en Python. AsÃ­ que, para definir cada <abbr title="la definiciÃ³n de cÃ³mo deberÃ­an formarse los datos">esquema</abbr> necesitas usar utilidades y clases especÃ­ficas proporcionadas por Marshmallow.

/// check | InspirÃ³ a **FastAPI** a

Usar cÃ³digo para definir "esquemas" que proporcionen tipos de datos y validaciÃ³n automÃ¡ticamente.

///

### <a href="https://webargs.readthedocs.io/en/latest/" class="external-link" target="_blank">Webargs</a>

Otra gran funcionalidad requerida por las APIs es el <abbr title="lectura y conversiÃ³n a datos de Python">parse</abbr> de datos de las requests entrantes.

Webargs es una herramienta que fue creada para proporcionar esa funcionalidad sobre varios frameworks, incluido Flask.

Usa Marshmallow por debajo para hacer la validaciÃ³n de datos. Y fue creada por los mismos desarrolladores.

Es una gran herramienta y la he usado mucho tambiÃ©n, antes de tener **FastAPI**.

/// info | InformaciÃ³n

Webargs fue creada por los mismos desarrolladores de Marshmallow.

///

/// check | InspirÃ³ a **FastAPI** a

Tener validaciÃ³n automÃ¡tica de datos entrantes en una request.

///

### <a href="https://apispec.readthedocs.io/en/stable/" class="external-link" target="_blank">APISpec</a>

Marshmallow y Webargs proporcionan validaciÃ³n, parse y serializaciÃ³n como plug-ins.

Pero la documentaciÃ³n todavÃ­a falta. Entonces APISpec fue creado.

Es un plug-in para muchos frameworks (y hay un plug-in para Starlette tambiÃ©n).

La manera en que funciona es que escribes la definiciÃ³n del esquema usando el formato YAML dentro del docstring de cada funciÃ³n que maneja una ruta.

Y genera esquemas OpenAPI.

AsÃ­ es como funciona en Flask, Starlette, Responder, etc.

Pero luego, tenemos otra vez el problema de tener una micro-sintaxis, dentro de un string de Python (un gran YAML).

El editor no puede ayudar mucho con eso. Y si modificamos parÃ¡metros o esquemas de Marshmallow y olvidamos tambiÃ©n modificar ese docstring YAML, el esquema generado estarÃ­a obsoleto.

/// info | InformaciÃ³n

APISpec fue creado por los mismos desarrolladores de Marshmallow.

///

/// check | InspirÃ³ a **FastAPI** a

Soportar el estÃ¡ndar abierto para APIs, OpenAPI.

///

### <a href="https://flask-apispec.readthedocs.io/en/latest/" class="external-link" target="_blank">Flask-apispec</a>

Es un plug-in de Flask, que conecta juntos Webargs, Marshmallow y APISpec.

Usa la informaciÃ³n de Webargs y Marshmallow para generar automÃ¡ticamente esquemas OpenAPI, usando APISpec.

Es una gran herramienta, muy subestimada. DeberÃ­a ser mucho mÃ¡s popular que muchos plug-ins de Flask por ahÃ­. Puede que se deba a que su documentaciÃ³n es demasiado concisa y abstracta.

Esto resolviÃ³ tener que escribir YAML (otra sintaxis) dentro de docstrings de Python.

Esta combinaciÃ³n de Flask, Flask-apispec con Marshmallow y Webargs fue mi stack de backend favorito hasta construir **FastAPI**.

Usarlo llevÃ³ a la creaciÃ³n de varios generadores de full-stack para Flask. Estos son los principales stacks que yo (y varios equipos externos) hemos estado usando hasta ahora:

* <a href="https://github.com/tiangolo/full-stack" class="external-link" target="_blank">https://github.com/tiangolo/full-stack</a>
* <a href="https://github.com/tiangolo/full-stack-flask-couchbase" class="external-link" target="_blank">https://github.com/tiangolo/full-stack-flask-couchbase</a>
* <a href="https://github.com/tiangolo/full-stack-flask-couchdb" class="external-link" target="_blank">https://github.com/tiangolo/full-stack-flask-couchdb</a>

Y estos mismos generadores de full-stack fueron la base de los [Generadores de Proyectos **FastAPI**](project-generation.md){.internal-link target=_blank}.

/// info | InformaciÃ³n

Flask-apispec fue creado por los mismos desarrolladores de Marshmallow.

///

/// check | InspirÃ³ a **FastAPI** a

Generar el esquema OpenAPI automÃ¡ticamente, desde el mismo cÃ³digo que define la serializaciÃ³n y validaciÃ³n.

///

### <a href="https://nestjs.com/" class="external-link" target="_blank">NestJS</a> (y <a href="https://angular.io/" class="external-link" target="_blank">Angular</a>)

Esto ni siquiera es Python, NestJS es un framework de JavaScript (TypeScript) NodeJS inspirado por Angular.

Logra algo algo similar a lo que se puede hacer con Flask-apispec.

Tiene un sistema de inyecciÃ³n de dependencias integrado, inspirado por Angular 2. Requiere pre-registrar los "inyectables" (como todos los otros sistemas de inyecciÃ³n de dependencias que conozco), por lo que aÃ±ade a la verbosidad y repeticiÃ³n de cÃ³digo.

Como los parÃ¡metros se describen con tipos de TypeScript (similar a las anotaciones de tipos en Python), el soporte editorial es bastante bueno.

Pero como los datos de TypeScript no se preservan despuÃ©s de la compilaciÃ³n a JavaScript, no puede depender de los tipos para definir validaciÃ³n, serializaciÃ³n y documentaciÃ³n al mismo tiempo. Debido a esto y algunas decisiones de diseÃ±o, para obtener validaciÃ³n, serializaciÃ³n y generaciÃ³n automÃ¡tica del esquema, es necesario agregar decoradores en muchos lugares. Por lo tanto, se vuelve bastante verboso.

No puede manejar muy bien modelos anidados. Entonces, si el cuerpo JSON en la request es un objeto JSON que tiene campos internos que a su vez son objetos JSON anidados, no puede ser documentado y validado apropiadamente.

/// check | InspirÃ³ a **FastAPI** a

Usar tipos de Python para tener un gran soporte del editor.

Tener un poderoso sistema de inyecciÃ³n de dependencias. Encontrar una forma de minimizar la repeticiÃ³n de cÃ³digo.

///

### <a href="https://sanic.readthedocs.io/en/latest/" class="external-link" target="_blank">Sanic</a>

Fue uno de los primeros frameworks de Python extremadamente rÃ¡pidos basados en `asyncio`. Fue hecho para ser muy similar a Flask.

/// note | Detalles TÃ©cnicos

UsÃ³ <a href="https://github.com/MagicStack/uvloop" class="external-link" target="_blank">`uvloop`</a> en lugar del loop `asyncio` por defecto de Python. Eso fue lo que lo hizo tan rÃ¡pido.

Claramente inspirÃ³ a Uvicorn y Starlette, que actualmente son mÃ¡s rÃ¡pidos que Sanic en benchmarks abiertos.

///

/// check | InspirÃ³ a **FastAPI** a

Encontrar una manera de tener un rendimiento impresionante.

Por eso **FastAPI** se basa en Starlette, ya que es el framework mÃ¡s rÃ¡pido disponible (probado por benchmarks de terceros).

///

### <a href="https://falconframework.org/" class="external-link" target="_blank">Falcon</a>

Falcon es otro framework de Python de alto rendimiento, estÃ¡ diseÃ±ado para ser minimalista y funcionar como la base de otros frameworks como Hug.

EstÃ¡ diseÃ±ado para tener funciones que reciben dos parÃ¡metros, un "request" y un "response". Luego "lees" partes del request y "escribes" partes en el response. Debido a este diseÃ±o, no es posible declarar parÃ¡metros de request y cuerpos con las anotaciones de tipos estÃ¡ndar de Python como parÃ¡metros de funciÃ³n.

Por lo tanto, la validaciÃ³n de datos, la serializaciÃ³n y la documentaciÃ³n, tienen que hacerse en cÃ³digo, no automÃ¡ticamente. O tienen que implementarse como un framework sobre Falcon, como Hug. Esta misma distinciÃ³n ocurre en otros frameworks que se inspiran en el diseÃ±o de Falcon, de tener un objeto request y un objeto response como parÃ¡metros.

/// check | InspirÃ³ a **FastAPI** a

Buscar maneras de obtener un gran rendimiento.

Junto con Hug (ya que Hug se basa en Falcon), inspiraron a **FastAPI** a declarar un parÃ¡metro `response` en las funciones.

Aunque en FastAPI es opcional, y se utiliza principalmente para configurar headers, cookies y cÃ³digos de estado alternativos.

///

### <a href="https://moltenframework.com/" class="external-link" target="_blank">Molten</a>

DescubrÃ­ Molten en las primeras etapas de construcciÃ³n de **FastAPI**. Y tiene ideas bastante similares:

* Basado en las anotaciones de tipos de Python.
* ValidaciÃ³n y documentaciÃ³n a partir de estos tipos.
* Sistema de InyecciÃ³n de Dependencias.

No utiliza un paquete de validaciÃ³n de datos, serializaciÃ³n y documentaciÃ³n de terceros como Pydantic, tiene el suyo propio. Por lo tanto, estas definiciones de tipos de datos no serÃ­an reutilizables tan fÃ¡cilmente.

Requiere configuraciones un poquito mÃ¡s verbosas. Y dado que se basa en WSGI (en lugar de ASGI), no estÃ¡ diseÃ±ado para aprovechar el alto rendimiento proporcionado por herramientas como Uvicorn, Starlette y Sanic.

El sistema de inyecciÃ³n de dependencias requiere pre-registrar las dependencias y las dependencias se resuelven en base a los tipos declarados. Por lo tanto, no es posible declarar mÃ¡s de un "componente" que proporcione cierto tipo.

Las rutas se declaran en un solo lugar, usando funciones declaradas en otros lugares (en lugar de usar decoradores que pueden colocarse justo encima de la funciÃ³n que maneja el endpoint). Esto se acerca mÃ¡s a cÃ³mo lo hace Django que a cÃ³mo lo hace Flask (y Starlette). Separa en el cÃ³digo cosas que estÃ¡n relativamente acopladas.

/// check | InspirÃ³ a **FastAPI** a

Definir validaciones extra para tipos de datos usando el valor "default" de los atributos del modelo. Esto mejora el soporte del editor y no estaba disponible en Pydantic antes.

Esto en realidad inspirÃ³ la actualizaciÃ³n de partes de Pydantic, para soportar el mismo estilo de declaraciÃ³n de validaciÃ³n (toda esta funcionalidad ya estÃ¡ disponible en Pydantic).

///

### <a href="https://github.com/hugapi/hug" class="external-link" target="_blank">Hug</a>

Hug fue uno de los primeros frameworks en implementar la declaraciÃ³n de tipos de parÃ¡metros API usando las anotaciones de tipos de Python. Esta fue una gran idea que inspirÃ³ a otras herramientas a hacer lo mismo.

Usaba tipos personalizados en sus declaraciones en lugar de tipos estÃ¡ndar de Python, pero aÃºn asÃ­ fue un gran avance.

TambiÃ©n fue uno de los primeros frameworks en generar un esquema personalizado declarando toda la API en JSON.

No se basaba en un estÃ¡ndar como OpenAPI y JSON Schema. Por lo que no serÃ­a sencillo integrarlo con otras herramientas, como Swagger UI. Pero, nuevamente, fue una idea muy innovadora.

Tiene una funcionalidad interesante e inusual: usando el mismo framework, es posible crear APIs y tambiÃ©n CLIs.

Dado que se basa en el estÃ¡ndar previo para frameworks web Python sincrÃ³nicos (WSGI), no puede manejar Websockets y otras cosas, aunque aÃºn asÃ­ tiene un alto rendimiento tambiÃ©n.

/// info | InformaciÃ³n

Hug fue creado por Timothy Crosley, el mismo creador de <a href="https://github.com/timothycrosley/isort" class="external-link" target="_blank">`isort`</a>, una gran herramienta para ordenar automÃ¡ticamente imports en archivos Python.

///

/// check | Ideas que inspiraron a **FastAPI**

Hug inspirÃ³ partes de APIStar, y fue una de las herramientas que encontrÃ© mÃ¡s prometedoras, junto a APIStar.

Hug ayudÃ³ a inspirar a **FastAPI** a usar anotaciones de tipos de Python para declarar parÃ¡metros, y a generar un esquema definiendo la API automÃ¡ticamente.

Hug inspirÃ³ a **FastAPI** a declarar un parÃ¡metro `response` en funciones para configurar headers y cookies.

///

### <a href="https://github.com/encode/apistar" class="external-link" target="_blank">APIStar</a> (<= 0.5)

Justo antes de decidir construir **FastAPI** encontrÃ© **APIStar** server. TenÃ­a casi todo lo que estaba buscando y tenÃ­a un gran diseÃ±o.

Era una de las primeras implementaciones de un framework utilizando las anotaciones de tipos de Python para declarar parÃ¡metros y requests que jamÃ¡s vi (antes de NestJS y Molten). Lo encontrÃ© mÃ¡s o menos al mismo tiempo que Hug. Pero APIStar usaba el estÃ¡ndar OpenAPI.

TenÃ­a validaciÃ³n de datos automÃ¡tica, serializaciÃ³n de datos y generaciÃ³n del esquema OpenAPI basada en las mismas anotaciones de tipos en varios lugares.

Las definiciones de esquema de cuerpo no usaban las mismas anotaciones de tipos de Python como Pydantic, era un poco mÃ¡s similar a Marshmallow, por lo que el soporte del editor no serÃ­a tan bueno, pero aÃºn asÃ­, APIStar era la mejor opciÃ³n disponible.

TenÃ­a los mejores benchmarks de rendimiento en ese momento (solo superado por Starlette).

Al principio, no tenÃ­a una interfaz de usuario web de documentaciÃ³n de API automÃ¡tica, pero sabÃ­a que podÃ­a agregar Swagger UI a Ã©l.

TenÃ­a un sistema de inyecciÃ³n de dependencias. RequerÃ­a pre-registrar componentes, como otras herramientas discutidas anteriormente. Pero aÃºn asÃ­, era una gran funcionalidad.

Nunca pude usarlo en un proyecto completo, ya que no tenÃ­a integraciÃ³n de seguridad, por lo que no podÃ­a reemplazar todas las funcionalidades que tenÃ­a con los generadores de full-stack basados en Flask-apispec. TenÃ­a en mi lista de tareas pendientes de proyectos crear un pull request agregando esa funcionalidad.

Pero luego, el enfoque del proyecto cambiÃ³.

Ya no era un framework web API, ya que el creador necesitaba enfocarse en Starlette.

Ahora APIStar es un conjunto de herramientas para validar especificaciones OpenAPI, no un framework web.

/// info | InformaciÃ³n

APIStar fue creado por Tom Christie. El mismo que creÃ³:

* Django REST Framework
* Starlette (en la cual **FastAPI** estÃ¡ basado)
* Uvicorn (usado por Starlette y **FastAPI**)

///

/// check | InspirÃ³ a **FastAPI** a

Existir.

La idea de declarar mÃºltiples cosas (validaciÃ³n de datos, serializaciÃ³n y documentaciÃ³n) con los mismos tipos de Python, que al mismo tiempo proporcionaban un gran soporte del editor, era algo que considerÃ© una idea brillante.

Y despuÃ©s de buscar durante mucho tiempo un framework similar y probar muchas alternativas diferentes, APIStar fue la mejor opciÃ³n disponible.

Luego APIStar dejÃ³ de existir como servidor y Starlette fue creado, y fue una nueva y mejor base para tal sistema. Esa fue la inspiraciÃ³n final para construir **FastAPI**.

Considero a **FastAPI** un "sucesor espiritual" de APIStar, mientras mejora y aumenta las funcionalidades, el sistema de tipos y otras partes, basÃ¡ndose en los aprendizajes de todas estas herramientas previas.

///

## Usado por **FastAPI**

### <a href="https://docs.pydantic.dev/" class="external-link" target="_blank">Pydantic</a>

Pydantic es un paquete para definir validaciÃ³n de datos, serializaciÃ³n y documentaciÃ³n (usando JSON Schema) basÃ¡ndose en las anotaciones de tipos de Python.

Eso lo hace extremadamente intuitivo.

Es comparable a Marshmallow. Aunque es mÃ¡s rÃ¡pido que Marshmallow en benchmarks. Y como estÃ¡ basado en las mismas anotaciones de tipos de Python, el soporte del editor es estupendo.

/// check | **FastAPI** lo usa para

Manejar toda la validaciÃ³n de datos, serializaciÃ³n de datos y documentaciÃ³n automÃ¡tica de modelos (basada en JSON Schema).

**FastAPI** luego toma esos datos JSON Schema y los coloca en OpenAPI, aparte de todas las otras cosas que hace.

///

### <a href="https://www.starlette.io/" class="external-link" target="_blank">Starlette</a>

Starlette es un framework/toolkit <abbr title="El nuevo estÃ¡ndar para construir aplicaciones web asÃ­ncronas en Python">ASGI</abbr> liviano, ideal para construir servicios asyncio de alto rendimiento.

Es muy simple e intuitivo. EstÃ¡ diseÃ±ado para ser fÃ¡cilmente extensible y tener componentes modulares.

Tiene:

* Un rendimiento seriamente impresionante.
* Soporte para WebSocket.
* Tareas en segundo plano dentro del proceso.
* Eventos de inicio y apagado.
* Cliente de pruebas basado en HTTPX.
* CORS, GZip, Archivos estÃ¡ticos, Responses en streaming.
* Soporte para sesiones y cookies.
* Cobertura de tests del 100%.
* Base de cÃ³digo 100% tipada.
* Pocas dependencias obligatorias.

Starlette es actualmente el framework de Python mÃ¡s rÃ¡pido probado. Solo superado por Uvicorn, que no es un framework, sino un servidor.

Starlette proporciona toda la funcionalidad bÃ¡sica de un microframework web.

Pero no proporciona validaciÃ³n de datos automÃ¡tica, serializaciÃ³n o documentaciÃ³n.

Esa es una de las principales cosas que **FastAPI** agrega, todo basado en las anotaciones de tipos de Python (usando Pydantic). Eso, ademÃ¡s del sistema de inyecciÃ³n de dependencias, utilidades de seguridad, generaciÃ³n de esquemas OpenAPI, etc.

/// note | Detalles TÃ©cnicos

ASGI es un nuevo "estÃ¡ndar" que estÃ¡ siendo desarrollado por miembros del equipo central de Django. TodavÃ­a no es un "estÃ¡ndar de Python" (un PEP), aunque estÃ¡n en proceso de hacerlo.

No obstante, ya estÃ¡ siendo usado como un "estÃ¡ndar" por varias herramientas. Esto mejora enormemente la interoperabilidad, ya que podrÃ­as cambiar Uvicorn por cualquier otro servidor ASGI (como Daphne o Hypercorn), o podrÃ­as aÃ±adir herramientas compatibles con ASGI, como `python-socketio`.

///

/// check | **FastAPI** lo usa para

Manejar todas las partes web centrales. AÃ±adiendo funcionalidades encima.

La clase `FastAPI` en sÃ­ misma hereda directamente de la clase `Starlette`.

Por lo tanto, cualquier cosa que puedas hacer con Starlette, puedes hacerlo directamente con **FastAPI**, ya que es bÃ¡sicamente Starlette potenciado.

///

### <a href="https://www.uvicorn.org/" class="external-link" target="_blank">Uvicorn</a>

Uvicorn es un servidor ASGI extremadamente rÃ¡pido, construido sobre uvloop y httptools.

No es un framework web, sino un servidor. Por ejemplo, no proporciona herramientas para el enrutamiento por paths. Eso es algo que un framework como Starlette (o **FastAPI**) proporcionarÃ­a encima.

Es el servidor recomendado para Starlette y **FastAPI**.

/// check | **FastAPI** lo recomienda como

El servidor web principal para ejecutar aplicaciones **FastAPI**.

TambiÃ©n puedes usar la opciÃ³n de lÃ­nea de comandos `--workers` para tener un servidor multiproceso asÃ­ncrono.

Revisa mÃ¡s detalles en la secciÃ³n [Despliegue](deployment/index.md){.internal-link target=_blank}.

///

## Benchmarks y velocidad

Para entender, comparar, y ver la diferencia entre Uvicorn, Starlette y FastAPI, revisa la secciÃ³n sobre [Benchmarks](benchmarks.md){.internal-link target=_blank}.


================================================
File: /docs/es/docs/async.md
================================================
# Concurrencia y async / await

Detalles sobre la sintaxis `async def` para *path operation functions* y algunos antecedentes sobre el cÃ³digo asÃ­ncrono, la concurrencia y el paralelismo.

## Â¿Con prisa?

<abbr title="too long; didn't read"><strong>TL;DR:</strong></abbr>

Si estÃ¡s usando paquetes de terceros que te dicen que los llames con `await`, como:

```Python
results = await some_library()
```

Entonces, declara tus *path operation functions* con `async def` asÃ­:

```Python hl_lines="2"
@app.get('/')
async def read_results():
    results = await some_library()
    return results
```

/// note | Nota

Solo puedes usar `await` dentro de funciones creadas con `async def`.

///

---

Si estÃ¡s usando un paquete de terceros que se comunica con algo (una base de datos, una API, el sistema de archivos, etc.) y no tiene soporte para usar `await` (este es actualmente el caso para la mayorÃ­a de los paquetes de base de datos), entonces declara tus *path operation functions* como normalmente, usando simplemente `def`, asÃ­:

```Python hl_lines="2"
@app.get('/')
def results():
    results = some_library()
    return results
```

---

Si tu aplicaciÃ³n (de alguna manera) no tiene que comunicarse con nada mÃ¡s y esperar a que responda, usa `async def`.

---

Si simplemente no lo sabes, usa `def` normal.

---

**Nota**: Puedes mezclar `def` y `async def` en tus *path operation functions* tanto como necesites y definir cada una utilizando la mejor opciÃ³n para ti. FastAPI harÃ¡ lo correcto con ellas.

De todos modos, en cualquiera de los casos anteriores, FastAPI seguirÃ¡ funcionando de forma asÃ­ncrona y serÃ¡ extremadamente rÃ¡pido.

Pero al seguir los pasos anteriores, podrÃ¡ hacer algunas optimizaciones de rendimiento.

## Detalles TÃ©cnicos

Las versiones modernas de Python tienen soporte para **"cÃ³digo asÃ­ncrono"** utilizando algo llamado **"coroutines"**, con la sintaxis **`async` y `await`**.

Veamos esa frase por partes en las secciones a continuaciÃ³n:

* **CÃ³digo AsÃ­ncrono**
* **`async` y `await`**
* **Coroutines**

## CÃ³digo AsÃ­ncrono

El cÃ³digo asÃ­ncrono simplemente significa que el lenguaje ðŸ’¬ tiene una forma de decirle a la computadora / programa ðŸ¤– que en algÃºn momento del cÃ³digo, tendrÃ¡ que esperar que *otra cosa* termine en otro lugar. Digamos que esa *otra cosa* se llama "archivo-lento" ðŸ“.

Entonces, durante ese tiempo, la computadora puede ir y hacer algÃºn otro trabajo, mientras "archivo-lento" ðŸ“ termina.

Luego la computadora / programa ðŸ¤– volverÃ¡ cada vez que tenga una oportunidad porque estÃ¡ esperando nuevamente, o siempre que ðŸ¤– haya terminado todo el trabajo que tenÃ­a en ese punto. Y ðŸ¤– comprobarÃ¡ si alguna de las tareas que estaba esperando ya se han completado, haciendo lo que tenÃ­a que hacer.

DespuÃ©s, ðŸ¤– toma la primera tarea que termine (digamos, nuestro "archivo-lento" ðŸ“) y continÃºa con lo que tenÃ­a que hacer con ella.

Ese "esperar otra cosa" normalmente se refiere a las operaciones de <abbr title="Input and Output">I/O</abbr> que son relativamente "lentas" (comparadas con la velocidad del procesador y la memoria RAM), como esperar:

* que los datos del cliente se envÃ­en a travÃ©s de la red
* que los datos enviados por tu programa sean recibidos por el cliente a travÃ©s de la red
* que el contenido de un archivo en el disco sea leÃ­do por el sistema y entregado a tu programa
* que el contenido que tu programa entregÃ³ al sistema sea escrito en el disco
* una operaciÃ³n de API remota
* que una operaciÃ³n de base de datos termine
* que una query de base de datos devuelva los resultados
* etc.

Como el tiempo de ejecuciÃ³n se consume principalmente esperando operaciones de <abbr title="Input and Output">I/O</abbr>, las llaman operaciones "I/O bound".

Se llama "asÃ­ncrono" porque la computadora / programa no tiene que estar "sincronizado" con la tarea lenta, esperando el momento exacto en que la tarea termine, sin hacer nada, para poder tomar el resultado de la tarea y continuar el trabajo.

En lugar de eso, al ser un sistema "asÃ­ncrono", una vez terminado, la tarea puede esperar un poco en la cola (algunos microsegundos) para que la computadora / programa termine lo que saliÃ³ a hacer, y luego regrese para tomar los resultados y continuar trabajando con ellos.

Para el "sincrÃ³nico" (contrario al "asÃ­ncrono") comÃºnmente tambiÃ©n usan el tÃ©rmino "secuencial", porque la computadora / programa sigue todos los pasos en secuencia antes de cambiar a una tarea diferente, incluso si esos pasos implican esperar.

### Concurrencia y Hamburguesas

Esta idea de cÃ³digo **asÃ­ncrono** descrita anteriormente a veces tambiÃ©n se llama **"concurrencia"**. Es diferente del **"paralelismo"**.

**Concurrencia** y **paralelismo** ambos se relacionan con "diferentes cosas sucediendo mÃ¡s o menos al mismo tiempo".

Pero los detalles entre *concurrencia* y *paralelismo* son bastante diferentes.

Para ver la diferencia, imagina la siguiente historia sobre hamburguesas:

### Hamburguesas Concurrentes

Vas con tu crush a conseguir comida rÃ¡pida, te pones en fila mientras el cajero toma los pedidos de las personas frente a ti. ðŸ˜

<img src="/img/async/concurrent-burgers/concurrent-burgers-01.png" class="illustration">

Luego es tu turno, haces tu pedido de 2 hamburguesas muy sofisticadas para tu crush y para ti. ðŸ”ðŸ”

<img src="/img/async/concurrent-burgers/concurrent-burgers-02.png" class="illustration">

El cajero dice algo al cocinero en la cocina para que sepan que tienen que preparar tus hamburguesas (aunque actualmente estÃ¡n preparando las de los clientes anteriores).

<img src="/img/async/concurrent-burgers/concurrent-burgers-03.png" class="illustration">

Pagas. ðŸ’¸

El cajero te da el nÃºmero de tu turno.

<img src="/img/async/concurrent-burgers/concurrent-burgers-04.png" class="illustration">

Mientras esperas, vas con tu crush y eliges una mesa, te sientas y hablas con tu crush por un largo rato (ya que tus hamburguesas son muy sofisticadas y toman un tiempo en prepararse).

Mientras estÃ¡s sentado en la mesa con tu crush, mientras esperas las hamburguesas, puedes pasar ese tiempo admirando lo increÃ­ble, lindo e inteligente que es tu crush âœ¨ðŸ˜âœ¨.

<img src="/img/async/concurrent-burgers/concurrent-burgers-05.png" class="illustration">

Mientras esperas y hablas con tu crush, de vez en cuando revisas el nÃºmero mostrado en el mostrador para ver si ya es tu turno.

Luego, en algÃºn momento, finalmente es tu turno. Vas al mostrador, obtienes tus hamburguesas y vuelves a la mesa.

<img src="/img/async/concurrent-burgers/concurrent-burgers-06.png" class="illustration">

TÃº y tu crush comen las hamburguesas y pasan un buen rato. âœ¨

<img src="/img/async/concurrent-burgers/concurrent-burgers-07.png" class="illustration">

/// info | InformaciÃ³n

Hermosas ilustraciones de <a href="https://www.instagram.com/ketrinadrawsalot" class="external-link" target="_blank">Ketrina Thompson</a>. ðŸŽ¨

///

---

Imagina que eres la computadora / programa ðŸ¤– en esa historia.

Mientras estÃ¡s en la fila, estÃ¡s inactivo ðŸ˜´, esperando tu turno, sin hacer nada muy "productivo". Pero la fila es rÃ¡pida porque el cajero solo estÃ¡ tomando los pedidos (no preparÃ¡ndolos), asÃ­ que estÃ¡ bien.

Luego, cuando es tu turno, haces un trabajo realmente "productivo", procesas el menÃº, decides lo que quieres, obtienes la elecciÃ³n de tu crush, pagas, verificas que das el billete o tarjeta correctos, verificas que te cobren correctamente, verificas que el pedido tenga los artÃ­culos correctos, etc.

Pero luego, aunque todavÃ­a no tienes tus hamburguesas, tu trabajo con el cajero estÃ¡ "en pausa" â¸, porque tienes que esperar ðŸ•™ a que tus hamburguesas estÃ©n listas.

Pero como te alejas del mostrador y te sientas en la mesa con un nÃºmero para tu turno, puedes cambiar ðŸ”€ tu atenciÃ³n a tu crush, y "trabajar" â¯ ðŸ¤“ en eso. Luego, nuevamente estÃ¡s haciendo algo muy "productivo" como es coquetear con tu crush ðŸ˜.

Luego el cajero ðŸ’ dice "he terminado de hacer las hamburguesas" al poner tu nÃºmero en el mostrador, pero no saltas como loco inmediatamente cuando el nÃºmero mostrado cambia a tu nÃºmero de turno. Sabes que nadie robarÃ¡ tus hamburguesas porque tienes el nÃºmero de tu turno, y ellos tienen el suyo.

AsÃ­ que esperas a que tu crush termine la historia (termine el trabajo â¯ / tarea actual que se estÃ¡ procesando ðŸ¤“), sonrÃ­es amablemente y dices que vas por las hamburguesas â¸.

Luego vas al mostrador ðŸ”€, a la tarea inicial que ahora estÃ¡ terminada â¯, recoges las hamburguesas, das las gracias y las llevas a la mesa. Eso termina ese paso / tarea de interacciÃ³n con el mostrador â¹. Eso a su vez, crea una nueva tarea, de "comer hamburguesas" ðŸ”€ â¯, pero la anterior de "obtener hamburguesas" ha terminado â¹.

### Hamburguesas Paralelas

Ahora imaginemos que estas no son "Hamburguesas Concurrentes", sino "Hamburguesas Paralelas".

Vas con tu crush a obtener comida rÃ¡pida paralela.

Te pones en fila mientras varios (digamos 8) cajeros que al mismo tiempo son cocineros toman los pedidos de las personas frente a ti.

Todos antes que tÃº estÃ¡n esperando a que sus hamburguesas estÃ©n listas antes de dejar el mostrador porque cada uno de los 8 cajeros va y prepara la hamburguesa de inmediato antes de obtener el siguiente pedido.

<img src="/img/async/parallel-burgers/parallel-burgers-01.png" class="illustration">

Luego, finalmente es tu turno, haces tu pedido de 2 hamburguesas muy sofisticadas para tu crush y para ti.

Pagas ðŸ’¸.

<img src="/img/async/parallel-burgers/parallel-burgers-02.png" class="illustration">

El cajero va a la cocina.

Esperas, de pie frente al mostrador ðŸ•™, para que nadie mÃ¡s tome tus hamburguesas antes que tÃº, ya que no hay nÃºmeros para los turnos.

<img src="/img/async/parallel-burgers/parallel-burgers-03.png" class="illustration">

Como tÃº y tu crush estÃ¡n ocupados no dejando que nadie se interponga y tome tus hamburguesas cuando lleguen, no puedes prestar atenciÃ³n a tu crush. ðŸ˜ž

Este es un trabajo "sincrÃ³nico", estÃ¡s "sincronizado" con el cajero/cocinero ðŸ‘¨â€ðŸ³. Tienes que esperar ðŸ•™ y estar allÃ­ en el momento exacto en que el cajero/cocinero ðŸ‘¨â€ðŸ³ termine las hamburguesas y te las entregue, o de lo contrario, alguien mÃ¡s podrÃ­a tomarlas.

<img src="/img/async/parallel-burgers/parallel-burgers-04.png" class="illustration">

Luego tu cajero/cocinero ðŸ‘¨â€ðŸ³ finalmente regresa con tus hamburguesas, despuÃ©s de mucho tiempo esperando ðŸ•™ allÃ­ frente al mostrador.

<img src="/img/async/parallel-burgers/parallel-burgers-05.png" class="illustration">

Tomas tus hamburguesas y vas a la mesa con tu crush.

Simplemente las comes, y has terminado. â¹

<img src="/img/async/parallel-burgers/parallel-burgers-06.png" class="illustration">

No hubo mucho hablar o coquetear ya que la mayor parte del tiempo se dedicÃ³ a esperar ðŸ•™ frente al mostrador. ðŸ˜ž

/// info | InformaciÃ³n

Hermosas ilustraciones de <a href="https://www.instagram.com/ketrinadrawsalot" class="external-link" target="_blank">Ketrina Thompson</a>. ðŸŽ¨

///

---

En este escenario de las hamburguesas paralelas, eres una computadora / programa ðŸ¤– con dos procesadores (tÃº y tu crush), ambos esperando ðŸ•™ y dedicando su atenciÃ³n â¯ a estar "esperando en el mostrador" ðŸ•™ por mucho tiempo.

La tienda de comida rÃ¡pida tiene 8 procesadores (cajeros/cocineros). Mientras que la tienda de hamburguesas concurrentes podrÃ­a haber tenido solo 2 (un cajero y un cocinero).

Pero aÃºn asÃ­, la experiencia final no es la mejor. ðŸ˜ž

---

Esta serÃ­a la historia equivalente de las hamburguesas paralelas. ðŸ”

Para un ejemplo mÃ¡s "de la vida real" de esto, imagina un banco.

Hasta hace poco, la mayorÃ­a de los bancos tenÃ­an mÃºltiples cajeros ðŸ‘¨â€ðŸ’¼ðŸ‘¨â€ðŸ’¼ðŸ‘¨â€ðŸ’¼ðŸ‘¨â€ðŸ’¼ y una gran fila ðŸ•™ðŸ•™ðŸ•™ðŸ•™ðŸ•™ðŸ•™ðŸ•™ðŸ•™.

Todos los cajeros haciendo todo el trabajo con un cliente tras otro ðŸ‘¨â€ðŸ’¼â¯.

Y tienes que esperar ðŸ•™ en la fila por mucho tiempo o pierdes tu turno.

Probablemente no querrÃ­as llevar a tu crush ðŸ˜ contigo a hacer trÃ¡mites en el banco ðŸ¦.

### ConclusiÃ³n de las Hamburguesas

En este escenario de "hamburguesas de comida rÃ¡pida con tu crush", como hay mucha espera ðŸ•™, tiene mucho mÃ¡s sentido tener un sistema concurrente â¸ðŸ”€â¯.

Este es el caso para la mayorÃ­a de las aplicaciones web.

Muchos, muchos usuarios, pero tu servidor estÃ¡ esperando ðŸ•™ su conexiÃ³n no tan buena para enviar sus requests.

Y luego esperar ðŸ•™ nuevamente a que los responses retornen.

Esta "espera" ðŸ•™ se mide en microsegundos, pero aÃºn asÃ­, sumÃ¡ndolo todo, es mucha espera al final.

Por eso tiene mucho sentido usar cÃ³digo asÃ­ncrono â¸ðŸ”€â¯ para las APIs web.

Este tipo de asincronÃ­a es lo que hizo popular a NodeJS (aunque NodeJS no es paralelo) y esa es la fortaleza de Go como lenguaje de programaciÃ³n.

Y ese es el mismo nivel de rendimiento que obtienes con **FastAPI**.

Y como puedes tener paralelismo y asincronÃ­a al mismo tiempo, obtienes un mayor rendimiento que la mayorÃ­a de los frameworks de NodeJS probados y a la par con Go, que es un lenguaje compilado mÃ¡s cercano a C <a href="https://www.techempower.com/benchmarks/#section=data-r17&hw=ph&test=query&l=zijmkf-1" class="external-link" target="_blank">(todo gracias a Starlette)</a>.

### Â¿Es la concurrencia mejor que el paralelismo?

Â¡No! Esa no es la moraleja de la historia.

La concurrencia es diferente del paralelismo. Y es mejor en escenarios **especÃ­ficos** que implican mucha espera. Debido a eso, generalmente es mucho mejor que el paralelismo para el desarrollo de aplicaciones web. Pero no para todo.

AsÃ­ que, para equilibrar eso, imagina la siguiente historia corta:

> Tienes que limpiar una casa grande y sucia.

*SÃ­, esa es toda la historia*.

---

No hay esperas ðŸ•™ en ninguna parte, solo mucho trabajo por hacer, en mÃºltiples lugares de la casa.

PodrÃ­as tener turnos como en el ejemplo de las hamburguesas, primero la sala de estar, luego la cocina, pero como no estÃ¡s esperando ðŸ•™ nada, solo limpiando y limpiando, los turnos no afectarÃ­an nada.

TomarÃ­a la misma cantidad de tiempo terminar con o sin turnos (concurrencia) y habrÃ­as hecho la misma cantidad de trabajo.

Pero en este caso, si pudieras traer a los 8 ex-cajeros/cocineros/ahora-limpiadores, y cada uno de ellos (mÃ¡s tÃº) pudiera tomar una zona de la casa para limpiarla, podrÃ­as hacer todo el trabajo en **paralelo**, con la ayuda extra, y terminar mucho antes.

En este escenario, cada uno de los limpiadores (incluyÃ©ndote) serÃ­a un procesador, haciendo su parte del trabajo.

Y como la mayor parte del tiempo de ejecuciÃ³n se dedica al trabajo real (en lugar de esperar), y el trabajo en una computadora lo realiza una <abbr title="Central Processing Unit">CPU</abbr>, llaman a estos problemas "CPU bound".

---

Ejemplos comunes de operaciones limitadas por la CPU son cosas que requieren procesamiento matemÃ¡tico complejo.

Por ejemplo:

* **Procesamiento de audio** o **imÃ¡genes**.
* **VisiÃ³n por computadora**: una imagen estÃ¡ compuesta de millones de pÃ­xeles, cada pÃ­xel tiene 3 valores / colores, procesar eso normalmente requiere calcular algo en esos pÃ­xeles, todos al mismo tiempo.
* **Machine Learning**: normalmente requiere muchas multiplicaciones de "matrices" y "vectores". Piensa en una enorme hoja de cÃ¡lculo con nÃºmeros y multiplicando todos juntos al mismo tiempo.
* **Deep Learning**: este es un subcampo de Machine Learning, por lo tanto, se aplica lo mismo. Es solo que no hay una sola hoja de cÃ¡lculo de nÃºmeros para multiplicar, sino un enorme conjunto de ellas, y en muchos casos, usas un procesador especial para construir y / o usar esos modelos.

### Concurrencia + Paralelismo: Web + Machine Learning

Con **FastAPI** puedes aprovechar la concurrencia que es muy comÃºn para el desarrollo web (la misma atracciÃ³n principal de NodeJS).

Pero tambiÃ©n puedes explotar los beneficios del paralelismo y la multiprocesamiento (tener mÃºltiples procesos ejecutÃ¡ndose en paralelo) para cargas de trabajo **CPU bound** como las de los sistemas de Machine Learning.

Eso, mÃ¡s el simple hecho de que Python es el lenguaje principal para **Data Science**, Machine Learning y especialmente Deep Learning, hacen de FastAPI una muy buena opciÃ³n para APIs web de Data Science / Machine Learning y aplicaciones (entre muchas otras).

Para ver cÃ³mo lograr este paralelismo en producciÃ³n, consulta la secciÃ³n sobre [Deployment](deployment/index.md){.internal-link target=_blank}.

## `async` y `await`

Las versiones modernas de Python tienen una forma muy intuitiva de definir cÃ³digo asÃ­ncrono. Esto hace que se vea igual que el cÃ³digo "secuencial" normal y hace el "wait" por ti en los momentos adecuados.

Cuando hay una operaciÃ³n que requerirÃ¡ esperar antes de dar los resultados y tiene soporte para estas nuevas funcionalidades de Python, puedes programarlo asÃ­:

```Python
burgers = await get_burgers(2)
```

La clave aquÃ­ es el `await`. Dice a Python que tiene que esperar â¸ a que `get_burgers(2)` termine de hacer su cosa ðŸ•™ antes de almacenar los resultados en `burgers`. Con eso, Python sabrÃ¡ que puede ir y hacer algo mÃ¡s ðŸ”€ â¯ mientras tanto (como recibir otro request).

Para que `await` funcione, tiene que estar dentro de una funciÃ³n que soporte esta asincronÃ­a. Para hacer eso, solo declara la funciÃ³n con `async def`:

```Python hl_lines="1"
async def get_burgers(number: int):
    # Hacer algunas cosas asÃ­ncronas para crear las hamburguesas
    return burgers
```

...en lugar de `def`:

```Python hl_lines="2"
# Esto no es asÃ­ncrono
def get_sequential_burgers(number: int):
    # Hacer algunas cosas secuenciales para crear las hamburguesas
    return burgers
```

Con `async def`, Python sabe que, dentro de esa funciÃ³n, tiene que estar atento a las expresiones `await`, y que puede "pausar" â¸ la ejecuciÃ³n de esa funciÃ³n e ir a hacer algo mÃ¡s ðŸ”€ antes de regresar.

Cuando deseas llamar a una funciÃ³n `async def`, tienes que "await" dicha funciÃ³n. AsÃ­ que, esto no funcionarÃ¡:

```Python
# Esto no funcionarÃ¡, porque get_burgers fue definido con: async def
burgers = get_burgers(2)
```

---

AsÃ­ que, si estÃ¡s usando un paquete que te dice que puedes llamarlo con `await`, necesitas crear las *path operation functions* que lo usen con `async def`, como en:

```Python hl_lines="2-3"
@app.get('/burgers')
async def read_burgers():
    burgers = await get_burgers(2)
    return burgers
```

### MÃ¡s detalles tÃ©cnicos

PodrÃ­as haber notado que `await` solo se puede usar dentro de funciones definidas con `async def`.

Pero al mismo tiempo, las funciones definidas con `async def` deben ser "awaited". Por lo tanto, las funciones con `async def` solo se pueden llamar dentro de funciones definidas con `async def` tambiÃ©n.

Entonces, sobre el huevo y la gallina, Â¿cÃ³mo llamas a la primera funciÃ³n `async`?

Si estÃ¡s trabajando con **FastAPI** no tienes que preocuparte por eso, porque esa "primera" funciÃ³n serÃ¡ tu *path operation function*, y FastAPI sabrÃ¡ cÃ³mo hacer lo correcto.

Pero si deseas usar `async` / `await` sin FastAPI, tambiÃ©n puedes hacerlo.

### Escribe tu propio cÃ³digo async

Starlette (y **FastAPI**) estÃ¡n basados en <a href="https://anyio.readthedocs.io/en/stable/" class="external-link" target="_blank">AnyIO</a>, lo que lo hace compatible tanto con la librerÃ­a estÃ¡ndar de Python <a href="https://docs.python.org/3/library/asyncio-task.html" class="external-link" target="_blank">asyncio</a> como con <a href="https://trio.readthedocs.io/en/stable/" class="external-link" target="_blank">Trio</a>.

En particular, puedes usar directamente <a href="https://anyio.readthedocs.io/en/stable/" class="external-link" target="_blank">AnyIO</a> para tus casos de uso avanzados de concurrencia que requieran patrones mÃ¡s avanzados en tu propio cÃ³digo.

E incluso si no estuvieras usando FastAPI, tambiÃ©n podrÃ­as escribir tus propias aplicaciones asÃ­ncronas con <a href="https://anyio.readthedocs.io/en/stable/" class="external-link" target="_blank">AnyIO</a> para ser altamente compatibles y obtener sus beneficios (p.ej. *concurrencia estructurada*).

CreÃ© otro paquete sobre AnyIO, como una capa delgada, para mejorar un poco las anotaciones de tipos y obtener mejor **autocompletado**, **errores en lÃ­nea**, etc. TambiÃ©n tiene una introducciÃ³n amigable y tutorial para ayudarte a **entender** y escribir **tu propio cÃ³digo async**: <a href="https://asyncer.tiangolo.com/" class="external-link" target="_blank">Asyncer</a>. SerÃ­a particularmente Ãºtil si necesitas **combinar cÃ³digo async con regular** (bloqueante/sincrÃ³nico).

### Otras formas de cÃ³digo asÃ­ncrono

Este estilo de usar `async` y `await` es relativamente nuevo en el lenguaje.

Pero hace que trabajar con cÃ³digo asÃ­ncrono sea mucho mÃ¡s fÃ¡cil.

Esta misma sintaxis (o casi idÃ©ntica) tambiÃ©n se incluyÃ³ recientemente en las versiones modernas de JavaScript (en el Navegador y NodeJS).

Pero antes de eso, manejar el cÃ³digo asÃ­ncrono era mucho mÃ¡s complejo y difÃ­cil.

En versiones previas de Python, podrÃ­as haber usado hilos o <a href="https://www.gevent.org/" class="external-link" target="_blank">Gevent</a>. Pero el cÃ³digo es mucho mÃ¡s complejo de entender, depurar y razonar.

En versiones previas de NodeJS / JavaScript en el Navegador, habrÃ­as usado "callbacks". Lo que lleva al <a href="http://callbackhell.com/" class="external-link" target="_blank">callback hell</a>.

## Coroutines

**Coroutines** es simplemente el tÃ©rmino muy elegante para la cosa que devuelve una funciÃ³n `async def`. Python sabe que es algo parecido a una funciÃ³n, que puede comenzar y que terminarÃ¡ en algÃºn momento, pero que podrÃ­a pausar â¸ internamente tambiÃ©n, siempre que haya un `await` dentro de Ã©l.

Pero toda esta funcionalidad de usar cÃ³digo asÃ­ncrono con `async` y `await` a menudo se resume como utilizar "coroutines". Es comparable a la funcionalidad clave principal de Go, las "Goroutines".

## ConclusiÃ³n

Veamos la misma frase de arriba:

> Las versiones modernas de Python tienen soporte para **"cÃ³digo asÃ­ncrono"** utilizando algo llamado **"coroutines"**, con la sintaxis **`async` y `await`**.

Eso deberÃ­a tener mÃ¡s sentido ahora. âœ¨

Todo eso es lo que impulsa FastAPI (a travÃ©s de Starlette) y lo que hace que tenga un rendimiento tan impresionante.

## Detalles Muy TÃ©cnicos

/// warning | Advertencia

Probablemente puedas saltarte esto.

Estos son detalles muy tÃ©cnicos de cÃ³mo funciona **FastAPI** en su interior.

Si tienes bastante conocimiento tÃ©cnico (coroutines, hilos, bloqueo, etc.) y tienes curiosidad sobre cÃ³mo FastAPI maneja `async def` vs `def` normal, adelante.

///

### Funciones de *path operation*

Cuando declaras una *path operation function* con `def` normal en lugar de `async def`, se ejecuta en un threadpool externo que luego es esperado, en lugar de ser llamado directamente (ya que bloquearÃ­a el servidor).

Si vienes de otro framework async que no funciona de la manera descrita anteriormente y estÃ¡s acostumbrado a definir funciones de *path operation* solo de cÃ³mputo trivial con `def` normal para una pequeÃ±a ganancia de rendimiento (alrededor de 100 nanosegundos), ten en cuenta que en **FastAPI** el efecto serÃ­a bastante opuesto. En estos casos, es mejor usar `async def` a menos que tus *path operation functions* usen cÃ³digo que realice <abbr title="Input/Output: lectura o escritura en disco, comunicaciones de red.">I/O</abbr> de bloqueo.

Aun asÃ­, en ambas situaciones, es probable que **FastAPI** [siga siendo mÃ¡s rÃ¡pida](index.md#performance){.internal-link target=_blank} que (o al menos comparable a) tu framework anterior.

### Dependencias

Lo mismo aplica para las [dependencias](tutorial/dependencies/index.md){.internal-link target=_blank}. Si una dependencia es una funciÃ³n estÃ¡ndar `def` en lugar de `async def`, se ejecuta en el threadpool externo.

### Sub-dependencias

Puedes tener mÃºltiples dependencias y [sub-dependencias](tutorial/dependencies/sub-dependencies.md){.internal-link target=_blank} requiriÃ©ndose mutuamente (como parÃ¡metros de las definiciones de funciones), algunas de ellas podrÃ­an ser creadas con `async def` y algunas con `def` normal. Aun funcionarÃ¡, y las que fueron creadas con `def` normal serÃ­an llamadas en un hilo externo (del threadpool) en lugar de ser "awaited".

### Otras funciones de utilidad

Cualquier otra funciÃ³n de utilidad que llames directamente puede ser creada con `def` normal o `async def` y FastAPI no afectarÃ¡ la forma en que la llames.

Esto contrasta con las funciones que FastAPI llama por ti: *path operation functions* y dependencias.

Si tu funciÃ³n de utilidad es una funciÃ³n normal con `def`, serÃ¡ llamada directamente (como la escribas en tu cÃ³digo), no en un threadpool; si la funciÃ³n es creada con `async def` entonces deberÃ­as "await" por esa funciÃ³n cuando la llames en tu cÃ³digo.

---

Nuevamente, estos son detalles muy tÃ©cnicos que probablemente serÃ­an Ãºtiles si los buscaste.

De lo contrario, deberÃ­as estar bien con las pautas de la secciÃ³n anterior: <a href="#in-a-hurry">Â¿Con prisa?</a>.


================================================
File: /docs/es/docs/benchmarks.md
================================================
# Benchmarks

Los benchmarks independientes de TechEmpower muestran aplicaciones de **FastAPI** ejecutÃ¡ndose bajo Uvicorn como <a href="https://www.techempower.com/benchmarks/#section=test&runid=7464e520-0dc2-473d-bd34-dbdfd7e85911&hw=ph&test=query&l=zijzen-7" class="external-link" target="_blank">uno de los frameworks de Python mÃ¡s rÃ¡pidos disponibles</a>, solo por debajo de Starlette y Uvicorn en sÃ­ mismos (utilizados internamente por FastAPI).

Pero al revisar benchmarks y comparaciones, debes tener en cuenta lo siguiente.

## Benchmarks y velocidad

Cuando ves los benchmarks, es comÃºn ver varias herramientas de diferentes tipos comparadas como equivalentes.

EspecÃ­ficamente, ver Uvicorn, Starlette y FastAPI comparados juntos (entre muchas otras herramientas).

Cuanto mÃ¡s simple sea el problema resuelto por la herramienta, mejor rendimiento tendrÃ¡. Y la mayorÃ­a de los benchmarks no prueban las funcionalidades adicionales proporcionadas por la herramienta.

La jerarquÃ­a es como:

* **Uvicorn**: un servidor ASGI
    * **Starlette**: (usa Uvicorn) un microframework web
        * **FastAPI**: (usa Starlette) un microframework para APIs con varias funcionalidades adicionales para construir APIs, con validaciÃ³n de datos, etc.

* **Uvicorn**:
    * TendrÃ¡ el mejor rendimiento, ya que no tiene mucho cÃ³digo extra aparte del propio servidor.
    * No escribirÃ­as una aplicaciÃ³n directamente en Uvicorn. Eso significarÃ­a que tu cÃ³digo tendrÃ­a que incluir, mÃ¡s o menos, al menos, todo el cÃ³digo proporcionado por Starlette (o **FastAPI**). Y si hicieras eso, tu aplicaciÃ³n final tendrÃ­a la misma carga que si hubieras usado un framework, minimizando el cÃ³digo de tu aplicaciÃ³n y los bugs.
    * Si estÃ¡s comparando Uvicorn, compÃ¡ralo con Daphne, Hypercorn, uWSGI, etc. Servidores de aplicaciones.
* **Starlette**:
    * TendrÃ¡ el siguiente mejor rendimiento, despuÃ©s de Uvicorn. De hecho, Starlette usa Uvicorn para ejecutarse. AsÃ­ que probablemente solo pueda ser "mÃ¡s lento" que Uvicorn por tener que ejecutar mÃ¡s cÃ³digo.
    * Pero te proporciona las herramientas para construir aplicaciones web sencillas, con enrutamiento basado en paths, etc.
    * Si estÃ¡s comparando Starlette, compÃ¡ralo con Sanic, Flask, Django, etc. Frameworks web (o microframeworks).
* **FastAPI**:
    * De la misma forma en que Starlette usa Uvicorn y no puede ser mÃ¡s rÃ¡pido que Ã©l, **FastAPI** usa Starlette, por lo que no puede ser mÃ¡s rÃ¡pido que Ã©l.
    * FastAPI ofrece mÃ¡s funcionalidades ademÃ¡s de las de Starlette. Funcionalidades que casi siempre necesitas al construir APIs, como la validaciÃ³n y serializaciÃ³n de datos. Y al utilizarlo, obtienes documentaciÃ³n automÃ¡tica gratis (la documentaciÃ³n automÃ¡tica ni siquiera aÃ±ade carga a las aplicaciones en ejecuciÃ³n, se genera al inicio).
    * Si no usabas FastAPI y utilizabas Starlette directamente (u otra herramienta, como Sanic, Flask, Responder, etc.) tendrÃ­as que implementar toda la validaciÃ³n y serializaciÃ³n de datos por ti mismo. Entonces, tu aplicaciÃ³n final aÃºn tendrÃ­a la misma carga que si hubiera sido construida usando FastAPI. Y en muchos casos, esta validaciÃ³n y serializaciÃ³n de datos es la mayor cantidad de cÃ³digo escrito en las aplicaciones.
    * Entonces, al usar FastAPI estÃ¡s ahorrando tiempo de desarrollo, bugs, lÃ­neas de cÃ³digo, y probablemente obtendrÃ­as el mismo rendimiento (o mejor) que si no lo usaras (ya que tendrÃ­as que implementarlo todo en tu cÃ³digo).
    * Si estÃ¡s comparando FastAPI, compÃ¡ralo con un framework de aplicaciÃ³n web (o conjunto de herramientas) que proporcione validaciÃ³n de datos, serializaciÃ³n y documentaciÃ³n, como Flask-apispec, NestJS, Molten, etc. Frameworks con validaciÃ³n de datos, serializaciÃ³n y documentaciÃ³n automÃ¡ticas integradas.


================================================
File: /docs/es/docs/environment-variables.md
================================================
# Variables de Entorno

/// tip | Consejo

Si ya sabes quÃ© son las "variables de entorno" y cÃ³mo usarlas, siÃ©ntete libre de saltarte esto.

///

Una variable de entorno (tambiÃ©n conocida como "**env var**") es una variable que vive **fuera** del cÃ³digo de Python, en el **sistema operativo**, y podrÃ­a ser leÃ­da por tu cÃ³digo de Python (o por otros programas tambiÃ©n).

Las variables de entorno pueden ser Ãºtiles para manejar **configuraciones** de aplicaciones, como parte de la **instalaciÃ³n** de Python, etc.

## Crear y Usar Variables de Entorno

Puedes **crear** y usar variables de entorno en la **shell (terminal)**, sin necesidad de Python:

//// tab | Linux, macOS, Windows Bash

<div class="termy">

```console
// PodrÃ­as crear una env var MY_NAME con
$ export MY_NAME="Wade Wilson"

// Luego podrÃ­as usarla con otros programas, como
$ echo "Hello $MY_NAME"

Hello Wade Wilson
```

</div>

////

//// tab | Windows PowerShell

<div class="termy">

```console
// Crea una env var MY_NAME
$ $Env:MY_NAME = "Wade Wilson"

// Ãšsala con otros programas, como
$ echo "Hello $Env:MY_NAME"

Hello Wade Wilson
```

</div>

////

## Leer Variables de Entorno en Python

TambiÃ©n podrÃ­as crear variables de entorno **fuera** de Python, en la terminal (o con cualquier otro mÃ©todo), y luego **leerlas en Python**.

Por ejemplo, podrÃ­as tener un archivo `main.py` con:

```Python hl_lines="3"
import os

name = os.getenv("MY_NAME", "World")
print(f"Hello {name} from Python")
```

/// tip | Consejo

El segundo argumento de <a href="https://docs.python.org/3.8/library/os.html#os.getenv" class="external-link" target="_blank">`os.getenv()`</a> es el valor por defecto a retornar.

Si no se proporciona, es `None` por defecto; aquÃ­ proporcionamos `"World"` como el valor por defecto para usar.

///

Luego podrÃ­as llamar a ese programa Python:

//// tab | Linux, macOS, Windows Bash

<div class="termy">

```console
// AquÃ­ todavÃ­a no configuramos la env var
$ python main.py

// Como no configuramos la env var, obtenemos el valor por defecto

Hello World from Python

// Pero si creamos una variable de entorno primero
$ export MY_NAME="Wade Wilson"

// Y luego llamamos al programa nuevamente
$ python main.py

// Ahora puede leer la variable de entorno

Hello Wade Wilson from Python
```

</div>

////

//// tab | Windows PowerShell

<div class="termy">

```console
// AquÃ­ todavÃ­a no configuramos la env var
$ python main.py

// Como no configuramos la env var, obtenemos el valor por defecto

Hello World from Python

// Pero si creamos una variable de entorno primero
$ $Env:MY_NAME = "Wade Wilson"

// Y luego llamamos al programa nuevamente
$ python main.py

// Ahora puede leer la variable de entorno

Hello Wade Wilson from Python
```

</div>

////

Dado que las variables de entorno pueden configurarse fuera del cÃ³digo, pero pueden ser leÃ­das por el cÃ³digo, y no tienen que ser almacenadas (committed en `git`) con el resto de los archivos, es comÃºn usarlas para configuraciones o **ajustes**.

TambiÃ©n puedes crear una variable de entorno solo para una **invocaciÃ³n especÃ­fica de un programa**, que estÃ¡ disponible solo para ese programa, y solo durante su duraciÃ³n.

Para hacer eso, crÃ©ala justo antes del programa en sÃ­, en la misma lÃ­nea:

<div class="termy">

```console
// Crea una env var MY_NAME en lÃ­nea para esta llamada del programa
$ MY_NAME="Wade Wilson" python main.py

// Ahora puede leer la variable de entorno

Hello Wade Wilson from Python

// La env var ya no existe despuÃ©s
$ python main.py

Hello World from Python
```

</div>

/// tip | Consejo

Puedes leer mÃ¡s al respecto en <a href="https://12factor.net/config" class="external-link" target="_blank">The Twelve-Factor App: Config</a>.

///

## Tipos y ValidaciÃ³n

Estas variables de entorno solo pueden manejar **strings de texto**, ya que son externas a Python y deben ser compatibles con otros programas y el resto del sistema (e incluso con diferentes sistemas operativos, como Linux, Windows, macOS).

Esto significa que **cualquier valor** leÃ­do en Python desde una variable de entorno **serÃ¡ un `str`**, y cualquier conversiÃ³n a un tipo diferente o cualquier validaciÃ³n tiene que hacerse en el cÃ³digo.

AprenderÃ¡s mÃ¡s sobre cÃ³mo usar variables de entorno para manejar **configuraciones de aplicaciÃ³n** en la [GuÃ­a del Usuario Avanzado - Ajustes y Variables de Entorno](./advanced/settings.md){.internal-link target=_blank}.

## Variable de Entorno `PATH`

Hay una variable de entorno **especial** llamada **`PATH`** que es utilizada por los sistemas operativos (Linux, macOS, Windows) para encontrar programas a ejecutar.

El valor de la variable `PATH` es un string largo que consiste en directorios separados por dos puntos `:` en Linux y macOS, y por punto y coma `;` en Windows.

Por ejemplo, la variable de entorno `PATH` podrÃ­a verse asÃ­:

//// tab | Linux, macOS

```plaintext
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin
```

Esto significa que el sistema deberÃ­a buscar programas en los directorios:

* `/usr/local/bin`
* `/usr/bin`
* `/bin`
* `/usr/sbin`
* `/sbin`

////

//// tab | Windows

```plaintext
C:\Program Files\Python312\Scripts;C:\Program Files\Python312;C:\Windows\System32
```

Esto significa que el sistema deberÃ­a buscar programas en los directorios:

* `C:\Program Files\Python312\Scripts`
* `C:\Program Files\Python312`
* `C:\Windows\System32`

////

Cuando escribes un **comando** en la terminal, el sistema operativo **busca** el programa en **cada uno de esos directorios** listados en la variable de entorno `PATH`.

Por ejemplo, cuando escribes `python` en la terminal, el sistema operativo busca un programa llamado `python` en el **primer directorio** de esa lista.

Si lo encuentra, entonces lo **utilizarÃ¡**. De lo contrario, continÃºa buscando en los **otros directorios**.

### Instalando Python y Actualizando el `PATH`

Cuando instalas Python, se te podrÃ­a preguntar si deseas actualizar la variable de entorno `PATH`.

//// tab | Linux, macOS

Digamos que instalas Python y termina en un directorio `/opt/custompython/bin`.

Si dices que sÃ­ para actualizar la variable de entorno `PATH`, entonces el instalador aÃ±adirÃ¡ `/opt/custompython/bin` a la variable de entorno `PATH`.

PodrÃ­a verse asÃ­:

```plaintext
/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/custompython/bin
```

De esta manera, cuando escribes `python` en la terminal, el sistema encontrarÃ¡ el programa Python en `/opt/custompython/bin` (el Ãºltimo directorio) y usarÃ¡ ese.

////

//// tab | Windows

Digamos que instalas Python y termina en un directorio `C:\opt\custompython\bin`.

Si dices que sÃ­ para actualizar la variable de entorno `PATH`, entonces el instalador aÃ±adirÃ¡ `C:\opt\custompython\bin` a la variable de entorno `PATH`.

```plaintext
C:\Program Files\Python312\Scripts;C:\Program Files\Python312;C:\Windows\System32;C:\opt\custompython\bin
```

De esta manera, cuando escribes `python` en la terminal, el sistema encontrarÃ¡ el programa Python en `C:\opt\custompython\bin` (el Ãºltimo directorio) y usarÃ¡ ese.

////

Entonces, si escribes:

<div class="termy">

```console
$ python
```

</div>

//// tab | Linux, macOS

El sistema **encontrarÃ¡** el programa `python` en `/opt/custompython/bin` y lo ejecutarÃ¡.

Esto serÃ­a mÃ¡s o menos equivalente a escribir:

<div class="termy">

```console
$ /opt/custompython/bin/python
```

</div>

////

//// tab | Windows

El sistema **encontrarÃ¡** el programa `python` en `C:\opt\custompython\bin\python` y lo ejecutarÃ¡.

Esto serÃ­a mÃ¡s o menos equivalente a escribir:

<div class="termy">

```console
$ C:\opt\custompython\bin\python
```

</div>

////

Esta informaciÃ³n serÃ¡ Ãºtil al aprender sobre [Entornos Virtuales](virtual-environments.md){.internal-link target=_blank}.

## ConclusiÃ³n

Con esto deberÃ­as tener una comprensiÃ³n bÃ¡sica de quÃ© son las **variables de entorno** y cÃ³mo usarlas en Python.

TambiÃ©n puedes leer mÃ¡s sobre ellas en la <a href="https://en.wikipedia.org/wiki/Environment_variable" class="external-link" target="_blank">Wikipedia para Variable de Entorno</a>.

En muchos casos no es muy obvio cÃ³mo las variables de entorno serÃ­an Ãºtiles y aplicables de inmediato. Pero siguen apareciendo en muchos escenarios diferentes cuando estÃ¡s desarrollando, asÃ­ que es bueno conocerlas.

Por ejemplo, necesitarÃ¡s esta informaciÃ³n en la siguiente secciÃ³n, sobre [Entornos Virtuales](virtual-environments.md).


================================================
File: /docs/es/docs/fastapi-cli.md
================================================
# FastAPI CLI

**FastAPI CLI** es un programa de lÃ­nea de comandos que puedes usar para servir tu aplicaciÃ³n FastAPI, gestionar tu proyecto FastAPI, y mÃ¡s.

Cuando instalas FastAPI (por ejemplo, con `pip install "fastapi[standard]"`), incluye un paquete llamado `fastapi-cli`, este paquete proporciona el comando `fastapi` en la terminal.

Para ejecutar tu aplicaciÃ³n FastAPI en modo de desarrollo, puedes usar el comando `fastapi dev`:

<div class="termy">

```console
$ <font color="#4E9A06">fastapi</font> dev <u style="text-decoration-style:solid">main.py</u>

  <span style="background-color:#009485"><font color="#D3D7CF"> FastAPI </font></span>  Starting development server ðŸš€

             Searching for package file structure from directories with
             <font color="#3465A4">__init__.py</font> files
             Importing from <font color="#75507B">/home/user/code/</font><font color="#AD7FA8">awesomeapp</font>

   <span style="background-color:#007166"><font color="#D3D7CF"> module </font></span>  ðŸ main.py

     <span style="background-color:#007166"><font color="#D3D7CF"> code </font></span>  Importing the FastAPI app object from the module with the
             following code:

             <u style="text-decoration-style:solid">from </u><u style="text-decoration-style:solid"><b>main</b></u><u style="text-decoration-style:solid"> import </u><u style="text-decoration-style:solid"><b>app</b></u>

      <span style="background-color:#007166"><font color="#D3D7CF"> app </font></span>  Using import string: <font color="#3465A4">main:app</font>

   <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Server started at <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000</u></font>
   <span style="background-color:#007166"><font color="#D3D7CF"> server </font></span>  Documentation at <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000/docs</u></font>

      <span style="background-color:#007166"><font color="#D3D7CF"> tip </font></span>  Running in development mode, for production use:
             <b>fastapi run</b>

             Logs:

     <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Will watch for changes in these directories:
             <b>[</b><font color="#4E9A06">&apos;/home/user/code/awesomeapp&apos;</font><b>]</b>
     <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Uvicorn running on <font color="#729FCF"><u style="text-decoration-style:solid">http://127.0.0.1:8000</u></font> <b>(</b>Press CTRL+C to
             quit<b>)</b>
     <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started reloader process <b>[</b><font color="#34E2E2"><b>383138</b></font><b>]</b> using WatchFiles
     <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Started server process <b>[</b><font color="#34E2E2"><b>383153</b></font><b>]</b>
     <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Waiting for application startup.
     <span style="background-color:#007166"><font color="#D3D7CF"> INFO </font></span>  Application startup complete.
```

</div>

El programa de lÃ­nea de comandos llamado `fastapi` es **FastAPI CLI**.

FastAPI CLI toma el path de tu programa Python (por ejemplo, `main.py`), detecta automÃ¡ticamente la `FastAPI` instance (comÃºnmente llamada `app`), determina el proceso de import correcto, y luego la sirve.

Para producciÃ³n usarÃ­as `fastapi run` en su lugar. ðŸš€

Internamente, **FastAPI CLI** usa <a href="https://www.uvicorn.org" class="external-link" target="_blank">Uvicorn</a>, un servidor ASGI de alto rendimiento y listo para producciÃ³n. ðŸ˜Ž

## `fastapi dev`

Ejecutar `fastapi dev` inicia el modo de desarrollo.

Por defecto, **auto-reload** estÃ¡ habilitado, recargando automÃ¡ticamente el servidor cuando realizas cambios en tu cÃ³digo. Esto consume muchos recursos y podrÃ­a ser menos estable que cuando estÃ¡ deshabilitado. DeberÃ­as usarlo solo para desarrollo. TambiÃ©n escucha en la direcciÃ³n IP `127.0.0.1`, que es la IP para que tu mÃ¡quina se comunique solo consigo misma (`localhost`).

## `fastapi run`

Ejecutar `fastapi run` inicia FastAPI en modo de producciÃ³n por defecto.

Por defecto, **auto-reload** estÃ¡ deshabilitado. TambiÃ©n escucha en la direcciÃ³n IP `0.0.0.0`, lo que significa todas las direcciones IP disponibles, de esta manera serÃ¡ accesible pÃºblicamente por cualquiera que pueda comunicarse con la mÃ¡quina. Esta es la manera en la que normalmente lo ejecutarÃ­as en producciÃ³n, por ejemplo, en un contenedor.

En la mayorÃ­a de los casos tendrÃ­as (y deberÃ­as) tener un "proxy de terminaciÃ³n" manejando HTTPS por ti, esto dependerÃ¡ de cÃ³mo despliegues tu aplicaciÃ³n, tu proveedor podrÃ­a hacer esto por ti, o podrÃ­as necesitar configurarlo tÃº mismo.

/// tip | Consejo

Puedes aprender mÃ¡s al respecto en la [documentaciÃ³n de despliegue](deployment/index.md){.internal-link target=_blank}.

///


================================================
File: /docs/es/docs/features.md
================================================
# Funcionalidades

## Funcionalidades de FastAPI

**FastAPI** te ofrece lo siguiente:

### Basado en estÃ¡ndares abiertos

* <a href="https://github.com/OAI/OpenAPI-Specification" class="external-link" target="_blank"><strong>OpenAPI</strong></a> para la creaciÃ³n de APIs, incluyendo declaraciones de <abbr title="tambiÃ©n conocido como: endpoints, rutas">path</abbr> <abbr title="tambiÃ©n conocido como mÃ©todos HTTP, como POST, GET, PUT, DELETE">operations</abbr>, parÃ¡metros, request bodies, seguridad, etc.
* DocumentaciÃ³n automÃ¡tica de modelos de datos con <a href="https://json-schema.org/" class="external-link" target="_blank"><strong>JSON Schema</strong></a> (ya que OpenAPI en sÃ­ mismo estÃ¡ basado en JSON Schema).
* DiseÃ±ado alrededor de estos estÃ¡ndares, tras un estudio meticuloso. En lugar de ser una capa adicional.
* Esto tambiÃ©n permite el uso de **generaciÃ³n de cÃ³digo cliente automÃ¡tica** en muchos idiomas.

### DocumentaciÃ³n automÃ¡tica

Interfaces web de documentaciÃ³n y exploraciÃ³n de APIs interactivas. Como el framework estÃ¡ basado en OpenAPI, hay mÃºltiples opciones, 2 incluidas por defecto.

* <a href="https://github.com/swagger-api/swagger-ui" class="external-link" target="_blank"><strong>Swagger UI</strong></a>, con exploraciÃ³n interactiva, llama y prueba tu API directamente desde el navegador.

![InteracciÃ³n Swagger UI](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)

* DocumentaciÃ³n alternativa de API con <a href="https://github.com/Rebilly/ReDoc" class="external-link" target="_blank"><strong>ReDoc</strong></a>.

![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)

### Solo Python moderno

Todo estÃ¡ basado en declaraciones estÃ¡ndar de **tipos en Python** (gracias a Pydantic). Sin nueva sintaxis que aprender. Solo Python moderno estÃ¡ndar.

Si necesitas un repaso de 2 minutos sobre cÃ³mo usar tipos en Python (aunque no uses FastAPI), revisa el tutorial corto: [Tipos en Python](python-types.md){.internal-link target=_blank}.

Escribes Python estÃ¡ndar con tipos:

```Python
from datetime import date

from pydantic import BaseModel

# Declara una variable como un str
# y obtiene soporte del editor dentro de la funciÃ³n
def main(user_id: str):
    return user_id


# Un modelo de Pydantic
class User(BaseModel):
    id: int
    name: str
    joined: date
```

Que luego puede ser usado como:

```Python
my_user: User = User(id=3, name="John Doe", joined="2018-07-19")

second_user_data = {
    "id": 4,
    "name": "Mary",
    "joined": "2018-11-30",
}

my_second_user: User = User(**second_user_data)
```

/// info | InformaciÃ³n

`**second_user_data` significa:

Pasa las claves y valores del dict `second_user_data` directamente como argumentos de clave-valor, equivalente a: `User(id=4, name="Mary", joined="2018-11-30")`

///

### Soporte del editor

Todo el framework fue diseÃ±ado para ser fÃ¡cil e intuitivo de usar, todas las decisiones fueron probadas en mÃºltiples editores incluso antes de comenzar el desarrollo, para asegurar la mejor experiencia de desarrollo.

En las encuestas a desarrolladores de Python, es claro <a href="https://www.jetbrains.com/research/python-developers-survey-2017/#tools-and-features" class="external-link" target="_blank">que una de las funcionalidades mÃ¡s usadas es el "autocompletado"</a>.

Todo el framework **FastAPI** estÃ¡ basado para satisfacer eso. El autocompletado funciona en todas partes.

Rara vez necesitarÃ¡s regresar a la documentaciÃ³n.

AquÃ­ estÃ¡ cÃ³mo tu editor podrÃ­a ayudarte:

* en <a href="https://code.visualstudio.com/" class="external-link" target="_blank">Visual Studio Code</a>:

![soporte del editor](https://fastapi.tiangolo.com/img/vscode-completion.png)

* en <a href="https://www.jetbrains.com/pycharm/" class="external-link" target="_blank">PyCharm</a>:

![soporte del editor](https://fastapi.tiangolo.com/img/pycharm-completion.png)

ObtendrÃ¡s autocompletado en cÃ³digo que podrÃ­as considerar imposible antes. Por ejemplo, la clave `price` dentro de un cuerpo JSON (que podrÃ­a haber estado anidado) que proviene de un request.

No mÃ¡s escribir nombres de claves incorrectos, yendo de un lado a otro entre la documentaciÃ³n, o desplazÃ¡ndote hacia arriba y abajo para encontrar si finalmente usaste `username` o `user_name`.

### Breve

Tiene **valores predeterminados** sensatos para todo, con configuraciones opcionales en todas partes. Todos los parÃ¡metros se pueden ajustar finamente para hacer lo que necesitas y para definir el API que necesitas.

Pero por defecto, todo **"simplemente funciona"**.

### ValidaciÃ³n

* ValidaciÃ³n para la mayorÃ­a (Â¿o todas?) de los **tipos de datos** de Python, incluyendo:
    * Objetos JSON (`dict`).
    * Array JSON (`list`) definiendo tipos de elementos.
    * Campos de cadena de caracteres (`str`), definiendo longitudes mÃ­nimas y mÃ¡ximas.
    * NÃºmeros (`int`, `float`) con valores mÃ­nimos y mÃ¡ximos, etc.

* ValidaciÃ³n para tipos mÃ¡s exÃ³ticos, como:
    * URL.
    * Email.
    * UUID.
    * ...y otros.

Toda la validaciÃ³n es manejada por **Pydantic**, una herramienta bien establecida y robusta.

### Seguridad y autenticaciÃ³n

Seguridad y autenticaciÃ³n integradas. Sin ningÃºn compromiso con bases de datos o modelos de datos.

Todos los esquemas de seguridad definidos en OpenAPI, incluyendo:

* HTTP BÃ¡sico.
* **OAuth2** (tambiÃ©n con **tokens JWT**). Revisa el tutorial sobre [OAuth2 con JWT](tutorial/security/oauth2-jwt.md){.internal-link target=_blank}.
* API keys en:
    * Headers.
    * ParÃ¡metros de query.
    * Cookies, etc.

AdemÃ¡s de todas las caracterÃ­sticas de seguridad de Starlette (incluyendo **cookies de sesiÃ³n**).

Todo construido como herramientas y componentes reutilizables que son fÃ¡ciles de integrar con tus sistemas, almacenes de datos, bases de datos relacionales y NoSQL, etc.

### InyecciÃ³n de dependencias

FastAPI incluye un sistema de <abbr title='tambiÃ©n conocido como "componentes", "recursos", "servicios", "proveedores"'><strong>InyecciÃ³n de Dependencias</strong></abbr> extremadamente fÃ¡cil de usar, pero extremadamente potente.

* Incluso las dependencias pueden tener dependencias, creando una jerarquÃ­a o **"grÃ¡fico de dependencias"**.
* Todo **manejado automÃ¡ticamente** por el framework.
* Todas las dependencias pueden requerir datos de los requests y **aumentar las restricciones de la path operation** y la documentaciÃ³n automÃ¡tica.
* **ValidaciÃ³n automÃ¡tica** incluso para los parÃ¡metros de *path operation* definidos en las dependencias.
* Soporte para sistemas de autenticaciÃ³n de usuario complejos, **conexiones a bases de datos**, etc.
* **Sin compromisos** con bases de datos, frontends, etc. Pero fÃ¡cil integraciÃ³n con todos ellos.

### "Plug-ins" ilimitados

O de otra manera, no hay necesidad de ellos, importa y usa el cÃ³digo que necesitas.

Cualquier integraciÃ³n estÃ¡ diseÃ±ada para ser tan simple de usar (con dependencias) que puedes crear un "plug-in" para tu aplicaciÃ³n en 2 lÃ­neas de cÃ³digo usando la misma estructura y sintaxis utilizada para tus *path operations*.

### Probado

* 100% de <abbr title="La cantidad de cÃ³digo que se prueba automÃ¡ticamente">cobertura de tests</abbr>.
* CÃ³digo completamente <abbr title="Anotaciones de tipos en Python, con esto tu editor y herramientas externas pueden ofrecerte mejor soporte">anotado con tipos</abbr>.
* Usado en aplicaciones en producciÃ³n.

## Funcionalidades de Starlette

**FastAPI** es totalmente compatible con (y estÃ¡ basado en) <a href="https://www.starlette.io/" class="external-link" target="_blank"><strong>Starlette</strong></a>. AsÃ­ que, cualquier cÃ³digo adicional de Starlette que tengas, tambiÃ©n funcionarÃ¡.

`FastAPI` es en realidad una subclase de `Starlette`. AsÃ­ que, si ya conoces o usas Starlette, la mayorÃ­a de las funcionalidades funcionarÃ¡n de la misma manera.

Con **FastAPI** obtienes todas las funcionalidades de **Starlette** (ya que FastAPI es simplemente Starlette potenciado):

* Rendimiento seriamente impresionante. Es <a href="https://github.com/encode/starlette#performance" class="external-link" target="_blank">uno de los frameworks de Python mÃ¡s rÃ¡pidos disponibles, a la par de **NodeJS** y **Go**</a>.
* Soporte para **WebSocket**.
* Tareas en segundo plano en el mismo proceso.
* Eventos de inicio y apagado.
* Cliente de prueba basado en HTTPX.
* **CORS**, GZip, archivos estÃ¡ticos, responses en streaming.
* Soporte para **Session y Cookie**.
* Cobertura de tests del 100%.
* CÃ³digo completamente anotado con tipos.

## Funcionalidades de Pydantic

**FastAPI** es totalmente compatible con (y estÃ¡ basado en) <a href="https://docs.pydantic.dev/" class="external-link" target="_blank"><strong>Pydantic</strong></a>. Por lo tanto, cualquier cÃ³digo adicional de Pydantic que tengas, tambiÃ©n funcionarÃ¡.

Incluyendo paquetes externos tambiÃ©n basados en Pydantic, como <abbr title="Object-Relational Mapper">ORM</abbr>s, <abbr title="Object-Document Mapper">ODM</abbr>s para bases de datos.

Esto tambiÃ©n significa que, en muchos casos, puedes pasar el mismo objeto que obtienes de un request **directamente a la base de datos**, ya que todo se valida automÃ¡ticamente.

Lo mismo aplica al revÃ©s, en muchos casos puedes simplemente pasar el objeto que obtienes de la base de datos **directamente al cliente**.

Con **FastAPI** obtienes todas las funcionalidades de **Pydantic** (ya que FastAPI estÃ¡ basado en Pydantic para todo el manejo de datos):

* **Sin complicaciones**:
    * Sin micro-lenguaje de definiciÃ³n de esquemas nuevo que aprender.
    * Si conoces los tipos en Python sabes cÃ³mo usar Pydantic.
* Se lleva bien con tu **<abbr title="Entorno de Desarrollo Integrado, similar a un editor de cÃ³digo">IDE</abbr>/<abbr title="Un programa que verifica errores de cÃ³digo">linter</abbr>/cerebro**:
    * Porque las estructuras de datos de pydantic son solo instances de clases que defines; autocompletado, linting, mypy y tu intuiciÃ³n deberÃ­an funcionar correctamente con tus datos validados.
* Valida **estructuras complejas**:
    * Uso de modelos jerÃ¡rquicos de Pydantic, `List` y `Dict` de `typing` de Python, etc.
    * Y los validadores permiten definir, verificar y documentar de manera clara y fÃ¡cil esquemas de datos complejos como JSON Schema.
    * Puedes tener objetos JSON profundamente **anidados** y validarlos todos y anotarlos.
* **Extensible**:
    * Pydantic permite definir tipos de datos personalizados o puedes extender la validaciÃ³n con mÃ©todos en un modelo decorados con el decorador validator.
* Cobertura de tests del 100%.


================================================
File: /docs/es/docs/help-fastapi.md
================================================
# Ayuda a FastAPI - Consigue Ayuda

Â¿Te gusta **FastAPI**?

Â¿Te gustarÃ­a ayudar a FastAPI, a otros usuarios y al autor?

Â¿O te gustarÃ­a conseguir ayuda con **FastAPI**?

Hay formas muy sencillas de ayudar (varias implican solo uno o dos clics).

Y tambiÃ©n hay varias formas de conseguir ayuda.

## SuscrÃ­bete al boletÃ­n

Puedes suscribirte al (esporÃ¡dico) boletÃ­n [**FastAPI and friends**](newsletter.md){.internal-link target=_blank} para mantenerte al dÃ­a sobre:

* Noticias sobre FastAPI y amigos ðŸš€
* GuÃ­as ðŸ“
* Funcionalidades âœ¨
* Cambios importantes ðŸš¨
* Consejos y trucos âœ…

## Sigue a FastAPI en Twitter

<a href="https://twitter.com/fastapi" class="external-link" target="_blank">Sigue a @fastapi en **Twitter**</a> para obtener las Ãºltimas noticias sobre **FastAPI**. ðŸ¦

## Dale una estrella a **FastAPI** en GitHub

Puedes "darle una estrella" a FastAPI en GitHub (haciendo clic en el botÃ³n de estrella en la parte superior derecha): <a href="https://github.com/fastapi/fastapi" class="external-link" target="_blank">https://github.com/fastapi/fastapi</a>. â­ï¸

Al agregar una estrella, otros usuarios podrÃ¡n encontrarlo mÃ¡s fÃ¡cilmente y ver que ya ha sido Ãºtil para otros.

## Observa el repositorio de GitHub para lanzamientos

Puedes "observar" FastAPI en GitHub (haciendo clic en el botÃ³n "watch" en la parte superior derecha): <a href="https://github.com/fastapi/fastapi" class="external-link" target="_blank">https://github.com/fastapi/fastapi</a>. ðŸ‘€

AllÃ­ puedes seleccionar "Releases only".

Al hacerlo, recibirÃ¡s notificaciones (en tu email) cada vez que haya un nuevo lanzamiento (una nueva versiÃ³n) de **FastAPI** con correcciones de bugs y nuevas funcionalidades.

## ConÃ©ctate con el autor

Puedes conectar <a href="https://tiangolo.com" class="external-link" target="_blank">conmigo (SebastiÃ¡n RamÃ­rez / `tiangolo`)</a>, el autor.

Puedes:

* <a href="https://github.com/tiangolo" class="external-link" target="_blank">Seguirme en **GitHub**</a>.
    * Ver otros proyectos de CÃ³digo Abierto que he creado y que podrÃ­an ayudarte.
    * Seguirme para ver cuÃ¡ndo creo un nuevo proyecto de CÃ³digo Abierto.
* <a href="https://twitter.com/tiangolo" class="external-link" target="_blank">Seguirme en **Twitter**</a> o <a href="https://fosstodon.org/@tiangolo" class="external-link" target="_blank">Mastodon</a>.
    * Contarme cÃ³mo usas FastAPI (me encanta oÃ­r eso).
    * Enterarte cuando hago anuncios o lanzo nuevas herramientas.
    * TambiÃ©n puedes <a href="https://twitter.com/fastapi" class="external-link" target="_blank">seguir @fastapi en Twitter</a> (una cuenta aparte).
* <a href="https://www.linkedin.com/in/tiangolo/" class="external-link" target="_blank">Seguirme en **LinkedIn**</a>.
    * Enterarte cuando hago anuncios o lanzo nuevas herramientas (aunque uso Twitter mÃ¡s a menudo ðŸ¤·â€â™‚).
* Leer lo que escribo (o seguirme) en <a href="https://dev.to/tiangolo" class="external-link" target="_blank">**Dev.to**</a> o <a href="https://medium.com/@tiangolo" class="external-link" target="_blank">**Medium**</a>.
    * Leer otras ideas, artÃ­culos, y leer sobre las herramientas que he creado.
    * Seguirme para leer lo que publico nuevo.

## Twittea sobre **FastAPI**

<a href="https://twitter.com/compose/tweet?text=I'm loving @fastapi because... https://github.com/fastapi/fastapi" class="external-link" target="_blank">Twittea sobre **FastAPI**</a> y dime a mÃ­ y a otros por quÃ© te gusta. ðŸŽ‰

Me encanta escuchar cÃ³mo se estÃ¡ utilizando **FastAPI**, quÃ© te ha gustado, en quÃ© proyecto/empresa lo estÃ¡s usando, etc.

## Vota por FastAPI

* <a href="https://www.slant.co/options/34241/~fastapi-review" class="external-link" target="_blank">Vota por **FastAPI** en Slant</a>.
* <a href="https://alternativeto.net/software/fastapi/about/" class="external-link" target="_blank">Vota por **FastAPI** en AlternativeTo</a>.
* <a href="https://stackshare.io/pypi-fastapi" class="external-link" target="_blank">Di que usas **FastAPI** en StackShare</a>.

## Ayuda a otros con preguntas en GitHub

Puedes intentar ayudar a otros con sus preguntas en:

* <a href="https://github.com/fastapi/fastapi/discussions/categories/questions?discussions_q=category%3AQuestions+is%3Aunanswered" class="external-link" target="_blank">GitHub Discussions</a>
* <a href="https://github.com/fastapi/fastapi/issues?q=is%3Aissue+is%3Aopen+sort%3Aupdated-desc+label%3Aquestion+-label%3Aanswered+" class="external-link" target="_blank">GitHub Issues</a>

En muchos casos, probablemente ya conozcas la respuesta a esas preguntas. ðŸ¤“

Si estÃ¡s ayudando mucho a la gente con sus preguntas, te convertirÃ¡s en un [FastAPI Expert](fastapi-people.md#fastapi-experts){.internal-link target=_blank} oficial. ðŸŽ‰

Solo recuerda, el punto mÃ¡s importante es: trata de ser amable. La gente llega con sus frustraciones y, en muchos casos, no pregunta de la mejor manera, pero haz todo lo posible por ser amable. ðŸ¤—

La idea es que la comunidad de **FastAPI** sea amable y acogedora. Al mismo tiempo, no aceptes acoso o comportamiento irrespetuoso hacia los demÃ¡s. Tenemos que cuidarnos unos a otros.

---

AquÃ­ te explico cÃ³mo ayudar a otros con preguntas (en discusiones o issues):

### Entiende la pregunta

* Revisa si puedes entender cuÃ¡l es el **propÃ³sito** y el caso de uso de la persona que pregunta.

* Luego revisa si la pregunta (la gran mayorÃ­a son preguntas) es **clara**.

* En muchos casos, la pregunta planteada es sobre una soluciÃ³n imaginaria del usuario, pero podrÃ­a haber una **mejor**. Si puedes entender mejor el problema y el caso de uso, podrÃ­as sugerir una mejor **soluciÃ³n alternativa**.

* Si no puedes entender la pregunta, pide mÃ¡s **detalles**.

### Reproduce el problema

En la mayorÃ­a de los casos y preguntas hay algo relacionado con el **cÃ³digo original** de la persona.

En muchos casos solo copiarÃ¡n un fragmento del cÃ³digo, pero eso no es suficiente para **reproducir el problema**.

* Puedes pedirles que proporcionen un <a href="https://stackoverflow.com/help/minimal-reproducible-example" class="external-link" target="_blank">ejemplo mÃ­nimo, reproducible</a>, que puedas **copiar-pegar** y ejecutar localmente para ver el mismo error o comportamiento que estÃ¡n viendo, o para entender mejor su caso de uso.

* Si te sientes muy generoso, puedes intentar **crear un ejemplo** asÃ­ tÃº mismo, solo basado en la descripciÃ³n del problema. Solo ten en cuenta que esto podrÃ­a llevar mucho tiempo y podrÃ­a ser mejor pedirles que aclaren el problema primero.

### Sugerir soluciones

* DespuÃ©s de poder entender la pregunta, puedes darles un posible **respuesta**.

* En muchos casos, es mejor entender su **problema subyacente o caso de uso**, porque podrÃ­a haber una mejor manera de resolverlo que lo que estÃ¡n intentando hacer.

### Pide cerrar

Si responden, hay una alta probabilidad de que hayas resuelto su problema, felicidades, Â¡**eres un hÃ©roe**! ðŸ¦¸

* Ahora, si eso resolviÃ³ su problema, puedes pedirles que:

    * En GitHub Discussions: marquen el comentario como la **respuesta**.
    * En GitHub Issues: **cierren** el issue.

## Observa el repositorio de GitHub

Puedes "observar" FastAPI en GitHub (haciendo clic en el botÃ³n "watch" en la parte superior derecha): <a href="https://github.com/fastapi/fastapi" class="external-link" target="_blank">https://github.com/fastapi/fastapi</a>. ðŸ‘€

Si seleccionas "Watching" en lugar de "Releases only", recibirÃ¡s notificaciones cuando alguien cree un nuevo issue o pregunta. TambiÃ©n puedes especificar que solo deseas que te notifiquen sobre nuevos issues, discusiones, PRs, etc.

Luego puedes intentar ayudarlos a resolver esas preguntas.

## Haz preguntas

Puedes <a href="https://github.com/fastapi/fastapi/discussions/new?category=questions" class="external-link" target="_blank">crear una nueva pregunta</a> en el repositorio de GitHub, por ejemplo, para:

* Hacer una **pregunta** o preguntar sobre un **problema**.
* Sugerir una nueva **funcionalidad**.

**Nota**: si lo haces, entonces te voy a pedir que tambiÃ©n ayudes a otros. ðŸ˜‰

## Revisa Pull Requests

Puedes ayudarme a revisar pull requests de otros.

De nuevo, por favor, haz tu mejor esfuerzo por ser amable. ðŸ¤—

---

AquÃ­ estÃ¡ lo que debes tener en cuenta y cÃ³mo revisar un pull request:

### Entiende el problema

* Primero, asegÃºrate de **entender el problema** que el pull request estÃ¡ intentando resolver. PodrÃ­a tener una discusiÃ³n mÃ¡s larga en una GitHub Discussion o issue.

* TambiÃ©n hay una buena posibilidad de que el pull request no sea realmente necesario porque el problema se puede resolver de una manera **diferente**. Entonces puedes sugerir o preguntar sobre eso.

### No te preocupes por el estilo

* No te preocupes demasiado por cosas como los estilos de los mensajes de commit, yo harÃ© squash y merge personalizando el commit manualmente.

* Tampoco te preocupes por las reglas de estilo, hay herramientas automatizadas verificando eso.

Y si hay alguna otra necesidad de estilo o consistencia, pedirÃ© directamente eso, o agregarÃ© commits encima con los cambios necesarios.

### Revisa el cÃ³digo

* Revisa y lee el cÃ³digo, ve si tiene sentido, **ejecÃºtalo localmente** y ve si realmente resuelve el problema.

* Luego **comenta** diciendo que hiciste eso, asÃ­ sabrÃ© que realmente lo revisaste.

/// info | InformaciÃ³n

Desafortunadamente, no puedo simplemente confiar en PRs que solo tienen varias aprobaciones.

Varias veces ha sucedido que hay PRs con 3, 5 o mÃ¡s aprobaciones, probablemente porque la descripciÃ³n es atractiva, pero cuando reviso los PRs, en realidad estÃ¡n rotos, tienen un bug, o no resuelven el problema que dicen resolver. ðŸ˜…

AsÃ­ que, es realmente importante que realmente leas y ejecutes el cÃ³digo, y me hagas saber en los comentarios que lo hiciste. ðŸ¤“

///

* Si el PR se puede simplificar de alguna manera, puedes pedir eso, pero no hay necesidad de ser demasiado exigente, podrÃ­a haber muchos puntos de vista subjetivos (y yo tendrÃ© el mÃ­o tambiÃ©n ðŸ™ˆ), asÃ­ que es mejor si puedes centrarte en las cosas fundamentales.

### Tests

* AyÃºdame a verificar que el PR tenga **tests**.

* Verifica que los tests **fallen** antes del PR. ðŸš¨

* Luego verifica que los tests **pasen** despuÃ©s del PR. âœ…

* Muchos PRs no tienen tests, puedes **recordarles** que agreguen tests, o incluso puedes **sugerir** algunos tests tÃº mismo. Eso es una de las cosas que consume mÃ¡s tiempo y puedes ayudar mucho con eso.

* Luego tambiÃ©n comenta lo que intentaste, de esa manera sabrÃ© que lo revisaste. ðŸ¤“

## Crea un Pull Request

Puedes [contribuir](contributing.md){.internal-link target=_blank} al cÃ³digo fuente con Pull Requests, por ejemplo:

* Para corregir un error tipogrÃ¡fico que encontraste en la documentaciÃ³n.
* Para compartir un artÃ­culo, video o podcast que creaste o encontraste sobre FastAPI <a href="https://github.com/fastapi/fastapi/edit/master/docs/en/data/external_links.yml" class="external-link" target="_blank">editando este archivo</a>.
    * AsegÃºrate de agregar tu enlace al inicio de la secciÃ³n correspondiente.
* Para ayudar a [traducir la documentaciÃ³n](contributing.md#translations){.internal-link target=_blank} a tu idioma.
    * TambiÃ©n puedes ayudar a revisar las traducciones creadas por otros.
* Para proponer nuevas secciones de documentaciÃ³n.
* Para corregir un issue/bug existente.
    * AsegÃºrate de agregar tests.
* Para agregar una nueva funcionalidad.
    * AsegÃºrate de agregar tests.
    * AsegÃºrate de agregar documentaciÃ³n si es relevante.

## Ayuda a Mantener FastAPI

Â¡AyÃºdame a mantener **FastAPI**! ðŸ¤“

Hay mucho trabajo por hacer, y para la mayorÃ­a de ello, **TÃš** puedes hacerlo.

Las tareas principales que puedes hacer ahora son:

* [Ayudar a otros con preguntas en GitHub](#help-others-with-questions-in-github){.internal-link target=_blank} (ver la secciÃ³n arriba).
* [Revisar Pull Requests](#review-pull-requests){.internal-link target=_blank} (ver la secciÃ³n arriba).

Esas dos tareas son las que **consumen mÃ¡s tiempo**. Ese es el trabajo principal de mantener FastAPI.

Si puedes ayudarme con eso, **me estÃ¡s ayudando a mantener FastAPI** y asegurando que siga **avanzando mÃ¡s rÃ¡pido y mejor**. ðŸš€

## Ãšnete al chat

Ãšnete al servidor de chat ðŸ‘¥ <a href="https://discord.gg/VQjSZaeJmf" class="external-link" target="_blank">Discord</a> ðŸ‘¥ y charla con otros en la comunidad de FastAPI.

/// tip | Consejo

Para preguntas, hÃ¡zlas en <a href="https://github.com/fastapi/fastapi/discussions/new?category=questions" class="external-link" target="_blank">GitHub Discussions</a>, hay muchas mÃ¡s probabilidades de que recibas ayuda de parte de los [FastAPI Experts](fastapi-people.md#fastapi-experts){.internal-link target=_blank}.

Usa el chat solo para otras conversaciones generales.

///

### No uses el chat para preguntas

Ten en cuenta que dado que los chats permiten una "conversaciÃ³n mÃ¡s libre", es fÃ¡cil hacer preguntas que son demasiado generales y mÃ¡s difÃ­ciles de responder, por lo que es posible que no recibas respuestas.

En GitHub, la plantilla te guiarÃ¡ para escribir la pregunta correcta para que puedas obtener mÃ¡s fÃ¡cilmente una buena respuesta, o incluso resolver el problema por ti mismo antes de preguntar. Y en GitHub puedo asegurarme de responder siempre todo, incluso si lleva tiempo. No puedo hacer eso personalmente con los sistemas de chat. ðŸ˜…

Las conversaciones en los sistemas de chat tampoco son tan fÃ¡cilmente buscables como en GitHub, por lo que las preguntas y respuestas podrÃ­an perderse en la conversaciÃ³n. Y solo las que estÃ¡n en GitHub cuentan para convertirse en un [FastAPI Expert](fastapi-people.md#fastapi-experts){.internal-link target=_blank}, por lo que probablemente recibirÃ¡s mÃ¡s atenciÃ³n en GitHub.

Por otro lado, hay miles de usuarios en los sistemas de chat, por lo que hay muchas posibilidades de que encuentres a alguien con quien hablar allÃ­, casi todo el tiempo. ðŸ˜„

## Patrocina al autor

TambiÃ©n puedes apoyar financieramente al autor (a mÃ­) a travÃ©s de <a href="https://github.com/sponsors/tiangolo" class="external-link" target="_blank">GitHub sponsors</a>.

AllÃ­ podrÃ­as comprarme un cafÃ© â˜•ï¸ para decir gracias. ðŸ˜„

Y tambiÃ©n puedes convertirte en un sponsor de Plata o de Oro para FastAPI. ðŸ…ðŸŽ‰

## Patrocina las herramientas que impulsan FastAPI

Como habrÃ¡s visto en la documentaciÃ³n, FastAPI se apoya en los hombros de gigantes, Starlette y Pydantic.

TambiÃ©n puedes patrocinar:

* <a href="https://github.com/sponsors/samuelcolvin" class="external-link" target="_blank">Samuel Colvin (Pydantic)</a>
* <a href="https://github.com/sponsors/encode" class="external-link" target="_blank">Encode (Starlette, Uvicorn)</a>

---

Â¡Gracias! ðŸš€


================================================
File: /docs/es/docs/history-design-future.md
================================================
# Historia, DiseÃ±o y Futuro

Hace algÃºn tiempo, <a href="https://github.com/fastapi/fastapi/issues/3#issuecomment-454956920" class="external-link" target="_blank">un usuario de **FastAPI** preguntÃ³</a>:

> Â¿CuÃ¡l es la historia de este proyecto? Parece haber surgido de la nada y ser increÃ­ble en pocas semanas [...]

AquÃ­ hay un poquito de esa historia.

## Alternativas

He estado creando APIs con requisitos complejos durante varios aÃ±os (Machine Learning, sistemas distribuidos, trabajos asÃ­ncronos, bases de datos NoSQL, etc.), liderando varios equipos de desarrolladores.

Como parte de eso, necesitaba investigar, probar y usar muchas alternativas.

La historia de **FastAPI** es en gran parte la historia de sus predecesores.

Como se dice en la secciÃ³n [Alternativas](alternatives.md){.internal-link target=_blank}:

<blockquote markdown="1">

**FastAPI** no existirÃ­a si no fuera por el trabajo previo de otros.

Ha habido muchas herramientas creadas antes que han ayudado a inspirar su creaciÃ³n.

He estado evitando la creaciÃ³n de un nuevo framework durante varios aÃ±os. Primero tratÃ© de resolver todas las funcionalidades cubiertas por **FastAPI** usando varios frameworks, complementos y herramientas diferentes.

Pero en algÃºn momento, no habÃ­a otra opciÃ³n que crear algo que proporcionara todas estas funcionalidades, tomando las mejores ideas de herramientas anteriores y combinÃ¡ndolas de la mejor manera posible, usando funcionalidades del lenguaje que ni siquiera estaban disponibles antes (anotaciones de tipos de Python 3.6+).

</blockquote>

## InvestigaciÃ³n

Al usar todas las alternativas anteriores, tuve la oportunidad de aprender de todas ellas, tomar ideas y combinarlas de la mejor manera que pude encontrar para mÃ­ y los equipos de desarrolladores con los que he trabajado.

Por ejemplo, estaba claro que idealmente deberÃ­a estar basado en las anotaciones de tipos estÃ¡ndar de Python.

TambiÃ©n, el mejor enfoque era usar estÃ¡ndares ya existentes.

Entonces, antes de siquiera empezar a programar **FastAPI**, pasÃ© varios meses estudiando las especificaciones de OpenAPI, JSON Schema, OAuth2, etc. Entendiendo su relaciÃ³n, superposiciÃ³n y diferencias.

## DiseÃ±o

Luego pasÃ© algÃºn tiempo diseÃ±ando la "API" de desarrollador que querÃ­a tener como usuario (como desarrollador usando FastAPI).

ProbÃ© varias ideas en los editores de Python mÃ¡s populares: PyCharm, VS Code, editores basados en Jedi.

SegÃºn la Ãºltima <a href="https://www.jetbrains.com/research/python-developers-survey-2018/#development-tools" class="external-link" target="_blank">Encuesta de Desarrolladores de Python</a>, estos editores cubren alrededor del 80% de los usuarios.

Esto significa que **FastAPI** fue especÃ­ficamente probado con los editores usados por el 80% de los desarrolladores de Python. Y como la mayorÃ­a de los otros editores tienden a funcionar de manera similar, todos sus beneficios deberÃ­an funcionar prÃ¡cticamente para todos los editores.

De esa manera, pude encontrar las mejores maneras de reducir la duplicaciÃ³n de cÃ³digo tanto como fuera posible, para tener autocompletado en todas partes, chequeos de tipos y errores, etc.

Todo de una manera que proporcionara la mejor experiencia de desarrollo para todos los desarrolladores.

## Requisitos

DespuÃ©s de probar varias alternativas, decidÃ­ que iba a usar <a href="https://docs.pydantic.dev/" class="external-link" target="_blank">**Pydantic**</a> por sus ventajas.

Luego contribuÃ­ a este, para hacerlo totalmente compatible con JSON Schema, para soportar diferentes maneras de definir declaraciones de restricciones, y para mejorar el soporte de los editores (chequeo de tipos, autocompletado) basado en las pruebas en varios editores.

Durante el desarrollo, tambiÃ©n contribuÃ­ a <a href="https://www.starlette.io/" class="external-link" target="_blank">**Starlette**</a>, el otro requisito clave.

## Desarrollo

Para cuando comencÃ© a crear el propio **FastAPI**, la mayorÃ­a de las piezas ya estaban en su lugar, el diseÃ±o estaba definido, los requisitos y herramientas estaban listos, y el conocimiento sobre los estÃ¡ndares y especificaciones estaba claro y fresco.

## Futuro

A este punto, ya estÃ¡ claro que **FastAPI** con sus ideas estÃ¡ siendo Ãºtil para muchas personas.

EstÃ¡ siendo elegido sobre alternativas anteriores por adaptarse mejor a muchos casos de uso.

Muchos desarrolladores y equipos ya dependen de **FastAPI** para sus proyectos (incluyÃ©ndome a mÃ­ y a mi equipo).

Pero aÃºn asÃ­, hay muchas mejoras y funcionalidades por venir.

**FastAPI** tiene un gran futuro por delante.

Y [tu ayuda](help-fastapi.md){.internal-link target=_blank} es muy apreciada.


================================================
File: /docs/es/docs/index.md
================================================
# FastAPI

<style>
.md-content .md-typeset h1 { display: none; }
</style>

<p align="center">
  <a href="https://fastapi.tiangolo.com"><img src="https://fastapi.tiangolo.com/img/logo-margin/logo-teal.png" alt="FastAPI"></a>
</p>
<p align="center">
    <em>FastAPI framework, alto rendimiento, fÃ¡cil de aprender, rÃ¡pido de programar, listo para producciÃ³n</em>
</p>
<p align="center">
<a href="https://github.com/fastapi/fastapi/actions?query=workflow%3ATest+event%3Apush+branch%3Amaster" target="_blank">
    <img src="https://github.com/fastapi/fastapi/workflows/Test/badge.svg?event=push&branch=master" alt="Test">
</a>
<a href="https://coverage-badge.samuelcolvin.workers.dev/redirect/fastapi/fastapi" target="_blank">
    <img src="https://coverage-badge.samuelcolvin.workers.dev/fastapi/fastapi.svg" alt="Coverage">
</a>
<a href="https://pypi.org/project/fastapi" target="_blank">
    <img src="https://img.shields.io/pypi/v/fastapi?color=%2334D058&label=pypi%20package" alt="Package version">
</a>
<a href="https://pypi.org/project/fastapi" target="_blank">
    <img src="https://img.shields.io/pypi/pyversions/fastapi.svg?color=%2334D058" alt="Supported Python versions">
</a>
</p>

---

**DocumentaciÃ³n**: <a href="https://fastapi.tiangolo.com" target="_blank">https://fastapi.tiangolo.com</a>

**CÃ³digo Fuente**: <a href="https://github.com/fastapi/fastapi" target="_blank">https://github.com/fastapi/fastapi</a>

---

FastAPI es un framework web moderno, rÃ¡pido (de alto rendimiento), para construir APIs con Python basado en las anotaciones de tipos estÃ¡ndar de Python.

Las caracterÃ­sticas clave son:

* **RÃ¡pido**: Muy alto rendimiento, a la par con **NodeJS** y **Go** (gracias a Starlette y Pydantic). [Uno de los frameworks Python mÃ¡s rÃ¡pidos disponibles](#performance).
* **RÃ¡pido de programar**: Aumenta la velocidad para desarrollar funcionalidades en aproximadamente un 200% a 300%. *
* **Menos bugs**: Reduce en aproximadamente un 40% los errores inducidos por humanos (desarrolladores). *
* **Intuitivo**: Gran soporte para editores. <abbr title="tambiÃ©n conocido como autocompletado, IntelliSense">Autocompletado</abbr> en todas partes. Menos tiempo depurando.
* **FÃ¡cil**: DiseÃ±ado para ser fÃ¡cil de usar y aprender. Menos tiempo leyendo documentaciÃ³n.
* **Corto**: Minimiza la duplicaciÃ³n de cÃ³digo. MÃºltiples funcionalidades desde cada declaraciÃ³n de parÃ¡metro. Menos bugs.
* **Robusto**: ObtÃ©n cÃ³digo listo para producciÃ³n. Con documentaciÃ³n interactiva automÃ¡tica.
* **Basado en estÃ¡ndares**: Basado (y completamente compatible) con los estÃ¡ndares abiertos para APIs: <a href="https://github.com/OAI/OpenAPI-Specification" class="external-link" target="_blank">OpenAPI</a> (anteriormente conocido como Swagger) y <a href="https://json-schema.org/" class="external-link" target="_blank">JSON Schema</a>.

<small>* estimaciÃ³n basada en pruebas con un equipo de desarrollo interno, construyendo aplicaciones de producciÃ³n.</small>

## Sponsors

<!-- sponsors -->

{% if sponsors %}
{% for sponsor in sponsors.gold -%}
<a href="{{ sponsor.url }}" target="_blank" title="{{ sponsor.title }}"><img src="{{ sponsor.img }}" style="border-radius:15px"></a>
{% endfor -%}
{%- for sponsor in sponsors.silver -%}
<a href="{{ sponsor.url }}" target="_blank" title="{{ sponsor.title }}"><img src="{{ sponsor.img }}" style="border-radius:15px"></a>
{% endfor %}
{% endif %}

<!-- /sponsors -->

<a href="https://fastapi.tiangolo.com/fastapi-people/#sponsors" class="external-link" target="_blank">Otros sponsors</a>

## Opiniones

"_[...] Estoy usando **FastAPI** un montÃ³n estos dÃ­as. [...] De hecho, estoy planeando usarlo para todos los servicios de **ML de mi equipo en Microsoft**. Algunos de ellos se estÃ¡n integrando en el nÃºcleo del producto **Windows** y algunos productos de **Office**._"

<div style="text-align: right; margin-right: 10%;">Kabir Khan - <strong>Microsoft</strong> <a href="https://github.com/fastapi/fastapi/pull/26" target="_blank"><small>(ref)</small></a></div>

---

"_Adoptamos el paquete **FastAPI** para crear un servidor **REST** que pueda ser consultado para obtener **predicciones**. [para Ludwig]_"

<div style="text-align: right; margin-right: 10%;">Piero Molino, Yaroslav Dudin, y Sai Sumanth Miryala - <strong>Uber</strong> <a href="https://eng.uber.com/ludwig-v0-2/" target="_blank"><small>(ref)</small></a></div>

---

"_**Netflix** se complace en anunciar el lanzamiento de cÃ³digo abierto de nuestro framework de orquestaciÃ³n de **gestiÃ³n de crisis**: **Dispatch**! [construido con **FastAPI**]_"

<div style="text-align: right; margin-right: 10%;">Kevin Glisson, Marc Vilanova, Forest Monsen - <strong>Netflix</strong> <a href="https://netflixtechblog.com/introducing-dispatch-da4b8a2a8072" target="_blank"><small>(ref)</small></a></div>

---

"_Estoy sÃºper emocionado con **FastAPI**. Â¡Es tan divertido!_"

<div style="text-align: right; margin-right: 10%;">Brian Okken - <strong><a href="https://pythonbytes.fm/episodes/show/123/time-to-right-the-py-wrongs?time_in_sec=855" target="_blank">host del podcast Python Bytes</a></strong> <a href="https://twitter.com/brianokken/status/1112220079972728832" target="_blank"><small>(ref)</small></a></div>

---

"_Honestamente, lo que has construido parece sÃºper sÃ³lido y pulido. En muchos aspectos, es lo que querÃ­a que **Hug** fuera; es realmente inspirador ver a alguien construir eso._"

<div style="text-align: right; margin-right: 10%;">Timothy Crosley - <strong><a href="https://github.com/hugapi/hug" target="_blank">creador de Hug</a></strong> <a href="https://news.ycombinator.com/item?id=19455465" target="_blank"><small>(ref)</small></a></div>

---

"_Si estÃ¡s buscando aprender un **framework moderno** para construir APIs REST, Ã©chale un vistazo a **FastAPI** [...] Es rÃ¡pido, fÃ¡cil de usar y fÃ¡cil de aprender [...]_"

"_Nos hemos cambiado a **FastAPI** para nuestras **APIs** [...] Creo que te gustarÃ¡ [...]_"

<div style="text-align: right; margin-right: 10%;">Ines Montani - Matthew Honnibal - <strong><a href="https://explosion.ai" target="_blank">fundadores de Explosion AI</a> - <a href="https://spacy.io" target="_blank">creadores de spaCy</a></strong> <a href="https://twitter.com/_inesmontani/status/1144173225322143744" target="_blank"><small>(ref)</small></a> - <a href="https://twitter.com/honnibal/status/1144031421859655680" target="_blank"><small>(ref)</small></a></div>

---

"_Si alguien estÃ¡ buscando construir una API de Python para producciÃ³n, altamente recomendarÃ­a **FastAPI**. EstÃ¡ **hermosamente diseÃ±ado**, es **simple de usar** y **altamente escalable**, se ha convertido en un **componente clave** en nuestra estrategia de desarrollo API primero y estÃ¡ impulsando muchas automatizaciones y servicios como nuestro Ingeniero Virtual TAC._"

<div style="text-align: right; margin-right: 10%;">Deon Pillsbury - <strong>Cisco</strong> <a href="https://www.linkedin.com/posts/deonpillsbury_cisco-cx-python-activity-6963242628536487936-trAp/" target="_blank"><small>(ref)</small></a></div>

---

## **Typer**, el FastAPI de las CLIs

<a href="https://typer.tiangolo.com" target="_blank"><img src="https://typer.tiangolo.com/img/logo-margin/logo-margin-vector.svg" style="width: 20%;"></a>

Si estÃ¡s construyendo una aplicaciÃ³n de <abbr title="Interfaz de LÃ­nea de Comandos">CLI</abbr> para ser usada en el terminal en lugar de una API web, revisa <a href="https://typer.tiangolo.com/" class="external-link" target="_blank">**Typer**</a>.

**Typer** es el hermano pequeÃ±o de FastAPI. Y estÃ¡ destinado a ser el **FastAPI de las CLIs**. âŒ¨ï¸ ðŸš€

## Requisitos

FastAPI se apoya en hombros de gigantes:

* <a href="https://www.starlette.io/" class="external-link" target="_blank">Starlette</a> para las partes web.
* <a href="https://docs.pydantic.dev/" class="external-link" target="_blank">Pydantic</a> para las partes de datos.

## InstalaciÃ³n

Crea y activa un <a href="https://fastapi.tiangolo.com/virtual-environments/" class="external-link" target="_blank">entorno virtual</a> y luego instala FastAPI:

<div class="termy">

```console
$ pip install "fastapi[standard]"

---> 100%
```

</div>

**Nota**: AsegÃºrate de poner `"fastapi[standard]"` entre comillas para asegurar que funcione en todas las terminales.

## Ejemplo

### CrÃ©alo

* Crea un archivo `main.py` con:

```Python
from typing import Union

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}
```

<details markdown="1">
<summary>O usa <code>async def</code>...</summary>

Si tu cÃ³digo usa `async` / `await`, usa `async def`:

```Python hl_lines="9  14"
from typing import Union

from fastapi import FastAPI

app = FastAPI()


@app.get("/")
async def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
async def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}
```

**Nota**:

Si no lo sabes, revisa la secciÃ³n _"Â¿Con prisa?"_ sobre <a href="https://fastapi.tiangolo.com/async/#in-a-hurry" target="_blank">`async` y `await` en la documentaciÃ³n</a>.

</details>

### CÃ³rrelo

Corre el servidor con:

<div class="termy">

```console
$ fastapi dev main.py

 â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ FastAPI CLI - Development mode â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
 â”‚                                                     â”‚
 â”‚  Serving at: http://127.0.0.1:8000                  â”‚
 â”‚                                                     â”‚
 â”‚  API docs: http://127.0.0.1:8000/docs               â”‚
 â”‚                                                     â”‚
 â”‚  Running in development mode, for production use:   â”‚
 â”‚                                                     â”‚
 â”‚  fastapi run                                        â”‚
 â”‚                                                     â”‚
 â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

INFO:     Will watch for changes in these directories: ['/home/user/code/awesomeapp']
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
INFO:     Started reloader process [2248755] using WatchFiles
INFO:     Started server process [2248757]
INFO:     Waiting for application startup.
INFO:     Application startup complete.
```

</div>

<details markdown="1">
<summary>Acerca del comando <code>fastapi dev main.py</code>...</summary>

El comando `fastapi dev` lee tu archivo `main.py`, detecta la app **FastAPI** en Ã©l y arranca un servidor usando <a href="https://www.uvicorn.org" class="external-link" target="_blank">Uvicorn</a>.

Por defecto, `fastapi dev` comenzarÃ¡ con auto-recarga habilitada para el desarrollo local.

Puedes leer mÃ¡s sobre esto en la <a href="https://fastapi.tiangolo.com/fastapi-cli/" target="_blank">documentaciÃ³n del CLI de FastAPI</a>.

</details>

### RevÃ­salo

Abre tu navegador en <a href="http://127.0.0.1:8000/items/5?q=somequery" class="external-link" target="_blank">http://127.0.0.1:8000/items/5?q=somequery</a>.

VerÃ¡s el response JSON como:

```JSON
{"item_id": 5, "q": "somequery"}
```

Ya creaste una API que:

* Recibe requests HTTP en los _paths_ `/` y `/items/{item_id}`.
* Ambos _paths_ toman _operaciones_ `GET` (tambiÃ©n conocidas como mÃ©todos HTTP).
* El _path_ `/items/{item_id}` tiene un _parÃ¡metro de path_ `item_id` que debe ser un `int`.
* El _path_ `/items/{item_id}` tiene un _parÃ¡metro de query_ `q` opcional que es un `str`.

### DocumentaciÃ³n interactiva de la API

Ahora ve a <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

VerÃ¡s la documentaciÃ³n interactiva automÃ¡tica de la API (proporcionada por <a href="https://github.com/swagger-api/swagger-ui" class="external-link" target="_blank">Swagger UI</a>):

![Swagger UI](https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png)

### DocumentaciÃ³n de API Alternativa

Y ahora, ve a <a href="http://127.0.0.1:8000/redoc" class="external-link" target="_blank">http://127.0.0.1:8000/redoc</a>.

VerÃ¡s la documentaciÃ³n alternativa automÃ¡tica (proporcionada por <a href="https://github.com/Rebilly/ReDoc" class="external-link" target="_blank">ReDoc</a>):

![ReDoc](https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png)

## ActualizaciÃ³n del Ejemplo

Ahora modifica el archivo `main.py` para recibir un body desde un request `PUT`.

Declara el body usando tipos estÃ¡ndar de Python, gracias a Pydantic.

```Python hl_lines="4  9-12  25-27"
from typing import Union

from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()


class Item(BaseModel):
    name: str
    price: float
    is_offer: Union[bool, None] = None


@app.get("/")
def read_root():
    return {"Hello": "World"}


@app.get("/items/{item_id}")
def read_item(item_id: int, q: Union[str, None] = None):
    return {"item_id": item_id, "q": q}


@app.put("/items/{item_id}")
def update_item(item_id: int, item: Item):
    return {"item_name": item.name, "item_id": item_id}
```

El servidor `fastapi dev` deberÃ­a recargarse automÃ¡ticamente.

### ActualizaciÃ³n de la DocumentaciÃ³n Interactiva de la API

Ahora ve a <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

* La documentaciÃ³n interactiva de la API se actualizarÃ¡ automÃ¡ticamente, incluyendo el nuevo body:

![Swagger UI](https://fastapi.tiangolo.com/img/index/index-03-swagger-02.png)

* Haz clic en el botÃ³n "Try it out", te permite llenar los parÃ¡metros e interactuar directamente con la API:

![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-04-swagger-03.png)

* Luego haz clic en el botÃ³n "Execute", la interfaz de usuario se comunicarÃ¡ con tu API, enviarÃ¡ los parÃ¡metros, obtendrÃ¡ los resultados y los mostrarÃ¡ en la pantalla:

![Swagger UI interaction](https://fastapi.tiangolo.com/img/index/index-05-swagger-04.png)

### ActualizaciÃ³n de la DocumentaciÃ³n Alternativa de la API

Y ahora, ve a <a href="http://127.0.0.1:8000/redoc" class="external-link" target="_blank">http://127.0.0.1:8000/redoc</a>.

* La documentaciÃ³n alternativa tambiÃ©n reflejarÃ¡ el nuevo parÃ¡metro de query y body:

![ReDoc](https://fastapi.tiangolo.com/img/index/index-06-redoc-02.png)

### Resumen

En resumen, declaras **una vez** los tipos de parÃ¡metros, body, etc. como parÃ¡metros de funciÃ³n.

Lo haces con tipos estÃ¡ndar modernos de Python.

No tienes que aprender una nueva sintaxis, los mÃ©todos o clases de un paquete especÃ­fico, etc.

Solo **Python** estÃ¡ndar.

Por ejemplo, para un `int`:

```Python
item_id: int
```

o para un modelo `Item` mÃ¡s complejo:

```Python
item: Item
```

...y con esa Ãºnica declaraciÃ³n obtienes:

* Soporte para editores, incluyendo:
    * Autocompletado.
    * Chequeo de tipos.
* ValidaciÃ³n de datos:
    * Errores automÃ¡ticos y claros cuando los datos son invÃ¡lidos.
    * ValidaciÃ³n incluso para objetos JSON profundamente anidados.
* <abbr title="tambiÃ©n conocido como: serializaciÃ³n, parsing, marshalling">ConversiÃ³n</abbr> de datos de entrada: de la red a los datos y tipos de Python. Leyendo desde:
    * JSON.
    * ParÃ¡metros de path.
    * ParÃ¡metros de query.
    * Cookies.
    * Headers.
    * Forms.
    * Archivos.
* <abbr title="tambiÃ©n conocido como: serializaciÃ³n, parsing, marshalling">ConversiÃ³n</abbr> de datos de salida: convirtiendo de datos y tipos de Python a datos de red (como JSON):
    * Convertir tipos de Python (`str`, `int`, `float`, `bool`, `list`, etc).
    * Objetos `datetime`.
    * Objetos `UUID`.
    * Modelos de base de datos.
    * ...y muchos mÃ¡s.
* DocumentaciÃ³n interactiva automÃ¡tica de la API, incluyendo 2 interfaces de usuario alternativas:
    * Swagger UI.
    * ReDoc.

---

Volviendo al ejemplo de cÃ³digo anterior, **FastAPI**:

* ValidarÃ¡ que haya un `item_id` en el path para requests `GET` y `PUT`.
* ValidarÃ¡ que el `item_id` sea del tipo `int` para requests `GET` y `PUT`.
    * Si no lo es, el cliente verÃ¡ un error Ãºtil y claro.
* ComprobarÃ¡ si hay un parÃ¡metro de query opcional llamado `q` (como en `http://127.0.0.1:8000/items/foo?q=somequery`) para requests `GET`.
    * Como el parÃ¡metro `q` estÃ¡ declarado con `= None`, es opcional.
    * Sin el `None` serÃ­a requerido (como lo es el body en el caso con `PUT`).
* Para requests `PUT` a `/items/{item_id}`, leerÃ¡ el body como JSON:
    * ComprobarÃ¡ que tiene un atributo requerido `name` que debe ser un `str`.
    * ComprobarÃ¡ que tiene un atributo requerido `price` que debe ser un `float`.
    * ComprobarÃ¡ que tiene un atributo opcional `is_offer`, que debe ser un `bool`, si estÃ¡ presente.
    * Todo esto tambiÃ©n funcionarÃ­a para objetos JSON profundamente anidados.
* ConvertirÃ¡ de y a JSON automÃ¡ticamente.
* DocumentarÃ¡ todo con OpenAPI, que puede ser usado por:
    * Sistemas de documentaciÃ³n interactiva.
    * Sistemas de generaciÃ³n automÃ¡tica de cÃ³digo cliente, para muchos lenguajes.
* ProporcionarÃ¡ 2 interfaces web de documentaciÃ³n interactiva directamente.

---

Solo tocamos los conceptos bÃ¡sicos, pero ya te haces una idea de cÃ³mo funciona todo.

Intenta cambiar la lÃ­nea con:

```Python
    return {"item_name": item.name, "item_id": item_id}
```

...desde:

```Python
        ... "item_name": item.name ...
```

...a:

```Python
        ... "item_price": item.price ...
```

...y observa cÃ³mo tu editor autocompleta los atributos y conoce sus tipos:

![editor support](https://fastapi.tiangolo.com/img/vscode-completion.png)

Para un ejemplo mÃ¡s completo incluyendo mÃ¡s funcionalidades, ve al <a href="https://fastapi.tiangolo.com/tutorial/">Tutorial - GuÃ­a del Usuario</a>.

**Alerta de spoilers**: el tutorial - guÃ­a del usuario incluye:

* DeclaraciÃ³n de **parÃ¡metros** desde otros lugares diferentes como: **headers**, **cookies**, **campos de formulario** y **archivos**.
* CÃ³mo establecer **restricciones de validaciÃ³n** como `maximum_length` o `regex`.
* Un sistema de **<abbr title="tambiÃ©n conocido como componentes, recursos, proveedores, servicios, inyectables">InyecciÃ³n de Dependencias</abbr>** muy poderoso y fÃ¡cil de usar.
* Seguridad y autenticaciÃ³n, incluyendo soporte para **OAuth2** con **tokens JWT** y autenticaciÃ³n **HTTP Basic**.
* TÃ©cnicas mÃ¡s avanzadas (pero igualmente fÃ¡ciles) para declarar **modelos JSON profundamente anidados** (gracias a Pydantic).
* IntegraciÃ³n con **GraphQL** usando <a href="https://strawberry.rocks" class="external-link" target="_blank">Strawberry</a> y otros paquetes.
* Muchas funcionalidades extra (gracias a Starlette) como:
    * **WebSockets**
    * pruebas extremadamente fÃ¡ciles basadas en HTTPX y `pytest`
    * **CORS**
    * **Sesiones de Cookies**
    * ...y mÃ¡s.

## Rendimiento

Benchmarks independientes de TechEmpower muestran aplicaciones **FastAPI** ejecutÃ¡ndose bajo Uvicorn como <a href="https://www.techempower.com/benchmarks/#section=test&runid=7464e520-0dc2-473d-bd34-dbdfd7e85911&hw=ph&test=query&l=zijzen-7" class="external-link" target="_blank">uno de los frameworks Python mÃ¡s rÃ¡pidos disponibles</a>, solo por debajo de Starlette y Uvicorn (usados internamente por FastAPI). (*)

Para entender mÃ¡s sobre esto, ve la secciÃ³n <a href="https://fastapi.tiangolo.com/benchmarks/" class="internal-link" target="_blank">Benchmarks</a>.

## Dependencias

FastAPI depende de Pydantic y Starlette.

### Dependencias `standard`

Cuando instalas FastAPI con `pip install "fastapi[standard]"` viene con el grupo `standard` de dependencias opcionales:

Usadas por Pydantic:

* <a href="https://github.com/JoshData/python-email-validator" target="_blank"><code>email-validator</code></a> - para validaciÃ³n de correos electrÃ³nicos.

Usadas por Starlette:

* <a href="https://www.python-httpx.org" target="_blank"><code>httpx</code></a> - Requerido si deseas usar el `TestClient`.
* <a href="https://jinja.palletsprojects.com" target="_blank"><code>jinja2</code></a> - Requerido si deseas usar la configuraciÃ³n de plantilla predeterminada.
* <a href="https://github.com/Kludex/python-multipart" target="_blank"><code>python-multipart</code></a> - Requerido si deseas soportar <abbr title="convertir el string que viene de un request HTTP en datos de Python">"parsing"</abbr> de forms, con `request.form()`.

Usadas por FastAPI / Starlette:

* <a href="https://www.uvicorn.org" target="_blank"><code>uvicorn</code></a> - para el servidor que carga y sirve tu aplicaciÃ³n. Esto incluye `uvicorn[standard]`, que incluye algunas dependencias (por ejemplo, `uvloop`) necesarias para servir con alto rendimiento.
* `fastapi-cli` - para proporcionar el comando `fastapi`.

### Sin Dependencias `standard`

Si no deseas incluir las dependencias opcionales `standard`, puedes instalar con `pip install fastapi` en lugar de `pip install "fastapi[standard]"`.

### Dependencias Opcionales Adicionales

Existen algunas dependencias adicionales que podrÃ­as querer instalar.

Dependencias opcionales adicionales de Pydantic:

* <a href="https://docs.pydantic.dev/latest/usage/pydantic_settings/" target="_blank"><code>pydantic-settings</code></a> - para la gestiÃ³n de configuraciones.
* <a href="https://docs.pydantic.dev/latest/usage/types/extra_types/extra_types/" target="_blank"><code>pydantic-extra-types</code></a> - para tipos extra para ser usados con Pydantic.

Dependencias opcionales adicionales de FastAPI:

* <a href="https://github.com/ijl/orjson" target="_blank"><code>orjson</code></a> - Requerido si deseas usar `ORJSONResponse`.
* <a href="https://github.com/esnme/ultrajson" target="_blank"><code>ujson</code></a> - Requerido si deseas usar `UJSONResponse`.

## Licencia

Este proyecto tiene licencia bajo los tÃ©rminos de la licencia MIT.


================================================
File: /docs/es/docs/project-generation.md
================================================
# Plantilla Full Stack FastAPI

Las plantillas, aunque normalmente vienen con una configuraciÃ³n especÃ­fica, estÃ¡n diseÃ±adas para ser flexibles y personalizables. Esto te permite modificarlas y adaptarlas a los requisitos de tu proyecto, haciÃ©ndolas un excelente punto de partida. ðŸ

Puedes usar esta plantilla para comenzar, ya que incluye gran parte de la configuraciÃ³n inicial, seguridad, base de datos y algunos endpoints de API ya hechos para ti.

Repositorio de GitHub: <a href="https://github.com/tiangolo/full-stack-fastapi-template" class="external-link" target="_blank">Plantilla Full Stack FastAPI</a>

## Plantilla Full Stack FastAPI - TecnologÃ­a y Funcionalidades

- âš¡ [**FastAPI**](https://fastapi.tiangolo.com) para la API del backend en Python.
    - ðŸ§° [SQLModel](https://sqlmodel.tiangolo.com) para las interacciones con bases de datos SQL en Python (ORM).
    - ðŸ” [Pydantic](https://docs.pydantic.dev), utilizado por FastAPI, para la validaciÃ³n de datos y gestiÃ³n de configuraciones.
    - ðŸ’¾ [PostgreSQL](https://www.postgresql.org) como base de datos SQL.
- ðŸš€ [React](https://react.dev) para el frontend.
    - ðŸ’ƒ Usando TypeScript, hooks, [Vite](https://vitejs.dev), y otras partes de una stack moderna de frontend.
    - ðŸŽ¨ [Chakra UI](https://chakra-ui.com) para los componentes del frontend.
    - ðŸ¤– Un cliente de frontend generado automÃ¡ticamente.
    - ðŸ§ª [Playwright](https://playwright.dev) para pruebas End-to-End.
    - ðŸ¦‡ Soporte para modo oscuro.
- ðŸ‹ [Docker Compose](https://www.docker.com) para desarrollo y producciÃ³n.
- ðŸ”’ Hashing seguro de contraseÃ±as por defecto.
- ðŸ”‘ AutenticaciÃ³n con tokens JWT.
- ðŸ“« RecuperaciÃ³n de contraseÃ±as basada en email.
- âœ… Pruebas con [Pytest](https://pytest.org).
- ðŸ“ž [Traefik](https://traefik.io) como proxy inverso / balanceador de carga.
- ðŸš¢ Instrucciones de despliegue usando Docker Compose, incluyendo cÃ³mo configurar un proxy Traefik frontend para manejar certificados HTTPS automÃ¡ticos.
- ðŸ­ CI (integraciÃ³n continua) y CD (despliegue continuo) basados en GitHub Actions.


================================================
File: /docs/es/docs/python-types.md
================================================
# IntroducciÃ³n a Tipos en Python

Python tiene soporte para "anotaciones de tipos" opcionales (tambiÃ©n llamadas "type hints").

Estas **"anotaciones de tipos"** o type hints son una sintaxis especial que permite declarar el <abbr title="por ejemplo: str, int, float, bool">tipo</abbr> de una variable.

Al declarar tipos para tus variables, los editores y herramientas te pueden proporcionar un mejor soporte.

Este es solo un **tutorial rÃ¡pido / recordatorio** sobre las anotaciones de tipos en Python. Cubre solo lo mÃ­nimo necesario para usarlas con **FastAPI**... que en realidad es muy poco.

**FastAPI** se basa completamente en estas anotaciones de tipos, dÃ¡ndole muchas ventajas y beneficios.

Pero incluso si nunca usas **FastAPI**, te beneficiarÃ­a aprender un poco sobre ellas.

/// note | Nota

Si eres un experto en Python, y ya sabes todo sobre las anotaciones de tipos, salta al siguiente capÃ­tulo.

///

## MotivaciÃ³n

Comencemos con un ejemplo simple:

{* ../../docs_src/python_types/tutorial001.py *}

Llamar a este programa genera:

```
John Doe
```

La funciÃ³n hace lo siguiente:

* Toma un `first_name` y `last_name`.
* Convierte la primera letra de cada uno a mayÃºsculas con `title()`.
* <abbr title="Los une, como uno. Con el contenido de uno despuÃ©s del otro.">Concatena</abbr> ambos con un espacio en el medio.

{* ../../docs_src/python_types/tutorial001.py hl[2] *}

### EdÃ­talo

Es un programa muy simple.

Pero ahora imagina que lo escribieras desde cero.

En algÃºn momento habrÃ­as empezado la definiciÃ³n de la funciÃ³n, tenÃ­as los parÃ¡metros listos...

Pero luego tienes que llamar "ese mÃ©todo que convierte la primera letra a mayÃºscula".

Â¿Era `upper`? Â¿Era `uppercase`? `first_uppercase`? `capitalize`?

Entonces, pruebas con el amigo del viejo programador, el autocompletado del editor.

Escribes el primer parÃ¡metro de la funciÃ³n, `first_name`, luego un punto (`.`) y luego presionas `Ctrl+Espacio` para activar el autocompletado.

Pero, tristemente, no obtienes nada Ãºtil:

<img src="/img/python-types/image01.png">

### AÃ±adir tipos

Modifiquemos una sola lÃ­nea de la versiÃ³n anterior.

Cambiaremos exactamente este fragmento, los parÃ¡metros de la funciÃ³n, de:

```Python
    first_name, last_name
```

a:

```Python
    first_name: str, last_name: str
```

Eso es todo.

Esas son las "anotaciones de tipos":

{* ../../docs_src/python_types/tutorial002.py hl[1] *}

Eso no es lo mismo que declarar valores predeterminados como serÃ­a con:

```Python
    first_name="john", last_name="doe"
```

Es una cosa diferente.

Estamos usando dos puntos (`:`), no igualdades (`=`).

Y agregar anotaciones de tipos normalmente no cambia lo que sucede de lo que ocurrirÃ­a sin ellas.

Pero ahora, imagina que nuevamente estÃ¡s en medio de la creaciÃ³n de esa funciÃ³n, pero con anotaciones de tipos.

En el mismo punto, intentas activar el autocompletado con `Ctrl+Espacio` y ves:

<img src="/img/python-types/image02.png">

Con eso, puedes desplazarte, viendo las opciones, hasta que encuentres la que "te suene":

<img src="/img/python-types/image03.png">

## MÃ¡s motivaciÃ³n

Revisa esta funciÃ³n, ya tiene anotaciones de tipos:

{* ../../docs_src/python_types/tutorial003.py hl[1] *}

Porque el editor conoce los tipos de las variables, no solo obtienes autocompletado, tambiÃ©n obtienes chequeo de errores:

<img src="/img/python-types/image04.png">

Ahora sabes que debes corregirlo, convertir `age` a un string con `str(age)`:

{* ../../docs_src/python_types/tutorial004.py hl[2] *}

## DeclaraciÃ³n de tipos

Acabas de ver el lugar principal para declarar anotaciones de tipos. Como parÃ¡metros de funciÃ³n.

Este tambiÃ©n es el lugar principal donde los utilizarÃ­as con **FastAPI**.

### Tipos simples

Puedes declarar todos los tipos estÃ¡ndar de Python, no solo `str`.

Puedes usar, por ejemplo:

* `int`
* `float`
* `bool`
* `bytes`

{* ../../docs_src/python_types/tutorial005.py hl[1] *}

### Tipos genÃ©ricos con parÃ¡metros de tipo

Hay algunas estructuras de datos que pueden contener otros valores, como `dict`, `list`, `set` y `tuple`. Y los valores internos tambiÃ©n pueden tener su propio tipo.

Estos tipos que tienen tipos internos se denominan tipos "**genÃ©ricos**". Y es posible declararlos, incluso con sus tipos internos.

Para declarar esos tipos y los tipos internos, puedes usar el mÃ³dulo estÃ¡ndar de Python `typing`. Existe especÃ­ficamente para soportar estas anotaciones de tipos.

#### Versiones mÃ¡s recientes de Python

La sintaxis que utiliza `typing` es **compatible** con todas las versiones, desde Python 3.6 hasta las versiones mÃ¡s recientes, incluyendo Python 3.9, Python 3.10, etc.

A medida que avanza Python, las **versiones mÃ¡s recientes** vienen con soporte mejorado para estas anotaciones de tipos y en muchos casos ni siquiera necesitarÃ¡s importar y usar el mÃ³dulo `typing` para declarar las anotaciones de tipos.

Si puedes elegir una versiÃ³n mÃ¡s reciente de Python para tu proyecto, podrÃ¡s aprovechar esa simplicidad adicional.

En toda la documentaciÃ³n hay ejemplos compatibles con cada versiÃ³n de Python (cuando hay una diferencia).

Por ejemplo, "**Python 3.6+**" significa que es compatible con Python 3.6 o superior (incluyendo 3.7, 3.8, 3.9, 3.10, etc). Y "**Python 3.9+**" significa que es compatible con Python 3.9 o superior (incluyendo 3.10, etc).

Si puedes usar las **Ãºltimas versiones de Python**, utiliza los ejemplos para la Ãºltima versiÃ³n, esos tendrÃ¡n la **mejor y mÃ¡s simple sintaxis**, por ejemplo, "**Python 3.10+**".

#### Lista

Por ejemplo, vamos a definir una variable para ser una `list` de `str`.

//// tab | Python 3.9+

Declara la variable, con la misma sintaxis de dos puntos (`:`).

Como tipo, pon `list`.

Como la lista es un tipo que contiene algunos tipos internos, los pones entre corchetes:

```Python hl_lines="1"
{!> ../../docs_src/python_types/tutorial006_py39.py!}
```

////

//// tab | Python 3.8+

De `typing`, importa `List` (con una `L` mayÃºscula):

```Python hl_lines="1"
{!> ../../docs_src/python_types/tutorial006.py!}
```

Declara la variable, con la misma sintaxis de dos puntos (`:`).

Como tipo, pon el `List` que importaste de `typing`.

Como la lista es un tipo que contiene algunos tipos internos, los pones entre corchetes:

```Python hl_lines="4"
{!> ../../docs_src/python_types/tutorial006.py!}
```

////

/// info | InformaciÃ³n

Esos tipos internos en los corchetes se denominan "parÃ¡metros de tipo".

En este caso, `str` es el parÃ¡metro de tipo pasado a `List` (o `list` en Python 3.9 y superior).

///

Eso significa: "la variable `items` es una `list`, y cada uno de los Ã­tems en esta lista es un `str`".

/// tip | Consejo

Si usas Python 3.9 o superior, no tienes que importar `List` de `typing`, puedes usar el mismo tipo `list` regular en su lugar.

///

Al hacer eso, tu editor puede proporcionar soporte incluso mientras procesa elementos de la lista:

<img src="/img/python-types/image05.png">

Sin tipos, eso es casi imposible de lograr.

Nota que la variable `item` es uno de los elementos en la lista `items`.

Y aÃºn asÃ­, el editor sabe que es un `str` y proporciona soporte para eso.

#### Tuple y Set

HarÃ­as lo mismo para declarar `tuple`s y `set`s:

//// tab | Python 3.9+

```Python hl_lines="1"
{!> ../../docs_src/python_types/tutorial007_py39.py!}
```

////

//// tab | Python 3.8+

```Python hl_lines="1  4"
{!> ../../docs_src/python_types/tutorial007.py!}
```

////

Esto significa:

* La variable `items_t` es un `tuple` con 3 Ã­tems, un `int`, otro `int`, y un `str`.
* La variable `items_s` es un `set`, y cada uno de sus Ã­tems es del tipo `bytes`.

#### Dict

Para definir un `dict`, pasas 2 parÃ¡metros de tipo, separados por comas.

El primer parÃ¡metro de tipo es para las claves del `dict`.

El segundo parÃ¡metro de tipo es para los valores del `dict`:

//// tab | Python 3.9+

```Python hl_lines="1"
{!> ../../docs_src/python_types/tutorial008_py39.py!}
```

////

//// tab | Python 3.8+

```Python hl_lines="1  4"
{!> ../../docs_src/python_types/tutorial008.py!}
```

////

Esto significa:

* La variable `prices` es un `dict`:
    * Las claves de este `dict` son del tipo `str` (digamos, el nombre de cada Ã­tem).
    * Los valores de este `dict` son del tipo `float` (digamos, el precio de cada Ã­tem).

#### Union

Puedes declarar que una variable puede ser cualquier de **varios tipos**, por ejemplo, un `int` o un `str`.

En Python 3.6 y posterior (incluyendo Python 3.10) puedes usar el tipo `Union` de `typing` y poner dentro de los corchetes los posibles tipos a aceptar.

En Python 3.10 tambiÃ©n hay una **nueva sintaxis** donde puedes poner los posibles tipos separados por una <abbr title='tambiÃ©n llamado "operador OR a nivel de bits", pero ese significado no es relevante aquÃ­'>barra vertical (`|`)</abbr>.

//// tab | Python 3.10+

```Python hl_lines="1"
{!> ../../docs_src/python_types/tutorial008b_py310.py!}
```

////

//// tab | Python 3.8+

```Python hl_lines="1  4"
{!> ../../docs_src/python_types/tutorial008b.py!}
```

////

En ambos casos, esto significa que `item` podrÃ­a ser un `int` o un `str`.

#### Posiblemente `None`

Puedes declarar que un valor podrÃ­a tener un tipo, como `str`, pero que tambiÃ©n podrÃ­a ser `None`.

En Python 3.6 y posteriores (incluyendo Python 3.10) puedes declararlo importando y usando `Optional` del mÃ³dulo `typing`.

```Python hl_lines="1  4"
{!../../docs_src/python_types/tutorial009.py!}
```

Usar `Optional[str]` en lugar de solo `str` te permitirÃ¡ al editor ayudarte a detectar errores donde podrÃ­as estar asumiendo que un valor siempre es un `str`, cuando en realidad tambiÃ©n podrÃ­a ser `None`.

`Optional[Something]` es realmente un atajo para `Union[Something, None]`, son equivalentes.

Esto tambiÃ©n significa que en Python 3.10, puedes usar `Something | None`:

//// tab | Python 3.10+

```Python hl_lines="1"
{!> ../../docs_src/python_types/tutorial009_py310.py!}
```

////

//// tab | Python 3.8+

```Python hl_lines="1  4"
{!> ../../docs_src/python_types/tutorial009.py!}
```

////

//// tab | Python 3.8+ alternative

```Python hl_lines="1  4"
{!> ../../docs_src/python_types/tutorial009b.py!}
```

////

#### Uso de `Union` u `Optional`

Si estÃ¡s usando una versiÃ³n de Python inferior a 3.10, aquÃ­ tienes un consejo desde mi punto de vista muy **subjetivo**:

* ðŸš¨ Evita usar `Optional[SomeType]`
* En su lugar âœ¨ **usa `Union[SomeType, None]`** âœ¨.

Ambos son equivalentes y debajo son lo mismo, pero recomendarÃ­a `Union` en lugar de `Optional` porque la palabra "**opcional**" parecerÃ­a implicar que el valor es opcional, y en realidad significa "puede ser `None`", incluso si no es opcional y aÃºn es requerido.

Creo que `Union[SomeType, None]` es mÃ¡s explÃ­cito sobre lo que significa.

Se trata solo de las palabras y nombres. Pero esas palabras pueden afectar cÃ³mo tÃº y tus compaÃ±eros de equipo piensan sobre el cÃ³digo.

Como ejemplo, tomemos esta funciÃ³n:

{* ../../docs_src/python_types/tutorial009c.py hl[1,4] *}

El parÃ¡metro `name` estÃ¡ definido como `Optional[str]`, pero **no es opcional**, no puedes llamar a la funciÃ³n sin el parÃ¡metro:

```Python
say_hi()  # Â¡Oh, no, esto lanza un error! ðŸ˜±
```

El parÃ¡metro `name` sigue siendo **requerido** (no *opcional*) porque no tiene un valor predeterminado. AÃºn asÃ­, `name` acepta `None` como valor:

```Python
say_hi(name=None)  # Esto funciona, None es vÃ¡lido ðŸŽ‰
```

La buena noticia es que, una vez que estÃ©s en Python 3.10, no tendrÃ¡s que preocuparte por eso, ya que podrÃ¡s simplemente usar `|` para definir uniones de tipos:

{* ../../docs_src/python_types/tutorial009c_py310.py hl[1,4] *}

Y entonces no tendrÃ¡s que preocuparte por nombres como `Optional` y `Union`. ðŸ˜Ž

#### Tipos genÃ©ricos

Estos tipos que toman parÃ¡metros de tipo en corchetes se llaman **Tipos GenÃ©ricos** o **GenÃ©ricos**, por ejemplo:

//// tab | Python 3.10+

Puedes usar los mismos tipos integrados como genÃ©ricos (con corchetes y tipos dentro):

* `list`
* `tuple`
* `set`
* `dict`

Y lo mismo que con Python 3.8, desde el mÃ³dulo `typing`:

* `Union`
* `Optional` (lo mismo que con Python 3.8)
* ...y otros.

En Python 3.10, como alternativa a usar los genÃ©ricos `Union` y `Optional`, puedes usar la <abbr title='tambiÃ©n llamado "operador OR a nivel de bits", pero ese significado no es relevante aquÃ­'>barra vertical (`|`)</abbr> para declarar uniones de tipos, eso es mucho mejor y mÃ¡s simple.

////

//// tab | Python 3.9+

Puedes usar los mismos tipos integrados como genÃ©ricos (con corchetes y tipos dentro):

* `list`
* `tuple`
* `set`
* `dict`

Y lo mismo que con Python 3.8, desde el mÃ³dulo `typing`:

* `Union`
* `Optional`
* ...y otros.

////

//// tab | Python 3.8+

* `List`
* `Tuple`
* `Set`
* `Dict`
* `Union`
* `Optional`
* ...y otros.

////

### Clases como tipos

TambiÃ©n puedes declarar una clase como el tipo de una variable.

Digamos que tienes una clase `Person`, con un nombre:

{* ../../docs_src/python_types/tutorial010.py hl[1:3] *}

Luego puedes declarar una variable para que sea de tipo `Person`:

{* ../../docs_src/python_types/tutorial010.py hl[6] *}

Y luego, nuevamente, obtienes todo el soporte del editor:

<img src="/img/python-types/image06.png">

Nota que esto significa "`one_person` es una **instance** de la clase `Person`".

No significa "`one_person` es la **clase** llamada `Person`".

## Modelos Pydantic

<a href="https://docs.pydantic.dev/" class="external-link" target="_blank">Pydantic</a> es un paquete de Python para realizar la validaciÃ³n de datos.

Declaras la "forma" de los datos como clases con atributos.

Y cada atributo tiene un tipo.

Entonces creas un instance de esa clase con algunos valores y validarÃ¡ los valores, los convertirÃ¡ al tipo adecuado (si es el caso) y te darÃ¡ un objeto con todos los datos.

Y obtienes todo el soporte del editor con ese objeto resultante.

Un ejemplo de la documentaciÃ³n oficial de Pydantic:

//// tab | Python 3.10+

```Python
{!> ../../docs_src/python_types/tutorial011_py310.py!}
```

////

//// tab | Python 3.9+

```Python
{!> ../../docs_src/python_types/tutorial011_py39.py!}
```

////

//// tab | Python 3.8+

```Python
{!> ../../docs_src/python_types/tutorial011.py!}
```

////

/// info | InformaciÃ³n

Para saber mÃ¡s sobre <a href="https://docs.pydantic.dev/" class="external-link" target="_blank">Pydantic, revisa su documentaciÃ³n</a>.

///

**FastAPI** estÃ¡ completamente basado en Pydantic.

VerÃ¡s mucho mÃ¡s de todo esto en prÃ¡ctica en el [Tutorial - GuÃ­a del Usuario](tutorial/index.md){.internal-link target=_blank}.

/// tip | Consejo

Pydantic tiene un comportamiento especial cuando utilizas `Optional` o `Union[Something, None]` sin un valor por defecto, puedes leer mÃ¡s sobre ello en la documentaciÃ³n de Pydantic sobre <a href="https://docs.pydantic.dev/2.3/usage/models/#required-fields" class="external-link" target="_blank">Required Optional fields</a>.

///

## Anotaciones de tipos con metadata

Python tambiÃ©n tiene una funcionalidad que permite poner **<abbr title="Datos sobre los datos, en este caso, informaciÃ³n sobre el tipo, por ejemplo, una descripciÃ³n.">metadata</abbr> adicional** en estas anotaciones de tipos usando `Annotated`.

//// tab | Python 3.9+

En Python 3.9, `Annotated` es parte de la librerÃ­a estÃ¡ndar, asÃ­ que puedes importarlo desde `typing`.

```Python hl_lines="1  4"
{!> ../../docs_src/python_types/tutorial013_py39.py!}
```

////

//// tab | Python 3.8+

En versiones por debajo de Python 3.9, importas `Annotated` de `typing_extensions`.

Ya estarÃ¡ instalado con **FastAPI**.

```Python hl_lines="1  4"
{!> ../../docs_src/python_types/tutorial013.py!}
```

////

Python en sÃ­ no hace nada con este `Annotated`. Y para los editores y otras herramientas, el tipo sigue siendo `str`.

Pero puedes usar este espacio en `Annotated` para proporcionar a **FastAPI** metadata adicional sobre cÃ³mo quieres que se comporte tu aplicaciÃ³n.

