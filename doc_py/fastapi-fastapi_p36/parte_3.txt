
`.add_task()` erh√§lt als Argumente:

* Eine Taskfunktion, die im Hintergrund ausgef√ºhrt wird (`write_notification`).
* Eine beliebige Folge von Argumenten, die der Reihe nach an die Taskfunktion √ºbergeben werden sollen (`email`).
* Alle Schl√ºsselwort-Argumente, die an die Taskfunktion √ºbergeben werden sollen (`message="some notification"`).

## Dependency Injection

Die Verwendung von `BackgroundTasks` funktioniert auch mit dem <abbr title="Einbringen von Abh√§ngigkeiten">Dependency Injection</abbr> System. Sie k√∂nnen einen Parameter vom Typ `BackgroundTasks` auf mehreren Ebenen deklarieren: in einer *Pfadoperation-Funktion*, in einer Abh√§ngigkeit (Dependable), in einer Unterabh√§ngigkeit usw.

**FastAPI** wei√ü, was jeweils zu tun ist und wie dasselbe Objekt wiederverwendet werden kann, sodass alle Hintergrundtasks zusammengef√ºhrt und anschlie√üend im Hintergrund ausgef√ºhrt werden:

{* ../../docs_src/background_tasks/tutorial002_an_py310.py hl[13,15,22,25] *}

In obigem Beispiel werden die Nachrichten, *nachdem* die Response gesendet wurde, in die Datei `log.txt` geschrieben.

Wenn im Request ein Query-Parameter enthalten war, wird dieser in einem Hintergrundtask in das Log geschrieben.

Und dann schreibt ein weiterer Hintergrundtask, der in der *Pfadoperation-Funktion* erstellt wird, eine Nachricht unter Verwendung des Pfad-Parameters `email`.

## Technische Details

Die Klasse `BackgroundTasks` stammt direkt von <a href="https://www.starlette.io/background/" class="external-link" target="_blank">`starlette.background`</a>.

Sie wird direkt in FastAPI importiert/inkludiert, sodass Sie sie von `fastapi` importieren k√∂nnen und vermeiden, versehentlich das alternative `BackgroundTask` (ohne das `s` am Ende) von `starlette.background` zu importieren.

Indem Sie nur `BackgroundTasks` (und nicht `BackgroundTask`) verwenden, ist es dann m√∂glich, es als *Pfadoperation-Funktion*-Parameter zu verwenden und **FastAPI** den Rest f√ºr Sie erledigen zu lassen, genau wie bei der direkten Verwendung des `Request`-Objekts.

Es ist immer noch m√∂glich, `BackgroundTask` allein in FastAPI zu verwenden, aber Sie m√ºssen das Objekt in Ihrem Code erstellen und eine Starlette-`Response` zur√ºckgeben, die es enth√§lt.

Weitere Details finden Sie in der <a href="https://www.starlette.io/background/" class="external-link" target="_blank">offiziellen Starlette-Dokumentation f√ºr Hintergrundtasks</a>.

## Vorbehalt

Wenn Sie umfangreiche Hintergrundberechnungen durchf√ºhren m√ºssen und diese nicht unbedingt vom selben Prozess ausgef√ºhrt werden m√ºssen (z. B. m√ºssen Sie Speicher, Variablen, usw. nicht gemeinsam nutzen), k√∂nnte die Verwendung anderer gr√∂√üerer Tools wie z. B. <a href="https://docs.celeryq.dev" class="external-link" target="_blank">Celery</a> von Vorteil sein.

Sie erfordern in der Regel komplexere Konfigurationen und einen Nachrichten-/Job-Queue-Manager wie RabbitMQ oder Redis, erm√∂glichen Ihnen jedoch die Ausf√ºhrung von Hintergrundtasks in mehreren Prozessen und insbesondere auf mehreren Servern.

Wenn Sie jedoch √ºber dieselbe **FastAPI**-Anwendung auf Variablen und Objekte zugreifen oder kleine Hintergrundtasks ausf√ºhren m√ºssen (z. B. das Senden einer E-Mail-Benachrichtigung), k√∂nnen Sie einfach `BackgroundTasks` verwenden.

## Zusammenfassung

Importieren und verwenden Sie `BackgroundTasks` mit Parametern in *Pfadoperation-Funktionen* und Abh√§ngigkeiten, um Hintergrundtasks hinzuzuf√ºgen.


================================================
File: /docs/de/docs/tutorial/bigger-applications.md
================================================
# Gr√∂√üere Anwendungen ‚Äì mehrere Dateien

Wenn Sie eine Anwendung oder eine Web-API erstellen, ist es selten der Fall, dass Sie alles in einer einzigen Datei unterbringen k√∂nnen.

**FastAPI** bietet ein praktisches Werkzeug zur Strukturierung Ihrer Anwendung bei gleichzeitiger Wahrung der Flexibilit√§t.

/// info

Wenn Sie von Flask kommen, w√§re dies das √Ñquivalent zu Flasks Blueprints.

///

## Eine Beispiel-Dateistruktur

Nehmen wir an, Sie haben eine Dateistruktur wie diese:

```
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dependencies.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ routers
‚îÇ¬†¬† ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îÇ   ‚îú‚îÄ‚îÄ items.py
‚îÇ¬†¬† ‚îÇ   ‚îî‚îÄ‚îÄ users.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ internal
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ admin.py
```

/// tip | Tipp

Es gibt mehrere `__init__.py`-Dateien: eine in jedem Verzeichnis oder Unterverzeichnis.

Das erm√∂glicht den Import von Code aus einer Datei in eine andere.

In `app/main.py` k√∂nnten Sie beispielsweise eine Zeile wie diese haben:

```
from app.routers import items
```

///

* Das Verzeichnis `app` enth√§lt alles. Und es hat eine leere Datei `app/__init__.py`, es handelt sich also um ein ‚ÄûPython-Package‚Äú (eine Sammlung von ‚ÄûPython-Modulen‚Äú): `app`.
* Es enth√§lt eine Datei `app/main.py`. Da sie sich in einem Python-Package (einem Verzeichnis mit einer Datei `__init__.py`) befindet, ist sie ein ‚ÄûModul‚Äú dieses Packages: `app.main`.
* Es gibt auch eine Datei `app/dependencies.py`, genau wie `app/main.py` ist sie ein ‚ÄûModul‚Äú: `app.dependencies`.
* Es gibt ein Unterverzeichnis `app/routers/` mit einer weiteren Datei `__init__.py`, es handelt sich also um ein ‚ÄûPython-Subpackage‚Äú: `app.routers`.
* Die Datei `app/routers/items.py` befindet sich in einem Package, `app/routers/`, also ist sie ein Submodul: `app.routers.items`.
* Das Gleiche gilt f√ºr `app/routers/users.py`, es ist ein weiteres Submodul: `app.routers.users`.
* Es gibt auch ein Unterverzeichnis `app/internal/` mit einer weiteren Datei `__init__.py`, es handelt sich also um ein weiteres ‚ÄûPython-Subpackage‚Äú: `app.internal`.
* Und die Datei `app/internal/admin.py` ist ein weiteres Submodul: `app.internal.admin`.

<img src="/img/tutorial/bigger-applications/package.svg">

Die gleiche Dateistruktur mit Kommentaren:

```
.
‚îú‚îÄ‚îÄ app                  # ‚Äûapp‚Äú ist ein Python-Package
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py      # diese Datei macht ‚Äûapp‚Äú zu einem ‚ÄûPython-Package‚Äú
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py          # ‚Äûmain‚Äú-Modul, z. B. import app.main
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ dependencies.py  # ‚Äûdependencies‚Äú-Modul, z. B. import app.dependencies
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ routers          # ‚Äûrouters‚Äú ist ein ‚ÄûPython-Subpackage‚Äú
‚îÇ¬†¬† ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py  # macht ‚Äûrouters‚Äú zu einem ‚ÄûPython-Subpackage‚Äú
‚îÇ¬†¬† ‚îÇ   ‚îú‚îÄ‚îÄ items.py     # ‚Äûitems‚Äú-Submodul, z. B. import app.routers.items
‚îÇ¬†¬† ‚îÇ   ‚îî‚îÄ‚îÄ users.py     # ‚Äûusers‚Äú-Submodul, z. B. import app.routers.users
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ internal         # ‚Äûinternal‚Äú ist ein ‚ÄûPython-Subpackage‚Äú
‚îÇ¬†¬†     ‚îú‚îÄ‚îÄ __init__.py  # macht ‚Äûinternal‚Äú zu einem ‚ÄûPython-Subpackage‚Äú
‚îÇ¬†¬†     ‚îî‚îÄ‚îÄ admin.py     # ‚Äûadmin‚Äú-Submodul, z. B. import app.internal.admin
```

## `APIRouter`

Nehmen wir an, die Datei, die nur f√ºr die Verwaltung von Benutzern zust√§ndig ist, ist das Submodul unter `/app/routers/users.py`.

Sie m√∂chten die *Pfadoperationen* f√ºr Ihre Benutzer vom Rest des Codes trennen, um ihn organisiert zu halten.

Aber es ist immer noch Teil derselben **FastAPI**-Anwendung/Web-API (es ist Teil desselben ‚ÄûPython-Packages‚Äú).

Sie k√∂nnen die *Pfadoperationen* f√ºr dieses Modul mit `APIRouter` erstellen.

### `APIRouter` importieren

Sie importieren ihn und erstellen eine ‚ÄûInstanz‚Äú auf die gleiche Weise wie mit der Klasse `FastAPI`:

```Python hl_lines="1  3" title="app/routers/users.py"
{!../../docs_src/bigger_applications/app/routers/users.py!}
```

### *Pfadoperationen* mit `APIRouter`

Und dann verwenden Sie ihn, um Ihre *Pfadoperationen* zu deklarieren.

Verwenden Sie ihn auf die gleiche Weise wie die Klasse `FastAPI`:

```Python hl_lines="6  11  16" title="app/routers/users.py"
{!../../docs_src/bigger_applications/app/routers/users.py!}
```

Sie k√∂nnen sich `APIRouter` als eine ‚ÄûMini-`FastAPI`‚Äú-Klasse vorstellen.

Alle die gleichen Optionen werden unterst√ºtzt.

Alle die gleichen `parameters`, `responses`, `dependencies`, `tags`, usw.

/// tip | Tipp

In diesem Beispiel hei√üt die Variable `router`, aber Sie k√∂nnen ihr einen beliebigen Namen geben.

///

Wir werden diesen `APIRouter` in die Hauptanwendung `FastAPI` einbinden, aber zuerst k√ºmmern wir uns um die Abh√§ngigkeiten und einen anderen `APIRouter`.

## Abh√§ngigkeiten

Wir sehen, dass wir einige Abh√§ngigkeiten ben√∂tigen, die an mehreren Stellen der Anwendung verwendet werden.

Also f√ºgen wir sie in ihr eigenes `dependencies`-Modul (`app/dependencies.py`) ein.

Wir werden nun eine einfache Abh√§ngigkeit verwenden, um einen benutzerdefinierten `X-Token`-Header zu lesen:

//// tab | Python 3.9+

```Python hl_lines="3  6-8" title="app/dependencies.py"
{!> ../../docs_src/bigger_applications/app_an_py39/dependencies.py!}
```

////

//// tab | Python 3.8+

```Python hl_lines="1  5-7" title="app/dependencies.py"
{!> ../../docs_src/bigger_applications/app_an/dependencies.py!}
```

////

//// tab | Python 3.8+ nicht annotiert

/// tip | Tipp

Bevorzugen Sie die `Annotated`-Version, falls m√∂glich.

///

```Python hl_lines="1  4-6" title="app/dependencies.py"
{!> ../../docs_src/bigger_applications/app/dependencies.py!}
```

////

/// tip | Tipp

Um dieses Beispiel zu vereinfachen, verwenden wir einen erfundenen Header.

Aber in der Praxis werden Sie mit den integrierten [Sicherheits-Werkzeugen](security/index.md){.internal-link target=_blank} bessere Ergebnisse erzielen.

///

## Ein weiteres Modul mit `APIRouter`.

Nehmen wir an, Sie haben im Modul unter `app/routers/items.py` auch die Endpunkte, die f√ºr die Verarbeitung von Artikeln (‚ÄûItems‚Äú) aus Ihrer Anwendung vorgesehen sind.

Sie haben *Pfadoperationen* f√ºr:

* `/items/`
* `/items/{item_id}`

Es ist alles die gleiche Struktur wie bei `app/routers/users.py`.

Aber wir wollen schlauer sein und den Code etwas vereinfachen.

Wir wissen, dass alle *Pfadoperationen* in diesem Modul folgendes haben:

* Pfad-`prefix`: `/items`.
* `tags`: (nur ein Tag: `items`).
* Zus√§tzliche `responses`.
* `dependencies`: Sie alle ben√∂tigen die von uns erstellte `X-Token`-Abh√§ngigkeit.

Anstatt also alles zu jeder *Pfadoperation* hinzuzuf√ºgen, k√∂nnen wir es dem `APIRouter` hinzuf√ºgen.

```Python hl_lines="5-10  16  21" title="app/routers/items.py"
{!../../docs_src/bigger_applications/app/routers/items.py!}
```

Da der Pfad jeder *Pfadoperation* mit `/` beginnen muss, wie in:

```Python hl_lines="1"
@router.get("/{item_id}")
async def read_item(item_id: str):
    ...
```

... darf das Pr√§fix kein abschlie√üendes `/` enthalten.

Das Pr√§fix lautet in diesem Fall also `/items`.

Wir k√∂nnen auch eine Liste von `tags` und zus√§tzliche `responses` hinzuf√ºgen, die auf alle in diesem Router enthaltenen *Pfadoperationen* angewendet werden.

Und wir k√∂nnen eine Liste von `dependencies` hinzuf√ºgen, die allen *Pfadoperationen* im Router hinzugef√ºgt und f√ºr jeden an sie gerichteten Request ausgef√ºhrt/aufgel√∂st werden.

/// tip | Tipp

Beachten Sie, dass √§hnlich wie bei [Abh√§ngigkeiten in *Pfadoperation-Dekoratoren*](dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank} kein Wert an Ihre *Pfadoperation-Funktion* √ºbergeben wird.

///

Das Endergebnis ist, dass die Pfade f√ºr diese Artikel jetzt wie folgt lauten:

* `/items/`
* `/items/{item_id}`

... wie wir es beabsichtigt hatten.

* Sie werden mit einer Liste von Tags gekennzeichnet, die einen einzelnen String `"items"` enth√§lt.
    * Diese ‚ÄûTags‚Äú sind besonders n√ºtzlich f√ºr die automatischen interaktiven Dokumentationssysteme (unter Verwendung von OpenAPI).
* Alle enthalten die vordefinierten `responses`.
* F√ºr alle diese *Pfadoperationen* wird die Liste der `dependencies` ausgewertet/ausgef√ºhrt, bevor sie selbst ausgef√ºhrt werden.
    * Wenn Sie au√üerdem Abh√§ngigkeiten in einer bestimmten *Pfadoperation* deklarieren, **werden diese ebenfalls ausgef√ºhrt**.
    * Zuerst werden die Router-Abh√§ngigkeiten ausgef√ºhrt, dann die [`dependencies` im Dekorator](dependencies/dependencies-in-path-operation-decorators.md){.internal-link target=_blank} und dann die normalen Parameterabh√§ngigkeiten.
    * Sie k√∂nnen auch [`Security`-Abh√§ngigkeiten mit `scopes`](../advanced/security/oauth2-scopes.md){.internal-link target=_blank} hinzuf√ºgen.

/// tip | Tipp

`dependencies` im `APIRouter` k√∂nnen beispielsweise verwendet werden, um eine Authentifizierung f√ºr eine ganze Gruppe von *Pfadoperationen* zu erfordern. Selbst wenn die Abh√§ngigkeiten nicht jeder einzeln hinzugef√ºgt werden.

///

/// check

Die Parameter `prefix`, `tags`, `responses` und `dependencies` sind (wie in vielen anderen F√§llen) nur ein Feature von **FastAPI**, um Ihnen dabei zu helfen, Codeverdoppelung zu vermeiden.

///

### Die Abh√§ngigkeiten importieren

Der folgende Code befindet sich im Modul `app.routers.items`, also in der Datei `app/routers/items.py`.

Und wir m√ºssen die Abh√§ngigkeitsfunktion aus dem Modul `app.dependencies` importieren, also aus der Datei `app/dependencies.py`.

Daher verwenden wir einen relativen Import mit `..` f√ºr die Abh√§ngigkeiten:

```Python hl_lines="3" title="app/routers/items.py"
{!../../docs_src/bigger_applications/app/routers/items.py!}
```

#### Wie relative Importe funktionieren

/// tip | Tipp

Wenn Sie genau wissen, wie Importe funktionieren, fahren Sie mit dem n√§chsten Abschnitt unten fort.

///

Ein einzelner Punkt `.`, wie in:

```Python
from .dependencies import get_token_header
```

w√ºrde bedeuten:

* Beginnend im selben Package, in dem sich dieses Modul (die Datei `app/routers/items.py`) befindet (das Verzeichnis `app/routers/`) ...
* finde das Modul `dependencies` (eine imagin√§re Datei unter `app/routers/dependencies.py`) ...
* und importiere daraus die Funktion `get_token_header`.

Aber diese Datei existiert nicht, unsere Abh√§ngigkeiten befinden sich in einer Datei unter `app/dependencies.py`.

Erinnern Sie sich, wie unsere Anwendungs-/Dateistruktur aussieht:

<img src="/img/tutorial/bigger-applications/package.svg">

---

Die beiden Punkte `..`, wie in:

```Python
from ..dependencies import get_token_header
```

bedeuten:

* Beginnend im selben Package, in dem sich dieses Modul (die Datei `app/routers/items.py`) befindet (das Verzeichnis `app/routers/`) ...
* gehe zum √ºbergeordneten Package (das Verzeichnis `app/`) ...
* und finde dort das Modul `dependencies` (die Datei unter `app/dependencies.py`) ...
* und importiere daraus die Funktion `get_token_header`.

Das funktioniert korrekt! üéâ

---

Das Gleiche gilt, wenn wir drei Punkte `...` verwendet h√§tten, wie in:

```Python
from ...dependencies import get_token_header
```

Das w√ºrde bedeuten:

* Beginnend im selben Package, in dem sich dieses Modul (die Datei `app/routers/items.py`) befindet (das Verzeichnis `app/routers/`) ...
* gehe zum √ºbergeordneten Package (das Verzeichnis `app/`) ...
* gehe dann zum √ºbergeordneten Package dieses Packages (es gibt kein √ºbergeordnetes Package, `app` ist die oberste Ebene üò±) ...
* und finde dort das Modul `dependencies` (die Datei unter `app/dependencies.py`) ...
* und importiere daraus die Funktion `get_token_header`.

Das w√ºrde sich auf ein Paket oberhalb von `app/` beziehen, mit seiner eigenen Datei `__init__.py`, usw. Aber das haben wir nicht. Das w√ºrde in unserem Beispiel also einen Fehler ausl√∂sen. üö®

Aber jetzt wissen Sie, wie es funktioniert, sodass Sie relative Importe in Ihren eigenen Anwendungen verwenden k√∂nnen, egal wie komplex diese sind. ü§ì

### Einige benutzerdefinierte `tags`, `responses`, und `dependencies` hinzuf√ºgen

Wir f√ºgen weder das Pr√§fix `/items` noch `tags=["items"]` zu jeder *Pfadoperation* hinzu, da wir sie zum `APIRouter` hinzugef√ºgt haben.

Aber wir k√∂nnen immer noch _mehr_ `tags` hinzuf√ºgen, die auf eine bestimmte *Pfadoperation* angewendet werden, sowie einige zus√§tzliche `responses`, die speziell f√ºr diese *Pfadoperation* gelten:

```Python hl_lines="30-31" title="app/routers/items.py"
{!../../docs_src/bigger_applications/app/routers/items.py!}
```

/// tip | Tipp

Diese letzte Pfadoperation wird eine Kombination von Tags haben: `["items", "custom"]`.

Und sie wird auch beide Responses in der Dokumentation haben, eine f√ºr `404` und eine f√ºr `403`.

///

## Das Haupt-`FastAPI`.

Sehen wir uns nun das Modul unter `app/main.py` an.

Hier importieren und verwenden Sie die Klasse `FastAPI`.

Dies ist die Hauptdatei Ihrer Anwendung, die alles zusammen bindet.

Und da sich der Gro√üteil Ihrer Logik jetzt in seinem eigenen spezifischen Modul befindet, wird die Hauptdatei recht einfach sein.

### `FastAPI` importieren

Sie importieren und erstellen wie gewohnt eine `FastAPI`-Klasse.

Und wir k√∂nnen sogar [globale Abh√§ngigkeiten](dependencies/global-dependencies.md){.internal-link target=_blank} deklarieren, die mit den Abh√§ngigkeiten f√ºr jeden `APIRouter` kombiniert werden:

```Python hl_lines="1  3  7" title="app/main.py"
{!../../docs_src/bigger_applications/app/main.py!}
```

### Den `APIRouter` importieren

Jetzt importieren wir die anderen Submodule, die `APIRouter` haben:

```Python hl_lines="4-5" title="app/main.py"
{!../../docs_src/bigger_applications/app/main.py!}
```

Da es sich bei den Dateien `app/routers/users.py` und `app/routers/items.py` um Submodule handelt, die Teil desselben Python-Packages `app` sind, k√∂nnen wir einen einzelnen Punkt `.` verwenden, um sie mit ‚Äûrelativen Imports‚Äú zu importieren.

### Wie das Importieren funktioniert

Die Sektion:

```Python
from .routers import items, users
```

bedeutet:

* Beginnend im selben Package, in dem sich dieses Modul (die Datei `app/main.py`) befindet (das Verzeichnis `app/`) ...
* Suche nach dem Subpackage `routers` (das Verzeichnis unter `app/routers/`) ...
* und importiere daraus die Submodule `items` (die Datei unter `app/routers/items.py`) und `users` (die Datei unter `app/routers/users.py`) ...

Das Modul `items` verf√ºgt √ºber eine Variable `router` (`items.router`). Das ist dieselbe, die wir in der Datei `app/routers/items.py` erstellt haben, es ist ein `APIRouter`-Objekt.

Und dann machen wir das gleiche f√ºr das Modul `users`.

Wir k√∂nnten sie auch wie folgt importieren:

```Python
from app.routers import items, users
```

/// info

Die erste Version ist ein ‚Äûrelativer Import‚Äú:

```Python
from .routers import items, users
```

Die zweite Version ist ein ‚Äûabsoluter Import‚Äú:

```Python
from app.routers import items, users
```

Um mehr √ºber Python-Packages und -Module zu erfahren, lesen Sie <a href="https://docs.python.org/3/tutorial/modules.html" class="external-link" target="_blank">die offizielle Python-Dokumentation √ºber Module</a>.

///

### Namenskollisionen vermeiden

Wir importieren das Submodul `items` direkt, anstatt nur seine Variable `router` zu importieren.

Das liegt daran, dass wir im Submodul `users` auch eine weitere Variable namens `router` haben.

Wenn wir eine nach der anderen importiert h√§tten, etwa:

```Python
from .routers.items import router
from .routers.users import router
```

w√ºrde der `router` von `users` den von `items` √ºberschreiben und wir k√∂nnten sie nicht gleichzeitig verwenden.

Um also beide in derselben Datei verwenden zu k√∂nnen, importieren wir die Submodule direkt:

```Python hl_lines="5" title="app/main.py"
{!../../docs_src/bigger_applications/app/main.py!}
```


### Die `APIRouter` f√ºr `users` und `items` inkludieren

Inkludieren wir nun die `router` aus diesen Submodulen `users` und `items`:

```Python hl_lines="10-11" title="app/main.py"
{!../../docs_src/bigger_applications/app/main.py!}
```

/// info

`users.router` enth√§lt den `APIRouter` in der Datei `app/routers/users.py`.

Und `items.router` enth√§lt den `APIRouter` in der Datei `app/routers/items.py`.

///

Mit `app.include_router()` k√∂nnen wir jeden `APIRouter` zur Hauptanwendung `FastAPI` hinzuf√ºgen.

Es wird alle Routen von diesem Router als Teil von dieser inkludieren.

/// note | Technische Details

Tats√§chlich wird intern eine *Pfadoperation* f√ºr jede *Pfadoperation* erstellt, die im `APIRouter` deklariert wurde.

Hinter den Kulissen wird es also tats√§chlich so funktionieren, als ob alles dieselbe einzige Anwendung w√§re.

///

/// check

Bei der Einbindung von Routern m√ºssen Sie sich keine Gedanken √ºber die Performanz machen.

Dies dauert Mikrosekunden und geschieht nur beim Start.

Es hat also keinen Einfluss auf die Leistung. ‚ö°

///

### Einen `APIRouter` mit benutzerdefinierten `prefix`, `tags`, `responses` und `dependencies` einf√ºgen

Stellen wir uns nun vor, dass Ihre Organisation Ihnen die Datei `app/internal/admin.py` gegeben hat.

Sie enth√§lt einen `APIRouter` mit einigen administrativen *Pfadoperationen*, die Ihre Organisation zwischen mehreren Projekten teilt.

In diesem Beispiel wird es ganz einfach sein. Nehmen wir jedoch an, dass wir, da sie mit anderen Projekten in der Organisation geteilt wird, sie nicht √§ndern und kein `prefix`, `dependencies`, `tags`, usw. direkt zum `APIRouter` hinzuf√ºgen k√∂nnen:

```Python hl_lines="3" title="app/internal/admin.py"
{!../../docs_src/bigger_applications/app/internal/admin.py!}
```

Aber wir m√∂chten immer noch ein benutzerdefiniertes `prefix` festlegen, wenn wir den `APIRouter` einbinden, sodass alle seine *Pfadoperationen* mit `/admin` beginnen, wir m√∂chten es mit den `dependencies` sichern, die wir bereits f√ºr dieses Projekt haben, und wir m√∂chten `tags` und `responses` hinzuf√ºgen.

Wir k√∂nnen das alles deklarieren, ohne den urspr√ºnglichen `APIRouter` √§ndern zu m√ºssen, indem wir diese Parameter an `app.include_router()` √ºbergeben:

```Python hl_lines="14-17" title="app/main.py"
{!../../docs_src/bigger_applications/app/main.py!}
```

Auf diese Weise bleibt der urspr√ºngliche `APIRouter` unver√§ndert, sodass wir dieselbe `app/internal/admin.py`-Datei weiterhin mit anderen Projekten in der Organisation teilen k√∂nnen.

Das Ergebnis ist, dass in unserer Anwendung jede der *Pfadoperationen* aus dem Modul `admin` Folgendes haben wird:

* Das Pr√§fix `/admin`.
* Den Tag `admin`.
* Die Abh√§ngigkeit `get_token_header`.
* Die Response `418`. üçµ

Dies wirkt sich jedoch nur auf diesen `APIRouter` in unserer Anwendung aus, nicht auf anderen Code, der ihn verwendet.

So k√∂nnten beispielsweise andere Projekte denselben `APIRouter` mit einer anderen Authentifizierungsmethode verwenden.

### Eine *Pfadoperation* hinzuf√ºgen

Wir k√∂nnen *Pfadoperationen* auch direkt zur `FastAPI`-App hinzuf√ºgen.

Hier machen wir es ... nur um zu zeigen, dass wir es k√∂nnen ü§∑:

```Python hl_lines="21-23" title="app/main.py"
{!../../docs_src/bigger_applications/app/main.py!}
```

und es wird korrekt funktionieren, zusammen mit allen anderen *Pfadoperationen*, die mit `app.include_router()` hinzugef√ºgt wurden.

/// info | Sehr technische Details

**Hinweis**: Dies ist ein sehr technisches Detail, das Sie wahrscheinlich **einfach √ºberspringen** k√∂nnen.

---

Die `APIRouter` sind nicht ‚Äûgemountet‚Äú, sie sind nicht vom Rest der Anwendung isoliert.

Das liegt daran, dass wir deren *Pfadoperationen* in das OpenAPI-Schema und die Benutzeroberfl√§chen einbinden m√∂chten.

Da wir sie nicht einfach isolieren und unabh√§ngig vom Rest ‚Äûmounten‚Äú k√∂nnen, werden die *Pfadoperationen* ‚Äûgeklont‚Äú (neu erstellt) und nicht direkt einbezogen.

///

## Es in der automatischen API-Dokumentation ansehen

F√ºhren Sie nun `uvicorn` aus, indem Sie das Modul `app.main` und die Variable `app` verwenden:

<div class="termy">

```console
$ uvicorn app.main:app --reload

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

und √∂ffnen Sie die Dokumentation unter <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

Sie sehen die automatische API-Dokumentation, einschlie√ülich der Pfade aller Submodule, mit den richtigen Pfaden (und Pr√§fixen) und den richtigen Tags:

<img src="/img/tutorial/bigger-applications/image01.png">

## Den gleichen Router mehrmals mit unterschiedlichem `prefix` inkludieren

Sie k√∂nnen `.include_router()` auch mehrmals mit *demselben* Router und unterschiedlichen Pr√§fixen verwenden.

Dies k√∂nnte beispielsweise n√ºtzlich sein, um dieselbe API unter verschiedenen Pr√§fixen verf√ºgbar zu machen, z. B. `/api/v1` und `/api/latest`.

Dies ist eine fortgeschrittene Verwendung, die Sie m√∂glicherweise nicht wirklich ben√∂tigen, aber f√ºr den Fall, dass Sie sie ben√∂tigen, ist sie vorhanden.

## Einen `APIRouter` in einen anderen einf√ºgen

Auf die gleiche Weise, wie Sie einen `APIRouter` in eine `FastAPI`-Anwendung einbinden k√∂nnen, k√∂nnen Sie einen `APIRouter` in einen anderen `APIRouter` einbinden, indem Sie Folgendes verwenden:

```Python
router.include_router(other_router)
```

Stellen Sie sicher, dass Sie dies tun, bevor Sie `router` in die `FastAPI`-App einbinden, damit auch die *Pfadoperationen* von `other_router` inkludiert werden.


================================================
File: /docs/de/docs/tutorial/body-fields.md
================================================
# Body ‚Äì Felder

So wie Sie zus√§tzliche Validation und Metadaten in Parametern der **Pfadoperation-Funktion** mittels `Query`, `Path` und `Body` deklarieren, k√∂nnen Sie auch innerhalb von Pydantic-Modellen zus√§tzliche Validation und Metadaten deklarieren, mittels Pydantics `Field`.

## `Field` importieren

Importieren Sie es zuerst:

{* ../../docs_src/body_fields/tutorial001_an_py310.py hl[4] *}

/// warning | Achtung

Beachten Sie, dass `Field` direkt von `pydantic` importiert wird, nicht von `fastapi`, wie die anderen (`Query`, `Path`, `Body`, usw.)

///

## Modellattribute deklarieren

Dann k√∂nnen Sie `Field` mit Modellattributen deklarieren:

{* ../../docs_src/body_fields/tutorial001_an_py310.py hl[11:14] *}

`Field` funktioniert genauso wie `Query`, `Path` und `Body`, es hat die gleichen Parameter, usw.

/// note | Technische Details

Tats√§chlich erstellen `Query`, `Path` und andere, die sie kennenlernen werden, Instanzen von Unterklassen einer allgemeinen Klasse `Param`, die ihrerseits eine Unterklasse von Pydantics `FieldInfo`-Klasse ist.

Und Pydantics `Field` gibt ebenfalls eine Instanz von `FieldInfo` zur√ºck.

`Body` gibt auch Instanzen einer Unterklasse von `FieldInfo` zur√ºck. Und sp√§ter werden Sie andere sehen, die Unterklassen der `Body`-Klasse sind.

Denken Sie daran, dass `Query`, `Path` und andere von `fastapi` tats√§chlich Funktionen sind, die spezielle Klassen zur√ºckgeben.

///

/// tip | Tipp

Beachten Sie, dass jedes Modellattribut mit einem Typ, Defaultwert und `Field` die gleiche Struktur hat wie ein Parameter einer Pfadoperation-Funktion, nur mit `Field` statt `Path`, `Query`, `Body`.

///

## Zus√§tzliche Information hinzuf√ºgen

Sie k√∂nnen zus√§tzliche Information in `Field`, `Query`, `Body`, usw. deklarieren. Und es wird im generierten JSON-Schema untergebracht.

Sie werden sp√§ter mehr dar√ºber lernen, wie man zus√§tzliche Information unterbringt, wenn Sie lernen, Beispiele zu deklarieren.

/// warning | Achtung

Extra-Schl√ºssel, die `Field` √ºberreicht werden, werden auch im resultierenden OpenAPI-Schema Ihrer Anwendung gelistet. Da diese Schl√ºssel nicht notwendigerweise Teil der OpenAPI-Spezifikation sind, k√∂nnten einige OpenAPI-Tools, wie etwa [der OpenAPI-Validator](https://validator.swagger.io/), nicht mit Ihrem generierten Schema funktionieren.

///

## Zusammenfassung

Sie k√∂nnen Pydantics `Field` verwenden, um zus√§tzliche Validierungen und Metadaten f√ºr Modellattribute zu deklarieren.

Sie k√∂nnen auch Extra-Schl√ºssel verwenden, um zus√§tzliche JSON-Schema-Metadaten zu √ºberreichen.


================================================
File: /docs/de/docs/tutorial/body-multiple-params.md
================================================
# Body ‚Äì Mehrere Parameter

Jetzt, da wir gesehen haben, wie `Path` und `Query` verwendet werden, schauen wir uns fortgeschrittenere Verwendungsm√∂glichkeiten von Requestbody-Deklarationen an.

## `Path`-, `Query`- und Body-Parameter vermischen

Zuerst einmal, Sie k√∂nnen `Path`-, `Query`- und Requestbody-Parameter-Deklarationen frei mischen und **FastAPI** wird wissen, was zu tun ist.

Und Sie k√∂nnen auch Body-Parameter als optional kennzeichnen, indem Sie den Defaultwert auf `None` setzen:

{* ../../docs_src/body_multiple_params/tutorial001_an_py310.py hl[18:20] *}

/// note | Hinweis

Beachten Sie, dass in diesem Fall das `item`, welches vom Body genommen wird, optional ist. Da es `None` als Defaultwert hat.

///

## Mehrere Body-Parameter

Im vorherigen Beispiel erwartete die *Pfadoperation* einen JSON-Body mit den Attributen eines `Item`s, etwa:

```JSON
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2
}
```

Aber Sie k√∂nnen auch mehrere Body-Parameter deklarieren, z. B. `item` und `user`:

{* ../../docs_src/body_multiple_params/tutorial002_py310.py hl[20] *}

In diesem Fall wird **FastAPI** bemerken, dass es mehr als einen Body-Parameter in der Funktion gibt (zwei Parameter, die Pydantic-Modelle sind).

Es wird deshalb die Parameternamen als Schl√ºssel (Feldnamen) im Body verwenden, und erwartet einen Body wie folgt:

```JSON
{
    "item": {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    },
    "user": {
        "username": "dave",
        "full_name": "Dave Grohl"
    }
}
```

/// note | Hinweis

Beachten Sie, dass, obwohl `item` wie zuvor deklariert wurde, es nun unter einem Schl√ºssel `item` im Body erwartet wird.

///

**FastAPI** wird die automatische Konvertierung des Requests √ºbernehmen, sodass der Parameter `item` seinen spezifischen Inhalt bekommt, genau so wie der Parameter `user`.

Es wird die Validierung dieser zusammengesetzten Daten √ºbernehmen, und sie im OpenAPI-Schema und der automatischen Dokumentation dokumentieren.

## Einzelne Werte im Body

So wie `Query` und `Path` f√ºr Query- und Pfad-Parameter, hat **FastAPI** auch das √Ñquivalent `Body`, um Extra-Daten f√ºr Body-Parameter zu definieren.

Zum Beispiel, das vorherige Modell erweiternd, k√∂nnten Sie entscheiden, dass Sie einen weiteren Schl√ºssel <abbr title="Wichtigkeit">`importance`</abbr> haben m√∂chten, im selben Body, Seite an Seite mit `item` und `user`.

Wenn Sie diesen Parameter einfach so hinzuf√ºgen, wird **FastAPI** annehmen, dass es ein Query-Parameter ist.

Aber Sie k√∂nnen **FastAPI** instruieren, ihn als weiteren Body-Schl√ºssel zu erkennen, indem Sie `Body` verwenden:

{* ../../docs_src/body_multiple_params/tutorial003_an_py310.py hl[23] *}

In diesem Fall erwartet **FastAPI** einen Body wie:

```JSON
{
    "item": {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    },
    "user": {
        "username": "dave",
        "full_name": "Dave Grohl"
    },
    "importance": 5
}
```

Wiederum wird es die Daten konvertieren, validieren, dokumentieren, usw.

## Mehrere Body-Parameter und Query-Parameter

Nat√ºrlich k√∂nnen Sie auch, wann immer Sie das brauchen, weitere Query-Parameter hinzuf√ºgen, zus√§tzlich zu den Body-Parametern.

Da einfache Werte standardm√§√üig als Query-Parameter interpretiert werden, m√ºssen Sie `Query` nicht explizit hinzuf√ºgen, Sie k√∂nnen einfach schreiben:

```Python
q: Union[str, None] = None
```

Oder in Python 3.10 und dar√ºber:

```Python
q: str | None = None
```

Zum Beispiel:

{* ../../docs_src/body_multiple_params/tutorial004_an_py310.py hl[27] *}

/// info

`Body` hat die gleichen zus√§tzlichen Validierungs- und Metadaten-Parameter wie `Query` und `Path` und andere, die Sie sp√§ter kennenlernen.

///

## Einen einzelnen Body-Parameter einbetten

Nehmen wir an, Sie haben nur einen einzelnen `item`-Body-Parameter, ein Pydantic-Modell `Item`.

Normalerweise wird **FastAPI** dann seinen JSON-Body direkt erwarten.

Aber wenn Sie m√∂chten, dass es einen JSON-Body erwartet, mit einem Schl√ºssel `item` und darin den Inhalt des Modells, so wie es das tut, wenn Sie mehrere Body-Parameter deklarieren, dann k√∂nnen Sie den speziellen `Body`-Parameter `embed` setzen:

```Python
item: Item = Body(embed=True)
```

so wie in:

{* ../../docs_src/body_multiple_params/tutorial005_an_py310.py hl[17] *}

In diesem Fall erwartet **FastAPI** einen Body wie:

```JSON hl_lines="2"
{
    "item": {
        "name": "Foo",
        "description": "The pretender",
        "price": 42.0,
        "tax": 3.2
    }
}
```

statt:

```JSON
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2
}
```

## Zusammenfassung

Sie k√∂nnen mehrere Body-Parameter zu ihrer *Pfadoperation-Funktion* hinzuf√ºgen, obwohl ein Request nur einen einzigen Body enthalten kann.

**FastAPI** wird sich darum k√ºmmern, Ihnen korrekte Daten in Ihrer Funktion zu √ºberreichen, und das korrekte Schema in der *Pfadoperation* zu validieren und zu dokumentieren.

Sie k√∂nnen auch einzelne Werte deklarieren, die als Teil des Bodys empfangen werden.

Und Sie k√∂nnen **FastAPI** instruieren, den Body in einem Schl√ºssel unterzubringen, selbst wenn nur ein einzelner Body-Parameter deklariert ist.


================================================
File: /docs/de/docs/tutorial/body-nested-models.md
================================================
# Body ‚Äì Verschachtelte Modelle

Mit **FastAPI** k√∂nnen Sie (dank Pydantic) beliebig tief verschachtelte Modelle definieren, validieren und dokumentieren.

## Listen als Felder

Sie k√∂nnen ein Attribut als Kindtyp definieren, zum Beispiel eine Python-`list`e.

{* ../../docs_src/body_nested_models/tutorial001_py310.py hl[12] *}

Das bewirkt, dass `tags` eine Liste ist, wenngleich es nichts √ºber den Typ der Elemente der Liste aussagt.

## Listen mit Typ-Parametern als Felder

Aber Python erlaubt es, Listen mit inneren Typen, auch ‚ÄûTyp-Parameter‚Äú genannt, zu deklarieren.

### `List` von `typing` importieren

In Python 3.9 oder dar√ºber k√∂nnen Sie einfach `list` verwenden, um diese Typannotationen zu deklarieren, wie wir unten sehen werden. üí°

In Python-Versionen vor 3.9 (3.6 und dar√ºber), m√ºssen Sie zuerst `List` von Pythons Standardmodul `typing` importieren.

{* ../../docs_src/body_nested_models/tutorial002.py hl[1] *}

### Eine `list`e mit einem Typ-Parameter deklarieren

Um Typen wie `list`, `dict`, `tuple` mit inneren Typ-Parametern (inneren Typen) zu deklarieren:

* Wenn Sie eine Python-Version kleiner als 3.9 verwenden, importieren Sie das √Ñquivalent zum entsprechenden Typ vom `typing`-Modul
* √úberreichen Sie den/die inneren Typ(en) von eckigen Klammern umschlossen, `[` und `]`, als ‚ÄûTyp-Parameter‚Äú

In Python 3.9 w√§re das:

```Python
my_list: list[str]
```

Und in Python-Versionen vor 3.9:

```Python
from typing import List

my_list: List[str]
```

Das ist alles Standard-Python-Syntax f√ºr Typdeklarationen.

Verwenden Sie dieselbe Standardsyntax f√ºr Modellattribute mit inneren Typen.

In unserem Beispiel k√∂nnen wir also bewirken, dass `tags` spezifisch eine ‚ÄûListe von Strings‚Äú ist:

{* ../../docs_src/body_nested_models/tutorial002_py310.py hl[12] *}

## Set-Typen

Aber dann denken wir dar√ºber nach und stellen fest, dass sich die Tags nicht wiederholen sollen, es sollen eindeutige Strings sein.

Python hat einen Datentyp speziell f√ºr Mengen eindeutiger Dinge: das <abbr title="Menge">`set`</abbr>.

Deklarieren wir also `tags` als Set von Strings.

{* ../../docs_src/body_nested_models/tutorial003_py310.py hl[12] *}

Jetzt, selbst wenn Sie einen Request mit duplizierten Daten erhalten, werden diese zu einem Set eindeutiger Dinge konvertiert.

Und wann immer Sie diese Daten ausgeben, selbst wenn die Quelle Duplikate hatte, wird es als Set von eindeutigen Dingen ausgegeben.

Und es wird entsprechend annotiert/dokumentiert.

## Verschachtelte Modelle

Jedes Attribut eines Pydantic-Modells hat einen Typ.

Aber dieser Typ kann selbst ein anderes Pydantic-Modell sein.

Sie k√∂nnen also tief verschachtelte JSON-‚ÄûObjekte‚Äú deklarieren, mit spezifischen Attributnamen, -typen, und -validierungen.

Alles das beliebig tief verschachtelt.

### Ein Kindmodell definieren

Wir k√∂nnen zum Beispiel ein `Image`-Modell definieren.

{* ../../docs_src/body_nested_models/tutorial004_py310.py hl[7:9] *}

### Das Kindmodell als Typ verwenden

Und dann k√∂nnen wir es als Typ eines Attributes verwenden.

{* ../../docs_src/body_nested_models/tutorial004_py310.py hl[18] *}

Das w√ºrde bedeuten, dass **FastAPI** einen Body erwartet wie:

```JSON
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2,
    "tags": ["rock", "metal", "bar"],
    "image": {
        "url": "http://example.com/baz.jpg",
        "name": "The Foo live"
    }
}
```

Wiederum, nur mit dieser Deklaration erhalten Sie von **FastAPI**:

* Editor-Unterst√ºtzung (Codevervollst√§ndigung, usw.), selbst f√ºr verschachtelte Modelle
* Datenkonvertierung
* Datenvalidierung
* Automatische Dokumentation

## Spezielle Typen und Validierungen

Abgesehen von normalen einfachen Typen, wie `str`, `int`, `float`, usw. k√∂nnen Sie komplexere einfache Typen verwenden, die von `str` erben.

Um alle Optionen kennenzulernen, die Sie haben, schauen Sie sich <a href="https://docs.pydantic.dev/latest/concepts/types/" class="external-link" target="_blank">Pydantics Typ√ºbersicht</a> an. Sie werden im n√§chsten Kapitel ein paar Beispiele kennenlernen.

Da wir zum Beispiel im `Image`-Modell ein Feld `url` haben, k√∂nnen wir deklarieren, dass das eine Instanz von Pydantics `HttpUrl` sein soll, anstelle eines `str`:

{* ../../docs_src/body_nested_models/tutorial005_py310.py hl[2,8] *}

Es wird getestet, ob der String eine g√ºltige URL ist, und als solche wird er in JSON Schema / OpenAPI dokumentiert.

## Attribute mit Listen von Kindmodellen

Sie k√∂nnen Pydantic-Modelle auch als Typen innerhalb von `list`, `set`, usw. verwenden:

{* ../../docs_src/body_nested_models/tutorial006_py310.py hl[18] *}

Das wird einen JSON-Body erwarten (konvertieren, validieren, dokumentieren), wie:

```JSON hl_lines="11"
{
    "name": "Foo",
    "description": "The pretender",
    "price": 42.0,
    "tax": 3.2,
    "tags": [
        "rock",
        "metal",
        "bar"
    ],
    "images": [
        {
            "url": "http://example.com/baz.jpg",
            "name": "The Foo live"
        },
        {
            "url": "http://example.com/dave.jpg",
            "name": "The Baz"
        }
    ]
}
```

/// info

Beachten Sie, dass der `images`-Schl√ºssel jetzt eine Liste von Bild-Objekten hat.

///

## Tief verschachtelte Modelle

Sie k√∂nnen beliebig tief verschachtelte Modelle definieren:

{* ../../docs_src/body_nested_models/tutorial007_py310.py hl[7,12,18,21,25] *}

/// info

Beachten Sie, wie `Offer` eine Liste von `Item`s hat, von denen jedes seinerseits eine optionale Liste von `Image`s hat.

///

## Bodys aus reinen Listen

Wenn Sie m√∂chten, dass das √§u√üerste Element des JSON-Bodys ein JSON-`array` (eine Python-`list`e) ist, k√∂nnen Sie den Typ im Funktionsparameter deklarieren, mit der gleichen Syntax wie in Pydantic-Modellen:

```Python
images: List[Image]
```

oder in Python 3.9 und dar√ºber:

```Python
images: list[Image]
```

so wie in:

{* ../../docs_src/body_nested_models/tutorial008_py39.py hl[13] *}

## Editor-Unterst√ºtzung √ºberall

Und Sie erhalten Editor-Unterst√ºtzung √ºberall.

Selbst f√ºr Dinge in Listen:

<img src="/img/tutorial/body-nested-models/image01.png">

Sie w√ºrden diese Editor-Unterst√ºtzung nicht erhalten, wenn Sie direkt mit `dict`, statt mit Pydantic-Modellen arbeiten w√ºrden.

Aber Sie m√ºssen sich auch nicht weiter um die Modelle k√ºmmern, hereinkommende Dicts werden automatisch in sie konvertiert. Und was Sie zur√ºckgeben, wird automatisch nach JSON konvertiert.

## Bodys mit beliebigen `dict`s

Sie k√∂nnen einen Body auch als `dict` deklarieren, mit Schl√ºsseln eines Typs und Werten eines anderen Typs.

So brauchen Sie vorher nicht zu wissen, wie die Feld-/Attribut-Namen lauten (wie es bei Pydantic-Modellen der Fall w√§re).

Das ist n√ºtzlich, wenn Sie Schl√ºssel empfangen, deren Namen Sie nicht bereits kennen.

---

Ein anderer n√ºtzlicher Anwendungsfall ist, wenn Sie Schl√ºssel eines anderen Typs haben wollen, z. B. `int`.

Das schauen wir uns mal an.

Im folgenden Beispiel akzeptieren Sie irgendein `dict`, solange es `int`-Schl√ºssel und `float`-Werte hat.

{* ../../docs_src/body_nested_models/tutorial009_py39.py hl[7] *}

/// tip | Tipp

Bedenken Sie, dass JSON nur `str` als Schl√ºssel unterst√ºtzt.

Aber Pydantic hat automatische Datenkonvertierung.

Das bedeutet, dass Ihre API-Clients nur Strings senden k√∂nnen, aber solange diese Strings nur Zahlen enthalten, wird Pydantic sie konvertieren und validieren.

Und das `dict` welches Sie als `weights` erhalten, wird `int`-Schl√ºssel und `float`-Werte haben.

///

## Zusammenfassung

Mit **FastAPI** haben Sie die maximale Flexibilit√§t von Pydantic-Modellen, w√§hrend Ihr Code einfach, kurz und elegant bleibt.

Aber mit all den Vorz√ºgen:

* Editor-Unterst√ºtzung (Codevervollst√§ndigung √ºberall)
* Datenkonvertierung (auch bekannt als Parsen, Serialisierung)
* Datenvalidierung
* Schema-Dokumentation
* Automatische Dokumentation


================================================
File: /docs/de/docs/tutorial/body-updates.md
================================================
# Body ‚Äì Aktualisierungen

## Ersetzendes Aktualisieren mit `PUT`

Um einen Artikel zu aktualisieren, k√∂nnen Sie die <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PUT" class="external-link" target="_blank">HTTP `PUT`</a> Operation verwenden.

Sie k√∂nnen den `jsonable_encoder` verwenden, um die empfangenen Daten in etwas zu konvertieren, das als JSON gespeichert werden kann (in z. B. einer NoSQL-Datenbank). Zum Beispiel, um ein `datetime` in einen `str` zu konvertieren.

{* ../../docs_src/body_updates/tutorial001_py310.py hl[28:33] *}

`PUT` wird verwendet, um Daten zu empfangen, die die existierenden Daten ersetzen sollen.

### Warnung bez√ºglich des Ersetzens

Das bedeutet, dass, wenn Sie den Artikel `bar` aktualisieren wollen, mittels `PUT` und folgendem Body:

```Python
{
    "name": "Barz",
    "price": 3,
    "description": None,
}
```

das Eingabemodell nun den Defaultwert `"tax": 10.5` hat, weil Sie das bereits gespeicherte Attribut `"tax": 20.2` nicht mit √ºbergeben haben.

Die Daten werden darum mit einem ‚Äûneuen‚Äú `tax`-Wert von `10.5` abgespeichert.

## Teilweises Ersetzen mit `PATCH`

Sie k√∂nnen auch die <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/PATCH" class="external-link" target="_blank">HTTP `PATCH`</a> Operation verwenden, um Daten *teilweise* zu ersetzen.

Das bedeutet, sie senden nur die Daten, die Sie aktualisieren wollen, der Rest bleibt unver√§ndert.

/// note | Hinweis

`PATCH` wird seltener verwendet und ist weniger bekannt als `PUT`.

Und viele Teams verwenden ausschlie√ülich `PUT`, selbst f√ºr nur Teil-Aktualisierungen.

Es steht Ihnen **frei**, das zu verwenden, was Sie m√∂chten, **FastAPI** legt Ihnen keine Einschr√§nkungen auf.

Aber dieser Leitfaden zeigt Ihnen mehr oder weniger, wie die beiden normalerweise verwendet werden.

///

### Pydantics `exclude_unset`-Parameter verwenden

Wenn Sie Teil-Aktualisierungen entgegennehmen, ist der `exclude_unset`-Parameter in der `.model_dump()`-Methode von Pydantic-Modellen sehr n√ºtzlich.

Wie in `item.model_dump(exclude_unset=True)`.

/// info

In Pydantic v1 hie√ü diese Methode `.dict()`, in Pydantic v2 wurde sie deprecated (aber immer noch unterst√ºtzt) und in `.model_dump()` umbenannt.

Die Beispiele hier verwenden `.dict()` f√ºr die Kompatibilit√§t mit Pydantic v1, Sie sollten jedoch stattdessen `.model_dump()` verwenden, wenn Sie Pydantic v2 verwenden k√∂nnen.

///

Das wird ein `dict` erstellen, mit nur den Daten, die gesetzt wurden als das `item`-Modell erstellt wurde, Defaultwerte ausgeschlossen.

Sie k√∂nnen das verwenden, um ein `dict` zu erstellen, das nur die (im Request) gesendeten Daten enth√§lt, ohne Defaultwerte:

{* ../../docs_src/body_updates/tutorial002_py310.py hl[32] *}

### Pydantics `update`-Parameter verwenden

Jetzt k√∂nnen Sie eine Kopie des existierenden Modells mittels `.model_copy()` erstellen, wobei Sie dem `update`-Parameter ein `dict` mit den zu √§ndernden Daten √ºbergeben.

/// info

In Pydantic v1 hie√ü diese Methode `.copy()`, in Pydantic v2 wurde sie deprecated (aber immer noch unterst√ºtzt) und in `.model_copy()` umbenannt.

Die Beispiele hier verwenden `.copy()` f√ºr die Kompatibilit√§t mit Pydantic v1, Sie sollten jedoch stattdessen `.model_copy()` verwenden, wenn Sie Pydantic v2 verwenden k√∂nnen.

///

Wie in `stored_item_model.model_copy(update=update_data)`:

{* ../../docs_src/body_updates/tutorial002_py310.py hl[33] *}

### Rekapitulation zum teilweisen Ersetzen

Zusammengefasst, um Teil-Ersetzungen vorzunehmen:

* (Optional) verwenden Sie `PATCH` statt `PUT`.
* Lesen Sie die bereits gespeicherten Daten aus.
* F√ºgen Sie diese in ein Pydantic-Modell ein.
* Erzeugen Sie aus dem empfangenen Modell ein `dict` ohne Defaultwerte (mittels `exclude_unset`).
    * So ersetzen Sie nur die tats√§chlich vom Benutzer gesetzten Werte, statt dass bereits gespeicherte Werte mit Defaultwerten des Modells √ºberschrieben werden.
* Erzeugen Sie eine Kopie ihres gespeicherten Modells, wobei Sie die Attribute mit den empfangenen Teil-Ersetzungen aktualisieren (mittels des `update`-Parameters).
* Konvertieren Sie das kopierte Modell zu etwas, das in ihrer Datenbank gespeichert werden kann (indem Sie beispielsweise `jsonable_encoder` verwenden).
    * Das ist vergleichbar dazu, die `.model_dump()`-Methode des Modells erneut aufzurufen, aber es wird sicherstellen, dass die Werte zu Daten konvertiert werden, die ihrerseits zu JSON konvertiert werden k√∂nnen, zum Beispiel `datetime` zu `str`.
* Speichern Sie die Daten in Ihrer Datenbank.
* Geben Sie das aktualisierte Modell zur√ºck.

{* ../../docs_src/body_updates/tutorial002_py310.py hl[28:35] *}

/// tip | Tipp

Sie k√∂nnen tats√§chlich die gleiche Technik mit einer HTTP `PUT` Operation verwenden.

Aber dieses Beispiel verwendet `PATCH`, da dieses f√ºr solche Anwendungsf√§lle geschaffen wurde.

///

/// note | Hinweis

Beachten Sie, dass das hereinkommende Modell immer noch validiert wird.

Wenn Sie also Teil-Aktualisierungen empfangen wollen, die alle Attribute auslassen k√∂nnen, m√ºssen Sie ein Modell haben, dessen Attribute alle als optional gekennzeichnet sind (mit Defaultwerten oder `None`).

Um zu unterscheiden zwischen Modellen f√ºr **Aktualisierungen**, mit lauter optionalen Werten, und solchen f√ºr die **Erzeugung**, mit ben√∂tigten Werten, k√∂nnen Sie die Techniken verwenden, die in [Extramodelle](extra-models.md){.internal-link target=_blank} beschrieben wurden.

///


================================================
File: /docs/de/docs/tutorial/body.md
================================================
# Requestbody

Wenn Sie Daten von einem <abbr title="Client: Eine Software, die sich mit einem Server verbindet.">Client</abbr> (sagen wir, einem Browser) zu Ihrer API senden, dann senden Sie diese als einen **Requestbody** (Deutsch: Anfragek√∂rper).

Ein **Request**body sind Daten, die vom Client zu Ihrer API gesendet werden. Ein **Response**body (Deutsch: Antwortk√∂rper) sind Daten, die Ihre API zum Client sendet.

Ihre API sendet fast immer einen **Response**body. Aber Clients senden nicht unbedingt immer **Request**bodys (sondern nur Metadaten).

Um einen **Request**body zu deklarieren, verwenden Sie <a href="https://docs.pydantic.dev/" class="external-link" target="_blank">Pydantic</a>-Modelle mit allen deren F√§higkeiten und Vorz√ºgen.

/// info

Um Daten zu versenden, sollten Sie eines von: `POST` (meistverwendet), `PUT`, `DELETE` oder `PATCH` verwenden.

Senden Sie einen Body mit einem `GET`-Request, dann f√ºhrt das laut Spezifikation zu undefiniertem Verhalten. Trotzdem wird es von FastAPI unterst√ºtzt, f√ºr sehr komplexe/extreme Anwendungsf√§lle.

Da aber davon abgeraten wird, zeigt die interaktive Dokumentation mit Swagger-Benutzeroberfl√§che die Dokumentation f√ºr den Body auch nicht an, wenn `GET` verwendet wird. Dazwischengeschaltete Proxys unterst√ºtzen es m√∂glicherweise auch nicht.

///

## Importieren Sie Pydantics `BaseModel`

Zuerst m√ºssen Sie `BaseModel` von `pydantic` importieren:

{* ../../docs_src/body/tutorial001_py310.py hl[2] *}

## Erstellen Sie Ihr Datenmodell

Dann deklarieren Sie Ihr Datenmodell als eine Klasse, die von `BaseModel` erbt.

Verwenden Sie Standard-Python-Typen f√ºr die Klassenattribute:

{* ../../docs_src/body/tutorial001_py310.py hl[5:9] *}

Wie auch bei Query-Parametern gilt, wenn ein Modellattribut einen Defaultwert hat, ist das Attribut nicht erforderlich. Ansonsten ist es erforderlich. Verwenden Sie `None`, um es als optional zu kennzeichnen.

Zum Beispiel deklariert das obige Modell ein JSON "`object`" (oder Python-`dict`) wie dieses:

```JSON
{
    "name": "Foo",
    "description": "An optional description",
    "price": 45.2,
    "tax": 3.5
}
```

Da `description` und `tax` optional sind (mit `None` als Defaultwert), w√§re folgendes JSON "`object`" auch g√ºltig:

```JSON
{
    "name": "Foo",
    "price": 45.2
}
```

## Deklarieren Sie es als Parameter

Um es zu Ihrer *Pfadoperation* hinzuzuf√ºgen, deklarieren Sie es auf die gleiche Weise, wie Sie Pfad- und Query-Parameter deklariert haben:

{* ../../docs_src/body/tutorial001_py310.py hl[16] *}

... und deklarieren Sie seinen Typ als das Modell, welches Sie erstellt haben, `Item`.

## Resultate

Mit nur dieser Python-Typdeklaration, wird **FastAPI**:

* Den Requestbody als JSON lesen.
* Die entsprechenden Typen konvertieren (falls n√∂tig).
* Diese Daten validieren.
    * Wenn die Daten ung√ºltig sind, einen klar lesbaren Fehler zur√ºckgeben, der anzeigt, wo und was die inkorrekten Daten waren.
* Ihnen die erhaltenen Daten im Parameter `item` √ºbergeben.
    * Da Sie diesen in der Funktion als vom Typ `Item` deklariert haben, erhalten Sie die ganze Editor-Unterst√ºtzung (Autovervollst√§ndigung, usw.) f√ºr alle Attribute und deren Typen.
* Eine <a href="https://json-schema.org" class="external-link" target="_blank">JSON Schema</a> Definition f√ºr Ihr Modell generieren, welche Sie √ºberall sonst verwenden k√∂nnen, wenn es f√ºr Ihr Projekt Sinn macht.
* Diese Schemas werden Teil des generierten OpenAPI-Schemas und werden von den <abbr title="User Interface ‚Äì Benutzeroberfl√§che">UIs</abbr> der automatischen Dokumentation verwendet.

## Automatische Dokumentation

Die JSON-Schemas Ihrer Modelle werden Teil ihrer OpenAPI-generierten Schemas und werden in der interaktiven API Dokumentation angezeigt:

<img src="/img/tutorial/body/image01.png">

Und werden auch verwendet in der API-Dokumentation innerhalb jeder *Pfadoperation*, welche sie braucht:

<img src="/img/tutorial/body/image02.png">

## Editor Unterst√ºtzung

In Ihrem Editor, innerhalb Ihrer Funktion, erhalten Sie Typhinweise und Code-Vervollst√§ndigung √ºberall (was nicht der Fall w√§re, wenn Sie ein `dict` anstelle eines Pydantic Modells erhalten h√§tten):

<img src="/img/tutorial/body/image03.png">

Sie bekommen auch Fehler-Meldungen f√ºr inkorrekte Typoperationen:

<img src="/img/tutorial/body/image04.png">

Das ist nicht zuf√§llig so, das ganze Framework wurde um dieses Design herum aufgebaut.

Und es wurde in der Designphase gr√ºndlich getestet, vor der Implementierung, um sicherzustellen, dass es mit jedem Editor funktioniert.

Es gab sogar ein paar √Ñnderungen an Pydantic selbst, um das zu unterst√ºtzen.

Die vorherigen Screenshots zeigten <a href="https://code.visualstudio.com" class="external-link" target="_blank">Visual Studio Code</a>.

Aber Sie bekommen die gleiche Editor-Unterst√ºtzung in <a href="https://www.jetbrains.com/pycharm/" class="external-link" target="_blank">PyCharm</a> und in den meisten anderen Python-Editoren:

<img src="/img/tutorial/body/image05.png">

/// tip | Tipp

Wenn Sie <a href="https://www.jetbrains.com/pycharm/" class="external-link" target="_blank">PyCharm</a> als Ihren Editor verwenden, probieren Sie das <a href="https://github.com/koxudaxi/pydantic-pycharm-plugin/" class="external-link" target="_blank">Pydantic PyCharm Plugin</a> aus.

Es verbessert die Editor-Unterst√ºtzung f√ºr Pydantic-Modelle, mit:

* Code-Vervollst√§ndigung
* Typ√ºberpr√ºfungen
* Refaktorisierung
* Suchen
* Inspektionen

///

## Das Modell verwenden

Innerhalb der Funktion k√∂nnen Sie alle Attribute des Modells direkt verwenden:

{* ../../docs_src/body/tutorial002_py310.py hl[19] *}

## Requestbody- + Pfad-Parameter

Sie k√∂nnen Pfad- und Requestbody-Parameter gleichzeitig deklarieren.

**FastAPI** erkennt, dass Funktionsparameter, die mit Pfad-Parametern √ºbereinstimmen, **vom Pfad genommen** werden sollen, und dass Funktionsparameter, welche Pydantic-Modelle sind, **vom Requestbody genommen** werden sollen.

{* ../../docs_src/body/tutorial003_py310.py hl[15:16] *}

## Requestbody- + Pfad- + Query-Parameter

Sie k√∂nnen auch zur gleichen Zeit **Body-**, **Pfad-** und **Query-Parameter** deklarieren.

**FastAPI** wird jeden Parameter korrekt erkennen und die Daten vom richtigen Ort holen.

{* ../../docs_src/body/tutorial004_py310.py hl[16] *}

Die Funktionsparameter werden wie folgt erkannt:

* Wenn der Parameter auch im **Pfad** deklariert wurde, wird er als Pfad-Parameter interpretiert.
* Wenn der Parameter ein **einfacher Typ** ist (wie `int`, `float`, `str`, `bool`, usw.), wird er als **Query**-Parameter interpretiert.
* Wenn der Parameter vom Typ eines **Pydantic-Modells** ist, wird er als Request**body** interpretiert.

/// note | Hinweis

FastAPI wei√ü, dass der Wert von `q` nicht erforderlich ist, wegen des definierten Defaultwertes `= None`

Das `Union` in `Union[str, None]` wird von FastAPI nicht verwendet, aber es erlaubt Ihrem Editor, Sie besser zu unterst√ºtzen und Fehler zu erkennen.

///

## Ohne Pydantic

Wenn Sie keine Pydantic-Modelle verwenden wollen, k√∂nnen Sie auch **Body**-Parameter nehmen. Siehe die Dokumentation unter [Body ‚Äì Mehrere Parameter: Einfache Werte im Body](body-multiple-params.md#einzelne-werte-im-body){.internal-link target=\_blank}.


================================================
File: /docs/de/docs/tutorial/cookie-params.md
================================================
# Cookie-Parameter

So wie `Query`- und `Path`-Parameter k√∂nnen Sie auch <abbr title='Cookie ‚Äì ‚ÄûKeks‚Äú: Mechanismus, der kurze Daten in Textform im Browser des Benutzers speichert und abfragt'>Cookie</abbr>-Parameter definieren.

## `Cookie` importieren

Importieren Sie zuerst `Cookie`:

{* ../../docs_src/cookie_params/tutorial001_an_py310.py hl[3] *}

## `Cookie`-Parameter deklarieren

Dann deklarieren Sie Ihre Cookie-Parameter, auf die gleiche Weise, wie Sie auch `Path`- und `Query`-Parameter deklarieren.

Der erste Wert ist der Typ. Sie k√∂nnen `Cookie` die gehabten Extra Validierungs- und Beschreibungsparameter hinzuf√ºgen. Danach k√∂nnen Sie einen Defaultwert vergeben:

{* ../../docs_src/cookie_params/tutorial001_an_py310.py hl[9] *}

/// note | Technische Details

`Cookie` ist eine Schwesterklasse von `Path` und `Query`. Sie erbt von derselben gemeinsamen `Param`-Elternklasse.

Aber erinnern Sie sich, dass, wenn Sie `Query`, `Path`, `Cookie` und andere von `fastapi` importieren, diese tats√§chlich Funktionen sind, welche spezielle Klassen zur√ºckgeben.

///

/// info

Um Cookies zu deklarieren, m√ºssen Sie `Cookie` verwenden, da diese Parameter sonst als Query-Parameter interpretiert werden w√ºrden.

///

## Zusammenfassung

Deklarieren Sie Cookies mittels `Cookie`, auf die gleiche Weise wie bei `Query` und `Path`.


================================================
File: /docs/de/docs/tutorial/encoder.md
================================================
# JSON-kompatibler Encoder

Es gibt F√§lle, da m√∂chten Sie einen Datentyp (etwa ein Pydantic-Modell) in etwas konvertieren, das kompatibel mit JSON ist (etwa ein `dict`, eine `list`e, usw.).

Zum Beispiel, wenn Sie es in einer Datenbank speichern m√∂chten.

Daf√ºr bietet **FastAPI** eine Funktion `jsonable_encoder()`.

## `jsonable_encoder` verwenden

Stellen wir uns vor, Sie haben eine Datenbank `fake_db`, die nur JSON-kompatible Daten entgegennimmt.

Sie akzeptiert zum Beispiel keine `datetime`-Objekte, da die nicht kompatibel mit JSON sind.

Ein `datetime`-Objekt m√ºsste also in einen `str` umgewandelt werden, der die Daten im <a href="https://en.wikipedia.org/wiki/ISO_8601" class="external-link" target="_blank">ISO-Format</a> enth√§lt.

Genauso w√ºrde die Datenbank kein Pydantic-Modell (ein Objekt mit Attributen) akzeptieren, sondern nur ein `dict`.

Sie k√∂nnen f√ºr diese F√§lle `jsonable_encoder` verwenden.

Es nimmt ein Objekt entgegen, wie etwa ein Pydantic-Modell, und gibt eine JSON-kompatible Version zur√ºck:

{* ../../docs_src/encoder/tutorial001_py310.py hl[4,21] *}

In diesem Beispiel wird das Pydantic-Modell in ein `dict`, und das `datetime`-Objekt in ein `str` konvertiert.

Das Resultat dieses Aufrufs ist etwas, das mit Pythons Standard-<a href="https://docs.python.org/3/library/json.html#json.dumps" class="external-link" target="_blank">`json.dumps()`</a> kodiert werden kann.

Es wird also kein gro√üer `str` zur√ºckgegeben, der die Daten im JSON-Format (als String) enth√§lt. Es wird eine Python-Standarddatenstruktur (z. B. ein `dict`) zur√ºckgegeben, mit Werten und Unterwerten, die alle mit JSON kompatibel sind.

/// note | Hinweis

`jsonable_encoder` wird tats√§chlich von **FastAPI** intern verwendet, um Daten zu konvertieren. Aber es ist in vielen anderen Szenarien hilfreich.

///


================================================
File: /docs/de/docs/tutorial/extra-data-types.md
================================================
# Zus√§tzliche Datentypen

Bisher haben Sie g√§ngige Datentypen verwendet, wie zum Beispiel:

* `int`
* `float`
* `str`
* `bool`

Sie k√∂nnen aber auch komplexere Datentypen verwenden.

Und Sie haben immer noch dieselbe Funktionalit√§t wie bisher gesehen:

* Gro√üartige Editor-Unterst√ºtzung.
* Datenkonvertierung bei eingehenden Requests.
* Datenkonvertierung f√ºr Response-Daten.
* Datenvalidierung.
* Automatische Annotation und Dokumentation.

## Andere Datentypen

Hier sind einige der zus√§tzlichen Datentypen, die Sie verwenden k√∂nnen:

* `UUID`:
    * Ein standardm√§√üiger ‚Äûuniversell eindeutiger Bezeichner‚Äú (‚ÄûUniversally Unique Identifier‚Äú), der in vielen Datenbanken und Systemen als ID √ºblich ist.
    * Wird in Requests und Responses als `str` dargestellt.
* `datetime.datetime`:
    * Ein Python-`datetime.datetime`.
    * Wird in Requests und Responses als `str` im ISO 8601-Format dargestellt, etwa: `2008-09-15T15:53:00+05:00`.
* `datetime.date`:
    * Python-`datetime.date`.
    * Wird in Requests und Responses als `str` im ISO 8601-Format dargestellt, etwa: `2008-09-15`.
* `datetime.time`:
    * Ein Python-`datetime.time`.
    * Wird in Requests und Responses als `str` im ISO 8601-Format dargestellt, etwa: `14:23:55.003`.
* `datetime.timedelta`:
    * Ein Python-`datetime.timedelta`.
    * Wird in Requests und Responses als `float` der Gesamtsekunden dargestellt.
    * Pydantic erm√∂glicht auch die Darstellung als ‚ÄûISO 8601 Zeitdifferenz-Kodierung‚Äú, <a href="https://docs.pydantic.dev/1.10/usage/exporting_models/#json_encoders" class="external-link" target="_blank">Weitere Informationen finden Sie in der Dokumentation</a>.
* `frozenset`:
    * Wird in Requests und Responses wie ein `set` behandelt:
        * Bei Requests wird eine Liste gelesen, Duplikate entfernt und in ein `set` umgewandelt.
        * Bei Responses wird das `set` in eine `list`e umgewandelt.
        * Das generierte Schema zeigt an, dass die `set`-Werte eindeutig sind (unter Verwendung von JSON Schemas `uniqueItems`).
* `bytes`:
    * Standard-Python-`bytes`.
    * In Requests und Responses werden sie als `str` behandelt.
    * Das generierte Schema wird anzeigen, dass es sich um einen `str` mit `binary` ‚ÄûFormat‚Äú handelt.
* `Decimal`:
    * Standard-Python-`Decimal`.
    * In Requests und Responses wird es wie ein `float` behandelt.
* Sie k√∂nnen alle g√ºltigen Pydantic-Datentypen hier √ºberpr√ºfen: <a href="https://docs.pydantic.dev/latest/usage/types/types/" class="external-link" target="_blank">Pydantic data types</a>.

## Beispiel

Hier ist ein Beispiel f√ºr eine *Pfadoperation* mit Parametern, die einige der oben genannten Typen verwenden.

{* ../../docs_src/extra_data_types/tutorial001_an_py310.py hl[1,3,12:16] *}

Beachten Sie, dass die Parameter innerhalb der Funktion ihren nat√ºrlichen Datentyp haben und Sie beispielsweise normale Datumsmanipulationen durchf√ºhren k√∂nnen, wie zum Beispiel:

{* ../../docs_src/extra_data_types/tutorial001_an_py310.py hl[18:19] *}


================================================
File: /docs/de/docs/tutorial/extra-models.md
================================================
# Extramodelle

Fahren wir beim letzten Beispiel fort. Es gibt normalerweise mehrere zusammengeh√∂rende Modelle.

Insbesondere Benutzermodelle, denn:

* Das **hereinkommende Modell** sollte ein Passwort haben k√∂nnen.
* Das **herausgehende Modell** sollte kein Passwort haben.
* Das **Datenbankmodell** sollte wahrscheinlich ein <abbr title='Ein aus scheinbar zuf√§lligen Zeichen bestehender ‚ÄûFingerabdruck‚Äú eines Textes. Der Inhalt des Textes kann nicht eingesehen werden.'>gehashtes</abbr> Passwort haben.

/// danger | Gefahr

Speichern Sie niemals das Klartext-Passwort eines Benutzers. Speichern Sie immer den ‚Äûsicheren Hash‚Äú, den Sie verifizieren k√∂nnen.

Falls Ihnen das nichts sagt, in den [Sicherheits-Kapiteln](security/simple-oauth2.md#passwort-hashing){.internal-link target=_blank} werden Sie lernen, was ein ‚ÄûPasswort-Hash‚Äú ist.

///

## Mehrere Modelle

Hier der generelle Weg, wie die Modelle mit ihren Passwort-Feldern aussehen k√∂nnten, und an welchen Orten sie verwendet werden w√ºrden.

{* ../../docs_src/extra_models/tutorial001_py310.py hl[7,9,14,20,22,27:28,31:33,38:39] *}

/// info

In Pydantic v1 hie√ü diese Methode `.dict()`, in Pydantic v2 wurde sie deprecated (aber immer noch unterst√ºtzt) und in `.model_dump()` umbenannt.

Die Beispiele hier verwenden `.dict()` f√ºr die Kompatibilit√§t mit Pydantic v1, Sie sollten jedoch stattdessen `.model_dump()` verwenden, wenn Sie Pydantic v2 verwenden k√∂nnen.

///

### √úber `**user_in.dict()`

#### Pydantic's `.dict()`

`user_in` ist ein Pydantic-Modell der Klasse `UserIn`.

Pydantic-Modelle haben eine `.dict()`-Methode, die ein `dict` mit den Daten des Modells zur√ºckgibt.

Wenn wir also ein Pydantic-Objekt `user_in` erstellen, etwa so:

```Python
user_in = UserIn(username="john", password="secret", email="john.doe@example.com")
```

und wir rufen seine `.dict()`-Methode auf:

```Python
user_dict = user_in.dict()
```

dann haben wir jetzt in der Variable `user_dict` ein `dict` mit den gleichen Daten (es ist ein `dict` statt eines Pydantic-Modellobjekts).

Wenn wir es ausgeben:

```Python
print(user_dict)
```

bekommen wir ein Python-`dict`:

```Python
{
    'username': 'john',
    'password': 'secret',
    'email': 'john.doe@example.com',
    'full_name': None,
}
```

#### Ein `dict` entpacken

Wenn wir ein `dict` wie `user_dict` nehmen, und es einer Funktion (oder Klassenmethode) mittels `**user_dict` √ºbergeben, wird Python es ‚Äûentpacken‚Äú. Es wird die Schl√ºssel und Werte von `user_dict` direkt als Schl√ºsselwort-Argumente √ºbergeben.

Wenn wir also das `user_dict` von oben nehmen und schreiben:

```Python
UserInDB(**user_dict)
```

dann ist das ungef√§hr √§quivalent zu:

```Python
UserInDB(
    username="john",
    password="secret",
    email="john.doe@example.com",
    full_name=None,
)
```

Oder, pr√§ziser, `user_dict` wird direkt verwendet, welche Werte es auch immer haben mag:

```Python
UserInDB(
    username = user_dict["username"],
    password = user_dict["password"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
)
```

#### Ein Pydantic-Modell aus den Inhalten eines anderen erstellen.

Da wir in obigem Beispiel `user_dict` mittels `user_in.dict()` erzeugt haben, ist dieser Code:

```Python
user_dict = user_in.dict()
UserInDB(**user_dict)
```

√§quivalent zu:

```Python
UserInDB(**user_in.dict())
```

... weil `user_in.dict()` ein `dict` ist, und dann lassen wir Python es ‚Äûentpacken‚Äú, indem wir es `UserInDB` √ºbergeben, mit vorangestelltem `**`.

Wir erhalten also ein Pydantic-Modell aus den Daten eines anderen Pydantic-Modells.

#### Ein `dict` entpacken und zus√§tzliche Schl√ºsselwort-Argumente

Und dann f√ºgen wir ein noch weiteres Schl√ºsselwort-Argument hinzu, `hashed_password=hashed_password`:

```Python
UserInDB(**user_in.dict(), hashed_password=hashed_password)
```

... was am Ende ergibt:

```Python
UserInDB(
    username = user_dict["username"],
    password = user_dict["password"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
    hashed_password = hashed_password,
)
```

/// warning | Achtung

Die Hilfsfunktionen `fake_password_hasher` und `fake_save_user` demonstrieren nur den m√∂glichen Fluss der Daten und bieten nat√ºrlich keine echte Sicherheit.

///

## Verdopplung vermeiden

Reduzierung von Code-Verdoppelung ist eine der Kern-Ideen von **FastAPI**.

Weil Verdoppelung von Code die Wahrscheinlichkeit von Fehlern, Sicherheitsproblemen, Desynchronisation (Code wird nur an einer Stelle ver√§ndert, aber nicht an einer anderen), usw. erh√∂ht.

Unsere Modelle teilen alle eine Menge der Daten und verdoppeln Attribut-Namen und -Typen.

Das k√∂nnen wir besser machen.

Wir deklarieren ein `UserBase`-Modell, das als Basis f√ºr unsere anderen Modelle dient. Dann k√∂nnen wir Unterklassen erstellen, die seine Attribute (Typdeklarationen, Validierungen, usw.) erben.

Die ganze Datenkonvertierung, -validierung, -dokumentation, usw. wird immer noch wie gehabt funktionieren.

Auf diese Weise beschreiben wir nur noch die Unterschiede zwischen den Modellen (mit Klartext-`password`, mit `hashed_password`, und ohne Passwort):

{* ../../docs_src/extra_models/tutorial002_py310.py hl[7,13:14,17:18,21:22] *}

## `Union`, oder `anyOf`

Sie k√∂nnen deklarieren, dass eine Response eine <abbr title="Union ‚Äì Verbund, Einheit‚Äö Vereinigung: Eines von Mehreren">`Union`</abbr> mehrerer Typen ist, sprich, einer dieser Typen.

Das wird in OpenAPI mit `anyOf` angezeigt.

Um das zu tun, verwenden Sie Pythons Standard-Typhinweis <a href="https://docs.python.org/3/library/typing.html#typing.Union" class="external-link" target="_blank">`typing.Union`</a>:

/// note | Hinweis

Listen Sie, wenn Sie eine <a href="https://pydantic-docs.helpmanual.io/usage/types/#unions" class="external-link" target="_blank">`Union`</a> definieren, denjenigen Typ zuerst, der am spezifischsten ist, gefolgt von den weniger spezifischen Typen. Im Beispiel oben, in `Union[PlaneItem, CarItem]` also den spezifischeren `PlaneItem` vor dem weniger spezifischen `CarItem`.

///

{* ../../docs_src/extra_models/tutorial003_py310.py hl[1,14:15,18:20,33] *}

### `Union` in Python 3.10

In diesem Beispiel √ºbergeben wir dem Argument `response_model` den Wert `Union[PlaneItem, CarItem]`.

Da wir es als **Wert einem Argument √ºberreichen**, statt es als **Typannotation** zu verwenden, m√ºssen wir `Union` verwenden, selbst in Python 3.10.

Wenn es eine Typannotation gewesen w√§re, h√§tten wir auch den vertikalen Trennstrich verwenden k√∂nnen, wie in:

```Python
some_variable: PlaneItem | CarItem
```

Aber wenn wir das in der Zuweisung `response_model=PlaneItem | CarItem` machen, erhalten wir eine Fehlermeldung, da Python versucht, eine **ung√ºltige Operation** zwischen `PlaneItem` und `CarItem` durchzuf√ºhren, statt es als Typannotation zu interpretieren.

## Listen von Modellen

Genauso k√∂nnen Sie eine Response deklarieren, die eine Liste von Objekten ist.

Verwenden Sie daf√ºr Pythons Standard `typing.List` (oder nur `list` in Python 3.9 und dar√ºber):

{* ../../docs_src/extra_models/tutorial004_py39.py hl[18] *}

## Response mit beliebigem `dict`

Sie k√∂nne auch eine Response deklarieren, die ein beliebiges `dict` zur√ºckgibt, bei dem nur die Typen der Schl√ºssel und der Werte bekannt sind, ohne ein Pydantic-Modell zu verwenden.

Das ist n√ºtzlich, wenn Sie die g√ºltigen Feld-/Attribut-Namen von vorneherein nicht wissen (was f√ºr ein Pydantic-Modell notwendig ist).

In diesem Fall k√∂nnen Sie `typing.Dict` verwenden (oder nur `dict` in Python 3.9 und dar√ºber):

{* ../../docs_src/extra_models/tutorial005_py39.py hl[6] *}

## Zusammenfassung

Verwenden Sie gerne mehrere Pydantic-Modelle und vererben Sie je nach Bedarf.

Sie brauchen kein einzelnes Datenmodell pro Einheit, wenn diese Einheit verschiedene Zust√§nde annehmen kann. So wie unsere Benutzer-‚ÄûEinheit‚Äú, welche einen Zustand mit `password`, einen mit `password_hash` und einen ohne Passwort hatte.


================================================
File: /docs/de/docs/tutorial/first-steps.md
================================================
# Erste Schritte

Die einfachste FastAPI-Datei k√∂nnte wie folgt aussehen:

{* ../../docs_src/first_steps/tutorial001.py *}

Kopieren Sie dies in eine Datei `main.py`.

Starten Sie den Live-Server:

<div class="termy">

```console
$ uvicorn main:app --reload

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
<span style="color: green;">INFO</span>:     Started reloader process [28720]
<span style="color: green;">INFO</span>:     Started server process [28722]
<span style="color: green;">INFO</span>:     Waiting for application startup.
<span style="color: green;">INFO</span>:     Application startup complete.
```

</div>

/// note | Hinweis

Der Befehl `uvicorn main:app` bezieht sich auf:

* `main`: die Datei `main.py` (das sogenannte Python-‚ÄûModul‚Äú).
* `app`: das Objekt, welches in der Datei `main.py` mit der Zeile `app = FastAPI()` erzeugt wurde.
* `--reload`: l√§sst den Server nach Code√§nderungen neu starten. Verwenden Sie das nur w√§hrend der Entwicklung.

///

In der Konsolenausgabe sollte es eine Zeile geben, die ungef√§hr so aussieht:

```hl_lines="4"
INFO:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

Diese Zeile zeigt die URL, unter der Ihre Anwendung auf Ihrem lokalen Computer bereitgestellt wird.

### Testen Sie es

√ñffnen Sie Ihren Browser unter <a href="http://127.0.0.1:8000" class="external-link" target="_blank">http://127.0.0.1:8000.</a>

Sie werden folgende JSON-Response sehen:

```JSON
{"message": "Hello World"}
```

### Interaktive API-Dokumentation

Gehen Sie als N√§chstes auf <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs </a>.

Sie werden die automatisch erzeugte, interaktive API-Dokumentation sehen (bereitgestellt durch <a href="https://github.com/swagger-api/swagger-ui" class="external-link" target="_blank">Swagger UI</a>):

![Swagger UI](https://fastapi.tiangolo.com/img/index/index-01-swagger-ui-simple.png)

### Alternative API-Dokumentation

Gehen Sie nun auf <a href="http://127.0.0.1:8000/redoc" class="external-link" target="_blank">http://127.0.0.1:8000/redoc</a>.

Dort sehen Sie die alternative, automatische Dokumentation (bereitgestellt durch <a href="https://github.com/Rebilly/ReDoc" class="external-link" target="_blank">ReDoc</a>):

![ReDoc](https://fastapi.tiangolo.com/img/index/index-02-redoc-simple.png)

### OpenAPI

**FastAPI** generiert ein ‚ÄûSchema‚Äú mit all Ihren APIs unter Verwendung des **OpenAPI**-Standards zur Definition von APIs.

#### ‚ÄûSchema‚Äú

Ein ‚ÄûSchema‚Äú ist eine Definition oder Beschreibung von etwas. Nicht der eigentliche Code, der es implementiert, sondern lediglich eine abstrakte Beschreibung.

#### API-‚ÄûSchema‚Äú

In diesem Fall ist  <a href="https://github.com/OAI/OpenAPI-Specification" class="external-link" target="_blank">OpenAPI</a> eine Spezifikation, die vorschreibt, wie ein Schema f√ºr Ihre API zu definieren ist.

Diese Schemadefinition enth√§lt Ihre API-Pfade, die m√∂glichen Parameter, welche diese entgegennehmen, usw.

#### Daten-‚ÄûSchema‚Äú

Der Begriff ‚ÄûSchema‚Äú kann sich auch auf die Form von Daten beziehen, wie z. B. einen JSON-Inhalt.

In diesem Fall sind die JSON-Attribute und deren Datentypen, usw. gemeint.

#### OpenAPI und JSON Schema

OpenAPI definiert ein API-Schema f√ºr Ihre API. Dieses Schema enth√§lt Definitionen (oder ‚ÄûSchemas‚Äú) der Daten, die von Ihrer API unter Verwendung von **JSON Schema**, dem Standard f√ºr JSON-Datenschemata, gesendet und empfangen werden.

#### √úberpr√ºfen Sie die `openapi.json`

Falls Sie wissen m√∂chten, wie das rohe OpenAPI-Schema aussieht: FastAPI generiert automatisch ein JSON (Schema) mit den Beschreibungen Ihrer gesamten API.

Sie k√∂nnen es direkt einsehen unter: <a href="http://127.0.0.1:8000/openapi.json" class="external-link" target="_blank">http://127.0.0.1:8000/openapi.json</a>.

Es wird ein JSON angezeigt, welches ungef√§hr so aussieht:

```JSON
{
    "openapi": "3.1.0",
    "info": {
        "title": "FastAPI",
        "version": "0.1.0"
    },
    "paths": {
        "/items/": {
            "get": {
                "responses": {
                    "200": {
                        "description": "Successful Response",
                        "content": {
                            "application/json": {



...
```

#### Wof√ºr OpenAPI gedacht ist

Das OpenAPI-Schema ist die Grundlage f√ºr die beiden enthaltenen interaktiven Dokumentationssysteme.

Es gibt dutzende Alternativen, die alle auf OpenAPI basieren. Sie k√∂nnen jede dieser Alternativen problemlos zu Ihrer mit **FastAPI** erstellten Anwendung hinzuf√ºgen.

Ebenfalls k√∂nnen Sie es verwenden, um automatisch Code f√ºr Clients zu generieren, die mit Ihrer API kommunizieren. Zum Beispiel f√ºr Frontend-, Mobile- oder IoT-Anwendungen.

## R√ºckblick, Schritt f√ºr Schritt

### Schritt 1: Importieren von `FastAPI`

{* ../../docs_src/first_steps/tutorial001.py hl[1] *}

`FastAPI` ist eine Python-Klasse, die die gesamte Funktionalit√§t f√ºr Ihre API bereitstellt.

/// note | Technische Details

`FastAPI`  ist eine Klasse, die direkt von `Starlette` erbt.

Sie k√∂nnen alle <a href="https://www.starlette.io/" class="external-link" target="_blank">Starlette</a>-Funktionalit√§ten auch mit `FastAPI` nutzen.

///

### Schritt 2: Erzeugen einer `FastAPI`-‚ÄûInstanz‚Äú

{* ../../docs_src/first_steps/tutorial001.py hl[3] *}

In diesem Beispiel ist die Variable `app` eine ‚ÄûInstanz‚Äú der Klasse `FastAPI`.

Dies wird der Hauptinteraktionspunkt f√ºr die Erstellung all Ihrer APIs sein.

Die Variable `app` ist dieselbe, auf die sich der Befehl `uvicorn` bezieht:

<div class="termy">

```console
$ uvicorn main:app --reload

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

Wenn Sie Ihre Anwendung wie folgt erstellen:

{* ../../docs_src/first_steps/tutorial002.py hl[3] *}

Und in eine Datei `main.py` einf√ºgen, dann w√ºrden Sie `uvicorn` wie folgt aufrufen:

<div class="termy">

```console
$ uvicorn main:my_awesome_api --reload

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

### Schritt 3: Erstellen einer *Pfadoperation*

#### Pfad

‚ÄûPfad‚Äú bezieht sich hier auf den letzten Teil der URL, beginnend mit dem ersten `/`.

In einer URL wie:

```
https://example.com/items/foo
```

... w√§re der Pfad folglich:

```
/items/foo
```

/// info

Ein ‚ÄûPfad‚Äú wird h√§ufig auch als ‚ÄûEndpunkt‚Äú oder ‚ÄûRoute‚Äú bezeichnet.

///

Bei der Erstellung einer API ist der ‚ÄûPfad‚Äú die wichtigste M√∂glichkeit zur Trennung von ‚ÄûAnliegen‚Äú und ‚ÄûRessourcen‚Äú.

#### Operation

‚ÄûOperation‚Äú bezieht sich hier auf eine der HTTP-‚ÄûMethoden‚Äú.

Eine von diesen:

* `POST`
* `GET`
* `PUT`
* `DELETE`

... und die etwas Exotischeren:

* `OPTIONS`
* `HEAD`
* `PATCH`
* `TRACE`

Im HTTP-Protokoll k√∂nnen Sie mit jedem Pfad √ºber eine (oder mehrere) dieser ‚ÄûMethoden‚Äú kommunizieren.

---

Bei der Erstellung von APIs verwenden Sie normalerweise diese spezifischen HTTP-Methoden, um eine bestimmte Aktion durchzuf√ºhren.

Normalerweise verwenden Sie:

* `POST`: um Daten zu erzeugen (create).
* `GET`: um Daten zu lesen (read).
* `PUT`: um Daten zu aktualisieren (update).
* `DELETE`: um Daten zu l√∂schen (delete).

In OpenAPI wird folglich jede dieser HTTP-Methoden als ‚ÄûOperation‚Äú bezeichnet.

Wir werden sie auch ‚Äû**Operationen**‚Äú nennen.

#### Definieren eines *Pfadoperation-Dekorators*

{* ../../docs_src/first_steps/tutorial001.py hl[6] *}

Das `@app.get("/")` sagt **FastAPI**, dass die Funktion direkt darunter f√ºr die Bearbeitung von Anfragen zust√§ndig ist, die an:

 * den Pfad `/`
 * unter der Verwendung der <abbr title="eine HTTP GET Methode"><code>get</code>-Operation</abbr> gehen

/// info | `@decorator` Information

Diese `@something`-Syntax wird in Python ‚ÄûDekorator‚Äú genannt.

Sie platzieren ihn √ºber einer Funktion. Wie ein h√ºbscher, dekorativer Hut (daher kommt wohl der Begriff).

Ein ‚ÄûDekorator‚Äú nimmt die darunter stehende Funktion und macht etwas damit.

In unserem Fall teilt dieser Dekorator **FastAPI** mit, dass die folgende Funktion mit dem **Pfad** `/` und der **Operation** `get` zusammenh√§ngt.

Dies ist der ‚Äû**Pfadoperation-Dekorator**‚Äú.

///

Sie k√∂nnen auch die anderen Operationen verwenden:

* `@app.post()`
* `@app.put()`
* `@app.delete()`

Oder die exotischeren:

* `@app.options()`
* `@app.head()`
* `@app.patch()`
* `@app.trace()`

/// tip | Tipp

Es steht Ihnen frei, jede Operation (HTTP-Methode) so zu verwenden, wie Sie es m√∂chten.

**FastAPI** erzwingt keine bestimmte Bedeutung.

Die hier aufgef√ºhrten Informationen dienen als Leitfaden und sind nicht verbindlich.

Wenn Sie beispielsweise GraphQL verwenden, f√ºhren Sie normalerweise alle Aktionen nur mit ‚ÄûPOST‚Äú-Operationen durch.

///

### Schritt 4: Definieren der **Pfadoperation-Funktion**

Das ist unsere ‚Äû**Pfadoperation-Funktion**‚Äú:

* **Pfad**: ist `/`.
* **Operation**: ist `get`.
* **Funktion**: ist die Funktion direkt unter dem ‚ÄûDekorator‚Äú (unter `@app.get("/")`).

{* ../../docs_src/first_steps/tutorial001.py hl[7] *}

Dies ist eine Python-Funktion.

Sie wird von **FastAPI** immer dann aufgerufen, wenn sie eine Anfrage an die URL "`/`" mittels einer `GET`-Operation erh√§lt.

In diesem Fall handelt es sich um eine `async`-Funktion.

---

Sie k√∂nnten sie auch als normale Funktion anstelle von `async def` definieren:

{* ../../docs_src/first_steps/tutorial003.py hl[7] *}

/// note | Hinweis

Wenn Sie den Unterschied nicht kennen, lesen Sie [Async: *‚ÄûIn Eile?‚Äú*](../async.md#in-eile){.internal-link target=_blank}.

///

### Schritt 5: den Inhalt zur√ºckgeben

{* ../../docs_src/first_steps/tutorial001.py hl[8] *}

Sie k√∂nnen ein `dict`, eine `list`, einzelne Werte wie `str`, `int`, usw. zur√ºckgeben.

Sie k√∂nnen auch Pydantic-Modelle zur√ºckgeben (dazu sp√§ter mehr).

Es gibt viele andere Objekte und Modelle, die automatisch zu JSON konvertiert werden (einschlie√ülich ORMs usw.). Versuchen Sie, Ihre Lieblingsobjekte zu verwenden. Es ist sehr wahrscheinlich, dass sie bereits unterst√ºtzt werden.

## Zusammenfassung

* Importieren Sie `FastAPI`.
* Erstellen Sie eine `app` Instanz.
* Schreiben Sie einen **Pfadoperation-Dekorator** (wie z. B. `@app.get("/")`).
* Schreiben Sie eine **Pfadoperation-Funktion** (wie z. B. oben `def root(): ...`).
* Starten Sie den Entwicklungsserver (z. B. `uvicorn main:app --reload`).


================================================
File: /docs/de/docs/tutorial/handling-errors.md
================================================
# Fehlerbehandlung

Es gibt viele Situationen, in denen Sie einem Client, der Ihre API benutzt, einen Fehler zur√ºckgeben m√ºssen.

Dieser Client k√∂nnte ein Browser mit einem Frontend, Code von jemand anderem, ein <abbr title="Internet of Things ‚Äì Internet der Dinge: Ger√§te, die √ºber das Internet Informationen austauschen">IoT</abbr>-Ger√§t, usw., sein.

Sie m√ºssten beispielsweise einem Client sagen:

* Dass er nicht die notwendigen Berechtigungen hat, eine Aktion auszuf√ºhren.
* Dass er zu einer Ressource keinen Zugriff hat.
* Dass die Ressource, auf die er zugreifen m√∂chte, nicht existiert.
* usw.

In diesen F√§llen geben Sie normalerweise einen **HTTP-Statuscode** im Bereich **400** (400 bis 499) zur√ºck.

Das ist vergleichbar mit den HTTP-Statuscodes im Bereich 200 (von 200 bis 299). Diese ‚Äû200‚Äúer Statuscodes bedeuten, dass der Request in einem bestimmten Aspekt ein ‚ÄûSuccess‚Äú (‚ÄûErfolg‚Äú) war.

Die Statuscodes im 400er-Bereich bedeuten hingegen, dass es einen Fehler gab.

Erinnern Sie sich an all diese **404 Not Found** Fehler (und Witze)?

## `HTTPException` verwenden

Um HTTP-Responses mit Fehlern zum Client zur√ºckzugeben, verwenden Sie `HTTPException`.

### `HTTPException` importieren

{* ../../docs_src/handling_errors/tutorial001.py hl[1] *}

### Eine `HTTPException` in Ihrem Code ausl√∂sen

`HTTPException` ist eine normale Python-<abbr title="Exception ‚Äì Ausnahme, Fehler: Python-Objekt, das einen Fehler nebst Metadaten repr√§sentiert">Exception</abbr> mit einigen zus√§tzlichen Daten, die f√ºr APIs relevant sind.

Weil es eine Python-Exception ist, geben Sie sie nicht zur√ºck, (`return`), sondern Sie l√∂sen sie aus (`raise`).

Das bedeutet auch, wenn Sie in einer Hilfsfunktion sind, die Sie von ihrer *Pfadoperation-Funktion* aus aufrufen, und Sie l√∂sen eine `HTTPException` von innerhalb dieser Hilfsfunktion aus, dann wird der Rest der *Pfadoperation-Funktion* nicht ausgef√ºhrt, sondern der Request wird sofort abgebrochen und der HTTP-Error der `HTTP-Exception` wird zum Client gesendet.

Der Vorteil, eine Exception auszul√∂sen (`raise`), statt sie zur√ºckzugeben (`return`) wird im Abschnitt √ºber Abh√§ngigkeiten und Sicherheit klarer werden.

Im folgenden Beispiel l√∂sen wir, wenn der Client eine ID anfragt, die nicht existiert, eine Exception mit dem Statuscode `404` aus.

{* ../../docs_src/handling_errors/tutorial001.py hl[11] *}

### Die resultierende Response

Wenn der Client `http://example.com/items/foo` anfragt (ein `item_id` `"foo"`), erh√§lt dieser Client einen HTTP-Statuscode 200 und folgende JSON-Response:

```JSON
{
  "item": "The Foo Wrestlers"
}
```

Aber wenn der Client `http://example.com/items/bar` anfragt (ein nicht-existierendes `item_id` `"bar"`), erh√§lt er einen HTTP-Statuscode 404 (der ‚ÄûNot Found‚Äú-Fehler), und eine JSON-Response wie folgt:

```JSON
{
  "detail": "Item not found"
}
```

/// tip | Tipp

Wenn Sie eine `HTTPException` ausl√∂sen, k√∂nnen Sie dem Parameter `detail` jeden Wert √ºbergeben, der nach JSON konvertiert werden kann, nicht nur `str`.

Zum Beispiel ein `dict`, eine `list`, usw.

Das wird automatisch von **FastAPI** gehandhabt und der Wert nach JSON konvertiert.

///

## Benutzerdefinierte Header hinzuf√ºgen

Es gibt Situationen, da ist es n√ºtzlich, dem HTTP-Error benutzerdefinierte Header hinzuf√ºgen zu k√∂nnen, etwa in einigen Sicherheitsszenarien.

Sie m√ºssen das wahrscheinlich nicht direkt in ihrem Code verwenden.

Aber falls es in einem fortgeschrittenen Szenario notwendig ist, k√∂nnen Sie benutzerdefinierte Header wie folgt hinzuf√ºgen:

{* ../../docs_src/handling_errors/tutorial002.py hl[14] *}

## Benutzerdefinierte Exceptionhandler definieren

Sie k√∂nnen benutzerdefinierte <abbr title="Exceptionhandler ‚Äì Ausnahmebehandler: Funktion, die sich um die Bearbeitung einer Exception k√ºmmert">Exceptionhandler</abbr> hinzuf√ºgen, mithilfe <a href="https://www.starlette.io/exceptions/" class="external-link" target="_blank">derselben Werkzeuge f√ºr Exceptions von Starlette</a>.

Nehmen wir an, Sie haben eine benutzerdefinierte Exception `UnicornException`, die Sie (oder eine Bibliothek, die Sie verwenden) `raise`n k√∂nnten.

Und Sie m√∂chten diese Exception global mit FastAPI handhaben.

Sie k√∂nnten einen benutzerdefinierten Exceptionhandler mittels `@app.exception_handler()` hinzuf√ºgen:

{* ../../docs_src/handling_errors/tutorial003.py hl[5:7,13:18,24] *}

Wenn Sie nun `/unicorns/yolo` anfragen, `raise`d die *Pfadoperation* eine `UnicornException`.

Aber diese wird von `unicorn_exception_handler` gehandhabt.

Sie erhalten also einen sauberen Error mit einem Statuscode `418` und dem JSON-Inhalt:

```JSON
{"message": "Oops! yolo did something. There goes a rainbow..."}
```

/// note | Technische Details

Sie k√∂nnen auch `from starlette.requests import Request` und `from starlette.responses import JSONResponse` verwenden.

**FastAPI** bietet dieselben `starlette.responses` auch via `fastapi.responses` an, als Annehmlichkeit f√ºr Sie, den Entwickler. Die meisten verf√ºgbaren Responses kommen aber direkt von Starlette. Das Gleiche gilt f√ºr `Request`.

///

## Die Default-Exceptionhandler √ºberschreiben

**FastAPI** hat einige Default-Exceptionhandler.

Diese Handler k√ºmmern sich darum, Default-JSON-Responses zur√ºckzugeben, wenn Sie eine `HTTPException` `raise`n, und wenn der Request ung√ºltige Daten enth√§lt.

Sie k√∂nnen diese Exceptionhandler mit ihren eigenen √ºberschreiben.

### Requestvalidierung-Exceptions √ºberschreiben

Wenn ein Request ung√ºltige Daten enth√§lt, l√∂st **FastAPI** intern einen `RequestValidationError` aus.

Und bietet auch einen Default-Exceptionhandler daf√ºr.

Um diesen zu √ºberschreiben, importieren Sie den `RequestValidationError` und verwenden Sie ihn in `@app.exception_handler(RequestValidationError)`, um Ihren Exceptionhandler zu dekorieren.

Der Exceptionhandler wird einen `Request` und die Exception entgegennehmen.

{* ../../docs_src/handling_errors/tutorial004.py hl[2,14:16] *}

Wenn Sie nun `/items/foo` besuchen, erhalten Sie statt des Default-JSON-Errors:

```JSON
{
    "detail": [
        {
            "loc": [
                "path",
                "item_id"
            ],
            "msg": "value is not a valid integer",
            "type": "type_error.integer"
        }
    ]
}
```

eine Textversion:

```
1 validation error
path -> item_id
  value is not a valid integer (type=type_error.integer)
```

#### `RequestValidationError` vs. `ValidationError`

/// warning | Achtung

Das folgende sind technische Details, die Sie √ºberspringen k√∂nnen, wenn sie f√ºr Sie nicht wichtig sind.

///

`RequestValidationError` ist eine Unterklasse von Pydantics <a href="https://pydantic-docs.helpmanual.io/usage/models/#error-handling" class="external-link" target="_blank">`ValidationError`</a>.

**FastAPI** verwendet diesen, sodass Sie, wenn Sie ein Pydantic-Modell f√ºr `response_model` verwenden, und ihre Daten fehlerhaft sind, einen Fehler in ihrem Log sehen.

Aber der Client/Benutzer sieht ihn nicht. Stattdessen erh√§lt der Client einen <abbr title="Interner Server-Fehler">‚ÄûInternal Server Error‚Äú</abbr> mit einem HTTP-Statuscode `500`.

Das ist, wie es sein sollte, denn wenn Sie einen Pydantic-`ValidationError` in Ihrer *Response* oder irgendwo sonst in ihrem Code haben (es sei denn, im *Request* des Clients), ist das tats√§chlich ein Bug in ihrem Code.

Und w√§hrend Sie den Fehler beheben, sollten ihre Clients/Benutzer keinen Zugriff auf interne Informationen √ºber den Fehler haben, da das eine Sicherheitsl√ºcke aufdecken k√∂nnte.

### den `HTTPException`-Handler √ºberschreiben

Genauso k√∂nnen Sie den `HTTPException`-Handler √ºberschreiben.

Zum Beispiel k√∂nnten Sie eine Klartext-Response statt JSON f√ºr diese Fehler zur√ºckgeben wollen:

{* ../../docs_src/handling_errors/tutorial004.py hl[3:4,9:11,22] *}

/// note | Technische Details

Sie k√∂nnen auch `from starlette.responses import PlainTextResponse` verwenden.

**FastAPI** bietet dieselben `starlette.responses` auch via `fastapi.responses` an, als Annehmlichkeit f√ºr Sie, den Entwickler. Die meisten verf√ºgbaren Responses kommen aber direkt von Starlette.

///

### Den `RequestValidationError`-Body verwenden

Der `RequestValidationError` enth√§lt den empfangenen `body` mit den ung√ºltigen Daten.

Sie k√∂nnten diesen verwenden, w√§hrend Sie Ihre Anwendung entwickeln, um den Body zu loggen und zu debuggen, ihn zum Benutzer zur√ºckzugeben, usw.

{* ../../docs_src/handling_errors/tutorial005.py hl[14] *}

Jetzt versuchen Sie, einen ung√ºltigen Artikel zu senden:

```JSON
{
  "title": "towel",
  "size": "XL"
}
```

Sie erhalten eine Response, die Ihnen sagt, dass die Daten ung√ºltig sind, und welche den empfangenen Body enth√§lt.

```JSON hl_lines="12-15"
{
  "detail": [
    {
      "loc": [
        "body",
        "size"
      ],
      "msg": "value is not a valid integer",
      "type": "type_error.integer"
    }
  ],
  "body": {
    "title": "towel",
    "size": "XL"
  }
}
```

#### FastAPIs `HTTPException` vs. Starlettes `HTTPException`

**FastAPI** hat seine eigene `HTTPException`.

Und **FastAPI**s `HTTPException`-Fehlerklasse erbt von Starlettes `HTTPException`-Fehlerklasse.

Der einzige Unterschied besteht darin, dass **FastAPIs** `HTTPException` alles f√ºr das Feld `detail` akzeptiert, was nach JSON konvertiert werden kann, w√§hrend Starlettes `HTTPException` nur Strings zul√§sst.

Sie k√∂nnen also weiterhin **FastAPI**s `HTTPException` wie √ºblich in Ihrem Code ausl√∂sen.

Aber wenn Sie einen Exceptionhandler registrieren, registrieren Sie ihn f√ºr Starlettes `HTTPException`.

Auf diese Weise wird Ihr Handler, wenn irgendein Teil von Starlettes internem Code, oder eine Starlette-Erweiterung, oder -Plugin eine Starlette-`HTTPException` ausl√∂st, in der Lage sein, diese zu fangen und zu handhaben.

Damit wir in diesem Beispiel beide `HTTPException`s im selben Code haben k√∂nnen, benennen wir Starlettes Exception um zu `StarletteHTTPException`:

```Python
from starlette.exceptions import HTTPException as StarletteHTTPException
```

### **FastAPI**s Exceptionhandler wiederverwenden

Wenn Sie die Exception zusammen mit denselben Default-Exceptionhandlern von **FastAPI** verwenden m√∂chten, k√∂nnen Sie die Default-Exceptionhandler von `fastapi.Exception_handlers` importieren und wiederverwenden:

{* ../../docs_src/handling_errors/tutorial006.py hl[2:5,15,21] *}

In diesem Beispiel `print`en Sie nur den Fehler mit einer sehr ausdrucksstarken Nachricht, aber Sie sehen, worauf wir hinauswollen. Sie k√∂nnen mit der Exception etwas machen und dann einfach die Default-Exceptionhandler wiederverwenden.


================================================
File: /docs/de/docs/tutorial/header-params.md
================================================
# Header-Parameter

So wie `Query`-, `Path`-, und `Cookie`-Parameter k√∂nnen Sie auch <abbr title='Header ‚Äì Kopfzeilen, Header, Header-Felder: Schl√ºssel-Wert-Metadaten, die vom Client beim Request, und vom Server bei der Response gesendet werden'>Header</abbr>-Parameter definieren.

## `Header` importieren

Importieren Sie zuerst `Header`:

{* ../../docs_src/header_params/tutorial001_an_py310.py hl[3] *}

## `Header`-Parameter deklarieren

Dann deklarieren Sie Ihre Header-Parameter, auf die gleiche Weise, wie Sie auch `Path`-, `Query`-, und `Cookie`-Parameter deklarieren.

Der erste Wert ist der Typ. Sie k√∂nnen `Header` die gehabten Extra Validierungs- und Beschreibungsparameter hinzuf√ºgen. Danach k√∂nnen Sie einen Defaultwert vergeben:

{* ../../docs_src/header_params/tutorial001_an_py310.py hl[9] *}

/// note | Technische Details

`Header` ist eine Schwesterklasse von `Path`, `Query` und `Cookie`. Sie erbt von derselben gemeinsamen `Param`-Elternklasse.

Aber erinnern Sie sich, dass, wenn Sie `Query`, `Path`,  `Header` und andere von `fastapi` importieren, diese tats√§chlich Funktionen sind, welche spezielle Klassen zur√ºckgeben.

///

/// info

Um Header zu deklarieren, m√ºssen Sie `Header` verwenden, da diese Parameter sonst als Query-Parameter interpretiert werden w√ºrden.

///

## Automatische Konvertierung

`Header` hat weitere Funktionalit√§t, zus√§tzlich zu der, die `Path`, `Query` und `Cookie` bereitstellen.

Die meisten Standard-Header benutzen als Trennzeichen einen Bindestrich, auch bekannt als das ‚ÄûMinus-Symbol‚Äú (`-`).

Aber eine Variable wie `user-agent` ist in Python nicht g√ºltig.

Darum wird `Header` standardm√§√üig in Parameternamen den Unterstrich (`_`) zu einem Bindestrich (`-`) konvertieren.

HTTP-Header sind au√üerdem unabh√§ngig von Gro√ü-/Kleinschreibung, darum k√∂nnen Sie sie mittels der Standard-Python-Schreibweise deklarieren (auch bekannt als "snake_case").

Sie k√∂nnen also `user_agent` schreiben, wie Sie es normalerweise in Python-Code machen w√ºrden, statt etwa die ersten Buchstaben gro√ü zu schreiben, wie in `User_Agent`.

Wenn Sie aus irgendeinem Grund das automatische Konvertieren von Unterstrichen zu Bindestrichen abschalten m√∂chten, setzen Sie den Parameter `convert_underscores` auf `False`.

{* ../../docs_src/header_params/tutorial002_an_py310.py hl[10] *}

/// warning | Achtung

Bevor Sie `convert_underscores` auf `False` setzen, bedenken Sie, dass manche HTTP-Proxys und Server die Verwendung von Headern mit Unterstrichen nicht erlauben.

///

## Doppelte Header

Es ist m√∂glich, doppelte Header zu empfangen. Also den gleichen Header mit unterschiedlichen Werten.

Sie k√∂nnen solche F√§lle deklarieren, indem Sie in der Typdeklaration eine Liste verwenden.

Sie erhalten dann alle Werte von diesem doppelten Header als Python-`list`e.

Um zum Beispiel einen Header `X-Token` zu deklarieren, der mehrmals vorkommen kann, schreiben Sie:

{* ../../docs_src/header_params/tutorial003_an_py310.py hl[9] *}

Wenn Sie mit einer *Pfadoperation* kommunizieren, die zwei HTTP-Header sendet, wie:

```
X-Token: foo
X-Token: bar
```

Dann w√§re die Response:

```JSON
{
    "X-Token values": [
        "bar",
        "foo"
    ]
}
```

## Zusammenfassung

Deklarieren Sie Header mittels `Header`, auf die gleiche Weise wie bei `Query`, `Path` und `Cookie`.

Machen Sie sich keine Sorgen um Unterstriche in ihren Variablen, **FastAPI** wird sich darum k√ºmmern, diese zu konvertieren.


================================================
File: /docs/de/docs/tutorial/index.md
================================================
# Tutorial ‚Äì Benutzerhandbuch

Dieses Tutorial zeigt Ihnen Schritt f√ºr Schritt, wie Sie **FastAPI** und die meisten seiner Funktionen verwenden k√∂nnen.

Jeder Abschnitt baut schrittweise auf den vorhergehenden auf. Diese Abschnitte sind aber nach einzelnen Themen gegliedert, sodass Sie direkt zu einem bestimmten Thema √ºbergehen k√∂nnen, um Ihre speziellen API-Anforderungen zu l√∂sen.

Au√üerdem dienen diese als zuk√ºnftige Referenz.

Dadurch k√∂nnen Sie jederzeit  zur√ºckkommen und sehen genau das, was Sie ben√∂tigen.

## Den Code ausf√ºhren

Alle Codebl√∂cke k√∂nnen kopiert und direkt verwendet werden (da es sich um getestete Python-Dateien handelt).

Um eines der Beispiele auszuf√ºhren, kopieren Sie den Code in eine Datei `main.py`, und starten Sie `uvicorn` mit:

<div class="termy">

```console
$ uvicorn main:app --reload

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
<span style="color: green;">INFO</span>:     Started reloader process [28720]
<span style="color: green;">INFO</span>:     Started server process [28722]
<span style="color: green;">INFO</span>:     Waiting for application startup.
<span style="color: green;">INFO</span>:     Application startup complete.
```

</div>

Es wird **ausdr√ºcklich empfohlen**, dass Sie den Code schreiben oder kopieren, ihn bearbeiten und lokal ausf√ºhren.

Die Verwendung in Ihrem eigenen Editor zeigt Ihnen die Vorteile von FastAPI am besten, wenn Sie sehen, wie wenig Code Sie schreiben m√ºssen, all die Typpr√ºfungen, die automatische Vervollst√§ndigung usw.

---

## FastAPI installieren

Der erste Schritt besteht aus der Installation von FastAPI.

F√ºr dieses Tutorial empfiehlt es sich, FastAPI mit allen optionalen Abh√§ngigkeiten und Funktionen zu installieren:

<div class="termy">

```console
$ pip install "fastapi[all]"

---> 100%
```

</div>

... das beinhaltet auch `uvicorn`, welchen Sie als Server verwenden k√∂nnen, der ihren Code ausf√ºhrt.

/// note | Hinweis

Sie k√∂nnen die einzelnen Teile auch separat installieren.

Das folgende w√ºrden Sie wahrscheinlich tun, wenn Sie Ihre Anwendung in der Produktion einsetzen:

```
pip install fastapi
```

Installieren Sie auch `uvicorn` als Server:

```
pip install "uvicorn[standard]"
```

Das gleiche gilt f√ºr jede der optionalen Abh√§ngigkeiten, die Sie verwenden m√∂chten.

///

## Handbuch f√ºr fortgeschrittene Benutzer

Es gibt auch ein **Handbuch f√ºr fortgeschrittene Benutzer**, welches Sie sp√§ter nach diesem **Tutorial ‚Äì Benutzerhandbuch** lesen k√∂nnen.

Das **Handbuch f√ºr fortgeschrittene Benutzer** baut auf diesem Tutorial auf, verwendet dieselben Konzepte und bringt Ihnen einige zus√§tzliche Funktionen bei.

Allerdings sollten Sie zuerst das **Tutorial ‚Äì Benutzerhandbuch** lesen (was Sie hier gerade tun).

Die Dokumentation ist so konzipiert, dass Sie mit dem **Tutorial ‚Äì Benutzerhandbuch** eine vollst√§ndige Anwendung erstellen k√∂nnen und diese dann je nach Bedarf mit einigen der zus√§tzlichen Ideen aus dem **Handbuch f√ºr fortgeschrittene Benutzer** vervollst√§ndigen k√∂nnen.


================================================
File: /docs/de/docs/tutorial/metadata.md
================================================
# Metadaten und URLs der Dokumentationen

Sie k√∂nnen mehrere Metadaten-Einstellungen f√ºr Ihre **FastAPI**-Anwendung konfigurieren.

## Metadaten f√ºr die API

Sie k√∂nnen die folgenden Felder festlegen, welche in der OpenAPI-Spezifikation und den Benutzeroberfl√§chen der automatischen API-Dokumentation verwendet werden:

| Parameter | Typ | Beschreibung |
|------------|------|-------------|
| `title` | `str` | Der Titel der API. |
| `summary` | `str` | Eine kurze Zusammenfassung der API. <small>Verf√ºgbar seit OpenAPI 3.1.0, FastAPI 0.99.0.</small> |
| `description` | `str` | Eine kurze Beschreibung der API. Kann Markdown verwenden. |
| `version` | `string` | Die Version der API. Das ist die Version Ihrer eigenen Anwendung, nicht die von OpenAPI. Zum Beispiel `2.5.0`. |
| `terms_of_service` | `str` | Eine URL zu den Nutzungsbedingungen f√ºr die API. Falls angegeben, muss es sich um eine URL handeln. |
| `contact` | `dict` | Die Kontaktinformationen f√ºr die verf√ºgbar gemachte API. Kann mehrere Felder enthalten. <details><summary><code>contact</code>-Felder</summary><table><thead><tr><th>Parameter</th><th>Typ</th><th>Beschreibung</th></tr></thead><tbody><tr><td><code>name</code></td><td><code>str</code></td><td>Der identifizierende Name der Kontaktperson/Organisation.</td></tr><tr><td><code>url</code></td><td><code>str</code></td><td>Die URL, die auf die Kontaktinformationen verweist. MUSS im Format einer URL vorliegen.</td></tr><tr><td><code>email</code></td><td><code>str</code></td><td>Die E-Mail-Adresse der Kontaktperson/Organisation. MUSS im Format einer E-Mail-Adresse vorliegen.</td></tr></tbody></table></details> |
| `license_info` | `dict` | Die Lizenzinformationen f√ºr die verf√ºgbar gemachte API. Kann mehrere Felder enthalten. <details><summary><code>license_info</code>-Felder</summary><table><thead><tr><th>Parameter</th><th>Typ</th><th>Beschreibung</th></tr></thead><tbody><tr><td><code>name</code></td><td><code>str</code></td><td><strong>ERFORDERLICH</strong> (wenn eine <code>license_info</code> festgelegt ist). Der f√ºr die API verwendete Lizenzname.</td></tr><tr><td><code>identifier</code></td><td><code>str</code></td><td>Ein <a href="https://spdx.org/licenses/" class="external-link" target="_blank">SPDX</a>-Lizenzausdruck f√ºr die API. Das Feld <code>identifier</code> und das Feld <code>url</code> schlie√üen sich gegenseitig aus. <small>Verf√ºgbar seit OpenAPI 3.1.0, FastAPI 0.99.0.</small></td></tr><tr><td><code>url</code></td><td><code >str</code></td><td>Eine URL zur Lizenz, die f√ºr die API verwendet wird. MUSS im Format einer URL vorliegen.</td></tr></tbody></table></details> |

Sie k√∂nnen diese wie folgt setzen:

{* ../../docs_src/metadata/tutorial001.py hl[3:16,19:32] *}

/// tip | Tipp

Sie k√∂nnen Markdown in das Feld `description` schreiben und es wird in der Ausgabe gerendert.

///

Mit dieser Konfiguration w√ºrde die automatische API-Dokumentation wie folgt aussehen:

<img src="/img/tutorial/metadata/image01.png">

## Lizenz-ID

Seit OpenAPI 3.1.0 und FastAPI 0.99.0 k√∂nnen Sie die `license_info` auch mit einem `identifier` anstelle einer `url` festlegen.

Zum Beispiel:

{* ../../docs_src/metadata/tutorial001_1.py hl[31] *}

## Metadaten f√ºr Tags

Sie k√∂nnen mit dem Parameter `openapi_tags` auch zus√§tzliche Metadaten f√ºr die verschiedenen Tags hinzuf√ºgen, die zum Gruppieren Ihrer Pfadoperationen verwendet werden.

Es wird eine Liste ben√∂tigt, die f√ºr jedes Tag ein Dict enth√§lt.

Jedes Dict kann Folgendes enthalten:

* `name` (**erforderlich**): ein `str` mit demselben Tag-Namen, den Sie im Parameter `tags` in Ihren *Pfadoperationen* und `APIRouter`n verwenden.
* `description`: ein `str` mit einer kurzen Beschreibung f√ºr das Tag. Sie kann Markdown enthalten und wird in der Benutzeroberfl√§che der Dokumentation angezeigt.
* `externalDocs`: ein `dict`, das externe Dokumentation beschreibt mit:
     * `description`: ein `str` mit einer kurzen Beschreibung f√ºr die externe Dokumentation.
     * `url` (**erforderlich**): ein `str` mit der URL f√ºr die externe Dokumentation.

### Metadaten f√ºr Tags erstellen

Versuchen wir das an einem Beispiel mit Tags f√ºr `users` und `items`.

Erstellen Sie Metadaten f√ºr Ihre Tags und √ºbergeben Sie sie an den Parameter `openapi_tags`:

{* ../../docs_src/metadata/tutorial004.py hl[3:16,18] *}

Beachten Sie, dass Sie Markdown in den Beschreibungen verwenden k√∂nnen. Beispielsweise wird ‚Äûlogin‚Äú in Fettschrift (**login**) und ‚Äûfancy‚Äú in Kursivschrift (_fancy_) angezeigt.

/// tip | Tipp

Sie m√ºssen nicht f√ºr alle von Ihnen verwendeten Tags Metadaten hinzuf√ºgen.

///

### Ihre Tags verwenden

Verwenden Sie den Parameter `tags` mit Ihren *Pfadoperationen* (und `APIRouter`n), um diese verschiedenen Tags zuzuweisen:

{* ../../docs_src/metadata/tutorial004.py hl[21,26] *}

/// info

Lesen Sie mehr zu Tags unter [Pfadoperation-Konfiguration](path-operation-configuration.md#tags){.internal-link target=_blank}.

///

### Die Dokumentation anschauen

Wenn Sie nun die Dokumentation ansehen, werden dort alle zus√§tzlichen Metadaten angezeigt:

<img src="/img/tutorial/metadata/image02.png">

### Reihenfolge der Tags

Die Reihenfolge der Tag-Metadaten-Dicts definiert auch die Reihenfolge, in der diese in der Benutzeroberfl√§che der Dokumentation angezeigt werden.

Auch wenn beispielsweise `users` im Alphabet nach `items` kommt, wird es vor diesen angezeigt, da wir seine Metadaten als erstes Dict der Liste hinzugef√ºgt haben.

## OpenAPI-URL

Standardm√§√üig wird das OpenAPI-Schema unter `/openapi.json` bereitgestellt.

Sie k√∂nnen das aber mit dem Parameter `openapi_url` konfigurieren.

Um beispielsweise festzulegen, dass es unter `/api/v1/openapi.json` bereitgestellt wird:

{* ../../docs_src/metadata/tutorial002.py hl[3] *}

Wenn Sie das OpenAPI-Schema vollst√§ndig deaktivieren m√∂chten, k√∂nnen Sie `openapi_url=None` festlegen, wodurch auch die Dokumentationsbenutzeroberfl√§chen deaktiviert werden, die es verwenden.

## URLs der Dokumentationen

Sie k√∂nnen die beiden enthaltenen Dokumentationsbenutzeroberfl√§chen konfigurieren:

* **Swagger UI**: bereitgestellt unter `/docs`.
     * Sie k√∂nnen deren URL mit dem Parameter `docs_url` festlegen.
     * Sie k√∂nnen sie deaktivieren, indem Sie `docs_url=None` festlegen.
* **ReDoc**: bereitgestellt unter `/redoc`.
     * Sie k√∂nnen deren URL mit dem Parameter `redoc_url` festlegen.
     * Sie k√∂nnen sie deaktivieren, indem Sie `redoc_url=None` festlegen.

Um beispielsweise Swagger UI so einzustellen, dass sie unter `/documentation` bereitgestellt wird, und ReDoc zu deaktivieren:

{* ../../docs_src/metadata/tutorial003.py hl[3] *}


================================================
File: /docs/de/docs/tutorial/middleware.md
================================================
# Middleware

Sie k√∂nnen Middleware zu **FastAPI**-Anwendungen hinzuf√ºgen.

Eine ‚ÄûMiddleware‚Äú ist eine Funktion, die mit jedem **Request** arbeitet, bevor er von einer bestimmten *Pfadoperation* verarbeitet wird. Und auch mit jeder **Response**, bevor sie zur√ºckgegeben wird.

* Sie nimmt jeden **Request** entgegen, der an Ihre Anwendung gesendet wird.
* Sie kann dann etwas mit diesem **Request** tun oder beliebigen Code ausf√ºhren.
* Dann gibt sie den **Request** zur Verarbeitung durch den Rest der Anwendung weiter (durch eine bestimmte *Pfadoperation*).
* Sie nimmt dann die **Response** entgegen, die von der Anwendung generiert wurde (durch eine bestimmte *Pfadoperation*).
* Sie kann etwas mit dieser **Response** tun oder beliebigen Code ausf√ºhren.
* Dann gibt sie die **Response** zur√ºck.

/// note | Technische Details

Wenn Sie Abh√§ngigkeiten mit `yield` haben, wird der Exit-Code *nach* der Middleware ausgef√ºhrt.

Wenn es Hintergrundaufgaben gab (sp√§ter dokumentiert), werden sie *nach* allen Middlewares ausgef√ºhrt.

///

## Erstellung einer Middleware

Um eine Middleware zu erstellen, verwenden Sie den Dekorator `@app.middleware("http")` √ºber einer Funktion.

Die Middleware-Funktion erh√§lt:

* Den `request`.
* Eine Funktion `call_next`, die den `request` als Parameter erh√§lt.
    * Diese Funktion gibt den `request` an die entsprechende *Pfadoperation* weiter.
    * Dann gibt es die von der entsprechenden *Pfadoperation* generierte `response` zur√ºck.
* Sie k√∂nnen die `response` dann weiter modifizieren, bevor Sie sie zur√ºckgeben.

{* ../../docs_src/middleware/tutorial001.py hl[8:9,11,14] *}

/// tip | Tipp

Beachten Sie, dass benutzerdefinierte propriet√§re Header hinzugef√ºgt werden k√∂nnen. <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers" class="external-link" target="_blank">Verwenden Sie daf√ºr das Pr√§fix 'X-'</a>.

Wenn Sie jedoch benutzerdefinierte Header haben, die ein Client in einem Browser sehen soll, m√ºssen Sie sie zu Ihrer CORS-Konfigurationen ([CORS (Cross-Origin Resource Sharing)](cors.md){.internal-link target=_blank}) hinzuf√ºgen, indem Sie den Parameter `expose_headers` verwenden, der in der <a href="https://www.starlette.io/middleware/#corsmiddleware" class="external-link" target="_blank">Starlette-CORS-Dokumentation</a> dokumentiert ist.

///

/// note | Technische Details

Sie k√∂nnten auch `from starlette.requests import Request` verwenden.

**FastAPI** bietet es als Komfort f√ºr Sie, den Entwickler, an. Aber es stammt direkt von Starlette.

///

### Vor und nach der `response`

Sie k√∂nnen Code hinzuf√ºgen, der mit dem `request` ausgef√ºhrt wird, bevor dieser von einer beliebigen *Pfadoperation* empfangen wird.

Und auch nachdem die `response` generiert wurde, bevor sie zur√ºckgegeben wird.

Sie k√∂nnten beispielsweise einen benutzerdefinierten Header `X-Process-Time` hinzuf√ºgen, der die Zeit in Sekunden enth√§lt, die ben√∂tigt wurde, um den Request zu verarbeiten und eine Response zu generieren:

{* ../../docs_src/middleware/tutorial001.py hl[10,12:13] *}

## Andere Middlewares

Sie k√∂nnen sp√§ter mehr √ºber andere Middlewares in [Handbuch f√ºr fortgeschrittene Benutzer: Fortgeschrittene Middleware](../advanced/middleware.md){.internal-link target=_blank} lesen.

In der n√§chsten Sektion erfahren Sie, wie Sie <abbr title="Cross-Origin Resource Sharing">CORS</abbr> mit einer Middleware behandeln k√∂nnen.


================================================
File: /docs/de/docs/tutorial/path-operation-configuration.md
================================================
# Pfadoperation-Konfiguration

Es gibt mehrere Konfigurations-Parameter, die Sie Ihrem *Pfadoperation-Dekorator* √ºbergeben k√∂nnen.

/// warning | Achtung

Beachten Sie, dass diese Parameter direkt dem *Pfadoperation-Dekorator* √ºbergeben werden, nicht der *Pfadoperation-Funktion*.

///

## Response-Statuscode

Sie k√∂nnen den (HTTP-)`status_code` definieren, den die Response Ihrer *Pfadoperation* verwenden soll.

Sie k√∂nnen direkt den `int`-Code √ºbergeben, etwa `404`.

Aber falls Sie sich nicht mehr erinnern, wof√ºr jede Nummer steht, k√∂nnen Sie die Abk√ºrzungs-Konstanten in `status` verwenden:

{* ../../docs_src/path_operation_configuration/tutorial001_py310.py hl[1,15] *}

Dieser Statuscode wird in der Response verwendet und zum OpenAPI-Schema hinzugef√ºgt.

/// note | Technische Details

Sie k√∂nnen auch `from starlette import status` verwenden.

**FastAPI** bietet dieselben `starlette.status`-Codes auch via `fastapi.status` an, als Annehmlichkeit f√ºr Sie, den Entwickler. Sie kommen aber direkt von Starlette.

///

## Tags

Sie k√∂nnen Ihrer *Pfadoperation* Tags hinzuf√ºgen, mittels des Parameters `tags`, dem eine `list`e von `str`s √ºbergeben wird (in der Regel nur ein `str`):

{* ../../docs_src/path_operation_configuration/tutorial002_py310.py hl[15,20,25] *}

Diese werden zum OpenAPI-Schema hinzugef√ºgt und von den automatischen Dokumentations-Benutzeroberfl√§chen verwendet:

<img src="/img/tutorial/path-operation-configuration/image01.png">

### Tags mittels Enumeration

Wenn Sie eine gro√üe Anwendung haben, k√∂nnen sich am Ende **viele Tags** anh√§ufen, und Sie m√∂chten sicherstellen, dass Sie f√ºr verwandte *Pfadoperationen* immer den **gleichen Tag** nehmen.

In diesem Fall macht es Sinn, die Tags in einem `Enum` zu speichern.

**FastAPI** unterst√ºtzt diese genauso wie einfache Strings:

{* ../../docs_src/path_operation_configuration/tutorial002b.py hl[1,8:10,13,18] *}

## Zusammenfassung und Beschreibung

Sie k√∂nnen eine Zusammenfassung (`summary`) und eine Beschreibung (`description`) hinzuf√ºgen:

{* ../../docs_src/path_operation_configuration/tutorial003_py310.py hl[18:19] *}

## Beschreibung mittels Docstring

Da Beschreibungen oft mehrere Zeilen lang sind, k√∂nnen Sie die Beschreibung der *Pfadoperation* im <abbr title="Ein mehrzeiliger String (keiner Variable zugewiesen) als erster Ausdruck in einer Funktion, wird f√ºr die Dokumentation derselben verwendet">Docstring</abbr> der Funktion deklarieren, und **FastAPI** wird sie daraus auslesen.

Sie k√∂nnen im Docstring <a href="https://en.wikipedia.org/wiki/Markdown" class="external-link" target="_blank">Markdown</a> schreiben, es wird korrekt interpretiert und angezeigt (die Einr√ºckung des Docstring beachtend).

{* ../../docs_src/path_operation_configuration/tutorial004_py310.py hl[17:25] *}

In der interaktiven Dokumentation sieht das dann so aus:

<img src="/img/tutorial/path-operation-configuration/image02.png">

## Beschreibung der Response

Die Response k√∂nnen Sie mit dem Parameter `response_description` beschreiben:

{* ../../docs_src/path_operation_configuration/tutorial005_py310.py hl[19] *}

/// info

beachten Sie, dass sich `response_description` speziell auf die Response bezieht, w√§hrend `description` sich generell auf die *Pfadoperation* bezieht.

///

/// check

OpenAPI verlangt, dass jede *Pfadoperation* √ºber eine Beschreibung der Response verf√ºgt.

Daher, wenn Sie keine vergeben, wird **FastAPI** automatisch eine f√ºr ‚ÄûErfolgreiche Response‚Äú erstellen.

///

<img src="/img/tutorial/path-operation-configuration/image03.png">

## Eine *Pfadoperation* deprecaten

Wenn Sie eine *Pfadoperation* als <abbr title="deprecated ‚Äì obsolet, veraltet: Es soll nicht mehr verwendet werden">deprecated</abbr> kennzeichnen m√∂chten, ohne sie zu entfernen, f√ºgen Sie den Parameter `deprecated` hinzu:

{* ../../docs_src/path_operation_configuration/tutorial006.py hl[16] *}

Sie wird in der interaktiven Dokumentation gut sichtbar als deprecated markiert werden:

<img src="/img/tutorial/path-operation-configuration/image04.png">

Vergleichen Sie, wie deprecatete und nicht-deprecatete *Pfadoperationen* aussehen:

<img src="/img/tutorial/path-operation-configuration/image05.png">

## Zusammenfassung

Sie k√∂nnen auf einfache Weise Metadaten f√ºr Ihre *Pfadoperationen* definieren, indem Sie den *Pfadoperation-Dekoratoren* Parameter hinzuf√ºgen.


================================================
File: /docs/de/docs/tutorial/path-params-numeric-validations.md
================================================
# Pfad-Parameter und Validierung von Zahlen

So wie Sie mit `Query` f√ºr Query-Parameter zus√§tzliche Validierungen und Metadaten hinzuf√ºgen k√∂nnen, k√∂nnen Sie das mittels `Path` auch f√ºr Pfad-Parameter tun.

## `Path` importieren

Importieren Sie zuerst `Path` von `fastapi`, und importieren Sie `Annotated`.

{* ../../docs_src/path_params_numeric_validations/tutorial001_an_py310.py hl[1,3] *}

/// info

FastAPI unterst√ºtzt (und empfiehlt die Verwendung von) `Annotated` seit Version 0.95.0.

Wenn Sie eine √§ltere Version haben, werden Sie Fehler angezeigt bekommen, wenn Sie versuchen, `Annotated` zu verwenden.

Bitte [aktualisieren Sie FastAPI](../deployment/versions.md#upgrade-der-fastapi-versionen){.internal-link target=_blank} daher mindestens zu Version 0.95.1, bevor Sie `Annotated` verwenden.

///

## Metadaten deklarieren

Sie k√∂nnen die gleichen Parameter deklarieren wie f√ºr `Query`.

Um zum Beispiel einen `title`-Metadaten-Wert f√ºr den Pfad-Parameter `item_id` zu deklarieren, schreiben Sie:

{* ../../docs_src/path_params_numeric_validations/tutorial001_an_py310.py hl[10] *}

/// note | Hinweis

Ein Pfad-Parameter ist immer erforderlich, weil er Teil des Pfads sein muss.

Sie sollten ihn daher mit `...` deklarieren, um ihn als erforderlich auszuzeichnen.

Doch selbst wenn Sie ihn mit `None` deklarieren, oder einen Defaultwert setzen, bewirkt das nichts, er bleibt immer erforderlich.

///

## Sortieren Sie die Parameter, wie Sie m√∂chten

/// tip | Tipp

Wenn Sie `Annotated` verwenden, ist das folgende nicht so wichtig / nicht notwendig.

///

Nehmen wir an, Sie m√∂chten den Query-Parameter `q` als erforderlichen `str` deklarieren.

Und Sie m√ºssen sonst nichts anderes f√ºr den Parameter deklarieren, Sie brauchen also nicht wirklich `Query`.

Aber Sie brauchen `Path` f√ºr den `item_id`-Pfad-Parameter. Und Sie m√∂chten aus irgendeinem Grund nicht `Annotated` verwenden.

Python wird sich beschweren, wenn Sie einen Parameter mit Defaultwert vor einen Parameter ohne Defaultwert setzen.

Aber Sie k√∂nnen die Reihenfolge der Parameter √§ndern, den Query-Parameter ohne Defaultwert zuerst.

F√ºr **FastAPI** ist es nicht wichtig. Es erkennt die Parameter anhand ihres Namens, ihrer Typen, und ihrer Defaultwerte (`Query`, `Path`, usw.). Es k√ºmmert sich nicht um die Reihenfolge.

Sie k√∂nnen Ihre Funktion also so deklarieren:

//// tab | Python 3.8 nicht annotiert

/// tip | Tipp

Bevorzugen Sie die `Annotated`-Version, falls m√∂glich.

///

```Python hl_lines="7"
{!> ../../docs_src/path_params_numeric_validations/tutorial002.py!}
```

////

Aber bedenken Sie, dass Sie dieses Problem nicht haben, wenn Sie `Annotated` verwenden, da Sie nicht die Funktions-Parameter-Defaultwerte f√ºr `Query()` oder `Path()` verwenden.

{* ../../docs_src/path_params_numeric_validations/tutorial002_an_py39.py hl[10] *}

## Sortieren Sie die Parameter wie Sie m√∂chten: Tricks

/// tip | Tipp

Wenn Sie `Annotated` verwenden, ist das folgende nicht so wichtig / nicht notwendig.

///

Hier ein **kleiner Trick**, der n√ºtzlich sein kann, aber Sie werden ihn nicht oft brauchen.

Wenn Sie eines der folgenden Dinge tun m√∂chten:

* den `q`-Parameter ohne `Query` oder irgendeinem Defaultwert deklarieren
* den Pfad-Parameter `item_id` mittels `Path` deklarieren
* die Parameter in einer unterschiedlichen Reihenfolge haben
* `Annotated` nicht verwenden

... dann hat Python eine kleine Spezial-Syntax f√ºr Sie.

√úbergeben Sie der Funktion `*` als ersten Parameter.

Python macht nichts mit diesem `*`, aber es wird wissen, dass alle folgenden Parameter als <abbr title="Keyword-Argument ‚Äì Schl√ºsselwort-Argument: Das Argument wird anhand seines Namens erkannt, nicht anhand seiner Reihenfolge in der Argumentliste">Keyword-Argumente</abbr> (Schl√ºssel-Wert-Paare), auch bekannt als <abbr title="Von: K-ey W-ord Arg-uments"><code>kwargs</code></abbr>, verwendet werden. Selbst wenn diese keinen Defaultwert haben.

{* ../../docs_src/path_params_numeric_validations/tutorial003.py hl[7] *}

### Besser mit `Annotated`

Bedenken Sie, dass Sie, wenn Sie `Annotated` verwenden, dieses Problem nicht haben, weil Sie keine Defaultwerte f√ºr Ihre Funktionsparameter haben. Sie m√ºssen daher wahrscheinlich auch nicht `*` verwenden.

{* ../../docs_src/path_params_numeric_validations/tutorial003_an_py39.py hl[10] *}

## Validierung von Zahlen: Gr√∂√üer oder gleich

Mit `Query` und `Path` (und anderen, die Sie sp√§ter kennenlernen), k√∂nnen Sie Zahlenbeschr√§nkungen deklarieren.

Hier, mit `ge=1`, wird festgelegt, dass `item_id` eine Ganzzahl ben√∂tigt, die gr√∂√üer oder gleich `1` ist (`g`reater than or `e`qual).
{* ../../docs_src/path_params_numeric_validations/tutorial004_an_py39.py hl[10] *}

## Validierung von Zahlen: Gr√∂√üer und kleiner oder gleich

Das Gleiche trifft zu auf:

* `gt`: `g`reater `t`han ‚Äì gr√∂√üer als
* `le`: `l`ess than or `e`qual ‚Äì kleiner oder gleich

{* ../../docs_src/path_params_numeric_validations/tutorial005_an_py39.py hl[10] *}

## Validierung von Zahlen: Floats, gr√∂√üer und kleiner

Zahlenvalidierung funktioniert auch f√ºr <abbr title="Kommazahl">`float`</abbr>-Werte.

Hier wird es wichtig, in der Lage zu sein, <abbr title="greater than ‚Äì gr√∂√üer als"><code>gt</code></abbr> zu deklarieren, und nicht nur <abbr title="greater than or equal ‚Äì gr√∂√üer oder gleich"><code>ge</code></abbr>, da Sie hiermit bestimmen k√∂nnen, dass ein Wert, zum Beispiel, gr√∂√üer als `0` sein muss, obwohl er kleiner als `1` ist.

`0.5` w√§re also ein g√ºltiger Wert, aber nicht `0.0` oder `0`.

Das gleiche gilt f√ºr <abbr title="less than ‚Äì kleiner als"><code>lt</code></abbr>.

{* ../../docs_src/path_params_numeric_validations/tutorial006_an_py39.py hl[13] *}

## Zusammenfassung

Mit `Query` und `Path` (und anderen, die Sie noch nicht gesehen haben) k√∂nnen Sie Metadaten und Stringvalidierungen deklarieren, so wie in [Query-Parameter und Stringvalidierungen](query-params-str-validations.md){.internal-link target=_blank} beschrieben.

Und Sie k√∂nnen auch Validierungen f√ºr Zahlen deklarieren:

* `gt`: `g`reater `t`han ‚Äì gr√∂√üer als
* `ge`: `g`reater than or `e`qual ‚Äì gr√∂√üer oder gleich
* `lt`: `l`ess `t`han ‚Äì kleiner als
* `le`: `l`ess than or `e`qual ‚Äì kleiner oder gleich

/// info

`Query`, `Path`, und andere Klassen, die Sie sp√§ter kennenlernen, sind Unterklassen einer allgemeinen `Param`-Klasse.

Sie alle teilen die gleichen Parameter f√ºr zus√§tzliche Validierung und Metadaten, die Sie gesehen haben.

///

/// note | Technische Details

`Query`, `Path` und andere, die Sie von `fastapi` importieren, sind tats√§chlich Funktionen.

Die, wenn sie aufgerufen werden, Instanzen der Klassen mit demselben Namen zur√ºckgeben.

Sie importieren also `Query`, welches eine Funktion ist. Aber wenn Sie es aufrufen, gibt es eine Instanz der Klasse zur√ºck, die auch `Query` genannt wird.

Diese Funktionen existieren (statt die Klassen direkt zu verwenden), damit Ihr Editor keine Fehlermeldungen √ºber ihre Typen ausgibt.

Auf diese Weise k√∂nnen Sie Ihren Editor und Ihre Programmier-Tools verwenden, ohne besondere Einstellungen vornehmen zu m√ºssen, um diese Fehlermeldungen stummzuschalten.

///


================================================
File: /docs/de/docs/tutorial/path-params.md
================================================
# Pfad-Parameter

Sie k√∂nnen Pfad-‚ÄûParameter‚Äú oder -‚ÄûVariablen‚Äú mit der gleichen Syntax deklarieren, welche in Python-<abbr title="Format-String ‚Äì Formatierter String: Der String enth√§lt Variablen, die mit geschweiften Klammern umschlossen sind. Solche Stellen werden durch den Wert der Variable ersetzt">Format-Strings</abbr> verwendet wird:

{* ../../docs_src/path_params/tutorial001.py hl[6:7] *}

Der Wert des Pfad-Parameters `item_id` wird Ihrer Funktion als das Argument `item_id` √ºbergeben.

Wenn Sie dieses Beispiel ausf√ºhren und auf <a href="http://127.0.0.1:8000/items/foo" class="external-link" target="_blank">http://127.0.0.1:8000/items/foo</a> gehen, sehen Sie als Response:

```JSON
{"item_id":"foo"}
```

## Pfad-Parameter mit Typen

Sie k√∂nnen den Typ eines Pfad-Parameters in der Argumentliste der Funktion deklarieren, mit Standard-Python-Typannotationen:

{* ../../docs_src/path_params/tutorial002.py hl[7] *}

In diesem Fall wird `item_id` als `int` deklariert, also als Ganzzahl.

/// check

Dadurch erhalten Sie Editor-Unterst√ºtzung innerhalb Ihrer Funktion, mit Fehlerpr√ºfungen, Codevervollst√§ndigung, usw.

///

## Daten-<abbr title="Auch bekannt als: Serialisierung, Parsen, Marshalling">Konversion</abbr>

Wenn Sie dieses Beispiel ausf√ºhren und Ihren Browser unter <a href="http://127.0.0.1:8000/items/3" class="external-link" target="_blank">http://127.0.0.1:8000/items/3</a> √∂ffnen, sehen Sie als Response:

```JSON
{"item_id":3}
```

/// check

Beachten Sie, dass der Wert, den Ihre Funktion erh√§lt und zur√ºckgibt, die Zahl `3` ist, also ein `int`. Nicht der String `"3"`, also ein `str`.

Sprich, mit dieser Typdeklaration wird **FastAPI** die Anfrage automatisch <abbr title="Den String, der von einer HTTP Anfrage kommt, in Python-Objekte konvertieren">‚Äûparsen‚Äú</abbr>.

///

## Datenvalidierung

Wenn Sie aber im Browser <a href="http://127.0.0.1:8000/items/foo" class="external-link" target="_blank">http://127.0.0.1:8000/items/foo</a> besuchen, erhalten Sie eine h√ºbsche HTTP-Fehlermeldung:

```JSON
{
  "detail": [
    {
      "type": "int_parsing",
      "loc": [
        "path",
        "item_id"
      ],
      "msg": "Input should be a valid integer, unable to parse string as an integer",
      "input": "foo",
      "url": "https://errors.pydantic.dev/2.1/v/int_parsing"
    }
  ]
}
```

Der Pfad-Parameter `item_id` hatte den Wert `"foo"`, was kein `int` ist.

Die gleiche Fehlermeldung w√ºrde angezeigt werden, wenn Sie ein `float` (also eine Kommazahl) statt eines `int`s √ºbergeben w√ºrden, wie etwa in: <a href="http://127.0.0.1:8000/items/4.2" class="external-link" target="_blank">http://127.0.0.1:8000/items/4.2</a>

/// check

Sprich, mit der gleichen Python-Typdeklaration gibt Ihnen **FastAPI** Datenvalidierung.

Beachten Sie, dass die Fehlermeldung auch direkt die Stelle anzeigt, wo die Validierung nicht erfolgreich war.

Das ist unglaublich hilfreich, wenn Sie Code entwickeln und debuggen, welcher mit ihrer API interagiert.

///

## Dokumentation

Wenn Sie die Seite <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a> in Ihrem Browser √∂ffnen, sehen Sie eine automatische, interaktive API-Dokumentation:

<img src="/img/tutorial/path-params/image01.png">

/// check

Wiederum, mit dieser gleichen Python-Typdeklaration gibt Ihnen **FastAPI** eine automatische, interaktive Dokumentation (verwendet die Swagger-Benutzeroberfl√§che).

Beachten Sie, dass der Pfad-Parameter dort als Ganzzahl deklariert ist.

///

## N√ºtzliche Standards. Alternative Dokumentation

Und weil das generierte Schema vom <a href="https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.1.0.md" class="external-link" target="_blank">OpenAPI</a>-Standard kommt, gibt es viele kompatible Tools.

Zum Beispiel bietet **FastAPI** selbst eine alternative API-Dokumentation (verwendet ReDoc), welche Sie unter <a href="http://127.0.0.1:8000/redoc" class="external-link" target="_blank">http://127.0.0.1:8000/redoc</a> einsehen k√∂nnen:

<img src="/img/tutorial/path-params/image02.png">

Und viele weitere kompatible Tools. Inklusive Codegenerierung f√ºr viele Sprachen.

## Pydantic

Die ganze Datenvalidierung wird hinter den Kulissen von <a href="https://pydantic-docs.helpmanual.io/" class="external-link" target="_blank">Pydantic</a> durchgef√ºhrt, Sie profitieren also von dessen Vorteilen. Und Sie wissen, dass Sie in guten H√§nden sind.

Sie k√∂nnen f√ºr Typ Deklarationen auch `str`, `float`, `bool` und viele andere komplexe Datentypen verwenden.

Mehrere davon werden wir in den n√§chsten Kapiteln erkunden.

## Die Reihenfolge ist wichtig

Wenn Sie *Pfadoperationen* erstellen, haben Sie manchmal einen fixen Pfad.

Etwa `/users/me`, um Daten √ºber den aktuellen Benutzer zu erhalten.

Und Sie haben auch einen Pfad `/users/{user_id}`, um Daten √ºber einen spezifischen Benutzer zu erhalten, mittels einer Benutzer-ID.

Weil *Pfadoperationen* in ihrer Reihenfolge ausgewertet werden, m√ºssen Sie sicherstellen, dass der Pfad `/users/me` vor `/users/{user_id}` deklariert wurde:

{* ../../docs_src/path_params/tutorial003.py hl[6,11] *}

Ansonsten w√ºrde der Pfad f√ºr `/users/{user_id}` auch `/users/me` auswerten, und annehmen, dass ein Parameter `user_id` mit dem Wert `"me"` √ºbergeben wurde.

Sie k√∂nnen eine Pfadoperation auch nicht erneut definieren:

{* ../../docs_src/path_params/tutorial003b.py hl[6,11] *}

Die erste Definition wird immer verwendet werden, da ihr Pfad zuerst √ºbereinstimmt.

## Vordefinierte Parameterwerte

Wenn Sie eine *Pfadoperation* haben, welche einen *Pfad-Parameter* hat, aber Sie wollen, dass dessen g√ºltige Werte vordefiniert sind, k√∂nnen Sie ein Standard-Python <abbr title="Enumeration, oder kurz Enum ‚Äì Aufz√§hlung">`Enum`</abbr> verwenden.

### Erstellen Sie eine `Enum`-Klasse

Importieren Sie `Enum` und erstellen Sie eine Unterklasse, die von `str` und `Enum` erbt.

Indem Sie von `str` erben, wei√ü die API Dokumentation, dass die Werte des Enums vom Typ `str` sein m√ºssen, und wird in der Lage sein, korrekt zu rendern.

Erstellen Sie dann Klassen-Attribute mit festgelegten Werten, welches die erlaubten Werte sein werden:

{* ../../docs_src/path_params/tutorial005.py hl[1,6:9] *}

/// info

<a href="https://docs.python.org/3/library/enum.html" class="external-link" target="_blank">Enumerationen (oder kurz Enums)</a> gibt es in Python seit Version 3.4.

///

/// tip | Tipp

Falls Sie sich fragen, was ‚ÄûAlexNet‚Äú, ‚ÄûResNet‚Äú und ‚ÄûLeNet‚Äú ist, das sind Namen von <abbr title="Genau genommen, Deep-Learning-Modellarchitekturen">Modellen</abbr> f√ºr maschinelles Lernen.

///

### Deklarieren Sie einen *Pfad-Parameter*

Dann erstellen Sie einen *Pfad-Parameter*, der als Typ die gerade erstellte Enum-Klasse hat (`ModelName`):

{* ../../docs_src/path_params/tutorial005.py hl[16] *}

### Testen Sie es in der API-Dokumentation

Weil die erlaubten Werte f√ºr den *Pfad-Parameter* nun vordefiniert sind, kann die interaktive Dokumentation sie als Auswahl-Drop-Down anzeigen:

<img src="/img/tutorial/path-params/image03.png">

### Mit Python-*<abbr title="Enumeration ‚Äì Aufz√§hlung">Enums</abbr>* arbeiten

Der *Pfad-Parameter* wird ein *<abbr title="Member ‚Äì Mitglied: Einer der m√∂glichen Werte einer Enumeration">Member</abbr> eines Enums* sein.

#### *Enum-Member* vergleichen

Sie k√∂nnen ihn mit einem Member Ihres Enums `ModelName` vergleichen:

{* ../../docs_src/path_params/tutorial005.py hl[17] *}

#### *Enum-Wert* erhalten

Den tats√§chlichen Wert (in diesem Fall ein `str`) erhalten Sie via `model_name.value`, oder generell, `ihr_enum_member.value`:

{* ../../docs_src/path_params/tutorial005.py hl[20] *}

/// tip | Tipp

Sie k√∂nnen den Wert `"lenet"` au√üerdem mittels `ModelName.lenet.value` abrufen.

///

#### *Enum-Member* zur√ºckgeben

Sie k√∂nnen *Enum-Member* in ihrer *Pfadoperation* zur√ºckgeben, sogar verschachtelt in einem JSON-Body (z. B. als `dict`).

Diese werden zu ihren entsprechenden Werten konvertiert (in diesem Fall Strings), bevor sie zum Client √ºbertragen werden:

{* ../../docs_src/path_params/tutorial005.py hl[18,21,23] *}

In Ihrem Client erhalten Sie eine JSON-Response, wie etwa:

```JSON
{
  "model_name": "alexnet",
  "message": "Deep Learning FTW!"
}
```

## Pfad Parameter die Pfade enthalten

Angenommen, Sie haben eine *Pfadoperation* mit einem Pfad `/files/{file_path}`.

Aber `file_path` soll selbst einen *Pfad* enthalten, etwa `home/johndoe/myfile.txt`.

Sprich, die URL f√ºr diese Datei w√§re etwas wie: `/files/home/johndoe/myfile.txt`.

### OpenAPI Unterst√ºtzung

OpenAPI bietet nicht die M√∂glichkeit, dass ein *Pfad-Parameter* seinerseits einen *Pfad* enthalten kann, das w√ºrde zu Szenarios f√ºhren, die schwierig zu testen und zu definieren sind.

Trotzdem k√∂nnen Sie das in **FastAPI** tun, indem Sie eines der internen Tools von Starlette verwenden.

Die Dokumentation w√ºrde weiterhin funktionieren, allerdings wird nicht dokumentiert werden, dass der Parameter ein Pfad sein sollte.

### Pfad Konverter

Mittels einer Option direkt von Starlette k√∂nnen Sie einen *Pfad-Parameter* deklarieren, der einen Pfad enthalten soll, indem Sie eine URL wie folgt definieren:

```
/files/{file_path:path}
```

In diesem Fall ist der Name des Parameters `file_path`. Der letzte Teil, `:path`, sagt aus, dass der Parameter ein *Pfad* sein soll.

Sie verwenden das also wie folgt:

{* ../../docs_src/path_params/tutorial004.py hl[6] *}

/// tip | Tipp

Der Parameter k√∂nnte einen f√ºhrenden Schr√§gstrich (`/`) haben, wie etwa in `/home/johndoe/myfile.txt`.

In dem Fall w√§re die URL: `/files//home/johndoe/myfile.txt`, mit einem doppelten Schr√§gstrich (`//`) zwischen `files` und `home`.

///

## Zusammenfassung

In **FastAPI** erhalten Sie mittels kurzer, intuitiver Typdeklarationen:

* Editor-Unterst√ºtzung: Fehlerpr√ºfungen, Codevervollst√§ndigung, usw.
* Daten "<abbr title="Den String, der von einer HTTP Anfrage kommt, nach Python-Daten konvertieren">parsen</abbr>"
* Datenvalidierung
* API-Annotationen und automatische Dokumentation

Und Sie m√ºssen sie nur einmal deklarieren.

Das ist wahrscheinlich der sichtbarste Unterschied zwischen **FastAPI** und alternativen Frameworks (abgesehen von der reinen Performanz).


================================================
File: /docs/de/docs/tutorial/query-params-str-validations.md
================================================
# Query-Parameter und Stringvalidierung

**FastAPI** erlaubt es Ihnen, Ihre Parameter zus√§tzlich zu validieren, und zus√§tzliche Informationen hinzuzuf√ºgen.

Nehmen wir als Beispiel die folgende Anwendung:

{* ../../docs_src/query_params_str_validations/tutorial001_py310.py hl[7] *}

Der Query-Parameter `q` hat den Typ `Union[str, None]` (oder `str | None` in Python 3.10), was bedeutet, er ist entweder ein `str` oder `None`. Der Defaultwert ist `None`, also wei√ü FastAPI, der Parameter ist nicht erforderlich.

/// note | Hinweis

FastAPI wei√ü nur dank des definierten Defaultwertes `=None`, dass der Wert von `q` nicht erforderlich ist

`Union[str, None]` hingegen erlaubt ihren Editor, Sie besser zu unterst√ºtzen und Fehler zu erkennen.

///

## Zus√§tzliche Validierung

Wir werden bewirken, dass, obwohl `q` optional ist, wenn es gegeben ist, **seine L√§nge 50 Zeichen nicht √ºberschreitet**.

### `Query` und `Annotated` importieren

Importieren Sie zuerst:

* `Query` von `fastapi`
* `Annotated` von `typing` (oder von `typing_extensions` in Python unter 3.9)

//// tab | Python 3.10+

In Python 3.9 oder dar√ºber, ist `Annotated` Teil der Standardbibliothek, also k√∂nnen Sie es von `typing` importieren.

```Python hl_lines="1  3"
{!> ../../docs_src/query_params_str_validations/tutorial002_an_py310.py!}
```

////

//// tab | Python 3.8+

In Versionen unter Python 3.9 importieren Sie `Annotated` von `typing_extensions`.

Es wird bereits mit FastAPI installiert sein.

```Python hl_lines="3-4"
{!> ../../docs_src/query_params_str_validations/tutorial002_an.py!}
```

////

/// info

FastAPI unterst√ºtzt (und empfiehlt die Verwendung von) `Annotated` seit Version 0.95.0.

Wenn Sie eine √§ltere Version haben, werden Sie Fehler angezeigt bekommen, wenn Sie versuchen, `Annotated` zu verwenden.

Bitte [aktualisieren Sie FastAPI](../deployment/versions.md#upgrade-der-fastapi-versionen){.internal-link target=_blank} daher mindestens zu Version 0.95.1, bevor Sie `Annotated` verwenden.

///

## `Annotated` im Typ des `q`-Parameters verwenden

Erinnern Sie sich, wie ich in [Einf√ºhrung in Python-Typen](../python-types.md#typhinweise-mit-metadaten-annotationen){.internal-link target=_blank} sagte, dass Sie mittels `Annotated` Metadaten zu Ihren Parametern hinzuf√ºgen k√∂nnen?

Jetzt ist es an der Zeit, das mit FastAPI auszuprobieren. üöÄ

Wir hatten diese Typannotation:

//// tab | Python 3.10+

```Python
q: str | None = None
```

////

//// tab | Python 3.8+

```Python
q: Union[str, None] = None
```

////

Wir wrappen das nun in `Annotated`, sodass daraus wird:

//// tab | Python 3.10+

```Python
q: Annotated[str | None] = None
```

////

//// tab | Python 3.8+

```Python
q: Annotated[Union[str, None]] = None
```

////

Beide Versionen bedeuten dasselbe: `q` ist ein Parameter, der `str` oder `None` sein kann. Standardm√§√üig ist er `None`.

Wenden wir uns jetzt den spannenden Dingen zu. üéâ

## `Query` zu `Annotated` im `q`-Parameter hinzuf√ºgen

Jetzt, da wir `Annotated` f√ºr unsere Metadaten deklariert haben, f√ºgen Sie `Query` hinzu, und setzen Sie den Parameter `max_length` auf `50`:

{* ../../docs_src/query_params_str_validations/tutorial002_an_py310.py hl[9] *}

Beachten Sie, dass der Defaultwert immer noch `None` ist, sodass der Parameter immer noch optional ist.

Aber jetzt, mit `Query(max_length=50)` innerhalb von `Annotated`, sagen wir FastAPI, dass es diesen Wert aus den Query-Parametern extrahieren soll (das h√§tte es sowieso gemacht ü§∑) und dass wir eine **zus√§tzliche Validierung** f√ºr diesen Wert haben wollen (darum machen wir das, um die zus√§tzliche Validierung zu bekommen). üòé

FastAPI wird nun:

* Die Daten **validieren** und sicherstellen, dass sie nicht l√§nger als 50 Zeichen sind
* Dem Client einen **verst√§ndlichen Fehler** anzeigen, wenn die Daten ung√ºltig sind
* Den Parameter in der OpenAPI-Schema-*Pfadoperation* **dokumentieren** (sodass er in der **automatischen Dokumentation** angezeigt wird)

## Alternativ (alt): `Query` als Defaultwert

Fr√ºhere Versionen von FastAPI (vor <abbr title="vor 2023-03">0.95.0</abbr>) ben√∂tigten `Query` als Defaultwert des Parameters, statt es innerhalb von `Annotated` unterzubringen. Die Chance ist gro√ü, dass Sie Quellcode sehen, der das immer noch so macht, darum erkl√§re ich es Ihnen.

/// tip | Tipp

Verwenden Sie f√ºr neuen Code, und wann immer m√∂glich, `Annotated`, wie oben erkl√§rt. Es gibt mehrere Vorteile (unten erl√§utert) und keine Nachteile. üç∞

///

So w√ºrden Sie `Query()` als Defaultwert Ihres Funktionsparameters verwenden, den Parameter `max_length` auf 50 gesetzt:

{* ../../docs_src/query_params_str_validations/tutorial002_py310.py hl[7] *}

Da wir in diesem Fall (ohne die Verwendung von `Annotated`) den Parameter-Defaultwert `None` mit `Query()` ersetzen, m√ºssen wir nun dessen Defaultwert mit dem Parameter `Query(default=None)` deklarieren. Das dient demselben Zweck, `None` als Defaultwert f√ºr den Funktionsparameter zu setzen (zumindest f√ºr FastAPI).

Sprich:

```Python
q: Union[str, None] = Query(default=None)
```

... macht den Parameter optional, mit dem Defaultwert `None`, genauso wie:

```Python
q: Union[str, None] = None
```

Und in Python 3.10 und dar√ºber macht:

```Python
q: str | None = Query(default=None)
```

... den Parameter optional, mit dem Defaultwert `None`, genauso wie:

```Python
q: str | None = None
```

Nur, dass die `Query`-Versionen den Parameter explizit als Query-Parameter deklarieren.

/// info

Bedenken Sie, dass:

```Python
= None
```

oder:

```Python
= Query(default=None)
```

der wichtigste Teil ist, um einen Parameter optional zu machen, da dieses `None` der Defaultwert ist, und das ist es, was diesen Parameter **nicht erforderlich** macht.

Der Teil mit `Union[str, None]` erlaubt es Ihrem Editor, Sie besser zu unterst√ºtzen, aber er sagt FastAPI nicht, dass dieser Parameter optional ist.

///

Jetzt k√∂nnen wir `Query` weitere Parameter √ºbergeben. Fangen wir mit dem `max_length` Parameter an, der auf Strings angewendet wird:

```Python
q: Union[str, None] = Query(default=None, max_length=50)
```

Das wird die Daten validieren, einen verst√§ndlichen Fehler ausgeben, wenn die Daten nicht g√ºltig sind, und den Parameter in der OpenAPI-Schema-*Pfadoperation* dokumentieren.

### `Query` als Defaultwert oder in `Annotated`

Bedenken Sie, dass wenn Sie `Query` innerhalb von `Annotated` benutzen, Sie den `default`-Parameter f√ºr `Query` nicht verwenden d√ºrfen.

Setzen Sie stattdessen den Defaultwert des Funktionsparameters, sonst w√§re es inkonsistent.

Zum Beispiel ist das nicht erlaubt:

```Python
q: Annotated[str, Query(default="rick")] = "morty"
```

... denn es wird nicht klar, ob der Defaultwert `"rick"` oder `"morty"` sein soll.

Sie w√ºrden also (bevorzugt) schreiben:

```Python
q: Annotated[str, Query()] = "rick"
```

In √§lterem Code werden Sie auch finden:

```Python
q: str = Query(default="rick")
```

### Vorz√ºge von `Annotated`

**Es wird empfohlen, `Annotated` zu verwenden**, statt des Defaultwertes im Funktionsparameter, das ist aus mehreren Gr√ºnden **besser**: ü§ì

Der **Default**wert des **Funktionsparameters** ist der **tats√§chliche Default**wert, das spielt generell intuitiver mit Python zusammen. üòå

Sie k√∂nnen die Funktion ohne FastAPI an **anderen Stellen aufrufen**, und es wird **wie erwartet funktionieren**. Wenn es einen **erforderlichen** Parameter gibt (ohne Defaultwert), und Sie f√ºhren die Funktion ohne den ben√∂tigten Parameter aus, dann wird Ihr **Editor** Sie das mit einem Fehler wissen lassen, und **Python** wird sich auch beschweren.

Wenn Sie aber nicht `Annotated` benutzen und stattdessen die **(alte) Variante mit einem Defaultwert**, dann m√ºssen Sie, wenn Sie die Funktion ohne FastAPI an **anderen Stellen** aufrufen, sich daran **erinnern**, die Argumente der Funktion zu √ºbergeben, damit es richtig funktioniert. Ansonsten erhalten Sie unerwartete Werte (z. B. `QueryInfo` oder etwas √Ñhnliches, statt `str`). Ihr Editor kann ihnen nicht helfen, und Python wird die Funktion ohne Beschwerden ausf√ºhren, es sei denn, die Operationen innerhalb l√∂sen einen Fehler aus.

Da `Annotated` mehrere Metadaten haben kann, k√∂nnen Sie dieselbe Funktion auch mit anderen Tools verwenden, wie etwa <a href="https://typer.tiangolo.com/" class="external-link" target="_blank">Typer</a>. üöÄ

## Mehr Validierungen hinzuf√ºgen

Sie k√∂nnen auch einen Parameter `min_length` hinzuf√ºgen:

{* ../../docs_src/query_params_str_validations/tutorial003_an_py310.py hl[10] *}

## Regul√§re Ausdr√ºcke hinzuf√ºgen

Sie k√∂nnen einen <abbr title="Ein regul√§rer Ausdruck, auch regex oder regexp genannt, ist eine Zeichensequenz, die ein Suchmuster f√ºr Strings definiert.">Regul√§ren Ausdruck</abbr> `pattern` definieren, mit dem der Parameter √ºbereinstimmen muss:

{* ../../docs_src/query_params_str_validations/tutorial004_an_py310.py hl[11] *}

Dieses bestimmte regul√§re Suchmuster pr√ºft, ob der erhaltene Parameter-Wert:

* `^`: mit den nachfolgenden Zeichen startet, keine Zeichen davor hat.
* `fixedquery`: den exakten Text `fixedquery` hat.
* `$`: danach endet, keine weiteren Zeichen hat als `fixedquery`.

Wenn Sie sich verloren f√ºhlen bei all diesen **‚ÄûRegul√§rer Ausdruck‚Äú**-Konzepten, keine Sorge. Regul√§re Ausdr√ºcke sind f√ºr viele Menschen ein schwieriges Thema. Sie k√∂nnen auch ohne regul√§re Ausdr√ºcke eine ganze Menge machen.

Aber wenn Sie sie brauchen und sie lernen, wissen Sie, dass Sie sie bereits direkt in **FastAPI** verwenden k√∂nnen.

### Pydantic v1 `regex` statt `pattern`

Vor Pydantic Version 2 und vor FastAPI Version 0.100.0, war der Name des Parameters `regex` statt `pattern`, aber das ist jetzt <abbr title="deprecated ‚Äì obsolet, veraltet: Es soll nicht mehr verwendet werden">deprecated</abbr>.

Sie k√∂nnten immer noch Code sehen, der den alten Namen verwendet:

//// tab | Pydantic v1

{* ../../docs_src/query_params_str_validations/tutorial004_regex_an_py310.py hl[11] *}

////

Beachten Sie aber, dass das deprecated ist, und zum neuen Namen `pattern` ge√§ndert werden sollte. ü§ì

## Defaultwerte

Sie k√∂nnen nat√ºrlich andere Defaultwerte als `None` verwenden.

Beispielsweise k√∂nnten Sie den `q` Query-Parameter so deklarieren, dass er eine `min_length` von `3` hat, und den Defaultwert `"fixedquery"`:

{* ../../docs_src/query_params_str_validations/tutorial005_an_py39.py hl[9] *}

/// note | Hinweis

Ein Parameter ist optional (nicht erforderlich), wenn er irgendeinen Defaultwert, auch `None`, hat.

///

## Erforderliche Parameter

Wenn wir keine Validierungen oder Metadaten haben, k√∂nnen wir den `q` Query-Parameter erforderlich machen, indem wir einfach keinen Defaultwert deklarieren, wie in:

```Python
q: str
```

statt:

```Python
q: Union[str, None] = None
```

Aber jetzt deklarieren wir den Parameter mit `Query`, wie in:

//// tab | Annotiert

```Python
q: Annotated[Union[str, None], Query(min_length=3)] = None
```

////

//// tab | Nicht annotiert

```Python
q: Union[str, None] = Query(default=None, min_length=3)
```

////

Wenn Sie einen Parameter erforderlich machen wollen, w√§hrend Sie `Query` verwenden, deklarieren Sie ebenfalls einfach keinen Defaultwert:

{* ../../docs_src/query_params_str_validations/tutorial006_an_py39.py hl[9] *}

### Erforderlich mit Ellipse (`...`)

Es gibt eine Alternative, die explizit deklariert, dass ein Wert erforderlich ist. Sie k√∂nnen als Default das <abbr title='Zeichenfolge, die einen Wert direkt darstellt, etwa 1, "hallowelt", True, None'>Literal</abbr> `...` setzen:

{* ../../docs_src/query_params_str_validations/tutorial006b_an_py39.py hl[9] *}

/// info

Falls Sie das `...` bisher noch nicht gesehen haben: Es ist ein spezieller einzelner Wert, <a href="https://docs.python.org/3/library/constants.html#Ellipsis" class="external-link" target="_blank">Teil von Python und wird ‚ÄûEllipsis‚Äú genannt</a> (Deutsch: Ellipse).

Es wird von Pydantic und FastAPI verwendet, um explizit zu deklarieren, dass ein Wert erforderlich ist.

///

Dies wird **FastAPI** wissen lassen, dass dieser Parameter erforderlich ist.

### Erforderlich, kann `None` sein

Sie k√∂nnen deklarieren, dass ein Parameter `None` akzeptiert, aber dennoch erforderlich ist. Das zwingt Clients, den Wert zu senden, selbst wenn er `None` ist.

Um das zu machen, deklarieren Sie, dass `None` ein g√ºltiger Typ ist, aber verwenden Sie dennoch `...` als Default:

{* ../../docs_src/query_params_str_validations/tutorial006c_an_py310.py hl[9] *}

/// tip | Tipp

Pydantic, welches die gesamte Datenvalidierung und Serialisierung in FastAPI antreibt, hat ein spezielles Verhalten, wenn Sie `Optional` oder `Union[Something, None]` ohne Defaultwert verwenden, Sie k√∂nnen mehr dar√ºber in der Pydantic-Dokumentation unter <a href="https://docs.pydantic.dev/2.3/usage/models/#required-fields" class="external-link" target="_blank">Required fields</a> erfahren.

///

/// tip | Tipp

Denken Sie daran, dass Sie in den meisten F√§llen, wenn etwas erforderlich ist, einfach den Defaultwert weglassen k√∂nnen. Sie m√ºssen also normalerweise `...` nicht verwenden.

///

## Query-Parameter-Liste / Mehrere Werte

Wenn Sie einen Query-Parameter explizit mit `Query` auszeichnen, k√∂nnen Sie ihn auch eine Liste von Werten empfangen lassen, oder anders gesagt, mehrere Werte.

Um zum Beispiel einen Query-Parameter `q` zu deklarieren, der mehrere Male in der URL vorkommen kann, schreiben Sie:

{* ../../docs_src/query_params_str_validations/tutorial011_an_py310.py hl[9] *}

Dann, mit einer URL wie:

```
http://localhost:8000/items/?q=foo&q=bar
```

bekommen Sie alle `q`-*Query-Parameter*-Werte (`foo` und `bar`) in einer Python-Liste ‚Äì `list` ‚Äì in ihrer *Pfadoperation-Funktion*, im Funktionsparameter `q`, √ºberreicht.

Die Response f√ºr diese URL w√§re also:

```JSON
{
  "q": [
    "foo",
    "bar"
  ]
}
```

/// tip | Tipp

Um einen Query-Parameter vom Typ `list` zu deklarieren, wie im Beispiel oben, m√ºssen Sie explizit `Query` verwenden, sonst w√ºrde der Parameter als Requestbody interpretiert werden.

///

Die interaktive API-Dokumentation wird entsprechend aktualisiert und erlaubt jetzt mehrere Werte.

<img src="/img/tutorial/query-params-str-validations/image02.png">

### Query-Parameter-Liste / Mehrere Werte mit Defaults

Und Sie k√∂nnen auch eine Default-`list`e von Werten definieren, wenn keine √ºbergeben werden:

{* ../../docs_src/query_params_str_validations/tutorial012_an_py39.py hl[9] *}

Wenn Sie auf:

```
http://localhost:8000/items/
```

gehen, wird der Default f√ºr `q` verwendet: `["foo", "bar"]`, und als Response erhalten Sie:

```JSON
{
  "q": [
    "foo",
    "bar"
  ]
}
```

#### `list` alleine verwenden

Sie k√∂nnen auch `list` direkt verwenden, anstelle von `List[str]` (oder `list[str]` in Python 3.9+):

{* ../../docs_src/query_params_str_validations/tutorial013_an_py39.py hl[9] *}

/// note | Hinweis

Beachten Sie, dass FastAPI in diesem Fall den Inhalt der Liste nicht √ºberpr√ºft.

Zum Beispiel w√ºrde `List[int]` √ºberpr√ºfen (und dokumentieren) dass die Liste Ganzzahlen enth√§lt. `list` alleine macht das nicht.

///

## Deklarieren von mehr Metadaten

Sie k√∂nnen mehr Informationen zum Parameter hinzuf√ºgen.

Diese Informationen werden zur generierten OpenAPI hinzugef√ºgt, und von den Dokumentations-Oberfl√§chen und von externen Tools verwendet.

/// note | Hinweis

Beachten Sie, dass verschiedene Tools OpenAPI m√∂glicherweise unterschiedlich gut unterst√ºtzen.

Einige k√∂nnten noch nicht alle zus√§tzlichen Informationen anzeigen, die Sie deklariert haben, obwohl in den meisten F√§llen geplant ist, das fehlende Feature zu implementieren.

///

Sie k√∂nnen einen Titel hinzuf√ºgen ‚Äì `title`:

{* ../../docs_src/query_params_str_validations/tutorial007_an_py310.py hl[10] *}

Und eine Beschreibung ‚Äì `description`:

{* ../../docs_src/query_params_str_validations/tutorial008_an_py310.py hl[14] *}

## Alias-Parameter

Stellen Sie sich vor, der Parameter soll `item-query` sein.

Wie in:

```
http://127.0.0.1:8000/items/?item-query=foobaritems
```

Aber `item-query` ist kein g√ºltiger Name f√ºr eine Variable in Python.

Am √§hnlichsten w√§re `item_query`.

Aber Sie m√∂chten dennoch exakt `item-query` verwenden.

Dann k√∂nnen Sie einen `alias` deklarieren, und dieser Alias wird verwendet, um den Parameter-Wert zu finden:

{* ../../docs_src/query_params_str_validations/tutorial009_an_py310.py hl[9] *}

## Parameter als deprecated ausweisen

Nehmen wir an, Sie m√∂gen diesen Parameter nicht mehr.

Sie m√ºssen ihn eine Weile dort belassen, weil Clients ihn benutzen, aber Sie m√∂chten, dass die Dokumentation klar anzeigt, dass er <abbr title="deprecated ‚Äì obsolet, veraltet: Es soll nicht mehr verwendet werden">deprecated</abbr> ist.

In diesem Fall f√ºgen Sie den Parameter `deprecated=True` zu `Query` hinzu.

{* ../../docs_src/query_params_str_validations/tutorial010_an_py310.py hl[19] *}

Die Dokumentation wird das so anzeigen:

<img src="/img/tutorial/query-params-str-validations/image01.png">

## Parameter von OpenAPI ausschlie√üen

Um einen Query-Parameter vom generierten OpenAPI-Schema auszuschlie√üen (und daher von automatischen Dokumentations-Systemen), setzen Sie den Parameter `include_in_schema` in `Query` auf `False`.

{* ../../docs_src/query_params_str_validations/tutorial014_an_py310.py hl[10] *}

## Zusammenfassung

Sie k√∂nnen zus√§tzliche Validierungen und Metadaten zu ihren Parametern hinzuf√ºgen.

Allgemeine Validierungen und Metadaten:

* `alias`
* `title`
* `description`
* `deprecated`

Validierungen spezifisch f√ºr Strings:

* `min_length`
* `max_length`
* `pattern`

In diesen Beispielen haben Sie gesehen, wie Sie Validierungen f√ºr Strings hinzuf√ºgen.

In den n√§chsten Kapiteln sehen wir, wie man Validierungen f√ºr andere Typen hinzuf√ºgt, etwa f√ºr Zahlen.


================================================
File: /docs/de/docs/tutorial/query-params.md
================================================
# Query-Parameter

Wenn Sie in ihrer Funktion Parameter deklarieren, die nicht Teil der Pfad-Parameter sind, dann werden diese automatisch als ‚ÄûQuery‚Äú-Parameter interpretiert.

{* ../../docs_src/query_params/tutorial001.py hl[9] *}

Query-Parameter (Deutsch: Abfrage-Parameter) sind die Schl√ºssel-Wert-Paare, die nach dem `?` in einer URL aufgelistet sind, getrennt durch `&`-Zeichen.

Zum Beispiel sind in der URL:

```
http://127.0.0.1:8000/items/?skip=0&limit=10
```

... die Query-Parameter:

* `skip`: mit dem Wert `0`
* `limit`: mit dem Wert `10`

Da sie Teil der URL sind, sind sie ‚Äûnaturgem√§√ü‚Äú Strings.

Aber wenn Sie sie mit Python-Typen deklarieren (im obigen Beispiel als `int`), werden sie zu diesem Typ konvertiert, und gegen diesen validiert.

Die gleichen Prozesse, die f√ºr Pfad-Parameter stattfinden, werden auch auf Query-Parameter angewendet:

* Editor Unterst√ºtzung (nat√ºrlich)
* <abbr title="Konvertieren des Strings, der von einer HTTP-Anfrage kommt, in Python-Daten">‚ÄûParsen‚Äú</abbr> der Daten
* Datenvalidierung
* Automatische Dokumentation

## Defaultwerte

Da Query-Parameter nicht ein festgelegter Teil des Pfades sind, k√∂nnen sie optional sein und Defaultwerte haben.

Im obigen Beispiel haben sie die Defaultwerte `skip=0` und `limit=10`.

Wenn Sie also zur URL:

```
http://127.0.0.1:8000/items/
```

gehen, so ist das das gleiche wie die URL:

```
http://127.0.0.1:8000/items/?skip=0&limit=10
```

Aber wenn Sie zum Beispiel zu:

```
http://127.0.0.1:8000/items/?skip=20
```

gehen, werden die Parameter-Werte Ihrer Funktion sein:

* `skip=20`: da Sie das in der URL gesetzt haben
* `limit=10`: weil das der Defaultwert ist

## Optionale Parameter

Auf die gleiche Weise k√∂nnen Sie optionale Query-Parameter deklarieren, indem Sie deren Defaultwert auf `None` setzen:

{* ../../docs_src/query_params/tutorial002_py310.py hl[7] *}

In diesem Fall wird der Funktionsparameter `q` optional, und standardm√§√üig `None` sein.

/// check

Beachten Sie auch, dass **FastAPI** intelligent genug ist, um zu erkennen, dass `item_id` ein Pfad-Parameter ist und `q` keiner, daher muss letzteres ein Query-Parameter sein.

///

## Query-Parameter Typkonvertierung

Sie k√∂nnen auch `bool`-Typen deklarieren und sie werden konvertiert:

{* ../../docs_src/query_params/tutorial003_py310.py hl[7] *}

Wenn Sie nun zu:

```
http://127.0.0.1:8000/items/foo?short=1
```

oder

```
http://127.0.0.1:8000/items/foo?short=True
```

oder

```
http://127.0.0.1:8000/items/foo?short=true
```

oder

```
http://127.0.0.1:8000/items/foo?short=on
```

oder

```
http://127.0.0.1:8000/items/foo?short=yes
```

gehen, oder zu irgendeiner anderen Variante der Gro√ü-/Kleinschreibung (Alles gro√ü, Anfangsbuchstabe gro√ü, usw.), dann wird Ihre Funktion den Parameter `short` mit dem `bool`-Wert `True` sehen, ansonsten mit dem Wert `False`.

## Mehrere Pfad- und Query-Parameter

Sie k√∂nnen mehrere Pfad-Parameter und Query-Parameter gleichzeitig deklarieren, **FastAPI** wei√ü, was welches ist.

Und Sie m√ºssen sie auch nicht in einer spezifischen Reihenfolge deklarieren.

Parameter werden anhand ihres Namens erkannt:

{* ../../docs_src/query_params/tutorial004_py310.py hl[6,8] *}

## Erforderliche Query-Parameter

Wenn Sie einen Defaultwert f√ºr Nicht-Pfad-Parameter deklarieren (Bis jetzt haben wir nur Query-Parameter gesehen), dann ist der Parameter nicht erforderlich.

Wenn Sie keinen spezifischen Wert haben wollen, sondern der Parameter einfach optional sein soll, dann setzen Sie den Defaultwert auf `None`.

Aber wenn Sie wollen, dass ein Query-Parameter erforderlich ist, vergeben Sie einfach keinen Defaultwert:

{* ../../docs_src/query_params/tutorial005.py hl[6:7] *}

Hier ist `needy` ein erforderlicher Query-Parameter vom Typ `str`.

Wenn Sie in Ihrem Browser eine URL wie:

```
http://127.0.0.1:8000/items/foo-item
```

... √∂ffnen, ohne den ben√∂tigten Parameter `needy`, dann erhalten Sie einen Fehler wie den folgenden:

```JSON
{
  "detail": [
    {
      "type": "missing",
      "loc": [
        "query",
        "needy"
      ],
      "msg": "Field required",
      "input": null,
      "url": "https://errors.pydantic.dev/2.1/v/missing"
    }
  ]
}
```

Da `needy` ein erforderlicher Parameter ist, m√ºssen Sie ihn in der URL setzen:

```
http://127.0.0.1:8000/items/foo-item?needy=sooooneedy
```

... Das funktioniert:

```JSON
{
    "item_id": "foo-item",
    "needy": "sooooneedy"
}
```

Und nat√ºrlich k√∂nnen Sie einige Parameter als erforderlich, einige mit Defaultwert, und einige als vollst√§ndig optional definieren:

{* ../../docs_src/query_params/tutorial006_py310.py hl[8] *}

In diesem Fall gibt es drei Query-Parameter:

* `needy`, ein erforderlicher `str`.
* `skip`, ein `int` mit einem Defaultwert `0`.
* `limit`, ein optionales `int`.

/// tip | Tipp

Sie k√∂nnen auch `Enum`s verwenden, auf die gleiche Weise wie mit [Pfad-Parametern](path-params.md#vordefinierte-parameterwerte){.internal-link target=_blank}.

///


================================================
File: /docs/de/docs/tutorial/request-files.md
================================================
# Dateien im Request

Mit `File` k√∂nnen sie vom Client hochzuladende Dateien definieren.

/// info

Um hochgeladene Dateien zu empfangen, installieren Sie zuerst <a href="https://andrew-d.github.io/python-multipart/" class="external-link" target="_blank">`python-multipart`</a>.

Z. B. `pip install python-multipart`.

Das, weil hochgeladene Dateien als ‚ÄûFormulardaten‚Äú gesendet werden.

///

## `File` importieren

Importieren Sie `File` und `UploadFile` von `fastapi`:

{* ../../docs_src/request_files/tutorial001_an_py39.py hl[3] *}

## `File`-Parameter definieren

Erstellen Sie Datei-Parameter, so wie Sie es auch mit `Body` und `Form` machen w√ºrden:

{* ../../docs_src/request_files/tutorial001_an_py39.py hl[9] *}

/// info

`File` ist eine Klasse, die direkt von `Form` erbt.

Aber erinnern Sie sich, dass, wenn Sie `Query`, `Path`,  `File` und andere von `fastapi` importieren, diese tats√§chlich Funktionen sind, welche spezielle Klassen zur√ºckgeben

///

/// tip | Tipp

Um Dateibodys zu deklarieren, m√ºssen Sie `File` verwenden, da diese Parameter sonst als Query-Parameter oder Body(-JSON)-Parameter interpretiert werden w√ºrden.

///

Die Dateien werden als ‚ÄûFormulardaten‚Äú hochgeladen.

Wenn Sie den Typ Ihrer *Pfadoperation-Funktion* als `bytes` deklarieren, wird **FastAPI** die Datei f√ºr Sie auslesen, und Sie erhalten den Inhalt als `bytes`.

Bedenken Sie, dass das bedeutet, dass sich der gesamte Inhalt der Datei im Arbeitsspeicher befindet. Das wird f√ºr kleinere Dateien gut funktionieren.

Aber es gibt viele F√§lle, in denen Sie davon profitieren, `UploadFile` zu verwenden.

## Datei-Parameter mit `UploadFile`

Definieren Sie einen Datei-Parameter mit dem Typ `UploadFile`:

{* ../../docs_src/request_files/tutorial001_an_py39.py hl[14] *}

`UploadFile` zu verwenden, hat mehrere Vorz√ºge gegen√ºber `bytes`:

* Sie m√ºssen `File()` nicht als Parameter-Defaultwert verwenden.
* Es wird eine <abbr title='Aufgespult, Warteschlangenartig'>‚ÄûSpool‚Äú</abbr>-Datei verwendet:
    * Eine Datei, die bis zu einem bestimmten Gr√∂√üen-Limit im Arbeitsspeicher behalten wird, und wenn das Limit √ºberschritten wird, auf der Festplatte gespeichert wird.
* Das bedeutet, es wird f√ºr gro√üe Dateien wie Bilder, Videos, gro√üe Bin√§rdateien, usw. gut funktionieren, ohne den ganzen Arbeitsspeicher aufzubrauchen.
* Sie k√∂nnen Metadaten aus der hochgeladenen Datei auslesen.
* Es hat eine <abbr title="dateiartig"><a href="https://docs.python.org/3/glossary.html#term-file-like-object" class="external-link" target="_blank">file-like</a></abbr> `async`hrone Schnittstelle.
* Es stellt ein tats√§chliches Python-<abbr title="Warteschlangenartige, tempor√§re Datei"><a href="https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile" class="external-link" target="_blank">`SpooledTemporaryFile`</a></abbr>-Objekt bereit, welches Sie direkt anderen Bibliotheken √ºbergeben k√∂nnen, die ein dateiartiges Objekt erwarten.

### `UploadFile`

`UploadFile` hat die folgenden Attribute:

* `filename`: Ein `str` mit dem urspr√ºnglichen Namen der hochgeladenen Datei (z. B. `meinbild.jpg`).
* `content_type`: Ein `str` mit dem Inhaltstyp (MIME-Typ / Medientyp) (z. B. `image/jpeg`).
* `file`: Ein <a href="https://docs.python.org/3/library/tempfile.html#tempfile.SpooledTemporaryFile" class="external-link" target="_blank">`SpooledTemporaryFile`</a> (ein <a href="https://docs.python.org/3/glossary.html#term-file-like-object" class="external-link" target="_blank">file-like</a> Objekt). Das ist das tats√§chliche Python-Objekt, das Sie direkt anderen Funktionen oder Bibliotheken √ºbergeben k√∂nnen, welche ein ‚Äûfile-like‚Äú-Objekt erwarten.

`UploadFile` hat die folgenden `async`hronen Methoden. Sie alle rufen die entsprechenden Methoden des darunterliegenden Datei-Objekts auf (wobei intern `SpooledTemporaryFile` verwendet wird).

* `write(daten)`: Schreibt `daten` (`str` oder `bytes`) in die Datei.
* `read(anzahl)`: Liest `anzahl` (`int`) bytes/Zeichen aus der Datei.
* `seek(versatz)`: Geht zur Position `versatz` (`int`) in der Datei.
    * Z. B. w√ºrde `await myfile.seek(0)` zum Anfang der Datei gehen.
    * Das ist besonders dann n√ºtzlich, wenn Sie `await myfile.read()` einmal ausf√ºhren und dann diese Inhalte erneut auslesen m√ºssen.
* `close()`: Schlie√üt die Datei.

Da alle diese Methoden `async`hron sind, m√ºssen Sie sie `await`en (‚Äûerwarten‚Äú).

Zum Beispiel k√∂nnen Sie innerhalb einer `async` *Pfadoperation-Funktion* den Inhalt wie folgt auslesen:

```Python
contents = await myfile.read()
```

Wenn Sie sich innerhalb einer normalen `def`-*Pfadoperation-Funktion* befinden, k√∂nnen Sie direkt auf `UploadFile.file` zugreifen, zum Beispiel:

```Python
contents = myfile.file.read()
```

/// note | Technische Details zu `async`

Wenn Sie die `async`-Methoden verwenden, f√ºhrt **FastAPI** die Datei-Methoden in einem <abbr title="Mehrere unabh√§ngige Kindprozesse">Threadpool</abbr> aus und erwartet sie.

///

/// note | Technische Details zu Starlette

**FastAPI**s `UploadFile` erbt direkt von **Starlette**s `UploadFile`, f√ºgt aber ein paar notwendige Teile hinzu, um es kompatibel mit **Pydantic** und anderen Teilen von FastAPI zu machen.

///

## Was sind ‚ÄûFormulardaten‚Äú

HTML-Formulare (`<form></form>`) senden die Daten in einer ‚Äûspeziellen‚Äú Kodierung zum Server, welche sich von JSON unterscheidet.

**FastAPI** stellt sicher, dass diese Daten korrekt ausgelesen werden, statt JSON zu erwarten.

/// note | Technische Details

Daten aus Formularen werden, wenn es keine Dateien sind, normalerweise mit dem <abbr title='Media type ‚Äì Medientyp, Typ des Mediums'>‚Äûmedia type‚Äú</abbr> `application/x-www-form-urlencoded` kodiert.

Sollte das Formular aber Dateien enthalten, dann werden diese mit `multipart/form-data` kodiert. Wenn Sie `File` verwenden, wird **FastAPI** wissen, dass es die Dateien vom korrekten Teil des Bodys holen muss.

Wenn Sie mehr √ºber Formularfelder und ihre Kodierungen lesen m√∂chten, besuchen Sie die <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" class="external-link" target="_blank"><abbr title="Mozilla Developer Network ‚Äì Mozilla-Entwickler-Netzwerk">MDN</abbr>-Webdokumentation f√ºr <code>POST</code></a>.

///

/// warning | Achtung

Sie k√∂nnen mehrere `File`- und `Form`-Parameter in einer *Pfadoperation* deklarieren, aber Sie k√∂nnen nicht gleichzeitig auch `Body`-Felder deklarieren, welche Sie als JSON erwarten, da der Request den Body mittels `multipart/form-data` statt `application/json` kodiert.

Das ist keine Limitation von **FastAPI**, sondern Teil des HTTP-Protokolls.

///

## Optionaler Datei-Upload

Sie k√∂nnen eine Datei optional machen, indem Sie Standard-Typannotationen verwenden und den Defaultwert auf `None` setzen:

{* ../../docs_src/request_files/tutorial001_02_an_py310.py hl[9,17] *}

## `UploadFile` mit zus√§tzlichen Metadaten

Sie k√∂nnen auch `File()` zusammen mit `UploadFile` verwenden, um zum Beispiel zus√§tzliche Metadaten zu setzen:

{* ../../docs_src/request_files/tutorial001_03_an_py39.py hl[9,15] *}

## Mehrere Datei-Uploads

Es ist auch m√∂glich, mehrere Dateien gleichzeitig hochzuladen.

Diese werden demselben Formularfeld zugeordnet, welches mit den Formulardaten gesendet wird.

Um das zu machen, deklarieren Sie eine Liste von `bytes` oder `UploadFile`s:

{* ../../docs_src/request_files/tutorial002_an_py39.py hl[10,15] *}

Sie erhalten, wie deklariert, eine `list`e von `bytes` oder `UploadFile`s.

/// note | Technische Details

Sie k√∂nnen auch `from starlette.responses import HTMLResponse` verwenden.

**FastAPI** bietet dieselben `starlette.responses` auch via `fastapi.responses` an, als Annehmlichkeit f√ºr Sie, den Entwickler. Die meisten verf√ºgbaren Responses kommen aber direkt von Starlette.

///

### Mehrere Datei-Uploads mit zus√§tzlichen Metadaten

Und so wie zuvor k√∂nnen Sie `File()` verwenden, um zus√§tzliche Parameter zu setzen, sogar f√ºr `UploadFile`:

{* ../../docs_src/request_files/tutorial003_an_py39.py hl[11,18:20] *}

## Zusammenfassung

Verwenden Sie `File`, `bytes` und `UploadFile`, um hochladbare Dateien im Request zu deklarieren, die als Formulardaten gesendet werden.


================================================
File: /docs/de/docs/tutorial/request-forms-and-files.md
================================================
# Formulardaten und Dateien im Request

Sie k√∂nnen gleichzeitig Dateien und Formulardaten mit `File` und `Form` definieren.

/// info

Um hochgeladene Dateien und/oder Formulardaten zu empfangen, installieren Sie zuerst <a href="https://andrew-d.github.io/python-multipart/" class="external-link" target="_blank">`python-multipart`</a>.

Z. B. `pip install python-multipart`.

///

## `File` und `Form` importieren

{* ../../docs_src/request_forms_and_files/tutorial001_an_py39.py hl[3] *}

## `File` und `Form`-Parameter definieren

Erstellen Sie Datei- und Formularparameter, so wie Sie es auch mit `Body` und `Query` machen w√ºrden:

{* ../../docs_src/request_forms_and_files/tutorial001_an_py39.py hl[10:12] *}

Die Datei- und Formularfelder werden als Formulardaten hochgeladen, und Sie erhalten diese Dateien und Formularfelder.

Und Sie k√∂nnen einige der Dateien als `bytes` und einige als `UploadFile` deklarieren.

/// warning | Achtung

Sie k√∂nnen mehrere `File`- und `Form`-Parameter in einer *Pfadoperation* deklarieren, aber Sie k√∂nnen nicht gleichzeitig auch `Body`-Felder deklarieren, welche Sie als JSON erwarten, da der Request den Body mittels `multipart/form-data` statt `application/json` kodiert.

Das ist keine Limitation von **FastAPI**, sondern Teil des HTTP-Protokolls.

///

## Zusammenfassung

Verwenden Sie `File` und `Form` zusammen, wenn Sie Daten und Dateien zusammen im selben Request empfangen m√ºssen.


================================================
File: /docs/de/docs/tutorial/request-forms.md
================================================
# Formulardaten

Wenn Sie Felder aus Formularen statt JSON empfangen m√ºssen, k√∂nnen Sie `Form` verwenden.

/// info

Um Formulare zu verwenden, installieren Sie zuerst <a href="https://andrew-d.github.io/python-multipart/" class="external-link" target="_blank">`python-multipart`</a>.

Z. B. `pip install python-multipart`.

///

## `Form` importieren

Importieren Sie `Form` von `fastapi`:

{* ../../docs_src/request_forms/tutorial001_an_py39.py hl[3] *}

## `Form`-Parameter definieren

Erstellen Sie Formular-Parameter, so wie Sie es auch mit `Body` und `Query` machen w√ºrden:

{* ../../docs_src/request_forms/tutorial001_an_py39.py hl[9] *}

Zum Beispiel stellt eine der M√∂glichkeiten, die OAuth2 Spezifikation zu verwenden (genannt <abbr title='‚ÄûPasswort-Fluss‚Äú'>‚Äûpassword flow‚Äú</abbr>), die Bedingung, einen `username` und ein `password` als Formularfelder zu senden.

Die <abbr title="Specification ‚Äì Spezifikation">Spec</abbr> erfordert, dass die Felder exakt `username` und `password` genannt werden und als Formularfelder, nicht JSON, gesendet werden.

Mit `Form` haben Sie die gleichen Konfigurationsm√∂glichkeiten wie mit `Body` (und `Query`, `Path`, `Cookie`), inklusive Validierung, Beispielen, einem Alias (z. B. `user-name` statt `username`), usw.

/// info

`Form` ist eine Klasse, die direkt von `Body` erbt.

///

/// tip | Tipp

Um Formularbodys zu deklarieren, verwenden Sie explizit `Form`, da diese Parameter sonst als Query-Parameter oder Body(-JSON)-Parameter interpretiert werden w√ºrden.

///

## √úber ‚ÄûFormularfelder‚Äú

HTML-Formulare (`<form></form>`) senden die Daten in einer ‚Äûspeziellen‚Äú Kodierung zum Server, welche sich von JSON unterscheidet.

**FastAPI** stellt sicher, dass diese Daten korrekt ausgelesen werden, statt JSON zu erwarten.

/// note | Technische Details

Daten aus Formularen werden normalerweise mit dem <abbr title='Media type ‚Äì Medientyp, Typ des Mediums'>‚Äûmedia type‚Äú</abbr> `application/x-www-form-urlencoded` kodiert.

Wenn das Formular stattdessen Dateien enth√§lt, werden diese mit `multipart/form-data` kodiert. Im n√§chsten Kapitel erfahren Sie mehr √ºber die Handhabung von Dateien.

Wenn Sie mehr √ºber Formularfelder und ihre Kodierungen lesen m√∂chten, besuchen Sie die <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/POST" class="external-link" target="_blank"><abbr title="Mozilla Developer Network ‚Äì Mozilla-Entwickler-Netzwerk">MDN</abbr>-Webdokumentation f√ºr <code>POST</code></a>.

///

/// warning | Achtung

Sie k√∂nnen mehrere `Form`-Parameter in einer *Pfadoperation* deklarieren, aber Sie k√∂nnen nicht gleichzeitig auch `Body`-Felder deklarieren, welche Sie als JSON erwarten, da der Request den Body mittels `application/x-www-form-urlencoded` statt `application/json` kodiert.

Das ist keine Limitation von **FastAPI**, sondern Teil des HTTP-Protokolls.

///

## Zusammenfassung

Verwenden Sie `Form`, um Eingabe-Parameter f√ºr Formulardaten zu deklarieren.


================================================
File: /docs/de/docs/tutorial/response-model.md
================================================
# Responsemodell ‚Äì R√ºckgabetyp

Sie k√∂nnen den Typ der <abbr title="Response ‚Äì Antwort: Daten, die zum anfragenden Client zur√ºckgeschickt werden">Response</abbr> deklarieren, indem Sie den **R√ºckgabetyp** der *Pfadoperation* annotieren.

Hierbei k√∂nnen Sie **Typannotationen** genauso verwenden, wie Sie es bei Werten von Funktions-**Parametern** machen; verwenden Sie Pydantic-Modelle, Listen, Dicts und skalare Werte wie Nummern, Booleans, usw.

{* ../../docs_src/response_model/tutorial001_01_py310.py hl[16,21] *}

FastAPI wird diesen R√ºckgabetyp verwenden, um:

* Die zur√ºckzugebenden Daten zu **validieren**.
    * Wenn die Daten ung√ºltig sind (Sie haben z. B. ein Feld vergessen), bedeutet das, *Ihr* Anwendungscode ist fehlerhaft, er gibt nicht zur√ºck, was er sollte, und daher wird ein <abbr title="Server-Fehler">Server-Error</abbr> ausgegeben, statt falscher Daten. So k√∂nnen Sie und ihre Clients sicher sein, dass diese die erwarteten Daten, in der richtigen Form erhalten.
* In der OpenAPI *Pfadoperation* ein **JSON-Schema** f√ºr die Response hinzuzuf√ºgen.
    * Dieses wird von der **automatischen Dokumentation** verwendet.
    * Es wird auch von automatisch Client-Code-generierenden Tools verwendet.

Aber am wichtigsten:

* Es wird die Ausgabedaten auf das **limitieren und filtern**, was im R√ºckgabetyp definiert ist.
    * Das ist insbesondere f√ºr die **Sicherheit** wichtig, mehr dazu unten.

## `response_model`-Parameter

Es gibt F√§lle, da m√∂chten oder m√ºssen Sie Daten zur√ºckgeben, die nicht genau dem entsprechen, was der Typ deklariert.

Zum Beispiel k√∂nnten Sie **ein Dict zur√ºckgeben** wollen, oder ein Datenbank-Objekt, aber **es als Pydantic-Modell deklarieren**. Auf diese Weise √ºbernimmt das Pydantic-Modell alle Datendokumentation, -validierung, usw. f√ºr das Objekt, welches Sie zur√ºckgeben (z. B. ein Dict oder ein Datenbank-Objekt).

W√ºrden Sie eine hierf√ºr eine R√ºckgabetyp-Annotation verwenden, dann w√ºrden Tools und Editoren (korrekterweise) Fehler ausgeben, die Ihnen sagen, dass Ihre Funktion einen Typ zur√ºckgibt (z. B. ein Dict), der sich unterscheidet von dem, was Sie deklariert haben (z. B. ein Pydantic-Modell).

In solchen F√§llen k√∂nnen Sie statt des R√ºckgabetyps den **Pfadoperation-Dekorator**-Parameter `response_model` verwenden.

Sie k√∂nnen `response_model` in jeder m√∂glichen *Pfadoperation* verwenden:

* `@app.get()`
* `@app.post()`
* `@app.put()`
* `@app.delete()`
* usw.

{* ../../docs_src/response_model/tutorial001_py310.py hl[17,22,24:27] *}

/// note | Hinweis

Beachten Sie, dass `response_model` ein Parameter der ‚ÄûDekorator‚Äú-Methode ist (`get`, `post`, usw.). Nicht der *Pfadoperation-Funktion*, so wie die anderen Parameter.

///

`response_model` nimmt denselben Typ entgegen, den Sie auch f√ºr ein Pydantic-Modellfeld deklarieren w√ºrden, also etwa ein Pydantic-Modell, aber es kann auch z. B. eine `list`e von Pydantic-Modellen sein, wie etwa `List[Item]`.

FastAPI wird dieses `response_model` nehmen, um die Daten zu dokumentieren, validieren, usw. und auch, um **die Ausgabedaten** entsprechend der Typdeklaration **zu konvertieren und filtern**.

/// tip | Tipp

Wenn Sie in Ihrem Editor strikte Typchecks haben, mypy, usw., k√∂nnen Sie den Funktions-R√ºckgabetyp als <abbr title='‚ÄûIrgend etwas‚Äú'>`Any`</abbr> deklarieren.

So sagen Sie dem Editor, dass Sie absichtlich *irgendetwas* zur√ºckgeben. Aber FastAPI wird trotzdem die Dokumentation, Validierung, Filterung, usw. der Daten √ºbernehmen, via `response_model`.

///

### `response_model`-Priorit√§t

Wenn sowohl R√ºckgabetyp als auch `response_model` deklariert sind, hat `response_model` die Priorit√§t und wird von FastAPI bevorzugt verwendet.

So k√∂nnen Sie korrekte Typannotationen zu ihrer Funktion hinzuf√ºgen, die von ihrem Editor und Tools wie mypy verwendet werden. Und dennoch √ºbernimmt FastAPI die Validierung und Dokumentation, usw., der Daten anhand von `response_model`.

Sie k√∂nnen auch `response_model=None` verwenden, um das Erstellen eines Responsemodells f√ºr diese *Pfadoperation* zu unterbinden. Sie k√∂nnten das tun wollen, wenn sie Dinge annotieren, die nicht g√ºltige Pydantic-Felder sind. Ein Beispiel dazu werden Sie in einer der Abschnitte unten sehen.

## Dieselben Eingabedaten zur√ºckgeben

Im Folgenden deklarieren wir ein `UserIn`-Modell; es enth√§lt ein Klartext-Passwort:

{* ../../docs_src/response_model/tutorial002_py310.py hl[7,9] *}

/// info

Um `EmailStr` zu verwenden, installieren Sie zuerst <a href="https://github.com/JoshData/python-email-validator" class="external-link" target="_blank">`email-validator`</a>.

Z. B. `pip install email-validator`
oder `pip install pydantic[email]`.

///

Wir verwenden dieses Modell, um sowohl unsere Eingabe- als auch Ausgabedaten zu deklarieren:

{* ../../docs_src/response_model/tutorial002_py310.py hl[16] *}

Immer wenn jetzt ein Browser einen Benutzer mit Passwort erzeugt, gibt die API dasselbe Passwort in der Response zur√ºck.

Hier ist das m√∂glicherweise kein Problem, da es derselbe Benutzer ist, der das Passwort sendet.

Aber wenn wir dasselbe Modell f√ºr eine andere *Pfadoperation* verwenden, k√∂nnten wir das Passwort dieses Benutzers zu jedem Client schicken.

/// danger | Gefahr

Speichern Sie niemals das Klartext-Passwort eines Benutzers, oder versenden Sie es in einer Response wie dieser, wenn Sie sich nicht der resultierenden Gefahren bewusst sind und nicht wissen, was Sie tun.

///

## Ausgabemodell hinzuf√ºgen

Wir k√∂nnen stattdessen ein Eingabemodell mit dem Klartext-Passwort, und ein Ausgabemodell ohne das Passwort erstellen:

{* ../../docs_src/response_model/tutorial003_py310.py hl[9,11,16] *}

Obwohl unsere *Pfadoperation-Funktion* hier denselben `user` von der Eingabe zur√ºckgibt, der das Passwort enth√§lt:

{* ../../docs_src/response_model/tutorial003_py310.py hl[24] *}

... haben wir deklariert, dass `response_model` das Modell `UserOut` ist, welches das Passwort nicht enth√§lt:

{* ../../docs_src/response_model/tutorial003_py310.py hl[22] *}

Darum wird **FastAPI** sich darum k√ºmmern, dass alle Daten, die nicht im Ausgabemodell deklariert sind, herausgefiltert werden (mittels Pydantic).

### `response_model` oder R√ºckgabewert

Da unsere zwei Modelle in diesem Fall unterschiedlich sind, w√ºrde, wenn wir den R√ºckgabewert der Funktion als `UserOut` deklarieren, der Editor sich beschweren, dass wir einen ung√ºltigen Typ zur√ºckgeben, weil das unterschiedliche Klassen sind.

Darum m√ºssen wir es in diesem Fall im `response_model`-Parameter deklarieren.

... aber lesen Sie weiter, um zu sehen, wie man das anders l√∂sen kann.

## R√ºckgabewert und Datenfilterung

F√ºhren wir unser vorheriges Beispiel fort. Wir wollten **die Funktion mit einem Typ annotieren**, aber etwas zur√ºckgeben, das **weniger Daten** enth√§lt.

Wir m√∂chten auch, dass FastAPI die Daten weiterhin, dem Responsemodell entsprechend, **filtert**.

Im vorherigen Beispiel mussten wir den `response_model`-Parameter verwenden, weil die Klassen unterschiedlich waren. Das bedeutet aber auch, wir bekommen keine Unterst√ºtzung vom Editor und anderen Tools, die den Funktions-R√ºckgabewert √ºberpr√ºfen.

Aber in den meisten F√§llen, wenn wir so etwas machen, wollen wir nur, dass das Modell einige der Daten **filtert/entfernt**, so wie in diesem Beispiel.

Und in solchen F√§llen k√∂nnen wir Klassen und Vererbung verwenden, um Vorteil aus den Typannotationen in der Funktion zu ziehen, was vom Editor und von Tools besser unterst√ºtzt wird, w√§hrend wir gleichzeitig FastAPIs **Datenfilterung** behalten.

{* ../../docs_src/response_model/tutorial003_01_py310.py hl[7:10,13:14,18] *}

Damit erhalten wir Tool-Unterst√ºtzung, vom Editor und mypy, da dieser Code hinsichtlich der Typen korrekt ist, aber wir erhalten auch die Datenfilterung von FastAPI.

Wie funktioniert das? Schauen wir uns das mal an. ü§ì

### Typannotationen und Tooling

Sehen wir uns zun√§chst an, wie Editor, mypy und andere Tools dies sehen w√ºrden.

`BaseUser` verf√ºgt √ºber die Basis-Felder. Dann erbt `UserIn` von `BaseUser` und f√ºgt das Feld `Passwort` hinzu, sodass dass es nun alle Felder beider Modelle hat.

Wir annotieren den Funktionsr√ºckgabetyp als `BaseUser`, geben aber tats√§chlich eine `UserIn`-Instanz zur√ºck.

F√ºr den Editor, mypy und andere Tools ist das kein Problem, da `UserIn` eine Unterklasse von `BaseUser` ist (Salopp: `UserIn` ist ein `BaseUser`). Es handelt sich um einen *g√ºltigen* Typ, solange irgendetwas √ºberreicht wird, das ein `BaseUser` ist.

### FastAPI Datenfilterung

FastAPI seinerseits wird den R√ºckgabetyp sehen und sicherstellen, dass das, was zur√ºckgegeben wird, **nur** diejenigen Felder enth√§lt, welche im Typ deklariert sind.

FastAPI macht intern mehrere Dinge mit Pydantic, um sicherzustellen, dass obige √Ñhnlichkeitsregeln der Klassenvererbung nicht auf die Filterung der zur√ºckgegebenen Daten angewendet werden, sonst k√∂nnten Sie am Ende mehr Daten zur√ºckgeben als gewollt.

Auf diese Weise erhalten Sie das beste beider Welten: Sowohl Typannotationen mit **Tool-Unterst√ºtzung** als auch **Datenfilterung**.

## Anzeige in der Dokumentation

Wenn Sie sich die automatische Dokumentation betrachten, k√∂nnen Sie sehen, dass Eingabe- und Ausgabemodell beide ihr eigenes JSON-Schema haben:

<img src="/img/tutorial/response-model/image01.png">

Und beide Modelle werden auch in der interaktiven API-Dokumentation verwendet:

<img src="/img/tutorial/response-model/image02.png">

## Andere R√ºckgabetyp-Annotationen

Es kann F√§lle geben, bei denen Sie etwas zur√ºckgeben, das kein g√ºltiges Pydantic-Feld ist, und Sie annotieren es in der Funktion nur, um Unterst√ºtzung von Tools zu erhalten (Editor, mypy, usw.).

### Eine Response direkt zur√ºckgeben

Der h√§ufigste Anwendungsfall ist, wenn Sie [eine Response direkt zur√ºckgeben, wie es sp√§ter im Handbuch f√ºr fortgeschrittene Benutzer erl√§utert wird](../advanced/response-directly.md){.internal-link target=_blank}.

{* ../../docs_src/response_model/tutorial003_02.py hl[8,10:11] *}

Dieser einfache Anwendungsfall wird automatisch von FastAPI gehandhabt, weil die Annotation des R√ºckgabetyps die Klasse (oder eine Unterklasse von) `Response` ist.

Und Tools werden auch gl√ºcklich sein, weil sowohl `RedirectResponse` als auch `JSONResponse` Unterklassen von `Response` sind, die Typannotation ist daher korrekt.

### Eine Unterklasse von Response annotieren

Sie k√∂nnen auch eine Unterklasse von `Response` in der Typannotation verwenden.

{* ../../docs_src/response_model/tutorial003_03.py hl[8:9] *}

Das wird ebenfalls funktionieren, weil `RedirectResponse` eine Unterklasse von `Response` ist, und FastAPI sich um diesen einfachen Anwendungsfall automatisch k√ºmmert.

### Ung√ºltige R√ºckgabetyp-Annotationen

Aber wenn Sie ein beliebiges anderes Objekt zur√ºckgeben, das kein g√ºltiger Pydantic-Typ ist (z. B. ein Datenbank-Objekt), und Sie annotieren es so in der Funktion, wird FastAPI versuchen, ein Pydantic-Responsemodell von dieser Typannotation zu erstellen, und scheitern.

Das gleiche wird passieren, wenn Sie eine <abbr title='Eine Union mehrerer Typen bedeutet: ‚ÄûIrgendeiner dieser Typen‚Äú'>Union</abbr> mehrerer Typen haben, und einer oder mehrere sind nicht g√ºltige Pydantic-Typen. Zum Beispiel funktioniert folgendes nicht üí•:

{* ../../docs_src/response_model/tutorial003_04_py310.py hl[8] *}

... das scheitert, da die Typannotation kein Pydantic-Typ ist, und auch keine einzelne `Response`-Klasse, oder -Unterklasse, es ist eine Union (eines von beiden) von `Response` und `dict`.

### Responsemodell deaktivieren

Beim Beispiel oben fortsetzend, m√∂gen Sie vielleicht die standardm√§√üige Datenvalidierung, -Dokumentation, -Filterung, usw., die von FastAPI durchgef√ºhrt wird, nicht haben.

Aber Sie m√∂chten dennoch den R√ºckgabetyp in der Funktion annotieren, um Unterst√ºtzung von Editoren und Typcheckern (z. B. mypy) zu erhalten.

In diesem Fall k√∂nnen Sie die Generierung des Responsemodells abschalten, indem Sie `response_model=None` setzen:

{* ../../docs_src/response_model/tutorial003_05_py310.py hl[7] *}

Das bewirkt, dass FastAPI die Generierung des Responsemodells unterl√§sst, und damit k√∂nnen Sie jede gew√ºnschte R√ºckgabetyp-Annotation haben, ohne dass es Ihre FastAPI-Anwendung beeinflusst. ü§ì

## Parameter f√ºr die Enkodierung des Responsemodells

Ihr Responsemodell k√∂nnte Defaultwerte haben, wie:

{* ../../docs_src/response_model/tutorial004_py310.py hl[9,11:12] *}

* `description: Union[str, None] = None` (oder `str | None = None` in Python 3.10) hat einen Defaultwert `None`.
* `tax: float = 10.5` hat einen Defaultwert `10.5`.
* `tags: List[str] = []` hat eine leere Liste als Defaultwert: `[]`.

Aber Sie m√∂chten diese vielleicht vom Resultat ausschlie√üen, wenn Sie gar nicht gesetzt wurden.

Wenn Sie zum Beispiel Modelle mit vielen optionalen Attributen in einer NoSQL-Datenbank haben, und Sie m√∂chten nicht ellenlange JSON-Responses voller Defaultwerte senden.

### Den `response_model_exclude_unset`-Parameter verwenden

Sie k√∂nnen den *Pfadoperation-Dekorator*-Parameter `response_model_exclude_unset=True` setzen:

{* ../../docs_src/response_model/tutorial004_py310.py hl[22] *}

Die Defaultwerte werden dann nicht in der Response enthalten sein, sondern nur die tats√§chlich gesetzten Werte.

Wenn Sie also den Artikel mit der ID `foo` bei der *Pfadoperation* anfragen, wird (ohne die Defaultwerte) die Response sein:

```JSON
{
    "name": "Foo",
    "price": 50.2
}
```

/// info

In Pydantic v1 hie√ü diese Methode `.dict()`, in Pydantic v2 wurde sie deprecated (aber immer noch unterst√ºtzt) und in `.model_dump()` umbenannt.

Die Beispiele hier verwenden `.dict()` f√ºr die Kompatibilit√§t mit Pydantic v1, Sie sollten jedoch stattdessen `.model_dump()` verwenden, wenn Sie Pydantic v2 verwenden k√∂nnen.

///

/// info

FastAPI verwendet `.dict()` von Pydantic Modellen, <a href="https://docs.pydantic.dev/1.10/usage/exporting_models/#modeldict" class="external-link" target="_blank">mit dessen `exclude_unset`-Parameter</a>, um das zu erreichen.

///

/// info

Sie k√∂nnen auch:

* `response_model_exclude_defaults=True`
* `response_model_exclude_none=True`

verwenden, wie in der <a href="https://docs.pydantic.dev/1.10/usage/exporting_models/#modeldict" class="external-link" target="_blank">Pydantic Dokumentation</a> f√ºr `exclude_defaults` und `exclude_none` beschrieben.

///

#### Daten mit Werten f√ºr Felder mit Defaultwerten

Aber wenn ihre Daten Werte f√ºr Modellfelder mit Defaultwerten haben, wie etwa der Artikel mit der ID `bar`:

```Python hl_lines="3  5"
{
    "name": "Bar",
    "description": "The bartenders",
    "price": 62,
    "tax": 20.2
}
```

dann werden diese Werte in der Response enthalten sein.

#### Daten mit den gleichen Werten wie die Defaultwerte

Wenn Daten die gleichen Werte haben wie ihre Defaultwerte, wie etwa der Artikel mit der ID `baz`:

```Python hl_lines="3  5-6"
{
    "name": "Baz",
    "description": None,
    "price": 50.2,
    "tax": 10.5,
    "tags": []
}
```

dann ist FastAPI klug genug (tats√§chlich ist Pydantic klug genug) zu erkennen, dass, obwohl `description`, `tax`, und `tags` die gleichen Werte haben wie ihre Defaultwerte, sie explizit gesetzt wurden (statt dass sie von den Defaultwerten genommen wurden).

Diese Felder werden also in der JSON-Response enthalten sein.

/// tip | Tipp

Beachten Sie, dass Defaultwerte alles M√∂gliche sein k√∂nnen, nicht nur `None`.

Sie k√∂nnen eine Liste (`[]`), ein `float` `10.5`, usw. sein.

///

### `response_model_include` und `response_model_exclude`

Sie k√∂nnen auch die Parameter `response_model_include` und `response_model_exclude` im **Pfadoperation-Dekorator** verwenden.

Diese nehmen ein `set` von `str`s entgegen, welches Namen von Attributen sind, die eingeschlossen (ohne die Anderen) oder ausgeschlossen (nur die Anderen) werden sollen.

Das kann als schnelle Abk√ºrzung verwendet werden, wenn Sie nur ein Pydantic-Modell haben und ein paar Daten von der Ausgabe ausschlie√üen wollen.

/// tip | Tipp

Es wird dennoch empfohlen, dass Sie die Ideen von oben verwenden, also mehrere Klassen statt dieser Parameter.

Der Grund ist, dass das das generierte JSON-Schema in der OpenAPI ihrer Anwendung (und deren Dokumentation) dennoch das komplette Modell abbildet, selbst wenn Sie `response_model_include` oder `response_model_exclude` verwenden, um einige Attribute auszuschlie√üen.

Das trifft auch auf `response_model_by_alias` zu, welches √§hnlich funktioniert.

///

{* ../../docs_src/response_model/tutorial005_py310.py hl[29,35] *}

/// tip | Tipp

Die Syntax `{"name", "description"}` erzeugt ein `set` mit diesen zwei Werten.

√Ñquivalent zu `set(["name", "description"])`.

///

#### `list`en statt `set`s verwenden

Wenn Sie vergessen, ein `set` zu verwenden, und stattdessen eine `list`e oder ein `tuple` √ºbergeben, wird FastAPI die dennoch in ein `set` konvertieren, und es wird korrekt funktionieren:

{* ../../docs_src/response_model/tutorial006_py310.py hl[29,35] *}

## Zusammenfassung

Verwenden Sie den Parameter `response_model` im *Pfadoperation-Dekorator*, um Responsemodelle zu definieren, und besonders, um private Daten herauszufiltern.

Verwenden Sie `response_model_exclude_unset`, um nur explizit gesetzte Werte zur√ºckzugeben.


================================================
File: /docs/de/docs/tutorial/response-status-code.md
================================================
# Response-Statuscode

So wie ein Responsemodell, k√∂nnen Sie auch einen HTTP-Statuscode f√ºr die Response deklarieren, mithilfe des Parameters `status_code`, und zwar in jeder der *Pfadoperationen*:

* `@app.get()`
* `@app.post()`
* `@app.put()`
* `@app.delete()`
* usw.

{* ../../docs_src/response_status_code/tutorial001.py hl[6] *}

/// note | Hinweis

Beachten Sie, dass `status_code` ein Parameter der ‚ÄûDekorator‚Äú-Methode ist (`get`, `post`, usw.). Nicht der *Pfadoperation-Funktion*, so wie die anderen Parameter und der Body.

///

Dem `status_code`-Parameter wird eine Zahl mit dem HTTP-Statuscode √ºbergeben.

/// info

Alternativ kann `status_code` auch ein `IntEnum` erhalten, so wie Pythons <a href="https://docs.python.org/3/library/http.html#http.HTTPStatus" class="external-link" target="_blank">`http.HTTPStatus`</a>.

///

Das wird:

* Diesen Statuscode mit der Response zur√ºcksenden.
* Ihn als solchen im OpenAPI-Schema dokumentieren (und somit in den Benutzeroberfl√§chen):

<img src="/img/tutorial/response-status-code/image01.png">

/// note | Hinweis

Einige Responsecodes (siehe n√§chster Abschnitt) kennzeichnen, dass die Response keinen Body hat.

FastAPI versteht das und wird in der OpenAPI-Dokumentation anzeigen, dass es keinen Responsebody gibt.

///

## √úber HTTP-Statuscodes

/// note | Hinweis

Wenn Sie bereits wissen, was HTTP-Statuscodes sind, √ºberspringen Sie dieses Kapitel und fahren Sie mit dem n√§chsten fort.

///

In HTTP senden Sie als Teil der Response einen aus drei Ziffern bestehenden numerischen Statuscode.

Diese Statuscodes haben einen Namen zugeordnet, um sie besser zu erkennen, aber der wichtige Teil ist die Zahl.

Kurz:

* `100` und dar√ºber stehen f√ºr ‚ÄûInformation‚Äú. Diese verwenden Sie selten direkt. Responses mit diesen Statuscodes k√∂nnen keinen Body haben.
* **`200`** und dar√ºber stehen f√ºr Responses, die ‚ÄûSuccessful‚Äú (‚ÄûErfolgreich‚Äú) waren. Diese verwenden Sie am h√§ufigsten.
    * `200` ist der Default-Statuscode, welcher bedeutet, alles ist ‚ÄûOK‚Äú.
    * Ein anderes Beispiel ist `201`, ‚ÄûCreated‚Äú (‚ÄûErzeugt‚Äú). Wird in der Regel verwendet, wenn ein neuer Datensatz in der Datenbank erzeugt wurde.
    * Ein spezieller Fall ist `204`, ‚ÄûNo Content‚Äú (‚ÄûKein Inhalt‚Äú). Diese Response wird verwendet, wenn es keinen Inhalt gibt, der zum Client zur√ºckgeschickt wird, diese Response hat also keinen Body.
* **`300`** und dar√ºber steht f√ºr ‚ÄûRedirection‚Äú (‚ÄûUmleitung‚Äú).  Responses mit diesen Statuscodes k√∂nnen einen oder keinen Body haben, mit Ausnahme von `304`, ‚ÄûNot Modified‚Äú (‚ÄûNicht ver√§ndert‚Äú), welche keinen haben darf.
* **`400`** und dar√ºber stehen f√ºr ‚ÄûClient error‚Äú-Responses (‚ÄûClient-Fehler‚Äú). Auch diese verwenden Sie am h√§ufigsten.
    * Ein Beispiel ist `404`, f√ºr eine ‚ÄûNot Found‚Äú-Response (‚ÄûNicht gefunden‚Äú).
    * F√ºr allgemeine Fehler beim Client k√∂nnen Sie einfach `400` verwenden.
* `500` und dar√ºber stehen f√ºr Server-Fehler. Diese verwenden Sie fast nie direkt. Wenn etwas an irgendeiner Stelle in Ihrem Anwendungscode oder im Server schiefl√§uft, wird automatisch einer dieser Fehler-Statuscodes zur√ºckgegeben.

/// tip | Tipp

Um mehr √ºber Statuscodes zu lernen, und welcher wof√ºr verwendet wird, lesen Sie die <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Status" class="external-link" target="_blank"><abbr title="Mozilla Developer Network ‚Äì Mozilla-Entwickler-Netzwerk">MDN</abbr> Dokumentation √ºber HTTP-Statuscodes</a>.

///

## Abk√ºrzung, um die Namen zu erinnern

Schauen wir uns das vorherige Beispiel noch einmal an:

{* ../../docs_src/response_status_code/tutorial001.py hl[6] *}

`201` ist der Statuscode f√ºr ‚ÄûCreated‚Äú (‚ÄûErzeugt‚Äú).

Aber Sie m√ºssen sich nicht daran erinnern, welcher dieser Codes was bedeutet.

Sie k√∂nnen die Hilfsvariablen von `fastapi.status` verwenden.

{* ../../docs_src/response_status_code/tutorial002.py hl[1,6] *}

Diese sind nur eine Annehmlichkeit und enthalten dieselbe Nummer, aber auf diese Weise k√∂nnen Sie die Autovervollst√§ndigung Ihres Editors verwenden, um sie zu finden:

<img src="/img/tutorial/response-status-code/image02.png">

/// note | Technische Details

Sie k√∂nnen auch `from starlette import status` verwenden.

**FastAPI** bietet dieselben `starlette.status`-Codes auch via `fastapi.status` an, als Annehmlichkeit f√ºr Sie, den Entwickler. Sie kommen aber direkt von Starlette.

///

## Den Defaultwert √§ndern

Sp√§ter sehen Sie, im [Handbuch f√ºr fortgeschrittene Benutzer](../advanced/response-change-status-code.md){.internal-link target=_blank}, wie Sie einen anderen Statuscode zur√ºckgeben k√∂nnen, als den Default, den Sie hier deklarieren.


================================================
File: /docs/de/docs/tutorial/schema-extra-example.md
================================================
# Beispiel-Request-Daten deklarieren

Sie k√∂nnen Beispiele f√ºr die Daten deklarieren, die Ihre Anwendung empfangen kann.

Hier sind mehrere M√∂glichkeiten, das zu tun.

## Zus√§tzliche JSON-Schemadaten in Pydantic-Modellen

Sie k√∂nnen `examples` (‚ÄûBeispiele‚Äú) f√ºr ein Pydantic-Modell deklarieren, welche dem generierten JSON-Schema hinzugef√ºgt werden.

//// tab | Pydantic v2

{* ../../docs_src/schema_extra_example/tutorial001_py310.py hl[13:24] *}

////

//// tab | Pydantic v1

{* ../../docs_src/schema_extra_example/tutorial001_pv1_py310.py hl[13:23] *}

////

Diese zus√§tzlichen Informationen werden unver√§ndert zum f√ºr dieses Modell ausgegebenen **JSON-Schema** hinzugef√ºgt und in der API-Dokumentation verwendet.

//// tab | Pydantic v2

In Pydantic Version 2 w√ºrden Sie das Attribut `model_config` verwenden, das ein `dict` akzeptiert, wie beschrieben in <a href="https://docs.pydantic.dev/latest/api/config/" class="external-link" target="_blank">Pydantic-Dokumentation: Configuration</a>.

Sie k√∂nnen `json_schema_extra` setzen, mit einem `dict`, das alle zus√§tzlichen Daten enth√§lt, die im generierten JSON-Schema angezeigt werden sollen, einschlie√ülich `examples`.

////

//// tab | Pydantic v1

In Pydantic Version 1 w√ºrden Sie eine interne Klasse `Config` und `schema_extra` verwenden, wie beschrieben in <a href="https://docs.pydantic.dev/1.10/usage/schema/#schema-customization" class="external-link" target="_blank">Pydantic-Dokumentation: Schema customization</a>.

Sie k√∂nnen `schema_extra` setzen, mit einem `dict`, das alle zus√§tzlichen Daten enth√§lt, die im generierten JSON-Schema angezeigt werden sollen, einschlie√ülich `examples`.

////

/// tip | Tipp

Mit derselben Technik k√∂nnen Sie das JSON-Schema erweitern und Ihre eigenen benutzerdefinierten Zusatzinformationen hinzuf√ºgen.

Sie k√∂nnten das beispielsweise verwenden, um Metadaten f√ºr eine Frontend-Benutzeroberfl√§che usw. hinzuzuf√ºgen.

///

/// info

OpenAPI 3.1.0 (verwendet seit FastAPI 0.99.0) hat Unterst√ºtzung f√ºr `examples` hinzugef√ºgt, was Teil des **JSON Schema** Standards ist.

Zuvor unterst√ºtzte es nur das Schl√ºsselwort `example` mit einem einzigen Beispiel. Dieses wird weiterhin von OpenAPI 3.1.0 unterst√ºtzt, ist jedoch <abbr title="deprecated ‚Äì obsolet, veraltet: Es soll nicht mehr verwendet werden">deprecated</abbr> und nicht Teil des JSON Schema Standards. Wir empfehlen Ihnen daher, von `example` nach `examples` zu migrieren. ü§ì

Mehr erfahren Sie am Ende dieser Seite.

///

## Zus√§tzliche Argumente f√ºr `Field`

Wenn Sie `Field()` mit Pydantic-Modellen verwenden, k√∂nnen Sie ebenfalls zus√§tzliche `examples` deklarieren:

{* ../../docs_src/schema_extra_example/tutorial002_py310.py hl[2,8:11] *}

## `examples` im JSON-Schema ‚Äì OpenAPI

Bei Verwendung von:

* `Path()`
* `Query()`
* `Header()`
* `Cookie()`
* `Body()`
* `Form()`
* `File()`

k√∂nnen Sie auch eine Gruppe von `examples` mit zus√§tzlichen Informationen deklarieren, die zu ihren **JSON-Schemas** innerhalb von **OpenAPI** hinzugef√ºgt werden.

### `Body` mit `examples`

Hier √ºbergeben wir `examples`, welches ein einzelnes Beispiel f√ºr die in `Body()` erwarteten Daten enth√§lt:

{* ../../docs_src/schema_extra_example/tutorial003_an_py310.py hl[22:29] *}

### Beispiel in der Dokumentations-Benutzeroberfl√§che

Mit jeder der oben genannten Methoden w√ºrde es in `/docs` so aussehen:

<img src="/img/tutorial/body-fields/image01.png">

### `Body` mit mehreren `examples`

Sie k√∂nnen nat√ºrlich auch mehrere `examples` √ºbergeben:

{* ../../docs_src/schema_extra_example/tutorial004_an_py310.py hl[23:38] *}

Wenn Sie das tun, werden die Beispiele Teil des internen **JSON-Schemas** f√ºr diese Body-Daten.

<abbr title="26.08.2023">W√§hrend dies geschrieben wird</abbr>, unterst√ºtzt Swagger UI, das f√ºr die Anzeige der Dokumentations-Benutzeroberfl√§che zust√§ndige Tool, jedoch nicht die Anzeige mehrerer Beispiele f√ºr die Daten in **JSON Schema**. Aber lesen Sie unten f√ºr einen Workaround weiter.

### OpenAPI-spezifische `examples`

Schon bevor **JSON Schema** `examples` unterst√ºtzte, unterst√ºtzte OpenAPI ein anderes Feld, das auch `examples` genannt wurde.

Diese **OpenAPI-spezifischen** `examples` finden sich in einem anderen Abschnitt der OpenAPI-Spezifikation. Sie sind **Details f√ºr jede *Pfadoperation***, nicht f√ºr jedes JSON-Schema.

Und Swagger UI unterst√ºtzt dieses spezielle Feld `examples` schon seit einiger Zeit. Sie k√∂nnen es also verwenden, um verschiedene **Beispiele in der Benutzeroberfl√§che der Dokumentation anzuzeigen**.

Das Format dieses OpenAPI-spezifischen Felds `examples` ist ein `dict` mit **mehreren Beispielen** (anstelle einer `list`e), jedes mit zus√§tzlichen Informationen, die auch zu **OpenAPI** hinzugef√ºgt werden.

Dies erfolgt nicht innerhalb jedes in OpenAPI enthaltenen JSON-Schemas, sondern au√üerhalb, in der *Pfadoperation*.

### Verwendung des Parameters `openapi_examples`

Sie k√∂nnen die OpenAPI-spezifischen `examples` in FastAPI mit dem Parameter `openapi_examples` deklarieren, f√ºr:

* `Path()`
* `Query()`
* `Header()`
* `Cookie()`
* `Body()`
* `Form()`
* `File()`

Die Schl√ºssel des `dict` identifizieren jedes Beispiel, und jeder Wert (`"value"`) ist ein weiteres `dict`.

Jedes spezifische Beispiel-`dict` in den `examples` kann Folgendes enthalten:

* `summary`: Kurze Beschreibung f√ºr das Beispiel.
* `description`: Eine lange Beschreibung, die Markdown-Text enthalten kann.
* `value`: Dies ist das tats√§chlich angezeigte Beispiel, z. B. ein `dict`.
* `externalValue`: Alternative zu `value`, eine URL, die auf das Beispiel verweist. Allerdings wird dies m√∂glicherweise nicht von so vielen Tools unterst√ºtzt wie `value`.

Sie k√∂nnen es so verwenden:

{* ../../docs_src/schema_extra_example/tutorial005_an_py310.py hl[23:49] *}

### OpenAPI-Beispiele in der Dokumentations-Benutzeroberfl√§che

Wenn `openapi_examples` zu `Body()` hinzugef√ºgt wird, w√ºrde `/docs` so aussehen:

<img src="/img/tutorial/body-fields/image02.png">

## Technische Details

/// tip | Tipp

Wenn Sie bereits **FastAPI** Version **0.99.0 oder h√∂her** verwenden, k√∂nnen Sie diese Details wahrscheinlich **√ºberspringen**.

Sie sind f√ºr √§ltere Versionen relevanter, bevor OpenAPI 3.1.0 verf√ºgbar war.

Sie k√∂nnen dies als eine kurze **Geschichtsstunde** zu OpenAPI und JSON Schema betrachten. ü§ì

///

/// warning | Achtung

Dies sind sehr technische Details zu den Standards **JSON Schema** und **OpenAPI**.

Wenn die oben genannten Ideen bereits f√ºr Sie funktionieren, reicht das m√∂glicherweise aus und Sie ben√∂tigen diese Details wahrscheinlich nicht, √ºberspringen Sie sie gerne.

///

Vor OpenAPI 3.1.0 verwendete OpenAPI eine √§ltere und modifizierte Version von **JSON Schema**.

JSON Schema hatte keine `examples`, daher f√ºgte OpenAPI seiner eigenen modifizierten Version ein eigenes `example`-Feld hinzu.

OpenAPI f√ºgte auch die Felder `example` und `examples` zu anderen Teilen der Spezifikation hinzu:

* <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#parameter-object" class="external-link" target="_blank">`Parameter Object` (in der Spezifikation)</a>, das verwendet wurde von FastAPIs:
    * `Path()`
    * `Query()`
    * `Header()`
    * `Cookie()`
* <a href="https://github.com/OAI/OpenAPI-Specification/blob/main/versions/3.1.0.md#media-type-object" class="external-link" target="_blank">`Request Body Object` im Feld `content` des `Media Type Object`s (in der Spezifikation)</a>, das verwendet wurde von FastAPIs:
    * `Body()`
    * `File()`
    * `Form()`

/// info

Dieser alte, OpenAPI-spezifische `examples`-Parameter hei√üt seit FastAPI `0.103.0` jetzt `openapi_examples`.

///

### JSON Schemas Feld `examples`

Aber dann f√ºgte JSON Schema ein <a href="https://json-schema.org/draft/2019-09/json-schema-validation.html#rfc.section.9.5" class="external-link" target="_blank">`examples`</a>-Feld zu einer neuen Version der Spezifikation hinzu.

Und dann basierte das neue OpenAPI 3.1.0 auf der neuesten Version (JSON Schema 2020-12), die dieses neue Feld `examples` enthielt.

Und jetzt hat dieses neue `examples`-Feld Vorrang vor dem alten (und benutzerdefinierten) `example`-Feld, im Singular, das jetzt deprecated ist.

Dieses neue `examples`-Feld in JSON Schema ist **nur eine `list`e** von Beispielen, kein Dict mit zus√§tzlichen Metadaten wie an den anderen Stellen in OpenAPI (oben beschrieben).

/// info

Selbst, nachdem OpenAPI 3.1.0 ver√∂ffentlicht wurde, mit dieser neuen, einfacheren Integration mit JSON Schema, unterst√ºtzte Swagger UI, das Tool, das die automatische Dokumentation bereitstellt, eine Zeit lang OpenAPI 3.1.0 nicht (das tut es seit Version 5.0.0 üéâ).

Aus diesem Grund verwendeten Versionen von FastAPI vor 0.99.0 immer noch Versionen von OpenAPI vor 3.1.0.

///

### Pydantic- und FastAPI-`examples`

Wenn Sie `examples` innerhalb eines Pydantic-Modells hinzuf√ºgen, indem Sie `schema_extra` oder `Field(examples=["something"])` verwenden, wird dieses Beispiel dem **JSON-Schema** f√ºr dieses Pydantic-Modell hinzugef√ºgt.

Und dieses **JSON-Schema** des Pydantic-Modells ist in der **OpenAPI** Ihrer API enthalten und wird dann in der Benutzeroberfl√§che der Dokumentation verwendet.

In Versionen von FastAPI vor 0.99.0 (0.99.0 und h√∂her verwenden das neuere OpenAPI 3.1.0), wenn Sie `example` oder `examples` mit einem der anderen Werkzeuge (`Query()`, `Body()`, usw.) verwendet haben, wurden diese Beispiele nicht zum JSON-Schema hinzugef√ºgt, das diese Daten beschreibt (nicht einmal zur OpenAPI-eigenen Version von JSON Schema), sondern direkt zur *Pfadoperation*-Deklaration in OpenAPI (au√üerhalb der Teile von OpenAPI, die JSON Schema verwenden).

Aber jetzt, da FastAPI 0.99.0 und h√∂her, OpenAPI 3.1.0 verwendet, das JSON Schema 2020-12 verwendet, und Swagger UI 5.0.0 und h√∂her, ist alles konsistenter und die Beispiele sind in JSON Schema enthalten.

### Swagger-Benutzeroberfl√§che und OpenAPI-spezifische `examples`.

Da die Swagger-Benutzeroberfl√§che derzeit nicht mehrere JSON Schema Beispiele unterst√ºtzt (Stand: 26.08.2023), hatten Benutzer keine M√∂glichkeit, mehrere Beispiele in der Dokumentation anzuzeigen.

Um dieses Problem zu l√∂sen, hat FastAPI `0.103.0` **Unterst√ºtzung** f√ºr die Deklaration desselben alten **OpenAPI-spezifischen** `examples`-Felds mit dem neuen Parameter `openapi_examples` hinzugef√ºgt. ü§ì

### Zusammenfassung

Ich habe immer gesagt, dass ich Geschichte nicht so sehr mag ... und jetzt schauen Sie mich an, wie ich ‚ÄûTechnikgeschichte‚Äú-Unterricht gebe. üòÖ

Kurz gesagt: **Upgraden Sie auf FastAPI 0.99.0 oder h√∂her**, und die Dinge sind viel **einfacher, konsistenter und intuitiver**, und Sie m√ºssen nicht alle diese historischen Details kennen. üòé


================================================
File: /docs/de/docs/tutorial/static-files.md
================================================
# Statische Dateien

Mit `StaticFiles` k√∂nnen Sie statische Dateien aus einem Verzeichnis automatisch bereitstellen.

## `StaticFiles` verwenden

* Importieren Sie `StaticFiles`.
* ‚ÄûMounten‚Äú Sie eine `StaticFiles()`-Instanz in einem bestimmten Pfad.

{* ../../docs_src/static_files/tutorial001.py hl[2,6] *}

/// note | Technische Details

Sie k√∂nnten auch `from starlette.staticfiles import StaticFiles` verwenden.

**FastAPI** stellt dasselbe `starlette.staticfiles` auch via `fastapi.staticfiles` bereit, als Annehmlichkeit f√ºr Sie, den Entwickler. Es kommt aber tats√§chlich direkt von Starlette.

///

### Was ist ‚ÄûMounten‚Äú?

‚ÄûMounten‚Äú bedeutet das Hinzuf√ºgen einer vollst√§ndigen ‚Äûunabh√§ngigen‚Äú Anwendung an einem bestimmten Pfad, die sich dann um die Handhabung aller Unterpfade k√ºmmert.

Dies unterscheidet sich von der Verwendung eines `APIRouter`, da eine gemountete Anwendung v√∂llig unabh√§ngig ist. Die OpenAPI und Dokumentation Ihrer Hauptanwendung enthalten nichts von der gemounteten Anwendung, usw.

Weitere Informationen hierzu finden Sie im [Handbuch f√ºr fortgeschrittene Benutzer](../advanced/index.md){.internal-link target=_blank}.

## Einzelheiten

Das erste `"/static"` bezieht sich auf den Unterpfad, auf dem diese ‚ÄûUnteranwendung‚Äú ‚Äûgemountet‚Äú wird. Daher wird jeder Pfad, der mit `"/static"` beginnt, von ihr verarbeitet.

Das `directory="static"` bezieht sich auf den Namen des Verzeichnisses, das Ihre statischen Dateien enth√§lt.

Das `name="static"` gibt dieser Unteranwendung einen Namen, der intern von **FastAPI** verwendet werden kann.

Alle diese Parameter k√∂nnen anders als "`static`" lauten, passen Sie sie an die Bed√ºrfnisse und spezifischen Details Ihrer eigenen Anwendung an.

## Weitere Informationen

Weitere Details und Optionen finden Sie in der <a href="https://www.starlette.io/staticfiles/" class="external-link" target="_blank">Dokumentation von Starlette zu statischen Dateien</a>.


================================================
File: /docs/de/docs/tutorial/testing.md
================================================
# Testen

Dank <a href="https://www.starlette.io/testclient/" class="external-link" target="_blank">Starlette</a> ist das Testen von **FastAPI**-Anwendungen einfach und macht Spa√ü.

Es basiert auf <a href="https://www.python-httpx.org" class="external-link" target="_blank">HTTPX</a>, welches wiederum auf der Grundlage von requests konzipiert wurde, es ist also sehr vertraut und intuitiv.

Damit k√∂nnen Sie <a href="https://docs.pytest.org/" class="external-link" target="_blank">pytest</a> direkt mit **FastAPI** verwenden.

## Verwendung von `TestClient`

/// info

Um `TestClient` zu verwenden, installieren Sie zun√§chst <a href="https://www.python-httpx.org" class="external-link" target="_blank">`httpx`</a>.

Z. B. `pip install httpx`.

///

Importieren Sie `TestClient`.

Erstellen Sie einen `TestClient`, indem Sie ihm Ihre **FastAPI**-Anwendung √ºbergeben.

Erstellen Sie Funktionen mit einem Namen, der mit `test_` beginnt (das sind `pytest`-Konventionen).

Verwenden Sie das `TestClient`-Objekt auf die gleiche Weise wie `httpx`.

Schreiben Sie einfache `assert`-Anweisungen mit den Standard-Python-Ausdr√ºcken, die Sie √ºberpr√ºfen m√ºssen (wiederum, Standard-`pytest`).

{* ../../docs_src/app_testing/tutorial001.py hl[2,12,15:18] *}

/// tip | Tipp

Beachten Sie, dass die Testfunktionen normal `def` und nicht `async def` sind.

Und die Anrufe an den Client sind ebenfalls normale Anrufe, die nicht `await` verwenden.

Dadurch k√∂nnen Sie `pytest` ohne Komplikationen direkt nutzen.

///

/// note | Technische Details

Sie k√∂nnten auch `from starlette.testclient import TestClient` verwenden.

**FastAPI** stellt denselben `starlette.testclient` auch via `fastapi.testclient` bereit, als Annehmlichkeit f√ºr Sie, den Entwickler. Es kommt aber tats√§chlich direkt von Starlette.

///

/// tip | Tipp

Wenn Sie in Ihren Tests neben dem Senden von Anfragen an Ihre FastAPI-Anwendung auch `async`-Funktionen aufrufen m√∂chten (z. B. asynchrone Datenbankfunktionen), werfen Sie einen Blick auf die [Async-Tests](../advanced/async-tests.md){.internal-link target=_blank} im Handbuch f√ºr fortgeschrittene Benutzer.

///

## Tests separieren

In einer echten Anwendung w√ºrden Sie Ihre Tests wahrscheinlich in einer anderen Datei haben.

Und Ihre **FastAPI**-Anwendung k√∂nnte auch aus mehreren Dateien/Modulen, usw. bestehen.

### **FastAPI** Anwendungsdatei

Nehmen wir an, Sie haben eine Dateistruktur wie in [Gr√∂√üere Anwendungen](bigger-applications.md){.internal-link target=_blank} beschrieben:

```
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ main.py
```

In der Datei `main.py` haben Sie Ihre **FastAPI**-Anwendung:


{* ../../docs_src/app_testing/main.py *}


### Testdatei

Dann k√∂nnten Sie eine Datei `test_main.py` mit Ihren Tests haben. Sie k√∂nnte sich im selben Python-Package befinden (dasselbe Verzeichnis mit einer `__init__.py`-Datei):

``` hl_lines="5"
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_main.py
```

Da sich diese Datei im selben Package befindet, k√∂nnen Sie relative Importe verwenden, um das Objekt `app` aus dem `main`-Modul (`main.py`) zu importieren:

{* ../../docs_src/app_testing/test_main.py hl[3] *}


... und haben den Code f√ºr die Tests wie zuvor.

## Testen: erweitertes Beispiel

Nun erweitern wir dieses Beispiel und f√ºgen weitere Details hinzu, um zu sehen, wie verschiedene Teile getestet werden.

### Erweiterte **FastAPI**-Anwendungsdatei

Fahren wir mit der gleichen Dateistruktur wie zuvor fort:

```
.
‚îú‚îÄ‚îÄ app
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ __init__.py
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ main.py
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ test_main.py
```

Nehmen wir an, dass die Datei `main.py` mit Ihrer **FastAPI**-Anwendung jetzt einige andere **Pfadoperationen** hat.

Sie verf√ºgt √ºber eine `GET`-Operation, die einen Fehler zur√ºckgeben k√∂nnte.

Sie verf√ºgt √ºber eine `POST`-Operation, die mehrere Fehler zur√ºckgeben k√∂nnte.

Beide *Pfadoperationen* erfordern einen `X-Token`-Header.

//// tab | Python 3.10+

```Python
{!> ../../docs_src/app_testing/app_b_an_py310/main.py!}
```

////

//// tab | Python 3.9+

```Python
{!> ../../docs_src/app_testing/app_b_an_py39/main.py!}
```

////

//// tab | Python 3.8+

```Python
{!> ../../docs_src/app_testing/app_b_an/main.py!}
```

////

//// tab | Python 3.10+ nicht annotiert

/// tip | Tipp

Bevorzugen Sie die `Annotated`-Version, falls m√∂glich.

///

```Python
{!> ../../docs_src/app_testing/app_b_py310/main.py!}
```

////

//// tab | Python 3.8+ nicht annotiert

/// tip | Tipp

Bevorzugen Sie die `Annotated`-Version, falls m√∂glich.

///

```Python
{!> ../../docs_src/app_testing/app_b/main.py!}
```

////

### Erweiterte Testdatei

Anschlie√üend k√∂nnten Sie `test_main.py` mit den erweiterten Tests aktualisieren:

{* ../../docs_src/app_testing/app_b/test_main.py *}


Wenn Sie m√∂chten, dass der Client Informationen im Request √ºbergibt und Sie nicht wissen, wie das geht, k√∂nnen Sie suchen (googeln), wie es mit `httpx` gemacht wird, oder sogar, wie es mit `requests` gemacht wird, da das Design von HTTPX auf dem Design von Requests basiert.

Dann machen Sie in Ihren Tests einfach das gleiche.

Z. B.:

* Um einen *Pfad*- oder *Query*-Parameter zu √ºbergeben, f√ºgen Sie ihn der URL selbst hinzu.
* Um einen JSON-Body zu √ºbergeben, √ºbergeben Sie ein Python-Objekt (z. B. ein `dict`) an den Parameter `json`.
* Wenn Sie *Formulardaten* anstelle von JSON senden m√ºssen, verwenden Sie stattdessen den `data`-Parameter.
* Um *Header* zu √ºbergeben, verwenden Sie ein `dict` im `headers`-Parameter.
* F√ºr *Cookies* ein `dict` im `cookies`-Parameter.

Weitere Informationen zum √úbergeben von Daten an das Backend (mithilfe von `httpx` oder dem `TestClient`) finden Sie in der <a href="https://www.python-httpx.org" class="external-link" target="_blank">HTTPX-Dokumentation</a>.

/// info

Beachten Sie, dass der `TestClient` Daten empf√§ngt, die nach JSON konvertiert werden k√∂nnen, keine Pydantic-Modelle.

Wenn Sie ein Pydantic-Modell in Ihrem Test haben und dessen Daten w√§hrend des Testens an die Anwendung senden m√∂chten, k√∂nnen Sie den `jsonable_encoder` verwenden, der in [JSON-kompatibler Encoder](encoder.md){.internal-link target=_blank} beschrieben wird.

///

## Tests ausf√ºhren

Danach m√ºssen Sie nur noch `pytest` installieren:

<div class="termy">

```console
$ pip install pytest

---> 100%
```

</div>

Es erkennt die Dateien und Tests automatisch, f√ºhrt sie aus und berichtet Ihnen die Ergebnisse.

F√ºhren Sie die Tests aus, mit:

<div class="termy">

```console
$ pytest

================ test session starts ================
platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1
rootdir: /home/user/code/superawesome-cli/app
plugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1
collected 6 items

---> 100%

test_main.py <span style="color: green; white-space: pre;">......                            [100%]</span>

<span style="color: green;">================= 1 passed in 0.03s =================</span>
```

</div>


================================================
File: /docs/de/docs/tutorial/dependencies/classes-as-dependencies.md
================================================
# Klassen als Abh√§ngigkeiten

Bevor wir tiefer in das **Dependency Injection** System eintauchen, lassen Sie uns das vorherige Beispiel verbessern.

## Ein `dict` aus dem vorherigen Beispiel

Im vorherigen Beispiel haben wir ein `dict` von unserer Abh√§ngigkeit (‚ÄûDependable‚Äú) zur√ºckgegeben:

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[9] *}

Aber dann haben wir ein `dict` im Parameter `commons` der *Pfadoperation-Funktion*.

Und wir wissen, dass Editoren nicht viel Unterst√ºtzung (wie etwa Code-Vervollst√§ndigung) f√ºr `dict`s bieten k√∂nnen, weil sie ihre Schl√ºssel- und Werttypen nicht kennen.

Das k√∂nnen wir besser machen ...

## Was macht eine Abh√§ngigkeit aus

Bisher haben Sie Abh√§ngigkeiten gesehen, die als Funktionen deklariert wurden.

Das ist jedoch nicht die einzige M√∂glichkeit, Abh√§ngigkeiten zu deklarieren (obwohl es wahrscheinlich die gebr√§uchlichste ist).

Der springende Punkt ist, dass eine Abh√§ngigkeit aufrufbar (‚Äûcallable‚Äú) sein sollte.

Ein ‚Äû**Callable**‚Äú in Python ist etwas, das wie eine Funktion aufgerufen werden kann (‚Äûto call‚Äú).

Wenn Sie also ein Objekt `something` haben (das m√∂glicherweise _keine_ Funktion ist) und Sie es wie folgt aufrufen (ausf√ºhren) k√∂nnen:

```Python
something()
```

oder

```Python
something(some_argument, some_keyword_argument="foo")
```

dann ist das ein ‚ÄûCallable‚Äú (ein ‚ÄûAufrufbares‚Äú).

## Klassen als Abh√§ngigkeiten

M√∂glicherweise stellen Sie fest, dass Sie zum Erstellen einer Instanz einer Python-Klasse die gleiche Syntax verwenden.

Zum Beispiel:

```Python
class Cat:
    def __init__(self, name: str):
        self.name = name


fluffy = Cat(name="Mr Fluffy")
```

In diesem Fall ist `fluffy` eine Instanz der Klasse `Cat`.

Und um `fluffy` zu erzeugen, rufen Sie `Cat` auf.

Eine Python-Klasse ist also auch ein **Callable**.

Darum k√∂nnen Sie in **FastAPI** auch eine Python-Klasse als Abh√§ngigkeit verwenden.

Was FastAPI tats√§chlich pr√ºft, ist, ob es sich um ein ‚ÄûCallable‚Äú (Funktion, Klasse oder irgendetwas anderes) handelt und ob die Parameter definiert sind.

Wenn Sie **FastAPI** ein ‚ÄûCallable‚Äú als Abh√§ngigkeit √ºbergeben, analysiert es die Parameter dieses ‚ÄûCallables‚Äú und verarbeitet sie auf die gleiche Weise wie die Parameter einer *Pfadoperation-Funktion*. Einschlie√ülich Unterabh√§ngigkeiten.

Das gilt auch f√ºr Callables ohne Parameter. So wie es auch f√ºr *Pfadoperation-Funktionen* ohne Parameter gilt.

Dann k√∂nnen wir das ‚ÄûDependable‚Äú `common_parameters` der Abh√§ngigkeit von oben in die Klasse `CommonQueryParams` √§ndern:

{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[11:15] *}

Achten Sie auf die Methode `__init__`, die zum Erstellen der Instanz der Klasse verwendet wird:

{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[12] *}

... sie hat die gleichen Parameter wie unsere vorherige `common_parameters`:

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[8] *}

Diese Parameter werden von **FastAPI** verwendet, um die Abh√§ngigkeit ‚Äûaufzul√∂sen‚Äú.

In beiden F√§llen wird sie haben:

* Einen optionalen `q`-Query-Parameter, der ein `str` ist.
* Einen `skip`-Query-Parameter, der ein `int` ist, mit einem Defaultwert `0`.
* Einen `limit`-Query-Parameter, der ein `int` ist, mit einem Defaultwert `100`.

In beiden F√§llen werden die Daten konvertiert, validiert, im OpenAPI-Schema dokumentiert, usw.

## Verwendung

Jetzt k√∂nnen Sie Ihre Abh√§ngigkeit mithilfe dieser Klasse deklarieren.

{* ../../docs_src/dependencies/tutorial002_an_py310.py hl[19] *}

**FastAPI** ruft die Klasse `CommonQueryParams` auf. Dadurch wird eine ‚ÄûInstanz‚Äú dieser Klasse erstellt und die Instanz wird als Parameter `commons` an Ihre Funktion √ºberreicht.

## Typannotation vs. `Depends`

Beachten Sie, wie wir `CommonQueryParams` im obigen Code zweimal schreiben:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
```

////

//// tab | Python 3.8+ nicht annotiert

/// tip | Tipp

Bevorzugen Sie die `Annotated`-Version, falls m√∂glich.

///

```Python
commons: CommonQueryParams = Depends(CommonQueryParams)
```

////

Das letzte `CommonQueryParams`, in:

```Python
... Depends(CommonQueryParams)
```

... ist das, was **FastAPI** tats√§chlich verwendet, um die Abh√§ngigkeit zu ermitteln.

Aus diesem extrahiert FastAPI die deklarierten Parameter, und dieses ist es, was FastAPI auch aufruft.

---

In diesem Fall hat das erste `CommonQueryParams` in:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, ...
```

////

//// tab | Python 3.8+ nicht annotiert

/// tip | Tipp

Bevorzugen Sie die `Annotated`-Version, falls m√∂glich.

///

```Python
commons: CommonQueryParams ...
```

////

... keine besondere Bedeutung f√ºr **FastAPI**. FastAPI verwendet es nicht f√ºr die Datenkonvertierung, -validierung, usw. (da es daf√ºr `Depends(CommonQueryParams)` verwendet).

Sie k√∂nnten tats√§chlich einfach schreiben:

//// tab | Python 3.8+

```Python
commons: Annotated[Any, Depends(CommonQueryParams)]
```

////

//// tab | Python 3.8+ nicht annotiert

/// tip | Tipp

Bevorzugen Sie die `Annotated`-Version, falls m√∂glich.

///

```Python
commons = Depends(CommonQueryParams)
```

////

... wie in:

{* ../../docs_src/dependencies/tutorial003_an_py310.py hl[19] *}

Es wird jedoch empfohlen, den Typ zu deklarieren, da Ihr Editor so wei√ü, was als Parameter `commons` √ºbergeben wird, und Ihnen dann bei der Codevervollst√§ndigung, Typpr√ºfungen, usw. helfen kann:

<img src="/img/tutorial/dependencies/image02.png">

## Abk√ºrzung

Aber Sie sehen, dass wir hier etwas Codeduplizierung haben, indem wir `CommonQueryParams` zweimal schreiben:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
```

////

//// tab | Python 3.8+ nicht annotiert

/// tip | Tipp

Bevorzugen Sie die `Annotated`-Version, falls m√∂glich.

///

```Python
commons: CommonQueryParams = Depends(CommonQueryParams)
```

////

**FastAPI** bietet eine Abk√ºrzung f√ºr diese F√§lle, wo die Abh√§ngigkeit *speziell* eine Klasse ist, welche **FastAPI** aufruft, um eine Instanz der Klasse selbst zu erstellen.

In diesem speziellen Fall k√∂nnen Sie Folgendes tun:

Anstatt zu schreiben:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, Depends(CommonQueryParams)]
```

////

//// tab | Python 3.8+ nicht annotiert

/// tip | Tipp

Bevorzugen Sie die `Annotated`-Version, falls m√∂glich.

///

```Python
commons: CommonQueryParams = Depends(CommonQueryParams)
```

////

... schreiben Sie:

//// tab | Python 3.8+

```Python
commons: Annotated[CommonQueryParams, Depends()]
```

////

//// tab | Python 3.8 nicht annotiert

/// tip | Tipp

Bevorzugen Sie die `Annotated`-Version, falls m√∂glich.

///

```Python
commons: CommonQueryParams = Depends()
```

////

Sie deklarieren die Abh√§ngigkeit als Typ des Parameters und verwenden `Depends()` ohne Parameter, anstatt die vollst√§ndige Klasse *erneut* in `Depends(CommonQueryParams)` schreiben zu m√ºssen.

Dasselbe Beispiel w√ºrde dann so aussehen:

{* ../../docs_src/dependencies/tutorial004_an_py310.py hl[19] *}

... und **FastAPI** wird wissen, was zu tun ist.

/// tip | Tipp

Wenn Sie das eher verwirrt, als Ihnen zu helfen, ignorieren Sie es, Sie *brauchen* es nicht.

Es ist nur eine Abk√ºrzung. Es geht **FastAPI** darum, Ihnen dabei zu helfen, Codeverdoppelung zu minimieren.

///


================================================
File: /docs/de/docs/tutorial/dependencies/dependencies-in-path-operation-decorators.md
================================================
# Abh√§ngigkeiten in Pfadoperation-Dekoratoren

Manchmal ben√∂tigen Sie den R√ºckgabewert einer Abh√§ngigkeit innerhalb Ihrer *Pfadoperation-Funktion* nicht wirklich.

Oder die Abh√§ngigkeit gibt keinen Wert zur√ºck.

Aber Sie m√ºssen Sie trotzdem ausf√ºhren/aufl√∂sen.

In diesen F√§llen k√∂nnen Sie, anstatt einen Parameter der *Pfadoperation-Funktion* mit `Depends` zu deklarieren, eine `list`e von `dependencies` zum *Pfadoperation-Dekorator* hinzuf√ºgen.

## `dependencies` zum *Pfadoperation-Dekorator* hinzuf√ºgen

Der *Pfadoperation-Dekorator* erh√§lt ein optionales Argument `dependencies`.

Es sollte eine `list`e von `Depends()` sein:

{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[19] *}

Diese Abh√§ngigkeiten werden auf die gleiche Weise wie normale Abh√§ngigkeiten ausgef√ºhrt/aufgel√∂st. Aber ihr Wert (falls sie einen zur√ºckgeben) wird nicht an Ihre *Pfadoperation-Funktion* √ºbergeben.

/// tip | Tipp

Einige Editoren pr√ºfen, ob Funktionsparameter nicht verwendet werden, und zeigen das als Fehler an.

Wenn Sie `dependencies` im *Pfadoperation-Dekorator* verwenden, stellen Sie sicher, dass sie ausgef√ºhrt werden, w√§hrend gleichzeitig Ihr Editor/Ihre Tools keine Fehlermeldungen ausgeben.

Damit wird auch vermieden, neue Entwickler m√∂glicherweise zu verwirren, die einen nicht verwendeten Parameter in Ihrem Code sehen und ihn f√ºr unn√∂tig halten k√∂nnten.

///

/// info

In diesem Beispiel verwenden wir zwei erfundene benutzerdefinierte Header `X-Key` und `X-Token`.

Aber in realen F√§llen w√ºrden Sie bei der Implementierung von Sicherheit mehr Vorteile durch die Verwendung der integrierten [Sicherheits-Werkzeuge (siehe n√§chstes Kapitel)](../security/index.md){.internal-link target=_blank} erzielen.

///

## Abh√§ngigkeitsfehler und -R√ºckgabewerte

Sie k√∂nnen dieselben Abh√§ngigkeits-*Funktionen* verwenden, die Sie normalerweise verwenden.

### Abh√§ngigkeitsanforderungen

Sie k√∂nnen Anforderungen f√ºr einen Request (wie Header) oder andere Unterabh√§ngigkeiten deklarieren:

{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[8,13] *}

### Exceptions ausl√∂sen

Die Abh√§ngigkeiten k√∂nnen Exceptions `raise`n, genau wie normale Abh√§ngigkeiten:

{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[10,15] *}

### R√ºckgabewerte

Und sie k√∂nnen Werte zur√ºckgeben oder nicht, die Werte werden nicht verwendet.

Sie k√∂nnen also eine normale Abh√§ngigkeit (die einen Wert zur√ºckgibt), die Sie bereits an anderer Stelle verwenden, wiederverwenden, und auch wenn der Wert nicht verwendet wird, wird die Abh√§ngigkeit ausgef√ºhrt:

{* ../../docs_src/dependencies/tutorial006_an_py39.py hl[11,16] *}

## Abh√§ngigkeiten f√ºr eine Gruppe von *Pfadoperationen*

Wenn Sie sp√§ter lesen, wie Sie gr√∂√üere Anwendungen strukturieren ([Gr√∂√üere Anwendungen ‚Äì Mehrere Dateien](../../tutorial/bigger-applications.md){.internal-link target=_blank}), m√∂glicherweise mit mehreren Dateien, lernen Sie, wie Sie einen einzelnen `dependencies`-Parameter f√ºr eine Gruppe von *Pfadoperationen* deklarieren.

## Globale Abh√§ngigkeiten

Als N√§chstes werden wir sehen, wie man Abh√§ngigkeiten zur gesamten `FastAPI`-Anwendung hinzuf√ºgt, sodass sie f√ºr jede *Pfadoperation* gelten.


================================================
File: /docs/de/docs/tutorial/dependencies/dependencies-with-yield.md
================================================
# Abh√§ngigkeiten mit yield

FastAPI unterst√ºtzt Abh√§ngigkeiten, die nach Abschluss einige <abbr title="Manchmal auch genannt ‚ÄûExit Code‚Äú, ‚ÄûCleanup Code‚Äú, ‚ÄûTeardown Code‚Äú, ‚ÄûClosing Code‚Äú, ‚ÄûKontext Manager Exit Code‚Äú, usw.">zus√§tzliche Schritte ausf√ºhren</abbr>.

Verwenden Sie dazu `yield` statt `return` und schreiben Sie die zus√§tzlichen Schritte / den zus√§tzlichen Code danach.

/// tip | Tipp

Stellen Sie sicher, dass Sie `yield` nur einmal pro Abh√§ngigkeit verwenden.

///

/// note | Technische Details

Jede Funktion, die dekoriert werden kann mit:

* <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" class="external-link" target="_blank">`@contextlib.contextmanager`</a> oder
* <a href="https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager" class="external-link" target="_blank">`@contextlib.asynccontextmanager`</a>

kann auch als g√ºltige **FastAPI**-Abh√§ngigkeit verwendet werden.

Tats√§chlich verwendet FastAPI diese beiden Dekoratoren intern.

///

## Eine Datenbank-Abh√§ngigkeit mit `yield`.

Sie k√∂nnten damit beispielsweise eine Datenbanksession erstellen und diese nach Abschluss schlie√üen.

Nur der Code vor und einschlie√ülich der `yield`-Anweisung wird ausgef√ºhrt, bevor eine Response erzeugt wird:

{* ../../docs_src/dependencies/tutorial007.py hl[2:4] *}

Der ge`yield`ete Wert ist das, was in *Pfadoperationen* und andere Abh√§ngigkeiten eingef√ºgt wird:

{* ../../docs_src/dependencies/tutorial007.py hl[4] *}

Der auf die `yield`-Anweisung folgende Code wird ausgef√ºhrt, nachdem die Response gesendet wurde:

{* ../../docs_src/dependencies/tutorial007.py hl[5:6] *}

/// tip | Tipp

Sie k√∂nnen `async`hrone oder regul√§re Funktionen verwenden.

**FastAPI** wird bei jeder das Richtige tun, so wie auch bei normalen Abh√§ngigkeiten.

///

## Eine Abh√§ngigkeit mit `yield` und `try`.

Wenn Sie einen `try`-Block in einer Abh√§ngigkeit mit `yield` verwenden, empfangen Sie alle Exceptions, die bei Verwendung der Abh√§ngigkeit geworfen wurden.

Wenn beispielsweise ein Code irgendwann in der Mitte, in einer anderen Abh√§ngigkeit oder in einer *Pfadoperation*, ein ‚ÄûRollback‚Äú einer Datenbanktransaktion oder einen anderen Fehler verursacht, empfangen Sie die resultierende Exception in Ihrer Abh√§ngigkeit.

Sie k√∂nnen also mit `except SomeException` diese bestimmte Exception innerhalb der Abh√§ngigkeit handhaben.

Auf die gleiche Weise k√∂nnen Sie `finally` verwenden, um sicherzustellen, dass die Exit-Schritte ausgef√ºhrt werden, unabh√§ngig davon, ob eine Exception geworfen wurde oder nicht.

{* ../../docs_src/dependencies/tutorial007.py hl[3,5] *}

## Unterabh√§ngigkeiten mit `yield`.

Sie k√∂nnen Unterabh√§ngigkeiten und ‚ÄûB√§ume‚Äú von Unterabh√§ngigkeiten beliebiger Gr√∂√üe und Form haben, und einige oder alle davon k√∂nnen `yield` verwenden.

**FastAPI** stellt sicher, dass der ‚ÄûExit-Code‚Äú in jeder Abh√§ngigkeit mit `yield` in der richtigen Reihenfolge ausgef√ºhrt wird.

Beispielsweise kann `dependency_c` von `dependency_b` und `dependency_b` von `dependency_a` abh√§ngen:

{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[6,14,22] *}

Und alle k√∂nnen `yield` verwenden.

In diesem Fall ben√∂tigt `dependency_c` zum Ausf√ºhren seines Exit-Codes, dass der Wert von `dependency_b` (hier `dep_b` genannt) verf√ºgbar ist.

Und wiederum ben√∂tigt `dependency_b` den Wert von `dependency_a` (hier `dep_a` genannt) f√ºr seinen Exit-Code.

{* ../../docs_src/dependencies/tutorial008_an_py39.py hl[18:19,26:27] *}

Auf die gleiche Weise k√∂nnten Sie einige Abh√§ngigkeiten mit `yield` und einige andere Abh√§ngigkeiten mit `return` haben, und alle k√∂nnen beliebig voneinander abh√§ngen.

Und Sie k√∂nnten eine einzelne Abh√§ngigkeit haben, die auf mehreren ge`yield`eten Abh√§ngigkeiten basiert, usw.

Sie k√∂nnen beliebige Kombinationen von Abh√§ngigkeiten haben.

**FastAPI** stellt sicher, dass alles in der richtigen Reihenfolge ausgef√ºhrt wird.

/// note | Technische Details

Dieses funktioniert dank Pythons <a href="https://docs.python.org/3/library/contextlib.html" class="external-link" target="_blank">Kontextmanager</a>.

**FastAPI** verwendet sie intern, um das zu erreichen.

///

## Abh√§ngigkeiten mit `yield` und `HTTPException`.

Sie haben gesehen, dass Ihre Abh√§ngigkeiten `yield` verwenden k√∂nnen und `try`-Bl√∂cke haben k√∂nnen, die Exceptions abfangen.

Auf die gleiche Weise k√∂nnten Sie im Exit-Code nach dem `yield` eine `HTTPException` oder √§hnliches ausl√∂sen.

/// tip | Tipp

Dies ist eine etwas fortgeschrittene Technik, die Sie in den meisten F√§llen nicht wirklich ben√∂tigen, da Sie Exceptions (einschlie√ülich `HTTPException`) innerhalb des restlichen Anwendungscodes ausl√∂sen k√∂nnen, beispielsweise in der *Pfadoperation-Funktion*.

Aber es ist f√ºr Sie da, wenn Sie es brauchen. ü§ì

///

{* ../../docs_src/dependencies/tutorial008b_an_py39.py hl[18:22,31] *}

Eine Alternative zum Abfangen von Exceptions (und m√∂glicherweise auch zum Ausl√∂sen einer weiteren `HTTPException`) besteht darin, einen [benutzerdefinierten Exceptionhandler](../handling-errors.md#benutzerdefinierte-exceptionhandler-definieren){.internal-link target=_blank} zu erstellen.

## Ausf√ºhrung von Abh√§ngigkeiten mit `yield`

Die Ausf√ºhrungsreihenfolge √§hnelt mehr oder weniger dem folgenden Diagramm. Die Zeit verl√§uft von oben nach unten. Und jede Spalte ist einer der interagierenden oder Code-ausf√ºhrenden Teilnehmer.

```mermaid
sequenceDiagram

participant client as Client
participant handler as Exceptionhandler
participant dep as Abh√§ngigkeit mit yield
participant operation as Pfadoperation
participant tasks as Hintergrundtasks

    Note over client,operation: Kann Exceptions ausl√∂sen, inklusive HTTPException
    client ->> dep: Startet den Request
    Note over dep: F√ºhrt den Code bis zum yield aus
    opt L√∂st Exception aus
        dep -->> handler: L√∂st Exception aus
        handler -->> client: HTTP-Error-Response
    end
    dep ->> operation: F√ºhrt Abh√§ngigkeit aus, z. B. DB-Session
    opt L√∂st aus
        operation -->> dep: L√∂st Exception aus (z. B. HTTPException)
        opt Handhabt
            dep -->> dep: Kann Exception abfangen, eine neue HTTPException ausl√∂sen, andere Exceptions ausl√∂sen
            dep -->> handler: Leitet Exception automatisch weiter
        end
        handler -->> client: HTTP-Error-Response
    end
    operation ->> client: Sendet Response an Client
    Note over client,operation: Response wurde gesendet, kann nicht mehr ge√§ndert werden
    opt Tasks
        operation -->> tasks: Sendet Hintergrundtasks
    end
    opt L√∂st andere Exception aus
        tasks -->> tasks: Handhabt Exception im Hintergrundtask-Code
    end
```

/// info

Es wird nur **eine Response** an den Client gesendet. Es kann eine Error-Response oder die Response der *Pfadoperation* sein.

Nachdem eine dieser Responses gesendet wurde, kann keine weitere Response gesendet werden.

///

/// tip | Tipp

Obiges Diagramm verwendet `HTTPException`, aber Sie k√∂nnen auch jede andere Exception ausl√∂sen, die Sie in einer Abh√§ngigkeit mit `yield` abfangen, oder mit einem [benutzerdefinierten Exceptionhandler](../handling-errors.md#benutzerdefinierte-exceptionhandler-definieren){.internal-link target=_blank} erstellt haben.

Wenn Sie eine Exception ausl√∂sen, wird diese mit yield an die Abh√§ngigkeiten √ºbergeben, einschlie√ülich `HTTPException`, und dann **erneut** an die Exceptionhandler. Wenn es f√ºr diese Exception keinen Exceptionhandler gibt, wird sie von der internen Default-`ServerErrorMiddleware` gehandhabt, was einen HTTP-Statuscode 500 zur√ºckgibt, um den Client dar√ºber zu informieren, dass ein Fehler auf dem Server aufgetreten ist.

///

## Abh√§ngigkeiten mit `yield`, `HTTPException` und Hintergrundtasks

/// warning | Achtung

Sie ben√∂tigen diese technischen Details h√∂chstwahrscheinlich nicht, Sie k√∂nnen diesen Abschnitt √ºberspringen und weiter unten fortfahren.

Diese Details sind vor allem dann n√ºtzlich, wenn Sie eine Version von FastAPI vor 0.106.0 verwendet haben und Ressourcen aus Abh√§ngigkeiten mit `yield` in Hintergrundtasks verwendet haben.

///

Vor FastAPI 0.106.0 war das Ausl√∂sen von Exceptions nach `yield` nicht m√∂glich, der Exit-Code in Abh√§ngigkeiten mit `yield` wurde ausgef√ºhrt, *nachdem* die Response gesendet wurde, die [Exceptionhandler](../handling-errors.md#benutzerdefinierte-exceptionhandler-definieren){.internal-link target=_blank} w√§ren also bereits ausgef√ºhrt worden.

Dies wurde haupts√§chlich so konzipiert, damit die gleichen Objekte, die durch Abh√§ngigkeiten ge`yield`et werden, innerhalb von Hintergrundtasks verwendet werden k√∂nnen, da der Exit-Code ausgef√ºhrt wird, nachdem die Hintergrundtasks abgeschlossen sind.

Da dies jedoch bedeuten w√ºrde, darauf zu warten, dass die Response durch das Netzwerk reist, w√§hrend eine Ressource unn√∂tigerweise in einer Abh√§ngigkeit mit yield gehalten wird (z. B. eine Datenbankverbindung), wurde dies in FastAPI 0.106.0 ge√§ndert.

/// tip | Tipp

Dar√ºber hinaus handelt es sich bei einem Hintergrundtask normalerweise um einen unabh√§ngigen Satz von Logik, der separat behandelt werden sollte, mit eigenen Ressourcen (z. B. einer eigenen Datenbankverbindung).

Auf diese Weise erhalten Sie wahrscheinlich saubereren Code.

///

Wenn Sie sich fr√ºher auf dieses Verhalten verlassen haben, sollten Sie jetzt die Ressourcen f√ºr Hintergrundtasks innerhalb des Hintergrundtasks selbst erstellen und intern nur Daten verwenden, die nicht von den Ressourcen von Abh√§ngigkeiten mit `yield` abh√§ngen.

Anstatt beispielsweise dieselbe Datenbanksitzung zu verwenden, w√ºrden Sie eine neue Datenbanksitzung innerhalb des Hintergrundtasks erstellen und die Objekte mithilfe dieser neuen Sitzung aus der Datenbank abrufen. Und anstatt das Objekt aus der Datenbank als Parameter an die Hintergrundtask-Funktion zu √ºbergeben, w√ºrden Sie die ID dieses Objekts √ºbergeben und das Objekt dann innerhalb der Hintergrundtask-Funktion erneut laden.

## Kontextmanager

### Was sind ‚ÄûKontextmanager‚Äú

‚ÄûKontextmanager‚Äú (Englisch ‚ÄûContext Manager‚Äú) sind bestimmte Python-Objekte, die Sie in einer `with`-Anweisung verwenden k√∂nnen.

Beispielsweise k√∂nnen Sie <a href="https://docs.python.org/3/tutorial/inputoutput.html#reading-and-writing-files" class="external-link" target="_blank">`with` verwenden, um eine Datei auszulesen</a>:

```Python
with open("./somefile.txt") as f:
    contents = f.read()
    print(contents)
```

Im Hintergrund erstellt das `open("./somefile.txt")` ein Objekt, das als ‚ÄûKontextmanager‚Äú bezeichnet wird.

Dieser stellt sicher dass, wenn der `with`-Block beendet ist, die Datei geschlossen wird, auch wenn Exceptions geworfen wurden.

Wenn Sie eine Abh√§ngigkeit mit `yield` erstellen, erstellt **FastAPI** daf√ºr intern einen Kontextmanager und kombiniert ihn mit einigen anderen zugeh√∂rigen Tools.

### Kontextmanager in Abh√§ngigkeiten mit `yield` verwenden

/// warning | Achtung

Dies ist mehr oder weniger eine ‚Äûfortgeschrittene‚Äú Idee.

Wenn Sie gerade erst mit **FastAPI** beginnen, m√∂chten Sie das vielleicht vorerst √ºberspringen.

///

In Python k√∂nnen Sie Kontextmanager erstellen, indem Sie <a href="https://docs.python.org/3/reference/datamodel.html#context-managers" class="external-link" target="_blank">eine Klasse mit zwei Methoden erzeugen: `__enter__()` und `__exit__()`</a>.

Sie k√∂nnen solche auch innerhalb von **FastAPI**-Abh√§ngigkeiten mit `yield` verwenden, indem Sie `with`- oder `async with`-Anweisungen innerhalb der Abh√§ngigkeits-Funktion verwenden:

{* ../../docs_src/dependencies/tutorial010.py hl[1:9,13] *}

/// tip | Tipp

Andere M√∂glichkeiten, einen Kontextmanager zu erstellen, sind:

* <a href="https://docs.python.org/3/library/contextlib.html#contextlib.contextmanager" class="external-link" target="_blank">`@contextlib.contextmanager`</a> oder
* <a href="https://docs.python.org/3/library/contextlib.html#contextlib.asynccontextmanager" class="external-link" target="_blank">`@contextlib.asynccontextmanager`</a>

Verwenden Sie diese, um eine Funktion zu dekorieren, die ein einziges `yield` hat.

Das ist es auch, was **FastAPI** intern f√ºr Abh√§ngigkeiten mit `yield` verwendet.

Aber Sie m√ºssen die Dekoratoren nicht f√ºr FastAPI-Abh√§ngigkeiten verwenden (und das sollten Sie auch nicht).

FastAPI erledigt das intern f√ºr Sie.

///


================================================
File: /docs/de/docs/tutorial/dependencies/global-dependencies.md
================================================
# Globale Abh√§ngigkeiten

Bei einigen Anwendungstypen m√∂chten Sie m√∂glicherweise Abh√§ngigkeiten zur gesamten Anwendung hinzuf√ºgen.

√Ñhnlich wie Sie [`dependencies` zu den *Pfadoperation-Dekoratoren* hinzuf√ºgen](dependencies-in-path-operation-decorators.md){.internal-link target=_blank} k√∂nnen, k√∂nnen Sie sie auch zur `FastAPI`-Anwendung hinzuf√ºgen.

In diesem Fall werden sie auf alle *Pfadoperationen* in der Anwendung angewendet:

{* ../../docs_src/dependencies/tutorial012_an_py39.py hl[16] *}

Und alle Ideen aus dem Abschnitt √ºber das [Hinzuf√ºgen von `dependencies` zu den *Pfadoperation-Dekoratoren*](dependencies-in-path-operation-decorators.md){.internal-link target=_blank} gelten weiterhin, aber in diesem Fall f√ºr alle *Pfadoperationen* in der Anwendung.

## Abh√§ngigkeiten f√ºr Gruppen von *Pfadoperationen*

Wenn Sie sp√§ter lesen, wie Sie gr√∂√üere Anwendungen strukturieren ([Bigger Applications - Multiple Files](../../tutorial/bigger-applications.md){.internal-link target=_blank}), m√∂glicherweise mit mehreren Dateien, lernen Sie, wie Sie einen einzelnen `dependencies`-Parameter f√ºr eine Gruppe von *Pfadoperationen* deklarieren.


================================================
File: /docs/de/docs/tutorial/dependencies/index.md
================================================
# Abh√§ngigkeiten

**FastAPI** hat ein sehr m√§chtiges, aber intuitives **<abbr title="Dependency Injection ‚Äì Einbringen von Abh√§ngigkeiten: Auch bekannt als Komponenten, Ressourcen, Provider, Services, Injectables">Dependency Injection</abbr>** System.

Es ist so konzipiert, sehr einfach zu verwenden zu sein und es jedem Entwickler sehr leicht zu machen, andere Komponenten mit **FastAPI** zu integrieren.

## Was ist ‚ÄûDependency Injection‚Äú

**‚ÄûDependency Injection‚Äú** bedeutet in der Programmierung, dass es f√ºr Ihren Code (in diesem Fall Ihre *Pfadoperation-Funktionen*) eine M√∂glichkeit gibt, Dinge zu deklarieren, die er verwenden m√∂chte und die er zum Funktionieren ben√∂tigt: ‚ÄûAbh√§ngigkeiten‚Äú ‚Äì ‚ÄûDependencies‚Äú.

Das System (in diesem Fall **FastAPI**) k√ºmmert sich dann darum, Ihren Code mit den erforderlichen Abh√§ngigkeiten zu versorgen (‚Äûdie Abh√§ngigkeiten einf√ºgen‚Äú ‚Äì ‚Äûinject the dependencies‚Äú).

Das ist sehr n√ºtzlich, wenn Sie:

* Eine gemeinsame Logik haben (die gleiche Code-Logik immer und immer wieder).
* Datenbankverbindungen teilen.
* Sicherheit, Authentifizierung, Rollenanforderungen, usw. durchsetzen.
* Und viele andere Dinge ...

All dies, w√§hrend Sie Codeverdoppelung minimieren.

## Erste Schritte

Sehen wir uns ein sehr einfaches Beispiel an. Es ist so einfach, dass es vorerst nicht sehr n√ºtzlich ist.

Aber so k√∂nnen wir uns besser auf die Funktionsweise des **Dependency Injection** Systems konzentrieren.

### Erstellen Sie eine Abh√§ngigkeit (<abbr title="Das von dem abh√§ngt, die zu verwendende Abh√§ngigkeit">‚ÄûDependable‚Äú</abbr>)

Konzentrieren wir uns zun√§chst auf die Abh√§ngigkeit - die Dependency.

Es handelt sich einfach um eine Funktion, die die gleichen Parameter entgegennimmt wie eine *Pfadoperation-Funktion*:
{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[8:9] *}

Das war's schon.

**Zwei Zeilen**.

Und sie hat die gleiche Form und Struktur wie alle Ihre *Pfadoperation-Funktionen*.

Sie k√∂nnen sie sich als *Pfadoperation-Funktion* ohne den ‚ÄûDekorator‚Äú (ohne `@app.get("/some-path")`) vorstellen.

Und sie kann alles zur√ºckgeben, was Sie m√∂chten.

In diesem Fall erwartet diese Abh√§ngigkeit:

* Einen optionalen Query-Parameter `q`, der ein `str` ist.
* Einen optionalen Query-Parameter `skip`, der ein `int` ist und standardm√§√üig `0` ist.
* Einen optionalen Query-Parameter `limit`, der ein `int` ist und standardm√§√üig `100` ist.

Und dann wird einfach ein `dict` zur√ºckgegeben, welches diese Werte enth√§lt.

/// info

FastAPI unterst√ºtzt (und empfiehlt die Verwendung von) `Annotated` seit Version 0.95.0.

Wenn Sie eine √§ltere Version haben, werden Sie Fehler angezeigt bekommen, wenn Sie versuchen, `Annotated` zu verwenden.

Bitte [aktualisieren Sie FastAPI](../../deployment/versions.md#upgrade-der-fastapi-versionen){.internal-link target=_blank} daher mindestens zu Version 0.95.1, bevor Sie `Annotated` verwenden.

///

### `Depends` importieren

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[3] *}

### Deklarieren der Abh√§ngigkeit im <abbr title="Das Abh√§ngige, der Verwender der Abh√§ngigkeit">‚ÄûDependant‚Äú</abbr>

So wie auch `Body`, `Query`, usw., verwenden Sie `Depends` mit den Parametern Ihrer *Pfadoperation-Funktion*:

{* ../../docs_src/dependencies/tutorial001_an_py310.py hl[13,18] *}

Obwohl Sie `Depends` in den Parametern Ihrer Funktion genauso verwenden wie `Body`, `Query`, usw., funktioniert `Depends` etwas anders.

Sie √ºbergeben `Depends` nur einen einzigen Parameter.

Dieser Parameter muss so etwas wie eine Funktion sein.

Sie **rufen diese nicht direkt auf** (f√ºgen Sie am Ende keine Klammern hinzu), sondern √ºbergeben sie einfach als Parameter an `Depends()`.

Und diese Funktion akzeptiert Parameter auf die gleiche Weise wie *Pfadoperation-Funktionen*.

/// tip | Tipp

Im n√§chsten Kapitel erfahren Sie, welche anderen ‚ÄûDinge‚Äú, au√üer Funktionen, Sie als Abh√§ngigkeiten verwenden k√∂nnen.

///

Immer wenn ein neuer Request eintrifft, k√ºmmert sich **FastAPI** darum:

* Ihre Abh√§ngigkeitsfunktion (‚ÄûDependable‚Äú) mit den richtigen Parametern aufzurufen.
* Sich das Ergebnis von dieser Funktion zu holen.
* Dieses Ergebnis dem Parameter Ihrer *Pfadoperation-Funktion* zuzuweisen.

```mermaid
graph TB

common_parameters(["common_parameters"])
read_items["/items/"]
read_users["/users/"]

common_parameters --> read_items
common_parameters --> read_users
```

Auf diese Weise schreiben Sie gemeinsam genutzten Code nur einmal, und **FastAPI** k√ºmmert sich darum, ihn f√ºr Ihre *Pfadoperationen* aufzurufen.

/// check

Beachten Sie, dass Sie keine spezielle Klasse erstellen und diese irgendwo an **FastAPI** √ºbergeben m√ºssen, um sie zu ‚Äûregistrieren‚Äú oder so √§hnlich.

Sie √ºbergeben es einfach an `Depends` und **FastAPI** wei√ü, wie der Rest erledigt wird.

///

## `Annotated`-Abh√§ngigkeiten wiederverwenden

In den Beispielen oben sehen Sie, dass es ein kleines bisschen **Codeverdoppelung** gibt.

Wenn Sie die Abh√§ngigkeit `common_parameters()` verwenden, m√ºssen Sie den gesamten Parameter mit der Typannotation und `Depends()` schreiben:

```Python
commons: Annotated[dict, Depends(common_parameters)]
```

Da wir jedoch `Annotated` verwenden, k√∂nnen wir diesen `Annotated`-Wert in einer Variablen speichern und an mehreren Stellen verwenden:

{* ../../docs_src/dependencies/tutorial001_02_an_py310.py hl[12,16,21] *}

/// tip | Tipp

Das ist schlicht Standard-Python, es wird als ‚ÄûTypalias‚Äú bezeichnet und ist eigentlich nicht **FastAPI**-spezifisch.

Da **FastAPI** jedoch auf Standard-Python, einschlie√ülich `Annotated`, basiert, k√∂nnen Sie diesen Trick in Ihrem Code verwenden. üòé

///

Die Abh√§ngigkeiten funktionieren weiterhin wie erwartet, und das **Beste daran** ist, dass die **Typinformationen erhalten bleiben**, was bedeutet, dass Ihr Editor Ihnen weiterhin **automatische Vervollst√§ndigung**, **Inline-Fehler**, usw. bieten kann. Das Gleiche gilt f√ºr andere Tools wie `mypy`.

Das ist besonders n√ºtzlich, wenn Sie es in einer **gro√üen Codebasis** verwenden, in der Sie in **vielen *Pfadoperationen*** immer wieder **dieselben Abh√§ngigkeiten** verwenden.

## `async` oder nicht `async`

Da Abh√§ngigkeiten auch von **FastAPI** aufgerufen werden (so wie Ihre *Pfadoperation-Funktionen*), gelten beim Definieren Ihrer Funktionen die gleichen Regeln.

Sie k√∂nnen `async def` oder einfach `def` verwenden.

Und Sie k√∂nnen Abh√§ngigkeiten mit `async def` innerhalb normaler `def`-*Pfadoperation-Funktionen* oder `def`-Abh√§ngigkeiten innerhalb von `async def`-*Pfadoperation-Funktionen*, usw. deklarieren.

Es spielt keine Rolle. **FastAPI** wei√ü, was zu tun ist.

/// note | Hinweis

Wenn Ihnen das nichts sagt, lesen Sie den [Async: *‚ÄûIn Eile?‚Äú*](../../async.md#in-eile){.internal-link target=_blank}-Abschnitt √ºber `async` und `await` in der Dokumentation.

///

## Integriert in OpenAPI

Alle Requestdeklarationen, -validierungen und -anforderungen Ihrer Abh√§ngigkeiten (und Unterabh√§ngigkeiten) werden in dasselbe OpenAPI-Schema integriert.

Die interaktive Dokumentation enth√§lt also auch alle Informationen aus diesen Abh√§ngigkeiten:

<img src="/img/tutorial/dependencies/image01.png">

## Einfache Verwendung

N√§her betrachtet, werden *Pfadoperation-Funktionen* deklariert, um verwendet zu werden, wann immer ein *Pfad* und eine *Operation* √ºbereinstimmen, und dann k√ºmmert sich **FastAPI** darum, die Funktion mit den richtigen Parametern aufzurufen, die Daten aus der Anfrage extrahierend.

Tats√§chlich funktionieren alle (oder die meisten) Webframeworks auf die gleiche Weise.

Sie rufen diese Funktionen niemals direkt auf. Sie werden von Ihrem Framework aufgerufen (in diesem Fall **FastAPI**).

Mit dem Dependency Injection System k√∂nnen Sie **FastAPI** ebenfalls mitteilen, dass Ihre *Pfadoperation-Funktion* von etwas anderem ‚Äûabh√§ngt‚Äú, das vor Ihrer *Pfadoperation-Funktion* ausgef√ºhrt werden soll, und **FastAPI** k√ºmmert sich darum, es auszuf√ºhren und die Ergebnisse zu ‚Äûinjizieren‚Äú.

Andere gebr√§uchliche Begriffe f√ºr dieselbe Idee der ‚ÄûAbh√§ngigkeitsinjektion‚Äú sind:

* Ressourcen
* Provider
* Services
* Injectables
* Komponenten

## **FastAPI**-Plugins

Integrationen und ‚ÄûPlugins‚Äú k√∂nnen mit dem **Dependency Injection** System erstellt werden. Aber tats√§chlich besteht **keine Notwendigkeit, ‚ÄûPlugins‚Äú zu erstellen**, da es durch die Verwendung von Abh√§ngigkeiten m√∂glich ist, eine unendliche Anzahl von Integrationen und Interaktionen zu deklarieren, die dann f√ºr Ihre *Pfadoperation-Funktionen* verf√ºgbar sind.

Und Abh√§ngigkeiten k√∂nnen auf sehr einfache und intuitive Weise erstellt werden, sodass Sie einfach die ben√∂tigten Python-Packages importieren und sie in wenigen Codezeilen, *im wahrsten Sinne des Wortes*, mit Ihren API-Funktionen integrieren.

Beispiele hierf√ºr finden Sie in den n√§chsten Kapiteln zu relationalen und NoSQL-Datenbanken, Sicherheit usw.

## **FastAPI**-Kompatibilit√§t

Die Einfachheit des Dependency Injection Systems macht **FastAPI** kompatibel mit:

* allen relationalen Datenbanken
* NoSQL-Datenbanken
* externen Packages
* externen APIs
* Authentifizierungs- und Autorisierungssystemen
* API-Nutzungs-√úberwachungssystemen
* Responsedaten-Injektionssystemen
* usw.

## Einfach und leistungsstark

Obwohl das hierarchische Dependency Injection System sehr einfach zu definieren und zu verwenden ist, ist es dennoch sehr m√§chtig.

Sie k√∂nnen Abh√§ngigkeiten definieren, die selbst wiederum Abh√§ngigkeiten definieren k√∂nnen.

Am Ende wird ein hierarchischer Baum von Abh√§ngigkeiten erstellt, und das **Dependency Injection** System k√ºmmert sich darum, alle diese Abh√§ngigkeiten (und deren Unterabh√§ngigkeiten) f√ºr Sie aufzul√∂sen und die Ergebnisse bei jedem Schritt einzubinden (zu injizieren).

Nehmen wir zum Beispiel an, Sie haben vier API-Endpunkte (*Pfadoperationen*):

* `/items/public/`
* `/items/private/`
* `/users/{user_id}/activate`
* `/items/pro/`

Dann k√∂nnten Sie f√ºr jeden davon unterschiedliche Berechtigungsanforderungen hinzuf√ºgen, nur mit Abh√§ngigkeiten und Unterabh√§ngigkeiten:

```mermaid
graph TB

current_user(["current_user"])
active_user(["active_user"])
admin_user(["admin_user"])
paying_user(["paying_user"])

public["/items/public/"]
private["/items/private/"]
activate_user["/users/{user_id}/activate"]
pro_items["/items/pro/"]

current_user --> active_user
active_user --> admin_user
active_user --> paying_user

current_user --> public
active_user --> private
admin_user --> activate_user
paying_user --> pro_items
```

## Integriert mit **OpenAPI**

Alle diese Abh√§ngigkeiten, w√§hrend sie ihre Anforderungen deklarieren, f√ºgen auch Parameter, Validierungen, usw. zu Ihren *Pfadoperationen* hinzu.

**FastAPI** k√ºmmert sich darum, alles zum OpenAPI-Schema hinzuzuf√ºgen, damit es in den interaktiven Dokumentationssystemen angezeigt wird.


================================================
File: /docs/de/docs/tutorial/dependencies/sub-dependencies.md
================================================
# Unterabh√§ngigkeiten

Sie k√∂nnen Abh√§ngigkeiten erstellen, die **Unterabh√§ngigkeiten** haben.

Diese k√∂nnen so **tief** verschachtelt sein, wie n√∂tig.

**FastAPI** k√ºmmert sich darum, sie aufzul√∂sen.

## Erste Abh√§ngigkeit, ‚ÄûDependable‚Äú

Sie k√∂nnten eine erste Abh√§ngigkeit (‚ÄûDependable‚Äú) wie folgt erstellen:

{* ../../docs_src/dependencies/tutorial005_an_py310.py hl[8:9] *}

Diese deklariert einen optionalen Abfrageparameter `q` vom Typ `str` und gibt ihn dann einfach zur√ºck.

Das ist recht einfach (nicht sehr n√ºtzlich), hilft uns aber dabei, uns auf die Funktionsweise der Unterabh√§ngigkeiten zu konzentrieren.

## Zweite Abh√§ngigkeit, ‚ÄûDependable‚Äú und ‚ÄûDependant‚Äú

Dann k√∂nnen Sie eine weitere Abh√§ngigkeitsfunktion (ein ‚ÄûDependable‚Äú) erstellen, die gleichzeitig eine eigene Abh√§ngigkeit deklariert (also auch ein ‚ÄûDependant‚Äú ist):

{* ../../docs_src/dependencies/tutorial005_an_py310.py hl[13] *}

Betrachten wir die deklarierten Parameter:

* Obwohl diese Funktion selbst eine Abh√§ngigkeit ist (‚ÄûDependable‚Äú, etwas h√§ngt von ihr ab), deklariert sie auch eine andere Abh√§ngigkeit (‚ÄûDependant‚Äú, sie h√§ngt von etwas anderem ab).
    * Sie h√§ngt von `query_extractor` ab und weist den von diesem zur√ºckgegebenen Wert dem Parameter `q` zu.
* Sie deklariert au√üerdem ein optionales `last_query`-Cookie, ein `str`.
    * Wenn der Benutzer keine Query `q` √ºbermittelt hat, verwenden wir die zuletzt √ºbermittelte Query, die wir zuvor in einem Cookie gespeichert haben.

## Die Abh√§ngigkeit verwenden

Diese Abh√§ngigkeit verwenden wir nun wie folgt:

{* ../../docs_src/dependencies/tutorial005_an_py310.py hl[23] *}

/// info

Beachten Sie, dass wir in der *Pfadoperation-Funktion* nur eine einzige Abh√§ngigkeit deklarieren, den `query_or_cookie_extractor`.

Aber **FastAPI** wird wissen, dass es zuerst `query_extractor` aufl√∂sen muss, um dessen Resultat `query_or_cookie_extractor` zu √ºbergeben, wenn dieses aufgerufen wird.

///

```mermaid
graph TB

query_extractor(["query_extractor"])
query_or_cookie_extractor(["query_or_cookie_extractor"])

read_query["/items/"]

query_extractor --> query_or_cookie_extractor --> read_query
```

## Dieselbe Abh√§ngigkeit mehrmals verwenden

Wenn eine Ihrer Abh√§ngigkeiten mehrmals f√ºr dieselbe *Pfadoperation* deklariert wird, beispielsweise wenn mehrere Abh√§ngigkeiten eine gemeinsame Unterabh√§ngigkeit haben, wird **FastAPI** diese Unterabh√§ngigkeit nur einmal pro Request aufrufen.

Und es speichert den zur√ºckgegebenen Wert in einem <abbr title="Mechanismus, der bereits berechnete/generierte Werte zwischenspeichert, um sie sp√§ter wiederzuverwenden, anstatt sie erneut zu berechnen.">‚ÄûCache‚Äú</abbr> und √ºbergibt diesen gecachten Wert an alle ‚ÄûDependanten‚Äú, die ihn in diesem spezifischen Request ben√∂tigen, anstatt die Abh√§ngigkeit mehrmals f√ºr denselben Request aufzurufen.

In einem fortgeschrittenen Szenario, bei dem Sie wissen, dass die Abh√§ngigkeit bei jedem Schritt (m√∂glicherweise mehrmals) in derselben Anfrage aufgerufen werden muss, anstatt den zwischengespeicherten Wert zu verwenden, k√∂nnen Sie den Parameter `use_cache=False` festlegen, wenn Sie `Depends` verwenden:

//// tab | Python 3.8+

```Python hl_lines="1"
async def needy_dependency(fresh_value: Annotated[str, Depends(get_value, use_cache=False)]):
    return {"fresh_value": fresh_value}
```

////

//// tab | Python 3.8+ nicht annotiert

/// tip | Tipp

Bevorzugen Sie die `Annotated`-Version, falls m√∂glich.

///

```Python hl_lines="1"
async def needy_dependency(fresh_value: str = Depends(get_value, use_cache=False)):
    return {"fresh_value": fresh_value}
```

////

## Zusammenfassung

Abgesehen von all den ausgefallenen W√∂rtern, die hier verwendet werden, ist das **Dependency Injection**-System recht simpel.

Einfach Funktionen, die genauso aussehen wie *Pfadoperation-Funktionen*.

Dennoch ist es sehr m√§chtig und erm√∂glicht Ihnen die Deklaration beliebig tief verschachtelter Abh√§ngigkeits-‚ÄûGraphen‚Äú (B√§ume).

/// tip | Tipp

All dies scheint angesichts dieser einfachen Beispiele m√∂glicherweise nicht so n√ºtzlich zu sein.

Aber Sie werden in den Kapiteln √ºber **Sicherheit** sehen, wie n√ºtzlich das ist.

Und Sie werden auch sehen, wie viel Code Sie dadurch einsparen.

///


================================================
File: /docs/de/docs/tutorial/security/first-steps.md
================================================
# Sicherheit ‚Äì Erste Schritte

Stellen wir uns vor, dass Sie Ihre **Backend**-API auf einer Domain haben.

Und Sie haben ein **Frontend** auf einer anderen Domain oder in einem anderen Pfad derselben Domain (oder in einer mobilen Anwendung).

Und Sie m√∂chten eine M√∂glichkeit haben, dass sich das Frontend mithilfe eines **Benutzernamens** und eines **Passworts** beim Backend authentisieren kann.

Wir k√∂nnen **OAuth2** verwenden, um das mit **FastAPI** zu erstellen.

Aber ersparen wir Ihnen die Zeit, die gesamte lange Spezifikation zu lesen, nur um die kleinen Informationen zu finden, die Sie ben√∂tigen.

Lassen Sie uns die von **FastAPI** bereitgestellten Tools verwenden, um Sicherheit zu gew√§hrleisten.

## Wie es aussieht

Lassen Sie uns zun√§chst einfach den Code verwenden und sehen, wie er funktioniert, und dann kommen wir zur√ºck, um zu verstehen, was passiert.

## `main.py` erstellen

Kopieren Sie das Beispiel in eine Datei `main.py`:

{* ../../docs_src/security/tutorial001_an_py39.py *}

## Ausf√ºhren

/// info

Um hochgeladene Dateien zu empfangen, installieren Sie zuerst <a href="https://andrew-d.github.io/python-multipart/" class="external-link" target="_blank">`python-multipart`</a>.

Z. B. `pip install python-multipart`.

Das, weil **OAuth2** ‚ÄûFormulardaten‚Äú zum Senden von `username` und `password` verwendet.

///

F√ºhren Sie das Beispiel aus mit:

<div class="termy">

```console
$ uvicorn main:app --reload

<span style="color: green;">INFO</span>:     Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit)
```

</div>

## √úberpr√ºfen

Gehen Sie zu der interaktiven Dokumentation unter: <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

Sie werden etwa Folgendes sehen:

<img src="/img/tutorial/security/image01.png">

/// check | Authorize-Button!

Sie haben bereits einen gl√§nzenden, neuen ‚ÄûAuthorize‚Äú-Button.

Und Ihre *Pfadoperation* hat in der oberen rechten Ecke ein kleines Schloss, auf das Sie klicken k√∂nnen.

///

Und wenn Sie darauf klicken, erhalten Sie ein kleines Anmeldeformular zur Eingabe eines `username` und `password` (und anderer optionaler Felder):

<img src="/img/tutorial/security/image02.png">

/// note | Hinweis

Es spielt keine Rolle, was Sie in das Formular eingeben, es wird noch nicht funktionieren. Wir kommen dahin.

///

Dies ist nat√ºrlich nicht das Frontend f√ºr die Endbenutzer, aber es ist ein gro√üartiges automatisches Tool, um Ihre gesamte API interaktiv zu dokumentieren.

Es kann vom Frontend-Team verwendet werden (das auch Sie selbst sein k√∂nnen).

Es kann von Anwendungen und Systemen Dritter verwendet werden.

Und es kann auch von Ihnen selbst verwendet werden, um dieselbe Anwendung zu debuggen, zu pr√ºfen und zu testen.

## Der `password`-Flow

Lassen Sie uns nun etwas zur√ºckgehen und verstehen, was das alles ist.

Der `password`-‚ÄûFlow‚Äú ist eine der in OAuth2 definierten Wege (‚ÄûFlows‚Äú) zur Handhabung von Sicherheit und Authentifizierung.

OAuth2 wurde so konzipiert, dass das Backend oder die API unabh√§ngig vom Server sein kann, der den Benutzer authentifiziert.

In diesem Fall handhabt jedoch dieselbe **FastAPI**-Anwendung sowohl die API als auch die Authentifizierung.

Betrachten wir es also aus dieser vereinfachten Sicht:

* Der Benutzer gibt den `username` und das `password` im Frontend ein und dr√ºckt `Enter`.
* Das Frontend (das im Browser des Benutzers l√§uft) sendet diesen `username` und das `password` an eine bestimmte URL in unserer API (deklariert mit `tokenUrl="token"`).
* Die API √ºberpr√ºft den `username` und das `password` und antwortet mit einem ‚ÄûToken‚Äú (wir haben davon noch nichts implementiert).
    * Ein ‚ÄûToken‚Äú ist lediglich ein String mit einem Inhalt, den wir sp√§ter verwenden k√∂nnen, um diesen Benutzer zu verifizieren.
    * Normalerweise l√§uft ein Token nach einiger Zeit ab.
        * Daher muss sich der Benutzer irgendwann sp√§ter erneut anmelden.
        * Und wenn der Token gestohlen wird, ist das Risiko geringer. Es handelt sich nicht um einen dauerhaften Schl√ºssel, der (in den meisten F√§llen) f√ºr immer funktioniert.
* Das Frontend speichert diesen Token vor√ºbergehend irgendwo.
* Der Benutzer klickt im Frontend, um zu einem anderen Abschnitt der Frontend-Web-Anwendung zu gelangen.
* Das Frontend muss weitere Daten von der API abrufen.
    * Es ben√∂tigt jedoch eine Authentifizierung f√ºr diesen bestimmten Endpunkt.
    * Um sich also bei unserer API zu authentifizieren, sendet es einen Header `Authorization` mit dem Wert `Bearer` plus dem Token.
    * Wenn der Token `foobar` enthielte, w√§re der Inhalt des `Authorization`-Headers: `Bearer foobar`.

## **FastAPI**s `OAuth2PasswordBearer`

**FastAPI** bietet mehrere Tools auf unterschiedlichen Abstraktionsebenen zur Implementierung dieser Sicherheitsfunktionen.

In diesem Beispiel verwenden wir **OAuth2** mit dem **Password**-Flow und einem **Bearer**-Token. Wir machen das mit der Klasse `OAuth2PasswordBearer`.

/// info

Ein ‚ÄûBearer‚Äú-Token ist nicht die einzige Option.

Aber es ist die beste f√ºr unseren Anwendungsfall.

Und es ist wahrscheinlich auch f√ºr die meisten anderen Anwendungsf√§lle die beste, es sei denn, Sie sind ein OAuth2-Experte und wissen genau, warum es eine andere Option gibt, die Ihren Anforderungen besser entspricht.

In dem Fall gibt Ihnen **FastAPI** ebenfalls die Tools, die Sie zum Erstellen brauchen.

///

Wenn wir eine Instanz der Klasse `OAuth2PasswordBearer` erstellen, √ºbergeben wir den Parameter `tokenUrl`. Dieser Parameter enth√§lt die URL, die der Client (das Frontend, das im Browser des Benutzers ausgef√ºhrt wird) verwendet, wenn er den `username` und das `password` sendet, um einen Token zu erhalten.

{* ../../docs_src/security/tutorial001_an_py39.py hl[8] *}

/// tip | Tipp

Hier bezieht sich `tokenUrl="token"` auf eine relative URL `token`, die wir noch nicht erstellt haben. Da es sich um eine relative URL handelt, entspricht sie `./token`.

Da wir eine relative URL verwenden, w√ºrde sich das, wenn sich Ihre API unter `https://example.com/` befindet, auf `https://example.com/token` beziehen. Wenn sich Ihre API jedoch unter `https://example.com/api/v1/` bef√§nde, w√ºrde es sich auf `https://example.com/api/v1/token` beziehen.

Die Verwendung einer relativen URL ist wichtig, um sicherzustellen, dass Ihre Anwendung auch in einem fortgeschrittenen Anwendungsfall, wie [hinter einem Proxy](../../advanced/behind-a-proxy.md){.internal-link target=_blank}, weiterhin funktioniert.

///

Dieser Parameter erstellt nicht diesen Endpunkt / diese *Pfadoperation*, sondern deklariert, dass die URL `/token` diejenige sein wird, die der Client verwenden soll, um den Token abzurufen. Diese Information wird in OpenAPI und dann in den interaktiven API-Dokumentationssystemen verwendet.

Wir werden demn√§chst auch die eigentliche Pfadoperation erstellen.

/// info

Wenn Sie ein sehr strenger ‚ÄûPythonista‚Äú sind, missf√§llt Ihnen m√∂glicherweise die Schreibweise des Parameternamens `tokenUrl` anstelle von `token_url`.

Das liegt daran, dass FastAPI denselben Namen wie in der OpenAPI-Spezifikation verwendet. Sodass Sie, wenn Sie mehr √ºber eines dieser Sicherheitsschemas herausfinden m√∂chten, den Namen einfach kopieren und einf√ºgen k√∂nnen, um weitere Informationen dar√ºber zu erhalten.

///

Die Variable `oauth2_scheme` ist eine Instanz von `OAuth2PasswordBearer`, aber auch ein ‚ÄûCallable‚Äú.

Es k√∂nnte wie folgt aufgerufen werden:

```Python
oauth2_scheme(some, parameters)
```

Es kann also mit `Depends` verwendet werden.

### Verwendung

Jetzt k√∂nnen Sie dieses `oauth2_scheme` als Abh√§ngigkeit `Depends` √ºbergeben.

{* ../../docs_src/security/tutorial001_an_py39.py hl[12] *}

Diese Abh√§ngigkeit stellt einen `str` bereit, der dem Parameter `token` der *Pfadoperation-Funktion* zugewiesen wird.

**FastAPI** wei√ü, dass es diese Abh√§ngigkeit verwenden kann, um ein ‚ÄûSicherheitsschema‚Äú im OpenAPI-Schema (und der automatischen API-Dokumentation) zu definieren.

/// info | Technische Details

**FastAPI** wei√ü, dass es die Klasse `OAuth2PasswordBearer` (deklariert in einer Abh√§ngigkeit) verwenden kann, um das Sicherheitsschema in OpenAPI zu definieren, da es von `fastapi.security.oauth2.OAuth2` erbt, das wiederum von `fastapi.security.base.SecurityBase` erbt.

Alle Sicherheits-Werkzeuge, die in OpenAPI integriert sind (und die automatische API-Dokumentation), erben von `SecurityBase`, so wei√ü **FastAPI**, wie es sie in OpenAPI integrieren muss.

///

## Was es macht

FastAPI wird im Request nach diesem `Authorization`-Header suchen, pr√ºfen, ob der Wert `Bearer` plus ein Token ist, und den Token als `str` zur√ºckgeben.

Wenn es keinen `Authorization`-Header sieht, oder der Wert keinen `Bearer`-Token hat, antwortet es direkt mit einem 401-Statuscode-Error (`UNAUTHORIZED`).

Sie m√ºssen nicht einmal pr√ºfen, ob der Token existiert, um einen Fehler zur√ºckzugeben. Seien Sie sicher, dass Ihre Funktion, wenn sie ausgef√ºhrt wird, ein `str` in diesem Token enth√§lt.

Sie k√∂nnen das bereits in der interaktiven Dokumentation ausprobieren:

<img src="/img/tutorial/security/image03.png">

Wir √ºberpr√ºfen im Moment noch nicht die G√ºltigkeit des Tokens, aber das ist bereits ein Anfang.

## Zusammenfassung

Mit nur drei oder vier zus√§tzlichen Zeilen haben Sie also bereits eine primitive Form der Sicherheit.


================================================
File: /docs/de/docs/tutorial/security/get-current-user.md
================================================
# Aktuellen Benutzer abrufen

Im vorherigen Kapitel hat das Sicherheitssystem (das auf dem Dependency Injection System basiert) der *Pfadoperation-Funktion* einen `token` vom Typ `str` √ºberreicht:

{* ../../docs_src/security/tutorial001_an_py39.py hl[12] *}

Aber das ist immer noch nicht so n√ºtzlich.

Lassen wir es uns den aktuellen Benutzer √ºberreichen.

## Ein Benutzermodell erstellen

Erstellen wir zun√§chst ein Pydantic-Benutzermodell.

So wie wir Pydantic zum Deklarieren von Bodys verwenden, k√∂nnen wir es auch √ºberall sonst verwenden:

{* ../../docs_src/security/tutorial002_an_py310.py hl[5,12:16] *}

## Eine `get_current_user`-Abh√§ngigkeit erstellen

Erstellen wir eine Abh√§ngigkeit `get_current_user`.

Erinnern Sie sich, dass Abh√§ngigkeiten Unterabh√§ngigkeiten haben k√∂nnen?

`get_current_user` wird seinerseits von `oauth2_scheme` abh√§ngen, das wir zuvor erstellt haben.

So wie wir es zuvor in der *Pfadoperation* direkt gemacht haben, erh√§lt unsere neue Abh√§ngigkeit `get_current_user` von der Unterabh√§ngigkeit `oauth2_scheme` einen `token` vom Typ `str`:

{* ../../docs_src/security/tutorial002_an_py310.py hl[25] *}

## Den Benutzer holen

`get_current_user` wird eine von uns erstellte (gefakte) Hilfsfunktion verwenden, welche einen Token vom Typ `str` entgegennimmt und unser Pydantic-`User`-Modell zur√ºckgibt:

{* ../../docs_src/security/tutorial002_an_py310.py hl[19:22,26:27] *}

## Den aktuellen Benutzer einf√ºgen

Und jetzt k√∂nnen wir wiederum `Depends` mit unserem `get_current_user` in der *Pfadoperation* verwenden:

{* ../../docs_src/security/tutorial002_an_py310.py hl[31] *}

Beachten Sie, dass wir als Typ von `current_user` das Pydantic-Modell `User` deklarieren.

Das wird uns innerhalb der Funktion bei Codevervollst√§ndigung und Typpr√ºfungen helfen.

/// tip | Tipp

Sie erinnern sich vielleicht, dass Requestbodys ebenfalls mit Pydantic-Modellen deklariert werden.

Weil Sie `Depends` verwenden, wird **FastAPI** hier aber nicht verwirrt.

///

/// check

Die Art und Weise, wie dieses System von Abh√§ngigkeiten konzipiert ist, erm√∂glicht es uns, verschiedene Abh√§ngigkeiten (verschiedene ‚ÄûDependables‚Äú) zu haben, die alle ein `User`-Modell zur√ºckgeben.

Wir sind nicht darauf beschr√§nkt, nur eine Abh√§ngigkeit zu haben, die diesen Typ von Daten zur√ºckgeben kann.

///

## Andere Modelle

Sie k√∂nnen jetzt den aktuellen Benutzer direkt in den *Pfadoperation-Funktionen* abrufen und die Sicherheitsmechanismen auf **Dependency Injection** Ebene handhaben, mittels `Depends`.

Und Sie k√∂nnen alle Modelle und Daten f√ºr die Sicherheitsanforderungen verwenden (in diesem Fall ein Pydantic-Modell `User`).

Sie sind jedoch nicht auf die Verwendung von bestimmten Datenmodellen, Klassen, oder Typen beschr√§nkt.

M√∂chten Sie eine `id` und eine `email` und keinen `username` in Ihrem Modell haben? Kein Problem. Sie k√∂nnen dieselben Tools verwenden.

M√∂chten Sie nur ein `str` haben? Oder nur ein `dict`? Oder direkt eine Instanz eines Modells einer Datenbank-Klasse? Es funktioniert alles auf die gleiche Weise.

Sie haben eigentlich keine Benutzer, die sich bei Ihrer Anwendung anmelden, sondern Roboter, Bots oder andere Systeme, die nur √ºber einen Zugriffstoken verf√ºgen? Auch hier funktioniert alles gleich.

Verwenden Sie einfach jede Art von Modell, jede Art von Klasse, jede Art von Datenbank, die Sie f√ºr Ihre Anwendung ben√∂tigen. **FastAPI** deckt das alles mit seinem Dependency Injection System ab.

## Codegr√∂√üe

Dieses Beispiel mag ausf√ºhrlich erscheinen. Bedenken Sie, dass wir Sicherheit, Datenmodelle, Hilfsfunktionen und *Pfadoperationen* in derselben Datei vermischen.

Aber hier ist der entscheidende Punkt.

Der Code f√ºr Sicherheit und Dependency Injection wird einmal geschrieben.

Sie k√∂nnen es so komplex gestalten, wie Sie m√∂chten. Und dennoch haben Sie es nur einmal geschrieben, an einer einzigen Stelle. Mit all der Flexibilit√§t.

Aber Sie k√∂nnen Tausende von Endpunkten (*Pfadoperationen*) haben, die dasselbe Sicherheitssystem verwenden.

Und alle (oder beliebige Teile davon) k√∂nnen Vorteil ziehen aus der Wiederverwendung dieser und anderer von Ihnen erstellter Abh√§ngigkeiten.

Und alle diese Tausenden von *Pfadoperationen* k√∂nnen nur drei Zeilen lang sein:

{* ../../docs_src/security/tutorial002_an_py310.py hl[30:32] *}

## Zusammenfassung

Sie k√∂nnen jetzt den aktuellen Benutzer direkt in Ihrer *Pfadoperation-Funktion* abrufen.

Wir haben bereits die H√§lfte geschafft.

Wir m√ºssen jetzt nur noch eine *Pfadoperation* hinzuf√ºgen, mittels der der Benutzer/Client tats√§chlich seinen `username` und `password` senden kann.

Das kommt als n√§chstes.


================================================
File: /docs/de/docs/tutorial/security/index.md
================================================
# Sicherheit

Es gibt viele Wege, Sicherheit, Authentifizierung und Autorisierung zu handhaben.

Und normalerweise ist es ein komplexes und ‚Äûschwieriges‚Äú Thema.

In vielen Frameworks und Systemen erfordert allein die Handhabung von Sicherheit und Authentifizierung viel Aufwand und Code (in vielen F√§llen kann er 50 % oder mehr des gesamten geschriebenen Codes ausmachen).

**FastAPI** bietet mehrere Tools, die Ihnen helfen, schnell und auf standardisierte Weise mit **Sicherheit** umzugehen, ohne alle Sicherheits-Spezifikationen studieren und erlernen zu m√ºssen.

Aber schauen wir uns zun√§chst ein paar kleine Konzepte an.

## In Eile?

Wenn Ihnen diese Begriffe egal sind und Sie einfach *jetzt* Sicherheit mit Authentifizierung basierend auf Benutzername und Passwort hinzuf√ºgen m√ºssen, fahren Sie mit den n√§chsten Kapiteln fort.

## OAuth2

OAuth2 ist eine Spezifikation, die verschiedene M√∂glichkeiten zur Handhabung von Authentifizierung und Autorisierung definiert.

Es handelt sich um eine recht umfangreiche Spezifikation, und sie deckt mehrere komplexe Anwendungsf√§lle ab.

Sie umfasst M√∂glichkeiten zur Authentifizierung mithilfe eines ‚ÄûDritten‚Äú (‚Äûthird party‚Äú).

Das ist es, was alle diese ‚ÄûLogin mit Facebook, Google, Twitter, GitHub‚Äú-Systeme unter der Haube verwenden.

### OAuth 1

Es gab ein OAuth 1, das sich stark von OAuth2 unterscheidet und komplexer ist, da es direkte Spezifikationen enth√§lt, wie die Kommunikation verschl√ºsselt wird.

Heutzutage ist es nicht sehr popul√§r und wird kaum verwendet.

OAuth2 spezifiziert nicht, wie die Kommunikation verschl√ºsselt werden soll, sondern erwartet, dass Ihre Anwendung mit HTTPS bereitgestellt wird.

/// tip | Tipp

Im Abschnitt √ºber **Deployment** erfahren Sie, wie Sie HTTPS mithilfe von Traefik und Let's Encrypt kostenlos einrichten.

///

## OpenID Connect

OpenID Connect ist eine weitere Spezifikation, die auf **OAuth2** basiert.

Sie erweitert lediglich OAuth2, indem sie einige Dinge spezifiziert, die in OAuth2 relativ mehrdeutig sind, um zu versuchen, es interoperabler zu machen.

Beispielsweise verwendet der Google Login OpenID Connect (welches seinerseits OAuth2 verwendet).

Aber der Facebook Login unterst√ºtzt OpenID Connect nicht. Es hat seine eigene Variante von OAuth2.

### OpenID (nicht ‚ÄûOpenID Connect‚Äú)

Es gab auch eine ‚ÄûOpenID‚Äú-Spezifikation. Sie versuchte das Gleiche zu l√∂sen wie **OpenID Connect**, basierte aber nicht auf OAuth2.

Es handelte sich also um ein komplett zus√§tzliches System.

Heutzutage ist es nicht sehr popul√§r und wird kaum verwendet.

## OpenAPI

OpenAPI (fr√ºher bekannt als Swagger) ist die offene Spezifikation zum Erstellen von APIs (jetzt Teil der Linux Foundation).

**FastAPI** basiert auf **OpenAPI**.

Das ist es, was erlaubt, mehrere automatische interaktive Dokumentations-Oberfl√§chen, Codegenerierung, usw. zu haben.

OpenAPI bietet die M√∂glichkeit, mehrere Sicherheits‚Äûsysteme‚Äú zu definieren.

Durch deren Verwendung k√∂nnen Sie alle diese Standards-basierten Tools nutzen, einschlie√ülich dieser interaktiven Dokumentationssysteme.

OpenAPI definiert die folgenden Sicherheitsschemas:

* `apiKey`: ein anwendungsspezifischer Schl√ºssel, der stammen kann von:
    * Einem Query-Parameter.
    * Einem Header.
    * Einem Cookie.
* `http`: Standard-HTTP-Authentifizierungssysteme, einschlie√ülich:
    * `bearer`: ein Header `Authorization` mit dem Wert `Bearer` plus einem Token. Dies wird von OAuth2 geerbt.
    * HTTP Basic Authentication.
    * HTTP Digest, usw.
* `oauth2`: Alle OAuth2-Methoden zum Umgang mit Sicherheit (genannt ‚ÄûFlows‚Äú).
    * Mehrere dieser Flows eignen sich zum Aufbau eines OAuth 2.0-Authentifizierungsanbieters (wie Google, Facebook, Twitter, GitHub usw.):
        * `implicit`
        * `clientCredentials`
        * `authorizationCode`
    * Es gibt jedoch einen bestimmten ‚ÄûFlow‚Äú, der perfekt f√ºr die direkte Abwicklung der Authentifizierung in derselben Anwendung verwendet werden kann:
        * `password`: Einige der n√§chsten Kapitel werden Beispiele daf√ºr behandeln.
* `openIdConnect`: bietet eine M√∂glichkeit, zu definieren, wie OAuth2-Authentifizierungsdaten automatisch ermittelt werden k√∂nnen.
    * Diese automatische Erkennung ist es, die in der OpenID Connect Spezifikation definiert ist.


/// tip | Tipp

Auch die Integration anderer Authentifizierungs-/Autorisierungsanbieter wie Google, Facebook, Twitter, GitHub, usw. ist m√∂glich und relativ einfach.

Das komplexeste Problem besteht darin, einen Authentifizierungs-/Autorisierungsanbieter wie solche aufzubauen, aber **FastAPI** reicht Ihnen die Tools, das einfach zu erledigen, w√§hrend Ihnen die schwere Arbeit abgenommen wird.

///

## **FastAPI** Tools

FastAPI stellt f√ºr jedes dieser Sicherheitsschemas im Modul `fastapi.security` verschiedene Tools bereit, die die Verwendung dieser Sicherheitsmechanismen vereinfachen.

In den n√§chsten Kapiteln erfahren Sie, wie Sie mit diesen von **FastAPI** bereitgestellten Tools Sicherheit zu Ihrer API hinzuf√ºgen.

Und Sie werden auch sehen, wie dies automatisch in das interaktive Dokumentationssystem integriert wird.


================================================
File: /docs/de/docs/tutorial/security/oauth2-jwt.md
================================================
# OAuth2 mit Password (und Hashing), Bearer mit JWT-Tokens

Da wir nun √ºber den gesamten Sicherheitsablauf verf√ºgen, machen wir die Anwendung tats√§chlich sicher, indem wir <abbr title="JSON Web Tokens">JWT</abbr>-Tokens und sicheres Passwort-Hashing verwenden.

Diesen Code k√∂nnen Sie tats√§chlich in Ihrer Anwendung verwenden, die Passwort-Hashes in Ihrer Datenbank speichern, usw.

Wir bauen auf dem vorherigen Kapitel auf.

## √úber JWT

JWT bedeutet ‚ÄûJSON Web Tokens‚Äú.

Es ist ein Standard, um ein JSON-Objekt in einem langen, kompakten String ohne Leerzeichen zu kodieren. Das sieht so aus:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

Da er nicht verschl√ºsselt ist, kann jeder die Informationen aus dem Inhalt wiederherstellen.

Aber er ist signiert. Wenn Sie also einen von Ihnen gesendeten Token zur√ºckerhalten, k√∂nnen Sie √ºberpr√ºfen, ob Sie ihn tats√§chlich gesendet haben.

Auf diese Weise k√∂nnen Sie einen Token mit einer G√ºltigkeitsdauer von beispielsweise einer Woche erstellen. Und wenn der Benutzer am n√§chsten Tag mit dem Token zur√ºckkommt, wissen Sie, dass der Benutzer immer noch bei Ihrem System angemeldet ist.

Nach einer Woche l√§uft der Token ab und der Benutzer wird nicht autorisiert und muss sich erneut anmelden, um einen neuen Token zu erhalten. Und wenn der Benutzer (oder ein Dritter) versuchen w√ºrde, den Token zu √§ndern, um das Ablaufdatum zu √§ndern, w√ºrden Sie das entdecken, weil die Signaturen nicht √ºbereinstimmen w√ºrden.

Wenn Sie mit JWT-Tokens spielen und sehen m√∂chten, wie sie funktionieren, schauen Sie sich <a href="https://jwt.io/" class="external-link" target="_blank">https://jwt.io</a> an.

## `python-jose` installieren.

Wir m√ºssen <abbr title="JOSE: JavaScript Object Signing and Encryption">`python-jose`</abbr> installieren, um die JWT-Tokens in Python zu generieren und zu verifizieren:

<div class="termy">

```console
$ pip install "python-jose[cryptography]"

---> 100%
```

</div>

<a href="https://github.com/mpdavis/python-jose" class="external-link" target="_blank">python-jose</a> erfordert zus√§tzlich ein kryptografisches Backend.

Hier verwenden wir das empfohlene: <a href="https://cryptography.io/" class="external-link" target="_blank">pyca/cryptography</a>.

/// tip | Tipp

Dieses Tutorial verwendete zuvor <a href="https://pyjwt.readthedocs.io/" class="external-link" target="_blank">PyJWT</a>.

Es wurde jedoch aktualisiert, stattdessen python-jose zu verwenden, da dieses alle Funktionen von PyJWT sowie einige Extras bietet, die Sie sp√§ter m√∂glicherweise ben√∂tigen, wenn Sie Integrationen mit anderen Tools erstellen.

///

## Passwort-Hashing

‚ÄûHashing‚Äú bedeutet: Konvertieren eines Inhalts (in diesem Fall eines Passworts) in eine Folge von Bytes (ein schlichter String), die wie Kauderwelsch aussieht.

Immer wenn Sie genau den gleichen Inhalt (genau das gleiche Passwort) √ºbergeben, erhalten Sie genau den gleichen Kauderwelsch.

Sie k√∂nnen jedoch nicht vom Kauderwelsch zur√ºck zum Passwort konvertieren.

### Warum Passwort-Hashing verwenden?

Wenn Ihre Datenbank gestohlen wird, hat der Dieb nicht die Klartext-Passw√∂rter Ihrer Benutzer, sondern nur die Hashes.

Der Dieb kann also nicht versuchen, die gleichen Passw√∂rter in einem anderen System zu verwenden (da viele Benutzer √ºberall das gleiche Passwort verwenden, w√§re dies gef√§hrlich).

## `passlib` installieren

PassLib ist ein gro√üartiges Python-Package, um Passwort-Hashes zu handhaben.

Es unterst√ºtzt viele sichere Hashing-Algorithmen und Werkzeuge, um mit diesen zu arbeiten.

Der empfohlene Algorithmus ist ‚ÄûBcrypt‚Äú.

Installieren Sie also PassLib mit Bcrypt:

<div class="termy">

```console
$ pip install "passlib[bcrypt]"

---> 100%
```

</div>

/// tip | Tipp

Mit `passlib` k√∂nnen Sie sogar konfigurieren, Passw√∂rter zu lesen, die von **Django**, einem **Flask**-Sicherheit-Plugin, oder vielen anderen erstellt wurden.

So k√∂nnten Sie beispielsweise die gleichen Daten aus einer Django-Anwendung in einer Datenbank mit einer FastAPI-Anwendung teilen. Oder schrittweise eine Django-Anwendung migrieren, w√§hrend Sie dieselbe Datenbank verwenden.

Und Ihre Benutzer k√∂nnten sich gleichzeitig √ºber Ihre Django-Anwendung oder Ihre **FastAPI**-Anwendung anmelden.

///

## Die Passw√∂rter hashen und √ºberpr√ºfen

Importieren Sie die ben√∂tigten Tools aus `passlib`.

Erstellen Sie einen PassLib-‚ÄûKontext‚Äú. Der wird f√ºr das Hashen und Verifizieren von Passw√∂rtern verwendet.

/// tip | Tipp

Der PassLib-Kontext kann auch andere Hashing-Algorithmen verwenden, einschlie√ülich deprecateter Alter, um etwa nur eine Verifizierung usw. zu erm√∂glichen.

Sie k√∂nnten ihn beispielsweise verwenden, um von einem anderen System (wie Django) generierte Passw√∂rter zu lesen und zu verifizieren, aber alle neuen Passw√∂rter mit einem anderen Algorithmus wie Bcrypt zu hashen.

Und mit allen gleichzeitig kompatibel sein.

///

Erstellen Sie eine Hilfsfunktion, um ein vom Benutzer stammendes Passwort zu hashen.

Und eine weitere, um zu √ºberpr√ºfen, ob ein empfangenes Passwort mit dem gespeicherten Hash √ºbereinstimmt.

Und noch eine, um einen Benutzer zu authentifizieren und zur√ºckzugeben.

{* ../../docs_src/security/tutorial004_an_py310.py hl[7,48,55:56,59:60,69:75] *}

/// note | Hinweis

Wenn Sie sich die neue (gefakte) Datenbank `fake_users_db` anschauen, sehen Sie, wie das gehashte Passwort jetzt aussieht: `"$2b$12$EixZaYVK1fsbw1ZfbX3OXePaWxn96p36WQoeG6Lruj3vjPGga31lW"`.

///

## JWT-Token verarbeiten

Importieren Sie die installierten Module.

Erstellen Sie einen zuf√§lligen geheimen Schl√ºssel, der zum Signieren der JWT-Tokens verwendet wird.

Um einen sicheren zuf√§lligen geheimen Schl√ºssel zu generieren, verwenden Sie den folgenden Befehl:

<div class="termy">

```console
$ openssl rand -hex 32

09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7
```

</div>

Und kopieren Sie die Ausgabe in die Variable `SECRET_KEY` (verwenden Sie nicht die im Beispiel).

Erstellen Sie eine Variable `ALGORITHM` f√ºr den Algorithmus, der zum Signieren des JWT-Tokens verwendet wird, und setzen Sie sie auf `"HS256"`.

Erstellen Sie eine Variable f√ºr das Ablaufdatum des Tokens.

Definieren Sie ein Pydantic-Modell, das im Token-Endpunkt f√ºr die Response verwendet wird.

Erstellen Sie eine Hilfsfunktion, um einen neuen Zugriffstoken zu generieren.

{* ../../docs_src/security/tutorial004_an_py310.py hl[6,12:14,28:30,78:86] *}

## Die Abh√§ngigkeiten aktualisieren

Aktualisieren Sie `get_current_user`, um den gleichen Token wie zuvor zu erhalten, dieses Mal jedoch unter Verwendung von JWT-Tokens.

Dekodieren Sie den empfangenen Token, validieren Sie ihn und geben Sie den aktuellen Benutzer zur√ºck.

Wenn der Token ung√ºltig ist, geben Sie sofort einen HTTP-Fehler zur√ºck.

{* ../../docs_src/security/tutorial004_an_py310.py hl[89:106] *}

## Die *Pfadoperation* `/token` aktualisieren

Erstellen Sie ein <abbr title="Zeitdifferenz">`timedelta`</abbr> mit der Ablaufzeit des Tokens.

Erstellen Sie einen echten JWT-Zugriffstoken und geben Sie ihn zur√ºck.

{* ../../docs_src/security/tutorial004_an_py310.py hl[117:132] *}

### Technische Details zum JWT-‚ÄûSubjekt‚Äú `sub`

Die JWT-Spezifikation besagt, dass es einen Schl√ºssel `sub` mit dem Subjekt des Tokens gibt.

Die Verwendung ist optional, aber dort w√ºrden Sie die Identifikation des Benutzers speichern, daher verwenden wir das hier.

JWT kann auch f√ºr andere Dinge verwendet werden, abgesehen davon, einen Benutzer zu identifizieren und ihm zu erlauben, Operationen direkt auf Ihrer API auszuf√ºhren.

Sie k√∂nnten beispielsweise ein ‚ÄûAuto‚Äú oder einen ‚ÄûBlog-Beitrag‚Äú identifizieren.

Anschlie√üend k√∂nnten Sie Berechtigungen f√ºr diese Entit√§t hinzuf√ºgen, etwa ‚ÄûFahren‚Äú (f√ºr das Auto) oder ‚ÄûBearbeiten‚Äú (f√ºr den Blog).

Und dann k√∂nnten Sie diesen JWT-Token einem Benutzer (oder Bot) geben und dieser k√∂nnte ihn verwenden, um diese Aktionen auszuf√ºhren (das Auto fahren oder den Blog-Beitrag bearbeiten), ohne dass er √ºberhaupt ein Konto haben m√ºsste, einfach mit dem JWT-Token, den Ihre API daf√ºr generiert hat.

Mit diesen Ideen kann JWT f√ºr weitaus anspruchsvollere Szenarien verwendet werden.

In diesen F√§llen k√∂nnten mehrere dieser Entit√§ten die gleiche ID haben, sagen wir `foo` (ein Benutzer `foo`, ein Auto `foo` und ein Blog-Beitrag `foo`).

Deshalb, um ID-Kollisionen zu vermeiden, k√∂nnten Sie beim Erstellen des JWT-Tokens f√ºr den Benutzer, dem Wert des `sub`-Schl√ºssels ein Pr√§fix, z. B. `username:` voranstellen. In diesem Beispiel h√§tte der Wert von `sub` also auch `username:johndoe` sein k√∂nnen.

Der wesentliche Punkt ist, dass der `sub`-Schl√ºssel in der gesamten Anwendung eine eindeutige Kennung haben sollte, und er sollte ein String sein.

## Es testen

F√ºhren Sie den Server aus und gehen Sie zur Dokumentation: <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

Die Benutzeroberfl√§che sieht wie folgt aus:

<img src="/img/tutorial/security/image07.png">

Melden Sie sich bei der Anwendung auf die gleiche Weise wie zuvor an.

Verwenden Sie die Anmeldeinformationen:

Benutzername: `johndoe`
Passwort: `secret`.

/// check

Beachten Sie, dass im Code nirgendwo das Klartext-Passwort "`secret`" steht, wir haben nur die gehashte Version.

///

<img src="/img/tutorial/security/image08.png">

Rufen Sie den Endpunkt `/users/me/` auf, Sie erhalten die Response:

```JSON
{
  "username": "johndoe",
  "email": "johndoe@example.com",
  "full_name": "John Doe",
  "disabled": false
}
```

<img src="/img/tutorial/security/image09.png">

Wenn Sie die Developer Tools √∂ffnen, k√∂nnen Sie sehen, dass die gesendeten Daten nur den Token enthalten. Das Passwort wird nur bei der ersten Anfrage gesendet, um den Benutzer zu authentisieren und diesen Zugriffstoken zu erhalten, aber nicht mehr danach:

<img src="/img/tutorial/security/image10.png">

/// note | Hinweis

Beachten Sie den Header `Authorization` mit einem Wert, der mit `Bearer` beginnt.

///

## Fortgeschrittene Verwendung mit `scopes`

OAuth2 hat ein Konzept von <abbr title="Geltungsbereiche">‚ÄûScopes‚Äú</abbr>.

Sie k√∂nnen diese verwenden, um einem JWT-Token einen bestimmten Satz von Berechtigungen zu √ºbergeben.

Anschlie√üend k√∂nnen Sie diesen Token einem Benutzer direkt oder einem Dritten geben, damit diese mit einer Reihe von Einschr√§nkungen mit Ihrer API interagieren k√∂nnen.

Wie Sie sie verwenden und wie sie in **FastAPI** integriert sind, erfahren Sie sp√§ter im **Handbuch f√ºr fortgeschrittene Benutzer**.

## Zusammenfassung

Mit dem, was Sie bis hier gesehen haben, k√∂nnen Sie eine sichere **FastAPI**-Anwendung mithilfe von Standards wie OAuth2 und JWT einrichten.

In fast jedem Framework wird die Handhabung der Sicherheit recht schnell zu einem ziemlich komplexen Thema.

Viele Packages, die es stark vereinfachen, m√ºssen viele Kompromisse beim Datenmodell, der Datenbank und den verf√ºgbaren Funktionen eingehen. Und einige dieser Pakete, die die Dinge zu sehr vereinfachen, weisen tats√§chlich Sicherheitsl√ºcken auf.

---

**FastAPI** geht bei keiner Datenbank, keinem Datenmodell oder Tool Kompromisse ein.

Es gibt Ihnen die volle Flexibilit√§t, diejenigen auszuw√§hlen, die am besten zu Ihrem Projekt passen.

Und Sie k√∂nnen viele gut gepflegte und weit verbreitete Packages wie `passlib` und `python-jose` direkt verwenden, da **FastAPI** keine komplexen Mechanismen zur Integration externer Pakete erfordert.

Aber es bietet Ihnen die Werkzeuge, um den Prozess so weit wie m√∂glich zu vereinfachen, ohne Kompromisse bei Flexibilit√§t, Robustheit oder Sicherheit einzugehen.

Und Sie k√∂nnen sichere Standardprotokolle wie OAuth2 auf relativ einfache Weise verwenden und implementieren.

Im **Handbuch f√ºr fortgeschrittene Benutzer** erfahren Sie mehr dar√ºber, wie Sie OAuth2-‚ÄûScopes‚Äú f√ºr ein feingranuliertes Berechtigungssystem verwenden, das denselben Standards folgt. OAuth2 mit Scopes ist der Mechanismus, der von vielen gro√üen Authentifizierungsanbietern wie Facebook, Google, GitHub, Microsoft, Twitter, usw. verwendet wird, um Drittanbieteranwendungen zu autorisieren, im Namen ihrer Benutzer mit ihren APIs zu interagieren.


================================================
File: /docs/de/docs/tutorial/security/simple-oauth2.md
================================================
# Einfaches OAuth2 mit Password und Bearer

Lassen Sie uns nun auf dem vorherigen Kapitel aufbauen und die fehlenden Teile hinzuf√ºgen, um einen vollst√§ndigen Sicherheits-Flow zu erhalten.

## `username` und `password` entgegennehmen

Wir werden **FastAPIs** Sicherheits-Werkzeuge verwenden, um den `username` und das `password` entgegenzunehmen.

OAuth2 spezifiziert, dass der Client/Benutzer bei Verwendung des ‚ÄûPassword Flow‚Äú (den wir verwenden) die Felder `username` und `password` als Formulardaten senden muss.

Und die Spezifikation sagt, dass die Felder so benannt werden m√ºssen. `user-name` oder `email` w√ºrde also nicht funktionieren.

Aber keine Sorge, Sie k√∂nnen sie Ihren Endbenutzern im Frontend so anzeigen, wie Sie m√∂chten.

Und Ihre Datenbankmodelle k√∂nnen beliebige andere Namen verwenden.

Aber f√ºr die Login-*Pfadoperation* m√ºssen wir diese Namen verwenden, um mit der Spezifikation kompatibel zu sein (und beispielsweise das integrierte API-Dokumentationssystem verwenden zu k√∂nnen).

Die Spezifikation besagt auch, dass `username` und `password` als Formulardaten gesendet werden m√ºssen (hier also kein JSON).

### <abbr title="Geltungsbereich">`scope`</abbr>

Ferner sagt die Spezifikation, dass der Client ein weiteres Formularfeld "`scope`" (‚ÄûGeltungsbereich‚Äú) senden kann.

Der Name des Formularfelds lautet `scope` (im Singular), tats√§chlich handelt es sich jedoch um einen langen String mit durch Leerzeichen getrennten ‚ÄûScopes‚Äú.

Jeder ‚ÄûScope‚Äú ist nur ein String (ohne Leerzeichen).

Diese werden normalerweise verwendet, um bestimmte Sicherheitsberechtigungen zu deklarieren, zum Beispiel:

* `users:read` oder `users:write` sind g√§ngige Beispiele.
* `instagram_basic` wird von Facebook / Instagram verwendet.
* `https://www.googleapis.com/auth/drive` wird von Google verwendet.

/// info

In OAuth2 ist ein ‚ÄûScope‚Äú nur ein String, der eine bestimmte erforderliche Berechtigung deklariert.

Es spielt keine Rolle, ob er andere Zeichen wie `:` enth√§lt oder ob es eine URL ist.

Diese Details sind implementierungsspezifisch.

F√ºr OAuth2 sind es einfach nur Strings.

///

## Code, um `username` und `password` entgegenzunehmen.

Lassen Sie uns nun die von **FastAPI** bereitgestellten Werkzeuge verwenden, um das zu erledigen.

### `OAuth2PasswordRequestForm`

Importieren Sie zun√§chst `OAuth2PasswordRequestForm` und verwenden Sie es als Abh√§ngigkeit mit `Depends` in der *Pfadoperation* f√ºr `/token`:

{* ../../docs_src/security/tutorial003_an_py310.py hl[4,78] *}

`OAuth2PasswordRequestForm` ist eine Klassenabh√§ngigkeit, die einen Formularbody deklariert mit:

* Dem `username`.
* Dem `password`.
* Einem optionalen `scope`-Feld als langem String, bestehend aus durch Leerzeichen getrennten Strings.
* Einem optionalen `grant_type` (‚ÄûArt der Anmeldung‚Äú).

/// tip | Tipp

Die OAuth2-Spezifikation *erfordert* tats√§chlich ein Feld `grant_type` mit dem festen Wert `password`, aber `OAuth2PasswordRequestForm` erzwingt dies nicht.

Wenn Sie es erzwingen m√ºssen, verwenden Sie `OAuth2PasswordRequestFormStrict` anstelle von `OAuth2PasswordRequestForm`.

///

* Eine optionale `client_id` (ben√∂tigen wir f√ºr unser Beispiel nicht).
* Ein optionales `client_secret` (ben√∂tigen wir f√ºr unser Beispiel nicht).

/// info

`OAuth2PasswordRequestForm` ist keine spezielle Klasse f√ºr **FastAPI**, so wie `OAuth2PasswordBearer`.

`OAuth2PasswordBearer` l√§sst **FastAPI** wissen, dass es sich um ein Sicherheitsschema handelt. Daher wird es auf diese Weise zu OpenAPI hinzugef√ºgt.

Aber `OAuth2PasswordRequestForm` ist nur eine Klassenabh√§ngigkeit, die Sie selbst h√§tten schreiben k√∂nnen, oder Sie h√§tten `Form`ular-Parameter direkt deklarieren k√∂nnen.

Da es sich jedoch um einen h√§ufigen Anwendungsfall handelt, wird er zur Vereinfachung direkt von **FastAPI** bereitgestellt.

///

### Die Formulardaten verwenden

/// tip | Tipp

Die Instanz der Klassenabh√§ngigkeit `OAuth2PasswordRequestForm` verf√ºgt, statt eines Attributs `scope` mit dem durch Leerzeichen getrennten langen String, √ºber das Attribut `scopes` mit einer tats√§chlichen Liste von Strings, einem f√ºr jeden gesendeten Scope.

In diesem Beispiel verwenden wir keine `scopes`, aber die Funktionalit√§t ist vorhanden, wenn Sie sie ben√∂tigen.

///

Rufen Sie nun die Benutzerdaten aus der (gefakten) Datenbank ab, f√ºr diesen `username` aus dem Formularfeld.

Wenn es keinen solchen Benutzer gibt, geben wir die Fehlermeldung ‚ÄûIncorrect username or password‚Äú zur√ºck.

F√ºr den Fehler verwenden wir die Exception `HTTPException`:

{* ../../docs_src/security/tutorial003_an_py310.py hl[3,79:81] *}

### Das Passwort √ºberpr√ºfen

Zu diesem Zeitpunkt liegen uns die Benutzerdaten aus unserer Datenbank vor, das Passwort haben wir jedoch noch nicht √ºberpr√ºft.

Lassen Sie uns diese Daten zun√§chst in das Pydantic-Modell `UserInDB` einf√ºgen.

Sie sollten niemals Klartext-Passw√∂rter speichern, daher verwenden wir ein (gefaktes) Passwort-Hashing-System.

Wenn die Passw√∂rter nicht √ºbereinstimmen, geben wir denselben Fehler zur√ºck.

#### Passwort-Hashing

‚ÄûHashing‚Äú bedeutet: Konvertieren eines Inhalts (in diesem Fall eines Passworts) in eine Folge von Bytes (ein schlichter String), die wie Kauderwelsch aussieht.

Immer wenn Sie genau den gleichen Inhalt (genau das gleiche Passwort) √ºbergeben, erhalten Sie genau den gleichen Kauderwelsch.

Sie k√∂nnen jedoch nicht vom Kauderwelsch zur√ºck zum Passwort konvertieren.

##### Warum Passwort-Hashing verwenden?

Wenn Ihre Datenbank gestohlen wird, hat der Dieb nicht die Klartext-Passw√∂rter Ihrer Benutzer, sondern nur die Hashes.

Der Dieb kann also nicht versuchen, die gleichen Passw√∂rter in einem anderen System zu verwenden (da viele Benutzer √ºberall das gleiche Passwort verwenden, w√§re dies gef√§hrlich).

{* ../../docs_src/security/tutorial003_an_py310.py hl[82:85] *}

#### √úber `**user_dict`

`UserInDB(**user_dict)` bedeutet:

*√úbergib die Schl√ºssel und Werte des `user_dict` direkt als Schl√ºssel-Wert-Argumente, √§quivalent zu:*

```Python
UserInDB(
    username = user_dict["username"],
    email = user_dict["email"],
    full_name = user_dict["full_name"],
    disabled = user_dict["disabled"],
    hashed_password = user_dict["hashed_password"],
)
```

/// info

Eine ausf√ºhrlichere Erkl√§rung von `**user_dict` finden Sie in [der Dokumentation f√ºr **Extra Modelle**](../extra-models.md#uber-user_indict){.internal-link target=_blank}.

///

## Den Token zur√ºckgeben

Die Response des `token`-Endpunkts muss ein JSON-Objekt sein.

Es sollte einen `token_type` haben. Da wir in unserem Fall ‚ÄûBearer‚Äú-Token verwenden, sollte der Token-Typ "`bearer`" sein.

Und es sollte einen `access_token` haben, mit einem String, der unseren Zugriffstoken enth√§lt.

In diesem einfachen Beispiel gehen wir einfach v√∂llig unsicher vor und geben denselben `username` wie der Token zur√ºck.

/// tip | Tipp

Im n√§chsten Kapitel sehen Sie eine wirklich sichere Implementierung mit Passwort-Hashing und <abbr title="JSON Web Tokens">JWT</abbr>-Tokens.

Aber konzentrieren wir uns zun√§chst auf die spezifischen Details, die wir ben√∂tigen.

///

{* ../../docs_src/security/tutorial003_an_py310.py hl[87] *}

/// tip | Tipp

Gem√§√ü der Spezifikation sollten Sie ein JSON mit einem `access_token` und einem `token_type` zur√ºckgeben, genau wie in diesem Beispiel.

Das m√ºssen Sie selbst in Ihrem Code tun und sicherstellen, dass Sie diese JSON-Schl√ºssel verwenden.

Es ist fast das Einzige, woran Sie denken m√ºssen, es selbst richtigzumachen und die Spezifikationen einzuhalten.

Den Rest erledigt **FastAPI** f√ºr Sie.

///

## Die Abh√§ngigkeiten aktualisieren

Jetzt werden wir unsere Abh√§ngigkeiten aktualisieren.

Wir m√∂chten den `current_user` *nur* erhalten, wenn dieser Benutzer aktiv ist.

Daher erstellen wir eine zus√§tzliche Abh√§ngigkeit `get_current_active_user`, die wiederum `get_current_user` als Abh√§ngigkeit verwendet.

Beide Abh√§ngigkeiten geben nur dann einen HTTP-Error zur√ºck, wenn der Benutzer nicht existiert oder inaktiv ist.

In unserem Endpunkt erhalten wir also nur dann einen Benutzer, wenn der Benutzer existiert, korrekt authentifiziert wurde und aktiv ist:

{* ../../docs_src/security/tutorial003_an_py310.py hl[58:66,69:74,94] *}

/// info

Der zus√§tzliche Header `WWW-Authenticate` mit dem Wert `Bearer`, den wir hier zur√ºckgeben, ist ebenfalls Teil der Spezifikation.

Jeder HTTP-(Fehler-)Statuscode 401 ‚ÄûUNAUTHORIZED‚Äú soll auch einen `WWW-Authenticate`-Header zur√ºckgeben.

Im Fall von Bearer-Tokens (in unserem Fall) sollte der Wert dieses Headers `Bearer` lauten.

Sie k√∂nnen diesen zus√§tzlichen Header tats√§chlich weglassen und es w√ºrde trotzdem funktionieren.

Aber er wird hier bereitgestellt, um den Spezifikationen zu entsprechen.

Au√üerdem gibt es m√∂glicherweise Tools, die ihn erwarten und verwenden (jetzt oder in der Zukunft) und das k√∂nnte f√ºr Sie oder Ihre Benutzer jetzt oder in der Zukunft n√ºtzlich sein.

Das ist der Vorteil von Standards ...

///

## Es in Aktion sehen

√ñffnen Sie die interaktive Dokumentation: <a href="http://127.0.0.1:8000/docs" class="external-link" target="_blank">http://127.0.0.1:8000/docs</a>.

### Authentifizieren

Klicken Sie auf den Button ‚ÄûAuthorize‚Äú.

Verwenden Sie die Anmeldedaten:

Benutzer: `johndoe`

Passwort: `secret`.

<img src="/img/tutorial/security/image04.png">

Nach der Authentifizierung im System sehen Sie Folgendes:

<img src="/img/tutorial/security/image05.png">

### Die eigenen Benutzerdaten ansehen

Verwenden Sie nun die Operation `GET` mit dem Pfad `/users/me`.

Sie erhalten Ihre Benutzerdaten:

```JSON
{
  "username": "johndoe",
  "email": "johndoe@example.com",
  "full_name": "John Doe",
  "disabled": false,
  "hashed_password": "fakehashedsecret"
}
```

<img src="/img/tutorial/security/image06.png">

Wenn Sie auf das Schlosssymbol klicken und sich abmelden und dann den gleichen Vorgang nochmal versuchen, erhalten Sie einen HTTP 401 Error:

```JSON
{
  "detail": "Not authenticated"
}
```

### Inaktiver Benutzer

Versuchen Sie es nun mit einem inaktiven Benutzer und authentisieren Sie sich mit:

Benutzer: `alice`.

Passwort: `secret2`.

Und versuchen Sie, die Operation `GET` mit dem Pfad `/users/me` zu verwenden.

Sie erhalten die Fehlermeldung ‚ÄûInactive user‚Äú:

```JSON
{
  "detail": "Inactive user"
}
```

## Zusammenfassung

Sie verf√ºgen jetzt √ºber die Tools, um ein vollst√§ndiges Sicherheitssystem basierend auf `username` und `password` f√ºr Ihre API zu implementieren.

Mit diesen Tools k√∂nnen Sie das Sicherheitssystem mit jeder Datenbank und jedem Benutzer oder Datenmodell kompatibel machen.

Das einzige fehlende Detail ist, dass es noch nicht wirklich ‚Äûsicher‚Äú ist.

Im n√§chsten Kapitel erfahren Sie, wie Sie eine sichere Passwort-Hashing-Bibliothek und <abbr title="JSON Web Tokens">JWT</abbr>-Token verwenden.


================================================
File: /docs/em/mkdocs.yml
================================================
INHERIT: ../en/mkdocs.yml


================================================
File: /docs/em/docs/alternatives.md
================================================
# üéõ, üåà &amp; üî∫

‚ö´Ô∏è‚ùî üòÆ **FastAPI**, ‚ùî ‚ö´Ô∏è üî¨ üéè üéõ &amp; ‚ö´Ô∏è‚ùî ‚ö´Ô∏è üá≠üá≤ ‚ö™Ô∏è‚û°Ô∏è üë´.

## üé∂

**FastAPI** üö´üîú üîÄ üö• üö´ ‚èÆÔ∏è üë∑ üéè.

üì§ ‚úîÔ∏è üìö üß∞ ‚úç ‚è≠ üëà ‚úîÔ∏è ‚Ñπ üòÆ üöÆ üèó.

üë§ ‚úîÔ∏è ‚ùé üèó üÜï üõ†Ô∏è üìö 1Ô∏è‚É£2Ô∏è‚É£üóìÔ∏è. ü•á üë§ üîÑ ‚ùé üåê ‚öí üìî **FastAPI** ‚öôÔ∏è üìö üéè üõ†Ô∏è, üîå-üîå, &amp; üß∞.

‚úãÔ∏è ‚òù, üì§ üôÖ‚Äç‚ôÇ üéè üéõ üåò üèó üï≥ üëà üöö üåê üë´ ‚öí, ‚úä üèÜ üí≠ ‚ö™Ô∏è‚û°Ô∏è ‚èÆÔ∏è üß∞, &amp; üåÄ üë´ üèÜ üåå üí™, ‚öôÔ∏è üá™üá∏ ‚öí üëà ‚ûñüö´ üí™ ‚è≠ (üêç 3Ô∏è‚É£.6Ô∏è‚É£ ‚ûï üÜé üîë).

## ‚èÆÔ∏è üß∞

### <a href="https://www.djangoproject.com/" class="external-link" target="_blank">‚ú≥</a>

‚ö´Ô∏è üåÖ üåü üêç üõ†Ô∏è &amp; üõé üï¥. ‚ö´Ô∏è ‚öôÔ∏è üèó ‚öôÔ∏è üíñ üë±üìî.

‚ö´Ô∏è üì∂ üòÜ üîó ‚èÆÔ∏è üîó üíΩ (üíñ ‚ú≥ ‚öñÔ∏è ‚ú≥),, ‚úîÔ∏è ‚òÅ üíΩ (üíñ üóÑ, ‚ú≥, üë∏, ‚ôíÔ∏è) üëë üè™ üöí üö´ üì∂ ‚è©.

‚ö´Ô∏è ‚úç üèó üï∏ üë©‚Äçüíª, üö´ ‚úç üîó ‚öôÔ∏è üèõ üï∏ (üíñ üò•, Vue.js &amp; üìê) ‚öñÔ∏è üéè ‚öôÔ∏è (üíñ <abbr title="Internet of Things">‚òÅ</abbr> üì≥) üîó ‚èÆÔ∏è ‚ö´Ô∏è.

### <a href="https://www.django-rest-framework.org/" class="external-link" target="_blank">‚ú≥ üéÇ üõ†Ô∏è</a>

‚ú≥ üéÇ üõ†Ô∏è ‚úç üóú üß∞ üèó üï∏ üîó ‚öôÔ∏è ‚ú≥ üîò, üìâ üöÆ üõ†Ô∏è üõ†Ô∏è.

‚ö´Ô∏è ‚öôÔ∏è üìö üè¢ ‚úÖ ü¶é, üü• üëí &amp; üéü.

‚ö´Ô∏è üïê ü•á üñº **üèß üõ†Ô∏è üßæ**, &amp; üëâ üéØ üïê ü•á üí≠ üëà üòÆ "üîé" **FastAPI**.

/// note

‚ú≥ üéÇ üõ†Ô∏è ‚úç ‚ú° üá∫üá∏üèõ. üéè üëº üíÉ &amp; Uvicorn, üîõ ‚ùî **FastAPI** ‚öìÔ∏è.

///

/// check | üòÆ **FastAPI**

‚úîÔ∏è üèß üõ†Ô∏è üßæ üï∏ üë©‚Äçüíª üî¢.

///

### <a href="https://flask.palletsprojects.com" class="external-link" target="_blank">üè∫</a>

üè∫ "üï∏", ‚ö´Ô∏è üö´ üîå üíΩ üõ†Ô∏è üö´ üìö üëú üëà üëü üî¢ ‚ú≥.

üëâ ü¶Å &amp; üí™ ‚úî üî® üëú üíñ ‚öôÔ∏è ‚òÅ üíΩ üëë üíΩ üíæ ‚öôÔ∏è.

‚ö´Ô∏è üì∂ üôÖ, ‚ö´Ô∏è üì∂ üèãÔ∏è üí°, üëê üßæ ü§ö üôÅ üì° ‚òù.

‚ö´Ô∏è üõé ‚öôÔ∏è üéè üà∏ üëà üö´ üéØ üí™ üíΩ, üë©‚Äçüíª üßæ, ‚öñÔ∏è üôÜ üìö ‚öí üëà üëü üè§-üèó ‚ú≥. üëê üìö üë´ ‚öí üí™ üöÆ ‚èÆÔ∏è üîå-üîå.

üëâ ‚öñ üçï, &amp; ‚ûñ "üï∏" üëà üí™ ‚Üî üìî ‚ö´Ô∏è‚ùî ‚ö´Ô∏è‚ùî üí™ üîë ‚öí üëà üë§ üíö üöß.

üëê ü¶Å üè∫, ‚ö´Ô∏è üòë üíñ üëç üèè üèó üîó. ‚è≠ üëú üîé "‚ú≥ üéÇ üõ†Ô∏è" üè∫.

/// check | üòÆ **FastAPI**

‚óæ-üõ†Ô∏è. ‚öí ‚ö´Ô∏è ‚è© üåÄ &amp; üèè üß∞ &amp; üçï üí™.

‚úîÔ∏è üôÖ &amp; ‚è© ‚öôÔ∏è üïπ ‚öôÔ∏è.

///

### <a href="https://requests.readthedocs.io" class="external-link" target="_blank">üì®</a>

**FastAPI** üö´ ü§ô üéõ **üì®**. üë´ ‚Üî üì∂ üéè.

‚ö´Ô∏è üîú ü§ô ‚ö† ‚öôÔ∏è üì® *üîò* FastAPI üà∏.

‚úãÔ∏è, FastAPI ü§ö üåà ‚ö™Ô∏è‚û°Ô∏è üì®.

**üì®** üóÉ *üîó* ‚èÆÔ∏è üîó (üë©‚Äçüíª), ‚è™ **FastAPI** üóÉ *üèó* üîó (üíΩ).

üë´, üåñ ‚öñÔ∏è üåò, üîÑ üîö, üîó üî† üéè.

üì® ‚úîÔ∏è üì∂ üôÖ &amp; üèãÔ∏è üîß, ‚ö´Ô∏è üì∂ ‚è© ‚öôÔ∏è, ‚èÆÔ∏è ü§î üî¢. ‚úãÔ∏è üéè üï∞, ‚ö´Ô∏è üì∂ üèãÔ∏è &amp; üõÉ.

üëà ‚ö´Ô∏è‚ùî, üí¨ üõÇ üï∏:

&gt; üì® 1Ô∏è‚É£ üèÜ ‚è¨ üêç üì¶ üåê üï∞

üåå üëÜ ‚öôÔ∏è ‚ö´Ô∏è üì∂ üôÖ. üñº, `GET` üì®, üëÜ üîú ‚úç:

```Python
response = requests.get("http://example.com/some/url")
```

FastAPI üòë üõ†Ô∏è *‚û° üõ†Ô∏è* üí™ üëÄ üíñ:

```Python hl_lines="1"
@app.get("/some/url")
def read_url():
    return {"message": "Hello World"}
```
